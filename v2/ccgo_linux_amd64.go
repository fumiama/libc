// Code generated for linux/amd64 by 'cc --package-name=libc --prefix-enumerator=_ --prefix-external=x_ --prefix-field=F --prefix-macro=m_ --prefix-static-internal=_ --prefix-static-none=_ --prefix-tagged-enum=_ --prefix-tagged-struct=T --prefix-tagged-union=T --prefix-typename=T --prefix-undefined=_ -exec-cc cc -extended-errors -ignore-asm-errors -ignore-unsupported-alignment -ignore-unsupported-atomic-sizes -hide a_inc,a_dec,a_swap,a_store,a_ctz_64,a_and_64,a_or_64,a_spin,a_fetch_add,a_cas_p -hide syscall0,syscall1,syscall2,syscall3,syscall4,syscall5,syscall6 -hide __pthread_self,sqrt,system -nostdlib -shared -o lib/libc.so.go src/conf/confstr.lo.go src/conf/fpathconf.lo.go src/conf/pathconf.lo.go src/conf/sysconf.lo.go src/ctype/__ctype_get_mb_cur_max.lo.go src/ctype/isalnum.lo.go src/ctype/isalpha.lo.go src/ctype/isascii.lo.go src/ctype/isblank.lo.go src/ctype/iscntrl.lo.go src/ctype/isdigit.lo.go src/ctype/isgraph.lo.go src/ctype/islower.lo.go src/ctype/isprint.lo.go src/ctype/ispunct.lo.go src/ctype/isspace.lo.go src/ctype/isupper.lo.go src/ctype/iswalnum.lo.go src/ctype/iswalpha.lo.go src/ctype/iswblank.lo.go src/ctype/iswcntrl.lo.go src/ctype/iswctype.lo.go src/ctype/iswdigit.lo.go src/ctype/iswgraph.lo.go src/ctype/iswlower.lo.go src/ctype/iswprint.lo.go src/ctype/iswpunct.lo.go src/ctype/iswspace.lo.go src/ctype/iswupper.lo.go src/ctype/iswxdigit.lo.go src/ctype/isxdigit.lo.go src/ctype/toascii.lo.go src/ctype/tolower.lo.go src/ctype/toupper.lo.go src/ctype/towctrans.lo.go src/ctype/wcswidth.lo.go src/ctype/wctrans.lo.go src/ctype/wcwidth.lo.go src/dirent/__getdents.lo.go src/dirent/alphasort.lo.go src/dirent/closedir.lo.go src/dirent/dirfd.lo.go src/dirent/fdopendir.lo.go src/dirent/opendir.lo.go src/dirent/readdir.lo.go src/dirent/readdir_r.lo.go src/dirent/rewinddir.lo.go src/dirent/scandir.lo.go src/dirent/seekdir.lo.go src/dirent/telldir.lo.go src/env/__environ.lo.go src/env/__libc_start_main.lo.go src/env/clearenv.lo.go src/env/getenv.lo.go src/env/putenv.lo.go src/env/setenv.lo.go src/env/unsetenv.lo.go src/errno/__errno_location.lo.go src/errno/strerror.lo.go src/exit/_Exit.lo.go src/exit/abort.lo.go src/exit/assert.lo.go src/exit/atexit.lo.go src/exit/exit.lo.go src/fcntl/creat.lo.go src/fcntl/fcntl.lo.go src/fcntl/open.lo.go src/fcntl/openat.lo.go src/internal/libc.lo.go src/internal/syscall.lo.go src/ipc/ftok.lo.go src/ipc/semctl.lo.go src/ipc/semget.lo.go src/ipc/semop.lo.go src/ipc/shmat.lo.go src/ipc/shmctl.lo.go src/ipc/shmdt.lo.go src/ipc/shmget.lo.go src/linux/brk.lo.go src/linux/chroot.lo.go src/linux/daemon.lo.go src/linux/epoll_create.lo.go src/linux/epoll_create1.lo.go src/linux/epoll_ctl.lo.go src/linux/epoll_pwait.lo.go src/linux/epoll_wait.lo.go src/linux/getdtablesize.lo.go src/linux/gethostid.lo.go src/linux/getopt_long.lo.go src/linux/getpagesize.lo.go src/linux/getpass.lo.go src/linux/initgroups.lo.go src/linux/klogctl.lo.go src/linux/mntent.lo.go src/linux/mount.lo.go src/linux/prctl.lo.go src/linux/reboot.lo.go src/linux/sbrk.lo.go src/linux/sendfile.lo.go src/linux/setgroups.lo.go src/linux/sethostname.lo.go src/linux/settimeofday.lo.go src/linux/signalfd.lo.go src/linux/stime.lo.go src/linux/swapoff.lo.go src/linux/swapon.lo.go src/linux/sysinfo.lo.go src/linux/umount.lo.go src/linux/umount2.lo.go src/linux/utimes.lo.go src/linux/wait3.lo.go src/linux/wait4.lo.go src/locale/catclose.lo.go src/locale/catgets.lo.go src/locale/catopen.lo.go src/locale/duplocale.lo.go src/locale/freelocale.lo.go src/locale/iconv.lo.go src/locale/intl.lo.go src/locale/isalnum_l.lo.go src/locale/isalpha_l.lo.go src/locale/isblank_l.lo.go src/locale/iscntrl_l.lo.go src/locale/isdigit_l.lo.go src/locale/isgraph_l.lo.go src/locale/islower_l.lo.go src/locale/isprint_l.lo.go src/locale/ispunct_l.lo.go src/locale/isspace_l.lo.go src/locale/isupper_l.lo.go src/locale/isxdigit_l.lo.go src/locale/langinfo.lo.go src/locale/localeconv.lo.go src/locale/newlocale.lo.go src/locale/nl_langinfo.lo.go src/locale/setlocale.lo.go src/locale/strcoll.lo.go src/locale/strxfrm.lo.go src/locale/tolower_l.lo.go src/locale/toupper_l.lo.go src/locale/wcscoll.lo.go src/locale/wcsxfrm.lo.go src/malloc/__brk.lo.go src/malloc/__simple_malloc.lo.go src/malloc/calloc.lo.go src/malloc/malloc.lo.go src/malloc/memalign.lo.go src/malloc/posix_memalign.lo.go src/math/__fpclassify.lo.go src/math/__fpclassifyf.lo.go src/math/__fpclassifyl.lo.go src/math/e_acos.lo.go src/math/e_acosf.lo.go src/math/e_acosh.lo.go src/math/e_acoshf.lo.go src/math/e_asin.lo.go src/math/e_asinf.lo.go src/math/e_atan2.lo.go src/math/e_atan2f.lo.go src/math/e_atanh.lo.go src/math/e_atanhf.lo.go src/math/e_cosh.lo.go src/math/e_coshf.lo.go src/math/e_exp.lo.go src/math/e_expf.lo.go src/math/e_fmod.lo.go src/math/e_fmodf.lo.go src/math/e_hypot.lo.go src/math/e_hypotf.lo.go src/math/e_log.lo.go src/math/e_log10.lo.go src/math/e_log10f.lo.go src/math/e_logf.lo.go src/math/e_pow.lo.go src/math/e_powf.lo.go src/math/e_rem_pio2.lo.go src/math/e_rem_pio2f.lo.go src/math/e_remainder.lo.go src/math/e_remainderf.lo.go src/math/e_scalb.lo.go src/math/e_scalbf.lo.go src/math/e_sinh.lo.go src/math/e_sinhf.lo.go src/math/k_cos.lo.go src/math/k_cosf.lo.go src/math/k_rem_pio2.lo.go src/math/k_rem_pio2f.lo.go src/math/k_sin.lo.go src/math/k_sinf.lo.go src/math/k_tan.lo.go src/math/k_tanf.lo.go src/math/s_asinh.lo.go src/math/s_asinhf.lo.go src/math/s_atan.lo.go src/math/s_atanf.lo.go src/math/s_cbrt.lo.go src/math/s_cbrtf.lo.go src/math/s_ceil.lo.go src/math/s_ceilf.lo.go src/math/s_copysign.lo.go src/math/s_copysignf.lo.go src/math/s_cos.lo.go src/math/s_cosf.lo.go src/math/s_erf.lo.go src/math/s_erff.lo.go src/math/s_expm1.lo.go src/math/s_expm1f.lo.go src/math/s_fabs.lo.go src/math/s_fabsf.lo.go src/math/s_floor.lo.go src/math/s_floorf.lo.go src/math/s_ilogb.lo.go src/math/s_ilogbf.lo.go src/math/s_ldexp.lo.go src/math/s_ldexpf.lo.go src/math/s_llrint.lo.go src/math/s_log1p.lo.go src/math/s_log1pf.lo.go src/math/s_logb.lo.go src/math/s_logbf.lo.go src/math/s_lrint.lo.go src/math/s_lrintf.lo.go src/math/s_modf.lo.go src/math/s_modff.lo.go src/math/s_nextafter.lo.go src/math/s_nextafterf.lo.go src/math/s_remquo.lo.go src/math/s_remquof.lo.go src/math/s_rint.lo.go src/math/s_rintf.lo.go src/math/s_round.lo.go src/math/s_roundf.lo.go src/math/s_scalbln.lo.go src/math/s_scalblnf.lo.go src/math/s_sin.lo.go src/math/s_sinf.lo.go src/math/s_tan.lo.go src/math/s_tanf.lo.go src/math/s_tanh.lo.go src/math/s_tanhf.lo.go src/math/s_trunc.lo.go src/math/s_truncf.lo.go src/misc/basename.lo.go src/misc/bswap_32.lo.go src/misc/bswap_64.lo.go src/misc/crypt.lo.go src/misc/cuserid.lo.go src/misc/dirname.lo.go src/misc/ffs.lo.go src/misc/ftw.lo.go src/misc/getdomainname.lo.go src/misc/getgrouplist.lo.go src/misc/getopt.lo.go src/misc/getpriority.lo.go src/misc/getrlimit.lo.go src/misc/getrusage.lo.go src/misc/getsubopt.lo.go src/misc/ioctl.lo.go src/misc/lockf.lo.go src/misc/nftw.lo.go src/misc/openpty.lo.go src/misc/pty.lo.go src/misc/realpath.lo.go src/misc/sched_yield.lo.go src/misc/setpriority.lo.go src/misc/setrlimit.lo.go src/misc/syslog.lo.go src/misc/uname.lo.go src/mman/madvise.lo.go src/mman/mlock.lo.go src/mman/mlockall.lo.go src/mman/mmap.lo.go src/mman/mprotect.lo.go src/mman/mremap.lo.go src/mman/msync.lo.go src/mman/munlock.lo.go src/mman/munlockall.lo.go src/mman/munmap.lo.go src/mman/posix_madvise.lo.go src/multibyte/btowc.lo.go src/multibyte/decode.lo.go src/multibyte/internal.lo.go src/multibyte/mblen.lo.go src/multibyte/mbrlen.lo.go src/multibyte/mbrtowc.lo.go src/multibyte/mbsinit.lo.go src/multibyte/mbsnrtowcs.lo.go src/multibyte/mbsrtowcs.lo.go src/multibyte/mbstowcs.lo.go src/multibyte/mbtowc.lo.go src/multibyte/wcrtomb.lo.go src/multibyte/wcsnrtombs.lo.go src/multibyte/wcsrtombs.lo.go src/multibyte/wcstombs.lo.go src/multibyte/wctob.lo.go src/multibyte/wctomb.lo.go src/network/__dns.lo.go src/network/__ipparse.lo.go src/network/accept.lo.go src/network/bind.lo.go src/network/connect.lo.go src/network/dn_expand.lo.go src/network/ent.lo.go src/network/freeaddrinfo.lo.go src/network/gai_strerror.lo.go src/network/getaddrinfo.lo.go src/network/gethostbyaddr.lo.go src/network/gethostbyaddr_r.lo.go src/network/gethostbyname.lo.go src/network/gethostbyname2.lo.go src/network/gethostbyname2_r.lo.go src/network/gethostbyname_r.lo.go src/network/getnameinfo.lo.go src/network/getpeername.lo.go src/network/getservbyname.lo.go src/network/getservbyname_r.lo.go src/network/getservbyport.lo.go src/network/getservbyport_r.lo.go src/network/getsockname.lo.go src/network/getsockopt.lo.go src/network/h_errno.lo.go src/network/hstrerror.lo.go src/network/htonl.lo.go src/network/htons.lo.go src/network/in6addr_any.lo.go src/network/in6addr_loopback.lo.go src/network/inet_addr.lo.go src/network/inet_aton.lo.go src/network/inet_ntoa.lo.go src/network/inet_ntop.lo.go src/network/inet_pton.lo.go src/network/listen.lo.go src/network/ntohl.lo.go src/network/ntohs.lo.go src/network/proto.lo.go src/network/recv.lo.go src/network/recvfrom.lo.go src/network/recvmsg.lo.go src/network/res_init.lo.go src/network/res_query.lo.go src/network/send.lo.go src/network/sendmsg.lo.go src/network/sendto.lo.go src/network/serv.lo.go src/network/setsockopt.lo.go src/network/shutdown.lo.go src/network/sockatmark.lo.go src/network/socket.lo.go src/network/socketpair.lo.go src/passwd/getgr_r.lo.go src/passwd/getgrent.lo.go src/passwd/getgrent_a.lo.go src/passwd/getpw_r.lo.go src/passwd/getpwent.lo.go src/passwd/getpwent_a.lo.go src/passwd/getspent.lo.go src/passwd/getspnam.lo.go src/passwd/getspnam_r.lo.go src/passwd/lckpwdf.lo.go src/prng/__rand48_step.lo.go src/prng/__seed48.lo.go src/prng/drand48.lo.go src/prng/lcong48.lo.go src/prng/lrand48.lo.go src/prng/mrand48.lo.go src/prng/rand.lo.go src/prng/rand_r.lo.go src/prng/random.lo.go src/prng/seed48.lo.go src/prng/srand48.lo.go src/prng/srandom.lo.go src/process/execl.lo.go src/process/execle.lo.go src/process/execlp.lo.go src/process/execv.lo.go src/process/execve.lo.go src/process/execvp.lo.go src/process/fork.lo.go src/process/system.lo.go src/process/vfork.lo.go src/process/wait.lo.go src/process/waitid.lo.go src/process/waitpid.lo.go src/regex/fnmatch.lo.go src/regex/glob.lo.go src/regex/regcomp.lo.go src/regex/regerror.lo.go src/regex/regexec.lo.go src/regex/tre-mem.lo.go src/select/poll.lo.go src/select/pselect.lo.go src/select/select.lo.go src/signal/getitimer.lo.go src/signal/kill.lo.go src/signal/killpg.lo.go src/signal/raise.lo.go src/signal/setitimer.lo.go src/signal/sigaction.lo.go src/signal/sigaddset.lo.go src/signal/sigaltstack.lo.go src/signal/sigdelset.lo.go src/signal/sigemptyset.lo.go src/signal/sigfillset.lo.go src/signal/sighold.lo.go src/signal/sigignore.lo.go src/signal/siginterrupt.lo.go src/signal/sigismember.lo.go src/signal/siglongjmp.lo.go src/signal/signal.lo.go src/signal/sigpause.lo.go src/signal/sigpending.lo.go src/signal/sigprocmask.lo.go src/signal/sigqueue.lo.go src/signal/sigrelse.lo.go src/signal/sigrtmax.lo.go src/signal/sigrtmin.lo.go src/signal/sigset.lo.go src/signal/sigsuspend.lo.go src/signal/sigtimedwait.lo.go src/signal/sigwait.lo.go src/signal/sigwaitinfo.lo.go src/stat/chmod.lo.go src/stat/fchmod.lo.go src/stat/fchmodat.lo.go src/stat/fstat.lo.go src/stat/fstatat.lo.go src/stat/fstatvfs.lo.go src/stat/lstat.lo.go src/stat/mkdir.lo.go src/stat/mkdirat.lo.go src/stat/mkfifo.lo.go src/stat/mkfifoat.lo.go src/stat/mknod.lo.go src/stat/mknodat.lo.go src/stat/stat.lo.go src/stat/statvfs.lo.go src/stat/umask.lo.go src/stdio/__fclose_ca.lo.go src/stdio/__fdopen.lo.go src/stdio/__fopen_rb_ca.lo.go src/stdio/__fpending.lo.go src/stdio/__ofl.lo.go src/stdio/__overflow.lo.go src/stdio/__scanf.lo.go src/stdio/__stdio_close.lo.go src/stdio/__stdio_read.lo.go src/stdio/__stdio_seek.lo.go src/stdio/__stdio_write.lo.go src/stdio/__uflow.lo.go src/stdio/__underflow.lo.go src/stdio/asprintf.lo.go src/stdio/clearerr.lo.go src/stdio/dprintf.lo.go src/stdio/fclose.lo.go src/stdio/feof.lo.go src/stdio/ferror.lo.go src/stdio/fflush.lo.go src/stdio/fgetc.lo.go src/stdio/fgetpos.lo.go src/stdio/fgets.lo.go src/stdio/fgetwc.lo.go src/stdio/fgetws.lo.go src/stdio/fileno.lo.go src/stdio/fmemopen.lo.go src/stdio/fopen.lo.go src/stdio/fprintf.lo.go src/stdio/fputc.lo.go src/stdio/fputs.lo.go src/stdio/fputwc.lo.go src/stdio/fputws.lo.go src/stdio/fread.lo.go src/stdio/freopen.lo.go src/stdio/fscanf.lo.go src/stdio/fseek.lo.go src/stdio/fsetpos.lo.go src/stdio/ftell.lo.go src/stdio/fwide.lo.go src/stdio/fwrite.lo.go src/stdio/fwscanf.lo.go src/stdio/getc.lo.go src/stdio/getc_unlocked.lo.go src/stdio/getchar.lo.go src/stdio/getchar_unlocked.lo.go src/stdio/getdelim.lo.go src/stdio/getline.lo.go src/stdio/gets.lo.go src/stdio/getw.lo.go src/stdio/getwc.lo.go src/stdio/getwchar.lo.go src/stdio/pclose.lo.go src/stdio/perror.lo.go src/stdio/popen.lo.go src/stdio/printf.lo.go src/stdio/putc.lo.go src/stdio/putc_unlocked.lo.go src/stdio/putchar.lo.go src/stdio/putchar_unlocked.lo.go src/stdio/puts.lo.go src/stdio/putw.lo.go src/stdio/putwc.lo.go src/stdio/putwchar.lo.go src/stdio/remove.lo.go src/stdio/rename.lo.go src/stdio/rewind.lo.go src/stdio/scanf.lo.go src/stdio/setbuf.lo.go src/stdio/setvbuf.lo.go src/stdio/snprintf.lo.go src/stdio/sprintf.lo.go src/stdio/sscanf.lo.go src/stdio/stderr.lo.go src/stdio/stdin.lo.go src/stdio/stdout.lo.go src/stdio/swscanf.lo.go src/stdio/tempnam.lo.go src/stdio/tmpfile.lo.go src/stdio/tmpnam.lo.go src/stdio/ungetc.lo.go src/stdio/ungetwc.lo.go src/stdio/vasprintf.lo.go src/stdio/vdprintf.lo.go src/stdio/vfprintf.lo.go src/stdio/vfscanf.lo.go src/stdio/vfwscanf.lo.go src/stdio/vprintf.lo.go src/stdio/vscanf.lo.go src/stdio/vsnprintf.lo.go src/stdio/vsprintf.lo.go src/stdio/vsscanf.lo.go src/stdio/vswscanf.lo.go src/stdio/vwscanf.lo.go src/stdio/wscanf.lo.go src/stdlib/abs.lo.go src/stdlib/atof.lo.go src/stdlib/atoi.lo.go src/stdlib/atol.lo.go src/stdlib/atoll.lo.go src/stdlib/bsearch.lo.go src/stdlib/div.lo.go src/stdlib/frexp.lo.go src/stdlib/frexpf.lo.go src/stdlib/frexpl.lo.go src/stdlib/imaxabs.lo.go src/stdlib/imaxdiv.lo.go src/stdlib/labs.lo.go src/stdlib/ldiv.lo.go src/stdlib/llabs.lo.go src/stdlib/lldiv.lo.go src/stdlib/qsort.lo.go src/stdlib/strtod.lo.go src/stdlib/strtof.lo.go src/stdlib/strtoimax.lo.go src/stdlib/strtol.lo.go src/stdlib/strtold.lo.go src/stdlib/strtoll.lo.go src/stdlib/strtoul.lo.go src/stdlib/strtoull.lo.go src/stdlib/strtoumax.lo.go src/stdlib/wcstoimax.lo.go src/stdlib/wcstol.lo.go src/stdlib/wcstoll.lo.go src/stdlib/wcstoul.lo.go src/stdlib/wcstoull.lo.go src/stdlib/wcstoumax.lo.go src/string/bcmp.lo.go src/string/bcopy.lo.go src/string/bzero.lo.go src/string/index.lo.go src/string/memchr.lo.go src/string/memcmp.lo.go src/string/memcpy.lo.go src/string/memmove.lo.go src/string/mempcpy.lo.go src/string/memset.lo.go src/string/rindex.lo.go src/string/stpcpy.lo.go src/string/stpncpy.lo.go src/string/strcasecmp.lo.go src/string/strcasestr.lo.go src/string/strcat.lo.go src/string/strchr.lo.go src/string/strchrnul.lo.go src/string/strcmp.lo.go src/string/strcpy.lo.go src/string/strcspn.lo.go src/string/strdup.lo.go src/string/strerror_r.lo.go src/string/strlcat.lo.go src/string/strlcpy.lo.go src/string/strlen.lo.go src/string/strncasecmp.lo.go src/string/strncat.lo.go src/string/strncmp.lo.go src/string/strncpy.lo.go src/string/strndup.lo.go src/string/strnlen.lo.go src/string/strpbrk.lo.go src/string/strrchr.lo.go src/string/strsep.lo.go src/string/strsignal.lo.go src/string/strspn.lo.go src/string/strstr.lo.go src/string/strtok.lo.go src/string/strtok_r.lo.go src/string/swab.lo.go src/string/wcscat.lo.go src/string/wcschr.lo.go src/string/wcscmp.lo.go src/string/wcscpy.lo.go src/string/wcscspn.lo.go src/string/wcslen.lo.go src/string/wcsncat.lo.go src/string/wcsncmp.lo.go src/string/wcsncpy.lo.go src/string/wcspbrk.lo.go src/string/wcsrchr.lo.go src/string/wcsspn.lo.go src/string/wcsstr.lo.go src/string/wcswcs.lo.go src/string/wmemchr.lo.go src/string/wmemcmp.lo.go src/string/wmemcpy.lo.go src/string/wmemmove.lo.go src/string/wmemset.lo.go src/stub/utmpx.lo.go src/temp/mkdtemp.lo.go src/temp/mkstemp.lo.go src/temp/mktemp.lo.go src/termios/cfgetospeed.lo.go src/termios/cfsetospeed.lo.go src/termios/tcdrain.lo.go src/termios/tcflow.lo.go src/termios/tcflush.lo.go src/termios/tcgetattr.lo.go src/termios/tcgetsid.lo.go src/termios/tcsendbreak.lo.go src/termios/tcsetattr.lo.go src/thread/__futex.lo.go src/thread/__lock.lo.go src/thread/__timedwait.lo.go src/thread/__wait.lo.go src/thread/__wake.lo.go src/thread/cancellation.lo.go src/thread/pthread_attr_destroy.lo.go src/thread/pthread_attr_getdetachstate.lo.go src/thread/pthread_attr_getguardsize.lo.go src/thread/pthread_attr_getscope.lo.go src/thread/pthread_attr_getstacksize.lo.go src/thread/pthread_attr_init.lo.go src/thread/pthread_attr_setdetachstate.lo.go src/thread/pthread_attr_setguardsize.lo.go src/thread/pthread_attr_setscope.lo.go src/thread/pthread_attr_setstacksize.lo.go src/thread/pthread_barrier_destroy.lo.go src/thread/pthread_barrier_init.lo.go src/thread/pthread_barrier_wait.lo.go src/thread/pthread_cancel.lo.go src/thread/pthread_cond_broadcast.lo.go src/thread/pthread_cond_destroy.lo.go src/thread/pthread_cond_init.lo.go src/thread/pthread_cond_signal.lo.go src/thread/pthread_cond_timedwait.lo.go src/thread/pthread_cond_wait.lo.go src/thread/pthread_create.lo.go src/thread/pthread_detach.lo.go src/thread/pthread_equal.lo.go src/thread/pthread_getspecific.lo.go src/thread/pthread_join.lo.go src/thread/pthread_key_create.lo.go src/thread/pthread_key_delete.lo.go src/thread/pthread_kill.lo.go src/thread/pthread_mutex_destroy.lo.go src/thread/pthread_mutex_init.lo.go src/thread/pthread_mutex_lock.lo.go src/thread/pthread_mutex_timedlock.lo.go src/thread/pthread_mutex_trylock.lo.go src/thread/pthread_mutex_unlock.lo.go src/thread/pthread_mutexattr_destroy.lo.go src/thread/pthread_mutexattr_gettype.lo.go src/thread/pthread_mutexattr_init.lo.go src/thread/pthread_mutexattr_settype.lo.go src/thread/pthread_once.lo.go src/thread/pthread_rwlock_destroy.lo.go src/thread/pthread_rwlock_init.lo.go src/thread/pthread_rwlock_rdlock.lo.go src/thread/pthread_rwlock_timedrdlock.lo.go src/thread/pthread_rwlock_timedwrlock.lo.go src/thread/pthread_rwlock_tryrdlock.lo.go src/thread/pthread_rwlock_trywrlock.lo.go src/thread/pthread_rwlock_unlock.lo.go src/thread/pthread_rwlock_wrlock.lo.go src/thread/pthread_self.lo.go src/thread/pthread_setcancelstate.lo.go src/thread/pthread_setcanceltype.lo.go src/thread/pthread_setspecific.lo.go src/thread/pthread_spin_destroy.lo.go src/thread/pthread_spin_init.lo.go src/thread/pthread_spin_lock.lo.go src/thread/pthread_spin_trylock.lo.go src/thread/pthread_spin_unlock.lo.go src/thread/pthread_testcancel.lo.go src/time/__asctime.lo.go src/time/__time_to_tm.lo.go src/time/__tm_to_time.lo.go src/time/asctime.lo.go src/time/asctime_r.lo.go src/time/clock.lo.go src/time/clock_gettime.lo.go src/time/ctime.lo.go src/time/ctime_r.lo.go src/time/difftime.lo.go src/time/gettimeofday.lo.go src/time/gmtime.lo.go src/time/gmtime_r.lo.go src/time/localtime.lo.go src/time/localtime_r.lo.go src/time/mktime.lo.go src/time/nanosleep.lo.go src/time/strftime.lo.go src/time/strptime.lo.go src/time/time.lo.go src/time/times.lo.go src/time/tzset.lo.go src/time/utime.lo.go src/unistd/_exit.lo.go src/unistd/access.lo.go src/unistd/alarm.lo.go src/unistd/chdir.lo.go src/unistd/chown.lo.go src/unistd/close.lo.go src/unistd/ctermid.lo.go src/unistd/dup.lo.go src/unistd/dup2.lo.go src/unistd/faccessat.lo.go src/unistd/fchdir.lo.go src/unistd/fchown.lo.go src/unistd/fchownat.lo.go src/unistd/fdatasync.lo.go src/unistd/fsync.lo.go src/unistd/ftruncate.lo.go src/unistd/getcwd.lo.go src/unistd/getegid.lo.go src/unistd/geteuid.lo.go src/unistd/getgid.lo.go src/unistd/getgroups.lo.go src/unistd/gethostname.lo.go src/unistd/getlogin.lo.go src/unistd/getlogin_r.lo.go src/unistd/getpgid.lo.go src/unistd/getpgrp.lo.go src/unistd/getpid.lo.go src/unistd/getppid.lo.go src/unistd/getsid.lo.go src/unistd/getuid.lo.go src/unistd/isatty.lo.go src/unistd/lchown.lo.go src/unistd/link.lo.go src/unistd/linkat.lo.go src/unistd/lseek.lo.go src/unistd/nice.lo.go src/unistd/pause.lo.go src/unistd/pipe.lo.go src/unistd/pread.lo.go src/unistd/pwrite.lo.go src/unistd/read.lo.go src/unistd/readlink.lo.go src/unistd/readlinkat.lo.go src/unistd/readv.lo.go src/unistd/renameat.lo.go src/unistd/rmdir.lo.go src/unistd/setegid.lo.go src/unistd/seteuid.lo.go src/unistd/setgid.lo.go src/unistd/setpgid.lo.go src/unistd/setpgrp.lo.go src/unistd/setregid.lo.go src/unistd/setreuid.lo.go src/unistd/setsid.lo.go src/unistd/setuid.lo.go src/unistd/sleep.lo.go src/unistd/symlink.lo.go src/unistd/symlinkat.lo.go src/unistd/sync.lo.go src/unistd/tcgetpgrp.lo.go src/unistd/tcsetpgrp.lo.go src/unistd/truncate.lo.go src/unistd/ttyname.lo.go src/unistd/ttyname_r.lo.go src/unistd/ualarm.lo.go src/unistd/unlink.lo.go src/unistd/unlinkat.lo.go src/unistd/usleep.lo.go src/unistd/write.lo.go src/unistd/writev.lo.go', DO NOT EDIT..

//go:build linux && amd64
// +build linux,amd64

package libc

import (
	"reflect"
	"unsafe"
)

var (
	_ reflect.Type
	_ unsafe.Pointer
)

const m_EINVAL = 22
const m__CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116

type T__builtin_va_list = uintptr

type T__predefined_size_t = uint64

type T__predefined_wchar_t = int32

type T__predefined_ptrdiff_t = int64

type Tsize_t = uint64

type Tssize_t = int64

type Tintptr_t = int64

type Tuseconds_t = int64

type Tpid_t = int32

type Tuid_t = uint32

type Tgid_t = uint32

type Toff_t = int64

type Tva_list = uintptr

type Tfpos_t = struct {
	F__align  [0]float64
	F__opaque [16]int8
}

func x_confstr(tls *TLS, name int32, buf uintptr, len1 uint64) (r uint64) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	var s uintptr
	s = ts
	if !(name != 0) {
		s = ts + 1
	} else if uint32(name) & ^Uint32FromUint32(4) != uint32(1) && uint32(name-int32(m__CS_POSIX_V6_ILP32_OFF32_CFLAGS)) > uint32(31) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uint64(0)
	}
	// snprintf is overkill but avoid wasting code size to implement
	// this completely useless function and its truncation semantics
	return uint64(x_snprintf(tls, buf, len1, ts+15, VaList(bp+8, s)))
}

const m_NAME_MAX = 255
const m_PAGESIZE = 4096
const m_PATH_MAX = 4096
const m_PIPE_BUF = 4096
const m_SYMLINK_MAX = 255
const m__PC_2_SYMLINKS = 20
const m__PC_ALLOC_SIZE_MIN = 18
const m__PC_ASYNC_IO = 10
const m__PC_CHOWN_RESTRICTED = 6
const m__PC_FILESIZEBITS = 13
const m__PC_LINK_MAX = 0
const m__PC_MAX_CANON = 1
const m__PC_MAX_INPUT = 2
const m__PC_NAME_MAX = 3
const m__PC_NO_TRUNC = 7
const m__PC_PATH_MAX = 4
const m__PC_PIPE_BUF = 5
const m__PC_PRIO_IO = 11
const m__PC_REC_INCR_XFER_SIZE = 14
const m__PC_REC_MAX_XFER_SIZE = 15
const m__PC_REC_MIN_XFER_SIZE = 16
const m__PC_REC_XFER_ALIGN = 17
const m__PC_SOCK_MAXBUF = 12
const m__PC_SYMLINK_MAX = 19
const m__PC_SYNC_IO = 9
const m__PC_VDISABLE = 8
const m__POSIX_LINK_MAX = 8
const m__POSIX_MAX_CANON = 255
const m__POSIX_MAX_INPUT = 255

func x_fpathconf(tls *TLS, fd int32, name int32) (r int64) {
	if uint64(name) > Uint64FromInt64(42)/Uint64FromInt64(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	}
	return int64(_values[name])
}

var _values = [21]int16{
	0:  int16(m__POSIX_LINK_MAX),
	1:  int16(m__POSIX_MAX_CANON),
	2:  int16(m__POSIX_MAX_INPUT),
	3:  int16(m_NAME_MAX),
	4:  int16(m_PATH_MAX),
	5:  int16(m_PIPE_BUF),
	6:  int16(1),
	7:  int16(1),
	8:  0,
	9:  0,
	10: 0,
	11: 0,
	12: int16(-int32(1)),
	13: int16(8),
	14: int16(m_PAGESIZE),
	15: int16(m_PAGESIZE),
	16: int16(m_PAGESIZE),
	17: int16(m_PAGESIZE),
	18: int16(m_PAGESIZE),
	19: int16(m_SYMLINK_MAX),
	20: int16(1)}

func x_pathconf(tls *TLS, path uintptr, name int32) (r int64) {
	return x_fpathconf(tls, -int32(1), name)
}

const m_ARG_MAX = 131072
const m_COLL_WEIGHTS_MAX = 2
const m_HOST_NAME_MAX = 255
const m_IOV_MAX = 1024
const m_NZERO = 20
const m_RE_DUP_MAX = 255
const m_SYMLOOP_MAX = 40
const m_TTY_NAME_MAX = 20
const m_TZNAME_MAX = 6
const m__POSIX2_BC_BASE_MAX = 99
const m__POSIX2_BC_DIM_MAX = 2048
const m__POSIX2_BC_SCALE_MAX = 99
const m__POSIX2_BC_STRING_MAX = 1000
const m__POSIX_DELAYTIMER_MAX = 32
const m__POSIX_MQ_PRIO_MAX = 32
const m__POSIX_SEM_NSEMS_MAX = 256
const m__POSIX_SEM_VALUE_MAX = 32767
const m__POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
const m__POSIX_VERSION = 200809
const m__SC_2_CHAR_TERM = 95
const m__SC_2_C_BIND = 47
const m__SC_2_C_DEV = 48
const m__SC_2_C_VERSION = 96
const m__SC_2_FORT_DEV = 49
const m__SC_2_FORT_RUN = 50
const m__SC_2_LOCALEDEF = 52
const m__SC_2_PBS = 168
const m__SC_2_PBS_ACCOUNTING = 169
const m__SC_2_PBS_CHECKPOINT = 175
const m__SC_2_PBS_LOCATE = 170
const m__SC_2_PBS_MESSAGE = 171
const m__SC_2_PBS_TRACK = 172
const m__SC_2_SW_DEV = 51
const m__SC_2_UPE = 97
const m__SC_2_VERSION = 46
const m__SC_ADVISORY_INFO = 132
const m__SC_AIO_LISTIO_MAX = 23
const m__SC_AIO_MAX = 24
const m__SC_AIO_PRIO_DELTA_MAX = 25
const m__SC_ARG_MAX = 0
const m__SC_ASYNCHRONOUS_IO = 12
const m__SC_ATEXIT_MAX = 87
const m__SC_AVPHYS_PAGES = 86
const m__SC_BARRIERS = 133
const m__SC_BASE = 134
const m__SC_BC_BASE_MAX = 36
const m__SC_BC_DIM_MAX = 37
const m__SC_BC_SCALE_MAX = 38
const m__SC_BC_STRING_MAX = 39
const m__SC_CHARCLASS_NAME_MAX = 45
const m__SC_CHAR_BIT = 101
const m__SC_CHAR_MAX = 102
const m__SC_CHAR_MIN = 103
const m__SC_CHILD_MAX = 1
const m__SC_CLK_TCK = 2
const m__SC_CLOCK_SELECTION = 137
const m__SC_COLL_WEIGHTS_MAX = 40
const m__SC_CPUTIME = 138
const m__SC_C_LANG_SUPPORT = 135
const m__SC_C_LANG_SUPPORT_R = 136
const m__SC_DELAYTIMER_MAX = 26
const m__SC_DEVICE_IO = 140
const m__SC_DEVICE_SPECIFIC = 141
const m__SC_DEVICE_SPECIFIC_R = 142
const m__SC_EQUIV_CLASS_MAX = 41
const m__SC_EXPR_NEST_MAX = 42
const m__SC_FD_MGMT = 143
const m__SC_FIFO = 144
const m__SC_FILE_ATTRIBUTES = 146
const m__SC_FILE_LOCKING = 147
const m__SC_FILE_SYSTEM = 148
const m__SC_FSYNC = 15
const m__SC_GETGR_R_SIZE_MAX = 69
const m__SC_GETPW_R_SIZE_MAX = 70
const m__SC_HOST_NAME_MAX = 180
const m__SC_INT_MAX = 104
const m__SC_INT_MIN = 105
const m__SC_IOV_MAX = 60
const m__SC_IPV6 = 235
const m__SC_JOB_CONTROL = 7
const m__SC_LINE_MAX = 43
const m__SC_LOGIN_NAME_MAX = 71
const m__SC_LONG_BIT = 106
const m__SC_MAPPED_FILES = 16
const m__SC_MB_LEN_MAX = 108
const m__SC_MEMLOCK = 17
const m__SC_MEMLOCK_RANGE = 18
const m__SC_MEMORY_PROTECTION = 19
const m__SC_MESSAGE_PASSING = 20
const m__SC_MONOTONIC_CLOCK = 149
const m__SC_MQ_OPEN_MAX = 27
const m__SC_MQ_PRIO_MAX = 28
const m__SC_MULTI_PROCESS = 150
const m__SC_NETWORKING = 152
const m__SC_NGROUPS_MAX = 3
const m__SC_NL_ARGMAX = 119
const m__SC_NL_LANGMAX = 120
const m__SC_NL_MSGMAX = 121
const m__SC_NL_NMAX = 122
const m__SC_NL_SETMAX = 123
const m__SC_NL_TEXTMAX = 124
const m__SC_NPROCESSORS_CONF = 83
const m__SC_NPROCESSORS_ONLN = 84
const m__SC_NZERO = 109
const m__SC_OPEN_MAX = 4
const m__SC_PAGE_SIZE = 30
const m__SC_PASS_MAX = 88
const m__SC_PHYS_PAGES = 85
const m__SC_PII = 53
const m__SC_PII_INTERNET = 56
const m__SC_PII_INTERNET_DGRAM = 62
const m__SC_PII_INTERNET_STREAM = 61
const m__SC_PII_OSI = 57
const m__SC_PII_OSI_CLTS = 64
const m__SC_PII_OSI_COTS = 63
const m__SC_PII_OSI_M = 65
const m__SC_PII_SOCKET = 55
const m__SC_PII_XTI = 54
const m__SC_PIPE = 145
const m__SC_POLL = 58
const m__SC_PRIORITIZED_IO = 13
const m__SC_PRIORITY_SCHEDULING = 10
const m__SC_RAW_SOCKETS = 236
const m__SC_READER_WRITER_LOCKS = 153
const m__SC_REALTIME_SIGNALS = 9
const m__SC_REGEXP = 155
const m__SC_REGEX_VERSION = 156
const m__SC_RE_DUP_MAX = 44
const m__SC_RTSIG_MAX = 31
const m__SC_SAVED_IDS = 8
const m__SC_SCHAR_MAX = 111
const m__SC_SCHAR_MIN = 112
const m__SC_SELECT = 59
const m__SC_SEMAPHORES = 21
const m__SC_SEM_NSEMS_MAX = 32
const m__SC_SEM_VALUE_MAX = 33
const m__SC_SHARED_MEMORY_OBJECTS = 22
const m__SC_SHELL = 157
const m__SC_SHRT_MAX = 113
const m__SC_SHRT_MIN = 114
const m__SC_SIGNALS = 158
const m__SC_SIGQUEUE_MAX = 34
const m__SC_SINGLE_PROCESS = 151
const m__SC_SPAWN = 159
const m__SC_SPIN_LOCKS = 154
const m__SC_SPORADIC_SERVER = 160
const m__SC_SSIZE_MAX = 110
const m__SC_SS_REPL_MAX = 241
const m__SC_STREAMS = 174
const m__SC_STREAM_MAX = 5
const m__SC_SYMLOOP_MAX = 173
const m__SC_SYNCHRONIZED_IO = 14
const m__SC_SYSTEM_DATABASE = 162
const m__SC_SYSTEM_DATABASE_R = 163
const m__SC_THREADS = 67
const m__SC_THREAD_ATTR_STACKADDR = 77
const m__SC_THREAD_ATTR_STACKSIZE = 78
const m__SC_THREAD_CPUTIME = 139
const m__SC_THREAD_DESTRUCTOR_ITERATIONS = 73
const m__SC_THREAD_KEYS_MAX = 74
const m__SC_THREAD_PRIORITY_SCHEDULING = 79
const m__SC_THREAD_PRIO_INHERIT = 80
const m__SC_THREAD_PRIO_PROTECT = 81
const m__SC_THREAD_PROCESS_SHARED = 82
const m__SC_THREAD_ROBUST_PRIO_INHERIT = 247
const m__SC_THREAD_ROBUST_PRIO_PROTECT = 248
const m__SC_THREAD_SAFE_FUNCTIONS = 68
const m__SC_THREAD_SPORADIC_SERVER = 161
const m__SC_THREAD_STACK_MIN = 75
const m__SC_THREAD_THREADS_MAX = 76
const m__SC_TIMEOUTS = 164
const m__SC_TIMERS = 11
const m__SC_TIMER_MAX = 35
const m__SC_TRACE = 181
const m__SC_TRACE_EVENT_FILTER = 182
const m__SC_TRACE_EVENT_NAME_MAX = 242
const m__SC_TRACE_INHERIT = 183
const m__SC_TRACE_LOG = 184
const m__SC_TRACE_NAME_MAX = 243
const m__SC_TRACE_SYS_MAX = 244
const m__SC_TRACE_USER_EVENT_MAX = 245
const m__SC_TTY_NAME_MAX = 72
const m__SC_TYPED_MEMORY_OBJECTS = 165
const m__SC_TZNAME_MAX = 6
const m__SC_T_IOV_MAX = 66
const m__SC_UCHAR_MAX = 115
const m__SC_UINT_MAX = 116
const m__SC_ULONG_MAX = 117
const m__SC_USER_GROUPS = 166
const m__SC_USER_GROUPS_R = 167
const m__SC_USHRT_MAX = 118
const m__SC_V6_ILP32_OFF32 = 176
const m__SC_V6_ILP32_OFFBIG = 177
const m__SC_V6_LP64_OFF64 = 178
const m__SC_V6_LPBIG_OFFBIG = 179
const m__SC_V7_ILP32_OFF32 = 237
const m__SC_V7_ILP32_OFFBIG = 238
const m__SC_V7_LP64_OFF64 = 239
const m__SC_V7_LPBIG_OFFBIG = 240
const m__SC_VERSION = 29
const m__SC_WORD_BIT = 107
const m__SC_XBS5_ILP32_OFF32 = 125
const m__SC_XBS5_ILP32_OFFBIG = 126
const m__SC_XBS5_LP64_OFF64 = 127
const m__SC_XBS5_LPBIG_OFFBIG = 128
const m__SC_XOPEN_CRYPT = 92
const m__SC_XOPEN_ENH_I18N = 93
const m__SC_XOPEN_LEGACY = 129
const m__SC_XOPEN_REALTIME = 130
const m__SC_XOPEN_REALTIME_THREADS = 131
const m__SC_XOPEN_SHM = 94
const m__SC_XOPEN_STREAMS = 246
const m__SC_XOPEN_UNIX = 91
const m__SC_XOPEN_VERSION = 89
const m__SC_XOPEN_XCU_VERSION = 90
const m__SC_XOPEN_XPG2 = 98
const m__SC_XOPEN_XPG3 = 99
const m__SC_XOPEN_XPG4 = 100
const m__XOPEN_VERSION = 700

func x_sysconf(tls *TLS, name int32) (r int64) {
	if uint64(name) > Uint64FromInt64(498)/Uint64FromInt64(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	} else {
		if int32(_values1[name]) == -int32(2) {
			return int64(200809)
		} else {
			if int32(_values1[name]) == -int32(3) {
				return int64(m_ARG_MAX)
			} else {
				return int64(_values1[name])
			}
		}
	}
	return r
}

var _values1 = [249]int16{
	0:   int16(-Int32FromInt32(3)),
	1:   int16(-int32(1)),
	2:   int16(100),
	3:   int16(32),
	4:   int16(1024),
	5:   int16(-int32(1)),
	6:   int16(m_TZNAME_MAX),
	7:   int16(1),
	8:   int16(1),
	9:   int16(1),
	10:  int16(-int32(1)),
	11:  int16(-Int32FromInt32(2)),
	12:  int16(-Int32FromInt32(2)),
	13:  int16(-int32(1)),
	14:  int16(-int32(1)),
	15:  int16(-int32(1)),
	16:  int16(-Int32FromInt32(2)),
	17:  int16(-Int32FromInt32(2)),
	18:  int16(-Int32FromInt32(2)),
	19:  int16(-Int32FromInt32(2)),
	20:  int16(-int32(1)),
	21:  int16(-Int32FromInt32(2)),
	22:  int16(-int32(1)),
	23:  int16(-int32(1)),
	24:  int16(-int32(1)),
	25:  0,
	26:  int16(m__POSIX_DELAYTIMER_MAX),
	27:  int16(-int32(1)),
	28:  int16(m__POSIX_MQ_PRIO_MAX),
	29:  int16(-Int32FromInt32(2)),
	30:  int16(m_PAGESIZE),
	31:  int16(63),
	32:  int16(m__POSIX_SEM_NSEMS_MAX),
	33:  int16(m__POSIX_SEM_VALUE_MAX),
	34:  int16(-int32(1)),
	35:  int16(-int32(1)),
	36:  int16(m__POSIX2_BC_BASE_MAX),
	37:  int16(m__POSIX2_BC_DIM_MAX),
	38:  int16(m__POSIX2_BC_SCALE_MAX),
	39:  int16(m__POSIX2_BC_STRING_MAX),
	40:  int16(m_COLL_WEIGHTS_MAX),
	41:  int16(-int32(1)),
	42:  int16(-int32(1)),
	43:  int16(-int32(1)),
	44:  int16(m_RE_DUP_MAX),
	45:  int16(-int32(1)),
	46:  int16(-Int32FromInt32(2)),
	47:  int16(-Int32FromInt32(2)),
	48:  int16(-int32(1)),
	49:  int16(-int32(1)),
	50:  int16(-int32(1)),
	51:  int16(-int32(1)),
	52:  int16(-int32(1)),
	53:  int16(-int32(1)),
	54:  int16(-int32(1)),
	55:  int16(-int32(1)),
	56:  int16(-int32(1)),
	57:  int16(-int32(1)),
	58:  int16(1),
	59:  int16(1),
	60:  int16(m_IOV_MAX),
	61:  int16(-int32(1)),
	62:  int16(-int32(1)),
	63:  int16(-int32(1)),
	64:  int16(-int32(1)),
	65:  int16(-int32(1)),
	66:  int16(-int32(1)),
	67:  int16(-Int32FromInt32(2)),
	68:  int16(-Int32FromInt32(2)),
	69:  int16(-int32(1)),
	70:  int16(-int32(1)),
	71:  int16(256),
	72:  int16(m_TTY_NAME_MAX),
	73:  int16(m__POSIX_THREAD_DESTRUCTOR_ITERATIONS),
	74:  int16(-int32(1)),
	75:  int16(Int32FromInt32(2) * Int32FromInt32(m_PAGESIZE)),
	76:  int16(-int32(1)),
	77:  int16(-int32(1)),
	78:  int16(-Int32FromInt32(2)),
	79:  int16(-int32(1)),
	80:  int16(-int32(1)),
	81:  int16(-int32(1)),
	82:  int16(-Int32FromInt32(2)),
	83:  int16(-int32(1)),
	84:  int16(-int32(1)),
	85:  int16(-int32(1)),
	86:  int16(-int32(1)),
	87:  int16(-int32(1)),
	88:  int16(-int32(1)),
	89:  int16(m__XOPEN_VERSION),
	90:  int16(m__XOPEN_VERSION),
	91:  int16(-int32(1)),
	92:  int16(-int32(1)),
	93:  int16(1),
	94:  int16(1),
	95:  int16(-int32(1)),
	96:  int16(-int32(1)),
	97:  int16(-int32(1)),
	98:  int16(-int32(1)),
	99:  int16(-int32(1)),
	100: int16(-int32(1)),
	101: int16(-int32(1)),
	102: int16(-int32(1)),
	103: int16(-int32(1)),
	104: int16(-int32(1)),
	105: int16(-int32(1)),
	106: int16(-int32(1)),
	107: int16(-int32(1)),
	108: int16(-int32(1)),
	109: int16(m_NZERO),
	110: int16(-int32(1)),
	111: int16(-int32(1)),
	112: int16(-int32(1)),
	113: int16(-int32(1)),
	114: int16(-int32(1)),
	115: int16(-int32(1)),
	116: int16(-int32(1)),
	117: int16(-int32(1)),
	118: int16(-int32(1)),
	119: int16(-int32(1)),
	120: int16(-int32(1)),
	121: int16(-int32(1)),
	122: int16(-int32(1)),
	123: int16(-int32(1)),
	124: int16(-int32(1)),
	125: int16(-int32(1)),
	126: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(4)) - Int32FromInt32(1)),
	127: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(8)) - Int32FromInt32(1)),
	128: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) >= Uint64FromInt32(8)) - Int32FromInt32(1)),
	129: int16(-int32(1)),
	130: int16(-int32(1)),
	131: int16(-int32(1)),
	132: int16(-int32(1)),
	133: int16(-Int32FromInt32(2)),
	134: int16(-int32(1)),
	135: int16(-int32(1)),
	136: int16(-int32(1)),
	137: int16(-Int32FromInt32(2)),
	138: int16(-Int32FromInt32(2)),
	139: int16(-int32(1)),
	140: int16(-int32(1)),
	141: int16(-int32(1)),
	142: int16(-int32(1)),
	143: int16(-int32(1)),
	144: int16(-int32(1)),
	145: int16(-int32(1)),
	146: int16(-int32(1)),
	147: int16(-int32(1)),
	148: int16(-int32(1)),
	149: int16(-Int32FromInt32(2)),
	150: int16(-int32(1)),
	151: int16(-int32(1)),
	152: int16(-int32(1)),
	153: int16(-Int32FromInt32(2)),
	154: int16(-Int32FromInt32(2)),
	155: int16(1),
	156: int16(-int32(1)),
	157: int16(1),
	158: int16(-int32(1)),
	159: int16(-int32(1)),
	160: int16(-int32(1)),
	161: int16(-int32(1)),
	162: int16(-int32(1)),
	163: int16(-int32(1)),
	164: int16(-Int32FromInt32(2)),
	165: int16(-int32(1)),
	166: int16(-int32(1)),
	167: int16(-int32(1)),
	168: int16(-int32(1)),
	169: int16(-int32(1)),
	170: int16(-int32(1)),
	171: int16(-int32(1)),
	172: int16(-int32(1)),
	173: int16(m_SYMLOOP_MAX),
	174: 0,
	175: int16(-int32(1)),
	176: int16(-int32(1)),
	177: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(4)) - Int32FromInt32(1)),
	178: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(8)) - Int32FromInt32(1)),
	179: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) >= Uint64FromInt32(8)) - Int32FromInt32(1)),
	180: int16(m_HOST_NAME_MAX),
	181: int16(-int32(1)),
	182: int16(-int32(1)),
	183: int16(-int32(1)),
	184: int16(-int32(1)),
	235: int16(-Int32FromInt32(2)),
	236: int16(-Int32FromInt32(2)),
	237: int16(-int32(1)),
	238: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(4)) - Int32FromInt32(1)),
	239: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) == Uint64FromInt32(8)) - Int32FromInt32(1)),
	240: int16(Int32FromInt32(2)*BoolInt32(Uint64FromInt64(8) >= Uint64FromInt32(8)) - Int32FromInt32(1)),
	241: int16(-int32(1)),
	242: int16(-int32(1)),
	243: int16(-int32(1)),
	244: int16(-int32(1)),
	245: int16(-int32(1)),
	246: 0,
	247: int16(-int32(1)),
	248: int16(-int32(1))}

type Twchar_t = int32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

func x___ctype_get_mb_cur_max(tls *TLS) (r uint64) {
	return uint64(4)
}

type Tlocale_t = uintptr

func x_isalnum(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c|Int32FromInt32(32)-Int32FromUint8('a')) < uint32(26) || uint32(c-Int32FromUint8('0')) < uint32(10))
}

func x_isalpha(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)|uint32(32)-uint32('a') < uint32(26))
}

func x_isascii(tls *TLS, c int32) (r int32) {
	return BoolInt32(!(c & ^Int32FromInt32(0x7f) != 0))
}

func x_isblank(tls *TLS, c int32) (r int32) {
	return BoolInt32(c == int32(' ') || c == int32('\t'))
}

func x_iscntrl(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c) < uint32(0x20) || c == int32(0x7f))
}

func x_isdigit(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('0') < uint32(10))
}

func x_isgraph(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32(0x21) < uint32(0x5e))
}

func x_islower(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('a') < uint32(26))
}

func x_isprint(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32(0x20) < uint32(0x5f))
}

func x_ispunct(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c-Int32FromInt32(0x21)) < uint32(0x5e) && !(x_isalnum(tls, c) != 0))
}

func x_isspace(tls *TLS, c int32) (r int32) {
	return BoolInt32(c == int32(' ') || uint32(c)-uint32('\t') < uint32(5))
}

func x_isupper(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('A') < uint32(26))
}

type Twint_t = int32

type Twctype_t = int32

type Tmbstate_t = struct {
	F__opaque1 uint32
	F__opaque2 uint32
}

type Twctrans_t = int32

func x_iswalnum(tls *TLS, wc int32) (r int32) {
	return BoolInt32(uint32(wc)-uint32('0') < uint32(10) || x_iswalpha(tls, wc) != 0)
}

func x_iswalpha(tls *TLS, wc int32) (r int32) {
	return BoolInt32(uint32(32)|uint32(wc)-uint32('a') < uint32(26))
}

func x_iswblank(tls *TLS, wc int32) (r int32) {
	return x_isblank(tls, wc)
}

func x_iswcntrl(tls *TLS, wc int32) (r int32) {
	return BoolInt32(uint32(wc) < uint32(32) || uint32(wc-Int32FromInt32(0x7f)) < uint32(33) || uint32(wc-Int32FromInt32(0x2028)) < uint32(2) || uint32(wc-Int32FromInt32(0xfff9)) < uint32(3))
}

const m_WCTYPE_ALNUM = 1
const m_WCTYPE_ALPHA = 2
const m_WCTYPE_BLANK = 3
const m_WCTYPE_CNTRL = 4
const m_WCTYPE_DIGIT = 5
const m_WCTYPE_GRAPH = 6
const m_WCTYPE_LOWER = 7
const m_WCTYPE_PRINT = 8
const m_WCTYPE_PUNCT = 9
const m_WCTYPE_SPACE = 10
const m_WCTYPE_UPPER = 11
const m_WCTYPE_XDIGIT = 12

func x_iswctype(tls *TLS, wc int32, type1 int32) (r int32) {
	switch type1 {
	case int32(m_WCTYPE_ALNUM):
		return x_iswalnum(tls, wc)
	case int32(m_WCTYPE_ALPHA):
		return x_iswalpha(tls, wc)
	case int32(m_WCTYPE_BLANK):
		return x_iswblank(tls, wc)
	case int32(m_WCTYPE_CNTRL):
		return x_iswcntrl(tls, wc)
	case int32(m_WCTYPE_DIGIT):
		return BoolInt32(uint32(wc-Int32FromInt32('0')) < uint32(10))
	case int32(m_WCTYPE_GRAPH):
		return x_iswgraph(tls, wc)
	case int32(m_WCTYPE_LOWER):
		return x_iswlower(tls, wc)
	case int32(m_WCTYPE_PRINT):
		return x_iswprint(tls, wc)
	case int32(m_WCTYPE_PUNCT):
		return x_iswpunct(tls, wc)
	case int32(m_WCTYPE_SPACE):
		return x_iswspace(tls, wc)
	case int32(m_WCTYPE_UPPER):
		return x_iswupper(tls, wc)
	case int32(m_WCTYPE_XDIGIT):
		return x_iswxdigit(tls, wc)
	}
	return 0
}

func x_wctype(tls *TLS, s uintptr) (r int32) {
	var i int32
	var p uintptr
	i = int32(1)
	p = uintptr(unsafe.Pointer(&_names))
	for *(*int8)(unsafe.Pointer(p)) != 0 {
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(*(*int8)(unsafe.Pointer(p))) && !(x_strcmp(tls, s, p) != 0) {
			return i
		}
		goto _1
	_1:
		i++
		p += uintptr(6)
	}
	return 0
}

/* order must match! */
var _names = [73]int8{'a', 'l', 'n', 'u', 'm', 0, 'a', 'l', 'p', 'h', 'a', 0, 'b', 'l', 'a', 'n', 'k', 0, 'c', 'n', 't', 'r', 'l', 0, 'd', 'i', 'g', 'i', 't', 0, 'g', 'r', 'a', 'p', 'h', 0, 'l', 'o', 'w', 'e', 'r', 0, 'p', 'r', 'i', 'n', 't', 0, 'p', 'u', 'n', 'c', 't', 0, 's', 'p', 'a', 'c', 'e', 0, 'u', 'p', 'p', 'e', 'r', 0, 'x', 'd', 'i', 'g', 'i', 't'}

func x_iswdigit(tls *TLS, wc int32) (r int32) {
	return BoolInt32(uint32(wc)-uint32('0') < uint32(10))
}

func x_iswgraph(tls *TLS, wc int32) (r int32) {
	/* ISO C defines this function as: */
	return BoolInt32(!(x_iswspace(tls, wc) != 0) && x_iswprint(tls, wc) != 0)
}

func x_iswlower(tls *TLS, wc int32) (r int32) {
	return BoolInt32(x_towupper(tls, wc) != wc)
}

func x_iswprint(tls *TLS, wc int32) (r int32) {
	var c uint32
	c = uint32(wc)
	/* assume any non-control, non-illegal codepoint is printable */
	if c > uint32(0x10ffff) || c-uint32(0xd800) < uint32(0x800) || c&uint32(0xfffe) == uint32(0xfffe) || x_iswcntrl(tls, int32(c)) != 0 {
		return 0
	}
	return int32(1)
}

type Tint8_t = int8

type Tint16_t = int16

type Tint32_t = int32

type Tint64_t = int64

type Tuint8_t = uint8

type Tuint16_t = uint16

type Tuint32_t = uint32

type Tuint64_t = uint64

type Tint_least8_t = int8

type Tint_least16_t = int16

type Tint_least32_t = int32

type Tint_least64_t = int64

type Tuint_least8_t = uint8

type Tuint_least16_t = uint16

type Tuint_least32_t = uint32

type Tuint_least64_t = uint64

type Tint_fast8_t = int8

type Tint_fast16_t = int32

type Tint_fast32_t = int32

type Tint_fast64_t = int64

type Tuint_fast8_t = uint8

type Tuint_fast16_t = uint32

type Tuint_fast32_t = uint32

type Tuint_fast64_t = uint64

type Tuintptr_t = uint64

type Tintmax_t = int64

type Tuintmax_t = uint64

type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
}

/* The below data is derived from classes (P.|Sm) plus Pattern_Syntax */

type Trange = struct {
	F__ccgo0 uint32
}

var _ranges = [114]Trange{
	0:   {F__ccgo0: uint32(Int32FromInt32(0x2f))&0xfffff<<0 | uint32(Int32FromInt32(0x2f)-Int32FromInt32(0x21))&0xfff<<20},
	1:   {F__ccgo0: uint32(Int32FromInt32(0x40))&0xfffff<<0 | uint32(Int32FromInt32(0x40)-Int32FromInt32(0x3a))&0xfff<<20},
	2:   {F__ccgo0: uint32(Int32FromInt32(0x60))&0xfffff<<0 | uint32(Int32FromInt32(0x60)-Int32FromInt32(0x5b))&0xfff<<20},
	3:   {F__ccgo0: uint32(Int32FromInt32(0x7e))&0xfffff<<0 | uint32(Int32FromInt32(0x7e)-Int32FromInt32(0x7b))&0xfff<<20},
	4:   {F__ccgo0: uint32(Int32FromInt32(0xa7))&0xfffff<<0 | uint32(Int32FromInt32(0xa7)-Int32FromInt32(0xa1))&0xfff<<20},
	5:   {F__ccgo0: uint32(Int32FromInt32(0xa9))&0xfffff<<0 | uint32(Int32FromInt32(0xa9)-Int32FromInt32(0xa9))&0xfff<<20},
	6:   {F__ccgo0: uint32(Int32FromInt32(0xac))&0xfffff<<0 | uint32(Int32FromInt32(0xac)-Int32FromInt32(0xab))&0xfff<<20},
	7:   {F__ccgo0: uint32(Int32FromInt32(0xae))&0xfffff<<0 | uint32(Int32FromInt32(0xae)-Int32FromInt32(0xae))&0xfff<<20},
	8:   {F__ccgo0: uint32(Int32FromInt32(0xb1))&0xfffff<<0 | uint32(Int32FromInt32(0xb1)-Int32FromInt32(0xb0))&0xfff<<20},
	9:   {F__ccgo0: uint32(Int32FromInt32(0xb7))&0xfffff<<0 | uint32(Int32FromInt32(0xb7)-Int32FromInt32(0xb6))&0xfff<<20},
	10:  {F__ccgo0: uint32(Int32FromInt32(0xbb))&0xfffff<<0 | uint32(Int32FromInt32(0xbb)-Int32FromInt32(0xbb))&0xfff<<20},
	11:  {F__ccgo0: uint32(Int32FromInt32(0xbf))&0xfffff<<0 | uint32(Int32FromInt32(0xbf)-Int32FromInt32(0xbf))&0xfff<<20},
	12:  {F__ccgo0: uint32(Int32FromInt32(0xd7))&0xfffff<<0 | uint32(Int32FromInt32(0xd7)-Int32FromInt32(0xd7))&0xfff<<20},
	13:  {F__ccgo0: uint32(Int32FromInt32(0xf7))&0xfffff<<0 | uint32(Int32FromInt32(0xf7)-Int32FromInt32(0xf7))&0xfff<<20},
	14:  {F__ccgo0: uint32(Int32FromInt32(0x37e))&0xfffff<<0 | uint32(Int32FromInt32(0x37e)-Int32FromInt32(0x37e))&0xfff<<20},
	15:  {F__ccgo0: uint32(Int32FromInt32(0x387))&0xfffff<<0 | uint32(Int32FromInt32(0x387)-Int32FromInt32(0x387))&0xfff<<20},
	16:  {F__ccgo0: uint32(Int32FromInt32(0x3f6))&0xfffff<<0 | uint32(Int32FromInt32(0x3f6)-Int32FromInt32(0x3f6))&0xfff<<20},
	17:  {F__ccgo0: uint32(Int32FromInt32(0x55f))&0xfffff<<0 | uint32(Int32FromInt32(0x55f)-Int32FromInt32(0x55a))&0xfff<<20},
	18:  {F__ccgo0: uint32(Int32FromInt32(0x58a))&0xfffff<<0 | uint32(Int32FromInt32(0x58a)-Int32FromInt32(0x589))&0xfff<<20},
	19:  {F__ccgo0: uint32(Int32FromInt32(0x5be))&0xfffff<<0 | uint32(Int32FromInt32(0x5be)-Int32FromInt32(0x5be))&0xfff<<20},
	20:  {F__ccgo0: uint32(Int32FromInt32(0x5c0))&0xfffff<<0 | uint32(Int32FromInt32(0x5c0)-Int32FromInt32(0x5c0))&0xfff<<20},
	21:  {F__ccgo0: uint32(Int32FromInt32(0x5c3))&0xfffff<<0 | uint32(Int32FromInt32(0x5c3)-Int32FromInt32(0x5c3))&0xfff<<20},
	22:  {F__ccgo0: uint32(Int32FromInt32(0x5c6))&0xfffff<<0 | uint32(Int32FromInt32(0x5c6)-Int32FromInt32(0x5c6))&0xfff<<20},
	23:  {F__ccgo0: uint32(Int32FromInt32(0x5f4))&0xfffff<<0 | uint32(Int32FromInt32(0x5f4)-Int32FromInt32(0x5f3))&0xfff<<20},
	24:  {F__ccgo0: uint32(Int32FromInt32(0x60a))&0xfffff<<0 | uint32(Int32FromInt32(0x60a)-Int32FromInt32(0x606))&0xfff<<20},
	25:  {F__ccgo0: uint32(Int32FromInt32(0x60d))&0xfffff<<0 | uint32(Int32FromInt32(0x60d)-Int32FromInt32(0x60c))&0xfff<<20},
	26:  {F__ccgo0: uint32(Int32FromInt32(0x61b))&0xfffff<<0 | uint32(Int32FromInt32(0x61b)-Int32FromInt32(0x61b))&0xfff<<20},
	27:  {F__ccgo0: uint32(Int32FromInt32(0x61f))&0xfffff<<0 | uint32(Int32FromInt32(0x61f)-Int32FromInt32(0x61e))&0xfff<<20},
	28:  {F__ccgo0: uint32(Int32FromInt32(0x66d))&0xfffff<<0 | uint32(Int32FromInt32(0x66d)-Int32FromInt32(0x66a))&0xfff<<20},
	29:  {F__ccgo0: uint32(Int32FromInt32(0x6d4))&0xfffff<<0 | uint32(Int32FromInt32(0x6d4)-Int32FromInt32(0x6d4))&0xfff<<20},
	30:  {F__ccgo0: uint32(Int32FromInt32(0x70d))&0xfffff<<0 | uint32(Int32FromInt32(0x70d)-Int32FromInt32(0x700))&0xfff<<20},
	31:  {F__ccgo0: uint32(Int32FromInt32(0x7f9))&0xfffff<<0 | uint32(Int32FromInt32(0x7f9)-Int32FromInt32(0x7f7))&0xfff<<20},
	32:  {F__ccgo0: uint32(Int32FromInt32(0x965))&0xfffff<<0 | uint32(Int32FromInt32(0x965)-Int32FromInt32(0x964))&0xfff<<20},
	33:  {F__ccgo0: uint32(Int32FromInt32(0x970))&0xfffff<<0 | uint32(Int32FromInt32(0x970)-Int32FromInt32(0x970))&0xfff<<20},
	34:  {F__ccgo0: uint32(Int32FromInt32(0xdf4))&0xfffff<<0 | uint32(Int32FromInt32(0xdf4)-Int32FromInt32(0xdf4))&0xfff<<20},
	35:  {F__ccgo0: uint32(Int32FromInt32(0xe4f))&0xfffff<<0 | uint32(Int32FromInt32(0xe4f)-Int32FromInt32(0xe4f))&0xfff<<20},
	36:  {F__ccgo0: uint32(Int32FromInt32(0xe5b))&0xfffff<<0 | uint32(Int32FromInt32(0xe5b)-Int32FromInt32(0xe5a))&0xfff<<20},
	37:  {F__ccgo0: uint32(Int32FromInt32(0xf12))&0xfffff<<0 | uint32(Int32FromInt32(0xf12)-Int32FromInt32(0xf04))&0xfff<<20},
	38:  {F__ccgo0: uint32(Int32FromInt32(0xf3d))&0xfffff<<0 | uint32(Int32FromInt32(0xf3d)-Int32FromInt32(0xf3a))&0xfff<<20},
	39:  {F__ccgo0: uint32(Int32FromInt32(0xf85))&0xfffff<<0 | uint32(Int32FromInt32(0xf85)-Int32FromInt32(0xf85))&0xfff<<20},
	40:  {F__ccgo0: uint32(Int32FromInt32(0xfd4))&0xfffff<<0 | uint32(Int32FromInt32(0xfd4)-Int32FromInt32(0xfd0))&0xfff<<20},
	41:  {F__ccgo0: uint32(Int32FromInt32(0x104f))&0xfffff<<0 | uint32(Int32FromInt32(0x104f)-Int32FromInt32(0x104a))&0xfff<<20},
	42:  {F__ccgo0: uint32(Int32FromInt32(0x10fb))&0xfffff<<0 | uint32(Int32FromInt32(0x10fb)-Int32FromInt32(0x10fb))&0xfff<<20},
	43:  {F__ccgo0: uint32(Int32FromInt32(0x1368))&0xfffff<<0 | uint32(Int32FromInt32(0x1368)-Int32FromInt32(0x1361))&0xfff<<20},
	44:  {F__ccgo0: uint32(Int32FromInt32(0x166e))&0xfffff<<0 | uint32(Int32FromInt32(0x166e)-Int32FromInt32(0x166d))&0xfff<<20},
	45:  {F__ccgo0: uint32(Int32FromInt32(0x1680))&0xfffff<<0 | uint32(Int32FromInt32(0x1680)-Int32FromInt32(0x1680))&0xfff<<20},
	46:  {F__ccgo0: uint32(Int32FromInt32(0x169c))&0xfffff<<0 | uint32(Int32FromInt32(0x169c)-Int32FromInt32(0x169b))&0xfff<<20},
	47:  {F__ccgo0: uint32(Int32FromInt32(0x16ed))&0xfffff<<0 | uint32(Int32FromInt32(0x16ed)-Int32FromInt32(0x16eb))&0xfff<<20},
	48:  {F__ccgo0: uint32(Int32FromInt32(0x1736))&0xfffff<<0 | uint32(Int32FromInt32(0x1736)-Int32FromInt32(0x1735))&0xfff<<20},
	49:  {F__ccgo0: uint32(Int32FromInt32(0x17d6))&0xfffff<<0 | uint32(Int32FromInt32(0x17d6)-Int32FromInt32(0x17d4))&0xfff<<20},
	50:  {F__ccgo0: uint32(Int32FromInt32(0x17da))&0xfffff<<0 | uint32(Int32FromInt32(0x17da)-Int32FromInt32(0x17d8))&0xfff<<20},
	51:  {F__ccgo0: uint32(Int32FromInt32(0x180a))&0xfffff<<0 | uint32(Int32FromInt32(0x180a)-Int32FromInt32(0x1800))&0xfff<<20},
	52:  {F__ccgo0: uint32(Int32FromInt32(0x180e))&0xfffff<<0 | uint32(Int32FromInt32(0x180e)-Int32FromInt32(0x180e))&0xfff<<20},
	53:  {F__ccgo0: uint32(Int32FromInt32(0x1945))&0xfffff<<0 | uint32(Int32FromInt32(0x1945)-Int32FromInt32(0x1944))&0xfff<<20},
	54:  {F__ccgo0: uint32(Int32FromInt32(0x19df))&0xfffff<<0 | uint32(Int32FromInt32(0x19df)-Int32FromInt32(0x19de))&0xfff<<20},
	55:  {F__ccgo0: uint32(Int32FromInt32(0x1a1f))&0xfffff<<0 | uint32(Int32FromInt32(0x1a1f)-Int32FromInt32(0x1a1e))&0xfff<<20},
	56:  {F__ccgo0: uint32(Int32FromInt32(0x1b60))&0xfffff<<0 | uint32(Int32FromInt32(0x1b60)-Int32FromInt32(0x1b5a))&0xfff<<20},
	57:  {F__ccgo0: uint32(Int32FromInt32(0x1c3f))&0xfffff<<0 | uint32(Int32FromInt32(0x1c3f)-Int32FromInt32(0x1c3b))&0xfff<<20},
	58:  {F__ccgo0: uint32(Int32FromInt32(0x1c7f))&0xfffff<<0 | uint32(Int32FromInt32(0x1c7f)-Int32FromInt32(0x1c7e))&0xfff<<20},
	59:  {F__ccgo0: uint32(Int32FromInt32(0x2027))&0xfffff<<0 | uint32(Int32FromInt32(0x2027)-Int32FromInt32(0x2010))&0xfff<<20},
	60:  {F__ccgo0: uint32(Int32FromInt32(0x205e))&0xfffff<<0 | uint32(Int32FromInt32(0x205e)-Int32FromInt32(0x2030))&0xfff<<20},
	61:  {F__ccgo0: uint32(Int32FromInt32(0x207e))&0xfffff<<0 | uint32(Int32FromInt32(0x207e)-Int32FromInt32(0x207a))&0xfff<<20},
	62:  {F__ccgo0: uint32(Int32FromInt32(0x208e))&0xfffff<<0 | uint32(Int32FromInt32(0x208e)-Int32FromInt32(0x208a))&0xfff<<20},
	63:  {F__ccgo0: uint32(Int32FromInt32(0x2144))&0xfffff<<0 | uint32(Int32FromInt32(0x2144)-Int32FromInt32(0x2140))&0xfff<<20},
	64:  {F__ccgo0: uint32(Int32FromInt32(0x214b))&0xfffff<<0 | uint32(Int32FromInt32(0x214b)-Int32FromInt32(0x214b))&0xfff<<20},
	65:  {F__ccgo0: uint32(Int32FromInt32(0x245f))&0xfffff<<0 | uint32(Int32FromInt32(0x245f)-Int32FromInt32(0x2190))&0xfff<<20},
	66:  {F__ccgo0: uint32(Int32FromInt32(0x2775))&0xfffff<<0 | uint32(Int32FromInt32(0x2775)-Int32FromInt32(0x2500))&0xfff<<20},
	67:  {F__ccgo0: uint32(Int32FromInt32(0x2bff))&0xfffff<<0 | uint32(Int32FromInt32(0x2bff)-Int32FromInt32(0x2794))&0xfff<<20},
	68:  {F__ccgo0: uint32(Int32FromInt32(0x2cfc))&0xfffff<<0 | uint32(Int32FromInt32(0x2cfc)-Int32FromInt32(0x2cf9))&0xfff<<20},
	69:  {F__ccgo0: uint32(Int32FromInt32(0x2cff))&0xfffff<<0 | uint32(Int32FromInt32(0x2cff)-Int32FromInt32(0x2cfe))&0xfff<<20},
	70:  {F__ccgo0: uint32(Int32FromInt32(0x2e7f))&0xfffff<<0 | uint32(Int32FromInt32(0x2e7f)-Int32FromInt32(0x2e00))&0xfff<<20},
	71:  {F__ccgo0: uint32(Int32FromInt32(0x3003))&0xfffff<<0 | uint32(Int32FromInt32(0x3003)-Int32FromInt32(0x3001))&0xfff<<20},
	72:  {F__ccgo0: uint32(Int32FromInt32(0x3020))&0xfffff<<0 | uint32(Int32FromInt32(0x3020)-Int32FromInt32(0x3008))&0xfff<<20},
	73:  {F__ccgo0: uint32(Int32FromInt32(0x3030))&0xfffff<<0 | uint32(Int32FromInt32(0x3030)-Int32FromInt32(0x3030))&0xfff<<20},
	74:  {F__ccgo0: uint32(Int32FromInt32(0x303d))&0xfffff<<0 | uint32(Int32FromInt32(0x303d)-Int32FromInt32(0x303d))&0xfff<<20},
	75:  {F__ccgo0: uint32(Int32FromInt32(0x30a0))&0xfffff<<0 | uint32(Int32FromInt32(0x30a0)-Int32FromInt32(0x30a0))&0xfff<<20},
	76:  {F__ccgo0: uint32(Int32FromInt32(0x30fb))&0xfffff<<0 | uint32(Int32FromInt32(0x30fb)-Int32FromInt32(0x30fb))&0xfff<<20},
	77:  {F__ccgo0: uint32(Int32FromInt32(0xa60f))&0xfffff<<0 | uint32(Int32FromInt32(0xa60f)-Int32FromInt32(0xa60d))&0xfff<<20},
	78:  {F__ccgo0: uint32(Int32FromInt32(0xa877))&0xfffff<<0 | uint32(Int32FromInt32(0xa877)-Int32FromInt32(0xa874))&0xfff<<20},
	79:  {F__ccgo0: uint32(Int32FromInt32(0xa8cf))&0xfffff<<0 | uint32(Int32FromInt32(0xa8cf)-Int32FromInt32(0xa8ce))&0xfff<<20},
	80:  {F__ccgo0: uint32(Int32FromInt32(0xa92f))&0xfffff<<0 | uint32(Int32FromInt32(0xa92f)-Int32FromInt32(0xa92e))&0xfff<<20},
	81:  {F__ccgo0: uint32(Int32FromInt32(0xa95f))&0xfffff<<0 | uint32(Int32FromInt32(0xa95f)-Int32FromInt32(0xa95f))&0xfff<<20},
	82:  {F__ccgo0: uint32(Int32FromInt32(0xfb29))&0xfffff<<0 | uint32(Int32FromInt32(0xfb29)-Int32FromInt32(0xfb29))&0xfff<<20},
	83:  {F__ccgo0: uint32(Int32FromInt32(0xfd3f))&0xfffff<<0 | uint32(Int32FromInt32(0xfd3f)-Int32FromInt32(0xfd3e))&0xfff<<20},
	84:  {F__ccgo0: uint32(Int32FromInt32(0xfe19))&0xfffff<<0 | uint32(Int32FromInt32(0xfe19)-Int32FromInt32(0xfe10))&0xfff<<20},
	85:  {F__ccgo0: uint32(Int32FromInt32(0xfe52))&0xfffff<<0 | uint32(Int32FromInt32(0xfe52)-Int32FromInt32(0xfe30))&0xfff<<20},
	86:  {F__ccgo0: uint32(Int32FromInt32(0xfe66))&0xfffff<<0 | uint32(Int32FromInt32(0xfe66)-Int32FromInt32(0xfe54))&0xfff<<20},
	87:  {F__ccgo0: uint32(Int32FromInt32(0xfe68))&0xfffff<<0 | uint32(Int32FromInt32(0xfe68)-Int32FromInt32(0xfe68))&0xfff<<20},
	88:  {F__ccgo0: uint32(Int32FromInt32(0xfe6b))&0xfffff<<0 | uint32(Int32FromInt32(0xfe6b)-Int32FromInt32(0xfe6a))&0xfff<<20},
	89:  {F__ccgo0: uint32(Int32FromInt32(0xff03))&0xfffff<<0 | uint32(Int32FromInt32(0xff03)-Int32FromInt32(0xff01))&0xfff<<20},
	90:  {F__ccgo0: uint32(Int32FromInt32(0xff0f))&0xfffff<<0 | uint32(Int32FromInt32(0xff0f)-Int32FromInt32(0xff05))&0xfff<<20},
	91:  {F__ccgo0: uint32(Int32FromInt32(0xff20))&0xfffff<<0 | uint32(Int32FromInt32(0xff20)-Int32FromInt32(0xff1a))&0xfff<<20},
	92:  {F__ccgo0: uint32(Int32FromInt32(0xff3d))&0xfffff<<0 | uint32(Int32FromInt32(0xff3d)-Int32FromInt32(0xff3b))&0xfff<<20},
	93:  {F__ccgo0: uint32(Int32FromInt32(0xff3f))&0xfffff<<0 | uint32(Int32FromInt32(0xff3f)-Int32FromInt32(0xff3f))&0xfff<<20},
	94:  {F__ccgo0: uint32(Int32FromInt32(0xff65))&0xfffff<<0 | uint32(Int32FromInt32(0xff65)-Int32FromInt32(0xff5b))&0xfff<<20},
	95:  {F__ccgo0: uint32(Int32FromInt32(0xffe2))&0xfffff<<0 | uint32(Int32FromInt32(0xffe2)-Int32FromInt32(0xffe2))&0xfff<<20},
	96:  {F__ccgo0: uint32(Int32FromInt32(0xffec))&0xfffff<<0 | uint32(Int32FromInt32(0xffec)-Int32FromInt32(0xffe9))&0xfff<<20},
	97:  {F__ccgo0: uint32(Int32FromInt32(0x10101))&0xfffff<<0 | uint32(Int32FromInt32(0x10101)-Int32FromInt32(0x10100))&0xfff<<20},
	98:  {F__ccgo0: uint32(Int32FromInt32(0x1039f))&0xfffff<<0 | uint32(Int32FromInt32(0x1039f)-Int32FromInt32(0x1039f))&0xfff<<20},
	99:  {F__ccgo0: uint32(Int32FromInt32(0x103d0))&0xfffff<<0 | uint32(Int32FromInt32(0x103d0)-Int32FromInt32(0x103d0))&0xfff<<20},
	100: {F__ccgo0: uint32(Int32FromInt32(0x1091f))&0xfffff<<0 | uint32(Int32FromInt32(0x1091f)-Int32FromInt32(0x1091f))&0xfff<<20},
	101: {F__ccgo0: uint32(Int32FromInt32(0x1093f))&0xfffff<<0 | uint32(Int32FromInt32(0x1093f)-Int32FromInt32(0x1093f))&0xfff<<20},
	102: {F__ccgo0: uint32(Int32FromInt32(0x10a58))&0xfffff<<0 | uint32(Int32FromInt32(0x10a58)-Int32FromInt32(0x10a50))&0xfff<<20},
	103: {F__ccgo0: uint32(Int32FromInt32(0x12473))&0xfffff<<0 | uint32(Int32FromInt32(0x12473)-Int32FromInt32(0x12470))&0xfff<<20},
	104: {F__ccgo0: uint32(Int32FromInt32(0x1d6c1))&0xfffff<<0 | uint32(Int32FromInt32(0x1d6c1)-Int32FromInt32(0x1d6c1))&0xfff<<20},
	105: {F__ccgo0: uint32(Int32FromInt32(0x1d6db))&0xfffff<<0 | uint32(Int32FromInt32(0x1d6db)-Int32FromInt32(0x1d6db))&0xfff<<20},
	106: {F__ccgo0: uint32(Int32FromInt32(0x1d6fb))&0xfffff<<0 | uint32(Int32FromInt32(0x1d6fb)-Int32FromInt32(0x1d6fb))&0xfff<<20},
	107: {F__ccgo0: uint32(Int32FromInt32(0x1d715))&0xfffff<<0 | uint32(Int32FromInt32(0x1d715)-Int32FromInt32(0x1d715))&0xfff<<20},
	108: {F__ccgo0: uint32(Int32FromInt32(0x1d735))&0xfffff<<0 | uint32(Int32FromInt32(0x1d735)-Int32FromInt32(0x1d735))&0xfff<<20},
	109: {F__ccgo0: uint32(Int32FromInt32(0x1d74f))&0xfffff<<0 | uint32(Int32FromInt32(0x1d74f)-Int32FromInt32(0x1d74f))&0xfff<<20},
	110: {F__ccgo0: uint32(Int32FromInt32(0x1d76f))&0xfffff<<0 | uint32(Int32FromInt32(0x1d76f)-Int32FromInt32(0x1d76f))&0xfff<<20},
	111: {F__ccgo0: uint32(Int32FromInt32(0x1d789))&0xfffff<<0 | uint32(Int32FromInt32(0x1d789)-Int32FromInt32(0x1d789))&0xfff<<20},
	112: {F__ccgo0: uint32(Int32FromInt32(0x1d7a9))&0xfffff<<0 | uint32(Int32FromInt32(0x1d7a9)-Int32FromInt32(0x1d7a9))&0xfff<<20},
	113: {F__ccgo0: uint32(Int32FromInt32(0x1d7c3))&0xfffff<<0 | uint32(Int32FromInt32(0x1d7c3)-Int32FromInt32(0x1d7c3))&0xfff<<20}}

func x_iswpunct(tls *TLS, wc int32) (r int32) {
	var a, n int32
	var c uint32
	c = uint32(wc)
	a = 0
	n = int32(Uint64FromInt64(456) / Uint64FromInt64(4))
	for cond := true; cond; cond = n != 0 {
		n >>= int32(1)
		a += (n + int32(1)) & (int32(uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges)) + uintptr(a+n)*4 + 0))&0xfffff>>0))-c) >> int32(31))
	}
	return BoolInt32(uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges)) + uintptr(a)*4 + 0))&0xfffff>>0))-c <= uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges)) + uintptr(a)*4 + 0))&0xfff00000>>20)))
}

func x_iswspace(tls *TLS, wc int32) (r int32) {
	if x_wcschr(tls, uintptr(unsafe.Pointer(&_spaces)), wc) != 0 {
		return int32(1)
	}
	return 0
}

var _spaces = [23]int32{
	0:  int32(' '),
	1:  int32('\t'),
	2:  int32('\n'),
	3:  int32('\r'),
	4:  int32(11),
	5:  int32(12),
	6:  int32(0x0085),
	7:  int32(0x2000),
	8:  int32(0x2001),
	9:  int32(0x2002),
	10: int32(0x2003),
	11: int32(0x2004),
	12: int32(0x2005),
	13: int32(0x2006),
	14: int32(0x2008),
	15: int32(0x2009),
	16: int32(0x200a),
	17: int32(0x200b),
	18: int32(0x2028),
	19: int32(0x2029),
	20: int32(0x2050),
	21: int32(0x3000),
	22: 0}

func x_iswupper(tls *TLS, wc int32) (r int32) {
	return BoolInt32(x_towlower(tls, wc) != wc)
}

func x_iswxdigit(tls *TLS, wc int32) (r int32) {
	return BoolInt32(uint32(wc-Int32FromUint8('0')) < uint32(10) || uint32(wc|Int32FromInt32(32)-Int32FromUint8('a')) < uint32(6))
}

func x_isxdigit(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c-Int32FromUint8('0')) < uint32(10) || uint32(c)|uint32(32)-uint32('a') < uint32(6))
}

// C documentation
//
//	/* nonsense function that should NEVER be used! */
func x_toascii(tls *TLS, c int32) (r int32) {
	return c & int32(0x7f)
}

func x_tolower(tls *TLS, c int32) (r int32) {
	if uint32(c-Int32FromUint8('A')) < uint32(26) {
		return c | int32(32)
	}
	return c
}

func x_toupper(tls *TLS, c int32) (r int32) {
	if uint32(c-Int32FromUint8('a')) < uint32(26) {
		return c & int32(0x5f)
	}
	return c
}

var _casemaps = [56]struct {
	Fupper uint16
	Flower int8
	Flen1  uint8
}{
	0:  {Fupper: uint16(Int32FromUint8('A')), Flower: int8(Int32FromUint8('a') - Int32FromUint8('A')), Flen1: uint8(Int32FromUint8('Z') - Int32FromUint8('A') + Int32FromInt32(1))},
	1:  {Fupper: uint16(Int32FromInt32(0xc0)), Flower: int8(Int32FromInt32(0xe0) - Int32FromInt32(0xc0)), Flen1: uint8(Int32FromInt32(0xde) - Int32FromInt32(0xc0) + Int32FromInt32(1))},
	2:  {Fupper: uint16(Int32FromInt32(0x0100)), Flower: int8(Int32FromInt32(0x0100) + Int32FromInt32(1) - Int32FromInt32(0x0100)), Flen1: uint8(Int32FromInt32(0x012e) - Int32FromInt32(0x0100) + Int32FromInt32(1))},
	3:  {Fupper: uint16(Int32FromInt32(0x0132)), Flower: int8(Int32FromInt32(0x0132) + Int32FromInt32(1) - Int32FromInt32(0x0132)), Flen1: uint8(Int32FromInt32(0x0136) - Int32FromInt32(0x0132) + Int32FromInt32(1))},
	4:  {Fupper: uint16(Int32FromInt32(0x0139)), Flower: int8(Int32FromInt32(0x0139) + Int32FromInt32(1) - Int32FromInt32(0x0139)), Flen1: uint8(Int32FromInt32(0x0147) - Int32FromInt32(0x0139) + Int32FromInt32(1))},
	5:  {Fupper: uint16(Int32FromInt32(0x014a)), Flower: int8(Int32FromInt32(0x014a) + Int32FromInt32(1) - Int32FromInt32(0x014a)), Flen1: uint8(Int32FromInt32(0x0176) - Int32FromInt32(0x014a) + Int32FromInt32(1))},
	6:  {Fupper: uint16(Int32FromInt32(0x0179)), Flower: int8(Int32FromInt32(0x0179) + Int32FromInt32(1) - Int32FromInt32(0x0179)), Flen1: uint8(Int32FromInt32(0x017d) - Int32FromInt32(0x0179) + Int32FromInt32(1))},
	7:  {Fupper: uint16(Int32FromInt32(0x370)), Flower: int8(Int32FromInt32(0x370) + Int32FromInt32(1) - Int32FromInt32(0x370)), Flen1: uint8(Int32FromInt32(0x372) - Int32FromInt32(0x370) + Int32FromInt32(1))},
	8:  {Fupper: uint16(Int32FromInt32(0x391)), Flower: int8(Int32FromInt32(0x3b1) - Int32FromInt32(0x391)), Flen1: uint8(Int32FromInt32(0x3a1) - Int32FromInt32(0x391) + Int32FromInt32(1))},
	9:  {Fupper: uint16(Int32FromInt32(0x3a3)), Flower: int8(Int32FromInt32(0x3c3) - Int32FromInt32(0x3a3)), Flen1: uint8(Int32FromInt32(0x3ab) - Int32FromInt32(0x3a3) + Int32FromInt32(1))},
	10: {Fupper: uint16(Int32FromInt32(0x400)), Flower: int8(Int32FromInt32(0x450) - Int32FromInt32(0x400)), Flen1: uint8(Int32FromInt32(0x40f) - Int32FromInt32(0x400) + Int32FromInt32(1))},
	11: {Fupper: uint16(Int32FromInt32(0x410)), Flower: int8(Int32FromInt32(0x430) - Int32FromInt32(0x410)), Flen1: uint8(Int32FromInt32(0x42f) - Int32FromInt32(0x410) + Int32FromInt32(1))},
	12: {Fupper: uint16(Int32FromInt32(0x460)), Flower: int8(Int32FromInt32(0x460) + Int32FromInt32(1) - Int32FromInt32(0x460)), Flen1: uint8(Int32FromInt32(0x480) - Int32FromInt32(0x460) + Int32FromInt32(1))},
	13: {Fupper: uint16(Int32FromInt32(0x48a)), Flower: int8(Int32FromInt32(0x48a) + Int32FromInt32(1) - Int32FromInt32(0x48a)), Flen1: uint8(Int32FromInt32(0x4be) - Int32FromInt32(0x48a) + Int32FromInt32(1))},
	14: {Fupper: uint16(Int32FromInt32(0x4c1)), Flower: int8(Int32FromInt32(0x4c1) + Int32FromInt32(1) - Int32FromInt32(0x4c1)), Flen1: uint8(Int32FromInt32(0x4cd) - Int32FromInt32(0x4c1) + Int32FromInt32(1))},
	15: {Fupper: uint16(Int32FromInt32(0x4d0)), Flower: int8(Int32FromInt32(0x4d0) + Int32FromInt32(1) - Int32FromInt32(0x4d0)), Flen1: uint8(Int32FromInt32(0x50e) - Int32FromInt32(0x4d0) + Int32FromInt32(1))},
	16: {Fupper: uint16(Int32FromInt32(0x531)), Flower: int8(Int32FromInt32(0x561) - Int32FromInt32(0x531)), Flen1: uint8(Int32FromInt32(0x556) - Int32FromInt32(0x531) + Int32FromInt32(1))},
	17: {Fupper: uint16(Int32FromInt32(0x01a0)), Flower: int8(Int32FromInt32(0x01a0) + Int32FromInt32(1) - Int32FromInt32(0x01a0)), Flen1: uint8(Int32FromInt32(0x01a4) - Int32FromInt32(0x01a0) + Int32FromInt32(1))},
	18: {Fupper: uint16(Int32FromInt32(0x01b3)), Flower: int8(Int32FromInt32(0x01b3) + Int32FromInt32(1) - Int32FromInt32(0x01b3)), Flen1: uint8(Int32FromInt32(0x01b5) - Int32FromInt32(0x01b3) + Int32FromInt32(1))},
	19: {Fupper: uint16(Int32FromInt32(0x01cd)), Flower: int8(Int32FromInt32(0x01cd) + Int32FromInt32(1) - Int32FromInt32(0x01cd)), Flen1: uint8(Int32FromInt32(0x01db) - Int32FromInt32(0x01cd) + Int32FromInt32(1))},
	20: {Fupper: uint16(Int32FromInt32(0x01de)), Flower: int8(Int32FromInt32(0x01de) + Int32FromInt32(1) - Int32FromInt32(0x01de)), Flen1: uint8(Int32FromInt32(0x01ee) - Int32FromInt32(0x01de) + Int32FromInt32(1))},
	21: {Fupper: uint16(Int32FromInt32(0x01f8)), Flower: int8(Int32FromInt32(0x01f8) + Int32FromInt32(1) - Int32FromInt32(0x01f8)), Flen1: uint8(Int32FromInt32(0x021e) - Int32FromInt32(0x01f8) + Int32FromInt32(1))},
	22: {Fupper: uint16(Int32FromInt32(0x0222)), Flower: int8(Int32FromInt32(0x0222) + Int32FromInt32(1) - Int32FromInt32(0x0222)), Flen1: uint8(Int32FromInt32(0x0232) - Int32FromInt32(0x0222) + Int32FromInt32(1))},
	23: {Fupper: uint16(Int32FromInt32(0x03d8)), Flower: int8(Int32FromInt32(0x03d8) + Int32FromInt32(1) - Int32FromInt32(0x03d8)), Flen1: uint8(Int32FromInt32(0x03ee) - Int32FromInt32(0x03d8) + Int32FromInt32(1))},
	24: {Fupper: uint16(Int32FromInt32(0x1e00)), Flower: int8(Int32FromInt32(0x1e00) + Int32FromInt32(1) - Int32FromInt32(0x1e00)), Flen1: uint8(Int32FromInt32(0x1e94) - Int32FromInt32(0x1e00) + Int32FromInt32(1))},
	25: {Fupper: uint16(Int32FromInt32(0x1ea0)), Flower: int8(Int32FromInt32(0x1ea0) + Int32FromInt32(1) - Int32FromInt32(0x1ea0)), Flen1: uint8(Int32FromInt32(0x1efe) - Int32FromInt32(0x1ea0) + Int32FromInt32(1))},
	26: {Fupper: uint16(Int32FromInt32(0x1f08)), Flower: int8(Int32FromInt32(0x1f00) - Int32FromInt32(0x1f08)), Flen1: uint8(Int32FromInt32(0x1f0f) - Int32FromInt32(0x1f08) + Int32FromInt32(1))},
	27: {Fupper: uint16(Int32FromInt32(0x1f18)), Flower: int8(Int32FromInt32(0x1f10) - Int32FromInt32(0x1f18)), Flen1: uint8(Int32FromInt32(0x1f1d) - Int32FromInt32(0x1f18) + Int32FromInt32(1))},
	28: {Fupper: uint16(Int32FromInt32(0x1f28)), Flower: int8(Int32FromInt32(0x1f20) - Int32FromInt32(0x1f28)), Flen1: uint8(Int32FromInt32(0x1f2f) - Int32FromInt32(0x1f28) + Int32FromInt32(1))},
	29: {Fupper: uint16(Int32FromInt32(0x1f38)), Flower: int8(Int32FromInt32(0x1f30) - Int32FromInt32(0x1f38)), Flen1: uint8(Int32FromInt32(0x1f3f) - Int32FromInt32(0x1f38) + Int32FromInt32(1))},
	30: {Fupper: uint16(Int32FromInt32(0x1f48)), Flower: int8(Int32FromInt32(0x1f40) - Int32FromInt32(0x1f48)), Flen1: uint8(Int32FromInt32(0x1f4d) - Int32FromInt32(0x1f48) + Int32FromInt32(1))},
	31: {Fupper: uint16(Int32FromInt32(0x1f68)), Flower: int8(Int32FromInt32(0x1f60) - Int32FromInt32(0x1f68)), Flen1: uint8(Int32FromInt32(0x1f6f) - Int32FromInt32(0x1f68) + Int32FromInt32(1))},
	32: {Fupper: uint16(Int32FromInt32(0x1f88)), Flower: int8(Int32FromInt32(0x1f80) - Int32FromInt32(0x1f88)), Flen1: uint8(Int32FromInt32(0x1f8f) - Int32FromInt32(0x1f88) + Int32FromInt32(1))},
	33: {Fupper: uint16(Int32FromInt32(0x1f98)), Flower: int8(Int32FromInt32(0x1f90) - Int32FromInt32(0x1f98)), Flen1: uint8(Int32FromInt32(0x1f9f) - Int32FromInt32(0x1f98) + Int32FromInt32(1))},
	34: {Fupper: uint16(Int32FromInt32(0x1fa8)), Flower: int8(Int32FromInt32(0x1fa0) - Int32FromInt32(0x1fa8)), Flen1: uint8(Int32FromInt32(0x1faf) - Int32FromInt32(0x1fa8) + Int32FromInt32(1))},
	35: {Fupper: uint16(Int32FromInt32(0x1fb8)), Flower: int8(Int32FromInt32(0x1fb0) - Int32FromInt32(0x1fb8)), Flen1: uint8(Int32FromInt32(0x1fb9) - Int32FromInt32(0x1fb8) + Int32FromInt32(1))},
	36: {Fupper: uint16(Int32FromInt32(0x1fba)), Flower: int8(Int32FromInt32(0x1f70) - Int32FromInt32(0x1fba)), Flen1: uint8(Int32FromInt32(0x1fbb) - Int32FromInt32(0x1fba) + Int32FromInt32(1))},
	37: {Fupper: uint16(Int32FromInt32(0x1fc8)), Flower: int8(Int32FromInt32(0x1f72) - Int32FromInt32(0x1fc8)), Flen1: uint8(Int32FromInt32(0x1fcb) - Int32FromInt32(0x1fc8) + Int32FromInt32(1))},
	38: {Fupper: uint16(Int32FromInt32(0x1fd8)), Flower: int8(Int32FromInt32(0x1fd0) - Int32FromInt32(0x1fd8)), Flen1: uint8(Int32FromInt32(0x1fd9) - Int32FromInt32(0x1fd8) + Int32FromInt32(1))},
	39: {Fupper: uint16(Int32FromInt32(0x1fda)), Flower: int8(Int32FromInt32(0x1f76) - Int32FromInt32(0x1fda)), Flen1: uint8(Int32FromInt32(0x1fdb) - Int32FromInt32(0x1fda) + Int32FromInt32(1))},
	40: {Fupper: uint16(Int32FromInt32(0x1fe8)), Flower: int8(Int32FromInt32(0x1fe0) - Int32FromInt32(0x1fe8)), Flen1: uint8(Int32FromInt32(0x1fe9) - Int32FromInt32(0x1fe8) + Int32FromInt32(1))},
	41: {Fupper: uint16(Int32FromInt32(0x1fea)), Flower: int8(Int32FromInt32(0x1f7a) - Int32FromInt32(0x1fea)), Flen1: uint8(Int32FromInt32(0x1feb) - Int32FromInt32(0x1fea) + Int32FromInt32(1))},
	42: {Fupper: uint16(Int32FromInt32(0x1ff8)), Flower: int8(Int32FromInt32(0x1f78) - Int32FromInt32(0x1ff8)), Flen1: uint8(Int32FromInt32(0x1ff9) - Int32FromInt32(0x1ff8) + Int32FromInt32(1))},
	43: {Fupper: uint16(Int32FromInt32(0x1ffa)), Flower: int8(Int32FromInt32(0x1f7c) - Int32FromInt32(0x1ffa)), Flen1: uint8(Int32FromInt32(0x1ffb) - Int32FromInt32(0x1ffa) + Int32FromInt32(1))},
	44: {Fupper: uint16(Int32FromInt32(0x246)), Flower: int8(Int32FromInt32(0x246) + Int32FromInt32(1) - Int32FromInt32(0x246)), Flen1: uint8(Int32FromInt32(0x24e) - Int32FromInt32(0x246) + Int32FromInt32(1))},
	45: {Fupper: uint16(Int32FromInt32(0x510)), Flower: int8(Int32FromInt32(0x510) + Int32FromInt32(1) - Int32FromInt32(0x510)), Flen1: uint8(Int32FromInt32(0x512) - Int32FromInt32(0x510) + Int32FromInt32(1))},
	46: {Fupper: uint16(Int32FromInt32(0x2160)), Flower: int8(Int32FromInt32(0x2170) - Int32FromInt32(0x2160)), Flen1: uint8(Int32FromInt32(0x216f) - Int32FromInt32(0x2160) + Int32FromInt32(1))},
	47: {Fupper: uint16(Int32FromInt32(0x2c00)), Flower: int8(Int32FromInt32(0x2c30) - Int32FromInt32(0x2c00)), Flen1: uint8(Int32FromInt32(0x2c2e) - Int32FromInt32(0x2c00) + Int32FromInt32(1))},
	48: {Fupper: uint16(Int32FromInt32(0x2c67)), Flower: int8(Int32FromInt32(0x2c67) + Int32FromInt32(1) - Int32FromInt32(0x2c67)), Flen1: uint8(Int32FromInt32(0x2c6b) - Int32FromInt32(0x2c67) + Int32FromInt32(1))},
	49: {Fupper: uint16(Int32FromInt32(0x2c80)), Flower: int8(Int32FromInt32(0x2c80) + Int32FromInt32(1) - Int32FromInt32(0x2c80)), Flen1: uint8(Int32FromInt32(0x2ce2) - Int32FromInt32(0x2c80) + Int32FromInt32(1))},
	50: {Fupper: uint16(Int32FromInt32(0xa722)), Flower: int8(Int32FromInt32(0xa722) + Int32FromInt32(1) - Int32FromInt32(0xa722)), Flen1: uint8(Int32FromInt32(0xa72e) - Int32FromInt32(0xa722) + Int32FromInt32(1))},
	51: {Fupper: uint16(Int32FromInt32(0xa732)), Flower: int8(Int32FromInt32(0xa732) + Int32FromInt32(1) - Int32FromInt32(0xa732)), Flen1: uint8(Int32FromInt32(0xa76e) - Int32FromInt32(0xa732) + Int32FromInt32(1))},
	52: {Fupper: uint16(Int32FromInt32(0xa779)), Flower: int8(Int32FromInt32(0xa779) + Int32FromInt32(1) - Int32FromInt32(0xa779)), Flen1: uint8(Int32FromInt32(0xa77b) - Int32FromInt32(0xa779) + Int32FromInt32(1))},
	53: {Fupper: uint16(Int32FromInt32(0xa77e)), Flower: int8(Int32FromInt32(0xa77e) + Int32FromInt32(1) - Int32FromInt32(0xa77e)), Flen1: uint8(Int32FromInt32(0xa786) - Int32FromInt32(0xa77e) + Int32FromInt32(1))},
	54: {Fupper: uint16(Int32FromInt32(0xff21)), Flower: int8(Int32FromInt32(0xff41) - Int32FromInt32(0xff21)), Flen1: uint8(Int32FromInt32(0xff3a) - Int32FromInt32(0xff21) + Int32FromInt32(1))},
	55: {}}

var _pairs = [112][2]uint16{
	0: {
		0: uint16('I'),
		1: uint16(0x0131)},
	1: {
		0: uint16('S'),
		1: uint16(0x017f)},
	2: {
		0: uint16(0x0130),
		1: uint16('i')},
	3: {
		0: uint16(0x0178),
		1: uint16(0x00ff)},
	4: {
		0: uint16(0x0181),
		1: uint16(0x0253)},
	5: {
		0: uint16(0x0182),
		1: uint16(0x0183)},
	6: {
		0: uint16(0x0184),
		1: uint16(0x0185)},
	7: {
		0: uint16(0x0186),
		1: uint16(0x0254)},
	8: {
		0: uint16(0x0187),
		1: uint16(0x0188)},
	9: {
		0: uint16(0x0189),
		1: uint16(0x0256)},
	10: {
		0: uint16(0x018a),
		1: uint16(0x0257)},
	11: {
		0: uint16(0x018b),
		1: uint16(0x018c)},
	12: {
		0: uint16(0x018e),
		1: uint16(0x01dd)},
	13: {
		0: uint16(0x018f),
		1: uint16(0x0259)},
	14: {
		0: uint16(0x0190),
		1: uint16(0x025b)},
	15: {
		0: uint16(0x0191),
		1: uint16(0x0192)},
	16: {
		0: uint16(0x0193),
		1: uint16(0x0260)},
	17: {
		0: uint16(0x0194),
		1: uint16(0x0263)},
	18: {
		0: uint16(0x0196),
		1: uint16(0x0269)},
	19: {
		0: uint16(0x0197),
		1: uint16(0x0268)},
	20: {
		0: uint16(0x0198),
		1: uint16(0x0199)},
	21: {
		0: uint16(0x019c),
		1: uint16(0x026f)},
	22: {
		0: uint16(0x019d),
		1: uint16(0x0272)},
	23: {
		0: uint16(0x019f),
		1: uint16(0x0275)},
	24: {
		0: uint16(0x01a6),
		1: uint16(0x0280)},
	25: {
		0: uint16(0x01a7),
		1: uint16(0x01a8)},
	26: {
		0: uint16(0x01a9),
		1: uint16(0x0283)},
	27: {
		0: uint16(0x01ac),
		1: uint16(0x01ad)},
	28: {
		0: uint16(0x01ae),
		1: uint16(0x0288)},
	29: {
		0: uint16(0x01af),
		1: uint16(0x01b0)},
	30: {
		0: uint16(0x01b1),
		1: uint16(0x028a)},
	31: {
		0: uint16(0x01b2),
		1: uint16(0x028b)},
	32: {
		0: uint16(0x01b7),
		1: uint16(0x0292)},
	33: {
		0: uint16(0x01b8),
		1: uint16(0x01b9)},
	34: {
		0: uint16(0x01bc),
		1: uint16(0x01bd)},
	35: {
		0: uint16(0x01c4),
		1: uint16(0x01c6)},
	36: {
		0: uint16(0x01c4),
		1: uint16(0x01c5)},
	37: {
		0: uint16(0x01c5),
		1: uint16(0x01c6)},
	38: {
		0: uint16(0x01c7),
		1: uint16(0x01c9)},
	39: {
		0: uint16(0x01c7),
		1: uint16(0x01c8)},
	40: {
		0: uint16(0x01c8),
		1: uint16(0x01c9)},
	41: {
		0: uint16(0x01ca),
		1: uint16(0x01cc)},
	42: {
		0: uint16(0x01ca),
		1: uint16(0x01cb)},
	43: {
		0: uint16(0x01cb),
		1: uint16(0x01cc)},
	44: {
		0: uint16(0x01f1),
		1: uint16(0x01f3)},
	45: {
		0: uint16(0x01f1),
		1: uint16(0x01f2)},
	46: {
		0: uint16(0x01f2),
		1: uint16(0x01f3)},
	47: {
		0: uint16(0x01f4),
		1: uint16(0x01f5)},
	48: {
		0: uint16(0x01f6),
		1: uint16(0x0195)},
	49: {
		0: uint16(0x01f7),
		1: uint16(0x01bf)},
	50: {
		0: uint16(0x0220),
		1: uint16(0x019e)},
	51: {
		0: uint16(0x0386),
		1: uint16(0x03ac)},
	52: {
		0: uint16(0x0388),
		1: uint16(0x03ad)},
	53: {
		0: uint16(0x0389),
		1: uint16(0x03ae)},
	54: {
		0: uint16(0x038a),
		1: uint16(0x03af)},
	55: {
		0: uint16(0x038c),
		1: uint16(0x03cc)},
	56: {
		0: uint16(0x038e),
		1: uint16(0x03cd)},
	57: {
		0: uint16(0x038f),
		1: uint16(0x03ce)},
	58: {
		0: uint16(0x0399),
		1: uint16(0x0345)},
	59: {
		0: uint16(0x0399),
		1: uint16(0x1fbe)},
	60: {
		0: uint16(0x03a3),
		1: uint16(0x03c2)},
	61: {
		0: uint16(0x03f7),
		1: uint16(0x03f8)},
	62: {
		0: uint16(0x03fa),
		1: uint16(0x03fb)},
	63: {
		0: uint16(0x1e60),
		1: uint16(0x1e9b)},
	64: {
		0: uint16(0x1f59),
		1: uint16(0x1f51)},
	65: {
		0: uint16(0x1f5b),
		1: uint16(0x1f53)},
	66: {
		0: uint16(0x1f5d),
		1: uint16(0x1f55)},
	67: {
		0: uint16(0x1f5f),
		1: uint16(0x1f57)},
	68: {
		0: uint16(0x1fbc),
		1: uint16(0x1fb3)},
	69: {
		0: uint16(0x1fcc),
		1: uint16(0x1fc3)},
	70: {
		0: uint16(0x1fec),
		1: uint16(0x1fe5)},
	71: {
		0: uint16(0x1ffc),
		1: uint16(0x1ff3)},
	72: {
		0: uint16(0x23a),
		1: uint16(0x2c65)},
	73: {
		0: uint16(0x23b),
		1: uint16(0x23c)},
	74: {
		0: uint16(0x23d),
		1: uint16(0x19a)},
	75: {
		0: uint16(0x23e),
		1: uint16(0x2c66)},
	76: {
		0: uint16(0x241),
		1: uint16(0x242)},
	77: {
		0: uint16(0x243),
		1: uint16(0x180)},
	78: {
		0: uint16(0x244),
		1: uint16(0x289)},
	79: {
		0: uint16(0x245),
		1: uint16(0x28c)},
	80: {
		0: uint16(0x3f4),
		1: uint16(0x3b8)},
	81: {
		0: uint16(0x3f9),
		1: uint16(0x3f2)},
	82: {
		0: uint16(0x3fd),
		1: uint16(0x37b)},
	83: {
		0: uint16(0x3fe),
		1: uint16(0x37c)},
	84: {
		0: uint16(0x3ff),
		1: uint16(0x37d)},
	85: {
		0: uint16(0x4c0),
		1: uint16(0x4cf)},
	86: {
		0: uint16(0x2126),
		1: uint16(0x3c9)},
	87: {
		0: uint16(0x212a),
		1: uint16('k')},
	88: {
		0: uint16(0x212b),
		1: uint16(0xe5)},
	89: {
		0: uint16(0x2132),
		1: uint16(0x214e)},
	90: {
		0: uint16(0x2183),
		1: uint16(0x2184)},
	91: {
		0: uint16(0x2c60),
		1: uint16(0x2c61)},
	92: {
		0: uint16(0x2c62),
		1: uint16(0x26b)},
	93: {
		0: uint16(0x2c63),
		1: uint16(0x1d7d)},
	94: {
		0: uint16(0x2c64),
		1: uint16(0x27d)},
	95: {
		0: uint16(0x2c6d),
		1: uint16(0x251)},
	96: {
		0: uint16(0x2c6e),
		1: uint16(0x271)},
	97: {
		0: uint16(0x2c6f),
		1: uint16(0x250)},
	98: {
		0: uint16(0x2c72),
		1: uint16(0x2c73)},
	99: {
		0: uint16(0x2c75),
		1: uint16(0x2c76)},
	100: {
		0: uint16(0xa77d),
		1: uint16(0x1d79)},
	101: {
		0: uint16(0x376),
		1: uint16(0x377)},
	102: {
		0: uint16(0x39c),
		1: uint16(0xb5)},
	103: {
		0: uint16(0x392),
		1: uint16(0x3d0)},
	104: {
		0: uint16(0x398),
		1: uint16(0x3d1)},
	105: {
		0: uint16(0x3a6),
		1: uint16(0x3d5)},
	106: {
		0: uint16(0x3a0),
		1: uint16(0x3d6)},
	107: {
		0: uint16(0x39a),
		1: uint16(0x3f0)},
	108: {
		0: uint16(0x3a1),
		1: uint16(0x3f1)},
	109: {
		0: uint16(0x395),
		1: uint16(0x3f5)},
	110: {
		0: uint16(0x3cf),
		1: uint16(0x3d7)},
	111: {}}

func ___towcase(tls *TLS, wc int32, lower int32) (r int32) {
	var base, i, lmask, lmul int32
	lmul = int32(2)*lower - int32(1)
	lmask = lower - int32(1)
	if uint32(wc)-uint32(0x10400) < uint32(0x50) {
		return wc + lmul*int32(0x28)
	}
	/* no letters with case in these large ranges */
	if !(x_iswalpha(tls, wc) != 0) || uint32(wc)-uint32(0x0600) <= uint32(Int32FromInt32(0x0fff)-Int32FromInt32(0x0600)) || uint32(wc)-uint32(0x2e00) <= uint32(Int32FromInt32(0xa6ff)-Int32FromInt32(0x2e00)) || uint32(wc)-uint32(0xa800) <= uint32(Int32FromInt32(0xfeff)-Int32FromInt32(0xa800)) {
		return wc
	}
	/* special case because the diff between upper/lower is too big */
	if uint32(wc)-uint32(0x10a0) < uint32(0x26) || uint32(wc)-uint32(0x2d00) < uint32(0x26) {
		return wc + lmul*(Int32FromInt32(0x2d00)-Int32FromInt32(0x10a0))
	}
	for i = 0; _casemaps[i].Flen1 != 0; i++ {
		base = int32(_casemaps[i].Fupper) + lmask&int32(_casemaps[i].Flower)
		if uint32(wc)-uint32(base) < uint32(_casemaps[i].Flen1) {
			if int32(_casemaps[i].Flower) == int32(1) {
				return wc + lower - (wc-int32(_casemaps[i].Fupper))&int32(1)
			}
			return wc + lmul*int32(_casemaps[i].Flower)
		}
	}
	for i = 0; *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_pairs)) + uintptr(i)*4 + uintptr(int32(1)-lower)*2)) != 0; i++ {
		if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_pairs)) + uintptr(i)*4 + uintptr(int32(1)-lower)*2))) == wc {
			return int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_pairs)) + uintptr(i)*4 + uintptr(lower)*2)))
		}
	}
	if uint32(wc)-uint32(0x10428)+uint32(lower<<Int32FromInt32(5))+uint32(lower<<Int32FromInt32(3)) < uint32(0x28) {
		return wc - int32(0x28) + lower<<int32(10) + lower<<int32(6)
	}
	return wc
}

func x_towupper(tls *TLS, wc int32) (r int32) {
	return ___towcase(tls, wc, 0)
}

func x_towlower(tls *TLS, wc int32) (r int32) {
	return ___towcase(tls, wc, int32(1))
}

func x_wcswidth(tls *TLS, wcs uintptr, n uint64) (r int32) {
	var k, l, v2, v5 int32
	var v1 uint64
	var v3 bool
	l = 0
	k = 0
	for {
		v1 = n
		n--
		if v3 = v1 != 0 && *(*int32)(unsafe.Pointer(wcs)) != 0; v3 {
			v2 = x_wcwidth(tls, *(*int32)(unsafe.Pointer(wcs)))
			k = v2
		}
		if !(v3 && v2 >= 0) {
			break
		}
		goto _4
	_4:
		l += k
		wcs += 4
	}
	if k < 0 {
		v5 = k
	} else {
		v5 = l
	}
	return v5
}

func x_wctrans(tls *TLS, class uintptr) (r int32) {
	if !(x_strcmp(tls, class, ts+18) != 0) {
		return int32(1)
	}
	if !(x_strcmp(tls, class, ts+26) != 0) {
		return int32(2)
	}
	return 0
}

func x_towctrans(tls *TLS, wc int32, trans int32) (r int32) {
	if trans == int32(1) {
		return x_towupper(tls, wc)
	}
	if trans == int32(2) {
		return x_towlower(tls, wc)
	}
	return wc
}

var _ranges1 = [149]Trange{
	0:   {F__ccgo0: uint32(Int32FromInt32(0x036F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x036F)-Int32FromInt32(0x0300))&0x7ff<<21},
	1:   {F__ccgo0: uint32(Int32FromInt32(0x0486))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0486)-Int32FromInt32(0x0483))&0x7ff<<21},
	2:   {F__ccgo0: uint32(Int32FromInt32(0x0489))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0489)-Int32FromInt32(0x0488))&0x7ff<<21},
	3:   {F__ccgo0: uint32(Int32FromInt32(0x05BD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x05BD)-Int32FromInt32(0x0591))&0x7ff<<21},
	4:   {F__ccgo0: uint32(Int32FromInt32(0x05BF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x05BF)-Int32FromInt32(0x05BF))&0x7ff<<21},
	5:   {F__ccgo0: uint32(Int32FromInt32(0x05C2))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x05C2)-Int32FromInt32(0x05C1))&0x7ff<<21},
	6:   {F__ccgo0: uint32(Int32FromInt32(0x05C5))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x05C5)-Int32FromInt32(0x05C4))&0x7ff<<21},
	7:   {F__ccgo0: uint32(Int32FromInt32(0x05C7))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x05C7)-Int32FromInt32(0x05C7))&0x7ff<<21},
	8:   {F__ccgo0: uint32(Int32FromInt32(0x0603))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0603)-Int32FromInt32(0x0600))&0x7ff<<21},
	9:   {F__ccgo0: uint32(Int32FromInt32(0x0615))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0615)-Int32FromInt32(0x0610))&0x7ff<<21},
	10:  {F__ccgo0: uint32(Int32FromInt32(0x065E))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x065E)-Int32FromInt32(0x064B))&0x7ff<<21},
	11:  {F__ccgo0: uint32(Int32FromInt32(0x0670))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0670)-Int32FromInt32(0x0670))&0x7ff<<21},
	12:  {F__ccgo0: uint32(Int32FromInt32(0x06E4))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x06E4)-Int32FromInt32(0x06D6))&0x7ff<<21},
	13:  {F__ccgo0: uint32(Int32FromInt32(0x06E8))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x06E8)-Int32FromInt32(0x06E7))&0x7ff<<21},
	14:  {F__ccgo0: uint32(Int32FromInt32(0x06ED))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x06ED)-Int32FromInt32(0x06EA))&0x7ff<<21},
	15:  {F__ccgo0: uint32(Int32FromInt32(0x070F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x070F)-Int32FromInt32(0x070F))&0x7ff<<21},
	16:  {F__ccgo0: uint32(Int32FromInt32(0x0711))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0711)-Int32FromInt32(0x0711))&0x7ff<<21},
	17:  {F__ccgo0: uint32(Int32FromInt32(0x074A))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x074A)-Int32FromInt32(0x0730))&0x7ff<<21},
	18:  {F__ccgo0: uint32(Int32FromInt32(0x07B0))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x07B0)-Int32FromInt32(0x07A6))&0x7ff<<21},
	19:  {F__ccgo0: uint32(Int32FromInt32(0x07F3))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x07F3)-Int32FromInt32(0x07EB))&0x7ff<<21},
	20:  {F__ccgo0: uint32(Int32FromInt32(0x0902))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0902)-Int32FromInt32(0x0901))&0x7ff<<21},
	21:  {F__ccgo0: uint32(Int32FromInt32(0x093C))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x093C)-Int32FromInt32(0x093C))&0x7ff<<21},
	22:  {F__ccgo0: uint32(Int32FromInt32(0x0948))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0948)-Int32FromInt32(0x0941))&0x7ff<<21},
	23:  {F__ccgo0: uint32(Int32FromInt32(0x094D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x094D)-Int32FromInt32(0x094D))&0x7ff<<21},
	24:  {F__ccgo0: uint32(Int32FromInt32(0x0954))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0954)-Int32FromInt32(0x0951))&0x7ff<<21},
	25:  {F__ccgo0: uint32(Int32FromInt32(0x0963))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0963)-Int32FromInt32(0x0962))&0x7ff<<21},
	26:  {F__ccgo0: uint32(Int32FromInt32(0x0981))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0981)-Int32FromInt32(0x0981))&0x7ff<<21},
	27:  {F__ccgo0: uint32(Int32FromInt32(0x09BC))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x09BC)-Int32FromInt32(0x09BC))&0x7ff<<21},
	28:  {F__ccgo0: uint32(Int32FromInt32(0x09C4))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x09C4)-Int32FromInt32(0x09C1))&0x7ff<<21},
	29:  {F__ccgo0: uint32(Int32FromInt32(0x09CD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x09CD)-Int32FromInt32(0x09CD))&0x7ff<<21},
	30:  {F__ccgo0: uint32(Int32FromInt32(0x09E3))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x09E3)-Int32FromInt32(0x09E2))&0x7ff<<21},
	31:  {F__ccgo0: uint32(Int32FromInt32(0x0A02))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A02)-Int32FromInt32(0x0A01))&0x7ff<<21},
	32:  {F__ccgo0: uint32(Int32FromInt32(0x0A3C))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A3C)-Int32FromInt32(0x0A3C))&0x7ff<<21},
	33:  {F__ccgo0: uint32(Int32FromInt32(0x0A42))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A42)-Int32FromInt32(0x0A41))&0x7ff<<21},
	34:  {F__ccgo0: uint32(Int32FromInt32(0x0A48))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A48)-Int32FromInt32(0x0A47))&0x7ff<<21},
	35:  {F__ccgo0: uint32(Int32FromInt32(0x0A4D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A4D)-Int32FromInt32(0x0A4B))&0x7ff<<21},
	36:  {F__ccgo0: uint32(Int32FromInt32(0x0A71))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A71)-Int32FromInt32(0x0A70))&0x7ff<<21},
	37:  {F__ccgo0: uint32(Int32FromInt32(0x0A82))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0A82)-Int32FromInt32(0x0A81))&0x7ff<<21},
	38:  {F__ccgo0: uint32(Int32FromInt32(0x0ABC))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0ABC)-Int32FromInt32(0x0ABC))&0x7ff<<21},
	39:  {F__ccgo0: uint32(Int32FromInt32(0x0AC5))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0AC5)-Int32FromInt32(0x0AC1))&0x7ff<<21},
	40:  {F__ccgo0: uint32(Int32FromInt32(0x0AC8))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0AC8)-Int32FromInt32(0x0AC7))&0x7ff<<21},
	41:  {F__ccgo0: uint32(Int32FromInt32(0x0ACD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0ACD)-Int32FromInt32(0x0ACD))&0x7ff<<21},
	42:  {F__ccgo0: uint32(Int32FromInt32(0x0AE3))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0AE3)-Int32FromInt32(0x0AE2))&0x7ff<<21},
	43:  {F__ccgo0: uint32(Int32FromInt32(0x0B01))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B01)-Int32FromInt32(0x0B01))&0x7ff<<21},
	44:  {F__ccgo0: uint32(Int32FromInt32(0x0B3C))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B3C)-Int32FromInt32(0x0B3C))&0x7ff<<21},
	45:  {F__ccgo0: uint32(Int32FromInt32(0x0B3F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B3F)-Int32FromInt32(0x0B3F))&0x7ff<<21},
	46:  {F__ccgo0: uint32(Int32FromInt32(0x0B43))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B43)-Int32FromInt32(0x0B41))&0x7ff<<21},
	47:  {F__ccgo0: uint32(Int32FromInt32(0x0B4D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B4D)-Int32FromInt32(0x0B4D))&0x7ff<<21},
	48:  {F__ccgo0: uint32(Int32FromInt32(0x0B56))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B56)-Int32FromInt32(0x0B56))&0x7ff<<21},
	49:  {F__ccgo0: uint32(Int32FromInt32(0x0B82))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0B82)-Int32FromInt32(0x0B82))&0x7ff<<21},
	50:  {F__ccgo0: uint32(Int32FromInt32(0x0BC0))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0BC0)-Int32FromInt32(0x0BC0))&0x7ff<<21},
	51:  {F__ccgo0: uint32(Int32FromInt32(0x0BCD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0BCD)-Int32FromInt32(0x0BCD))&0x7ff<<21},
	52:  {F__ccgo0: uint32(Int32FromInt32(0x0C40))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0C40)-Int32FromInt32(0x0C3E))&0x7ff<<21},
	53:  {F__ccgo0: uint32(Int32FromInt32(0x0C48))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0C48)-Int32FromInt32(0x0C46))&0x7ff<<21},
	54:  {F__ccgo0: uint32(Int32FromInt32(0x0C4D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0C4D)-Int32FromInt32(0x0C4A))&0x7ff<<21},
	55:  {F__ccgo0: uint32(Int32FromInt32(0x0C56))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0C56)-Int32FromInt32(0x0C55))&0x7ff<<21},
	56:  {F__ccgo0: uint32(Int32FromInt32(0x0CBC))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0CBC)-Int32FromInt32(0x0CBC))&0x7ff<<21},
	57:  {F__ccgo0: uint32(Int32FromInt32(0x0CBF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0CBF)-Int32FromInt32(0x0CBF))&0x7ff<<21},
	58:  {F__ccgo0: uint32(Int32FromInt32(0x0CC6))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0CC6)-Int32FromInt32(0x0CC6))&0x7ff<<21},
	59:  {F__ccgo0: uint32(Int32FromInt32(0x0CCD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0CCD)-Int32FromInt32(0x0CCC))&0x7ff<<21},
	60:  {F__ccgo0: uint32(Int32FromInt32(0x0CE3))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0CE3)-Int32FromInt32(0x0CE2))&0x7ff<<21},
	61:  {F__ccgo0: uint32(Int32FromInt32(0x0D43))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0D43)-Int32FromInt32(0x0D41))&0x7ff<<21},
	62:  {F__ccgo0: uint32(Int32FromInt32(0x0D4D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0D4D)-Int32FromInt32(0x0D4D))&0x7ff<<21},
	63:  {F__ccgo0: uint32(Int32FromInt32(0x0DCA))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0DCA)-Int32FromInt32(0x0DCA))&0x7ff<<21},
	64:  {F__ccgo0: uint32(Int32FromInt32(0x0DD4))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0DD4)-Int32FromInt32(0x0DD2))&0x7ff<<21},
	65:  {F__ccgo0: uint32(Int32FromInt32(0x0DD6))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0DD6)-Int32FromInt32(0x0DD6))&0x7ff<<21},
	66:  {F__ccgo0: uint32(Int32FromInt32(0x0E31))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0E31)-Int32FromInt32(0x0E31))&0x7ff<<21},
	67:  {F__ccgo0: uint32(Int32FromInt32(0x0E3A))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0E3A)-Int32FromInt32(0x0E34))&0x7ff<<21},
	68:  {F__ccgo0: uint32(Int32FromInt32(0x0E4E))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0E4E)-Int32FromInt32(0x0E47))&0x7ff<<21},
	69:  {F__ccgo0: uint32(Int32FromInt32(0x0EB1))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0EB1)-Int32FromInt32(0x0EB1))&0x7ff<<21},
	70:  {F__ccgo0: uint32(Int32FromInt32(0x0EB9))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0EB9)-Int32FromInt32(0x0EB4))&0x7ff<<21},
	71:  {F__ccgo0: uint32(Int32FromInt32(0x0EBC))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0EBC)-Int32FromInt32(0x0EBB))&0x7ff<<21},
	72:  {F__ccgo0: uint32(Int32FromInt32(0x0ECD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0ECD)-Int32FromInt32(0x0EC8))&0x7ff<<21},
	73:  {F__ccgo0: uint32(Int32FromInt32(0x0F19))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F19)-Int32FromInt32(0x0F18))&0x7ff<<21},
	74:  {F__ccgo0: uint32(Int32FromInt32(0x0F35))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F35)-Int32FromInt32(0x0F35))&0x7ff<<21},
	75:  {F__ccgo0: uint32(Int32FromInt32(0x0F37))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F37)-Int32FromInt32(0x0F37))&0x7ff<<21},
	76:  {F__ccgo0: uint32(Int32FromInt32(0x0F39))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F39)-Int32FromInt32(0x0F39))&0x7ff<<21},
	77:  {F__ccgo0: uint32(Int32FromInt32(0x0F7E))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F7E)-Int32FromInt32(0x0F71))&0x7ff<<21},
	78:  {F__ccgo0: uint32(Int32FromInt32(0x0F84))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F84)-Int32FromInt32(0x0F80))&0x7ff<<21},
	79:  {F__ccgo0: uint32(Int32FromInt32(0x0F87))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F87)-Int32FromInt32(0x0F86))&0x7ff<<21},
	80:  {F__ccgo0: uint32(Int32FromInt32(0x0F97))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0F97)-Int32FromInt32(0x0F90))&0x7ff<<21},
	81:  {F__ccgo0: uint32(Int32FromInt32(0x0FBC))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0FBC)-Int32FromInt32(0x0F99))&0x7ff<<21},
	82:  {F__ccgo0: uint32(Int32FromInt32(0x0FC6))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x0FC6)-Int32FromInt32(0x0FC6))&0x7ff<<21},
	83:  {F__ccgo0: uint32(Int32FromInt32(0x1030))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1030)-Int32FromInt32(0x102D))&0x7ff<<21},
	84:  {F__ccgo0: uint32(Int32FromInt32(0x1032))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1032)-Int32FromInt32(0x1032))&0x7ff<<21},
	85:  {F__ccgo0: uint32(Int32FromInt32(0x1037))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1037)-Int32FromInt32(0x1036))&0x7ff<<21},
	86:  {F__ccgo0: uint32(Int32FromInt32(0x1039))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1039)-Int32FromInt32(0x1039))&0x7ff<<21},
	87:  {F__ccgo0: uint32(Int32FromInt32(0x1059))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1059)-Int32FromInt32(0x1058))&0x7ff<<21},
	88:  {F__ccgo0: uint32(Int32FromInt32(0x115F))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x115F)-Int32FromInt32(0x1100))&0x7ff<<21},
	89:  {F__ccgo0: uint32(Int32FromInt32(0x11FF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x11FF)-Int32FromInt32(0x1160))&0x7ff<<21},
	90:  {F__ccgo0: uint32(Int32FromInt32(0x135F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x135F)-Int32FromInt32(0x135F))&0x7ff<<21},
	91:  {F__ccgo0: uint32(Int32FromInt32(0x1714))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1714)-Int32FromInt32(0x1712))&0x7ff<<21},
	92:  {F__ccgo0: uint32(Int32FromInt32(0x1734))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1734)-Int32FromInt32(0x1732))&0x7ff<<21},
	93:  {F__ccgo0: uint32(Int32FromInt32(0x1753))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1753)-Int32FromInt32(0x1752))&0x7ff<<21},
	94:  {F__ccgo0: uint32(Int32FromInt32(0x1773))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1773)-Int32FromInt32(0x1772))&0x7ff<<21},
	95:  {F__ccgo0: uint32(Int32FromInt32(0x17B5))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x17B5)-Int32FromInt32(0x17B4))&0x7ff<<21},
	96:  {F__ccgo0: uint32(Int32FromInt32(0x17BD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x17BD)-Int32FromInt32(0x17B7))&0x7ff<<21},
	97:  {F__ccgo0: uint32(Int32FromInt32(0x17C6))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x17C6)-Int32FromInt32(0x17C6))&0x7ff<<21},
	98:  {F__ccgo0: uint32(Int32FromInt32(0x17D3))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x17D3)-Int32FromInt32(0x17C9))&0x7ff<<21},
	99:  {F__ccgo0: uint32(Int32FromInt32(0x17DD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x17DD)-Int32FromInt32(0x17DD))&0x7ff<<21},
	100: {F__ccgo0: uint32(Int32FromInt32(0x180D))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x180D)-Int32FromInt32(0x180B))&0x7ff<<21},
	101: {F__ccgo0: uint32(Int32FromInt32(0x18A9))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x18A9)-Int32FromInt32(0x18A9))&0x7ff<<21},
	102: {F__ccgo0: uint32(Int32FromInt32(0x1922))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1922)-Int32FromInt32(0x1920))&0x7ff<<21},
	103: {F__ccgo0: uint32(Int32FromInt32(0x1928))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1928)-Int32FromInt32(0x1927))&0x7ff<<21},
	104: {F__ccgo0: uint32(Int32FromInt32(0x1932))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1932)-Int32FromInt32(0x1932))&0x7ff<<21},
	105: {F__ccgo0: uint32(Int32FromInt32(0x193B))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x193B)-Int32FromInt32(0x1939))&0x7ff<<21},
	106: {F__ccgo0: uint32(Int32FromInt32(0x1A18))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1A18)-Int32FromInt32(0x1A17))&0x7ff<<21},
	107: {F__ccgo0: uint32(Int32FromInt32(0x1B03))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B03)-Int32FromInt32(0x1B00))&0x7ff<<21},
	108: {F__ccgo0: uint32(Int32FromInt32(0x1B34))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B34)-Int32FromInt32(0x1B34))&0x7ff<<21},
	109: {F__ccgo0: uint32(Int32FromInt32(0x1B3A))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B3A)-Int32FromInt32(0x1B36))&0x7ff<<21},
	110: {F__ccgo0: uint32(Int32FromInt32(0x1B3C))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B3C)-Int32FromInt32(0x1B3C))&0x7ff<<21},
	111: {F__ccgo0: uint32(Int32FromInt32(0x1B42))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B42)-Int32FromInt32(0x1B42))&0x7ff<<21},
	112: {F__ccgo0: uint32(Int32FromInt32(0x1B73))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1B73)-Int32FromInt32(0x1B6B))&0x7ff<<21},
	113: {F__ccgo0: uint32(Int32FromInt32(0x1DCA))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1DCA)-Int32FromInt32(0x1DC0))&0x7ff<<21},
	114: {F__ccgo0: uint32(Int32FromInt32(0x1DFF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1DFF)-Int32FromInt32(0x1DFE))&0x7ff<<21},
	115: {F__ccgo0: uint32(Int32FromInt32(0x200F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x200F)-Int32FromInt32(0x200B))&0x7ff<<21},
	116: {F__ccgo0: uint32(Int32FromInt32(0x202E))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x202E)-Int32FromInt32(0x202A))&0x7ff<<21},
	117: {F__ccgo0: uint32(Int32FromInt32(0x2063))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x2063)-Int32FromInt32(0x2060))&0x7ff<<21},
	118: {F__ccgo0: uint32(Int32FromInt32(0x206F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x206F)-Int32FromInt32(0x206A))&0x7ff<<21},
	119: {F__ccgo0: uint32(Int32FromInt32(0x20EF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x20EF)-Int32FromInt32(0x20D0))&0x7ff<<21},
	120: {F__ccgo0: uint32(Int32FromInt32(0x232A))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x232A)-Int32FromInt32(0x2329))&0x7ff<<21},
	121: {F__ccgo0: uint32(Int32FromInt32(0x3029))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x3029)-Int32FromInt32(0x2E80))&0x7ff<<21},
	122: {F__ccgo0: uint32(Int32FromInt32(0x302F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x302F)-Int32FromInt32(0x302A))&0x7ff<<21},
	123: {F__ccgo0: uint32(Int32FromInt32(0x303E))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x303E)-Int32FromInt32(0x3030))&0x7ff<<21},
	124: {F__ccgo0: uint32(Int32FromInt32(0x309A))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x309A)-Int32FromInt32(0x3099))&0x7ff<<21},
	125: {F__ccgo0: uint32(Int32FromInt32(0xA806))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xA806)-Int32FromInt32(0xA806))&0x7ff<<21},
	126: {F__ccgo0: uint32(Int32FromInt32(0xA80B))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xA80B)-Int32FromInt32(0xA80B))&0x7ff<<21},
	127: {F__ccgo0: uint32(Int32FromInt32(0xA826))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xA826)-Int32FromInt32(0xA825))&0x7ff<<21},
	128: {F__ccgo0: uint32(Int32FromInt32(0xFAFF))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFAFF)-Int32FromInt32(0xF900))&0x7ff<<21},
	129: {F__ccgo0: uint32(Int32FromInt32(0xFB1E))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFB1E)-Int32FromInt32(0xFB1E))&0x7ff<<21},
	130: {F__ccgo0: uint32(Int32FromInt32(0xFE0F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFE0F)-Int32FromInt32(0xFE00))&0x7ff<<21},
	131: {F__ccgo0: uint32(Int32FromInt32(0xFE23))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFE23)-Int32FromInt32(0xFE20))&0x7ff<<21},
	132: {F__ccgo0: uint32(Int32FromInt32(0xFE6F))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFE6F)-Int32FromInt32(0xFE30))&0x7ff<<21},
	133: {F__ccgo0: uint32(Int32FromInt32(0xFEFF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFEFF)-Int32FromInt32(0xFEFF))&0x7ff<<21},
	134: {F__ccgo0: uint32(Int32FromInt32(0xFF60))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFF60)-Int32FromInt32(0xFF00))&0x7ff<<21},
	135: {F__ccgo0: uint32(Int32FromInt32(0xFFE6))&0xfffff<<0 | uint32(Int32FromInt32(2)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xFFE6)-Int32FromInt32(0xFFE0))&0x7ff<<21},
	136: {F__ccgo0: uint32(Int32FromInt32(0x10A03))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x10A03)-Int32FromInt32(0x10A01))&0x7ff<<21},
	137: {F__ccgo0: uint32(Int32FromInt32(0x10A06))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x10A06)-Int32FromInt32(0x10A05))&0x7ff<<21},
	138: {F__ccgo0: uint32(Int32FromInt32(0x10A0F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x10A0F)-Int32FromInt32(0x10A0C))&0x7ff<<21},
	139: {F__ccgo0: uint32(Int32FromInt32(0x10A3A))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x10A3A)-Int32FromInt32(0x10A38))&0x7ff<<21},
	140: {F__ccgo0: uint32(Int32FromInt32(0x10A3F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x10A3F)-Int32FromInt32(0x10A3F))&0x7ff<<21},
	141: {F__ccgo0: uint32(Int32FromInt32(0x1D169))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1D169)-Int32FromInt32(0x1D167))&0x7ff<<21},
	142: {F__ccgo0: uint32(Int32FromInt32(0x1D182))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1D182)-Int32FromInt32(0x1D173))&0x7ff<<21},
	143: {F__ccgo0: uint32(Int32FromInt32(0x1D18B))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1D18B)-Int32FromInt32(0x1D185))&0x7ff<<21},
	144: {F__ccgo0: uint32(Int32FromInt32(0x1D1AD))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1D1AD)-Int32FromInt32(0x1D1AA))&0x7ff<<21},
	145: {F__ccgo0: uint32(Int32FromInt32(0x1D244))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0x1D244)-Int32FromInt32(0x1D242))&0x7ff<<21},
	146: {F__ccgo0: uint32(Int32FromInt32(0xE0001))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xE0001)-Int32FromInt32(0xE0001))&0x7ff<<21},
	147: {F__ccgo0: uint32(Int32FromInt32(0xE007F))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xE007F)-Int32FromInt32(0xE0020))&0x7ff<<21},
	148: {F__ccgo0: uint32(Int32FromInt32(0xE01EF))&0xfffff<<0 | uint32(Int32FromInt32(0)/Int32FromInt32(2))&0x1<<20 | uint32(Int32FromInt32(0xE01EF)-Int32FromInt32(0xE0100))&0x7ff<<21}}

func x_wcwidth(tls *TLS, wc int32) (r int32) {
	var a, n, v1 int32
	var c uint32
	c = uint32(wc)
	if c-uint32(0x20) < uint32(0x5f) {
		return int32(1)
	}
	if !(x_iswprint(tls, int32(c)) != 0) {
		if wc != 0 {
			v1 = -int32(1)
		} else {
			v1 = 0
		}
		return v1
	}
	if c-uint32(0x20000) < uint32(0x20000) {
		return int32(2)
	}
	/* The following code is a branchless binary search. */
	a = 0
	n = int32(Uint64FromInt64(596) / Uint64FromInt64(4))
	for cond := true; cond; cond = n != 0 {
		n >>= int32(1)
		a += (n + int32(1)) & (int32(uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges1)) + uintptr(a+n)*4 + 0))&0xfffff>>0))-c) >> int32(31))
	}
	if uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges1)) + uintptr(a)*4 + 0))&0xfffff>>0))-c <= uint32(int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges1)) + uintptr(a)*4 + 0))&0xffe00000>>21)) {
		return int32(2) * int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ranges1)) + uintptr(a)*4 + 0))&0x100000>>20)
	}
	return int32(1) + BoolInt32(c-uint32(0x3040) < uint32(Int32FromInt32(0xd800)-Int32FromInt32(0x3040)))
}

const m___NR_getdents64 = 217

type Tino_t = uint64

type Tdirent = struct {
	Fd_ino       uint64
	Fd_off       int64
	Fd_reclen    uint16
	Fd_type      uint8
	Fd_name      [1]int8
	F__ccgo_pad5 [4]byte
}

func x___getdents(tls *TLS, fd int32, buf uintptr, len1 uint64) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_getdents64), int64(fd), int64(buf), int64(len1)))
}

func x_alphasort(tls *TLS, a uintptr, b uintptr) (r int32) {
	return x_strcoll(tls, *(*uintptr)(unsafe.Pointer(a))+19, *(*uintptr)(unsafe.Pointer(b))+19)
}

type TDIR = struct {
	Flock    int32
	Ffd      int32
	Ftell    int64
	Fbuf_pos int32
	Fbuf_end int32
	Fbuf     [2048]int8
}

type T__DIR_s = TDIR

func x_closedir(tls *TLS, dir uintptr) (r int32) {
	var ret int32
	ret = x_close(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd)
	x_free(tls, dir)
	return ret
}

func x_dirfd(tls *TLS, d uintptr) (r int32) {
	return (*TDIR)(unsafe.Pointer(d)).Ffd
}

const m_ENOTDIR = 20
const m_FD_CLOEXEC = 1
const m_F_SETFD = 2
const m_S_IFDIR = 16384
const m_S_IFMT = 61440

type Tmode_t = uint32

type Tflock = struct {
	Fl_type      int16
	Fl_whence    int16
	Fl_start     int64
	Fl_len       int64
	Fl_pid       int32
	F__ccgo_pad5 [4]byte
}

type Ttime_t = int64

type Ttimespec = struct {
	Ftv_sec  int64
	Ftv_nsec uint64
}

type Tnlink_t = uint64

type Tdev_t = uint64

type Tblksize_t = int64

type Tblkcnt_t = int64

type Tstat = struct {
	Fst_dev     uint64
	Fst_ino     uint64
	Fst_nlink   uint64
	Fst_mode    uint32
	Fst_uid     uint32
	Fst_gid     uint32
	F__pad0     uint32
	Fst_rdev    uint64
	Fst_size    int64
	Fst_blksize int64
	Fst_blocks  int64
	Fst_atim    Ttimespec
	Fst_mtim    Ttimespec
	Fst_ctim    Ttimespec
	F__unused   [3]int64
}

func x_fdopendir(tls *TLS, fd int32) (r uintptr) {
	bp := tls.Alloc(160) /* tlsAllocs 144 maxVaListSize 8 */
	defer tls.Free(160)
	var dir, v1 uintptr
	var _ /* st at bp+0 */ Tstat
	if x_fstat(tls, fd, bp) < 0 || !((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&Uint32FromInt32(m_S_IFMT) == Uint32FromInt32(m_S_IFDIR)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOTDIR)
		return uintptr(0)
	}
	v1 = x_calloc(tls, uint64(1), uint64(2072))
	dir = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	x_fcntl(tls, fd, int32(m_F_SETFD), VaList(bp+152, int32(m_FD_CLOEXEC)))
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

const m_O_DIRECTORY = 65536
const m_O_RDONLY = 0

func x_opendir(tls *TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	var dir, v2 uintptr
	var fd, v1 int32
	v1 = x_open(tls, name, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_DIRECTORY), 0)
	fd = v1
	if v1 < 0 {
		return uintptr(0)
	}
	x_fcntl(tls, fd, int32(m_F_SETFD), VaList(bp+8, int32(m_FD_CLOEXEC)))
	v2 = x_calloc(tls, uint64(1), uint64(2072))
	dir = v2
	if !(v2 != 0) {
		x_close(tls, fd)
		return uintptr(0)
	}
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

//#define LFS64_2(x, y) weak_alias(x, y)

func x_readdir(tls *TLS, dir uintptr) (r uintptr) {
	var de uintptr
	var len1 int32
	if (*TDIR)(unsafe.Pointer(dir)).Fbuf_pos >= (*TDIR)(unsafe.Pointer(dir)).Fbuf_end {
		len1 = x___getdents(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, dir+24, uint64(2048))
		if len1 < 0 {
			(*TDIR)(unsafe.Pointer(dir)).Flock = 0
			return UintptrFromInt32(0)
		} else if len1 == 0 {
			return uintptr(0)
		}
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = len1
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = 0
	}
	de = dir + 24 + uintptr((*TDIR)(unsafe.Pointer(dir)).Fbuf_pos)
	*(*int32)(unsafe.Pointer(dir + 16)) += int32((*Tdirent)(unsafe.Pointer(de)).Fd_reclen)
	(*TDIR)(unsafe.Pointer(dir)).Ftell = (*Tdirent)(unsafe.Pointer(de)).Fd_off
	return de
}

const m_libc = 1

func x_readdir_r(tls *TLS, dir uintptr, buf uintptr, result uintptr) (r int32) {
	var de uintptr
	var errno_save, ret, v2 int32
	errno_save = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, dir)
		_ = Int32FromInt32(1)
	} else {
		_ = dir
		_ = Int32FromInt32(1)
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = 0
	de = x_readdir(tls, dir)
	v2 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	ret = v2
	if v2 != 0 {
		*(*int32)(unsafe.Pointer(dir)) = 0
		return ret
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = errno_save
	if de != 0 {
		x_memcpy(tls, buf, de, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
	} else {
		buf = UintptrFromInt32(0)
	}
	*(*int32)(unsafe.Pointer(dir)) = 0
	*(*uintptr)(unsafe.Pointer(result)) = buf
	return 0
}

const m_SEEK_SET = 0

func x_rewinddir(tls *TLS, dir uintptr) {
	var v2 int32
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, dir)
		_ = Int32FromInt32(1)
	} else {
		_ = dir
		_ = Int32FromInt32(1)
	}
	x_lseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, 0, m_SEEK_SET)
	v2 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v2
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v2
	(*TDIR)(unsafe.Pointer(dir)).Ftell = 0
	*(*int32)(unsafe.Pointer(dir)) = 0
}

type Tptrdiff_t = int64

func x_scandir(tls *TLS, path uintptr, res uintptr, sel uintptr, cmp uintptr) (r int32) {
	var cnt, len1, size, v2, v3 uint64
	var d, de, names, tmp, v1 uintptr
	var old_errno int32
	d = x_opendir(tls, path)
	names = uintptr(0)
	cnt = uint64(0)
	len1 = uint64(0)
	old_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if !(d != 0) {
		return -int32(1)
	}
	for {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = 0
		v1 = x_readdir(tls, d)
		de = v1
		if !(v1 != 0) {
			break
		}
		if sel != 0 && !((*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{sel})))(tls, de) != 0) {
			continue
		}
		if cnt >= len1 {
			len1 = uint64(2)*len1 + uint64(1)
			if len1 > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(8) {
				break
			}
			tmp = x_realloc(tls, names, len1*uint64(8))
			if !(tmp != 0) {
				break
			}
			names = tmp
		}
		size = uint64(int64(UintptrFromInt32(0)+19)-int64(UintptrFromInt32(0))) + x_strlen(tls, de+19) + uint64(1)
		*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) = x_malloc(tls, size)
		if !(*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) != 0) {
			break
		}
		v2 = cnt
		cnt++
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(v2)*8)), de, size)
	}
	x_closedir(tls, d)
	if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != 0 {
		old_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		if names != 0 {
			for {
				v3 = cnt
				cnt--
				if !(v3 > uint64(0)) {
					break
				}
				x_free(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)))
			}
		}
		x_free(tls, names)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = old_errno
		return -int32(1)
	}
	if cmp != 0 {
		x_qsort(tls, names, cnt, uint64(8), cmp)
	}
	*(*uintptr)(unsafe.Pointer(res)) = names
	return int32(cnt)
}

func x_seekdir(tls *TLS, dir uintptr, off int64) {
	var v2 int32
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, dir)
		_ = Int32FromInt32(1)
	} else {
		_ = dir
		_ = Int32FromInt32(1)
	}
	(*TDIR)(unsafe.Pointer(dir)).Ftell = x_lseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, off, m_SEEK_SET)
	v2 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v2
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v2
	*(*int32)(unsafe.Pointer(dir)) = 0
}

func x_telldir(tls *TLS, dir uintptr) (r int64) {
	return (*TDIR)(unsafe.Pointer(dir)).Ftell
}

func x___libc_start_main(tls *TLS, main1 uintptr, argc int32, argv uintptr, init1 uintptr, fini uintptr, ldso_fini uintptr) (r int32) {
	var envp uintptr
	/* Save the environment if it may be used by libc/application */
	envp = argv + uintptr(argc)*8 + uintptr(1)*8
	if x____environ != uintptr(-Int32FromInt32(1)) {
		x____environ = envp
	}
	/* Avoid writing 0 and triggering unnecessary COW */
	if ldso_fini != 0 {
		x___libc.Fldso_fini = ldso_fini
	}
	if fini != 0 {
		x___libc.Ffini = fini
	}
	/* Execute constructors (static) linked into the application */
	if init1 != 0 {
		(*(*func(*TLS, int32, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{init1})))(tls, argc, argv, envp)
	}
	if main1 != 0 {
		/* Pass control to to application */
		x_exit(tls, (*(*func(*TLS, int32, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{main1})))(tls, argc, argv, envp))
	}
	return 0
}

func x_clearenv(tls *TLS) (r int32) {
	*(*uintptr)(unsafe.Pointer(x____environ)) = uintptr(0)
	return 0
}

func x_getenv(tls *TLS, name uintptr) (r uintptr) {
	var i int32
	var l uint64
	l = x_strlen(tls, name)
	if !(x____environ != 0) || !(*(*int8)(unsafe.Pointer(name)) != 0) || x_strchr(tls, name, int32('=')) != 0 {
		return UintptrFromInt32(0)
	}
	for i = 0; *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0 && (x_strncmp(tls, name, *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)), l) != 0 || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) + uintptr(l)))) != int32('=')); i++ {
	}
	if *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0 {
		return *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) + uintptr(l) + uintptr(1)
	}
	return UintptrFromInt32(0)
}

func x___putenv(tls *TLS, s uintptr, a int32) (r int32) {
	var end, newenv, newmap uintptr
	var i, j int32
	var l uint64
	i = 0
	j = 0
	end = x_strchr(tls, s, int32('='))
	l = uint64(int64(end) - int64(s) + int64(1))
	newenv = uintptr(0)
	newmap = uintptr(0)
	if !(end != 0) || l == uint64(1) {
		return -int32(1)
	}
	for ; *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0 && x_memcmp(tls, s, *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)), l) != 0; i++ {
	}
	if a != 0 {
		if !(x___env_map != 0) {
			x___env_map = x_calloc(tls, uint64(2), uint64(8))
			if x___env_map != 0 {
				*(*uintptr)(unsafe.Pointer(x___env_map)) = s
			}
		} else {
			for ; *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != 0 && *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)); j++ {
			}
			if !(*(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != 0) {
				newmap = x_realloc(tls, x___env_map, uint64(8)*uint64(j+Int32FromInt32(2)))
				if newmap != 0 {
					x___env_map = newmap
					*(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) = s
					*(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j+int32(1))*8)) = UintptrFromInt32(0)
				}
			} else {
				x_free(tls, *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)))
			}
		}
	}
	if !(*(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0) {
		newenv = x_malloc(tls, uint64(8)*uint64(i+Int32FromInt32(2)))
		if !(newenv != 0) {
			if a != 0 && x___env_map != 0 {
				*(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) = uintptr(0)
			}
			return -int32(1)
		}
		x_memcpy(tls, newenv, x____environ, uint64(8)*uint64(i))
		*(*uintptr)(unsafe.Pointer(newenv + uintptr(i)*8)) = s
		*(*uintptr)(unsafe.Pointer(newenv + uintptr(i+int32(1))*8)) = uintptr(0)
		x____environ = newenv
		x_free(tls, _oldenv)
		_oldenv = x____environ
	}
	*(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) = s
	return 0
}

var _oldenv uintptr

func x_putenv(tls *TLS, s uintptr) (r int32) {
	return x___putenv(tls, s, 0)
}

const m_ENOMEM = 12

func x_setenv(tls *TLS, var1 uintptr, value uintptr, overwrite int32) (r int32) {
	var l1, l2 int32
	var s uintptr
	if x_strchr(tls, var1, int32('=')) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	if !(overwrite != 0) && x_getenv(tls, var1) != 0 {
		return 0
	}
	l1 = int32(x_strlen(tls, var1))
	l2 = int32(x_strlen(tls, value))
	s = x_malloc(tls, uint64(l1+l2+int32(2)))
	x_memcpy(tls, s, var1, uint64(l1))
	*(*int8)(unsafe.Pointer(s + uintptr(l1))) = int8('=')
	x_memcpy(tls, s+uintptr(l1)+uintptr(1), value, uint64(l2))
	*(*int8)(unsafe.Pointer(s + uintptr(l1+l2+int32(1)))) = 0
	if x___putenv(tls, s, int32(1)) != 0 {
		x_free(tls, s)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return -int32(1)
	}
	return 0
}

func x_unsetenv(tls *TLS, name uintptr) (r int32) {
	var i, j int32
	var l uint64
	l = x_strlen(tls, name)
	if !(*(*int8)(unsafe.Pointer(name)) != 0) || x_strchr(tls, name, int32('=')) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
again:
	for i = 0; *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0 && (x_memcmp(tls, name, *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)), l) != 0 || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) + uintptr(l)))) != int32('=')); i++ {
	}
	if *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0 {
		if x___env_map != 0 {
			for j = 0; *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != 0 && *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)); j++ {
			}
			x_free(tls, *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)))
			for ; *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) != 0; j++ {
				*(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j)*8)) = *(*uintptr)(unsafe.Pointer(x___env_map + uintptr(j+int32(1))*8))
			}
		}
		for ; *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) != 0; i++ {
			*(*uintptr)(unsafe.Pointer(x____environ + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer(x____environ + uintptr(i+int32(1))*8))
		}
		goto again
	}
	return 0
}

func x___errno_location(tls *TLS) (r uintptr) {
	if x___libc.Ferrno_location != 0 {
		return (*(*func(*TLS) uintptr)(unsafe.Pointer(&struct{ uintptr }{x___libc.Ferrno_location})))(tls)
	}
	return uintptr(unsafe.Pointer(&x_errno))
}

var _errid = [85]uint8{
	0:  uint8(84),
	1:  uint8(33),
	2:  uint8(34),
	3:  uint8(25),
	4:  uint8(13),
	5:  uint8(1),
	6:  uint8(2),
	7:  uint8(3),
	8:  uint8(17),
	9:  uint8(75),
	10: uint8(28),
	11: uint8(12),
	12: uint8(16),
	13: uint8(4),
	14: uint8(11),
	15: uint8(29),
	16: uint8(18),
	17: uint8(30),
	18: uint8(39),
	19: uint8(104),
	20: uint8(110),
	21: uint8(111),
	22: uint8(112),
	23: uint8(113),
	24: uint8(98),
	25: uint8(32),
	26: uint8(5),
	27: uint8(6),
	28: uint8(15),
	29: uint8(19),
	30: uint8(20),
	31: uint8(21),
	32: uint8(26),
	33: uint8(8),
	34: uint8(22),
	35: uint8(7),
	36: uint8(40),
	37: uint8(36),
	38: uint8(23),
	39: uint8(24),
	40: uint8(9),
	41: uint8(10),
	42: uint8(14),
	43: uint8(27),
	44: uint8(31),
	45: uint8(37),
	46: uint8(35),
	47: uint8(38),
	48: uint8(42),
	49: uint8(43),
	50: uint8(60),
	51: uint8(61),
	52: uint8(62),
	53: uint8(63),
	54: uint8(67),
	55: uint8(71),
	56: uint8(74),
	57: uint8(77),
	58: uint8(88),
	59: uint8(89),
	60: uint8(90),
	61: uint8(91),
	62: uint8(92),
	63: uint8(93),
	64: uint8(94),
	65: uint8(95),
	66: uint8(96),
	67: uint8(97),
	68: uint8(99),
	69: uint8(100),
	70: uint8(101),
	71: uint8(102),
	72: uint8(103),
	73: uint8(105),
	74: uint8(106),
	75: uint8(107),
	76: uint8(108),
	77: uint8(114),
	78: uint8(115),
	79: uint8(116),
	80: uint8(121),
	81: uint8(122),
	82: uint8(123),
	83: uint8(124),
	84: uint8(0)}

var _errmsg = [1862]int8{'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'b', 'y', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0, 'A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'o', 'u', 't', 's', 'i', 'd', 'e', ' ', 'd', 'o', 'm', 'a', 'i', 'n', 0, 'R', 'e', 's', 'u', 'l', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'p', 'r', 'e', 's', 'e', 'n', 't', 'a', 'b', 'l', 'e', 0, 'N', 'o', 't', ' ', 'a', ' ', 't', 't', 'y', 0, 'P', 'e', 'r', 'm', 'i', 's', 's', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'p', 'e', 'r', 'm', 'i', 't', 't', 'e', 'd', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'f', 'i', 'l', 'e', ' ', 'o', 'r', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 0, 'F', 'i', 'l', 'e', ' ', 'e', 'x', 'i', 's', 't', 's', 0, 'V', 'a', 'l', 'u', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', ' ', 'f', 'o', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e', 0, 'N', 'o', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'o', 'n', ' ', 'd', 'e', 'v', 'i', 'c', 'e', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'D', 'e', 'v', 'i', 'c', 'e', ' ', 'o', 'r', ' ', 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'b', 'u', 's', 'y', 0, 'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 'e', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'w', 'o', 'u', 'l', 'd', ' ', 'b', 'l', 'o', 'c', 'k', 0, 'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 's', 'e', 'e', 'k', 0, 'C', 'r', 'o', 's', 's', '-', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'l', 'i', 'n', 'k', 0, 'R', 'e', 'a', 'd', '-', 'o', 'n', 'l', 'y', ' ', 'f', 'i', 'l', 'e', ' ', 's', 'y', 's', 't', 'e', 'm', 0, 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y', 0, 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 's', 'e', 't', ' ', 'b', 'y', ' ', 'p', 'e', 'e', 'r', 0, 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 't', 'i', 'm', 'e', 'd', ' ', 'o', 'u', 't', 0, 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 'f', 'u', 's', 'e', 'd', 0, 'H', 'o', 's', 't', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n', 0, 'N', 'o', ' ', 'r', 'o', 'u', 't', 'e', ' ', 't', 'o', ' ', 'h', 'o', 's', 't', 0, 'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'i', 'n', ' ', 'u', 's', 'e', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e', 0, 'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'o', 'r', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', 0, 'B', 'l', 'o', 'c', 'k', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e', 0, 'N', 'o', 't', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0, 'I', 's', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0, 'T', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 'b', 'u', 's', 'y', 0, 'E', 'x', 'e', 'c', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 0, 'A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'l', 'i', 's', 't', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'l', 'e', 'v', 'e', 'l', 's', ' ', 'o', 'f', ' ', 's', 'y', 'm', 'b', 'o', 'l', 'i', 'c', ' ', 'l', 'i', 'n', 'k', 's', 0, 'F', 'i', 'l', 'e', 'n', 'a', 'm', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'F', 'i', 'l', 'e', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 0, 'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', 's', 0, 'B', 'a', 'd', ' ', 'f', 'i', 'l', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', 0, 'N', 'o', ' ', 'c', 'h', 'i', 'l', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'e', 's', 0, 'B', 'a', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', 0, 'F', 'i', 'l', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', 0, 'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'l', 'i', 'n', 'k', 's', 0, 'N', 'o', ' ', 'r', 'e', 'c', 'o', 'r', 'd', ' ', 'l', 'o', 'c', 'k', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'd', 'e', 'a', 'd', 'l', 'o', 'c', 'k', ' ', 'w', 'o', 'u', 'l', 'd', ' ', 'o', 'c', 'c', 'u', 'r', 0, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'N', 'o', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'o', 'f', ' ', 'd', 'e', 's', 'i', 'r', 'e', 'd', ' ', 't', 'y', 'p', 'e', 0, 'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', ' ', 'r', 'e', 'm', 'o', 'v', 'e', 'd', 0, 'D', 'e', 'v', 'i', 'c', 'e', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 't', 'r', 'e', 'a', 'm', 0, 'N', 'o', ' ', 'd', 'a', 't', 'a', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'T', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 's', 't', 'r', 'e', 'a', 'm', 's', ' ', 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e', 's', 0, 'L', 'i', 'n', 'k', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 's', 'e', 'v', 'e', 'r', 'e', 'd', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'o', 't', ' ', 'a', ' ', 'd', 'a', 't', 'a', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 0, 'F', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', ' ', 'i', 'n', ' ', 'b', 'a', 'd', ' ', 's', 't', 'a', 't', 'e', 0, 'S', 'o', 'c', 'k', 'e', 't', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'n', ' ', 'n', 'o', 'n', '-', 's', 'o', 'c', 'k', 'e', 't', 0, 'D', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0, 'M', 'e', 's', 's', 'a', 'g', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'w', 'r', 'o', 'n', 'g', ' ', 't', 'y', 'p', 'e', ' ', 'f', 'o', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'S', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'o', 'n', ' ', 's', 'o', 'c', 'k', 'e', 't', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0, 'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 's', 's', 'i', 'g', 'n', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', 'e', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', 0, 'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n', 0, 'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'i', 's', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 0, 'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'd', 'r', 'o', 'p', 'p', 'e', 'd', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'r', 'e', 's', 'e', 't', 0, 'S', 'o', 'f', 't', 'w', 'a', 'r', 'e', ' ', 'c', 'a', 'u', 's', 'e', 'd', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'a', 'b', 'o', 'r', 't', 0, 'N', 'o', ' ', 'b', 'u', 'f', 'f', 'e', 'r', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'S', 'o', 'c', 'k', 'e', 't', ' ', 'i', 's', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0, 'S', 'o', 'c', 'k', 'e', 't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0, 'C', 'a', 'n', 'n', 'o', 't', ' ', 's', 'e', 'n', 'd', ' ', 'a', 'f', 't', 'e', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 'w', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', 0, 'S', 't', 'a', 'l', 'e', ' ', 'N', 'F', 'S', ' ', 'f', 'i', 'l', 'e', ' ', 'h', 'a', 'n', 'd', 'l', 'e', 0, 'R', 'e', 'm', 'o', 't', 'e', ' ', 'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'Q', 'u', 'o', 't', 'a', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'N', 'o', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 't', 'y', 'p', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'n', 'u', 'm', 'b', 'e', 'r'}

func x_strerror(tls *TLS, e int32) (r uintptr) {
	var i int32
	var s uintptr
	for i = 0; _errid[i] != 0 && int32(_errid[i]) != e; i++ {
	}
	for s = uintptr(unsafe.Pointer(&_errmsg)); i != 0; {
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
		goto _1
	_1:
		s++
		i--
	}
	return s
}

const m___NR_exit = 60
const m___NR_exit_group = 231

func x__Exit(tls *TLS, ec int32) {
	_syscall1(tls, int64(m___NR_exit_group), int64(ec))
	_syscall1(tls, int64(m___NR_exit), int64(ec))
}

const m_SIGABRT = 6

type Tpthread_t = uintptr

type Tclock_t = int64

type Tsigset_t = struct {
	F__bits [16]uint64
}

type Tsiginfo_t = struct {
	Fsi_signo    int32
	Fsi_errno    int32
	Fsi_code     int32
	F__si_fields struct {
		F__kill [0]struct {
			Fsi_pid int32
			Fsi_uid uint32
		}
		F__timer [0]struct {
			Fsi_timerid  uintptr
			Fsi_overrun  int32
			F__pad       [0]int8
			Fsi_sigval   Tsigval
			Fsi_private  int32
			F__ccgo_pad5 [4]byte
		}
		F__rt [0]struct {
			Fsi_pid    int32
			Fsi_uid    uint32
			Fsi_sigval Tsigval
		}
		F__sigchld [0]struct {
			Fsi_pid    int32
			Fsi_uid    uint32
			Fsi_status int32
			Fsi_utime  int64
			Fsi_stime  int64
		}
		F__sigfault [0]struct {
			Fsi_addr     uintptr
			Faddr_lsb    int16
			F__ccgo_pad2 [6]byte
		}
		F__sigpoll [0]struct {
			Fsi_band     int64
			Fsi_fd       int32
			F__ccgo_pad2 [4]byte
		}
		F__pad [28]int32
	}
}

type T__siginfo = Tsiginfo_t

type Tsigaction = struct {
	F__sa_handler struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	}
	Fsa_mask       Tsigset_t
	Fsa_flags      int32
	F__sa_restorer uintptr
}

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  uint64
}

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
}

type Tsig_atomic_t = int32

func x_abort(tls *TLS) {
	x_raise(tls, int32(m_SIGABRT))
	for {
	}
}

func x___assert_fail(tls *TLS, expr uintptr, file uintptr, line int32, func1 uintptr) {
	bp := tls.Alloc(40) /* tlsAllocs 0 maxVaListSize 32 */
	defer tls.Free(40)
	x_fprintf(tls, Xstderr, ts+34, VaList(bp+8, expr, file, func1, line))
	x_fflush(tls, UintptrFromInt32(0))
	x_abort(tls)
}

const m_COUNT = 32

//#define LFS64_2(x, y) weak_alias(x, y)

/* Ensure that at least 32 atexit handlers can be registered without malloc */

type Tfl = struct {
	Fnext uintptr
	Ff    [32]uintptr
}

var _builtin Tfl
var _head uintptr

func _run_atexit_functions(tls *TLS) (r int32) {
	var i int32
	for ; _head != 0; _head = (*Tfl)(unsafe.Pointer(_head)).Fnext {
		for i = Int32FromInt32(m_COUNT) - Int32FromInt32(1); i >= 0 && !(*(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(i)*8)) != 0); i-- {
		}
		for ; i >= 0; i-- {
			(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(i)*8))})))(tls)
		}
	}
	return 0
}

func init() {
	p := unsafe.Pointer(&x___funcs_on_exit)
	*(*uintptr)(unsafe.Add(p, 0)) = __ccgo_fp(_run_atexit_functions)
}

func x_atexit(tls *TLS, func1 uintptr) (r int32) {
	var i int32
	var new_fl uintptr
	/* Hook for atexit extensions */
	if x___libc.Fatexit != 0 {
		return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{x___libc.Fatexit})))(tls, func1)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock))
		_ = Int32FromInt32(1)
	}
	/* Defer initialization of head so it can be in BSS */
	if !(_head != 0) {
		_head = uintptr(unsafe.Pointer(&_builtin))
	}
	/* If the current function list is full, add a new one */
	if *(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(Int32FromInt32(m_COUNT)-Int32FromInt32(1))*8)) != 0 {
		new_fl = x_calloc(tls, uint64(264), uint64(1))
		if !(new_fl != 0) {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock)))) = 0
			return -int32(1)
		}
		(*Tfl)(unsafe.Pointer(new_fl)).Fnext = _head
		_head = new_fl
	}
	/* Append function to the list. */
	for i = 0; i < int32(m_COUNT) && *(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(i)*8)) != 0; i++ {
	}
	*(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(i)*8)) = func1
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock)))) = 0
	return 0
}

var _lock int32

//#define LFS64_2(x, y) weak_alias(x, y)

/* __overflow.c and atexit.c override these */
var _dummy = uintptr(0)

func init() {
	p := unsafe.Pointer(&_dummy)
	*(*uintptr)(unsafe.Add(p, 0)) = uintptr(0)
}

var _dummy2 = uintptr(0)

func init() {
	p := unsafe.Pointer(&_dummy2)
	*(*uintptr)(unsafe.Add(p, 0)) = uintptr(0)
}

func x_exit(tls *TLS, code int32) {
	/* If more than one thread calls exit, hang until _Exit ends it all */
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock1)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock1))
		_ = Int32FromInt32(1)
	}
	/* Only do atexit & stdio flush if they were actually used */
	if x___funcs_on_exit != 0 {
		(*(*func(*TLS) int32)(unsafe.Pointer(&struct{ uintptr }{x___funcs_on_exit})))(tls)
	}
	if x___fflush_on_exit != 0 {
		(*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{x___fflush_on_exit})))(tls, uintptr(0))
	}
	/* Destructor s**t is kept separate from atexit to avoid bloat */
	if x___libc.Ffini != 0 {
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{x___libc.Ffini})))(tls)
	}
	if x___libc.Fldso_fini != 0 {
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fldso_fini})))(tls)
	}
	x__Exit(tls, code)
	for {
	}
}

var _lock1 int32

const m_O_CREAT = 64
const m_O_TRUNC = 512
const m_O_WRONLY = 1

func x_creat(tls *TLS, filename uintptr, mode uint32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	return x_open(tls, filename, Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_WRONLY)|Int32FromInt32(m_O_TRUNC), VaList(bp+8, mode))
}

const m_F_SETFL = 4
const m_F_SETLKW = 14
const m_O_LARGEFILE = 32768
const m___NR_fcntl = 72

func x_fcntl(tls *TLS, fd int32, cmd int32, va uintptr) (r1 int32) {
	var ap uintptr
	var arg int64
	var r int32
	ap = va
	arg = VaInt64(&ap)
	_ = ap
	if cmd == int32(m_F_SETFL) {
		arg |= int64(m_O_LARGEFILE)
	}
	if cmd == int32(m_F_SETLKW) {
		if x___libc.Fcancelpt != 0 {
			(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
			_ = 0
		}
		_ = Int32FromInt32(0)
	}
	r = int32(_syscall3(tls, int64(m___NR_fcntl), int64(fd), int64(cmd), arg))
	if cmd == int32(m_F_SETLKW) {
		if x___libc.Fcancelpt != 0 {
			(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
			_ = 0
		}
		_ = Int32FromInt32(0)
	}
	return r
}

const m___NR_open = 2

func x_open(tls *TLS, filename uintptr, flags int32, va uintptr) (r1 int32) {
	var ap uintptr
	var mode uint32
	var r int32
	ap = va
	mode = VaUint32(&ap)
	_ = ap
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall3(tls, int64(m___NR_open), int64(filename), int64(flags|int32(m_O_LARGEFILE)), int64(mode)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_openat = 257

func x_openat(tls *TLS, fd int32, filename uintptr, flags int32, va uintptr) (r1 int32) {
	var ap uintptr
	var mode uint32
	var r int32
	ap = va
	mode = VaUint32(&ap)
	_ = ap
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall4(tls, int64(m___NR_openat), int64(fd), int64(filename), int64(flags|int32(m_O_LARGEFILE)), int64(mode)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

//#define LFS64_2(x, y) weak_alias(x, y)

type T__libc = struct {
	Flock            uintptr
	Fcancelpt        uintptr
	Fatexit          uintptr
	Ffini            uintptr
	Fldso_fini       uintptr
	Ferrno_location  uintptr
	Fthreads_minus_1 int32
	Frsyscall        uintptr
	Ftsd_keys        uintptr
}

func x___syscall_ret(tls *TLS, r uint64) (r1 int64) {
	if r >= uint64(-Int32FromInt32(1))-Uint64FromInt32(4096) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(-int64(r))
		return int64(-int32(1))
	}
	return int64(r)
}

type Tkey_t = int32

type Tipc_perm = struct {
	Fkey    int32
	Fuid    uint32
	Fgid    uint32
	Fcuid   uint32
	Fcgid   uint32
	Fmode   uint32
	Fseq    int32
	F__pad1 int64
	F__pad2 int64
}

func x_ftok(tls *TLS, path uintptr, id int32) (r int32) {
	bp := tls.Alloc(144) /* tlsAllocs 144 maxVaListSize 0 */
	defer tls.Free(144)
	var _ /* st at bp+0 */ Tstat
	if x_stat(tls, path, bp) < 0 {
		return -int32(1)
	}
	return int32((*(*Tstat)(unsafe.Pointer(bp))).Fst_ino&Uint64FromInt32(0xffff) | (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev&Uint64FromInt32(0xff)<<Int32FromInt32(16) | uint64(id&Int32FromInt32(0xff)<<Int32FromInt32(24)))
}

const m___NR_semctl = 66

type Tsemid_ds = struct {
	Fsem_perm  Tipc_perm
	Fsem_otime int64
	F__unused1 uint64
	Fsem_ctime int64
	F__unused2 uint64
	Fsem_nsems uint64
	F__unused3 uint64
	F__unused4 uint64
}

type Tseminfo = struct {
	Fsemmap int32
	Fsemmni int32
	Fsemmns int32
	Fsemmnu int32
	Fsemmsl int32
	Fsemopm int32
	Fsemume int32
	Fsemusz int32
	Fsemvmx int32
	Fsemaem int32
}

type Tsembuf = struct {
	Fsem_num uint16
	Fsem_op  int16
	Fsem_flg int16
}

func x_semctl(tls *TLS, id int32, num int32, cmd int32, va uintptr) (r int32) {
	var ap uintptr
	var arg int64
	ap = va
	arg = VaInt64(&ap)
	_ = ap
	return int32(_syscall4(tls, int64(m___NR_semctl), int64(id), int64(num), int64(cmd), arg))
}

const m___NR_semget = 64

func x_semget(tls *TLS, key int32, n int32, fl int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_semget), int64(key), int64(n), int64(fl)))
}

const m___NR_semop = 65

func x_semop(tls *TLS, id int32, buf uintptr, n uint64) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_semop), int64(id), int64(buf), int64(n)))
}

const m___NR_shmat = 30

type Tshmid_ds = struct {
	Fshm_perm   Tipc_perm
	Fshm_segsz  uint64
	Fshm_atime  int64
	Fshm_dtime  int64
	Fshm_ctime  int64
	Fshm_cpid   int32
	Fshm_lpid   int32
	Fshm_nattch uint64
	F__pad1     uint64
	F__pad2     uint64
}

func x_shmat(tls *TLS, id int32, addr uintptr, flag int32) (r uintptr) {
	return uintptr(_syscall3(tls, int64(m___NR_shmat), int64(id), int64(addr), int64(flag)))
}

const m___NR_shmctl = 31

func x_shmctl(tls *TLS, id int32, cmd int32, buf uintptr) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_shmctl), int64(id), int64(cmd), int64(buf)))
}

const m___NR_shmdt = 67

func x_shmdt(tls *TLS, addr uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_shmdt), int64(addr)))
}

const m___NR_shmget = 29

func x_shmget(tls *TLS, key int32, size uint64, flag int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_shmget), int64(key), int64(size), int64(flag)))
}

const m___NR_brk = 12

func x_brk(tls *TLS, end uintptr) (r int32) {
	return -BoolInt32(_syscall1(tls, int64(m___NR_brk), int64(end)) == int64(-int32(1)))
}

const m___NR_chroot = 161

func x_chroot(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_chroot), int64(path)))
}

const m_O_RDWR = 2

func x_daemon(tls *TLS, nochdir int32, noclose int32) (r int32) {
	var failed, fd, v1 int32
	if !(nochdir != 0) && x_chdir(tls, ts+69) != 0 {
		return -int32(1)
	}
	if !(noclose != 0) {
		failed = 0
		v1 = x_open(tls, ts+71, int32(m_O_RDWR), 0)
		fd = v1
		if v1 < 0 {
			return -int32(1)
		}
		if x_dup2(tls, fd, 0) < 0 || x_dup2(tls, fd, int32(1)) < 0 || x_dup2(tls, fd, int32(2)) < 0 {
			failed++
		}
		if fd > int32(2) {
			x_close(tls, fd)
		}
		if failed != 0 {
			return -int32(1)
		}
	}
	switch x_fork(tls) {
	case 0:
	case -int32(1):
		return -int32(1)
	default:
		x__exit(tls, 0)
	}
	if x_setsid(tls) < 0 {
		return -int32(1)
	}
	switch x_fork(tls) {
	case 0:
	case -int32(1):
		return -int32(1)
	default:
		x__exit(tls, 0)
	}
	return 0
}

const m___NR_epoll_create = 213

type Tsuseconds_t = int64

type Tid_t = int32

type Tpthread_once_t = int32

type Tpthread_key_t = int32

type Tpthread_spinlock_t = int32

type Tpthread_attr_t = struct {
	F__u struct {
		F__s [0][2]uint64
		F__i [14]int32
	}
}

type Tpthread_mutexattr_t = uint32

type Tpthread_condattr_t = uint32

type Tpthread_barrierattr_t = uint32

type Tpthread_rwlockattr_t = struct {
	F__attr [2]uint32
}

type Tpthread_mutex_t = struct {
	F__u struct {
		F__p [0][1]uintptr
		F__i [10]int32
	}
}

type Tpthread_cond_t = struct {
	F__u struct {
		F__p [0][1]uintptr
		F__i [12]int32
	}
}

type Tpthread_rwlock_t = struct {
	F__u struct {
		F__p [0][1]uintptr
		F__i [14]int32
	}
}

type Tpthread_barrier_t = struct {
	F__u struct {
		F__p [0][1]uintptr
		F__i [8]int32
	}
}

type Tfsblkcnt_t = uint64

type Tfsfilcnt_t = uint64

type Ttimer_t = uintptr

type Tclockid_t = int32

type _EPOLL_EVENTS = int32

const ___EPOLL_DUMMY = 0

type Tepoll_data_t = struct {
	Ffd  [0]int32
	Fu32 [0]uint32
	Fu64 [0]uint64
	Fptr uintptr
}

type Tepoll_data = Tepoll_data_t

type Tepoll_event = struct {
	Fevents uint32
	Fdata   Tepoll_data_t
}

func x_epoll_create(tls *TLS, size int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_epoll_create), int64(size)))
}

const m___NR_epoll_create1 = 291

func x_epoll_create1(tls *TLS, flags int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_epoll_create1), int64(flags)))
}

const m___NR_epoll_ctl = 233

func x_epoll_ctl(tls *TLS, fd int32, op int32, fd2 int32, ev uintptr) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_epoll_ctl), int64(fd), int64(op), int64(fd2), int64(ev)))
}

const m___NR_epoll_pwait = 281

func x_epoll_pwait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32, sigs uintptr) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_epoll_pwait), int64(fd), int64(ev), int64(cnt), int64(to), int64(sigs), int64(8)))
}

const m___NR_epoll_wait = 232

func x_epoll_wait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_epoll_wait), int64(fd), int64(ev), int64(cnt), int64(to)))
}

const m_INT_MAX = 2147483647
const m_RLIMIT_NOFILE = 7

type Ttimeval = struct {
	Ftv_sec      int64
	Ftv_usec     int32
	F__ccgo_pad2 [4]byte
}

type Trlim_t = uint64

type Trlimit = struct {
	Frlim_cur uint64
	Frlim_max uint64
}

type Trusage = struct {
	Fru_utime    Ttimeval
	Fru_stime    Ttimeval
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
	F__reserved  [16]int64
}

func x_getdtablesize(tls *TLS) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1 uint64
	var _ /* rl at bp+0 */ Trlimit
	x_getrlimit(tls, int32(m_RLIMIT_NOFILE), bp)
	if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max < uint64(m_INT_MAX) {
		v1 = (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max
	} else {
		v1 = uint64(m_INT_MAX)
	}
	return int32(v1)
}

func x_gethostid(tls *TLS) (r int64) {
	return 0
}

const m_required_argument = 1

type Toption = struct {
	Fname        uintptr
	Fhas_arg     int32
	Fflag        uintptr
	Fval         int32
	F__ccgo_pad4 [4]byte
}

func ___getopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr, longonly int32) (r int32) {
	var i, v5 int32
	var name, opt, v1, v2, v4 uintptr
	var v3 bool
	if x_optind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) != 0) || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))))) != int32('-') {
		return -int32(1)
	}
	if longonly != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 1)) != 0 || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 1))) == int32('-') && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 2)) != 0 {
		for i = 0; (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname != 0; i++ {
			name = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname
			opt = *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(1)
			if int32(*(*int8)(unsafe.Pointer(opt))) == int32('-') {
				opt++
			}
			for {
				if v3 = *(*int8)(unsafe.Pointer(name)) != 0; v3 {
					v1 = name
					name++
					v2 = opt
					opt++
				}
				if !(v3 && int32(*(*int8)(unsafe.Pointer(v1))) == int32(*(*int8)(unsafe.Pointer(v2)))) {
					break
				}
			}
			if *(*int8)(unsafe.Pointer(name)) != 0 || *(*int8)(unsafe.Pointer(opt)) != 0 && int32(*(*int8)(unsafe.Pointer(opt))) != int32('=') {
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(opt))) == int32('=') {
				if !((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg != 0) {
					continue
				}
				x_optarg = opt + uintptr(1)
			} else {
				if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg == int32(m_required_argument) {
					x_optind++
					v5 = x_optind
					v4 = *(*uintptr)(unsafe.Pointer(argv + uintptr(v5)*8))
					x_optarg = v4
					if !(v4 != 0) {
						return int32(':')
					}
				} else {
					x_optarg = UintptrFromInt32(0)
				}
			}
			x_optind++
			if idx != 0 {
				*(*int32)(unsafe.Pointer(idx)) = i
			}
			if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag != 0 {
				*(*int32)(unsafe.Pointer((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag)) = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
				return 0
			}
			return (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 1))) == int32('-') {
			x_optind++
			return int32('?')
		}
	}
	return x_getopt(tls, argc, argv, optstring)
}

func x_getopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, 0)
}

func x_getopt_long_only(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, int32(1))
}

func x_getpagesize(tls *TLS) (r int32) {
	return int32(m_PAGESIZE)
}

const m_ECHO = 8
const m_ICANON = 2
const m_ICRNL = 256
const m_IGNCR = 128
const m_INLCR = 64
const m_ISIG = 1
const m_NCCS = 32
const m_O_NOCTTY = 256
const m_TCSAFLUSH = 2

type Tcc_t = uint8

type Tspeed_t = uint32

type Ttcflag_t = uint32

type Ttermios = struct {
	Fc_iflag    uint32
	Fc_oflag    uint32
	Fc_cflag    uint32
	Fc_lflag    uint32
	Fc_line     uint8
	Fc_cc       [32]uint8
	F__c_ispeed uint32
	F__c_ospeed uint32
}

func x_getpass(tls *TLS, prompt uintptr) (r uintptr) {
	bp := tls.Alloc(120) /* tlsAllocs 120 maxVaListSize 0 */
	defer tls.Free(120)
	var fd, v1 int32
	var l int64
	var _ /* s at bp+0 */ Ttermios
	var _ /* t at bp+60 */ Ttermios
	v1 = x_open(tls, ts+81, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_NOCTTY), 0)
	fd = v1
	if v1 < 0 {
		fd = 0
	}
	x_tcgetattr(tls, fd, bp+60)
	*(*Ttermios)(unsafe.Pointer(bp)) = *(*Ttermios)(unsafe.Pointer(bp + 60))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag)))) &= uint32(^(Int32FromInt32(m_ECHO) | Int32FromInt32(m_ISIG)))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag)))) |= uint32(m_ICANON)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag)))) &= uint32(^(Int32FromInt32(m_INLCR) | Int32FromInt32(m_IGNCR)))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag)))) |= uint32(m_ICRNL)
	x_tcsetattr(tls, fd, int32(m_TCSAFLUSH), bp+60)
	x_tcdrain(tls, fd)
	x_fputs(tls, prompt, Xstderr)
	x_fflush(tls, Xstderr)
	l = x_read(tls, fd, uintptr(unsafe.Pointer(&_password)), uint64(128))
	if l >= 0 {
		if l > 0 && int32(_password[l-int64(1)]) == int32('\n') {
			l--
		}
		_password[l] = 0
	}
	x_tcsetattr(tls, fd, int32(m_TCSAFLUSH), bp)
	if fd > int32(2) {
		x_close(tls, fd)
	}
	return uintptr(unsafe.Pointer(&_password))
}

var _password [128]int8

const m_NGROUPS_MAX = 32

type Tgroup = struct {
	Fgr_name   uintptr
	Fgr_passwd uintptr
	Fgr_gid    uint32
	Fgr_mem    uintptr
}

/* Most limits are system-specific */

/* Some universal constants... */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func x_initgroups(tls *TLS, user uintptr, gid uint32) (r int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxVaListSize 0 */
	defer tls.Free(136)
	var _ /* count at bp+128 */ int32
	var _ /* groups at bp+0 */ [32]uint32
	if x_getgrouplist(tls, user, gid, bp, bp+128) < 0 {
		return -int32(1)
	}
	return x_setgroups(tls, uint64(*(*int32)(unsafe.Pointer(bp + 128))), bp)
}

const m___NR_syslog = 103

func x_klogctl(tls *TLS, type1 int32, buf uintptr, len1 int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_syslog), int64(type1), int64(buf), int64(len1)))
}

const m_SEEK_END = 2

type Tmntent = struct {
	Fmnt_fsname uintptr
	Fmnt_dir    uintptr
	Fmnt_type   uintptr
	Fmnt_opts   uintptr
	Fmnt_freq   int32
	Fmnt_passno int32
}

func x_setmntent(tls *TLS, name uintptr, mode uintptr) (r uintptr) {
	return x_fopen(tls, name, mode)
}

func x_endmntent(tls *TLS, f uintptr) (r int32) {
	x_fclose(tls, f)
	return int32(1)
}

func x_getmntent(tls *TLS, f uintptr) (r uintptr) {
	bp := tls.Alloc(120) /* tlsAllocs 32 maxVaListSize 80 */
	defer tls.Free(120)
	var cnt int32
	var _ /* n at bp+0 */ [8]int32
	_mnt.Fmnt_freq = 0
	_mnt.Fmnt_passno = 0
	for cond := true; cond; cond = cnt >= int32(8) && int32(_linebuf[(*(*[8]int32)(unsafe.Pointer(bp)))[0]]) != int32('#') {
		x_fgets(tls, uintptr(unsafe.Pointer(&_linebuf)), int32(256), f)
		if x_feof(tls, f) != 0 {
			return UintptrFromInt32(0)
		}
		cnt = x_sscanf(tls, uintptr(unsafe.Pointer(&_linebuf)), ts+90, VaList(bp+40, bp, bp+uintptr(1)*4, bp+uintptr(2)*4, bp+uintptr(3)*4, bp+uintptr(4)*4, bp+uintptr(5)*4, bp+uintptr(6)*4, bp+uintptr(7)*4, uintptr(unsafe.Pointer(&_mnt.Fmnt_freq)), uintptr(unsafe.Pointer(&_mnt.Fmnt_passno))))
	}
	_linebuf[(*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)]] = 0
	_linebuf[(*(*[8]int32)(unsafe.Pointer(bp)))[int32(3)]] = 0
	_linebuf[(*(*[8]int32)(unsafe.Pointer(bp)))[int32(5)]] = 0
	_linebuf[(*(*[8]int32)(unsafe.Pointer(bp)))[int32(7)]] = 0
	_mnt.Fmnt_fsname = uintptr(unsafe.Pointer(&_linebuf)) + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[0])
	_mnt.Fmnt_dir = uintptr(unsafe.Pointer(&_linebuf)) + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)])
	_mnt.Fmnt_type = uintptr(unsafe.Pointer(&_linebuf)) + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)])
	_mnt.Fmnt_opts = uintptr(unsafe.Pointer(&_linebuf)) + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)])
	return uintptr(unsafe.Pointer(&_mnt))
}

var _linebuf [256]int8

var _mnt Tmntent

func x_addmntent(tls *TLS, f uintptr, mnt uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 0 maxVaListSize 48 */
	defer tls.Free(56)
	x_fseek(tls, f, 0, int32(m_SEEK_END))
	return BoolInt32(x_fprintf(tls, f, ts+129, VaList(bp+8, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_fsname, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_dir, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_type, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_freq, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_passno)) < 0)
}

func x_hasmntopt(tls *TLS, mnt uintptr, opt uintptr) (r uintptr) {
	return x_strstr(tls, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, opt)
}

const m___NR_mount = 165

func x_mount(tls *TLS, special uintptr, dir uintptr, fstype uintptr, flags uint64, data uintptr) (r int32) {
	return int32(_syscall5(tls, int64(m___NR_mount), int64(special), int64(dir), int64(fstype), int64(flags), int64(data)))
}

const m___NR_prctl = 157

func x_prctl(tls *TLS, op int32, va uintptr) (r int32) {
	var ap uintptr
	var i int32
	var x [4]uint64
	ap = va
	for i = 0; i < int32(4); i++ {
		x[i] = VaUint64(&ap)
	}
	return int32(_syscall5(tls, int64(m___NR_prctl), int64(op), int64(x[0]), int64(x[int32(1)]), int64(x[int32(2)]), int64(x[int32(3)])))
}

const m_ENOSYS = 38

func x_reboot(tls *TLS, type1 int32) (r int32) {
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOSYS)
	return -int32(1)
}

func x_sbrk(tls *TLS, inc int64) (r uintptr) {
	return uintptr(_syscall1(tls, int64(m___NR_brk), _syscall1(tls, int64(m___NR_brk), 0)+inc))
}

const m___NR_sendfile = 40

func x_sendfile(tls *TLS, out_fd int32, in_fd int32, ofs uintptr, count uint64) (r int64) {
	return _syscall4(tls, int64(m___NR_sendfile), int64(out_fd), int64(in_fd), int64(ofs), int64(count))
}

const m___NR_setgroups = 116

func x_setgroups(tls *TLS, count uint64, list uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_setgroups), int64(count), int64(list)))
}

const m___NR_sethostname = 170

func x_sethostname(tls *TLS, name uintptr, len1 uint64) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_sethostname), int64(name), int64(len1)))
}

const m_FD_SETSIZE = 1024
const m___NR_settimeofday = 164

type Tfd_set = struct {
	Ffds_bits [16]uint64
}

type Titimerval = struct {
	Fit_interval Ttimeval
	Fit_value    Ttimeval
}

func x_settimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_settimeofday), int64(tv), 0))
}

const m___NR_signalfd = 282

type Tsignalfd_siginfo = struct {
	Fssi_signo   uint32
	Fssi_errno   int32
	Fssi_code    int32
	Fssi_pid     uint32
	Fssi_uid     uint32
	Fssi_fd      int32
	Fssi_tid     uint32
	Fssi_band    uint32
	Fssi_overrun uint32
	Fssi_trapno  uint32
	Fssi_status  int32
	Fssi_int     int32
	Fssi_ptr     uint64
	Fssi_utime   uint64
	Fssi_stime   uint64
	Fssi_addr    uint64
	Fpad         [48]uint8
}

func x_signalfd(tls *TLS, fd int32, sigs uintptr, flags int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_signalfd), int64(fd), int64(sigs), int64(8)))
}

func x_stime(tls *TLS, t uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimeval
	*(*Ttimeval)(unsafe.Pointer(bp)) = Ttimeval{Ftv_sec: *(*int64)(unsafe.Pointer(t)), Ftv_usec: 0}
	return x_settimeofday(tls, bp, UintptrFromInt32(0))
}

const m___NR_swapoff = 168

func x_swapoff(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_swapoff), int64(path)))
}

const m___NR_swapon = 167

func x_swapon(tls *TLS, path uintptr, flags int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_swapon), int64(path), int64(flags)))
}

const m___NR_sysinfo = 99

func x_sysinfo(tls *TLS, info uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_sysinfo), int64(info)))
}

const m___NR_umount2 = 166

func x_umount(tls *TLS, special uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_umount2), int64(special), 0))
}

func x_umount2(tls *TLS, special uintptr, flags int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_umount2), int64(special), int64(flags)))
}

const m___NR_utime = 132

func x_utimes(tls *TLS, path uintptr, times uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1 int64
	var _ /* ktimes at bp+0 */ [2]int64
	if times != 0 {
		(*(*[2]int64)(unsafe.Pointer(bp)))[0] = (*(*Ttimeval)(unsafe.Pointer(times))).Ftv_sec
		(*(*[2]int64)(unsafe.Pointer(bp)))[int32(1)] = (*(*Ttimeval)(unsafe.Pointer(times + 1*16))).Ftv_sec
	}
	if times != 0 {
		v1 = int64(bp)
	} else {
		v1 = 0
	}
	return int32(_syscall2(tls, int64(m___NR_utime), int64(path), v1))
}

type Tidtype_t = int32

/* the following are needed for iso c functions to use */

func x_wait3(tls *TLS, status uintptr, options int32, usage uintptr) (r int32) {
	return x_wait4(tls, -int32(1), status, options, usage)
}

const m___NR_wait4 = 61

func x_wait4(tls *TLS, pid int32, status uintptr, options int32, usage uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var ret int32
	var _ /* kusage at bp+0 */ [4]int64
	ret = int32(_syscall4(tls, int64(m___NR_wait4), int64(pid), int64(status), int64(options), int64(usage)))
	/* Fixup kernel time_t... */
	if usage != 0 {
		x_memcpy(tls, bp, usage, uint64(32))
		x_memmove(tls, usage+uintptr(2)*16, usage+uintptr(4)*8, Uint64FromInt64(272)-Uint64FromInt32(2)*Uint64FromInt64(16))
		(*Trusage)(unsafe.Pointer(usage)).Fru_utime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[0], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)])}
		(*Trusage)(unsafe.Pointer(usage)).Fru_stime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)])}
	}
	return ret
}

type Tnl_item = int32

type Tnl_catd = int64

func x_catclose(tls *TLS, catd int64) (r int32) {
	return 0
}

func x_catgets(tls *TLS, catd int64, set_id int32, msg_id int32, s uintptr) (r uintptr) {
	return s
}

func x_catopen(tls *TLS, name uintptr, oflag int32) (r int64) {
	return int64(-Int32FromInt32(1))
}

type Tlconv = struct {
	Fdecimal_point      uintptr
	Fthousands_sep      uintptr
	Fgrouping           uintptr
	Fint_curr_symbol    uintptr
	Fcurrency_symbol    uintptr
	Fmon_decimal_point  uintptr
	Fmon_thousands_sep  uintptr
	Fmon_grouping       uintptr
	Fpositive_sign      uintptr
	Fnegative_sign      uintptr
	Fint_frac_digits    int8
	Ffrac_digits        int8
	Fp_cs_precedes      int8
	Fp_sep_by_space     int8
	Fn_cs_precedes      int8
	Fn_sep_by_space     int8
	Fp_sign_posn        int8
	Fn_sign_posn        int8
	Fint_p_cs_precedes  int8
	Fint_p_sep_by_space int8
	Fint_n_cs_precedes  int8
	Fint_n_sep_by_space int8
	Fint_p_sign_posn    int8
	Fint_n_sign_posn    int8
	F__ccgo_pad24       [2]byte
}

type T__locale = struct {
	Fdummy int32
}

func x_duplocale(tls *TLS, old uintptr) (r uintptr) {
	var new1 uintptr
	new1 = x_calloc(tls, uint64(1), uint64(4))
	if new1 != 0 {
		x_memcpy(tls, new1, old, uint64(4))
	}
	return new1
}

func x_freelocale(tls *TLS, l uintptr) {
	x_free(tls, l)
}

const m_E2BIG = 7
const m_EILSEQ = 84
const m_JIS_0201 = 22
const m_LATIN_9 = 20
const m_TIS_620 = 21
const m_UCS2BE = 4
const m_UCS2LE = 5
const m_US_ASCII = 17
const m_UTF_16BE = 2
const m_UTF_16LE = 1
const m_UTF_32BE = 0
const m_UTF_32LE = 3
const m_UTF_8 = 18
const m_WCHAR_T = 7

type Ticonv_t = uintptr

/* FIXME: these are not implemented yet
 * EUC:   A1-FE A1-FE
 * GBK:   81-FE 40-7E,80-FE
 * Big5:  A1-FE 40-7E,A1-FE
 */

/* Definitions of charmaps. Each charmap consists of:
 * 1. Empty-string-terminated list of null-terminated aliases.
 * 2. Special type code or bits per character.
 * 3. Number of elided entries (128 for specials).
 * 4. Character table (size determined by fields 2 and 3). */

var _charmaps = [2298]uint8{'u', 't', 'f', '8', 0, 0, 18, 128, 'w', 'c', 'h', 'a', 'r', 't', 0, 0, 7, 128, 'u', 'c', 's', '2', 0, 'u', 'c', 's', '2', 'b', 'e', 0, 0, 4, 128, 'u', 'c', 's', '2', 'l', 'e', 0, 0, 5, 128, 'u', 't', 'f', '1', '6', 0, 'u', 't', 'f', '1', '6', 'b', 'e', 0, 0, 2, 128, 'u', 't', 'f', '1', '6', 'l', 'e', 0, 0, 1, 128, 'u', 'c', 's', '4', 0, 'u', 'c', 's', '4', 'b', 'e', 0, 'u', 't', 'f', '3', '2', 0, 'u', 't', 'f', '3', '2', 'b', 'e', 0, 0, 0, 128, 'u', 'c', 's', '4', 'l', 'e', 0, 'u', 't', 'f', '3', '2', 'l', 'e', 0, 0, 3, 10, 's', 'c', 'i', 'i', 0, 'i', 's', 'o', '6', '4', '6', 0, 'u', 's', 'a', 's', 'c', 'i', 'i', 0, 0, 17, 128, 'l', 'a', 't', 'i', 'n', '1', 0, 'i', 's', 'o', '8', '8', '5', '9', '1', 0, 0, 9, 128, 'l', 'a', 't', 'i', 'n', '9', 0, 'i', 's', 'o', '8', '8', '5', '9', '1', '5', 0, 0, 20, 128, 't', 'i', 's', '6', '2', '0', 0, 'i', 's', 'o', '8', '8', '5', '9', '1', '1', 0, 0, 21, 128, 'j', 'i', 's', '0', '2', '0', '1', 0, 0, 22, 128, 'i', 's', 'o', '8', '8', '5', '9', '2', 0, 0, 10, '!', 4, 'a', 27, 20, ')', '=', 'i', 'u', 10, '*', '`', 'y', 'E', 'V', '^', 173, 244, 181, 23, ',', 5, 'm', '+', 20, '-', '>', 'm', 'u', ',', '.', 'a', '}', 'U', 150, '^', 221, 250, 197, 23, 'U', 193, 8, '#', 16, '1', '9', 25, 't', 12, 'C', 201, '`', 180, 140, 'F', 205, '8', 227, 16, 'D', 'C', 29, '5', 13, '5', 'P', 'Y', 's', 13, 'V', 'n', 'i', 3, 23, '7', 221, 136, 245, 'M', 'U', 225, 136, '3', 16, '9', ':', 29, 't', 'N', 'C', 233, 'd', 180, 206, 'F', 237, 184, 243, 'P', 'D', 'D', '!', '5', 15, '=', 'Q', 217, 's', 'O', 'V', 'o', 233, 19, 23, '?', 253, 140, 149, '-', 'i', 's', 'o', '8', '8', '5', '9', '3', 0, 0, 10, '!', '&', 'a', ';', 10, ')', 0, 144, 't', 10, '*', '0', 'y', 229, 17, 'M', 173, 0, 176, 23, ',', '\'', 201, '2', 11, '-', 181, 148, 't', 11, '.', '1', '}', 245, 'Q', 'M', 189, 0, 192, 23, '0', 193, 8, 3, 0, '1', 10, '!', 't', 12, '2', 201, '(', 179, 12, '3', 205, '8', 243, 12, 0, 209, 'H', '3', 13, '5', ' ', 'Y', 's', 13, 'G', 217, 'h', 179, 13, '7', 'l', 'q', 245, 13, '8', 225, 136, 3, 0, '9', 11, '%', 't', 14, ':', 233, 168, 179, 14, ';', 237, 184, 243, 14, 0, 241, 200, '3', 15, '=', '!', 217, 's', 'O', 'G', 249, 232, 179, 15, '?', 'm', 'u', 149, '-', 'i', 's', 'o', '8', '8', '5', '9', '4', 0, 0, 10, '!', 4, 225, 'd', 21, ')', '(', 237, 't', 10, '*', '`', 'I', '$', 146, 'Y', 173, 244, 245, 10, ',', 5, 'm', '{', 21, '-', ')', 241, 't', ',', '.', 'a', 'M', '4', 210, 'Y', 'J', 249, 181, 20, '@', 193, 8, '3', 12, '1', 197, 24, 227, 18, 'C', 201, '`', 180, 140, 'E', 205, '8', 163, 18, 'D', 'E', '1', 'e', 19, '5', 213, 'X', 's', 13, '6', 'r', 'i', 179, 13, '7', 'h', 169, 245, 'M', '@', 225, 136, '3', 14, '9', 229, 152, 243, 'R', 'C', 233, 'd', 180, 206, 'E', 237, 184, 179, 'R', 'D', 'F', '5', 'u', 19, '=', 245, 216, 's', 15, '>', 's', 233, 179, 15, '?', 'i', 173, 149, '-', 'i', 's', 'o', '8', '8', '5', '9', '5', 0, 0, 14, '!', 1, 132, 0, '1', '@', 16, 16, 5, 132, 1, 'q', '@', ' ', 16, 9, 132, 2, 177, '@', '0', 16, 173, 128, 3, 241, '@', '@', 16, 17, 132, 4, '1', 'A', 'P', 16, 21, 132, 5, 'q', 'A', '`', 16, 25, 132, 6, 177, 'A', 'p', 16, 29, 132, 7, 241, 'A', 128, 16, '!', 132, 8, '1', 'B', 144, 16, '%', 132, 9, 'q', 'B', 160, 16, ')', 132, 10, 177, 'B', 176, 16, '-', 132, 11, 241, 'B', 192, 16, '1', 132, 12, '1', 'C', 208, 16, '5', 132, 13, 'q', 'C', 224, 16, '9', 132, 14, 177, 'C', 240, 16, '=', 132, 15, 241, 'C', 0, 17, 'A', 132, 16, '1', 'D', 16, 17, 'E', 132, 17, 'q', 'D', ' ', 17, 'I', 132, 18, 177, 'D', '0', 17, 'M', 132, 19, 241, 'D', 'X', 132, 'Q', 132, 20, '1', 'E', 'P', 17, 'U', 132, 21, 'q', 'E', '`', 17, 'Y', 132, 22, 177, 'E', 'p', 17, 167, 128, 23, 241, 'E', 0, 'i', 's', 'o', '8', '8', '5', '9', '6', 0, 0, 11, '!', 0, 0, 0, 0, 'H', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 220, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 134, 1, 0, 0, 0, '|', 24, 0, '!', 22, 241, 136, 'I', '\\', 'b', 19, 159, 24, 197, ')', 'V', 241, 138, 'Y', 220, 'b', 23, 191, 24, 198, '1', 150, 241, 140, 'i', '\\', 'c', 27, 223, 24, 199, '9', 214, '1', 0, 0, 0, 0, 0, 0, 0, 200, 'A', 22, 242, 144, 137, '\\', 'd', '#', 31, 25, 201, 'I', 'V', 242, 146, 153, 220, 'd', '\'', '?', 25, 202, 'Q', 150, '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'i', 's', 'o', '8', '8', '5', '9', '7', 0, 0, 14, '!', 24, '`', 6, '8', 10, 176, 130, 175, 160, ')', 'p', 10, 160, 2, 169, 128, 222, 176, 10, 176, 2, 173, 0, 0, 'P', 1, 194, 2, 177, 128, ',', '0', 11, 16, 14, 133, 131, 225, 'p', 11, ' ', 14, 137, 131, 226, 176, 11, '0', 14, 189, 128, 227, 240, '8', '@', 14, 145, 131, 228, '0', '9', 'P', 14, 149, 131, 229, 'p', '9', '`', 14, 153, 131, 230, 176, '9', 'p', 14, 157, 131, 231, 240, '9', 128, 14, 161, 3, 0, '0', ':', 144, 14, 165, 131, 233, 'p', ':', 160, 14, 169, 131, 234, 176, ':', 176, 14, 173, 131, 235, 240, ':', 192, 14, 177, 131, 236, '0', ';', 208, 14, 181, 131, 237, 'p', ';', 224, 14, 185, 131, 238, 176, ';', 240, 14, 189, 131, 239, 240, ';', 0, 15, 193, 131, 240, '0', '<', 16, 15, 197, 131, 241, 'p', '<', ' ', 15, 201, 131, 242, 176, '<', '0', 15, 205, 131, 243, 0, 0, 0, 'i', 's', 'o', '8', '8', '5', '9', '8', 0, 0, 14, '!', 0, 128, '(', '0', 10, 144, 2, 165, 128, ')', 'p', 10, 160, 2, 169, 192, '5', 176, 10, 176, 2, 173, 128, '+', 240, 10, 192, 2, 177, 128, ',', '0', 11, 208, 2, 181, 128, '-', 'p', 11, 224, 2, 185, 192, '=', 176, 11, 240, 2, 189, 128, '/', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'p', 1, 'B', 23, 209, 133, 't', '1', ']', 'P', 23, 213, 133, 'u', 'q', ']', '`', 23, 217, 133, 'v', 177, ']', 'p', 23, 221, 133, 'w', 241, ']', 128, 23, 225, 133, 'x', '1', '^', 144, 23, 229, 133, 'y', 'q', '^', 160, 23, 233, 133, 'z', 1, 0, 0, 0, 14, 224, 3, 8, 0, 0, 'i', 's', 'o', '8', '8', '5', '9', '9', 0, 0, 9, 'P', 30, 163, 'I', 155, 'F', 173, 154, 181, 'k', 216, 178, 'i', 219, 198, 13, 166, 215, 'o', 224, 194, 137, 27, 'G', 174, 156, 185, 's', 232, 210, 169, '[', 199, 174, 157, 187, 'w', 31, 227, 201, 155, 'G', 175, 158, 189, '{', 248, 242, 233, 219, 199, '/', 230, 215, 127, 'i', 's', 'o', '8', '8', '5', '9', '1', '0', 0, 0, 14, '!', 4, 129, 'D', ' ', 18, 168, 4, '(', 129, 'M', 'p', 10, 236, 4, 16, 1, 'X', '`', 22, 244, 5, 173, 128, 'Z', 160, 20, 192, 2, 5, 193, 'D', '0', 18, 172, 4, ')', 193, 'M', 'p', 11, 240, 4, 17, 'A', 'X', 'p', 22, 248, 5, 21, 224, 'Z', 176, 20, 0, 4, 193, 128, '0', '0', 12, 16, 3, 197, 128, '1', 224, 18, '0', 4, 201, 0, 'F', 176, 12, 'X', 4, 205, 128, '3', 240, 12, '@', 3, 'E', 1, 'S', '0', 13, 'P', 3, 213, 128, '5', 128, 22, '`', 3, 'r', 129, '6', 176, 13, 'p', 3, 221, 128, '7', 240, 13, 4, 4, 225, 128, '8', '0', 14, 144, 3, 229, 128, '9', 240, 18, '4', 4, 233, '@', 'F', 176, 14, '\\', 4, 237, 128, ';', 240, 14, 192, 3, 'F', 'A', 'S', '0', 15, 208, 3, 245, 128, '=', 144, 22, 224, 3, 's', 129, '>', 176, 15, 240, 3, 253, 128, '?', 128, 19, 0, 'i', 's', 'o', '8', '8', '5', '9', '1', '3', 0, 0, 14, '!', 29, 160, '(', '0', 10, 144, 2, 30, 160, ')', 'p', 10, '`', 3, 169, 128, 'U', 176, 10, 176, 2, 173, 128, '+', '`', 12, 192, 2, 177, 128, ',', '0', 11, 'p', 128, 181, 128, '-', 'p', 11, 224, 3, 185, 192, 'U', 176, 11, 240, 2, 189, 128, '/', '`', 14, 16, 4, '.', 1, '@', '`', 16, 16, 3, 197, 0, 'F', ' ', 17, '0', 4, 201, '@', '^', '`', 17, 136, 4, '6', 129, 'J', 176, 19, 128, 5, 'C', 'A', 'Q', '0', 13, '0', 5, 213, 128, '5', 'p', 13, 200, 5, 'A', 129, 'V', 160, 22, 'p', 3, '{', 'A', '_', 240, 13, 20, 4, '/', 'A', '@', 'p', 16, 144, 3, 229, '@', 'F', '0', 17, '4', 4, 233, 128, '^', 'p', 17, 140, 4, '7', 193, 'J', 192, 19, 132, 5, 'D', 129, 'Q', '0', 15, '4', 5, 245, 128, '=', 'p', 15, 204, 5, 'B', 193, 'V', 176, 22, 240, 3, '|', 129, '_', 144, 1, 2, 'i', 's', 'o', '8', '8', '5', '9', '1', '4', 0, 0, 13, '!', 2, '~', 192, 143, 2, 133, 176, 16, 20, 252, ')', 0, 244, 169, '@', 208, '/', 'x', 'y', 223, 10, '\\', 1, '^', 240, 240, 31, 30, '$', 132, 4, ' ', 31, 228, 'm', 129, 149, 15, 244, 'W', '~', 208, 131, 249, 'y', 'O', 232, 11, '}', 152, 7, 6, 193, '@', 24, 12, 3, 'b', 'P', 12, 140, 193, '1', '@', 6, 201, '@', 25, ',', 3, 'f', 208, 12, 156, 193, '3', 160, 11, 209, '@', 26, 'L', 3, 'j', 'P', 13, 172, 129, 154, 199, 6, 217, '@', 27, 'l', 3, 'n', 208, 13, 236, 194, '7', 0, 7, 225, '@', 28, 140, 3, 'r', 'P', 14, 204, 193, '9', '@', 7, 233, '@', 29, 172, 3, 'v', 208, 14, 220, 193, ';', 168, 11, 241, '@', 30, 204, 3, 'z', 'P', 15, 236, 193, 154, 199, 7, 249, '@', 31, 236, 3, '~', 208, 15, 238, 194, '?', 0, 'i', 's', 'o', '8', '8', '5', '9', '1', '6', 0, 0, 14, '!', 4, 'A', 'A', 16, 20, 176, 130, 30, ' ', 'X', 'p', 10, 132, 5, 169, 0, 134, 176, 10, 228, 5, 173, 128, '^', 176, 23, 192, 2, 177, 0, 'C', ' ', 20, 244, 5, 29, 160, '-', 'p', 11, 248, 5, 13, 'A', 134, 176, 11, 'H', 5, 'S', 1, '^', 192, 23, 0, 3, 193, 128, '0', ' ', 16, 16, 3, 6, 129, '1', 'p', 12, ' ', 3, 201, 128, '2', 176, 12, '0', 3, 205, 128, '3', 240, 12, '@', 4, 'C', 129, '4', '0', 13, 'P', 3, 'P', 129, '5', 160, 21, 192, 5, 217, 128, '6', 176, 13, 'p', 3, 24, 129, 134, 240, 13, 128, 3, 225, 128, '8', '0', 16, 144, 3, 7, 129, '9', 'p', 14, 160, 3, 233, 128, ':', 176, 14, 176, 3, 237, 128, ';', 240, 14, 'D', 4, 'D', 129, '<', '0', 15, 208, 3, 'Q', 129, '=', 176, 21, 196, 5, 249, 128, '>', 176, 15, 240, 3, 25, 193, 134, 240, 15, 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '2', 0, 0, 14, 0, 172, ' ', 0, 160, 1, 'J', 6, 30, 160, 9, 8, 2, 134, 128, 198, 2, 12, 8, 22, 228, 128, 'R', 1, 0, 208, 23, 0, 0, 0, 0, 6, 152, 1, 'r', 128, 29, 160, 8, '8', 1, 'R', 128, 220, 130, 'H', 24, 22, 232, 128, 'S', 1, 0, 224, 23, 224, 5, 160, '@', '(', ' ', 10, 140, 2, 164, '@', ')', '`', 10, 156, 2, 168, '@', '*', 160, 10, 172, 2, 172, '@', '+', 224, 10, 188, 2, 176, '@', ',', ' ', 11, 204, 2, 180, '@', '-', '`', 11, 220, 2, 184, '@', '.', 160, 11, 236, 2, 188, '@', '/', 224, 11, 252, 2, 192, '@', '0', ' ', 12, 12, 3, 196, '@', '1', '`', 12, 28, 3, 200, '@', '2', 160, 12, ',', 3, 204, '@', '3', 224, 12, '<', 3, 208, '@', '4', ' ', 13, 'L', 3, 212, '@', '5', '`', 13, '\\', 3, 216, '@', '6', 160, 13, 'l', 3, 220, '@', '7', 224, 13, '|', 3, 224, '@', '8', ' ', 14, 140, 3, 228, '@', '9', '`', 14, 156, 3, 232, '@', ':', 160, 14, 172, 3, 236, '@', ';', 224, 14, 188, 3, 240, '@', '<', ' ', 15, 204, 3, 244, '@', '=', '`', 15, 220, 3, 248, '@', '>', 160, 15, 236, 3, 252, '@', '?', 224, 15, 252, 3}

func _fuzzycmp(tls *TLS, a uintptr, b uintptr) (r int32) {
	for *(*int8)(unsafe.Pointer(a)) != 0 && *(*int8)(unsafe.Pointer(b)) != 0 {
		for *(*int8)(unsafe.Pointer(a)) != 0 && uint32(*(*int8)(unsafe.Pointer(a)))|uint32(32)-uint32('a') > uint32(26) && uint32(int32(*(*int8)(unsafe.Pointer(a)))-int32('0')) > uint32(10) {
			a++
		}
		if uint32(*(*int8)(unsafe.Pointer(a)))|uint32(32) != uint32(*(*int8)(unsafe.Pointer(b))) {
			return int32(1)
		}
		goto _1
	_1:
		a++
		b++
	}
	return BoolInt32(int32(*(*int8)(unsafe.Pointer(a))) != int32(*(*int8)(unsafe.Pointer(b))))
}

func _find_charmap(tls *TLS, name uintptr) (r uint64) {
	var s uintptr
	for s = uintptr(unsafe.Pointer(&_charmaps)); *(*uint8)(unsafe.Pointer(s)) != 0; {
		if !(_fuzzycmp(tls, name, s) != 0) {
			for *(*uint8)(unsafe.Pointer(s)) != 0 {
				goto _1
			_1:
				s += uintptr(x_strlen(tls, s) + uint64(1))
			}
			return uint64(int64(s+uintptr(1)) - int64(uintptr(unsafe.Pointer(&_charmaps))))
		}
		s += uintptr(x_strlen(tls, s) + uint64(1))
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			s += uintptr(((int32(128)-int32(*(*uint8)(unsafe.Pointer(s + 2))))*int32(*(*uint8)(unsafe.Pointer(s + 1)))+int32(7))/int32(8) + int32(3))
		}
	}
	return uint64(-Int32FromInt32(1))
}

func x_iconv_open(tls *TLS, to uintptr, from uintptr) (r uintptr) {
	var f, t, v1, v2 uint64
	var v3 bool
	v1 = _find_charmap(tls, to)
	t = v1
	if v3 = v1 < uint64(0); !v3 {
		v2 = _find_charmap(tls, from)
		f = v2
	}
	if v3 || v2 < uint64(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(-Int32FromInt32(1))
	}
	return uintptr(f<<Int32FromInt32(16) | t)
}

func x_iconv_close(tls *TLS, cd uintptr) (r int32) {
	return 0
}

func _get_16(tls *TLS, s uintptr, e int32) (r uint32) {
	e &= int32(1)
	return uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(s + uintptr(int32(1)-e)))))
}

func _put_16(tls *TLS, s uintptr, c uint32, e int32) {
	e &= int32(1)
	*(*uint8)(unsafe.Pointer(s + uintptr(e))) = uint8(c >> int32(8))
	*(*uint8)(unsafe.Pointer(s + uintptr(int32(1)-e))) = uint8(c)
}

func _get_32(tls *TLS, s uintptr, e int32) (r uint32) {
	return (uint32(*(*uint8)(unsafe.Pointer(s + uintptr(e))))+0)<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(1)))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(2)))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(3)))))
}

func _put_32(tls *TLS, s uintptr, c uint32, e int32) {
	*(*uint8)(unsafe.Pointer(s + uintptr(e^0))) = uint8(c >> int32(24))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(1)))) = uint8(c >> int32(16))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(2)))) = uint8(c >> int32(8))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(3)))) = uint8(c)
}

func _get_mapping(tls *TLS, m uintptr, c uint32, n uint32) (r uint32) {
	switch n {
	default:
		fallthrough
	case uint32(9):
		return uint32(int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(9)/uint32(8)))))>>(c%uint32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(9)/uint32(8)+uint32(1)))))<<(uint32(8)-c%uint32(8))&(int32(1)<<n-int32(1)))
	case uint32(10):
		return uint32(int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(10)/uint32(8)))))>>(uint32(2)*c%uint32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(10)/uint32(8)+uint32(1)))))<<(uint32(8)-uint32(2)*c%uint32(8))&(int32(1)<<n-int32(1)))
	case uint32(11):
		return uint32((Int32FromInt32(1)<<Int32FromInt32(11) - Int32FromInt32(1)) & (int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(11))/uint32(8)))))>>(uint32(Int32FromInt32(11)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(11))/uint32(8)+uint32(1)))))<<(Uint32FromInt32(8)-uint32(Int32FromInt32(11)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(11))/uint32(8)+uint32(2)))))<<(Uint32FromInt32(16)-uint32(Int32FromInt32(11)%Int32FromInt32(8))*c%Uint32FromInt32(8))))
	case uint32(13):
		return uint32((Int32FromInt32(1)<<Int32FromInt32(13) - Int32FromInt32(1)) & (int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(13))/uint32(8)))))>>(uint32(Int32FromInt32(13)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(13))/uint32(8)+uint32(1)))))<<(Uint32FromInt32(8)-uint32(Int32FromInt32(13)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(13))/uint32(8)+uint32(2)))))<<(Uint32FromInt32(16)-uint32(Int32FromInt32(13)%Int32FromInt32(8))*c%Uint32FromInt32(8))))
	case uint32(14):
		return uint32((Int32FromInt32(1)<<Int32FromInt32(14) - Int32FromInt32(1)) & (int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(14))/uint32(8)))))>>(uint32(Int32FromInt32(14)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(14))/uint32(8)+uint32(1)))))<<(Uint32FromInt32(8)-uint32(Int32FromInt32(14)%Int32FromInt32(8))*c%Uint32FromInt32(8)) | int32(*(*uint8)(unsafe.Pointer(m + uintptr(c*uint32(Int32FromInt32(14))/uint32(8)+uint32(2)))))<<(Uint32FromInt32(16)-uint32(Int32FromInt32(14)%Int32FromInt32(8))*c%Uint32FromInt32(8))))
	}
	return r
}

func x_iconv(tls *TLS, cd0 uintptr, in uintptr, inb uintptr, out uintptr, outb uintptr) (r uint64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var c, d, elide, from, to, toelide uint32
	var cd, k, l, x uint64
	var err int32
	var map1, tomap, v48, v49 uintptr
	var totype, type1 uint8
	var _ /* st at bp+0 */ Tmbstate_t
	var _ /* tmp at bp+12 */ [4]int8
	var _ /* wc at bp+8 */ int32
	x = uint64(0)
	cd = uint64(cd0)
	to = uint32(cd & uint64(0xffff))
	from = uint32(cd >> int32(16))
	map1 = uintptr(unsafe.Pointer(&_charmaps)) + uintptr(from) + uintptr(2)
	tomap = uintptr(unsafe.Pointer(&_charmaps)) + uintptr(to) + uintptr(2)
	*(*Tmbstate_t)(unsafe.Pointer(bp)) = Tmbstate_t{}
	elide = uint32(int32(*(*uint8)(unsafe.Pointer(map1 + uintptr(-Int32FromInt32(1))))) + int32(128))
	toelide = uint32(int32(*(*uint8)(unsafe.Pointer(tomap + uintptr(-Int32FromInt32(1))))) + int32(128))
	type1 = *(*uint8)(unsafe.Pointer(map1 + uintptr(-Int32FromInt32(2))))
	totype = *(*uint8)(unsafe.Pointer(tomap + uintptr(-Int32FromInt32(2))))
	if !(in != 0) || !(*(*uintptr)(unsafe.Pointer(in)) != 0) || !(*(*uint64)(unsafe.Pointer(inb)) != 0) {
		return uint64(0)
	}
	for *(*uint64)(unsafe.Pointer(inb)) != 0 {
		c = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)))))
		l = uint64(1)
		if int32(type1) < int32(8) || c >= uint32(0x80) {
			switch int32(type1) {
			case int32(m_UTF_8):
				goto _2
			case int32(m_LATIN_9):
				goto _3
			case int32(m_TIS_620):
				goto _4
			case int32(m_JIS_0201):
				goto _5
			case int32(14):
				goto _6
			case int32(13):
				goto _7
			case int32(11):
				goto _8
			case int32(10):
				goto _9
			case int32(9):
				goto _10
			case int32(m_US_ASCII):
				goto _11
			case int32(m_WCHAR_T):
				goto _12
			case int32(m_UTF_32LE):
				goto _13
			case m_UTF_32BE:
				goto _14
			case int32(m_UTF_16LE):
				goto _15
			case int32(m_UTF_16BE):
				goto _16
			case int32(m_UCS2LE):
				goto _17
			case int32(m_UCS2BE):
				goto _18
			}
			goto _19
		_2:
			l = x_mbrtowc(tls, bp+8, *(*uintptr)(unsafe.Pointer(in)), *(*uint64)(unsafe.Pointer(inb)), bp)
			if !(l != 0) {
				l++
			} else {
				if l == uint64(-Int32FromInt32(1)) {
					goto ilseq
				} else if l == uint64(-Int32FromInt32(2)) {
					goto starved
				}
			}
			c = uint32(*(*int32)(unsafe.Pointer(bp + 8)))
			goto _19
		_3:
			if c-uint32(0xa4) <= uint32(Int32FromInt32(0xbe)-Int32FromInt32(0xa4)) {
				if c == uint32(0xa4) {
					c = uint32(0x20ac)
				} else if _map[c-uint32(0xa5)] != 0 {
					c = uint32(int32(0x100) | int32(_map[c-uint32(0xa5)]))
				}
			}
			goto _19
		_4:
			if c >= uint32(0xa1) {
				c += uint32(Int32FromInt32(0x0e01) - Int32FromInt32(0xa1))
			}
			goto _19
		_5:
			if c >= uint32(0xa1) {
				if c <= uint32(0xdf) {
					c += uint32(Int32FromInt32(0xff61) - Int32FromInt32(0xa1))
				} else {
					goto ilseq
				}
			}
			goto _19
		_10:
		_9:
		_8:
		_7:
		_6:
			if c < elide {
				goto _19
			}
			c = _get_mapping(tls, map1, c-elide, uint32(type1))
			if !!(c != 0) {
				goto _20
			}
		_11:
			goto ilseq
		_20:
			goto _19
		_12:
			l = uint64(4)
			if *(*uint64)(unsafe.Pointer(inb)) < l {
				goto starved
			}
			c = uint32(*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)))))
			if !(0 != 0) {
				goto _21
			}
		_14:
		_13:
			l = uint64(4)
			if *(*uint64)(unsafe.Pointer(inb)) < uint64(4) {
				goto starved
			}
			c = _get_32(tls, *(*uintptr)(unsafe.Pointer(in)), int32(type1))
		_21:
			if c-uint32(0xd800) < uint32(0x800) || c >= uint32(0x110000) {
				goto ilseq
			}
			goto _19
		_18:
		_17:
		_16:
		_15:
			l = uint64(2)
			if *(*uint64)(unsafe.Pointer(inb)) < uint64(2) {
				goto starved
			}
			c = _get_16(tls, *(*uintptr)(unsafe.Pointer(in)), int32(type1))
			if c-Uint32FromInt32(0xdc00) < uint32(0x400) {
				goto ilseq
			}
			if c-Uint32FromInt32(0xd800) < uint32(0x400) {
				if uint32(int32(type1)-int32(m_UCS2BE)) < uint32(2) {
					goto ilseq
				}
				l = uint64(4)
				if *(*uint64)(unsafe.Pointer(inb)) < uint64(4) {
					goto starved
				}
				d = _get_16(tls, *(*uintptr)(unsafe.Pointer(in))+uintptr(2), int32(from))
				if c-Uint32FromInt32(0xdc00) >= uint32(0x400) {
					goto ilseq
				}
				c = (c-uint32(0xd800))<<int32(10) | (d - uint32(0xdc00))
			}
			goto _19
		_19:
		}
		switch int32(totype) {
		case int32(m_WCHAR_T):
			goto _22
		case int32(m_UTF_8):
			goto _23
		case int32(m_TIS_620):
			goto _24
		case int32(m_JIS_0201):
			goto _25
		case int32(m_US_ASCII):
			goto _26
		case int32(m_LATIN_9):
			goto _27
		case int32(14):
			goto _28
		case int32(13):
			goto _29
		case int32(11):
			goto _30
		case int32(10):
			goto _31
		case int32(9):
			goto _32
		case int32(m_UTF_16LE):
			goto _33
		case int32(m_UTF_16BE):
			goto _34
		case int32(m_UCS2LE):
			goto _35
		case int32(m_UCS2BE):
			goto _36
		case int32(m_UTF_32LE):
			goto _37
		case m_UTF_32BE:
			goto _38
		}
		goto _39
	_22:
		if *(*uint64)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out)))) = int32(c)
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*uint64)(unsafe.Pointer(outb)) -= uint64(4)
		goto _39
	_23:
		if *(*uint64)(unsafe.Pointer(outb)) < uint64(4) {
			k = uint64(x_wctomb(tls, bp+12, int32(c)))
			if *(*uint64)(unsafe.Pointer(outb)) < k {
				goto toobig
			}
			x_memcpy(tls, *(*uintptr)(unsafe.Pointer(out)), bp+12, k)
		} else {
			k = uint64(x_wctomb(tls, *(*uintptr)(unsafe.Pointer(out)), int32(c)))
		}
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(k)
		*(*uint64)(unsafe.Pointer(outb)) -= k
		goto _39
	_24:
		if c-uint32(0xe01) <= uint32(Int32FromInt32(0xff)-Int32FromInt32(0xa1)) {
			c -= uint32(Int32FromInt32(0xe01) - Int32FromInt32(0xa1))
		} else if c >= uint32(0xa1) {
			goto ascii
		}
		goto revout
	_25:
		if c-uint32(0xff61) <= uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) {
			c -= uint32(Int32FromInt32(0xff61) - Int32FromInt32(0xa1))
		} else if c >= uint32(0xa1) {
			goto ascii
		}
		goto revout
	_27:
		if !(c == uint32(0x20ac)) {
			goto _40
		}
		c = uint32(0xa4)
		goto _41
	_40:
		if !(c-uint32(0x150) <= uint32(0x12) && int32(1)<<(c-uint32(0x150))&int32(0x3000c) != 0) {
			goto _42
		}
		c = uint32(_map1[c&uint32(3)])
		goto _43
	_42:
		if !(c-uint32(0x178) <= uint32(0x7) && int32(1)<<(c-uint32(0x178))&int32(0x61) != 0) {
			goto _44
		}
		c = uint32(_map2[c&uint32(7)])
		goto _45
	_44:
		if !(c > uint32(0x100) || c-uint32(0xa5) <= Uint32FromUint32(0xbe)-Uint32FromInt32(0xa5) && int32(1)<<(c-uint32(0xa5))&int32(0x388800a) != 0) {
			goto _46
		}
	_26:
	ascii:
		if c > uint32(0x7f) {
			x++
			c = Uint32FromUint8('*')
		}
	_46:
	_45:
	_43:
	_41:
	_32:
	_31:
	_30:
	_29:
	_28:
		if *(*uint64)(unsafe.Pointer(outb)) < uint64(1) {
			goto toobig
		}
		if !(c < toelide) {
			goto _47
		}
	revout:
		v49 = out
		v48 = *(*uintptr)(unsafe.Pointer(v49))
		*(*uintptr)(unsafe.Pointer(v49))++
		*(*int8)(unsafe.Pointer(v48)) = int8(c)
		*(*uint64)(unsafe.Pointer(outb)) -= uint64(1)
		goto _39
	_47:
		for d = uint32(0); d < uint32(256)-toelide; d++ {
			if c == _get_mapping(tls, tomap, d, uint32(totype)) {
				c = d + toelide
				goto revout
			}
		}
		x++
		c = uint32('*')
		goto revout
	_36:
	_35:
	_34:
	_33:
		if c < uint32(0x10000) {
			if *(*uint64)(unsafe.Pointer(outb)) < uint64(2) {
				goto toobig
			}
			_put_16(tls, *(*uintptr)(unsafe.Pointer(out)), c, int32(totype))
			*(*uintptr)(unsafe.Pointer(out)) += uintptr(2)
			*(*uint64)(unsafe.Pointer(outb)) -= uint64(2)
			goto _39
		}
		if uint32(int32(type1)-int32(m_UCS2BE)) < uint32(2) {
			goto ilseq
		}
		if *(*uint64)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		_put_16(tls, *(*uintptr)(unsafe.Pointer(out)), c>>int32(10)|uint32(0xd800), int32(totype))
		_put_16(tls, *(*uintptr)(unsafe.Pointer(out))+uintptr(2), c&uint32(0x3ff)|uint32(0xdc00), int32(totype))
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*uint64)(unsafe.Pointer(outb)) -= uint64(4)
		goto _39
	_38:
	_37:
		if *(*uint64)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		_put_32(tls, *(*uintptr)(unsafe.Pointer(out)), c, int32(totype))
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*uint64)(unsafe.Pointer(outb)) -= uint64(4)
		goto _39
	_39:
		goto _1
	_1:
		*(*uintptr)(unsafe.Pointer(in)) += uintptr(l)
		*(*uint64)(unsafe.Pointer(inb)) -= l
	}
	return x
ilseq:
	err = int32(m_EILSEQ)
	x = uint64(-Int32FromInt32(1))
	goto end
toobig:
	err = int32(m_E2BIG)
	goto end
starved:
	err = int32(m_EINVAL)
end:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = err
	return x
}

var _map = [26]uint8{
	0:  uint8(0),
	1:  uint8(0x60),
	2:  uint8(0),
	3:  uint8(0x61),
	4:  uint8(0),
	5:  uint8(0),
	6:  uint8(0),
	7:  uint8(0),
	8:  uint8(0),
	9:  uint8(0),
	10: uint8(0),
	11: uint8(0),
	12: uint8(0),
	13: uint8(0),
	14: uint8(0),
	15: uint8(0x7d),
	16: uint8(0),
	17: uint8(0),
	18: uint8(0),
	19: uint8(0x7e),
	20: uint8(0),
	21: uint8(0),
	22: uint8(0),
	23: uint8(0x52),
	24: uint8(0x53),
	25: uint8(0x78)}

var _map1 = [4]uint8{
	0: uint8(0xa6),
	1: uint8(0xa8),
	2: uint8(0xbc),
	3: uint8(0xbd)}

var _map2 = [7]uint8{
	0: uint8(0xbe),
	1: uint8(0),
	2: uint8(0),
	3: uint8(0),
	4: uint8(0),
	5: uint8(0xb4),
	6: uint8(0xb8)}

func x_gettext(tls *TLS, msgid uintptr) (r uintptr) {
	return msgid
}

func x_dgettext(tls *TLS, domainname uintptr, msgid uintptr) (r uintptr) {
	return msgid
}

func x_dcgettext(tls *TLS, domainname uintptr, msgid uintptr, category int32) (r uintptr) {
	return msgid
}

func x_ngettext(tls *TLS, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	var v1 uintptr
	if n == uint64(1) {
		v1 = msgid1
	} else {
		v1 = msgid2
	}
	return v1
}

func x_dngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	var v1 uintptr
	if n == uint64(1) {
		v1 = msgid1
	} else {
		v1 = msgid2
	}
	return v1
}

func x_dcngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64, category int32) (r uintptr) {
	var v1 uintptr
	if n == uint64(1) {
		v1 = msgid1
	} else {
		v1 = msgid2
	}
	return v1
}

func x_textdomain(tls *TLS, domainname uintptr) (r uintptr) {
	if domainname != 0 && *(*int8)(unsafe.Pointer(domainname)) != 0 && x_strcmp(tls, domainname, uintptr(unsafe.Pointer(&_default_str))) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&_default_str))
}

var _default_str = [9]int8{'m', 'e', 's', 's', 'a', 'g', 'e', 's'}

func x_bindtextdomain(tls *TLS, domainname uintptr, dirname uintptr) (r uintptr) {
	if !(domainname != 0) || !(*(*int8)(unsafe.Pointer(domainname)) != 0) || dirname != 0 && (int32(*(*int8)(unsafe.Pointer(dirname))) != int32('/') || *(*int8)(unsafe.Pointer(dirname + 1)) != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&_dir))
}

var _dir = [2]int8{'/'}

func x_bind_textdomain_codeset(tls *TLS, domainname uintptr, codeset uintptr) (r uintptr) {
	if !(domainname != 0) || !(*(*int8)(unsafe.Pointer(domainname)) != 0) || codeset != 0 && x_strcasecmp(tls, codeset, ts+148) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
	}
	return UintptrFromInt32(0)
}

func x_isalnum_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_isalnum(tls, c)
}

func x_isalpha_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c|Int32FromInt32(32)-Int32FromUint8('a')) < uint32(26))
}

func x_isblank_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_isblank(tls, c)
}

func x_iscntrl_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_iscntrl(tls, c)
}

func x_isdigit_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c-Int32FromUint8('0')) < uint32(10))
}

func x_isgraph_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c-Int32FromInt32(0x21)) < uint32(0x5e))
}

func x_islower_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c-Int32FromUint8('a')) < uint32(26))
}

func x_isprint_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c-Int32FromInt32(0x20)) < uint32(0x5f))
}

func x_ispunct_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_ispunct(tls, c)
}

func x_isspace_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_isspace(tls, c)
}

func x_isupper_l(tls *TLS, c int32, l uintptr) (r int32) {
	return BoolInt32(uint32(c-Int32FromUint8('A')) < uint32(26))
}

func x_isxdigit_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_isxdigit(tls, c)
}

const m_CODESET = 14
const m_LC_MESSAGES = 5
const m_LC_MONETARY = 4
const m_LC_NUMERIC = 1
const m_LC_TIME = 2

var _c_time = [312]int8{'S', 'u', 'n', 0, 'M', 'o', 'n', 0, 'T', 'u', 'e', 0, 'W', 'e', 'd', 0, 'T', 'h', 'u', 0, 'F', 'r', 'i', 0, 'S', 'a', 't', 0, 'S', 'u', 'n', 'd', 'a', 'y', 0, 'M', 'o', 'n', 'd', 'a', 'y', 0, 'T', 'u', 'e', 's', 'd', 'a', 'y', 0, 'W', 'e', 'd', 'n', 'e', 's', 'd', 'a', 'y', 0, 'T', 'h', 'u', 'r', 's', 'd', 'a', 'y', 0, 'F', 'r', 'i', 'd', 'a', 'y', 0, 'S', 'a', 't', 'u', 'r', 'd', 'a', 'y', 0, 'J', 'a', 'n', 0, 'F', 'e', 'b', 0, 'M', 'a', 'r', 0, 'A', 'p', 'r', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 0, 'J', 'u', 'l', 0, 'A', 'u', 'g', 0, 'S', 'e', 'p', 0, 'O', 'c', 't', 0, 'N', 'o', 'v', 0, 'D', 'e', 'c', 0, 'J', 'a', 'n', 'u', 'a', 'r', 'y', 0, 'F', 'e', 'b', 'r', 'u', 'a', 'r', 'y', 0, 'M', 'a', 'r', 'c', 'h', 0, 'A', 'p', 'r', 'i', 'l', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 'e', 0, 'J', 'u', 'l', 'y', 0, 'A', 'u', 'g', 'u', 's', 't', 0, 'S', 'e', 'p', 't', 'e', 'm', 'b', 'e', 'r', 0, 'O', 'c', 't', 'o', 'b', 'e', 'r', 0, 'N', 'o', 'v', 'e', 'm', 'b', 'e', 'r', 0, 'D', 'e', 'c', 'e', 'm', 'b', 'e', 'r', 0, 'A', 'M', 0, 'P', 'M', 0, '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, '%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p', 0, 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 1, '2', '3', '4', '5', '6', '7', '8', '9', '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S'}

var _c_messages = [12]int8{'^', '[', 'y', 'Y', ']', 0, '^', '[', 'n', 'N', ']'}
var _c_numeric = [3]int8{'.'}

func x___langinfo(tls *TLS, item int32) (r uintptr) {
	var cat, idx int32
	var str uintptr
	cat = item >> int32(16)
	idx = item & int32(65535)
	if item == int32(m_CODESET) {
		return ts + 148
	}
	switch cat {
	case int32(m_LC_NUMERIC):
		if idx > int32(1) {
			return UintptrFromInt32(0)
		}
		str = uintptr(unsafe.Pointer(&_c_numeric))
	case int32(m_LC_TIME):
		if idx > int32(0x31) {
			return UintptrFromInt32(0)
		}
		str = uintptr(unsafe.Pointer(&_c_time))
	case int32(m_LC_MONETARY):
		if idx > 0 {
			return UintptrFromInt32(0)
		}
		str = ts
	case int32(m_LC_MESSAGES):
		if idx > int32(1) {
			return UintptrFromInt32(0)
		}
		str = uintptr(unsafe.Pointer(&_c_messages))
	default:
		return UintptrFromInt32(0)
	}
	for idx != 0 {
		for ; *(*int8)(unsafe.Pointer(str)) != 0; str++ {
		}
		goto _1
	_1:
		idx--
		str++
	}
	return str
}

func x_localeconv(tls *TLS) (r uintptr) {
	if _posix_lconv != 0 {
		return _posix_lconv
	}
	_posix_lconv = x_malloc(tls, uint64(96))
	x_memset(tls, _posix_lconv, -int32(1), uint64(96))
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fdecimal_point = ts + 154
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fthousands_sep = ts
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fgrouping = ts + 156
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fint_curr_symbol = ts //"\xc2\xa4";
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fcurrency_symbol = ts
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fmon_decimal_point = ts
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fmon_thousands_sep = ts
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fmon_grouping = ts + 156
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fpositive_sign = ts // "+";
	(*Tlconv)(unsafe.Pointer(_posix_lconv)).Fnegative_sign = ts // "-";
	return _posix_lconv
}

var _posix_lconv uintptr

func x_newlocale(tls *TLS, mask int32, name uintptr, base uintptr) (r uintptr) {
	if *(*int8)(unsafe.Pointer(name)) != 0 && x_strcmp(tls, name, ts+158) != 0 && x_strcmp(tls, name, ts+160) != 0 {
		return uintptr(0)
	}
	if !(base != 0) {
		base = x_calloc(tls, uint64(1), uint64(4))
	}
	return base
}

func x_nl_langinfo(tls *TLS, item int32) (r uintptr) {
	switch item {
	case int32(m_CODESET):
		return ts + 148
	default:
		return ts
	}
	return r
}

func x_setlocale(tls *TLS, category int32, locale uintptr) (r uintptr) {
	/* Note: plain "C" would be better, but puts some broken
	 * software into legacy 8-bit-codepage mode, ignoring
	 * the standard library's multibyte encoding */
	return ts + 166
}

func x_strcoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	return x_strcmp(tls, l, r)
}

// C documentation
//
//	/* collate only by code points */
func x_strxfrm(tls *TLS, dest uintptr, src uintptr, n uint64) (r uint64) {
	var l uint64
	l = x_strlen(tls, src)
	if n > l {
		x_strcpy(tls, dest, src)
	}
	return l
}

func x_tolower_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_tolower(tls, c)
}

func x_toupper_l(tls *TLS, c int32, l uintptr) (r int32) {
	return x_toupper(tls, c)
}

// C documentation
//
//	/* FIXME: stub */
func x_wcscoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	return x_wcscmp(tls, l, r)
}

// C documentation
//
//	/* collate only by code points */
func x_wcsxfrm(tls *TLS, dest uintptr, src uintptr, n uint64) (r uint64) {
	var l uint64
	l = x_wcslen(tls, src)
	if l >= n {
		x_wmemcpy(tls, dest, src, n-uint64(1))
		*(*int32)(unsafe.Pointer(dest + uintptr(n-uint64(1))*4)) = 0
	} else {
		x_wcscpy(tls, dest, src)
	}
	return l
}

func x___brk(tls *TLS, newbrk uint64) (r uint64) {
	return uint64(_syscall1(tls, int64(m___NR_brk), int64(newbrk)))
}

const m_ALIGN = 16

//#define LFS64_2(x, y) weak_alias(x, y)

func x___simple_malloc(tls *TLS, n uint64) (r uintptr) {
	var align, base, new1, v2 uint64
	align = uint64(1)
	if n < Uint64FromUint64(0xffffffffffffffff)-Uint64FromInt32(m_ALIGN) {
		for align < n && align < uint64(m_ALIGN) {
			align += align
		}
	}
	n = (n + align - uint64(1)) & -align
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock2)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock2))
		_ = Int32FromInt32(1)
	}
	if !(_cur != 0) {
		v2 = x___brk(tls, uint64(0)) + Uint64FromInt32(16)
		_brk = v2
		_cur = v2
	}
	if n > uint64(0xffffffffffffffff)-_brk {
		goto fail
	}
	base = (_cur + align - uint64(1)) & -align
	if base+n > _brk {
		new1 = (base + n + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
		if x___brk(tls, new1) != new1 {
			goto fail
		}
		_brk = new1
	}
	_cur = base + n
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock2)))) = 0
	return uintptr(base)
fail:
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock2)))) = 0
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
	return uintptr(0)
}

var _cur uint64

var _brk uint64

var _lock2 int32

func x_calloc(tls *TLS, m uint64, n uint64) (r uintptr) {
	var p, z uintptr
	if n != 0 && m > uint64(-Int32FromInt32(1))/n {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	n *= m
	p = x_malloc(tls, n)
	if !(p != 0) {
		return uintptr(0)
	}
	/* Only do this for non-mmapped chunks */
	if *(*uint64)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))*8))&uint64(7) != 0 {
		/* Only write words that are not already zero */
		m = (n + uint64(8) - uint64(1)) / uint64(8)
		for z = p; m != 0; {
			if *(*uint64)(unsafe.Pointer(z)) != 0 {
				*(*uint64)(unsafe.Pointer(z)) = uint64(0)
			}
			goto _1
		_1:
			m--
			z += 8
		}
	}
	return p
}

const m_DONTCARE = 16
const m_MADV_DONTNEED = 4
const m_MAP_ANON = 32
const m_MAP_PRIVATE = 2
const m_MREMAP_MAYMOVE = 1
const m_PROT_READ = 1
const m_PROT_WRITE = 2
const m_RECLAIM = 163840

type T__pthread = struct {
	Fself          uintptr
	Ftlsdesc       [4]uint64
	Ftid           int32
	Fpid           int32
	Ftsd_used      int32
	Ferrno_val     int32
	Ferrno_ptr     uintptr
	Fcanceldisable int32
	Fcancelasync   int32
	Fcancelpoint   int32
	Fcancel        int32
	Fmap_base      uintptr
	Fmap_size      uint64
	Fstart_arg     uintptr
	Fstart         uintptr
	Fresult        uintptr
	Fexit_jmp_buf  Tjmp_buf
	Fdetached      int32
	Fexitlock      int32
	Fcancelbuf     uintptr
	Ftsd           uintptr
	Fattr          Tpthread_attr_t
}

type Tsched_param = struct {
	Fsched_priority        int32
	Fsched_ss_low_priority int32
	Fsched_ss_repl_period  Ttimespec
	Fsched_ss_init_budget  Ttimespec
	Fsched_ss_max_repl     int32
	F__ccgo_pad5           [4]byte
}

type Ttm = struct {
	Ftm_sec      int32
	Ftm_min      int32
	Ftm_hour     int32
	Ftm_mday     int32
	Ftm_mon      int32
	Ftm_year     int32
	Ftm_wday     int32
	Ftm_yday     int32
	Ftm_isdst    int32
	F__tm_gmtoff int64
	F__tm_zone   uintptr
}

type Titimerspec = struct {
	Fit_interval Ttimespec
	Fit_value    Ttimespec
}

type T__ptcb = struct {
	F__jb    [7]int64
	F__dummy int32
	F__next  uintptr
	F__ptrs  [3]uintptr
}

type Tjmp_buf = [9]uint64

type Tsigjmp_buf = [25]uint64

type Tchunk = struct {
	Fdata [1]uint64
	Fnext uintptr
	Fprev uintptr
}

type Tbin = struct {
	Flock [2]int32
	Fhead uintptr
	Ftail uintptr
}

var _mal struct {
	Fbrk       uint64
	Fheap      uintptr
	Fbinmap    uint64
	Fbins      [64]Tbin
	Fbrk_lock  [2]int32
	Ffree_lock [2]int32
}

func _lock3(tls *TLS, lk uintptr) {
	if !(x___libc.Fthreads_minus_1 != 0) {
		return
	}
	for _a_swap(tls, lk, int32(1)) != 0 {
		x___wait(tls, lk, lk+uintptr(1)*4, int32(1), int32(1))
	}
}

func _unlock(tls *TLS, lk uintptr) {
	if !(x___libc.Fthreads_minus_1 != 0) {
		return
	}
	_a_store(tls, lk, 0)
	if *(*int32)(unsafe.Pointer(lk + 1*4)) != 0 {
		x___wake(tls, lk, int32(1), int32(1))
	}
}

func _lock_bin(tls *TLS, i int32) {
	var v1 uintptr
	if x___libc.Fthreads_minus_1 != 0 {
		_lock3(tls, uintptr(unsafe.Pointer(&(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Flock)))
	}
	if !((*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Fhead != 0) {
		v1 = uintptr(unsafe.Pointer(&(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Fhead)) - UintptrFromInt32(1)*8
		(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Ftail = v1
		(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Fhead = v1
	}
}

func _unlock_bin(tls *TLS, i int32) {
	if !(x___libc.Fthreads_minus_1 != 0) {
		return
	}
	_unlock(tls, uintptr(unsafe.Pointer(&(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Flock)))
}

func _first_set(tls *TLS, x uint64) (r int32) {
	return _a_ctz_64(tls, x)
}

func _bin_index(tls *TLS, x uint64) (r int32) {
	var v1 float32
	x = x/(Uint64FromInt32(4)*Uint64FromInt64(8)) - uint64(1)
	if x <= uint64(32) {
		return int32(x)
	}
	if x > uint64(0x1c00) {
		return int32(63)
	}
	v1 = float32(x)
	return int32(*(*uint32)(unsafe.Pointer(&v1))>>Int32FromInt32(21) - uint32(496))
}

func _bin_index_up(tls *TLS, x uint64) (r int32) {
	var v1 float32
	x = x/(Uint64FromInt32(4)*Uint64FromInt64(8)) - uint64(1)
	if x <= uint64(32) {
		return int32(x)
	}
	v1 = float32(x)
	return int32((*(*uint32)(unsafe.Pointer(&v1))+uint32(0x1fffff))>>int32(21) - uint32(496))
}

func _expand_heap(tls *TLS, n uint64) (r uintptr) {
	var new1 uint64
	var w uintptr
	_lock3(tls, uintptr(unsafe.Pointer(&_mal.Fbrk_lock)))
	if n > uint64(0xffffffffffffffff)-_mal.Fbrk-uint64(Int32FromInt32(2)*Int32FromInt32(m_PAGESIZE)) {
		goto fail
	}
	new1 = (_mal.Fbrk + n + Uint64FromInt32(4)*Uint64FromInt64(8) + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
	n = new1 - _mal.Fbrk
	if x___brk(tls, new1) != new1 {
		goto fail
	}
	w = uintptr(new1) - UintptrFromInt32(1)*8
	*(*uint64)(unsafe.Pointer(w + uintptr(-Int32FromInt32(1))*8)) = n | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(w)) = Uint64FromInt32(0) | Uint64FromInt32(1)
	w = uintptr(_mal.Fbrk) - UintptrFromInt32(1)*8
	*(*uint64)(unsafe.Pointer(w)) = n | Uint64FromInt32(1)
	_mal.Fbrk = new1
	_unlock(tls, uintptr(unsafe.Pointer(&_mal.Fbrk_lock)))
	return w
fail:
	_unlock(tls, uintptr(unsafe.Pointer(&_mal.Fbrk_lock)))
	return uintptr(0)
}

func _init_malloc(tls *TLS) (r int32) {
	var c uintptr
	var state, v1 int32
	if _init == int32(2) {
		return 0
	}
	for {
		v1 = _a_swap(tls, uintptr(unsafe.Pointer(&_init)), int32(1))
		state = v1
		if !(v1 == int32(1)) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&_init)), uintptr(unsafe.Pointer(&_waiters)), int32(1), int32(1))
	}
	if state != 0 {
		_a_store(tls, uintptr(unsafe.Pointer(&_init)), int32(2))
		return 0
	}
	_mal.Fbrk = (x___brk(tls, uint64(0)) + Uint64FromInt32(2)*(Uint64FromInt32(4)*Uint64FromInt64(8)) - uint64(1)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	c = _expand_heap(tls, uint64(1))
	if !(c != 0) {
		_a_store(tls, uintptr(unsafe.Pointer(&_init)), 0)
		if _waiters != 0 {
			x___wake(tls, uintptr(unsafe.Pointer(&_init)), int32(1), int32(1))
		}
		return -int32(1)
	}
	_mal.Fheap = c
	*(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8)) = Uint64FromInt32(0) | Uint64FromInt32(1)
	x_free(tls, c+UintptrFromInt32(1)*8)
	_a_store(tls, uintptr(unsafe.Pointer(&_init)), int32(2))
	if _waiters != 0 {
		x___wake(tls, uintptr(unsafe.Pointer(&_init)), -int32(1), int32(1))
	}
	return 0
}

var _init int32

var _waiters int32

func _adjust_size(tls *TLS, n uintptr) (r int32) {
	/* Result of pointer difference must fit in ptrdiff_t. */
	if *(*uint64)(unsafe.Pointer(n)) > uint64(Int64FromInt64(0x7fffffffffffffff))-Uint64FromInt32(4)*Uint64FromInt64(8)-Uint64FromInt32(m_PAGESIZE) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return -int32(1)
	}
	*(*uint64)(unsafe.Pointer(n)) = (*(*uint64)(unsafe.Pointer(n)) + Uint64FromInt32(2)*Uint64FromInt64(8) + Uint64FromInt32(4)*Uint64FromInt64(8) - uint64(1)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	return 0
}

func _unbin(tls *TLS, c uintptr, i int32) {
	if (*Tchunk)(unsafe.Pointer(c)).Fprev == (*Tchunk)(unsafe.Pointer(c)).Fnext {
		_a_and_64(tls, uintptr(unsafe.Pointer(&_mal.Fbinmap)), ^(Uint64FromUint64(1) << i))
	}
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(c)).Fprev)).Fnext = (*Tchunk)(unsafe.Pointer(c)).Fnext
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(c)).Fnext)).Fprev = (*Tchunk)(unsafe.Pointer(c)).Fprev
	*(*uint64)(unsafe.Pointer(c)) |= Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(c + uintptr(*(*uint64)(unsafe.Pointer(c))&-(Uint64FromInt32(4)*Uint64FromInt64(8))) + uintptr(-Int32FromInt32(1))*8)) |= Uint64FromInt32(1)
}

func _alloc_fwd(tls *TLS, c uintptr) (r int32) {
	var i int32
	var k, v1 uint64
	for {
		v1 = *(*uint64)(unsafe.Pointer(c))
		k = v1
		if !!(v1&Uint64FromInt32(1) != 0) {
			break
		}
		i = _bin_index(tls, k)
		_lock_bin(tls, i)
		if *(*uint64)(unsafe.Pointer(c)) == k {
			_unbin(tls, c, i)
			_unlock_bin(tls, i)
			return int32(1)
		}
		_unlock_bin(tls, i)
	}
	return 0
}

func _alloc_rev(tls *TLS, c uintptr) (r int32) {
	var i int32
	var k, v1 uint64
	for {
		v1 = *(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8))
		k = v1
		if !!(v1&Uint64FromInt32(1) != 0) {
			break
		}
		i = _bin_index(tls, k)
		_lock_bin(tls, i)
		if *(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8)) == k {
			_unbin(tls, c-uintptr(*(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8))&-(Uint64FromInt32(4)*Uint64FromInt64(8))), i)
			_unlock_bin(tls, i)
			return int32(1)
		}
		_unlock_bin(tls, i)
	}
	return 0
}

// C documentation
//
//	/* pretrim - trims a chunk _prior_ to removing it from its bin.
//	 * Must be called with i as the ideal bin for size n, j the bin
//	 * for the _free_ chunk self, and bin j locked. */
func _pretrim(tls *TLS, self uintptr, n uint64, i int32, j int32) (r int32) {
	var n1 uint64
	var next, split uintptr
	/* We cannot pretrim if it would require re-binning. */
	if j < int32(40) {
		return 0
	}
	if j < i+int32(3) {
		if j != int32(63) {
			return 0
		}
		n1 = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
		if n1-n <= Uint64FromInt32(0x1c00)*(Uint64FromInt32(4)*Uint64FromInt64(8)) {
			return 0
		}
	} else {
		n1 = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	}
	if _bin_index(tls, n1-n) != j {
		return 0
	}
	next = self + uintptr(*(*uint64)(unsafe.Pointer(self))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
	split = self + uintptr(n)
	(*Tchunk)(unsafe.Pointer(split)).Fprev = (*Tchunk)(unsafe.Pointer(self)).Fprev
	(*Tchunk)(unsafe.Pointer(split)).Fnext = (*Tchunk)(unsafe.Pointer(self)).Fnext
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(split)).Fprev)).Fnext = split
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(split)).Fnext)).Fprev = split
	*(*uint64)(unsafe.Pointer(split + uintptr(-Int32FromInt32(1))*8)) = n | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(split)) = n1 - n
	*(*uint64)(unsafe.Pointer(next + uintptr(-Int32FromInt32(1))*8)) = n1 - n
	*(*uint64)(unsafe.Pointer(self)) = n | Uint64FromInt32(1)
	return int32(1)
}

func _trim(tls *TLS, self uintptr, n uint64) {
	var n1 uint64
	var next, split uintptr
	n1 = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	if n >= n1-uint64(m_DONTCARE) {
		return
	}
	next = self + uintptr(*(*uint64)(unsafe.Pointer(self))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
	split = self + uintptr(n)
	*(*uint64)(unsafe.Pointer(split + uintptr(-Int32FromInt32(1))*8)) = n | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(split)) = n1 - n | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(next + uintptr(-Int32FromInt32(1))*8)) = n1 - n | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(self)) = n | Uint64FromInt32(1)
	x_free(tls, split+UintptrFromInt32(1)*8)
}

func x_malloc(tls *TLS, _n uint64) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uint64)(unsafe.Pointer(bp)) = _n
	var base, c, x uintptr
	var i, j int32
	var len1, mask, v1 uint64
	if !(*(*uint64)(unsafe.Pointer(bp)) != 0) || _adjust_size(tls, bp) < 0 {
		return uintptr(0)
	}
	if *(*uint64)(unsafe.Pointer(bp)) > Uint64FromInt32(0x1c00)*(Uint64FromInt32(4)*Uint64FromInt64(8)) {
		len1 = (*(*uint64)(unsafe.Pointer(bp)) + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
		base = x___mmap(tls, uintptr(0), len1, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), 0)
		if base == uintptr(-Int32FromInt32(1)) {
			return uintptr(0)
		}
		c = base + uintptr(Uint64FromInt32(4)*Uint64FromInt64(8)) - UintptrFromInt64(8)
		*(*uint64)(unsafe.Pointer(c)) = len1 - (Uint64FromInt32(4)*Uint64FromInt64(8) - Uint64FromInt64(8))
		*(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8)) = Uint64FromInt32(4)*Uint64FromInt64(8) - Uint64FromInt64(8)
		return c + UintptrFromInt32(1)*8
	}
	i = _bin_index_up(tls, *(*uint64)(unsafe.Pointer(bp)))
	for {
		mask = _mal.Fbinmap & -(Uint64FromUint64(1) << i)
		if !(mask != 0) {
			_init_malloc(tls)
			c = _expand_heap(tls, *(*uint64)(unsafe.Pointer(bp)))
			if !(c != 0) {
				return uintptr(0)
			}
			if _alloc_rev(tls, c) != 0 {
				x = c
				c = c - uintptr(*(*uint64)(unsafe.Pointer(c + uintptr(-Int32FromInt32(1))*8))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
				v1 = *(*uint64)(unsafe.Pointer(x)) + *(*uint64)(unsafe.Pointer(c))&-(Uint64FromInt32(4)*Uint64FromInt64(8))
				*(*uint64)(unsafe.Pointer(c)) = v1
				*(*uint64)(unsafe.Pointer(x + uintptr(*(*uint64)(unsafe.Pointer(x))&-(Uint64FromInt32(4)*Uint64FromInt64(8))) + uintptr(-Int32FromInt32(1))*8)) = v1
			}
			break
		}
		j = _first_set(tls, mask)
		_lock_bin(tls, j)
		c = (*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(j)*24))).Fhead
		if c != uintptr(unsafe.Pointer(&(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(j)*24))).Fhead))-UintptrFromInt32(1)*8 && j == _bin_index(tls, *(*uint64)(unsafe.Pointer(c))) {
			if !(_pretrim(tls, c, *(*uint64)(unsafe.Pointer(bp)), i, j) != 0) {
				_unbin(tls, c, j)
			}
			_unlock_bin(tls, j)
			break
		}
		_unlock_bin(tls, j)
	}
	/* Now patch up in case we over-allocated */
	_trim(tls, c, *(*uint64)(unsafe.Pointer(bp)))
	return c + UintptrFromInt32(1)*8
}

func x_realloc(tls *TLS, p uintptr, _n uint64) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uint64)(unsafe.Pointer(bp)) = _n
	var base, new1, next, self, v2, v4 uintptr
	var extra, n0, n1, newlen, oldlen, v1 uint64
	var v3 bool
	if !(p != 0) {
		return x_malloc(tls, *(*uint64)(unsafe.Pointer(bp)))
	} else if !(*(*uint64)(unsafe.Pointer(bp)) != 0) {
		x_free(tls, p)
		return UintptrFromInt32(0)
	}
	if _adjust_size(tls, bp) < 0 {
		return uintptr(0)
	}
	self = p - UintptrFromInt32(1)*8
	v1 = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	n0 = v1
	n1 = v1
	if !(*(*uint64)(unsafe.Pointer(self))&Uint64FromInt32(1) != 0) {
		extra = *(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))
		base = self - uintptr(extra)
		oldlen = n0 + extra
		newlen = *(*uint64)(unsafe.Pointer(bp)) + extra
		if v3 = newlen < uint64(m_PAGESIZE); v3 {
			v2 = x_malloc(tls, *(*uint64)(unsafe.Pointer(bp)))
			new1 = v2
		}
		if v3 && v2 != 0 {
			x_memcpy(tls, new1, p, *(*uint64)(unsafe.Pointer(bp))-Uint64FromInt32(2)*Uint64FromInt64(8))
			x_free(tls, p)
			return new1
		}
		newlen = (newlen + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
		if oldlen == newlen {
			return p
		}
		base = x___mremap(tls, base, oldlen, newlen, int32(m_MREMAP_MAYMOVE), 0)
		if base == uintptr(-Int32FromInt32(1)) {
			if newlen < oldlen {
				v4 = p
			} else {
				v4 = uintptr(0)
			}
			return v4
		}
		self = base + uintptr(extra)
		*(*uint64)(unsafe.Pointer(self)) = newlen - extra
		return self + UintptrFromInt32(1)*8
	}
	next = self + uintptr(*(*uint64)(unsafe.Pointer(self))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
	/* Merge adjacent chunks if we need more space. This is not
	 * a waste of time even if we fail to get enough space, because our
	 * subsequent call to free would otherwise have to do the merge. */
	if *(*uint64)(unsafe.Pointer(bp)) > n1 && _alloc_fwd(tls, next) != 0 {
		n1 += *(*uint64)(unsafe.Pointer(next)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
		next = next + uintptr(*(*uint64)(unsafe.Pointer(next))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
	}
	/* FIXME: find what's wrong here and reenable it..? */
	if 0 != 0 && *(*uint64)(unsafe.Pointer(bp)) > n1 && _alloc_rev(tls, self) != 0 {
		self = self - uintptr(*(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
		n1 += *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	}
	*(*uint64)(unsafe.Pointer(self)) = n1 | Uint64FromInt32(1)
	*(*uint64)(unsafe.Pointer(next + uintptr(-Int32FromInt32(1))*8)) = n1 | Uint64FromInt32(1)
	/* If we got enough space, split off the excess and return */
	if *(*uint64)(unsafe.Pointer(bp)) <= n1 {
		//memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD);
		_trim(tls, self, *(*uint64)(unsafe.Pointer(bp)))
		return self + UintptrFromInt32(1)*8
	}
	/* As a last resort, allocate a new chunk and copy to it. */
	new1 = x_malloc(tls, *(*uint64)(unsafe.Pointer(bp))-Uint64FromInt32(2)*Uint64FromInt64(8))
	if !(new1 != 0) {
		return uintptr(0)
	}
	x_memcpy(tls, new1, p, n0-Uint64FromInt32(2)*Uint64FromInt64(8))
	x_free(tls, self+UintptrFromInt32(1)*8)
	return new1
}

func x_free(tls *TLS, p uintptr) {
	var a, b, extra, final_size, len1, new_size, size, v1 uint64
	var base, next, self uintptr
	var i, reclaim int32
	self = p - UintptrFromInt32(1)*8
	reclaim = 0
	if !(p != 0) {
		return
	}
	if !(*(*uint64)(unsafe.Pointer(self))&Uint64FromInt32(1) != 0) {
		extra = *(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))
		base = self - uintptr(extra)
		len1 = *(*uint64)(unsafe.Pointer(self))&-(Uint64FromInt32(4)*Uint64FromInt64(8)) + extra
		x___munmap(tls, base, len1)
		return
	}
	v1 = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
	new_size = v1
	final_size = v1
	next = self + uintptr(*(*uint64)(unsafe.Pointer(self))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
	for {
		/* Replace middle of large chunks with fresh zero pages */
		if reclaim != 0 && *(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))&*(*uint64)(unsafe.Pointer(next))&Uint64FromInt32(1) != 0 {
			a = (uint64(self) + Uint64FromInt32(4)*Uint64FromInt64(8) + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
			b = (uint64(next) - Uint64FromInt32(4)*Uint64FromInt64(8)) & uint64(-Int32FromInt32(m_PAGESIZE))
			x___madvise(tls, uintptr(a), b-a, int32(m_MADV_DONTNEED))
		}
		if *(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))&*(*uint64)(unsafe.Pointer(next))&Uint64FromInt32(1) != 0 {
			*(*uint64)(unsafe.Pointer(self)) = final_size | Uint64FromInt32(1)
			*(*uint64)(unsafe.Pointer(next + uintptr(-Int32FromInt32(1))*8)) = final_size | Uint64FromInt32(1)
			i = _bin_index(tls, final_size)
			_lock_bin(tls, i)
			_lock3(tls, uintptr(unsafe.Pointer(&_mal.Ffree_lock)))
			if *(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))&*(*uint64)(unsafe.Pointer(next))&Uint64FromInt32(1) != 0 {
				break
			}
			_unlock(tls, uintptr(unsafe.Pointer(&_mal.Ffree_lock)))
			_unlock_bin(tls, i)
		}
		if _alloc_rev(tls, self) != 0 {
			self = self - uintptr(*(*uint64)(unsafe.Pointer(self + uintptr(-Int32FromInt32(1))*8))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
			size = *(*uint64)(unsafe.Pointer(self)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
			final_size += size
			if new_size+size > uint64(m_RECLAIM) && new_size+size^size > size {
				reclaim = int32(1)
			}
		}
		if _alloc_fwd(tls, next) != 0 {
			size = *(*uint64)(unsafe.Pointer(next)) & -(Uint64FromInt32(4) * Uint64FromInt64(8))
			final_size += size
			if new_size+size > uint64(m_RECLAIM) && new_size+size^size > size {
				reclaim = int32(1)
			}
			next = next + uintptr(*(*uint64)(unsafe.Pointer(next))&-(Uint64FromInt32(4)*Uint64FromInt64(8)))
		}
	}
	*(*uint64)(unsafe.Pointer(self)) = final_size
	*(*uint64)(unsafe.Pointer(next + uintptr(-Int32FromInt32(1))*8)) = final_size
	_unlock(tls, uintptr(unsafe.Pointer(&_mal.Ffree_lock)))
	(*Tchunk)(unsafe.Pointer(self)).Fnext = uintptr(unsafe.Pointer(&(*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Fhead)) - UintptrFromInt32(1)*8
	(*Tchunk)(unsafe.Pointer(self)).Fprev = (*(*Tbin)(unsafe.Pointer(uintptr(unsafe.Pointer(&_mal.Fbins)) + uintptr(i)*24))).Ftail
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(self)).Fnext)).Fprev = self
	(*Tchunk)(unsafe.Pointer((*Tchunk)(unsafe.Pointer(self)).Fprev)).Fnext = self
	if !(_mal.Fbinmap&(Uint64FromUint64(1)<<i) != 0) {
		_a_or_64(tls, uintptr(unsafe.Pointer(&_mal.Fbinmap)), uint64(1)<<i)
	}
	_unlock_bin(tls, i)
}

func x_memalign(tls *TLS, align uint64, len1 uint64) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ret, v1 int32
	var _ /* mem at bp+0 */ uintptr
	v1 = x_posix_memalign(tls, bp, align, len1)
	ret = v1
	if v1 != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = ret
		return uintptr(0)
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

func x_posix_memalign(tls *TLS, res uintptr, align uint64, len1 uint64) (r int32) {
	var end, mem, new1, v1, v2 uintptr
	var footer, header uint64
	if align&-align != align {
		return int32(m_EINVAL)
	}
	if len1 > uint64(0xffffffffffffffff)-align {
		return int32(m_ENOMEM)
	}
	if align <= Uint64FromInt32(4)*Uint64FromInt64(8) {
		v1 = x_malloc(tls, len1)
		mem = v1
		if !(v1 != 0) {
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
		*(*uintptr)(unsafe.Pointer(res)) = mem
		return 0
	}
	v2 = x_malloc(tls, len1+align-uint64(1))
	mem = v2
	if !(v2 != 0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	header = *(*uint64)(unsafe.Pointer(mem + uintptr(-Int32FromInt32(1))*8))
	end = mem + uintptr(header&uint64(-Int32FromInt32(8)))
	footer = *(*uint64)(unsafe.Pointer(end + uintptr(-Int32FromInt32(2))*8))
	new1 = uintptr((uint64(mem) + align - Uint64FromInt32(1)) & -align)
	if !(header&Uint64FromInt32(7) != 0) {
		*(*uint64)(unsafe.Pointer(new1 + uintptr(-Int32FromInt32(2))*8)) = *(*uint64)(unsafe.Pointer(mem + uintptr(-Int32FromInt32(2))*8)) + uint64(int64(new1)-int64(mem))
		*(*uint64)(unsafe.Pointer(new1 + uintptr(-Int32FromInt32(1))*8)) = *(*uint64)(unsafe.Pointer(mem + uintptr(-Int32FromInt32(1))*8)) - uint64(int64(new1)-int64(mem))
		*(*uintptr)(unsafe.Pointer(res)) = new1
		return 0
	}
	*(*uint64)(unsafe.Pointer(mem + uintptr(-Int32FromInt32(1))*8)) = header&uint64(7) | uint64(int64(new1)-int64(mem))
	*(*uint64)(unsafe.Pointer(new1 + uintptr(-Int32FromInt32(2))*8)) = footer&uint64(7) | uint64(int64(new1)-int64(mem))
	*(*uint64)(unsafe.Pointer(new1 + uintptr(-Int32FromInt32(1))*8)) = header&uint64(7) | uint64(int64(end)-int64(new1))
	*(*uint64)(unsafe.Pointer(end + uintptr(-Int32FromInt32(2))*8)) = footer&uint64(7) | uint64(int64(end)-int64(new1))
	if new1 != mem {
		x_free(tls, mem)
	}
	*(*uintptr)(unsafe.Pointer(res)) = new1
	return 0
}

const m_FP_INFINITE = 1
const m_FP_NAN = 0
const m_FP_NORMAL = 4
const m_FP_SUBNORMAL = 3
const m_FP_ZERO = 2

type T__uint16_t = uint16

type T__uint32_t = uint32

type T__uint64_t = uint64

func x___fpclassify(tls *TLS, __x float64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var __ee, v1, v2 int32
	var _ /* __y at bp+0 */ struct {
		F__i [0]uint64
		F__d float64
	}
	*(*float64)(unsafe.Pointer(bp)) = __x
	__ee = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(__ee != 0) {
		if *(*uint64)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(m_FP_SUBNORMAL)
		} else {
			v1 = int32(m_FP_ZERO)
		}
		return v1
	}
	if __ee == int32(0x7ff) {
		if *(*uint64)(unsafe.Pointer(bp))<<int32(12) != 0 {
			v2 = m_FP_NAN
		} else {
			v2 = int32(m_FP_INFINITE)
		}
		return v2
	}
	return int32(m_FP_NORMAL)
}

func x___fpclassifyf(tls *TLS, __x float32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var __ee, v1, v2 int32
	var _ /* __y at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	*(*float32)(unsafe.Pointer(bp)) = __x
	__ee = int32(*(*uint32)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(__ee != 0) {
		if *(*uint32)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(m_FP_SUBNORMAL)
		} else {
			v1 = int32(m_FP_ZERO)
		}
		return v1
	}
	if __ee == int32(0xff) {
		if *(*uint32)(unsafe.Pointer(bp))<<int32(9) != 0 {
			v2 = m_FP_NAN
		} else {
			v2 = int32(m_FP_INFINITE)
		}
		return v2
	}
	return int32(m_FP_NORMAL)
}

// C documentation
//
//	/* FIXME: move this to arch-specific file */
func x___fpclassifyl(tls *TLS, __x float64) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var __ee, v1, v2 int32
	var _ /* __y at bp+0 */ struct {
		F__hw        [0][5]uint16
		F__m         [0]uint64
		F__ld        float64
		F__ccgo_pad3 [8]byte
	}
	*(*float64)(unsafe.Pointer(bp)) = __x
	__ee = int32(*(*uint16)(unsafe.Pointer(bp + 4*2))) & int32(0x7fff)
	if !(__ee != 0) {
		if *(*uint64)(unsafe.Pointer(&*(*struct {
			F__hw        [0][5]uint16
			F__m         [0]uint64
			F__ld        float64
			F__ccgo_pad3 [8]byte
		})(unsafe.Pointer(bp)))) != 0 {
			v1 = int32(m_FP_SUBNORMAL)
		} else {
			v1 = int32(m_FP_ZERO)
		}
		return v1
	}
	if __ee == int32(0x7fff) {
		if *(*uint64)(unsafe.Pointer(&*(*struct {
			F__hw        [0][5]uint16
			F__m         [0]uint64
			F__ld        float64
			F__ccgo_pad3 [8]byte
		})(unsafe.Pointer(bp)))) != 0 {
			v2 = m_FP_NAN
		} else {
			v2 = int32(m_FP_INFINITE)
		}
		return v2
	}
	return int32(m_FP_NORMAL)
}

type Tieee_double_shape_type = struct {
	Fwords [0]uint64
	Fvalue float64
}

type Tieee_float_shape_type = struct {
	Fword  [0]uint32
	Fvalue float32
}

var _one = float64(1)                               /* 0x3FF00000, 0x00000000 */
var _pi = float64(3.141592653589793)                /* 0x400921FB, 0x54442D18 */
var _pio2_hi = float64(1.5707963267948966)          /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo = float64(6.123233995736766e-17)       /* 0x3C91A626, 0x33145C07 */
var _pS0 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS1 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS2 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS3 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS4 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS5 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS1 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS2 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS3 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS4 = float64(0.07703815055590194)

func x_acos(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var c, df, p, q, r, s, w, z float64
	var hx, ix int32
	var lx uint32
	var p1 uintptr
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* sl_u at bp+16 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x3ff00000) {
		/* |x| >= 1 */
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		lx = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
		if uint32(ix-Int32FromInt32(0x3ff00000))|lx == uint32(0) {
			/* |x|==1 */
			if hx > 0 {
				return float64(0)
			} else {
				return _pi + float64(2)*_pio2_lo
			} /* acos(-1)= pi */
		}
		return (x - x) / (x - x) /* acos(|x|>1) is NaN */
	}
	if ix < int32(0x3fe00000) { /* |x| < 0.5 */
		if ix <= int32(0x3c600000) {
			return _pio2_hi + _pio2_lo
		} /*if|x|<2**-57*/
		z = x * x
		p = z * (_pS0 + z*(_pS1+z*(_pS2+z*(_pS3+z*(_pS4+z*_pS5)))))
		q = _one + z*(_qS1+z*(_qS2+z*(_qS3+z*_qS4)))
		r = p / q
		return _pio2_hi - (x - (_pio2_lo - x*r))
	} else {
		if hx < 0 { /* x < -0.5 */
			z = (_one + x) * float64(0.5)
			p = z * (_pS0 + z*(_pS1+z*(_pS2+z*(_pS3+z*(_pS4+z*_pS5)))))
			q = _one + z*(_qS1+z*(_qS2+z*(_qS3+z*_qS4)))
			s = _sqrt(tls, z)
			r = p / q
			w = r*s - _pio2_lo
			return _pi - float64(2)*(s+w)
		} else { /* x > 0.5 */
			z = (_one - x) * float64(0.5)
			s = _sqrt(tls, z)
			df = s
			*(*float64)(unsafe.Pointer(bp + 16)) = df
			p1 = bp + 16
			*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & Uint64FromUint64(0xffffffff00000000)
			*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(uint32(Int32FromInt32(0)))
			df = *(*float64)(unsafe.Pointer(bp + 16))
			c = (z - df*df) / (s + df)
			p = z * (_pS0 + z*(_pS1+z*(_pS2+z*(_pS3+z*(_pS4+z*_pS5)))))
			q = _one + z*(_qS1+z*(_qS2+z*(_qS3+z*_qS4)))
			r = p / q
			w = r*s + c
			return float64(2) * (df + w)
		}
	}
	return r1
}

var _one1 = float32(1)                                   /* 0x3F800000 */
var _pi1 = float32(3.1415925026)                         /* 0x40490fda */
var _pio2_hi1 = float32(1.5707962513)                    /* 0x3fc90fda */
var _pio2_lo1 = float32(7.5497894159e-08)                /* 0x33a22168 */
var _pS01 = float32(0.16666667163)                       /* 0x3e2aaaab */
var _pS11 = float32(-Float64FromFloat64(0.32556581497))  /* 0xbea6b090 */
var _pS21 = float32(0.20121252537)                       /* 0x3e4e0aa8 */
var _pS31 = float32(-Float64FromFloat64(0.040055535734)) /* 0xbd241146 */
var _pS41 = float32(0.00079153501429)                    /* 0x3a4f7f04 */
var _pS51 = float32(3.4793309169e-05)                    /* 0x3811ef08 */
var _qS11 = float32(-Float64FromFloat64(2.4033949375))   /* 0xc019d139 */
var _qS21 = float32(2.0209457874)                        /* 0x4001572d */
var _qS31 = float32(-Float64FromFloat64(0.68828397989))  /* 0xbf303361 */
var _qS41 = float32(0.077038154006)

func x_acosf(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var c, df, p, q, r, s, w, z float32
	var hx, idf, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix == int32(0x3f800000) { /* |x|==1 */
		if hx > 0 {
			return float32(0)
		} else {
			return _pi1 + Float32FromFloat64(2)*_pio2_lo1
		}
	} else if ix > int32(0x3f800000) {
		/* |x| >= 1 */
		return (x - x) / (x - x) /* acos(|x|>1) is NaN */
	}
	if ix < int32(0x3f000000) { /* |x| < 0.5 */
		if ix <= int32(0x23000000) {
			return _pio2_hi1 + _pio2_lo1
		} /*if|x|<2**-57*/
		z = x * x
		p = z * (_pS01 + z*(_pS11+z*(_pS21+z*(_pS31+z*(_pS41+z*_pS51)))))
		q = _one1 + z*(_qS11+z*(_qS21+z*(_qS31+z*_qS41)))
		r = p / q
		return _pio2_hi1 - (x - (_pio2_lo1 - x*r))
	} else {
		if hx < 0 { /* x < -0.5 */
			z = (_one1 + x) * Float32FromFloat64(0.5)
			p = z * (_pS01 + z*(_pS11+z*(_pS21+z*(_pS31+z*(_pS41+z*_pS51)))))
			q = _one1 + z*(_qS11+z*(_qS21+z*(_qS31+z*_qS41)))
			s = _sqrtf(tls, z)
			r = p / q
			w = r*s - _pio2_lo1
			return _pi1 - Float32FromFloat64(2)*(s+w)
		} else { /* x > 0.5 */
			z = (_one1 - x) * Float32FromFloat64(0.5)
			s = _sqrtf(tls, z)
			df = s
			*(*float32)(unsafe.Pointer(bp + 4)) = df
			idf = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
			*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(idf) & Uint32FromUint32(0xfffff000)
			df = *(*float32)(unsafe.Pointer(bp + 8))
			c = (z - df*df) / (s + df)
			p = z * (_pS01 + z*(_pS11+z*(_pS21+z*(_pS31+z*(_pS41+z*_pS51)))))
			q = _one1 + z*(_qS11+z*(_qS21+z*(_qS31+z*_qS41)))
			r = p / q
			w = r*s + c
			return Float32FromFloat64(2) * (df + w)
		}
	}
	return r1
}

var _one2 = float64(1)
var _ln2 = float64(0.6931471805599453)

func x_acosh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx int32
	var lx uint32
	var t float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	if hx < int32(0x3ff00000) { /* x < 1 */
		return (x - x) / (x - x)
	} else {
		if hx >= int32(0x41b00000) { /* x > 2**28 */
			if hx >= int32(0x7ff00000) { /* x is inf of NaN */
				return x + x
			} else {
				return x_log(tls, x) + _ln2
			}
		} else {
			if uint32(hx-Int32FromInt32(0x3ff00000))|lx == uint32(0) {
				return float64(0)
			} else {
				if hx > int32(0x40000000) { /* 2**28 > x > 2 */
					t = x * x
					return x_log(tls, float64(2)*x-_one2/(x+_sqrt(tls, t-_one2)))
				} else { /* 1<x<2 */
					t = x - _one2
					return x_log1p(tls, t+_sqrt(tls, float64(2)*t+t*t))
				}
			}
		}
	}
	return r
}

var _one3 = float32(1)
var _ln21 = float32(0.69314718246)

func x_acoshf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx int32
	var t float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	if hx < int32(0x3f800000) { /* x < 1 */
		return (x - x) / (x - x)
	} else {
		if hx >= int32(0x4d800000) { /* x > 2**28 */
			if hx >= int32(0x7f800000) { /* x is inf of NaN */
				return x + x
			} else {
				return x_logf(tls, x) + _ln21
			}
		} else {
			if hx == int32(0x3f800000) {
				return float32(0)
			} else {
				if hx > int32(0x40000000) { /* 2**28 > x > 2 */
					t = x * x
					return x_logf(tls, Float32FromFloat64(2)*x-_one3/(x+_sqrtf(tls, t-_one3)))
				} else { /* 1<x<2 */
					t = x - _one3
					return x_log1pf(tls, t+_sqrtf(tls, Float32FromFloat64(2)*t+t*t))
				}
			}
		}
	}
	return r
}

var _one4 = float64(1) /* 0x3FF00000, 0x00000000 */
var _huge = float64(1e+300)
var _pio2_hi2 = float64(1.5707963267948966)    /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo2 = float64(6.123233995736766e-17) /* 0x3C91A626, 0x33145C07 */
var _pio4_hi = float64(0.7853981633974483)     /* 0x3FE921FB, 0x54442D18 */
/* coefficient for R(x^2) */
var _pS02 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS12 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS22 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS32 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS42 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS52 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS12 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS22 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS32 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS42 = float64(0.07703815055590194)

func x_asin(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var c, p, q, r, s, t, w float64
	var hx, ix int32
	var lx uint32
	var p1 uintptr
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* sl_u at bp+16 */ Tieee_double_shape_type
	t = float64(0)
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x3ff00000) { /* |x|>= 1 */
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		lx = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
		if uint32(ix-Int32FromInt32(0x3ff00000))|lx == uint32(0) {
			/* asin(1)=+-pi/2 with inexact */
			return x*_pio2_hi2 + x*_pio2_lo2
		}
		return (x - x) / (x - x)
	} else if ix < int32(0x3fe00000) {
		/* |x|<0.5 */
		if ix < int32(0x3e400000) { /* if |x| < 2**-27 */
			if _huge+x > _one4 {
				return x
			}
		} else {
			t = x * x
		}
		p = t * (_pS02 + t*(_pS12+t*(_pS22+t*(_pS32+t*(_pS42+t*_pS52)))))
		q = _one4 + t*(_qS12+t*(_qS22+t*(_qS32+t*_qS42)))
		w = p / q
		return x + x*w
	}
	/* 1> |x|>= 0.5 */
	w = _one4 - x_fabs(tls, x)
	t = w * float64(0.5)
	p = t * (_pS02 + t*(_pS12+t*(_pS22+t*(_pS32+t*(_pS42+t*_pS52)))))
	q = _one4 + t*(_qS12+t*(_qS22+t*(_qS32+t*_qS42)))
	s = _sqrt(tls, t)
	if ix >= int32(0x3FEF3333) { /* if |x| > 0.975 */
		w = p / q
		t = _pio2_hi2 - (float64(2)*(s+s*w) - _pio2_lo2)
	} else {
		w = s
		*(*float64)(unsafe.Pointer(bp + 16)) = w
		p1 = bp + 16
		*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(uint32(Int32FromInt32(0)))
		w = *(*float64)(unsafe.Pointer(bp + 16))
		c = (t - w*w) / (s + w)
		r = p / q
		p = float64(2)*s*r - (_pio2_lo2 - float64(2)*c)
		q = _pio4_hi - float64(2)*w
		t = _pio4_hi - (p - q)
	}
	if hx > 0 {
		return t
	} else {
		return -t
	}
	return r1
}

var _one5 = float32(1) /* 0x3F800000 */
var _huge1 = float32(1e+30)
var _pio2_hi3 = float32(1.5707962513)     /* 0x3fc90fda */
var _pio2_lo3 = float32(7.5497894159e-08) /* 0x33a22168 */
var _pio4_hi1 = float32(0.78539818525)    /* 0x3f490fdb */
/* coefficient for R(x^2) */
var _pS03 = float32(0.16666667163)                       /* 0x3e2aaaab */
var _pS13 = float32(-Float64FromFloat64(0.32556581497))  /* 0xbea6b090 */
var _pS23 = float32(0.20121252537)                       /* 0x3e4e0aa8 */
var _pS33 = float32(-Float64FromFloat64(0.040055535734)) /* 0xbd241146 */
var _pS43 = float32(0.00079153501429)                    /* 0x3a4f7f04 */
var _pS53 = float32(3.4793309169e-05)                    /* 0x3811ef08 */
var _qS13 = float32(-Float64FromFloat64(2.4033949375))   /* 0xc019d139 */
var _qS23 = float32(2.0209457874)                        /* 0x4001572d */
var _qS33 = float32(-Float64FromFloat64(0.68828397989))  /* 0xbf303361 */
var _qS43 = float32(0.077038154006)

func x_asinf(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var c, p, q, r, s, t, w float32
	var hx, iw, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	t = float32(0)
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix == int32(0x3f800000) {
		/* asin(1)=+-pi/2 with inexact */
		return x*_pio2_hi3 + x*_pio2_lo3
	} else {
		if ix > int32(0x3f800000) { /* |x|>= 1 */
			return (x - x) / (x - x)
		} else if ix < int32(0x3f000000) {
			/* |x|<0.5 */
			if ix < int32(0x32000000) { /* if |x| < 2**-27 */
				if _huge1+x > _one5 {
					return x
				}
			} else {
				t = x * x
			}
			p = t * (_pS03 + t*(_pS13+t*(_pS23+t*(_pS33+t*(_pS43+t*_pS53)))))
			q = _one5 + t*(_qS13+t*(_qS23+t*(_qS33+t*_qS43)))
			w = p / q
			return x + x*w
		}
	}
	/* 1> |x|>= 0.5 */
	w = _one5 - x_fabsf(tls, x)
	t = w * Float32FromFloat64(0.5)
	p = t * (_pS03 + t*(_pS13+t*(_pS23+t*(_pS33+t*(_pS43+t*_pS53)))))
	q = _one5 + t*(_qS13+t*(_qS23+t*(_qS33+t*_qS43)))
	s = _sqrtf(tls, t)
	if ix >= int32(0x3F79999A) { /* if |x| > 0.975 */
		w = p / q
		t = _pio2_hi3 - (Float32FromFloat64(2)*(s+s*w) - _pio2_lo3)
	} else {
		w = s
		*(*float32)(unsafe.Pointer(bp + 4)) = w
		iw = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(iw) & Uint32FromUint32(0xfffff000)
		w = *(*float32)(unsafe.Pointer(bp + 8))
		c = (t - w*w) / (s + w)
		r = p / q
		p = Float32FromFloat64(2)*s*r - (_pio2_lo3 - Float32FromFloat64(2)*c)
		q = _pio4_hi1 - Float32FromFloat64(2)*w
		t = _pio4_hi1 - (p - q)
	}
	if hx > 0 {
		return t
	} else {
		return -t
	}
	return r1
}

var _tiny = float64(1e-300)
var _zero = float64(0)
var _pi_o_4 = float64(0.7853981633974483) /* 0x3FE921FB, 0x54442D18 */
var _pi_o_2 = float64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _pi2 = float64(3.141592653589793)     /* 0x400921FB, 0x54442D18 */
var _pi_lo = float64(1.2246467991473532e-16)

func x_atan2(tls *TLS, y float64, x float64) (r float64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var hx, hy, ix, iy, k, m int32
	var lx, ly, zh uint32
	var z, v1, v2 float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	ly = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	iy = hy & int32(0x7fffffff)
	if uint32(ix)|(lx|-lx)>>int32(31) > uint32(0x7ff00000) || uint32(iy)|(ly|-ly)>>int32(31) > uint32(0x7ff00000) { /* x or y is NaN */
		return x + y
	}
	if uint32(hx-Int32FromInt32(0x3ff00000))|lx == uint32(0) {
		return x_atan(tls, y)
	} /* x=1.0 */
	m = hy>>Int32FromInt32(31)&int32(1) | hx>>Int32FromInt32(30)&int32(2) /* 2*sign(x)+sign(y) */
	/* when y = 0 */
	if uint32(iy)|ly == uint32(0) {
		switch m {
		case 0:
			fallthrough
		case int32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case int32(2):
			return _pi2 + _tiny /* atan(+0,-anything) = pi */
		case int32(3):
			return -_pi2 - _tiny /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if uint32(ix)|lx == uint32(0) {
		if hy < 0 {
			v1 = -_pi_o_2 - _tiny
		} else {
			v1 = _pi_o_2 + _tiny
		}
		return v1
	}
	/* when x is INF */
	if ix == int32(0x7ff00000) {
		if iy == int32(0x7ff00000) {
			switch m {
			case 0:
				return _pi_o_4 + _tiny /* atan(+INF,+INF) */
			case int32(1):
				return -_pi_o_4 - _tiny /* atan(-INF,+INF) */
			case int32(2):
				return float64(3)*_pi_o_4 + _tiny /*atan(+INF,-INF)*/
			case int32(3):
				return -Float64FromFloat64(3)*_pi_o_4 - _tiny /*atan(-INF,-INF)*/
			}
		} else {
			switch m {
			case 0:
				return _zero /* atan(+...,+INF) */
			case int32(1):
				return -_zero /* atan(-...,+INF) */
			case int32(2):
				return _pi2 + _tiny /* atan(+...,-INF) */
			case int32(3):
				return -_pi2 - _tiny /* atan(-...,-INF) */
			}
		}
	}
	/* when y is INF */
	if iy == int32(0x7ff00000) {
		if hy < 0 {
			v2 = -_pi_o_2 - _tiny
		} else {
			v2 = _pi_o_2 + _tiny
		}
		return v2
	}
	/* compute y/x */
	k = (iy - ix) >> int32(20)
	if k > int32(60) {
		z = _pi_o_2 + float64(0.5)*_pi_lo
	} else {
		if hx < 0 && k < -int32(60) {
			z = float64(0)
		} else {
			z = x_atan(tls, x_fabs(tls, y/x))
		}
	} /* safe to do y/x */
	switch m {
	case 0:
		return z /* atan(+,+) */
	case int32(1):
		*(*float64)(unsafe.Pointer(bp + 16)) = z
		zh = uint32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
		*(*float64)(unsafe.Pointer(bp + 24)) = z
		*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(zh^Uint32FromUint32(0x80000000)) << Int32FromInt32(32)
		z = *(*float64)(unsafe.Pointer(bp + 24))
		return z /* atan(-,+) */
	case int32(2):
		return _pi2 - (z - _pi_lo) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo - _pi2 /* atan(-,-) */
	}
	return r
}

var _tiny1 = float32(1e-30)
var _zero1 = float32(0)
var _pi_o_41 = float32(0.78539818525) /* 0x3f490fdb */
var _pi_o_21 = float32(1.5707963705)  /* 0x3fc90fdb */
var _pi3 = float32(3.141592741)       /* 0x40490fdb */
var _pi_lo1 = float32(-Float64FromFloat64(8.7422776573e-08))

func x_atan2f(tls *TLS, y float32, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hx, hy, ix, iy, k, m int32
	var z, v1, v2 float32
	var zh uint32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hy = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	iy = hy & int32(0x7fffffff)
	if ix > int32(0x7f800000) || iy > int32(0x7f800000) { /* x or y is NaN */
		return x + y
	}
	if hx == int32(0x3f800000) {
		return x_atanf(tls, y)
	} /* x=1.0 */
	m = hy>>Int32FromInt32(31)&int32(1) | hx>>Int32FromInt32(30)&int32(2) /* 2*sign(x)+sign(y) */
	/* when y = 0 */
	if iy == 0 {
		switch m {
		case 0:
			fallthrough
		case int32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case int32(2):
			return _pi3 + _tiny1 /* atan(+0,-anything) = pi */
		case int32(3):
			return -_pi3 - _tiny1 /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ix == 0 {
		if hy < 0 {
			v1 = -_pi_o_21 - _tiny1
		} else {
			v1 = _pi_o_21 + _tiny1
		}
		return v1
	}
	/* when x is INF */
	if ix == int32(0x7f800000) {
		if iy == int32(0x7f800000) {
			switch m {
			case 0:
				return _pi_o_41 + _tiny1 /* atan(+INF,+INF) */
			case int32(1):
				return -_pi_o_41 - _tiny1 /* atan(-INF,+INF) */
			case int32(2):
				return Float32FromFloat64(3)*_pi_o_41 + _tiny1 /*atan(+INF,-INF)*/
			case int32(3):
				return float32(-Float64FromFloat64(3))*_pi_o_41 - _tiny1 /*atan(-INF,-INF)*/
			}
		} else {
			switch m {
			case 0:
				return _zero1 /* atan(+...,+INF) */
			case int32(1):
				return -_zero1 /* atan(-...,+INF) */
			case int32(2):
				return _pi3 + _tiny1 /* atan(+...,-INF) */
			case int32(3):
				return -_pi3 - _tiny1 /* atan(-...,-INF) */
			}
		}
	}
	/* when y is INF */
	if iy == int32(0x7f800000) {
		if hy < 0 {
			v2 = -_pi_o_21 - _tiny1
		} else {
			v2 = _pi_o_21 + _tiny1
		}
		return v2
	}
	/* compute y/x */
	k = (iy - ix) >> int32(23)
	if k > int32(60) {
		z = _pi_o_21 + Float32FromFloat64(0.5)*_pi_lo1
	} else {
		if hx < 0 && k < -int32(60) {
			z = float32(0)
		} else {
			z = x_atanf(tls, x_fabsf(tls, y/x))
		}
	} /* safe to do y/x */
	switch m {
	case 0:
		return z /* atan(+,+) */
	case int32(1):
		*(*float32)(unsafe.Pointer(bp + 8)) = z
		zh = *(*uint32)(unsafe.Pointer(bp + 8))
		*(*uint32)(unsafe.Pointer(bp + 12)) = zh ^ Uint32FromUint32(0x80000000)
		z = *(*float32)(unsafe.Pointer(bp + 12))
		return z /* atan(-,+) */
	case int32(2):
		return _pi3 - (z - _pi_lo1) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo1 - _pi3 /* atan(-,-) */
	}
	return r
}

var _one6 = float64(1)
var _huge2 = float64(1e+300)
var _zero2 = float64(0)

func x_atanh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hx, ix int32
	var lx uint32
	var t float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* sh_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if uint32(ix)|(lx|-lx)>>int32(31) > uint32(0x3ff00000) { /* |x|>1 */
		return (x - x) / (x - x)
	}
	if ix == int32(0x3ff00000) {
		return x / _zero2
	}
	if ix < int32(0x3e300000) && _huge2+x > _zero2 {
		return x
	} /* x<2**-28 */
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	*(*uint64)(unsafe.Pointer(bp + 8)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 8)) |= uint64(ix) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 8))
	if ix < int32(0x3fe00000) { /* x < 0.5 */
		t = x + x
		t = float64(0.5) * x_log1p(tls, t+t*x/(_one6-x))
	} else {
		t = float64(0.5) * x_log1p(tls, (x+x)/(_one6-x))
	}
	if hx >= 0 {
		return t
	} else {
		return -t
	}
	return r
}

var _one7 = float32(1)
var _huge3 = float32(1e+30)

var _zero3 = float32(0)

func x_atanhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, ix int32
	var t float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix > int32(0x3f800000) { /* |x|>1 */
		return (x - x) / (x - x)
	}
	if ix == int32(0x3f800000) {
		return x / _zero3
	}
	if ix < int32(0x31800000) && _huge3+x > _zero3 {
		return x
	} /* x<2**-28 */
	*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(ix)
	x = *(*float32)(unsafe.Pointer(bp + 4))
	if ix < int32(0x3f000000) { /* x < 0.5 */
		t = x + x
		t = Float32FromFloat64(0.5) * x_log1pf(tls, t+t*x/(_one7-x))
	} else {
		t = Float32FromFloat64(0.5) * x_log1pf(tls, (x+x)/(_one7-x))
	}
	if hx >= 0 {
		return t
	} else {
		return -t
	}
	return r
}

var _one8 = float64(1)
var _half = float64(0.5)
var _huge4 = float64(1e+300)

func x_cosh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix int32
	var lx uint32
	var t, w float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	/* High word of |x|. */
	*(*float64)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix &= int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7ff00000) {
		return x * x
	}
	/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
	if ix < int32(0x3fd62e43) {
		t = x_expm1(tls, x_fabs(tls, x))
		w = _one8 + t
		if ix < int32(0x3c800000) {
			return w
		} /* cosh(tiny) = 1 */
		return _one8 + t*t/(w+w)
	}
	/* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
	if ix < int32(0x40360000) {
		t = x_exp(tls, x_fabs(tls, x))
		return _half*t + _half/t
	}
	/* |x| in [22, log(maxdouble)] return half*exp(|x|) */
	if ix < int32(0x40862E42) {
		return _half * x_exp(tls, x_fabs(tls, x))
	}
	/* |x| in [log(maxdouble), overflowthresold] */
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	lx = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	if ix < int32(0x408633CE) || ix == int32(0x408633ce) && lx <= Uint32FromUint32(0x8fb9f87d) {
		w = x_exp(tls, _half*x_fabs(tls, x))
		t = _half * w
		return t * w
	}
	/* |x| > overflowthresold, cosh(x) overflow */
	return _huge4 * _huge4
}

var _one9 = float32(1)
var _half1 = float32(0.5)
var _huge5 = float32(1e+30)

func x_coshf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix int32
	var t, w float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix &= int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7f800000) {
		return x * x
	}
	/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
	if ix < int32(0x3eb17218) {
		t = x_expm1f(tls, x_fabsf(tls, x))
		w = _one9 + t
		if ix < int32(0x24000000) {
			return w
		} /* cosh(tiny) = 1 */
		return _one9 + t*t/(w+w)
	}
	/* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
	if ix < int32(0x41b00000) {
		t = x_expf(tls, x_fabsf(tls, x))
		return _half1*t + _half1/t
	}
	/* |x| in [22, log(maxdouble)] return half*exp(|x|) */
	if ix < int32(0x42b17180) {
		return _half1 * x_expf(tls, x_fabsf(tls, x))
	}
	/* |x| in [log(maxdouble), overflowthresold] */
	if ix <= int32(0x42b2d4fc) {
		w = x_expf(tls, _half1*x_fabsf(tls, x))
		t = _half1 * w
		return t * w
	}
	/* |x| > overflowthresold, cosh(x) overflow */
	return _huge5 * _huge5
}

var _one10 = float64(1)
var _halF = [2]float64{
	0: float64(0.5),
	1: -Float64FromFloat64(0.5)}
var _huge6 = float64(1e+300)
var _twom1000 = float64(9.332636185032189e-302)           /* 2**-1000=0x01700000,0*/
var _o_threshold = float64(709.782712893384)              /* 0x40862E42, 0xFEFA39EF */
var _u_threshold = -Float64FromFloat64(745.1332191019411) /* 0xc0874910, 0xD52D3051 */
var _ln2HI = [2]float64{
	0: float64(0.6931471803691238),
	1: -Float64FromFloat64(0.6931471803691238)} /* 0xbfe62e42, 0xfee00000 */
var _ln2LO = [2]float64{
							0: float64(1.9082149292705877e-10),
							1: -Float64FromFloat64(1.9082149292705877e-10)} /* 0xbdea39ef, 0x35793c76 */
var _invln2 = float64(1.4426950408889634)             /* 0x3ff71547, 0x652b82fe */
var _P1 = float64(0.16666666666666602)                /* 0x3FC55555, 0x5555553E */
var _P2 = -Float64FromFloat64(0.0027777777777015593)  /* 0xBF66C16C, 0x16BEBD93 */
var _P3 = float64(6.613756321437934e-05)              /* 0x3F11566A, 0xAF25DE2C */
var _P4 = -Float64FromFloat64(1.6533902205465252e-06) /* 0xBEBBBD41, 0xC5D26BF1 */
var _P5 = float64(4.1381367970572385e-08)

func x_exp(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxVaListSize 0 */
	defer tls.Free(48)  /* default IEEE double exp */
	var c, hi, lo, t, y, v1 float64
	var hx, hy, hy1, lx uint32
	var k, xsb int32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* gh_u at bp+32 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+40 */ Tieee_double_shape_type
	hi = float64(0)
	lo = float64(0)
	k = 0
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	xsb = int32(hx >> Int32FromInt32(31) & uint32(1)) /* sign bit of x */
	hx &= uint32(0x7fffffff)                          /* high word of |x| */
	/* filter out non-finite argument */
	if hx >= uint32(0x40862E42) {
		/* if |x|>=709.78... */
		if hx >= uint32(0x7ff00000) {
			*(*float64)(unsafe.Pointer(bp + 8)) = x
			lx = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
			if hx&uint32(0xfffff)|lx != uint32(0) {
				return x + x
			} else {
				if xsb == 0 {
					v1 = x
				} else {
					v1 = float64(0)
				}
				return v1
			} /* exp(+-inf)={inf,0} */
		}
		if x > _o_threshold {
			return _huge6 * _huge6
		} /* overflow */
		if x < _u_threshold {
			return _twom1000 * _twom1000
		} /* underflow */
	}
	/* argument reduction */
	if hx > uint32(0x3fd62e42) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3FF0A2B2) { /* and |x| < 1.5 ln2 */
			hi = x - _ln2HI[xsb]
			lo = _ln2LO[xsb]
			k = int32(1) - xsb - xsb
		} else {
			k = int32(_invln2*x + _halF[xsb])
			t = float64(k)
			hi = x - t*_ln2HI[0] /* t*ln2HI is exact here */
			lo = t * _ln2LO[0]
		}
		x = hi - lo
	} else {
		if hx < uint32(0x3e300000) { /* when |x|<2**-28 */
			if _huge6+x > _one10 {
				return _one10 + x
			}
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	t = x * x
	c = x - t*(_P1+t*(_P2+t*(_P3+t*(_P4+t*_P5))))
	if k == 0 {
		return _one10 - (x*c/(c-float64(2)) - x)
	} else {
		y = _one10 - (lo - x*c/(float64(2)-c) - hi)
	}
	if k >= -int32(1021) {
		*(*float64)(unsafe.Pointer(bp + 16)) = y
		hy = uint32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
		*(*float64)(unsafe.Pointer(bp + 24)) = y
		*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(hy+uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
		y = *(*float64)(unsafe.Pointer(bp + 24)) /* add k to y's exponent */
		return y
	} else {
		*(*float64)(unsafe.Pointer(bp + 32)) = y
		hy1 = uint32(*(*uint64)(unsafe.Pointer(bp + 32)) >> int32(32))
		*(*float64)(unsafe.Pointer(bp + 40)) = y
		*(*uint64)(unsafe.Pointer(bp + 40)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 40)) |= uint64(hy1+uint32((k+Int32FromInt32(1000))<<Int32FromInt32(20))) << Int32FromInt32(32)
		y = *(*float64)(unsafe.Pointer(bp + 40)) /* add k to y's exponent */
		return y * _twom1000
	}
	return r
}

var _one11 = float32(1)
var _halF1 = [2]float32{
	0: float32(0.5),
	1: float32(-Float64FromFloat64(0.5))}
var _huge7 = float32(1e+30)
var _twom100 = float32(7.8886090522e-31)                       /* 2**-100=0x0d800000 */
var _o_threshold1 = float32(88.721679688)                      /* 0x42b17180 */
var _u_threshold1 = float32(-Float64FromFloat64(103.97208405)) /* 0xc2cff1b5 */
var _ln2HI1 = [2]float32{
	0: float32(0.69313812256),
	1: float32(-Float64FromFloat64(0.69313812256))} /* 0xbf317180 */
var _ln2LO1 = [2]float32{
								0: float32(9.0580006145e-06),
								1: float32(-Float64FromFloat64(9.0580006145e-06))} /* 0xb717f7d1 */
var _invln21 = float32(1.4426950216)                      /* 0x3fb8aa3b */
var _P11 = float32(0.16666667163)                         /* 0x3e2aaaab */
var _P21 = float32(-Float64FromFloat64(0.002777777845))   /* 0xbb360b61 */
var _P31 = float32(6.613755977e-05)                       /* 0x388ab355 */
var _P41 = float32(-Float64FromFloat64(1.6533901999e-06)) /* 0xb5ddea0e */
var _P51 = float32(4.1381369442e-08)

func x_expf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)  /* default IEEE double exp */
	var c, hi, lo, t, y float32
	var hx, hy, hy1 uint32
	var k, xsb int32
	var v1 float64
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+12 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	hi = float32(0)
	lo = float32(0)
	k = 0
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = *(*uint32)(unsafe.Pointer(bp))
	xsb = int32(hx >> Int32FromInt32(31) & uint32(1)) /* sign bit of x */
	hx &= uint32(0x7fffffff)                          /* high word of |x| */
	/* filter out non-finite argument */
	if hx >= uint32(0x42b17218) {
		/* if |x|>=88.721... */
		if hx > uint32(0x7f800000) {
			return x + x
		} /* NaN */
		if hx == uint32(0x7f800000) {
			if xsb == 0 {
				v1 = float64(x)
			} else {
				v1 = float64(0)
			}
			return float32(v1)
		} /* exp(+-inf)={inf,0} */
		if x > _o_threshold1 {
			return _huge7 * _huge7
		} /* overflow */
		if x < _u_threshold1 {
			return _twom100 * _twom100
		} /* underflow */
	}
	/* argument reduction */
	if hx > uint32(0x3eb17218) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3F851592) { /* and |x| < 1.5 ln2 */
			hi = x - _ln2HI1[xsb]
			lo = _ln2LO1[xsb]
			k = int32(1) - xsb - xsb
		} else {
			k = int32(_invln21*x + _halF1[xsb])
			t = float32(k)
			hi = x - t*_ln2HI1[0] /* t*ln2HI is exact here */
			lo = t * _ln2LO1[0]
		}
		x = hi - lo
	} else {
		if hx < uint32(0x31800000) { /* when |x|<2**-28 */
			if _huge7+x > _one11 {
				return _one11 + x
			}
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	t = x * x
	c = x - t*(_P11+t*(_P21+t*(_P31+t*(_P41+t*_P51))))
	if k == 0 {
		return _one11 - (x*c/(c-Float32FromFloat64(2)) - x)
	} else {
		y = _one11 - (lo - x*c/(Float32FromFloat64(2)-c) - hi)
	}
	if k >= -int32(125) {
		*(*float32)(unsafe.Pointer(bp + 4)) = y
		hy = *(*uint32)(unsafe.Pointer(bp + 4))
		*(*uint32)(unsafe.Pointer(bp + 8)) = hy + uint32(k<<Int32FromInt32(23))
		y = *(*float32)(unsafe.Pointer(bp + 8)) /* add k to y's exponent */
		return y
	} else {
		*(*float32)(unsafe.Pointer(bp + 12)) = y
		hy1 = *(*uint32)(unsafe.Pointer(bp + 12))
		*(*uint32)(unsafe.Pointer(bp + 16)) = hy1 + uint32((k+Int32FromInt32(100))<<Int32FromInt32(23))
		y = *(*float32)(unsafe.Pointer(bp + 16)) /* add k to y's exponent */
		return y * _twom100
	}
	return r
}

var _one12 = float64(1)
var _Zero = [2]float64{
	0: float64(0),
	1: -Float64FromFloat64(0)}

func x_fmod(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var hx, hy, hz, i, ix, iy, n, sx, v5 int32
	var lx, ly, lz uint32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* iw_u at bp+16 */ Tieee_double_shape_type
	var _ /* iw_u at bp+24 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	ly = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	sx = int32(uint32(hx) & uint32(0x80000000)) /* sign of x */
	hx ^= sx                                    /* |x| */
	hy &= int32(0x7fffffff)                     /* |y| */
	/* purge off exception values */
	if uint32(hy)|ly == uint32(0) || hx >= int32(0x7ff00000) || uint32(hy)|(ly|-ly)>>int32(31) > uint32(0x7ff00000) { /* or y is NaN */
		return x * y / (x * y)
	}
	if hx <= hy {
		if hx < hy || lx < ly {
			return x
		} /* |x|<|y| return x */
		if lx == ly {
			return _Zero[uint32(sx)>>int32(31)]
		} /* |x|=|y| return x*0*/
	}
	/* determine ix = ilogb(x) */
	if hx < int32(0x00100000) { /* subnormal x */
		if hx == 0 {
			ix = -int32(1043)
			i = int32(lx)
			for i > 0 {
				ix -= int32(1)
				goto _1
			_1:
				i <<= int32(1)
			}
		} else {
			ix = -int32(1022)
			i = hx << Int32FromInt32(11)
			for i > 0 {
				ix -= int32(1)
				goto _2
			_2:
				i <<= int32(1)
			}
		}
	} else {
		ix = hx>>Int32FromInt32(20) - int32(1023)
	}
	/* determine iy = ilogb(y) */
	if hy < int32(0x00100000) { /* subnormal y */
		if hy == 0 {
			iy = -int32(1043)
			i = int32(ly)
			for i > 0 {
				iy -= int32(1)
				goto _3
			_3:
				i <<= int32(1)
			}
		} else {
			iy = -int32(1022)
			i = hy << Int32FromInt32(11)
			for i > 0 {
				iy -= int32(1)
				goto _4
			_4:
				i <<= int32(1)
			}
		}
	} else {
		iy = hy>>Int32FromInt32(20) - int32(1023)
	}
	/* set up {hx,lx}, {hy,ly} and align y to x */
	if ix >= -int32(1022) {
		hx = int32(0x00100000) | int32(0x000fffff)&hx
	} else { /* subnormal x, shift x to normal */
		n = -int32(1022) - ix
		if n <= int32(31) {
			hx = int32(uint32(hx<<n) | lx>>(Int32FromInt32(32)-n))
			lx <<= uint32(n)
		} else {
			hx = int32(lx << (n - int32(32)))
			lx = uint32(0)
		}
	}
	if iy >= -int32(1022) {
		hy = int32(0x00100000) | int32(0x000fffff)&hy
	} else { /* subnormal y, shift y to normal */
		n = -int32(1022) - iy
		if n <= int32(31) {
			hy = int32(uint32(hy<<n) | ly>>(Int32FromInt32(32)-n))
			ly <<= uint32(n)
		} else {
			hy = int32(ly << (n - int32(32)))
			ly = uint32(0)
		}
	}
	/* fix point fmod */
	n = ix - iy
	for {
		v5 = n
		n--
		if !(v5 != 0) {
			break
		}
		hz = hx - hy
		lz = lx - ly
		if lx < ly {
			hz -= int32(1)
		}
		if hz < 0 {
			hx = int32(uint32(hx+hx) + lx>>Int32FromInt32(31))
			lx = lx + lx
		} else {
			if uint32(hz)|lz == uint32(0) { /* return sign(x)*0 */
				return _Zero[uint32(sx)>>int32(31)]
			}
			hx = int32(uint32(hz+hz) + lz>>Int32FromInt32(31))
			lx = lz + lz
		}
	}
	hz = hx - hy
	lz = lx - ly
	if lx < ly {
		hz -= int32(1)
	}
	if hz >= 0 {
		hx = hz
		lx = lz
	}
	/* convert back to floating value and restore the sign */
	if uint32(hx)|lx == uint32(0) { /* return sign(x)*0 */
		return _Zero[uint32(sx)>>int32(31)]
	}
	for hx < int32(0x00100000) {
		/* normalize x */
		hx = int32(uint32(hx+hx) + lx>>Int32FromInt32(31))
		lx = lx + lx
		iy -= int32(1)
	}
	if iy >= -int32(1022) { /* normalize output */
		hx = hx - Int32FromInt32(0x00100000) | (iy+Int32FromInt32(1023))<<Int32FromInt32(20)
		*(*uint64)(unsafe.Pointer(bp + 16)) = uint64(hx|sx)<<Int32FromInt32(32) | uint64(lx)
		x = *(*float64)(unsafe.Pointer(bp + 16))
	} else { /* subnormal output */
		n = -int32(1022) - iy
		if n <= int32(20) {
			lx = lx>>n | uint32(hx)<<(Int32FromInt32(32)-n)
			hx >>= n
		} else {
			if n <= int32(31) {
				lx = uint32(hx<<(Int32FromInt32(32)-n)) | lx>>n
				hx = sx
			} else {
				lx = uint32(hx >> (n - int32(32)))
				hx = sx
			}
		}
		*(*uint64)(unsafe.Pointer(bp + 24)) = uint64(hx|sx)<<Int32FromInt32(32) | uint64(lx)
		x = *(*float64)(unsafe.Pointer(bp + 24))
		x *= _one12
	}
	return x /* exact output */
}

var _one13 = float32(1)
var _Zero1 = [2]float32{
	0: float32(0),
	1: float32(-Float64FromFloat64(0))}

func x_fmodf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hx, hy, hz, i, ix, iy, n, sx, v3 int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hy = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	sx = int32(uint32(hx) & uint32(0x80000000)) /* sign of x */
	hx ^= sx                                    /* |x| */
	hy &= int32(0x7fffffff)                     /* |y| */
	/* purge off exception values */
	if hy == 0 || hx >= int32(0x7f800000) || hy > int32(0x7f800000) { /* or y is NaN */
		return x * y / (x * y)
	}
	if hx < hy {
		return x
	} /* |x|<|y| return x */
	if hx == hy {
		return _Zero1[uint32(sx)>>int32(31)]
	} /* |x|=|y| return x*0*/
	/* determine ix = ilogb(x) */
	if hx < int32(0x00800000) { /* subnormal x */
		ix = -int32(126)
		i = hx << Int32FromInt32(8)
		for i > 0 {
			ix -= int32(1)
			goto _1
		_1:
			i <<= int32(1)
		}
	} else {
		ix = hx>>Int32FromInt32(23) - int32(127)
	}
	/* determine iy = ilogb(y) */
	if hy < int32(0x00800000) { /* subnormal y */
		iy = -int32(126)
		i = hy << Int32FromInt32(8)
		for i >= 0 {
			iy -= int32(1)
			goto _2
		_2:
			i <<= int32(1)
		}
	} else {
		iy = hy>>Int32FromInt32(23) - int32(127)
	}
	/* set up {hx,lx}, {hy,ly} and align y to x */
	if ix >= -int32(126) {
		hx = int32(0x00800000) | int32(0x007fffff)&hx
	} else { /* subnormal x, shift x to normal */
		n = -int32(126) - ix
		hx = hx << n
	}
	if iy >= -int32(126) {
		hy = int32(0x00800000) | int32(0x007fffff)&hy
	} else { /* subnormal y, shift y to normal */
		n = -int32(126) - iy
		hy = hy << n
	}
	/* fix point fmod */
	n = ix - iy
	for {
		v3 = n
		n--
		if !(v3 != 0) {
			break
		}
		hz = hx - hy
		if hz < 0 {
			hx = hx + hx
		} else {
			if hz == 0 { /* return sign(x)*0 */
				return _Zero1[uint32(sx)>>int32(31)]
			}
			hx = hz + hz
		}
	}
	hz = hx - hy
	if hz >= 0 {
		hx = hz
	}
	/* convert back to floating value and restore the sign */
	if hx == 0 { /* return sign(x)*0 */
		return _Zero1[uint32(sx)>>int32(31)]
	}
	for hx < int32(0x00800000) {
		/* normalize x */
		hx = hx + hx
		iy -= int32(1)
	}
	if iy >= -int32(126) { /* normalize output */
		hx = hx - Int32FromInt32(0x00800000) | (iy+Int32FromInt32(127))<<Int32FromInt32(23)
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(hx | sx)
		x = *(*float32)(unsafe.Pointer(bp + 8))
	} else { /* subnormal output */
		n = -int32(126) - iy
		hx >>= n
		*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(hx | sx)
		x = *(*float32)(unsafe.Pointer(bp + 12))
		x *= _one13
	}
	return x /* exact output */
}

func x_hypot(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxVaListSize 0 */
	defer tls.Free(136)
	var a, b, t1, t2, w, y1, y2 float64
	var ha, hb, j, k int32
	var high, low, low1 uint32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+120 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* gl_u at bp+32 */ Tieee_double_shape_type
	var _ /* gl_u at bp+40 */ Tieee_double_shape_type
	var _ /* gl_u at bp+64 */ Tieee_double_shape_type
	var _ /* sh_u at bp+104 */ Tieee_double_shape_type
	var _ /* sh_u at bp+112 */ Tieee_double_shape_type
	var _ /* sh_u at bp+128 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+48 */ Tieee_double_shape_type
	var _ /* sh_u at bp+56 */ Tieee_double_shape_type
	var _ /* sh_u at bp+72 */ Tieee_double_shape_type
	var _ /* sh_u at bp+80 */ Tieee_double_shape_type
	var _ /* sh_u at bp+88 */ Tieee_double_shape_type
	var _ /* sh_u at bp+96 */ Tieee_double_shape_type
	a = x
	b = y
	*(*float64)(unsafe.Pointer(bp)) = x
	ha = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ha &= int32(0x7fffffff)
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hb = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	hb &= int32(0x7fffffff)
	if hb > ha {
		a = y
		b = x
		j = ha
		ha = hb
		hb = j
	} else {
		a = x
		b = y
	}
	*(*float64)(unsafe.Pointer(bp + 16)) = a
	*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(ha) << Int32FromInt32(32)
	a = *(*float64)(unsafe.Pointer(bp + 16)) /* a <- |a| */
	*(*float64)(unsafe.Pointer(bp + 24)) = b
	*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(hb) << Int32FromInt32(32)
	b = *(*float64)(unsafe.Pointer(bp + 24)) /* b <- |b| */
	if ha-hb > int32(0x3c00000) {
		return a + b
	} /* x/y > 2**60 */
	k = 0
	if ha > int32(0x5f300000) {
		/* a>2**500 */
		if ha >= int32(0x7ff00000) {
			/* Inf or NaN */
			w = a + b /* for sNaN */
			*(*float64)(unsafe.Pointer(bp + 32)) = a
			low = uint32(*(*uint64)(unsafe.Pointer(bp + 32)))
			if uint32(ha&Int32FromInt32(0xfffff))|low == uint32(0) {
				w = a
			}
			*(*float64)(unsafe.Pointer(bp + 40)) = b
			low = uint32(*(*uint64)(unsafe.Pointer(bp + 40)))
			if uint32(hb^Int32FromInt32(0x7ff00000))|low == uint32(0) {
				w = b
			}
			return w
		}
		/* scale a and b by 2**-600 */
		ha -= int32(0x25800000)
		hb -= int32(0x25800000)
		k += int32(600)
		*(*float64)(unsafe.Pointer(bp + 48)) = a
		*(*uint64)(unsafe.Pointer(bp + 48)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 48)) |= uint64(ha) << Int32FromInt32(32)
		a = *(*float64)(unsafe.Pointer(bp + 48))
		*(*float64)(unsafe.Pointer(bp + 56)) = b
		*(*uint64)(unsafe.Pointer(bp + 56)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 56)) |= uint64(hb) << Int32FromInt32(32)
		b = *(*float64)(unsafe.Pointer(bp + 56))
	}
	if hb < int32(0x20b00000) {
		/* b < 2**-500 */
		if hb <= int32(0x000fffff) { /* subnormal b or 0 */
			*(*float64)(unsafe.Pointer(bp + 64)) = b
			low1 = uint32(*(*uint64)(unsafe.Pointer(bp + 64)))
			if uint32(hb)|low1 == uint32(0) {
				return a
			}
			t1 = Float64FromInt32(0)
			*(*float64)(unsafe.Pointer(bp + 72)) = t1
			*(*uint64)(unsafe.Pointer(bp + 72)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 72)) |= uint64(Int32FromInt32(0x7fd00000)) << Int32FromInt32(32)
			t1 = *(*float64)(unsafe.Pointer(bp + 72)) /* t1=2^1022 */
			b *= t1
			a *= t1
			k -= int32(1022)
		} else { /* scale a and b by 2^600 */
			ha += int32(0x25800000) /* a *= 2^600 */
			hb += int32(0x25800000) /* b *= 2^600 */
			k -= int32(600)
			*(*float64)(unsafe.Pointer(bp + 80)) = a
			*(*uint64)(unsafe.Pointer(bp + 80)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 80)) |= uint64(ha) << Int32FromInt32(32)
			a = *(*float64)(unsafe.Pointer(bp + 80))
			*(*float64)(unsafe.Pointer(bp + 88)) = b
			*(*uint64)(unsafe.Pointer(bp + 88)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 88)) |= uint64(hb) << Int32FromInt32(32)
			b = *(*float64)(unsafe.Pointer(bp + 88))
		}
	}
	/* medium size a and b */
	w = a - b
	if w > b {
		t1 = Float64FromInt32(0)
		*(*float64)(unsafe.Pointer(bp + 96)) = t1
		*(*uint64)(unsafe.Pointer(bp + 96)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 96)) |= uint64(ha) << Int32FromInt32(32)
		t1 = *(*float64)(unsafe.Pointer(bp + 96))
		t2 = a - t1
		w = _sqrt(tls, t1*t1-(b*-b-t2*(a+t1)))
	} else {
		a = a + a
		y1 = Float64FromInt32(0)
		*(*float64)(unsafe.Pointer(bp + 104)) = y1
		*(*uint64)(unsafe.Pointer(bp + 104)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 104)) |= uint64(hb) << Int32FromInt32(32)
		y1 = *(*float64)(unsafe.Pointer(bp + 104))
		y2 = b - y1
		t1 = Float64FromInt32(0)
		*(*float64)(unsafe.Pointer(bp + 112)) = t1
		*(*uint64)(unsafe.Pointer(bp + 112)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 112)) |= uint64(ha+Int32FromInt32(0x00100000)) << Int32FromInt32(32)
		t1 = *(*float64)(unsafe.Pointer(bp + 112))
		t2 = a - t1
		w = _sqrt(tls, t1*y1-(w*-w-(t1*y2+t2*b)))
	}
	if k != 0 {
		t1 = float64(1)
		*(*float64)(unsafe.Pointer(bp + 120)) = t1
		high = uint32(*(*uint64)(unsafe.Pointer(bp + 120)) >> int32(32))
		*(*float64)(unsafe.Pointer(bp + 128)) = t1
		*(*uint64)(unsafe.Pointer(bp + 128)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 128)) |= uint64(high+uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
		t1 = *(*float64)(unsafe.Pointer(bp + 128))
		return t1 * w
	} else {
		return w
	}
	return r
}

func x_hypotf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var a, b, t1, t2, w, y1, y2 float32
	var ha, hb, j, k int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+20 */ Tieee_float_shape_type
	var _ /* sf_u at bp+24 */ Tieee_float_shape_type
	var _ /* sf_u at bp+28 */ Tieee_float_shape_type
	var _ /* sf_u at bp+32 */ Tieee_float_shape_type
	var _ /* sf_u at bp+36 */ Tieee_float_shape_type
	var _ /* sf_u at bp+40 */ Tieee_float_shape_type
	var _ /* sf_u at bp+44 */ Tieee_float_shape_type
	var _ /* sf_u at bp+48 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	a = x
	b = y
	*(*float32)(unsafe.Pointer(bp)) = x
	ha = int32(*(*uint32)(unsafe.Pointer(bp)))
	ha &= int32(0x7fffffff)
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hb = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	hb &= int32(0x7fffffff)
	if hb > ha {
		a = y
		b = x
		j = ha
		ha = hb
		hb = j
	} else {
		a = x
		b = y
	}
	*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ha)
	a = *(*float32)(unsafe.Pointer(bp + 8)) /* a <- |a| */
	*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(hb)
	b = *(*float32)(unsafe.Pointer(bp + 12)) /* b <- |b| */
	if ha-hb > int32(0xf000000) {
		return a + b
	} /* x/y > 2**30 */
	k = 0
	if ha > int32(0x58800000) {
		/* a>2**50 */
		if ha >= int32(0x7f800000) {
			/* Inf or NaN */
			w = a + b /* for sNaN */
			if ha == int32(0x7f800000) {
				w = a
			}
			if hb == int32(0x7f800000) {
				w = b
			}
			return w
		}
		/* scale a and b by 2**-68 */
		ha -= int32(0x22000000)
		hb -= int32(0x22000000)
		k += int32(68)
		*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(ha)
		a = *(*float32)(unsafe.Pointer(bp + 16))
		*(*uint32)(unsafe.Pointer(bp + 20)) = uint32(hb)
		b = *(*float32)(unsafe.Pointer(bp + 20))
	}
	if hb < int32(0x26800000) {
		/* b < 2**-50 */
		if hb <= int32(0x007fffff) { /* subnormal b or 0 */
			if hb == 0 {
				return a
			}
			*(*uint32)(unsafe.Pointer(bp + 24)) = uint32(Int32FromInt32(0x7e800000))
			t1 = *(*float32)(unsafe.Pointer(bp + 24)) /* t1=2^126 */
			b *= t1
			a *= t1
			k -= int32(126)
		} else { /* scale a and b by 2^68 */
			ha += int32(0x22000000) /* a *= 2^68 */
			hb += int32(0x22000000) /* b *= 2^68 */
			k -= int32(68)
			*(*uint32)(unsafe.Pointer(bp + 28)) = uint32(ha)
			a = *(*float32)(unsafe.Pointer(bp + 28))
			*(*uint32)(unsafe.Pointer(bp + 32)) = uint32(hb)
			b = *(*float32)(unsafe.Pointer(bp + 32))
		}
	}
	/* medium size a and b */
	w = a - b
	if w > b {
		*(*uint32)(unsafe.Pointer(bp + 36)) = uint32(ha) & Uint32FromUint32(0xfffff000)
		t1 = *(*float32)(unsafe.Pointer(bp + 36))
		t2 = a - t1
		w = _sqrtf(tls, t1*t1-(b*-b-t2*(a+t1)))
	} else {
		a = a + a
		*(*uint32)(unsafe.Pointer(bp + 40)) = uint32(hb) & Uint32FromUint32(0xfffff000)
		y1 = *(*float32)(unsafe.Pointer(bp + 40))
		y2 = b - y1
		*(*uint32)(unsafe.Pointer(bp + 44)) = uint32(ha + Int32FromInt32(0x00800000))
		t1 = *(*float32)(unsafe.Pointer(bp + 44))
		t2 = a - t1
		w = _sqrtf(tls, t1*y1-(w*-w-(t1*y2+t2*b)))
	}
	if k != 0 {
		*(*uint32)(unsafe.Pointer(bp + 48)) = uint32(Int32FromInt32(0x3f800000) + k<<Int32FromInt32(23))
		t1 = *(*float32)(unsafe.Pointer(bp + 48))
		return t1 * w
	} else {
		return w
	}
	return r
}

var _ln2_hi = float64(0.6931471803691238)     /* 3fe62e42 fee00000 */
var _ln2_lo = float64(1.9082149292705877e-10) /* 3dea39ef 35793c76 */
var _two54 = float64(1.8014398509481984e+16)  /* 43500000 00000000 */
var _Lg1 = float64(0.6666666666666735)        /* 3FE55555 55555593 */
var _Lg2 = float64(0.3999999999940942)        /* 3FD99999 9997FA04 */
var _Lg3 = float64(0.2857142874366239)        /* 3FD24924 94229359 */
var _Lg4 = float64(0.22222198432149784)       /* 3FCC71C5 1D8E78AF */
var _Lg5 = float64(0.1818357216161805)        /* 3FC74664 96CB03DE */
var _Lg6 = float64(0.15313837699209373)       /* 3FC39A09 D078C69F */
var _Lg7 = float64(0.14798198605116586)       /* 3FC2F112 DF3E5244 */

var _zero4 = float64(0)

func x_log(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var R, dk, f, hfsq, s, t1, t2, w, z float64
	var hx, i, j, k int32
	var lx uint32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	k = 0
	if hx < int32(0x00100000) {
		/* x < 2**-1022  */
		if uint32(hx&Int32FromInt32(0x7fffffff))|lx == uint32(0) {
			return -_two54 / _zero4
		} /* log(+-0)=-inf */
		if hx < 0 {
			return (x - x) / _zero4
		} /* log(-#) = NaN */
		k -= int32(54)
		x *= _two54 /* subnormal number, scale up x */
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		hx = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	}
	if hx >= int32(0x7ff00000) {
		return x + x
	}
	k += hx>>Int32FromInt32(20) - int32(1023)
	hx &= int32(0x000fffff)
	i = (hx + int32(0x95f64)) & int32(0x100000)
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(hx|(i^Int32FromInt32(0x3ff00000))) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 16)) /* normalize x or x/2 */
	k += i >> Int32FromInt32(20)
	f = x - float64(1)
	if int32(0x000fffff)&(int32(2)+hx) < int32(3) {
		/* |f| < 2**-20 */
		if f == _zero4 {
			if k == 0 {
				return _zero4
			} else {
				dk = float64(k)
				return dk*_ln2_hi + dk*_ln2_lo
			}
		}
		R = f * f * (float64(0.5) - float64(0.3333333333333333)*f)
		if k == 0 {
			return f - R
		} else {
			dk = float64(k)
			return dk*_ln2_hi - (R - dk*_ln2_lo - f)
		}
	}
	s = f / (float64(2) + f)
	dk = float64(k)
	z = s * s
	i = hx - int32(0x6147a)
	w = z * z
	j = int32(0x6b851) - hx
	t1 = w * (_Lg2 + w*(_Lg4+w*_Lg6))
	t2 = z * (_Lg1 + w*(_Lg3+w*(_Lg5+w*_Lg7)))
	i |= j
	R = t2 + t1
	if i > 0 {
		hfsq = float64(0.5) * f * f
		if k == 0 {
			return f - (hfsq - s*(hfsq+R))
		} else {
			return dk*_ln2_hi - (hfsq - (s*(hfsq+R) + dk*_ln2_lo) - f)
		}
	} else {
		if k == 0 {
			return f - s*(f-R)
		} else {
			return dk*_ln2_hi - (s*(f-R) - dk*_ln2_lo - f)
		}
	}
	return r
}

var _two541 = float64(1.8014398509481984e+16)   /* 0x43500000, 0x00000000 */
var _ivln10 = float64(0.4342944819032518)       /* 0x3FDBCB7B, 0x1526E50E */
var _log10_2hi = float64(0.30102999566361177)   /* 0x3FD34413, 0x509F6000 */
var _log10_2lo = float64(3.694239077158931e-13) /* 0x3D59FEF3, 0x11F12B36 */

var _zero5 = float64(0)

func x_log10(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var hx, i, k int32
	var lx uint32
	var y, z float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	k = 0
	if hx < int32(0x00100000) {
		/* x < 2**-1022  */
		if uint32(hx&Int32FromInt32(0x7fffffff))|lx == uint32(0) {
			return -_two541 / _zero5
		} /* log(+-0)=-inf */
		if hx < 0 {
			return (x - x) / _zero5
		} /* log(-#) = NaN */
		k -= int32(54)
		x *= _two541 /* subnormal number, scale up x */
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		hx = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	}
	if hx >= int32(0x7ff00000) {
		return x + x
	}
	k += hx>>Int32FromInt32(20) - int32(1023)
	i = int32(uint32(k) & uint32(0x80000000) >> int32(31))
	hx = hx&int32(0x000fffff) | (int32(0x3ff)-i)<<int32(20)
	y = float64(k + i)
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(hx) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 16))
	z = y*_log10_2lo + _ivln10*x_log(tls, x)
	return z + y*_log10_2hi
}

var _two25 = float32(3.3554432e+07)         /* 0x4c000000 */
var _ivln101 = float32(0.43429449201)       /* 0x3ede5bd9 */
var _log10_2hi1 = float32(0.30102920532)    /* 0x3e9a2080 */
var _log10_2lo1 = float32(7.9034151668e-07) /* 0x355427db */

var _zero6 = float32(0)

func x_log10f(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hx, i, k int32
	var y, z float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	k = 0
	if hx < int32(0x00800000) {
		/* x < 2**-126  */
		if hx&int32(0x7fffffff) == 0 {
			return -_two25 / _zero6
		} /* log(+-0)=-inf */
		if hx < 0 {
			return (x - x) / _zero6
		} /* log(-#) = NaN */
		k -= int32(25)
		x *= _two25 /* subnormal number, scale up x */
		*(*float32)(unsafe.Pointer(bp + 4)) = x
		hx = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	}
	if hx >= int32(0x7f800000) {
		return x + x
	}
	k += hx>>Int32FromInt32(23) - int32(127)
	i = int32(uint32(k) & uint32(0x80000000) >> int32(31))
	hx = hx&int32(0x007fffff) | (int32(0x7f)-i)<<int32(23)
	y = float32(k + i)
	*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(hx)
	x = *(*float32)(unsafe.Pointer(bp + 8))
	z = y*_log10_2lo1 + _ivln101*x_logf(tls, x)
	return z + y*_log10_2hi1
}

var _ln2_hi1 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo1 = float32(9.0580006145e-06) /* 0x3717f7d1 */
var _two251 = float32(3.3554432e+07)     /* 0x4c000000 */
var _Lg11 = float32(0.66666668653)       /* 3F2AAAAB */
var _Lg21 = float32(0.40000000596)       /* 3ECCCCCD */
var _Lg31 = float32(0.28571429849)       /* 3E924925 */
var _Lg41 = float32(0.22222198546)       /* 3E638E29 */
var _Lg51 = float32(0.1818357259)        /* 3E3A3325 */
var _Lg61 = float32(0.15313838422)       /* 3E1CD04F */
var _Lg71 = float32(0.1479819864)        /* 3E178897 */

var _zero7 = float32(0)

func x_logf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var R, dk, f, hfsq, s, t1, t2, w, z float32
	var i, ix, j, k int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	k = 0
	if ix < int32(0x00800000) {
		/* x < 2**-126  */
		if ix&int32(0x7fffffff) == 0 {
			return -_two251 / _zero7
		} /* log(+-0)=-inf */
		if ix < 0 {
			return (x - x) / _zero7
		} /* log(-#) = NaN */
		k -= int32(25)
		x *= _two251 /* subnormal number, scale up x */
		*(*float32)(unsafe.Pointer(bp + 4)) = x
		ix = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	}
	if ix >= int32(0x7f800000) {
		return x + x
	}
	k += ix>>Int32FromInt32(23) - int32(127)
	ix &= int32(0x007fffff)
	i = (ix + Int32FromInt32(0x95f64)<<Int32FromInt32(3)) & int32(0x800000)
	*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ix | (i ^ Int32FromInt32(0x3f800000)))
	x = *(*float32)(unsafe.Pointer(bp + 8)) /* normalize x or x/2 */
	k += i >> Int32FromInt32(23)
	f = x - Float32FromFloat64(1)
	if int32(0x007fffff)&(int32(15)+ix) < int32(16) {
		/* |f| < 2**-20 */
		if f == _zero7 {
			if k == 0 {
				return _zero7
			} else {
				dk = float32(k)
				return dk*_ln2_hi1 + dk*_ln2_lo1
			}
		}
		R = f * f * (Float32FromFloat64(0.5) - Float32FromFloat64(0.3333333333333333)*f)
		if k == 0 {
			return f - R
		} else {
			dk = float32(k)
			return dk*_ln2_hi1 - (R - dk*_ln2_lo1 - f)
		}
	}
	s = f / (Float32FromFloat64(2) + f)
	dk = float32(k)
	z = s * s
	i = ix - Int32FromInt32(0x6147a)<<Int32FromInt32(3)
	w = z * z
	j = Int32FromInt32(0x6b851)<<Int32FromInt32(3) - ix
	t1 = w * (_Lg21 + w*(_Lg41+w*_Lg61))
	t2 = z * (_Lg11 + w*(_Lg31+w*(_Lg51+w*_Lg71)))
	i |= j
	R = t2 + t1
	if i > 0 {
		hfsq = Float32FromFloat64(0.5) * f * f
		if k == 0 {
			return f - (hfsq - s*(hfsq+R))
		} else {
			return dk*_ln2_hi1 - (hfsq - (s*(hfsq+R) + dk*_ln2_lo1) - f)
		}
	} else {
		if k == 0 {
			return f - s*(f-R)
		} else {
			return dk*_ln2_hi1 - (s*(f-R) - dk*_ln2_lo1 - f)
		}
	}
	return r
}

var _bp = [2]float64{
	0: float64(1),
	1: float64(1.5)}
var _dp_h = [2]float64{
	0: float64(0),
	1: float64(0.5849624872207642)} /* 0x3FE2B803, 0x40000000 */
var _dp_l = [2]float64{
	0: float64(0),
	1: float64(1.350039202129749e-08)} /* 0x3E4CFDEB, 0x43CFD006 */
var _zero8 = float64(0)
var _one14 = float64(1)
var _two = float64(2)
var _two53 = float64(9.007199254740992e+15) /* 0x43400000, 0x00000000 */
var _huge8 = float64(1e+300)
var _tiny2 = float64(1e-300)

/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
var _L1 = float64(0.5999999999999946)                   /* 0x3FE33333, 0x33333303 */
var _L2 = float64(0.4285714285785502)                   /* 0x3FDB6DB6, 0xDB6FABFF */
var _L3 = float64(0.33333332981837743)                  /* 0x3FD55555, 0x518F264D */
var _L4 = float64(0.272728123808534)                    /* 0x3FD17460, 0xA91D4101 */
var _L5 = float64(0.23066074577556175)                  /* 0x3FCD864A, 0x93C9DB65 */
var _L6 = float64(0.20697501780033842)                  /* 0x3FCA7E28, 0x4A454EEF */
var _P12 = float64(0.16666666666666602)                 /* 0x3FC55555, 0x5555553E */
var _P22 = -Float64FromFloat64(0.0027777777777015593)   /* 0xBF66C16C, 0x16BEBD93 */
var _P32 = float64(6.613756321437934e-05)               /* 0x3F11566A, 0xAF25DE2C */
var _P42 = -Float64FromFloat64(1.6533902205465252e-06)  /* 0xBEBBBD41, 0xC5D26BF1 */
var _P52 = float64(4.1381367970572385e-08)              /* 0x3E663769, 0x72BEA4D0 */
var _lg2 = float64(0.6931471805599453)                  /* 0x3FE62E42, 0xFEFA39EF */
var _lg2_h = float64(0.6931471824645996)                /* 0x3FE62E43, 0x00000000 */
var _lg2_l = -Float64FromFloat64(1.904654299957768e-09) /* 0xBE205C61, 0x0CA86C39 */
var _ovt = float64(8.008566259537294e-17)               /* -(1024-log2(ovfl+.5ulp)) */
var _cp = float64(0.9617966939259756)                   /* 0x3FEEC709, 0xDC3A03FD =2/(3ln2) */
var _cp_h = float64(0.9617967009544373)                 /* 0x3FEEC709, 0xE0000000 =(float)cp */
var _cp_l = -Float64FromFloat64(7.028461650952758e-09)  /* 0xBE3E2FE0, 0x145B01F5 =tail of cp_h*/
var _ivln2 = float64(1.4426950408889634)                /* 0x3FF71547, 0x652B82FE =1/ln2 */
var _ivln2_h = float64(1.4426950216293335)              /* 0x3FF71547, 0x60000000 =24b 1/ln2*/
var _ivln2_l = float64(1.9259629911266175e-08)

func x_pow(tls *TLS, x float64, y float64) (r1 float64) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var ax, p_h, p_l, r, s, s2, s_h, s_l, ss, t, t1, t2, t_h, t_l, u, v, w, y1, z, z_h, z_l, v1, v2, v3, v4, v5, v6 float64
	var hx, hy, i, ix, iy, j, k, n, yisint int32
	var lx, ly uint32
	var p10, p11, p12, p13, p7, p8, p9 uintptr
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* ew_u at bp+88 */ Tieee_double_shape_type
	var _ /* gh_u at bp+112 */ Tieee_double_shape_type
	var _ /* gh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+120 */ Tieee_double_shape_type
	var _ /* sh_u at bp+32 */ Tieee_double_shape_type
	var _ /* sh_u at bp+48 */ Tieee_double_shape_type
	var _ /* sh_u at bp+96 */ Tieee_double_shape_type
	var _ /* sl_u at bp+104 */ Tieee_double_shape_type
	var _ /* sl_u at bp+16 */ Tieee_double_shape_type
	var _ /* sl_u at bp+40 */ Tieee_double_shape_type
	var _ /* sl_u at bp+56 */ Tieee_double_shape_type
	var _ /* sl_u at bp+64 */ Tieee_double_shape_type
	var _ /* sl_u at bp+72 */ Tieee_double_shape_type
	var _ /* sl_u at bp+80 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	ly = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	ix = hx & int32(0x7fffffff)
	iy = hy & int32(0x7fffffff)
	/* y==zero: x**0 = 1 */
	if uint32(iy)|ly == uint32(0) {
		return _one14
	}
	/* +-NaN return x+y */
	if ix > int32(0x7ff00000) || ix == int32(0x7ff00000) && lx != uint32(0) || iy > int32(0x7ff00000) || iy == int32(0x7ff00000) && ly != uint32(0) {
		return x + y
	}
	/* determine if y is an odd int when x < 0
	 * yisint = 0       ... y is not an integer
	 * yisint = 1       ... y is an odd int
	 * yisint = 2       ... y is an even int
	 */
	yisint = 0
	if hx < 0 {
		if iy >= int32(0x43400000) {
			yisint = int32(2)
		} else if iy >= int32(0x3ff00000) {
			k = iy>>Int32FromInt32(20) - int32(0x3ff) /* exponent */
			if k > int32(20) {
				j = int32(ly >> (int32(52) - k))
				if uint32(j<<(Int32FromInt32(52)-k)) == ly {
					yisint = int32(2) - j&int32(1)
				}
			} else if ly == uint32(0) {
				j = iy >> (int32(20) - k)
				if j<<(Int32FromInt32(20)-k) == iy {
					yisint = int32(2) - j&int32(1)
				}
			}
		}
	}
	/* special value of y */
	if ly == uint32(0) {
		if iy == int32(0x7ff00000) {
			/* y is +-inf */
			if uint32(ix-Int32FromInt32(0x3ff00000))|lx == uint32(0) {
				return y - y
			} else {
				if ix >= int32(0x3ff00000) { /* (|x|>1)**+-inf = inf,0 */
					if hy >= 0 {
						v1 = y
					} else {
						v1 = _zero8
					}
					return v1
				} else { /* (|x|<1)**-,+inf = inf,0 */
					if hy < 0 {
						v2 = -y
					} else {
						v2 = _zero8
					}
					return v2
				}
			}
		}
		if iy == int32(0x3ff00000) {
			/* y is  +-1 */
			if hy < 0 {
				return _one14 / x
			} else {
				return x
			}
		}
		if hy == int32(0x40000000) {
			return x * x
		} /* y is  2 */
		if hy == int32(0x3fe00000) {
			/* y is  0.5 */
			if hx >= 0 { /* x >= +0 */
				return _sqrt(tls, x)
			}
		}
	}
	ax = x_fabs(tls, x)
	/* special value of x */
	if lx == uint32(0) {
		if ix == int32(0x7ff00000) || ix == 0 || ix == int32(0x3ff00000) {
			z = ax /*x is +-0,+-inf,+-1*/
			if hy < 0 {
				z = _one14 / z
			} /* z = (1/|x|) */
			if hx < 0 {
				if ix-int32(0x3ff00000)|yisint == 0 {
					z = (z - z) / (z - z)
				} else if yisint == int32(1) {
					z = -z
				} /* (x<0)**odd = -(|x|**odd) */
			}
			return z
		}
	}
	/* CYGNUS LOCAL + fdlibm-5.3 fix: This used to be
	    n = (hx>>31)+1;
	   but ANSI C says a right shift of a signed negative quantity is
	   implementation defined.  */
	n = int32(uint32(hx)>>Int32FromInt32(31) - uint32(1))
	/* (x<0)**(non-int) is NaN */
	if n|yisint == 0 {
		return (x - x) / (x - x)
	}
	s = _one14 /* s (sign of result -ve**odd) = -1 else = 1 */
	if n|(yisint-int32(1)) == 0 {
		s = -_one14
	} /* (-ve)**(odd int) */
	/* |y| is huge */
	if iy > int32(0x41e00000) { /* if |y| > 2**31 */
		if iy > int32(0x43f00000) {
			/* if |y| > 2**64, must o/uflow */
			if ix <= int32(0x3fefffff) {
				if hy < 0 {
					v3 = _huge8 * _huge8
				} else {
					v3 = _tiny2 * _tiny2
				}
				return v3
			}
			if ix >= int32(0x3ff00000) {
				if hy > 0 {
					v4 = _huge8 * _huge8
				} else {
					v4 = _tiny2 * _tiny2
				}
				return v4
			}
		}
		/* over/underflow if x is not close to one */
		if ix < int32(0x3fefffff) {
			if hy < 0 {
				v5 = s * _huge8 * _huge8
			} else {
				v5 = s * _tiny2 * _tiny2
			}
			return v5
		}
		if ix > int32(0x3ff00000) {
			if hy > 0 {
				v6 = s * _huge8 * _huge8
			} else {
				v6 = s * _tiny2 * _tiny2
			}
			return v6
		}
		/* now |1-x| is tiny <= 2**-20, suffice to compute
		   log(x) by x-x^2/2+x^3/3-x^4/4 */
		t = ax - _one14 /* t has 20 trailing zeros */
		w = t * t * (float64(0.5) - t*(float64(0.3333333333333333)-t*float64(0.25)))
		u = _ivln2_h * t /* ivln2_h has 21 sig. bits */
		v = t*_ivln2_l - w*_ivln2
		t1 = u + v
		*(*float64)(unsafe.Pointer(bp + 16)) = t1
		p7 = bp + 16
		*(*uint64)(unsafe.Pointer(p7)) = *(*uint64)(unsafe.Pointer(p7)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(uint32(Int32FromInt32(0)))
		t1 = *(*float64)(unsafe.Pointer(bp + 16))
		t2 = v - (t1 - u)
	} else {
		n = 0
		/* take care subnormal number */
		if ix < int32(0x00100000) {
			ax *= _two53
			n -= int32(53)
			*(*float64)(unsafe.Pointer(bp + 24)) = ax
			ix = int32(*(*uint64)(unsafe.Pointer(bp + 24)) >> int32(32))
		}
		n += ix>>Int32FromInt32(20) - int32(0x3ff)
		j = ix & int32(0x000fffff)
		/* determine interval */
		ix = j | int32(0x3ff00000) /* normalize ix */
		if j <= int32(0x3988E) {
			k = 0
		} else {
			if j < int32(0xBB67A) {
				k = int32(1)
			} else {
				k = 0
				n += int32(1)
				ix -= int32(0x00100000)
			}
		}
		*(*float64)(unsafe.Pointer(bp + 32)) = ax
		*(*uint64)(unsafe.Pointer(bp + 32)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 32)) |= uint64(ix) << Int32FromInt32(32)
		ax = *(*float64)(unsafe.Pointer(bp + 32))
		/* compute ss = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
		u = ax - _bp[k] /* bp[0]=1.0, bp[1]=1.5 */
		v = _one14 / (ax + _bp[k])
		ss = u * v
		s_h = ss
		*(*float64)(unsafe.Pointer(bp + 40)) = s_h
		p8 = bp + 40
		*(*uint64)(unsafe.Pointer(p8)) = *(*uint64)(unsafe.Pointer(p8)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 40)) |= uint64(uint32(Int32FromInt32(0)))
		s_h = *(*float64)(unsafe.Pointer(bp + 40))
		/* t_h=ax+bp[k] High */
		t_h = _zero8
		*(*float64)(unsafe.Pointer(bp + 48)) = t_h
		*(*uint64)(unsafe.Pointer(bp + 48)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 48)) |= uint64(ix>>Int32FromInt32(1)|Int32FromInt32(0x20000000)+Int32FromInt32(0x00080000)+k<<Int32FromInt32(18)) << Int32FromInt32(32)
		t_h = *(*float64)(unsafe.Pointer(bp + 48))
		t_l = ax - (t_h - _bp[k])
		s_l = v * (u - s_h*t_h - s_h*t_l)
		/* compute log(ax) */
		s2 = ss * ss
		r = s2 * s2 * (_L1 + s2*(_L2+s2*(_L3+s2*(_L4+s2*(_L5+s2*_L6)))))
		r += s_l * (s_h + ss)
		s2 = s_h * s_h
		t_h = float64(3) + s2 + r
		*(*float64)(unsafe.Pointer(bp + 56)) = t_h
		p9 = bp + 56
		*(*uint64)(unsafe.Pointer(p9)) = *(*uint64)(unsafe.Pointer(p9)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 56)) |= uint64(uint32(Int32FromInt32(0)))
		t_h = *(*float64)(unsafe.Pointer(bp + 56))
		t_l = r - (t_h - float64(3) - s2)
		/* u+v = ss*(1+...) */
		u = s_h * t_h
		v = s_l*t_h + t_l*ss
		/* 2/(3log2)*(ss+...) */
		p_h = u + v
		*(*float64)(unsafe.Pointer(bp + 64)) = p_h
		p10 = bp + 64
		*(*uint64)(unsafe.Pointer(p10)) = *(*uint64)(unsafe.Pointer(p10)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 64)) |= uint64(uint32(Int32FromInt32(0)))
		p_h = *(*float64)(unsafe.Pointer(bp + 64))
		p_l = v - (p_h - u)
		z_h = _cp_h * p_h /* cp_h+cp_l = 2/(3*log2) */
		z_l = _cp_l*p_h + p_l*_cp + _dp_l[k]
		/* log2(ax) = (ss+..)*2/(3*log2) = n + dp_h + z_h + z_l */
		t = float64(n)
		t1 = z_h + z_l + _dp_h[k] + t
		*(*float64)(unsafe.Pointer(bp + 72)) = t1
		p11 = bp + 72
		*(*uint64)(unsafe.Pointer(p11)) = *(*uint64)(unsafe.Pointer(p11)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 72)) |= uint64(uint32(Int32FromInt32(0)))
		t1 = *(*float64)(unsafe.Pointer(bp + 72))
		t2 = z_l - (t1 - t - _dp_h[k] - z_h)
	}
	/* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
	y1 = y
	*(*float64)(unsafe.Pointer(bp + 80)) = y1
	p12 = bp + 80
	*(*uint64)(unsafe.Pointer(p12)) = *(*uint64)(unsafe.Pointer(p12)) & Uint64FromUint64(0xffffffff00000000)
	*(*uint64)(unsafe.Pointer(bp + 80)) |= uint64(uint32(Int32FromInt32(0)))
	y1 = *(*float64)(unsafe.Pointer(bp + 80))
	p_l = (y-y1)*t1 + y*t2
	p_h = y1 * t1
	z = p_l + p_h
	*(*float64)(unsafe.Pointer(bp + 88)) = z
	j = int32(*(*uint64)(unsafe.Pointer(bp + 88)) >> int32(32))
	i = int32(uint32(*(*uint64)(unsafe.Pointer(bp + 88))))
	if j >= int32(0x40900000) { /* z >= 1024 */
		if j-int32(0x40900000)|i != 0 { /* if z > 1024 */
			return s * _huge8 * _huge8
		} else {
			if p_l+_ovt > z-p_h {
				return s * _huge8 * _huge8
			}
		}
	} else if j&int32(0x7fffffff) >= int32(0x4090cc00) {
		/* z <= -1075 */
		if uint32(j)-uint32(0xc090cc00)|uint32(i) != uint32(0) { /* z < -1075 */
			return s * _tiny2 * _tiny2
		} else {
			if p_l <= z-p_h {
				return s * _tiny2 * _tiny2
			}
		}
	}
	/*
	 * compute 2**(p_h+p_l)
	 */
	i = j & int32(0x7fffffff)
	k = i>>Int32FromInt32(20) - int32(0x3ff)
	n = 0
	if i > int32(0x3fe00000) {
		/* if |z| > 0.5, set n = [z+0.5] */
		n = j + int32(0x00100000)>>(k+int32(1))
		k = n&int32(0x7fffffff)>>int32(20) - int32(0x3ff) /* new k for n */
		t = _zero8
		*(*float64)(unsafe.Pointer(bp + 96)) = t
		*(*uint64)(unsafe.Pointer(bp + 96)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 96)) |= uint64(n & ^(Int32FromInt32(0x000fffff)>>k)) << Int32FromInt32(32)
		t = *(*float64)(unsafe.Pointer(bp + 96))
		n = (n&int32(0x000fffff) | int32(0x00100000)) >> (int32(20) - k)
		if j < 0 {
			n = -n
		}
		p_h -= t
	}
	t = p_l + p_h
	*(*float64)(unsafe.Pointer(bp + 104)) = t
	p13 = bp + 104
	*(*uint64)(unsafe.Pointer(p13)) = *(*uint64)(unsafe.Pointer(p13)) & Uint64FromUint64(0xffffffff00000000)
	*(*uint64)(unsafe.Pointer(bp + 104)) |= uint64(uint32(Int32FromInt32(0)))
	t = *(*float64)(unsafe.Pointer(bp + 104))
	u = t * _lg2_h
	v = (p_l-(t-p_h))*_lg2 + t*_lg2_l
	z = u + v
	w = v - (z - u)
	t = z * z
	t1 = z - t*(_P12+t*(_P22+t*(_P32+t*(_P42+t*_P52))))
	r = z*t1/(t1-_two) - (w + z*w)
	z = _one14 - (r - z)
	*(*float64)(unsafe.Pointer(bp + 112)) = z
	j = int32(*(*uint64)(unsafe.Pointer(bp + 112)) >> int32(32))
	j += n << Int32FromInt32(20)
	if j>>Int32FromInt32(20) <= 0 {
		z = x_scalbn(tls, z, n)
	} else {
		*(*float64)(unsafe.Pointer(bp + 120)) = z
		*(*uint64)(unsafe.Pointer(bp + 120)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 120)) |= uint64(j) << Int32FromInt32(32)
		z = *(*float64)(unsafe.Pointer(bp + 120))
	}
	return s * z
}

var _bp1 = [2]float32{
	0: float32(1),
	1: float32(1.5)}
var _dp_h1 = [2]float32{
	0: float32(0),
	1: float32(0.584960938)} /* 0x3f15c000 */
var _dp_l1 = [2]float32{
	0: float32(0),
	1: float32(1.56322085e-06)} /* 0x35d1cfdc */
var _zero9 = float32(0)
var _one15 = float32(1)
var _two1 = float32(2)
var _two24 = float32(1.6777216e+07) /* 0x4b800000 */
var _huge9 = float32(1e+30)
var _tiny3 = float32(1e-30)

/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
var _L11 = float32(0.60000002384)                         /* 0x3f19999a */
var _L21 = float32(0.42857143283)                         /* 0x3edb6db7 */
var _L31 = float32(0.33333334327)                         /* 0x3eaaaaab */
var _L41 = float32(0.27272811532)                         /* 0x3e8ba305 */
var _L51 = float32(0.23066075146)                         /* 0x3e6c3255 */
var _L61 = float32(0.20697501302)                         /* 0x3e53f142 */
var _P13 = float32(0.16666667163)                         /* 0x3e2aaaab */
var _P23 = float32(-Float64FromFloat64(0.002777777845))   /* 0xbb360b61 */
var _P33 = float32(6.613755977e-05)                       /* 0x388ab355 */
var _P43 = float32(-Float64FromFloat64(1.6533901999e-06)) /* 0xb5ddea0e */
var _P53 = float32(4.1381369442e-08)                      /* 0x3331bb4c */
var _lg21 = float32(0.69314718246)                        /* 0x3f317218 */
var _lg2_h1 = float32(0.693145752)                        /* 0x3f317200 */
var _lg2_l1 = float32(1.42860654e-06)                     /* 0x35bfbe8c */
var _ovt1 = float32(4.2995665694e-08)                     /* -(128-log2(ovfl+.5ulp)) */
var _cp1 = float32(0.96179670095)                         /* 0x3f76384f =2/(3ln2) */
var _cp_h1 = float32(0.96179199219)                       /* 0x3f763800 =head of cp */
var _cp_l1 = float32(4.7017383622e-06)                    /* 0x369dc3a0 =tail of cp_h */
var _ivln21 = float32(1.4426950216)                       /* 0x3fb8aa3b =1/ln2 */
var _ivln2_h1 = float32(1.4426879883)                     /* 0x3fb8aa00 =16b 1/ln2*/
var _ivln2_l1 = float32(7.0526075433e-06)

func x_powf(tls *TLS, x float32, y float32) (r1 float32) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxVaListSize 0 */
	defer tls.Free(96)
	var ax, p_h, p_l, r, s, s2, s_h, s_l, sn, t, t1, t2, t_h, t_l, u, v, w, y1, z, z_h, z_l, v1, v2, v3, v4 float32
	var hx, hy, i, is, ix, iy, j, k, n, yisint int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+16 */ Tieee_float_shape_type
	var _ /* gf_u at bp+24 */ Tieee_float_shape_type
	var _ /* gf_u at bp+36 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* gf_u at bp+44 */ Tieee_float_shape_type
	var _ /* gf_u at bp+52 */ Tieee_float_shape_type
	var _ /* gf_u at bp+60 */ Tieee_float_shape_type
	var _ /* gf_u at bp+68 */ Tieee_float_shape_type
	var _ /* gf_u at bp+76 */ Tieee_float_shape_type
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* gf_u at bp+84 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+20 */ Tieee_float_shape_type
	var _ /* sf_u at bp+28 */ Tieee_float_shape_type
	var _ /* sf_u at bp+32 */ Tieee_float_shape_type
	var _ /* sf_u at bp+40 */ Tieee_float_shape_type
	var _ /* sf_u at bp+48 */ Tieee_float_shape_type
	var _ /* sf_u at bp+56 */ Tieee_float_shape_type
	var _ /* sf_u at bp+64 */ Tieee_float_shape_type
	var _ /* sf_u at bp+72 */ Tieee_float_shape_type
	var _ /* sf_u at bp+80 */ Tieee_float_shape_type
	var _ /* sf_u at bp+88 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hy = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	ix = hx & int32(0x7fffffff)
	iy = hy & int32(0x7fffffff)
	/* y==zero: x**0 = 1 */
	if iy == 0 {
		return _one15
	}
	/* +-NaN return x+y */
	if ix > int32(0x7f800000) || iy > int32(0x7f800000) {
		return x + y
	}
	/* determine if y is an odd int when x < 0
	 * yisint = 0       ... y is not an integer
	 * yisint = 1       ... y is an odd int
	 * yisint = 2       ... y is an even int
	 */
	yisint = 0
	if hx < 0 {
		if iy >= int32(0x4b800000) {
			yisint = int32(2)
		} else if iy >= int32(0x3f800000) {
			k = iy>>Int32FromInt32(23) - int32(0x7f) /* exponent */
			j = iy >> (int32(23) - k)
			if j<<(Int32FromInt32(23)-k) == iy {
				yisint = int32(2) - j&int32(1)
			}
		}
	}
	/* special value of y */
	if iy == int32(0x7f800000) {
		/* y is +-inf */
		if ix == int32(0x3f800000) {
			return y - y
		} else {
			if ix > int32(0x3f800000) { /* (|x|>1)**+-inf = inf,0 */
				if hy >= 0 {
					v1 = y
				} else {
					v1 = _zero9
				}
				return v1
			} else { /* (|x|<1)**-,+inf = inf,0 */
				if hy < 0 {
					v2 = -y
				} else {
					v2 = _zero9
				}
				return v2
			}
		}
	}
	if iy == int32(0x3f800000) {
		/* y is  +-1 */
		if hy < 0 {
			return _one15 / x
		} else {
			return x
		}
	}
	if hy == int32(0x40000000) {
		return x * x
	} /* y is  2 */
	if hy == int32(0x3f000000) {
		/* y is  0.5 */
		if hx >= 0 { /* x >= +0 */
			return _sqrtf(tls, x)
		}
	}
	ax = x_fabsf(tls, x)
	/* special value of x */
	if ix == int32(0x7f800000) || ix == 0 || ix == int32(0x3f800000) {
		z = ax /*x is +-0,+-inf,+-1*/
		if hy < 0 {
			z = _one15 / z
		} /* z = (1/|x|) */
		if hx < 0 {
			if ix-int32(0x3f800000)|yisint == 0 {
				z = (z - z) / (z - z)
			} else if yisint == int32(1) {
				z = -z
			} /* (x<0)**odd = -(|x|**odd) */
		}
		return z
	}
	n = int32(uint32(hx)>>Int32FromInt32(31) - uint32(1))
	/* (x<0)**(non-int) is NaN */
	if n|yisint == 0 {
		return (x - x) / (x - x)
	}
	sn = _one15 /* s (sign of result -ve**odd) = -1 else = 1 */
	if n|(yisint-int32(1)) == 0 {
		sn = -_one15
	} /* (-ve)**(odd int) */
	/* |y| is huge */
	if iy > int32(0x4d000000) { /* if |y| > 2**27 */
		/* over/underflow if x is not close to one */
		if ix < int32(0x3f7ffff8) {
			if hy < 0 {
				v3 = sn * _huge9 * _huge9
			} else {
				v3 = sn * _tiny3 * _tiny3
			}
			return v3
		}
		if ix > int32(0x3f800007) {
			if hy > 0 {
				v4 = sn * _huge9 * _huge9
			} else {
				v4 = sn * _tiny3 * _tiny3
			}
			return v4
		}
		/* now |1-x| is tiny <= 2**-20, suffice to compute
		   log(x) by x-x^2/2+x^3/3-x^4/4 */
		t = ax - Float32FromInt32(1) /* t has 20 trailing zeros */
		w = t * t * (Float32FromFloat64(0.5) - t*(Float32FromFloat64(0.333333333333)-t*Float32FromFloat64(0.25)))
		u = _ivln2_h1 * t /* ivln2_h has 16 sig. bits */
		v = t*_ivln2_l1 - w*_ivln21
		t1 = u + v
		*(*float32)(unsafe.Pointer(bp + 8)) = t1
		is = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
		*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(is) & Uint32FromUint32(0xfffff000)
		t1 = *(*float32)(unsafe.Pointer(bp + 12))
		t2 = v - (t1 - u)
	} else {
		n = 0
		/* take care subnormal number */
		if ix < int32(0x00800000) {
			ax *= _two24
			n -= int32(24)
			*(*float32)(unsafe.Pointer(bp + 16)) = ax
			ix = int32(*(*uint32)(unsafe.Pointer(bp + 16)))
		}
		n += ix>>Int32FromInt32(23) - int32(0x7f)
		j = ix & int32(0x007fffff)
		/* determine interval */
		ix = j | int32(0x3f800000) /* normalize ix */
		if j <= int32(0x1cc471) {
			k = 0
		} else {
			if j < int32(0x5db3d7) {
				k = int32(1)
			} else {
				k = 0
				n += int32(1)
				ix -= int32(0x00800000)
			}
		}
		*(*uint32)(unsafe.Pointer(bp + 20)) = uint32(ix)
		ax = *(*float32)(unsafe.Pointer(bp + 20))
		/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
		u = ax - _bp1[k] /* bp[0]=1.0, bp[1]=1.5 */
		v = _one15 / (ax + _bp1[k])
		s = u * v
		s_h = s
		*(*float32)(unsafe.Pointer(bp + 24)) = s_h
		is = int32(*(*uint32)(unsafe.Pointer(bp + 24)))
		*(*uint32)(unsafe.Pointer(bp + 28)) = uint32(is) & Uint32FromUint32(0xfffff000)
		s_h = *(*float32)(unsafe.Pointer(bp + 28))
		/* t_h=ax+bp[k] High */
		is = int32(uint32(ix>>Int32FromInt32(1))&uint32(0xfffff000) | uint32(0x20000000))
		*(*uint32)(unsafe.Pointer(bp + 32)) = uint32(is + Int32FromInt32(0x00400000) + k<<Int32FromInt32(21))
		t_h = *(*float32)(unsafe.Pointer(bp + 32))
		t_l = ax - (t_h - _bp1[k])
		s_l = v * (u - s_h*t_h - s_h*t_l)
		/* compute log(ax) */
		s2 = s * s
		r = s2 * s2 * (_L11 + s2*(_L21+s2*(_L31+s2*(_L41+s2*(_L51+s2*_L61)))))
		r += s_l * (s_h + s)
		s2 = s_h * s_h
		t_h = Float32FromFloat64(3) + s2 + r
		*(*float32)(unsafe.Pointer(bp + 36)) = t_h
		is = int32(*(*uint32)(unsafe.Pointer(bp + 36)))
		*(*uint32)(unsafe.Pointer(bp + 40)) = uint32(is) & Uint32FromUint32(0xfffff000)
		t_h = *(*float32)(unsafe.Pointer(bp + 40))
		t_l = r - (t_h - Float32FromFloat64(3) - s2)
		/* u+v = s*(1+...) */
		u = s_h * t_h
		v = s_l*t_h + t_l*s
		/* 2/(3log2)*(s+...) */
		p_h = u + v
		*(*float32)(unsafe.Pointer(bp + 44)) = p_h
		is = int32(*(*uint32)(unsafe.Pointer(bp + 44)))
		*(*uint32)(unsafe.Pointer(bp + 48)) = uint32(is) & Uint32FromUint32(0xfffff000)
		p_h = *(*float32)(unsafe.Pointer(bp + 48))
		p_l = v - (p_h - u)
		z_h = _cp_h1 * p_h /* cp_h+cp_l = 2/(3*log2) */
		z_l = _cp_l1*p_h + p_l*_cp1 + _dp_l1[k]
		/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
		t = float32(n)
		t1 = z_h + z_l + _dp_h1[k] + t
		*(*float32)(unsafe.Pointer(bp + 52)) = t1
		is = int32(*(*uint32)(unsafe.Pointer(bp + 52)))
		*(*uint32)(unsafe.Pointer(bp + 56)) = uint32(is) & Uint32FromUint32(0xfffff000)
		t1 = *(*float32)(unsafe.Pointer(bp + 56))
		t2 = z_l - (t1 - t - _dp_h1[k] - z_h)
	}
	/* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
	*(*float32)(unsafe.Pointer(bp + 60)) = y
	is = int32(*(*uint32)(unsafe.Pointer(bp + 60)))
	*(*uint32)(unsafe.Pointer(bp + 64)) = uint32(is) & Uint32FromUint32(0xfffff000)
	y1 = *(*float32)(unsafe.Pointer(bp + 64))
	p_l = (y-y1)*t1 + y*t2
	p_h = y1 * t1
	z = p_l + p_h
	*(*float32)(unsafe.Pointer(bp + 68)) = z
	j = int32(*(*uint32)(unsafe.Pointer(bp + 68)))
	if j > int32(0x43000000) { /* if z > 128 */
		return sn * _huge9 * _huge9
	} else {
		if j == int32(0x43000000) { /* if z == 128 */
			if p_l+_ovt1 > z-p_h {
				return sn * _huge9 * _huge9
			}
		} else {
			if j&int32(0x7fffffff) > int32(0x43160000) { /* z <= -150 */
				return sn * _tiny3 * _tiny3
			} else if uint32(j) == uint32(0xc3160000) {
				/* z == -150 */
				if p_l <= z-p_h {
					return sn * _tiny3 * _tiny3
				} /* underflow */
			}
		}
	}
	/*
	 * compute 2**(p_h+p_l)
	 */
	i = j & int32(0x7fffffff)
	k = i>>Int32FromInt32(23) - int32(0x7f)
	n = 0
	if i > int32(0x3f000000) {
		/* if |z| > 0.5, set n = [z+0.5] */
		n = j + int32(0x00800000)>>(k+int32(1))
		k = n&int32(0x7fffffff)>>int32(23) - int32(0x7f) /* new k for n */
		*(*uint32)(unsafe.Pointer(bp + 72)) = uint32(n & ^(Int32FromInt32(0x007fffff) >> k))
		t = *(*float32)(unsafe.Pointer(bp + 72))
		n = (n&int32(0x007fffff) | int32(0x00800000)) >> (int32(23) - k)
		if j < 0 {
			n = -n
		}
		p_h -= t
	}
	t = p_l + p_h
	*(*float32)(unsafe.Pointer(bp + 76)) = t
	is = int32(*(*uint32)(unsafe.Pointer(bp + 76)))
	*(*uint32)(unsafe.Pointer(bp + 80)) = uint32(is) & Uint32FromUint32(0xffff8000)
	t = *(*float32)(unsafe.Pointer(bp + 80))
	u = t * _lg2_h1
	v = (p_l-(t-p_h))*_lg21 + t*_lg2_l1
	z = u + v
	w = v - (z - u)
	t = z * z
	t1 = z - t*(_P13+t*(_P23+t*(_P33+t*(_P43+t*_P53))))
	r = z*t1/(t1-_two1) - (w + z*w)
	z = _one15 - (r - z)
	*(*float32)(unsafe.Pointer(bp + 84)) = z
	j = int32(*(*uint32)(unsafe.Pointer(bp + 84)))
	j += n << Int32FromInt32(23)
	if j>>Int32FromInt32(23) <= 0 {
		z = x_scalbnf(tls, z, n)
	} else {
		*(*uint32)(unsafe.Pointer(bp + 88)) = uint32(j)
		z = *(*float32)(unsafe.Pointer(bp + 88))
	}
	return sn * z
}

/*
 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
 */
var _two_over_pi = [66]int32{
	0:  int32(0xA2F983),
	1:  int32(0x6E4E44),
	2:  int32(0x1529FC),
	3:  int32(0x2757D1),
	4:  int32(0xF534DD),
	5:  int32(0xC0DB62),
	6:  int32(0x95993C),
	7:  int32(0x439041),
	8:  int32(0xFE5163),
	9:  int32(0xABDEBB),
	10: int32(0xC561B7),
	11: int32(0x246E3A),
	12: int32(0x424DD2),
	13: int32(0xE00649),
	14: int32(0x2EEA09),
	15: int32(0xD1921C),
	16: int32(0xFE1DEB),
	17: int32(0x1CB129),
	18: int32(0xA73EE8),
	19: int32(0x8235F5),
	20: int32(0x2EBB44),
	21: int32(0x84E99C),
	22: int32(0x7026B4),
	23: int32(0x5F7E41),
	24: int32(0x3991D6),
	25: int32(0x398353),
	26: int32(0x39F49C),
	27: int32(0x845F8B),
	28: int32(0xBDF928),
	29: int32(0x3B1FF8),
	30: int32(0x97FFDE),
	31: int32(0x05980F),
	32: int32(0xEF2F11),
	33: int32(0x8B5A0A),
	34: int32(0x6D1F6D),
	35: int32(0x367ECF),
	36: int32(0x27CB09),
	37: int32(0xB74F46),
	38: int32(0x3F669E),
	39: int32(0x5FEA2D),
	40: int32(0x7527BA),
	41: int32(0xC7EBE5),
	42: int32(0xF17B3D),
	43: int32(0x0739F7),
	44: int32(0x8A5292),
	45: int32(0xEA6BFB),
	46: int32(0x5FB11F),
	47: int32(0x8D5D08),
	48: int32(0x560330),
	49: int32(0x46FC7B),
	50: int32(0x6BABF0),
	51: int32(0xCFBC20),
	52: int32(0x9AF436),
	53: int32(0x1DA9E3),
	54: int32(0x91615E),
	55: int32(0xE61B08),
	56: int32(0x659985),
	57: int32(0x5F14A0),
	58: int32(0x68408D),
	59: int32(0xFFD880),
	60: int32(0x4D7327),
	61: int32(0x310606),
	62: int32(0x1556CA),
	63: int32(0x73A8C9),
	64: int32(0x60E27B),
	65: int32(0xC08C6B)}

var _npio2_hw = [32]int32{
	0:  int32(0x3FF921FB),
	1:  int32(0x400921FB),
	2:  int32(0x4012D97C),
	3:  int32(0x401921FB),
	4:  int32(0x401F6A7A),
	5:  int32(0x4022D97C),
	6:  int32(0x4025FDBB),
	7:  int32(0x402921FB),
	8:  int32(0x402C463A),
	9:  int32(0x402F6A7A),
	10: int32(0x4031475C),
	11: int32(0x4032D97C),
	12: int32(0x40346B9C),
	13: int32(0x4035FDBB),
	14: int32(0x40378FDB),
	15: int32(0x403921FB),
	16: int32(0x403AB41B),
	17: int32(0x403C463A),
	18: int32(0x403DD85A),
	19: int32(0x403F6A7A),
	20: int32(0x40407E4C),
	21: int32(0x4041475C),
	22: int32(0x4042106C),
	23: int32(0x4042D97C),
	24: int32(0x4043A28C),
	25: int32(0x40446B9C),
	26: int32(0x404534AC),
	27: int32(0x4045FDBB),
	28: int32(0x4046C6CB),
	29: int32(0x40478FDB),
	30: int32(0x404858EB),
	31: int32(0x404921FB)}

/*
 * invpio2:  53 bits of 2/pi
 * pio2_1:   first  33 bit of pi/2
 * pio2_1t:  pi/2 - pio2_1
 * pio2_2:   second 33 bit of pi/2
 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
 * pio2_3:   third  33 bit of pi/2
 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
 */

var _zero10 = float64(0)                       /* 0x00000000, 0x00000000 */
var _half2 = float64(0.5)                      /* 0x3FE00000, 0x00000000 */
var _two241 = float64(1.6777216e+07)           /* 0x41700000, 0x00000000 */
var _invpio2 = float64(0.6366197723675814)     /* 0x3FE45F30, 0x6DC9C883 */
var _pio2_1 = float64(1.5707963267341256)      /* 0x3FF921FB, 0x54400000 */
var _pio2_1t = float64(6.077100506506192e-11)  /* 0x3DD0B461, 0x1A626331 */
var _pio2_2 = float64(6.077100506303966e-11)   /* 0x3DD0B461, 0x1A600000 */
var _pio2_2t = float64(2.0222662487959506e-21) /* 0x3BA3198A, 0x2E037073 */
var _pio2_3 = float64(2.0222662487111665e-21)  /* 0x3BA3198A, 0x2E000000 */
var _pio2_3t = float64(8.4784276603689e-32)

func x___ieee754_rem_pio2(tls *TLS, x float64, y uintptr) (r1 int32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var e0, hx, i, ix, j, n, nx int32
	var fn, r, t, w, z, v1 float64
	var high, low uint32
	var _ /* gh_u at bp+24 */ Tieee_double_shape_type
	var _ /* gh_u at bp+32 */ Tieee_double_shape_type
	var _ /* gh_u at bp+40 */ Tieee_double_shape_type
	var _ /* gl_u at bp+48 */ Tieee_double_shape_type
	var _ /* iw_u at bp+56 */ Tieee_double_shape_type
	var _ /* tx at bp+0 */ [3]float64
	*(*float64)(unsafe.Pointer(bp + 24)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp + 24)) >> int32(32)) /* high word of x */
	ix = hx & int32(0x7fffffff)
	if ix <= int32(0x3fe921fb) {
		/* |x| ~<= pi/4 , no need for reduction */
		*(*float64)(unsafe.Pointer(y)) = x
		*(*float64)(unsafe.Pointer(y + 1*8)) = Float64FromInt32(0)
		return 0
	}
	if ix < int32(0x4002d97c) {
		/* |x| < 3pi/4, special case with n=+-1 */
		if hx > 0 {
			z = x - _pio2_1
			if ix != int32(0x3ff921fb) { /* 33+53 bit pi is good enough */
				*(*float64)(unsafe.Pointer(y)) = z - _pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - _pio2_1t
			} else { /* near pi/2, use 33+33+53 bit pi */
				z -= _pio2_2
				*(*float64)(unsafe.Pointer(y)) = z - _pio2_2t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - _pio2_2t
			}
			return int32(1)
		} else { /* negative x */
			z = x + _pio2_1
			if ix != int32(0x3ff921fb) { /* 33+53 bit pi is good enough */
				*(*float64)(unsafe.Pointer(y)) = z + _pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + _pio2_1t
			} else { /* near pi/2, use 33+33+53 bit pi */
				z += _pio2_2
				*(*float64)(unsafe.Pointer(y)) = z + _pio2_2t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + _pio2_2t
			}
			return -int32(1)
		}
	}
	if ix <= int32(0x413921fb) {
		/* |x| ~<= 2^19*(pi/2), medium size */
		t = x_fabs(tls, x)
		n = int32(t*_invpio2 + _half2)
		fn = float64(n)
		r = t - fn*_pio2_1
		w = fn * _pio2_1t /* 1st round good to 85 bit */
		if n < int32(32) && ix != _npio2_hw[n-int32(1)] {
			*(*float64)(unsafe.Pointer(y)) = r - w
		} else {
			j = ix >> int32(20)
			*(*float64)(unsafe.Pointer(y)) = r - w
			*(*float64)(unsafe.Pointer(bp + 32)) = *(*float64)(unsafe.Pointer(y))
			high = uint32(*(*uint64)(unsafe.Pointer(bp + 32)) >> int32(32))
			i = int32(uint32(j) - high>>Int32FromInt32(20)&uint32(0x7ff))
			if i > int32(16) {
				/* 2nd iteration needed, good to 118 */
				t = r
				w = fn * _pio2_2
				r = t - w
				w = fn*_pio2_2t - (t - r - w)
				*(*float64)(unsafe.Pointer(y)) = r - w
				*(*float64)(unsafe.Pointer(bp + 40)) = *(*float64)(unsafe.Pointer(y))
				high = uint32(*(*uint64)(unsafe.Pointer(bp + 40)) >> int32(32))
				i = int32(uint32(j) - high>>Int32FromInt32(20)&uint32(0x7ff))
				if i > int32(49) {
					/* 3rd iteration need, 151 bits acc */
					t = r /* will cover all possible cases */
					w = fn * _pio2_3
					r = t - w
					w = fn*_pio2_3t - (t - r - w)
					*(*float64)(unsafe.Pointer(y)) = r - w
				}
			}
		}
		*(*float64)(unsafe.Pointer(y + 1*8)) = r - *(*float64)(unsafe.Pointer(y)) - w
		if hx < 0 {
			*(*float64)(unsafe.Pointer(y)) = -*(*float64)(unsafe.Pointer(y))
			*(*float64)(unsafe.Pointer(y + 1*8)) = -*(*float64)(unsafe.Pointer(y + 1*8))
			return -n
		} else {
			return n
		}
	}
	/*
	 * all other (large) arguments
	 */
	if ix >= int32(0x7ff00000) {
		/* x is inf or NaN */
		v1 = x - x
		*(*float64)(unsafe.Pointer(y + 1*8)) = v1
		*(*float64)(unsafe.Pointer(y)) = v1
		return 0
	}
	/* set z = scalbn(|x|,ilogb(x)-23) */
	*(*float64)(unsafe.Pointer(bp + 48)) = x
	low = uint32(*(*uint64)(unsafe.Pointer(bp + 48)))
	e0 = ix>>Int32FromInt32(20) - int32(1046) /* e0 = ilogb(z)-23; */
	*(*uint64)(unsafe.Pointer(bp + 56)) = uint64(ix-e0<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(low)
	z = *(*float64)(unsafe.Pointer(bp + 56))
	for i = 0; i < int32(2); i++ {
		(*(*[3]float64)(unsafe.Pointer(bp)))[i] = float64(int32(z))
		z = (z - (*(*[3]float64)(unsafe.Pointer(bp)))[i]) * _two241
	}
	(*(*[3]float64)(unsafe.Pointer(bp)))[int32(2)] = z
	nx = int32(3)
	for (*(*[3]float64)(unsafe.Pointer(bp)))[nx-int32(1)] == _zero10 {
		nx--
	} /* skip zero term */
	n = x___kernel_rem_pio2(tls, bp, y, e0, nx, int32(2), uintptr(unsafe.Pointer(&_two_over_pi)))
	if hx < 0 {
		*(*float64)(unsafe.Pointer(y)) = -*(*float64)(unsafe.Pointer(y))
		*(*float64)(unsafe.Pointer(y + 1*8)) = -*(*float64)(unsafe.Pointer(y + 1*8))
		return -n
	}
	return n
}

/*
 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
 */
var _two_over_pi1 = [198]int32{
	0:   int32(0xA2),
	1:   int32(0xF9),
	2:   int32(0x83),
	3:   int32(0x6E),
	4:   int32(0x4E),
	5:   int32(0x44),
	6:   int32(0x15),
	7:   int32(0x29),
	8:   int32(0xFC),
	9:   int32(0x27),
	10:  int32(0x57),
	11:  int32(0xD1),
	12:  int32(0xF5),
	13:  int32(0x34),
	14:  int32(0xDD),
	15:  int32(0xC0),
	16:  int32(0xDB),
	17:  int32(0x62),
	18:  int32(0x95),
	19:  int32(0x99),
	20:  int32(0x3C),
	21:  int32(0x43),
	22:  int32(0x90),
	23:  int32(0x41),
	24:  int32(0xFE),
	25:  int32(0x51),
	26:  int32(0x63),
	27:  int32(0xAB),
	28:  int32(0xDE),
	29:  int32(0xBB),
	30:  int32(0xC5),
	31:  int32(0x61),
	32:  int32(0xB7),
	33:  int32(0x24),
	34:  int32(0x6E),
	35:  int32(0x3A),
	36:  int32(0x42),
	37:  int32(0x4D),
	38:  int32(0xD2),
	39:  int32(0xE0),
	40:  int32(0x06),
	41:  int32(0x49),
	42:  int32(0x2E),
	43:  int32(0xEA),
	44:  int32(0x09),
	45:  int32(0xD1),
	46:  int32(0x92),
	47:  int32(0x1C),
	48:  int32(0xFE),
	49:  int32(0x1D),
	50:  int32(0xEB),
	51:  int32(0x1C),
	52:  int32(0xB1),
	53:  int32(0x29),
	54:  int32(0xA7),
	55:  int32(0x3E),
	56:  int32(0xE8),
	57:  int32(0x82),
	58:  int32(0x35),
	59:  int32(0xF5),
	60:  int32(0x2E),
	61:  int32(0xBB),
	62:  int32(0x44),
	63:  int32(0x84),
	64:  int32(0xE9),
	65:  int32(0x9C),
	66:  int32(0x70),
	67:  int32(0x26),
	68:  int32(0xB4),
	69:  int32(0x5F),
	70:  int32(0x7E),
	71:  int32(0x41),
	72:  int32(0x39),
	73:  int32(0x91),
	74:  int32(0xD6),
	75:  int32(0x39),
	76:  int32(0x83),
	77:  int32(0x53),
	78:  int32(0x39),
	79:  int32(0xF4),
	80:  int32(0x9C),
	81:  int32(0x84),
	82:  int32(0x5F),
	83:  int32(0x8B),
	84:  int32(0xBD),
	85:  int32(0xF9),
	86:  int32(0x28),
	87:  int32(0x3B),
	88:  int32(0x1F),
	89:  int32(0xF8),
	90:  int32(0x97),
	91:  int32(0xFF),
	92:  int32(0xDE),
	93:  int32(0x05),
	94:  int32(0x98),
	95:  int32(0x0F),
	96:  int32(0xEF),
	97:  int32(0x2F),
	98:  int32(0x11),
	99:  int32(0x8B),
	100: int32(0x5A),
	101: int32(0x0A),
	102: int32(0x6D),
	103: int32(0x1F),
	104: int32(0x6D),
	105: int32(0x36),
	106: int32(0x7E),
	107: int32(0xCF),
	108: int32(0x27),
	109: int32(0xCB),
	110: int32(0x09),
	111: int32(0xB7),
	112: int32(0x4F),
	113: int32(0x46),
	114: int32(0x3F),
	115: int32(0x66),
	116: int32(0x9E),
	117: int32(0x5F),
	118: int32(0xEA),
	119: int32(0x2D),
	120: int32(0x75),
	121: int32(0x27),
	122: int32(0xBA),
	123: int32(0xC7),
	124: int32(0xEB),
	125: int32(0xE5),
	126: int32(0xF1),
	127: int32(0x7B),
	128: int32(0x3D),
	129: int32(0x07),
	130: int32(0x39),
	131: int32(0xF7),
	132: int32(0x8A),
	133: int32(0x52),
	134: int32(0x92),
	135: int32(0xEA),
	136: int32(0x6B),
	137: int32(0xFB),
	138: int32(0x5F),
	139: int32(0xB1),
	140: int32(0x1F),
	141: int32(0x8D),
	142: int32(0x5D),
	143: int32(0x08),
	144: int32(0x56),
	145: int32(0x03),
	146: int32(0x30),
	147: int32(0x46),
	148: int32(0xFC),
	149: int32(0x7B),
	150: int32(0x6B),
	151: int32(0xAB),
	152: int32(0xF0),
	153: int32(0xCF),
	154: int32(0xBC),
	155: int32(0x20),
	156: int32(0x9A),
	157: int32(0xF4),
	158: int32(0x36),
	159: int32(0x1D),
	160: int32(0xA9),
	161: int32(0xE3),
	162: int32(0x91),
	163: int32(0x61),
	164: int32(0x5E),
	165: int32(0xE6),
	166: int32(0x1B),
	167: int32(0x08),
	168: int32(0x65),
	169: int32(0x99),
	170: int32(0x85),
	171: int32(0x5F),
	172: int32(0x14),
	173: int32(0xA0),
	174: int32(0x68),
	175: int32(0x40),
	176: int32(0x8D),
	177: int32(0xFF),
	178: int32(0xD8),
	179: int32(0x80),
	180: int32(0x4D),
	181: int32(0x73),
	182: int32(0x27),
	183: int32(0x31),
	184: int32(0x06),
	185: int32(0x06),
	186: int32(0x15),
	187: int32(0x56),
	188: int32(0xCA),
	189: int32(0x73),
	190: int32(0xA8),
	191: int32(0xC9),
	192: int32(0x60),
	193: int32(0xE2),
	194: int32(0x7B),
	195: int32(0xC0),
	196: int32(0x8C),
	197: int32(0x6B)}

/*
This array is like the one in e_rem_pio2.c, but the numbers are

	single precision and the last 8 bits are forced to 0.
*/
var _npio2_hw1 = [32]int32{
	0:  int32(0x3fc90f00),
	1:  int32(0x40490f00),
	2:  int32(0x4096cb00),
	3:  int32(0x40c90f00),
	4:  int32(0x40fb5300),
	5:  int32(0x4116cb00),
	6:  int32(0x412fed00),
	7:  int32(0x41490f00),
	8:  int32(0x41623100),
	9:  int32(0x417b5300),
	10: int32(0x418a3a00),
	11: int32(0x4196cb00),
	12: int32(0x41a35c00),
	13: int32(0x41afed00),
	14: int32(0x41bc7e00),
	15: int32(0x41c90f00),
	16: int32(0x41d5a000),
	17: int32(0x41e23100),
	18: int32(0x41eec200),
	19: int32(0x41fb5300),
	20: int32(0x4203f200),
	21: int32(0x420a3a00),
	22: int32(0x42108300),
	23: int32(0x4216cb00),
	24: int32(0x421d1400),
	25: int32(0x42235c00),
	26: int32(0x4229a500),
	27: int32(0x422fed00),
	28: int32(0x42363600),
	29: int32(0x423c7e00),
	30: int32(0x4242c700),
	31: int32(0x42490f00)}

/*
 * invpio2:  24 bits of 2/pi
 * pio2_1:   first  17 bit of pi/2
 * pio2_1t:  pi/2 - pio2_1
 * pio2_2:   second 17 bit of pi/2
 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
 * pio2_3:   third  17 bit of pi/2
 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
 */

var _zero11 = float32(0)                  /* 0x00000000 */
var _half3 = float32(0.5)                 /* 0x3f000000 */
var _two8 = float32(256)                  /* 0x43800000 */
var _invpio21 = float32(0.63661980629)    /* 0x3f22f984 */
var _pio2_11 = float32(1.5707855225)      /* 0x3fc90f80 */
var _pio2_1t1 = float32(1.0804334124e-05) /* 0x37354443 */
var _pio2_21 = float32(1.0804273188e-05)  /* 0x37354400 */
var _pio2_2t1 = float32(6.0770999344e-11) /* 0x2e85a308 */
var _pio2_31 = float32(6.0770943833e-11)  /* 0x2e85a300 */
var _pio2_3t1 = float32(6.1232342629e-17)

func x___ieee754_rem_pio2f(tls *TLS, x float32, y uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var e0, hx, i, ix, j, n, nx int32
	var fn, r, t, w, z, v1 float32
	var high uint32
	var _ /* gf_u at bp+12 */ Tieee_float_shape_type
	var _ /* gf_u at bp+16 */ Tieee_float_shape_type
	var _ /* gf_u at bp+20 */ Tieee_float_shape_type
	var _ /* sf_u at bp+24 */ Tieee_float_shape_type
	var _ /* tx at bp+0 */ [3]float32
	*(*float32)(unsafe.Pointer(bp + 12)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp + 12)))
	ix = hx & int32(0x7fffffff)
	if ix <= int32(0x3f490fd8) {
		/* |x| ~<= pi/4 , no need for reduction */
		*(*float32)(unsafe.Pointer(y)) = x
		*(*float32)(unsafe.Pointer(y + 1*4)) = Float32FromInt32(0)
		return 0
	}
	if ix < int32(0x4016cbe4) {
		/* |x| < 3pi/4, special case with n=+-1 */
		if hx > 0 {
			z = x - _pio2_11
			if uint32(ix)&uint32(0xfffffff0) != uint32(0x3fc90fd0) { /* 24+24 bit pi OK */
				*(*float32)(unsafe.Pointer(y)) = z - _pio2_1t1
				*(*float32)(unsafe.Pointer(y + 1*4)) = z - *(*float32)(unsafe.Pointer(y)) - _pio2_1t1
			} else { /* near pi/2, use 24+24+24 bit pi */
				z -= _pio2_21
				*(*float32)(unsafe.Pointer(y)) = z - _pio2_2t1
				*(*float32)(unsafe.Pointer(y + 1*4)) = z - *(*float32)(unsafe.Pointer(y)) - _pio2_2t1
			}
			return int32(1)
		} else { /* negative x */
			z = x + _pio2_11
			if uint32(ix)&uint32(0xfffffff0) != uint32(0x3fc90fd0) { /* 24+24 bit pi OK */
				*(*float32)(unsafe.Pointer(y)) = z + _pio2_1t1
				*(*float32)(unsafe.Pointer(y + 1*4)) = z - *(*float32)(unsafe.Pointer(y)) + _pio2_1t1
			} else { /* near pi/2, use 24+24+24 bit pi */
				z += _pio2_21
				*(*float32)(unsafe.Pointer(y)) = z + _pio2_2t1
				*(*float32)(unsafe.Pointer(y + 1*4)) = z - *(*float32)(unsafe.Pointer(y)) + _pio2_2t1
			}
			return -int32(1)
		}
	}
	if ix <= int32(0x43490f80) {
		/* |x| ~<= 2^7*(pi/2), medium size */
		t = x_fabsf(tls, x)
		n = int32(t*_invpio21 + _half3)
		fn = float32(n)
		r = t - fn*_pio2_11
		w = fn * _pio2_1t1 /* 1st round good to 40 bit */
		if n < int32(32) && uint32(ix)&uint32(0xffffff00) != uint32(_npio2_hw1[n-int32(1)]) {
			*(*float32)(unsafe.Pointer(y)) = r - w
		} else {
			j = ix >> int32(23)
			*(*float32)(unsafe.Pointer(y)) = r - w
			*(*float32)(unsafe.Pointer(bp + 16)) = *(*float32)(unsafe.Pointer(y))
			high = *(*uint32)(unsafe.Pointer(bp + 16))
			i = int32(uint32(j) - high>>Int32FromInt32(23)&uint32(0xff))
			if i > int32(8) {
				/* 2nd iteration needed, good to 57 */
				t = r
				w = fn * _pio2_21
				r = t - w
				w = fn*_pio2_2t1 - (t - r - w)
				*(*float32)(unsafe.Pointer(y)) = r - w
				*(*float32)(unsafe.Pointer(bp + 20)) = *(*float32)(unsafe.Pointer(y))
				high = *(*uint32)(unsafe.Pointer(bp + 20))
				i = int32(uint32(j) - high>>Int32FromInt32(23)&uint32(0xff))
				if i > int32(25) {
					/* 3rd iteration need, 74 bits acc */
					t = r /* will cover all possible cases */
					w = fn * _pio2_31
					r = t - w
					w = fn*_pio2_3t1 - (t - r - w)
					*(*float32)(unsafe.Pointer(y)) = r - w
				}
			}
		}
		*(*float32)(unsafe.Pointer(y + 1*4)) = r - *(*float32)(unsafe.Pointer(y)) - w
		if hx < 0 {
			*(*float32)(unsafe.Pointer(y)) = -*(*float32)(unsafe.Pointer(y))
			*(*float32)(unsafe.Pointer(y + 1*4)) = -*(*float32)(unsafe.Pointer(y + 1*4))
			return -n
		} else {
			return n
		}
	}
	/*
	 * all other (large) arguments
	 */
	if ix >= int32(0x7f800000) {
		/* x is inf or NaN */
		v1 = x - x
		*(*float32)(unsafe.Pointer(y + 1*4)) = v1
		*(*float32)(unsafe.Pointer(y)) = v1
		return 0
	}
	/* set z = scalbn(|x|,ilogb(x)-7) */
	e0 = ix>>Int32FromInt32(23) - int32(134) /* e0 = ilogb(z)-7; */
	*(*uint32)(unsafe.Pointer(bp + 24)) = uint32(ix - e0<<Int32FromInt32(23))
	z = *(*float32)(unsafe.Pointer(bp + 24))
	for i = 0; i < int32(2); i++ {
		(*(*[3]float32)(unsafe.Pointer(bp)))[i] = float32(int32(z))
		z = (z - (*(*[3]float32)(unsafe.Pointer(bp)))[i]) * _two8
	}
	(*(*[3]float32)(unsafe.Pointer(bp)))[int32(2)] = z
	nx = int32(3)
	for (*(*[3]float32)(unsafe.Pointer(bp)))[nx-int32(1)] == _zero11 {
		nx--
	} /* skip zero term */
	n = x___kernel_rem_pio2f(tls, bp, y, e0, nx, int32(2), uintptr(unsafe.Pointer(&_two_over_pi1)))
	if hx < 0 {
		*(*float32)(unsafe.Pointer(y)) = -*(*float32)(unsafe.Pointer(y))
		*(*float32)(unsafe.Pointer(y + 1*4)) = -*(*float32)(unsafe.Pointer(y + 1*4))
		return -n
	}
	return n
}

var _zero12 = float64(0)

func x_remainder(tls *TLS, x float64, p float64) (r float64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var hp, hx int32
	var lp, lx, sx uint32
	var p_half float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	*(*float64)(unsafe.Pointer(bp + 8)) = p
	hp = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	lp = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	sx = uint32(hx) & uint32(0x80000000)
	hp &= int32(0x7fffffff)
	hx &= int32(0x7fffffff)
	/* purge off exception values */
	if uint32(hp)|lp == uint32(0) {
		return x * p / (x * p)
	} /* p = 0 */
	if hx >= int32(0x7ff00000) || hp >= int32(0x7ff00000) && uint32(hp-Int32FromInt32(0x7ff00000))|lp != uint32(0) {
		return x * p / (x * p)
	}
	if hp <= int32(0x7fdfffff) {
		x = x_fmod(tls, x, p+p)
	} /* now x < 2p */
	if uint32(hx-hp)|(lx-lp) == uint32(0) {
		return _zero12 * x
	}
	x = x_fabs(tls, x)
	p = x_fabs(tls, p)
	if hp < int32(0x00200000) {
		if x+x > p {
			x -= p
			if x+x >= p {
				x -= p
			}
		}
	} else {
		p_half = float64(0.5) * p
		if x > p_half {
			x -= p
			if x >= p_half {
				x -= p
			}
		}
	}
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 24)) = x
	*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(uint32(hx)^sx) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 24))
	return x
}

var _zero13 = float32(0)

func x_remainderf(tls *TLS, x float32, p float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hp, hx int32
	var p_half float32
	var sx uint32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	*(*float32)(unsafe.Pointer(bp + 4)) = p
	hp = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	sx = uint32(hx) & uint32(0x80000000)
	hp &= int32(0x7fffffff)
	hx &= int32(0x7fffffff)
	/* purge off exception values */
	if hp == 0 {
		return x * p / (x * p)
	} /* p = 0 */
	if hx >= int32(0x7f800000) || hp > int32(0x7f800000) { /* p is NaN */
		return x * p / (x * p)
	}
	if hp <= int32(0x7effffff) {
		x = x_fmodf(tls, x, p+p)
	} /* now x < 2p */
	if hx-hp == 0 {
		return _zero13 * x
	}
	x = x_fabsf(tls, x)
	p = x_fabsf(tls, p)
	if hp < int32(0x01000000) {
		if x+x > p {
			x -= p
			if x+x >= p {
				x -= p
			}
		}
	} else {
		p_half = Float32FromFloat64(0.5) * p
		if x > p_half {
			x -= p
			if x >= p_half {
				x -= p
			}
		}
	}
	*(*float32)(unsafe.Pointer(bp + 8)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
	*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(hx) ^ sx
	x = *(*float32)(unsafe.Pointer(bp + 12))
	return x
}

func x_scalb(tls *TLS, x float64, fn float64) (r float64) {
	if x___fpclassify(tls, x) == m_FP_NAN || x___fpclassify(tls, fn) == m_FP_NAN {
		return x * fn
	}
	if !(x___fpclassify(tls, fn) > Int32FromInt32(m_FP_INFINITE)) {
		if fn > float64(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if x_rint(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > float64(65000) {
		return x_scalbn(tls, x, int32(65000))
	}
	if -fn > float64(65000) {
		return x_scalbn(tls, x, -int32(65000))
	}
	return x_scalbn(tls, x, int32(fn))
}

func x_scalbf(tls *TLS, x float32, fn float32) (r float32) {
	if x___fpclassifyf(tls, x) == m_FP_NAN || x___fpclassifyf(tls, fn) == m_FP_NAN {
		return x * fn
	}
	if !(x___fpclassifyf(tls, fn) > Int32FromInt32(m_FP_INFINITE)) {
		if fn > Float32FromFloat64(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if x_rintf(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > Float32FromFloat64(65000) {
		return x_scalbnf(tls, x, int32(65000))
	}
	if -fn > Float32FromFloat64(65000) {
		return x_scalbnf(tls, x, -int32(65000))
	}
	return x_scalbnf(tls, x, int32(fn))
}

var _one16 = float64(1)
var _shuge = float64(1e+307)

func x_sinh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var h, t, w float64
	var ix, jx int32
	var lx uint32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	/* High word of |x|. */
	*(*float64)(unsafe.Pointer(bp)) = x
	jx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = jx & int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7ff00000) {
		return x + x
	}
	h = float64(0.5)
	if jx < 0 {
		h = -h
	}
	/* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
	if ix < int32(0x40360000) {
		/* |x|<22 */
		if ix < int32(0x3e300000) { /* |x|<2**-28 */
			if _shuge+x > _one16 {
				return x
			}
		} /* sinh(tiny) = tiny with inexact */
		t = x_expm1(tls, x_fabs(tls, x))
		if ix < int32(0x3ff00000) {
			return h * (float64(2)*t - t*t/(t+_one16))
		}
		return h * (t + t/(t+_one16))
	}
	/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
	if ix < int32(0x40862E42) {
		return h * x_exp(tls, x_fabs(tls, x))
	}
	/* |x| in [log(maxdouble), overflowthresold] */
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	lx = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	if ix < int32(0x408633CE) || ix == int32(0x408633ce) && lx <= Uint32FromUint32(0x8fb9f87d) {
		w = x_exp(tls, float64(0.5)*x_fabs(tls, x))
		t = h * w
		return t * w
	}
	/* |x| > overflowthresold, sinh(x) overflow */
	return x * _shuge
}

var _one17 = float32(1)
var _shuge1 = float32(1e+37)

func x_sinhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var h, t, w float32
	var ix, jx int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	jx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = jx & int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7f800000) {
		return x + x
	}
	h = float32(0.5)
	if jx < 0 {
		h = -h
	}
	/* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
	if ix < int32(0x41b00000) {
		/* |x|<22 */
		if ix < int32(0x31800000) { /* |x|<2**-28 */
			if _shuge1+x > _one17 {
				return x
			}
		} /* sinh(tiny) = tiny with inexact */
		t = x_expm1f(tls, x_fabsf(tls, x))
		if ix < int32(0x3f800000) {
			return h * (Float32FromFloat64(2)*t - t*t/(t+_one17))
		}
		return h * (t + t/(t+_one17))
	}
	/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
	if ix < int32(0x42b17180) {
		return h * x_expf(tls, x_fabsf(tls, x))
	}
	/* |x| in [log(maxdouble), overflowthresold] */
	if ix <= int32(0x42b2d4fc) {
		w = x_expf(tls, Float32FromFloat64(0.5)*x_fabsf(tls, x))
		t = h * w
		return t * w
	}
	/* |x| > overflowthresold, sinh(x) overflow */
	return x * _shuge1
}

var _one18 = float64(1)                               /* 0x3FF00000, 0x00000000 */
var _C1 = float64(0.0416666666666666)                 /* 0x3FA55555, 0x5555554C */
var _C2 = -Float64FromFloat64(0.001388888888887411)   /* 0xBF56C16C, 0x16C15177 */
var _C3 = float64(2.480158728947673e-05)              /* 0x3EFA01A0, 0x19CB1590 */
var _C4 = -Float64FromFloat64(2.7557314351390663e-07) /* 0xBE927E4F, 0x809C52AD */
var _C5 = float64(2.087572321298175e-09)              /* 0x3E21EE9E, 0xBDB4B1C4 */
var _C6 = -Float64FromFloat64(1.1359647557788195e-11)

func x___kernel_cos(tls *TLS, x float64, y float64) (r1 float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var a, hz, qx, r, z float64
	var ix int32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* iw_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix &= int32(0x7fffffff) /* ix = |x|'s high word*/
	if ix < int32(0x3e400000) {
		/* if x < 2**27 */
		if int32(x) == 0 {
			return _one18
		} /* generate inexact */
	}
	z = x * x
	r = z * (_C1 + z*(_C2+z*(_C3+z*(_C4+z*(_C5+z*_C6)))))
	if ix < int32(0x3FD33333) { /* if |x| < 0.3 */
		return _one18 - (float64(0.5)*z - (z*r - x*y))
	} else {
		if ix > int32(0x3fe90000) { /* x > 0.78125 */
			qx = float64(0.28125)
		} else {
			*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(ix-Int32FromInt32(0x00200000))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
			qx = *(*float64)(unsafe.Pointer(bp + 8))
		}
		hz = float64(0.5)*z - qx
		a = _one18 - qx
		return a - (hz - (z*r - x*y))
	}
	return r1
}

var _one19 = float32(1)                                   /* 0x3f800000 */
var _C11 = float32(0.041666667908)                        /* 0x3d2aaaab */
var _C21 = float32(-Float64FromFloat64(0.0013888889225))  /* 0xbab60b61 */
var _C31 = float32(2.4801587642e-05)                      /* 0x37d00d01 */
var _C41 = float32(-Float64FromFloat64(2.7557314297e-07)) /* 0xb493f27c */
var _C51 = float32(2.0875723372e-09)                      /* 0x310f74f6 */
var _C61 = float32(-Float64FromFloat64(1.1359647598e-11))

func x___kernel_cosf(tls *TLS, x float32, y float32) (r1 float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var a, hz, qx, r, z float32
	var ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix &= int32(0x7fffffff) /* ix = |x|'s high word*/
	if ix < int32(0x32000000) {
		/* if x < 2**27 */
		if int32(x) == 0 {
			return _one19
		} /* generate inexact */
	}
	z = x * x
	r = z * (_C11 + z*(_C21+z*(_C31+z*(_C41+z*(_C51+z*_C61)))))
	if ix < int32(0x3e99999a) { /* if |x| < 0.3 */
		return _one19 - (Float32FromFloat64(0.5)*z - (z*r - x*y))
	} else {
		if ix > int32(0x3f480000) { /* x > 0.78125 */
			qx = Float32FromFloat64(0.28125)
		} else {
			*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(ix - Int32FromInt32(0x01000000))
			qx = *(*float32)(unsafe.Pointer(bp + 4))
		}
		hz = Float32FromFloat64(0.5)*z - qx
		a = _one19 - qx
		return a - (hz - (z*r - x*y))
	}
	return r1
}

var _init_jk = [4]int32{
	0: int32(2),
	1: int32(3),
	2: int32(4),
	3: int32(6)} /* initial value for jk */

var _PIo2 = [8]float64{
	0: float64(1.570796251296997),
	1: float64(7.549789415861596e-08),
	2: float64(5.390302529957765e-15),
	3: float64(3.282003415807913e-22),
	4: float64(1.270655753080676e-29),
	5: float64(1.2293330898111133e-36),
	6: float64(2.7337005381646456e-44),
	7: float64(2.1674168387780482e-51)}

var _zero14 = float64(0)
var _one20 = float64(1)
var _two242 = float64(1.6777216e+07) /* 0x41700000, 0x00000000 */
var _twon24 = float64(5.960464477539063e-08)

func x___kernel_rem_pio2(tls *TLS, x uintptr, y uintptr, e0 int32, nx int32, prec int32, ipio2 uintptr) (r int32) {
	bp := tls.Alloc(240) /* tlsAllocs 240 maxVaListSize 0 */
	defer tls.Free(240)
	var carry, i, ih, j, jk, jp, jv, jx, jz, k, m, n, q0 int32
	var f, q [20]float64
	var fw, z, v10, v11, v2, v9 float64
	var _ /* fq at bp+80 */ [20]float64
	var _ /* iq at bp+0 */ [20]int32
	/* initialize jk*/
	jk = _init_jk[prec]
	jp = jk
	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - int32(1)
	jv = (e0 - int32(3)) / int32(24)
	if jv < 0 {
		jv = 0
	}
	q0 = e0 - int32(24)*(jv+int32(1))
	/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv - jx
	m = jx + jk
	for i = 0; i <= m; {
		if j < 0 {
			v2 = _zero14
		} else {
			v2 = float64(*(*int32)(unsafe.Pointer(ipio2 + uintptr(j)*4)))
		}
		f[i] = v2
		goto _1
	_1:
		i++
		j++
	}
	/* compute q[0],q[1],...q[jk] */
	for i = 0; i <= jk; i++ {
		j = 0
		fw = Float64FromFloat64(0)
		for ; j <= jx; j++ {
			fw += *(*float64)(unsafe.Pointer(x + uintptr(j)*8)) * f[jx+i-j]
		}
		q[i] = fw
	}
	jz = jk
recompute:
	/* distill q[] into iq[] reversingly */
	i = 0
	j = jz
	z = q[jz]
	for j > 0 {
		fw = float64(int32(_twon24 * z))
		(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(z - _two242*fw)
		z = q[j-int32(1)] + fw
		goto _3
	_3:
		i++
		j--
	}
	/* compute n */
	z = x_scalbn(tls, z, q0)                         /* actual value of z */
	z -= float64(8) * x_floor(tls, z*float64(0.125)) /* trim off integer >= 8 */
	n = int32(z)
	z -= float64(n)
	ih = 0
	if q0 > 0 { /* need iq[jz-1] to determine n */
		i = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(24) - q0)
		n += i
		*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) -= i << (int32(24) - q0)
		ih = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(23) - q0)
	} else {
		if q0 == 0 {
			ih = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> int32(23)
		} else if z >= float64(0.5) {
			ih = int32(2)
		}
	}
	if ih > 0 {
		/* q > 0.5 */
		n += int32(1)
		carry = 0
		for i = 0; i < jz; i++ { /* compute 1-q */
			j = (*(*[20]int32)(unsafe.Pointer(bp)))[i]
			if carry == 0 {
				if j != 0 {
					carry = int32(1)
					(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(0x1000000) - j
				}
			} else {
				(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(0xffffff) - j
			}
		}
		if q0 > 0 {
			/* rare case: chance is 1 in 12 */
			switch q0 {
			case int32(1):
				*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x7fffff)
			case int32(2):
				*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x3fffff)
				break
			}
		}
		if ih == int32(2) {
			z = _one20 - z
			if carry != 0 {
				z -= x_scalbn(tls, _one20, q0)
			}
		}
	}
	/* check if recomputation is needed */
	if z == _zero14 {
		j = 0
		for i = jz - int32(1); i >= jk; i-- {
			j |= (*(*[20]int32)(unsafe.Pointer(bp)))[i]
		}
		if j == 0 {
			/* need recomputation */
			for k = int32(1); (*(*[20]int32)(unsafe.Pointer(bp)))[jk-k] == 0; k++ {
			} /* k = no. of terms needed */
			for i = jz + int32(1); i <= jz+k; i++ { /* add q[jz+1] to q[jz+k] */
				f[jx+i] = float64(*(*int32)(unsafe.Pointer(ipio2 + uintptr(jv+i)*4)))
				j = 0
				fw = Float64FromFloat64(0)
				for ; j <= jx; j++ {
					fw += *(*float64)(unsafe.Pointer(x + uintptr(j)*8)) * f[jx+i-j]
				}
				q[i] = fw
			}
			jz += k
			goto recompute
		}
	}
	/* chop off zero terms */
	if z == float64(0) {
		jz -= int32(1)
		q0 -= int32(24)
		for (*(*[20]int32)(unsafe.Pointer(bp)))[jz] == 0 {
			jz--
			q0 -= int32(24)
		}
	} else { /* break z into 24-bit if necessary */
		z = x_scalbn(tls, z, -q0)
		if z >= _two242 {
			fw = float64(int32(_twon24 * z))
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(z - _two242*fw)
			jz += int32(1)
			q0 += int32(24)
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(fw)
		} else {
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(z)
		}
	}
	/* convert integer "bit" chunk to floating-point value */
	fw = x_scalbn(tls, _one20, q0)
	for i = jz; i >= 0; i-- {
		q[i] = fw * float64((*(*[20]int32)(unsafe.Pointer(bp)))[i])
		fw *= _twon24
	}
	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	for i = jz; i >= 0; i-- {
		fw = float64(0)
		k = Int32FromInt32(0)
		for ; k <= jp && k <= jz-i; k++ {
			fw += _PIo2[k] * q[i+k]
		}
		(*(*[20]float64)(unsafe.Pointer(bp + 80)))[jz-i] = fw
	}
	/* compress fq[] into y[] */
	switch prec {
	case 0:
		goto _4
	case int32(2):
		goto _5
	case int32(1):
		goto _6
	case int32(3):
		goto _7
	}
	goto _8
_4:
	fw = float64(0)
	for i = jz; i >= 0; i-- {
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v9 = fw
	} else {
		v9 = -fw
	}
	*(*float64)(unsafe.Pointer(y)) = v9
	goto _8
_6:
_5:
	fw = float64(0)
	for i = jz; i >= 0; i-- {
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v10 = fw
	} else {
		v10 = -fw
	}
	*(*float64)(unsafe.Pointer(y)) = v10
	fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[0] - fw
	for i = int32(1); i <= jz; i++ {
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v11 = fw
	} else {
		v11 = -fw
	}
	*(*float64)(unsafe.Pointer(y + 1*8)) = v11
	goto _8
_7: /* painful */
	i = jz
_14:
	if !(i > 0) {
		goto _12
	}
	fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	*(*float64)(unsafe.Pointer(bp + 80 + uintptr(i)*8)) += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
	(*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
	goto _13
_13:
	i--
	goto _14
	goto _12
_12:
	for i = jz; i > int32(1); i-- {
		fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		*(*float64)(unsafe.Pointer(bp + 80 + uintptr(i)*8)) += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
		(*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
	}
	fw = float64(0)
	i = jz
	for ; i >= int32(2); i-- {
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		*(*float64)(unsafe.Pointer(y)) = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[0]
		*(*float64)(unsafe.Pointer(y + 1*8)) = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float64)(unsafe.Pointer(y + 2*8)) = fw
	} else {
		*(*float64)(unsafe.Pointer(y)) = -(*(*[20]float64)(unsafe.Pointer(bp + 80)))[0]
		*(*float64)(unsafe.Pointer(y + 1*8)) = -(*(*[20]float64)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float64)(unsafe.Pointer(y + 2*8)) = -fw
	}
_8:
	return n & int32(7)
}

/* In the float version, the input parameter x contains 8 bit
   integers, not 24 bit integers.  113 bit precision is not supported.  */

var _init_jk1 = [3]int32{
	0: int32(4),
	1: int32(7),
	2: int32(9)} /* initial value for jk */

var _PIo21 = [11]float32{
	0:  float32(1.5703125),
	1:  float32(0.00045776367188),
	2:  float32(2.5987625122e-05),
	3:  float32(7.5437128544e-08),
	4:  float32(6.0026650317e-11),
	5:  float32(7.3896444519e-13),
	6:  float32(5.3845816694e-15),
	7:  float32(5.6378512969e-18),
	8:  float32(8.3009228831e-20),
	9:  float32(3.2756352257e-22),
	10: float32(6.3331015649e-25)}

var _zero15 = float32(0)
var _one21 = float32(1)
var _two81 = float32(256) /* 0x43800000 */
var _twon8 = float32(0.00390625)

func x___kernel_rem_pio2f(tls *TLS, x uintptr, y uintptr, e0 int32, nx int32, prec int32, ipio2 uintptr) (r int32) {
	bp := tls.Alloc(160) /* tlsAllocs 160 maxVaListSize 0 */
	defer tls.Free(160)
	var carry, i, ih, j, jk, jp, jv, jx, jz, k, m, n, q0 int32
	var f, q [20]float32
	var fw, z, v10, v11, v2, v9 float32
	var _ /* fq at bp+80 */ [20]float32
	var _ /* iq at bp+0 */ [20]int32
	/* initialize jk*/
	jk = _init_jk1[prec]
	jp = jk
	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - int32(1)
	jv = (e0 - int32(3)) / int32(8)
	if jv < 0 {
		jv = 0
	}
	q0 = e0 - int32(8)*(jv+int32(1))
	/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv - jx
	m = jx + jk
	for i = 0; i <= m; {
		if j < 0 {
			v2 = _zero15
		} else {
			v2 = float32(*(*int32)(unsafe.Pointer(ipio2 + uintptr(j)*4)))
		}
		f[i] = v2
		goto _1
	_1:
		i++
		j++
	}
	/* compute q[0],q[1],...q[jk] */
	for i = 0; i <= jk; i++ {
		j = 0
		fw = Float32FromFloat64(0)
		for ; j <= jx; j++ {
			fw += *(*float32)(unsafe.Pointer(x + uintptr(j)*4)) * f[jx+i-j]
		}
		q[i] = fw
	}
	jz = jk
recompute:
	/* distill q[] into iq[] reversingly */
	i = 0
	j = jz
	z = q[jz]
	for j > 0 {
		fw = float32(int32(_twon8 * z))
		(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(z - _two81*fw)
		z = q[j-int32(1)] + fw
		goto _3
	_3:
		i++
		j--
	}
	/* compute n */
	z = x_scalbnf(tls, z, q0)                                               /* actual value of z */
	z -= Float32FromFloat64(8) * x_floorf(tls, z*Float32FromFloat64(0.125)) /* trim off integer >= 8 */
	n = int32(z)
	z -= float32(n)
	ih = 0
	if q0 > 0 { /* need iq[jz-1] to determine n */
		i = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(8) - q0)
		n += i
		*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) -= i << (int32(8) - q0)
		ih = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(7) - q0)
	} else {
		if q0 == 0 {
			ih = (*(*[20]int32)(unsafe.Pointer(bp)))[jz-int32(1)] >> int32(7)
		} else if z >= Float32FromFloat64(0.5) {
			ih = int32(2)
		}
	}
	if ih > 0 {
		/* q > 0.5 */
		n += int32(1)
		carry = 0
		for i = 0; i < jz; i++ { /* compute 1-q */
			j = (*(*[20]int32)(unsafe.Pointer(bp)))[i]
			if carry == 0 {
				if j != 0 {
					carry = int32(1)
					(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(0x100) - j
				}
			} else {
				(*(*[20]int32)(unsafe.Pointer(bp)))[i] = int32(0xff) - j
			}
		}
		if q0 > 0 {
			/* rare case: chance is 1 in 12 */
			switch q0 {
			case int32(1):
				*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x7f)
			case int32(2):
				*(*int32)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x3f)
				break
			}
		}
		if ih == int32(2) {
			z = _one21 - z
			if carry != 0 {
				z -= x_scalbnf(tls, _one21, q0)
			}
		}
	}
	/* check if recomputation is needed */
	if z == _zero15 {
		j = 0
		for i = jz - int32(1); i >= jk; i-- {
			j |= (*(*[20]int32)(unsafe.Pointer(bp)))[i]
		}
		if j == 0 {
			/* need recomputation */
			for k = int32(1); (*(*[20]int32)(unsafe.Pointer(bp)))[jk-k] == 0; k++ {
			} /* k = no. of terms needed */
			for i = jz + int32(1); i <= jz+k; i++ { /* add q[jz+1] to q[jz+k] */
				f[jx+i] = float32(*(*int32)(unsafe.Pointer(ipio2 + uintptr(jv+i)*4)))
				j = 0
				fw = Float32FromFloat64(0)
				for ; j <= jx; j++ {
					fw += *(*float32)(unsafe.Pointer(x + uintptr(j)*4)) * f[jx+i-j]
				}
				q[i] = fw
			}
			jz += k
			goto recompute
		}
	}
	/* chop off zero terms */
	if z == Float32FromFloat64(0) {
		jz -= int32(1)
		q0 -= int32(8)
		for (*(*[20]int32)(unsafe.Pointer(bp)))[jz] == 0 {
			jz--
			q0 -= int32(8)
		}
	} else { /* break z into 8-bit if necessary */
		z = x_scalbnf(tls, z, -q0)
		if z >= _two81 {
			fw = float32(int32(_twon8 * z))
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(z - _two81*fw)
			jz += int32(1)
			q0 += int32(8)
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(fw)
		} else {
			(*(*[20]int32)(unsafe.Pointer(bp)))[jz] = int32(z)
		}
	}
	/* convert integer "bit" chunk to floating-point value */
	fw = x_scalbnf(tls, _one21, q0)
	for i = jz; i >= 0; i-- {
		q[i] = fw * float32((*(*[20]int32)(unsafe.Pointer(bp)))[i])
		fw *= _twon8
	}
	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	for i = jz; i >= 0; i-- {
		fw = float32(0)
		k = Int32FromInt32(0)
		for ; k <= jp && k <= jz-i; k++ {
			fw += _PIo21[k] * q[i+k]
		}
		(*(*[20]float32)(unsafe.Pointer(bp + 80)))[jz-i] = fw
	}
	/* compress fq[] into y[] */
	switch prec {
	case 0:
		goto _4
	case int32(2):
		goto _5
	case int32(1):
		goto _6
	case int32(3):
		goto _7
	}
	goto _8
_4:
	fw = float32(0)
	for i = jz; i >= 0; i-- {
		fw += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v9 = fw
	} else {
		v9 = -fw
	}
	*(*float32)(unsafe.Pointer(y)) = v9
	goto _8
_6:
_5:
	fw = float32(0)
	for i = jz; i >= 0; i-- {
		fw += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v10 = fw
	} else {
		v10 = -fw
	}
	*(*float32)(unsafe.Pointer(y)) = v10
	fw = (*(*[20]float32)(unsafe.Pointer(bp + 80)))[0] - fw
	for i = int32(1); i <= jz; i++ {
		fw += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		v11 = fw
	} else {
		v11 = -fw
	}
	*(*float32)(unsafe.Pointer(y + 1*4)) = v11
	goto _8
_7: /* painful */
	i = jz
_14:
	if !(i > 0) {
		goto _12
	}
	fw = (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
	*(*float32)(unsafe.Pointer(bp + 80 + uintptr(i)*4)) += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
	(*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
	goto _13
_13:
	i--
	goto _14
	goto _12
_12:
	for i = jz; i > int32(1); i-- {
		fw = (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
		*(*float32)(unsafe.Pointer(bp + 80 + uintptr(i)*4)) += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
		(*(*[20]float32)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
	}
	fw = float32(0)
	i = jz
	for ; i >= int32(2); i-- {
		fw += (*(*[20]float32)(unsafe.Pointer(bp + 80)))[i]
	}
	if ih == 0 {
		*(*float32)(unsafe.Pointer(y)) = (*(*[20]float32)(unsafe.Pointer(bp + 80)))[0]
		*(*float32)(unsafe.Pointer(y + 1*4)) = (*(*[20]float32)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float32)(unsafe.Pointer(y + 2*4)) = fw
	} else {
		*(*float32)(unsafe.Pointer(y)) = -(*(*[20]float32)(unsafe.Pointer(bp + 80)))[0]
		*(*float32)(unsafe.Pointer(y + 1*4)) = -(*(*[20]float32)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float32)(unsafe.Pointer(y + 2*4)) = -fw
	}
_8:
	return n & int32(7)
}

var _half4 = float64(0.5)                             /* 0x3FE00000, 0x00000000 */
var _S1 = -Float64FromFloat64(0.16666666666666632)    /* 0xBFC55555, 0x55555549 */
var _S2 = float64(0.00833333333332249)                /* 0x3F811111, 0x1110F8A6 */
var _S3 = -Float64FromFloat64(0.0001984126982985795)  /* 0xBF2A01A0, 0x19C161D5 */
var _S4 = float64(2.7557313707070068e-06)             /* 0x3EC71DE3, 0x57B1FE7D */
var _S5 = -Float64FromFloat64(2.5050760253406863e-08) /* 0xBE5AE5E6, 0x8A2B9CEB */
var _S6 = float64(1.58969099521155e-10)

func x___kernel_sin(tls *TLS, x float64, y float64, iy int32) (r1 float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix int32
	var r, v, z float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix &= int32(0x7fffffff) /* high word of x */
	if ix < int32(0x3e400000) {
		/* |x| < 2**-27 */
		if int32(x) == 0 {
			return x
		}
	} /* generate inexact */
	z = x * x
	v = z * x
	r = _S2 + z*(_S3+z*(_S4+z*(_S5+z*_S6)))
	if iy == 0 {
		return x + v*(_S1+z*r)
	} else {
		return x - (z*(_half4*y-v*r) - y - v*_S1)
	}
	return r1
}

var _half5 = float32(0.5)                                 /* 0x3f000000 */
var _S11 = float32(-Float64FromFloat64(0.16666667163))    /* 0xbe2aaaab */
var _S21 = float32(0.008333333768)                        /* 0x3c088889 */
var _S31 = float32(-Float64FromFloat64(0.00019841270114)) /* 0xb9500d01 */
var _S41 = float32(2.7557314297e-06)                      /* 0x3638ef1b */
var _S51 = float32(-Float64FromFloat64(2.5050759689e-08)) /* 0xb2d72f34 */
var _S61 = float32(1.5896910177e-10)

func x___kernel_sinf(tls *TLS, x float32, y float32, iy int32) (r1 float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix int32
	var r, v, z float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix &= int32(0x7fffffff) /* high word of x */
	if ix < int32(0x32000000) {
		/* |x| < 2**-27 */
		if int32(x) == 0 {
			return x
		}
	} /* generate inexact */
	z = x * x
	v = z * x
	r = _S21 + z*(_S31+z*(_S41+z*(_S51+z*_S61)))
	if iy == 0 {
		return x + v*(_S11+z*r)
	} else {
		return x - (z*(_half5*y-v*r) - y - v*_S11)
	}
	return r1
}

var _xxx = [16]float64{
	0:  float64(0.3333333333333341),
	1:  float64(0.13333333333320124),
	2:  float64(0.05396825397622605),
	3:  float64(0.021869488294859542),
	4:  float64(0.0088632398235993),
	5:  float64(0.0035920791075913124),
	6:  float64(0.0014562094543252903),
	7:  float64(0.0005880412408202641),
	8:  float64(0.0002464631348184699),
	9:  float64(7.817944429395571e-05),
	10: float64(7.140724913826082e-05),
	11: -Float64FromFloat64(1.8558637485527546e-05),
	12: float64(2.590730518636337e-05),
	13: float64(1),
	14: float64(0.7853981633974483),
	15: float64(3.061616997868383e-17)}

func x___kernel_tan(tls *TLS, x float64, y float64, iy int32) (r1 float64) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxVaListSize 0 */
	defer tls.Free(48)
	var a, a1, r, s, t, t1, v, w, z, v1, v3, v6 float64
	var hx, ix int32
	var low uint32
	var p2, p4, p5, p7 uintptr
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* sl_u at bp+16 */ Tieee_double_shape_type
	var _ /* sl_u at bp+24 */ Tieee_double_shape_type
	var _ /* sl_u at bp+32 */ Tieee_double_shape_type
	var _ /* sl_u at bp+40 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff) /* high word of |x| */
	if ix < int32(0x3e300000) {
		/* x < 2**-28 */
		if int32(x) == 0 {
			/* generate inexact */
			*(*float64)(unsafe.Pointer(bp + 8)) = x
			low = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
			if uint32(ix)|low|uint32(iy+Int32FromInt32(1)) == uint32(0) {
				return _xxx[int32(13)] / x_fabs(tls, x)
			} else {
				if iy == int32(1) {
					return x
				} else { /* compute -1 / (x+y) carefully */
					v1 = x + y
					w = v1
					z = v1
					*(*float64)(unsafe.Pointer(bp + 16)) = z
					p2 = bp + 16
					*(*uint64)(unsafe.Pointer(p2)) = *(*uint64)(unsafe.Pointer(p2)) & Uint64FromUint64(0xffffffff00000000)
					*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(uint32(Int32FromInt32(0)))
					z = *(*float64)(unsafe.Pointer(bp + 16))
					v = y - (z - x)
					v3 = -_xxx[int32(13)] / w
					a = v3
					t = v3
					*(*float64)(unsafe.Pointer(bp + 24)) = t
					p4 = bp + 24
					*(*uint64)(unsafe.Pointer(p4)) = *(*uint64)(unsafe.Pointer(p4)) & Uint64FromUint64(0xffffffff00000000)
					*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(uint32(Int32FromInt32(0)))
					t = *(*float64)(unsafe.Pointer(bp + 24))
					s = _xxx[int32(13)] + t*z
					return t + a*(s+t*v)
				}
			}
		}
	}
	if ix >= int32(0x3FE59428) {
		/* |x| >= 0.6744 */
		if hx < 0 {
			x = -x
			y = -y
		}
		z = _xxx[int32(14)] - x
		w = _xxx[int32(15)] - y
		x = z + w
		y = float64(0)
	}
	z = x * x
	w = z * z
	/*
	 * Break x^5*(T[1]+x^2*T[2]+...) into
	 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = _xxx[int32(1)] + w*(_xxx[int32(3)]+w*(_xxx[int32(5)]+w*(_xxx[int32(7)]+w*(_xxx[int32(9)]+w*_xxx[int32(11)]))))
	v = z * (_xxx[int32(2)] + w*(_xxx[int32(4)]+w*(_xxx[int32(6)]+w*(_xxx[int32(8)]+w*(_xxx[int32(10)]+w*_xxx[int32(12)])))))
	s = z * x
	r = y + z*(s*(r+v)+y)
	r += _xxx[0] * s
	w = x + r
	if ix >= int32(0x3FE59428) {
		v = float64(iy)
		return float64(Int32FromInt32(1)-hx>>Int32FromInt32(30)&Int32FromInt32(2)) * (v - float64(2)*(x-(w*w/(w+v)-r)))
	}
	if iy == int32(1) {
		return w
	} else {
		/*
		 * if allow error up to 2 ulp, simply return
		 * -1.0 / (x+r) here
		 */
		/* compute -1.0 / (x+r) accurately */
		z = w
		*(*float64)(unsafe.Pointer(bp + 32)) = z
		p5 = bp + 32
		*(*uint64)(unsafe.Pointer(p5)) = *(*uint64)(unsafe.Pointer(p5)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 32)) |= uint64(uint32(Int32FromInt32(0)))
		z = *(*float64)(unsafe.Pointer(bp + 32))
		v = r - (z - x) /* z+v = r+x */
		v6 = -Float64FromFloat64(1) / w
		a1 = v6
		t1 = v6 /* a = -1.0/w */
		*(*float64)(unsafe.Pointer(bp + 40)) = t1
		p7 = bp + 40
		*(*uint64)(unsafe.Pointer(p7)) = *(*uint64)(unsafe.Pointer(p7)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 40)) |= uint64(uint32(Int32FromInt32(0)))
		t1 = *(*float64)(unsafe.Pointer(bp + 40))
		s = float64(1) + t1*z
		return t1 + a1*(s+t1*v)
	}
	return r1
}

var _one22 = float32(1)                 /* 0x3f800000 */
var _pio4 = float32(0.78539812565)      /* 0x3f490fda */
var _pio4lo = float32(3.7748947079e-08) /* 0x33222168 */
var _T = [13]float32{
	0:  float32(0.33333334327),
	1:  float32(0.13333334029),
	2:  float32(0.053968254477),
	3:  float32(0.02186948806),
	4:  float32(0.0088632395491),
	5:  float32(0.0035920790397),
	6:  float32(0.0014562094584),
	7:  float32(0.00058804126456),
	8:  float32(0.00024646313977),
	9:  float32(7.8179444245e-05),
	10: float32(7.1407252108e-05),
	11: float32(-Float64FromFloat64(1.8558637748e-05)),
	12: float32(2.5907305826e-05)}

func x___kernel_tanf(tls *TLS, x float32, y float32, iy int32) (r1 float32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var a, t, v2 float64
	var a1, r, s, t1, v, w, z, v1, v3 float32
	var hx, i, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+12 */ Tieee_float_shape_type
	var _ /* gf_u at bp+20 */ Tieee_float_shape_type
	var _ /* gf_u at bp+28 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+24 */ Tieee_float_shape_type
	var _ /* sf_u at bp+32 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff) /* high word of |x| */
	if ix < int32(0x31800000) {
		/* x < 2**-28 */
		if int32(x) == 0 {
			/* generate inexact */
			if ix|(iy+int32(1)) == 0 {
				return _one22 / x_fabsf(tls, x)
			} else {
				if iy == int32(1) {
					return x
				} else { /* compute -1 / (x+y) carefully */
					v1 = x + y
					w = v1
					z = v1
					*(*float32)(unsafe.Pointer(bp + 4)) = z
					ix = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
					*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ix) & Uint32FromUint32(0xfffff000)
					z = *(*float32)(unsafe.Pointer(bp + 8))
					v = y - (z - x)
					v2 = float64(-_one22 / w)
					a = v2
					t = v2
					*(*float32)(unsafe.Pointer(bp + 12)) = float32(t)
					ix = int32(*(*uint32)(unsafe.Pointer(bp + 12)))
					*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(ix) & Uint32FromUint32(0xfffff000)
					t = float64(*(*float32)(unsafe.Pointer(bp + 16)))
					s = float32(float64(_one22) + t*float64(z))
					return float32(t + a*(float64(s)+t*float64(v)))
				}
			}
		}
	}
	if ix >= int32(0x3f2ca140) {
		/* |x|>=0.6744 */
		if hx < 0 {
			x = -x
			y = -y
		}
		z = _pio4 - x
		w = _pio4lo - y
		x = z + w
		y = float32(0)
	}
	z = x * x
	w = z * z
	/* Break x^5*(T[1]+x^2*T[2]+...) into
	 *    x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 *    x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = _T[int32(1)] + w*(_T[int32(3)]+w*(_T[int32(5)]+w*(_T[int32(7)]+w*(_T[int32(9)]+w*_T[int32(11)]))))
	v = z * (_T[int32(2)] + w*(_T[int32(4)]+w*(_T[int32(6)]+w*(_T[int32(8)]+w*(_T[int32(10)]+w*_T[int32(12)])))))
	s = z * x
	r = y + z*(s*(r+v)+y)
	r += _T[0] * s
	w = x + r
	if ix >= int32(0x3f2ca140) {
		v = float32(iy)
		return float32(Int32FromInt32(1)-hx>>Int32FromInt32(30)&Int32FromInt32(2)) * (v - Float32FromFloat64(2)*(x-(w*w/(w+v)-r)))
	}
	if iy == int32(1) {
		return w
	} else { /* if allow error up to 2 ulp,
		   simply return -1.0/(x+r) here */
		/*  compute -1.0/(x+r) accurately */
		z = w
		*(*float32)(unsafe.Pointer(bp + 20)) = z
		i = int32(*(*uint32)(unsafe.Pointer(bp + 20)))
		*(*uint32)(unsafe.Pointer(bp + 24)) = uint32(i) & Uint32FromUint32(0xfffff000)
		z = *(*float32)(unsafe.Pointer(bp + 24))
		v = r - (z - x) /* z+v = r+x */
		v3 = -Float32FromFloat64(1) / w
		a1 = v3
		t1 = v3 /* a = -1.0/w */
		*(*float32)(unsafe.Pointer(bp + 28)) = t1
		i = int32(*(*uint32)(unsafe.Pointer(bp + 28)))
		*(*uint32)(unsafe.Pointer(bp + 32)) = uint32(i) & Uint32FromUint32(0xfffff000)
		t1 = *(*float32)(unsafe.Pointer(bp + 32))
		s = Float32FromFloat64(1) + t1*z
		return t1 + a1*(s+t1*v)
	}
	return r1
}

var _one23 = float64(1)                 /* 0x3FF00000, 0x00000000 */
var _ln22 = float64(0.6931471805599453) /* 0x3FE62E42, 0xFEFA39EF */
var _huge10 = float64(1e+300)

func x_asinh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, ix int32
	var t, w float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7ff00000) {
		return x + x
	} /* x is inf or NaN */
	if ix < int32(0x3e300000) {
		/* |x|<2**-28 */
		if _huge10+x > _one23 {
			return x
		} /* return x inexact except 0 */
	}
	if ix > int32(0x41b00000) { /* |x| > 2**28 */
		w = x_log(tls, x_fabs(tls, x)) + _ln22
	} else {
		if ix > int32(0x40000000) { /* 2**28 > |x| > 2.0 */
			t = x_fabs(tls, x)
			w = x_log(tls, float64(2)*t+_one23/(_sqrt(tls, x*x+_one23)+t))
		} else { /* 2.0 > |x| > 2**-28 */
			t = x * x
			w = x_log1p(tls, x_fabs(tls, x)+t/(_one23+_sqrt(tls, _one23+t)))
		}
	}
	if hx > 0 {
		return w
	} else {
		return -w
	}
	return r
}

var _one24 = float32(1)            /* 0x3F800000 */
var _ln23 = float32(0.69314718246) /* 0x3f317218 */
var _huge11 = float32(1e+30)

func x_asinhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, ix int32
	var t, w float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7f800000) {
		return x + x
	} /* x is inf or NaN */
	if ix < int32(0x31800000) {
		/* |x|<2**-28 */
		if _huge11+x > _one24 {
			return x
		} /* return x inexact except 0 */
	}
	if ix > int32(0x4d800000) { /* |x| > 2**28 */
		w = x_logf(tls, x_fabsf(tls, x)) + _ln23
	} else {
		if ix > int32(0x40000000) { /* 2**28 > |x| > 2.0 */
			t = x_fabsf(tls, x)
			w = x_logf(tls, Float32FromFloat64(2)*t+_one24/(_sqrtf(tls, x*x+_one24)+t))
		} else { /* 2.0 > |x| > 2**-28 */
			t = x * x
			w = x_log1pf(tls, x_fabsf(tls, x)+t/(_one24+_sqrtf(tls, _one24+t)))
		}
	}
	if hx > 0 {
		return w
	} else {
		return -w
	}
	return r
}

var _atanhi = [4]float64{
	0: float64(0.4636476090008061),
	1: float64(0.7853981633974483),
	2: float64(0.982793723247329),
	3: float64(1.5707963267948966)}

var _atanlo = [4]float64{
	0: float64(2.2698777452961687e-17),
	1: float64(3.061616997868383e-17),
	2: float64(1.3903311031230998e-17),
	3: float64(6.123233995736766e-17)}

var _aT = [11]float64{
	0:  float64(0.3333333333333293),
	1:  -Float64FromFloat64(0.19999999999876483),
	2:  float64(0.14285714272503466),
	3:  -Float64FromFloat64(0.11111110405462356),
	4:  float64(0.09090887133436507),
	5:  -Float64FromFloat64(0.0769187620504483),
	6:  float64(0.06661073137387531),
	7:  -Float64FromFloat64(0.058335701337905735),
	8:  float64(0.049768779946159324),
	9:  -Float64FromFloat64(0.036531572744216916),
	10: float64(0.016285820115365782)}

var _one25 = float64(1)
var _huge12 = float64(1e+300)

func x_atan(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var hx, id, ix int32
	var low uint32
	var s1, s2, w, z, v1 float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x44100000) {
		/* if |x| >= 2^66 */
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		low = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
		if ix > int32(0x7ff00000) || ix == int32(0x7ff00000) && low != uint32(0) {
			return x + x
		} /* NaN */
		if hx > 0 {
			return _atanhi[int32(3)] + _atanlo[int32(3)]
		} else {
			return -_atanhi[int32(3)] - _atanlo[int32(3)]
		}
	}
	if ix < int32(0x3fdc0000) { /* |x| < 0.4375 */
		if ix < int32(0x3e200000) {
			/* |x| < 2^-29 */
			if _huge12+x > _one25 {
				return x
			} /* raise inexact */
		}
		id = -int32(1)
	} else {
		x = x_fabs(tls, x)
		if ix < int32(0x3ff30000) { /* |x| < 1.1875 */
			if ix < int32(0x3fe60000) { /* 7/16 <=|x|<11/16 */
				id = 0
				x = (float64(2)*x - _one25) / (float64(2) + x)
			} else { /* 11/16<=|x|< 19/16 */
				id = int32(1)
				x = (x - _one25) / (x + _one25)
			}
		} else {
			if ix < int32(0x40038000) { /* |x| < 2.4375 */
				id = int32(2)
				x = (x - float64(1.5)) / (_one25 + float64(1.5)*x)
			} else { /* 2.4375 <= |x| < 2^66 */
				id = int32(3)
				x = -Float64FromFloat64(1) / x
			}
		}
	}
	/* end of argument reduction */
	z = x * x
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT[0] + w*(_aT[int32(2)]+w*(_aT[int32(4)]+w*(_aT[int32(6)]+w*(_aT[int32(8)]+w*_aT[int32(10)])))))
	s2 = w * (_aT[int32(1)] + w*(_aT[int32(3)]+w*(_aT[int32(5)]+w*(_aT[int32(7)]+w*_aT[int32(9)]))))
	if id < 0 {
		return x - x*(s1+s2)
	} else {
		z = _atanhi[id] - (x*(s1+s2) - _atanlo[id] - x)
		if hx < 0 {
			v1 = -z
		} else {
			v1 = z
		}
		return v1
	}
	return r
}

var _atanhi1 = [4]float32{
	0: float32(0.46364760399),
	1: float32(0.78539812565),
	2: float32(0.98279368877),
	3: float32(1.5707962513)}

var _atanlo1 = [4]float32{
	0: float32(5.012158244e-09),
	1: float32(3.7748947079e-08),
	2: float32(3.447321717e-08),
	3: float32(7.5497894159e-08)}

var _aT1 = [11]float32{
	0:  float32(0.33333334327),
	1:  float32(-Float64FromFloat64(0.20000000298)),
	2:  float32(0.14285714924),
	3:  float32(-Float64FromFloat64(0.11111110449)),
	4:  float32(0.090908870101),
	5:  float32(-Float64FromFloat64(0.076918758452)),
	6:  float32(0.066610731184),
	7:  float32(-Float64FromFloat64(0.058335702866)),
	8:  float32(0.049768779427),
	9:  float32(-Float64FromFloat64(0.036531571299)),
	10: float32(0.016285819933)}

var _one26 = float32(1)
var _huge13 = float32(1e+30)

func x_atanf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, id, ix int32
	var s1, s2, w, z, v1 float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x50800000) {
		/* if |x| >= 2^34 */
		if ix > int32(0x7f800000) {
			return x + x
		} /* NaN */
		if hx > 0 {
			return _atanhi1[int32(3)] + _atanlo1[int32(3)]
		} else {
			return -_atanhi1[int32(3)] - _atanlo1[int32(3)]
		}
	}
	if ix < int32(0x3ee00000) { /* |x| < 0.4375 */
		if ix < int32(0x31000000) {
			/* |x| < 2^-29 */
			if _huge13+x > _one26 {
				return x
			} /* raise inexact */
		}
		id = -int32(1)
	} else {
		x = x_fabsf(tls, x)
		if ix < int32(0x3f980000) { /* |x| < 1.1875 */
			if ix < int32(0x3f300000) { /* 7/16 <=|x|<11/16 */
				id = 0
				x = (Float32FromFloat64(2)*x - _one26) / (Float32FromFloat64(2) + x)
			} else { /* 11/16<=|x|< 19/16 */
				id = int32(1)
				x = (x - _one26) / (x + _one26)
			}
		} else {
			if ix < int32(0x401c0000) { /* |x| < 2.4375 */
				id = int32(2)
				x = (x - Float32FromFloat64(1.5)) / (_one26 + Float32FromFloat64(1.5)*x)
			} else { /* 2.4375 <= |x| < 2^66 */
				id = int32(3)
				x = -Float32FromFloat64(1) / x
			}
		}
	}
	/* end of argument reduction */
	z = x * x
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT1[0] + w*(_aT1[int32(2)]+w*(_aT1[int32(4)]+w*(_aT1[int32(6)]+w*(_aT1[int32(8)]+w*_aT1[int32(10)])))))
	s2 = w * (_aT1[int32(1)] + w*(_aT1[int32(3)]+w*(_aT1[int32(5)]+w*(_aT1[int32(7)]+w*_aT1[int32(9)]))))
	if id < 0 {
		return x - x*(s1+s2)
	} else {
		z = _atanhi1[id] - (x*(s1+s2) - _atanlo1[id] - x)
		if hx < 0 {
			v1 = -z
		} else {
			v1 = z
		}
		return v1
	}
	return r
}

/* cbrt(x)
 * Return cube root of x
 */

var _B1 = uint32(715094163) /* B1 = (682-0.03306235651)*2**20 */
var _B2 = uint32(696219795) /* B2 = (664-0.03306235651)*2**20 */

var _C = float64(0.5428571428571428)             /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
var _D = -Float64FromFloat64(0.7053061224489796) /* -864/1225 = 0xBFE691DE, 0x2532C834 */
var _E = float64(1.4142857142857144)             /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
var _F = float64(1.6071428571428572)             /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
var _G = float64(0.35714285714285715)

func x_cbrt(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(88) /* tlsAllocs 88 maxVaListSize 0 */
	defer tls.Free(88)
	var high, low, sign uint32
	var hx int32
	var r, s, t, w float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+32 */ Tieee_double_shape_type
	var _ /* gh_u at bp+56 */ Tieee_double_shape_type
	var _ /* gh_u at bp+72 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* iw_u at bp+64 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+40 */ Tieee_double_shape_type
	var _ /* sh_u at bp+48 */ Tieee_double_shape_type
	var _ /* sh_u at bp+80 */ Tieee_double_shape_type
	t = float64(0)
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	sign = uint32(hx) & uint32(0x80000000) /* sign= sign(x) */
	hx = int32(uint32(hx) ^ sign)
	if hx >= int32(0x7ff00000) {
		return x + x
	} /* cbrt(NaN,INF) is itself */
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	low = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	if uint32(hx)|low == uint32(0) {
		return x
	} /* cbrt(0) is itself */
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(hx) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 16)) /* x <- |x| */
	/* rough cbrt to 5 bits */
	if hx < int32(0x00100000) {
		*(*float64)(unsafe.Pointer(bp + 24)) = t
		*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(Int32FromInt32(0x43500000)) << Int32FromInt32(32)
		t = *(*float64)(unsafe.Pointer(bp + 24)) /* set t= 2**54 */
		t *= x
		*(*float64)(unsafe.Pointer(bp + 32)) = t
		high = uint32(*(*uint64)(unsafe.Pointer(bp + 32)) >> int32(32))
		*(*float64)(unsafe.Pointer(bp + 40)) = t
		*(*uint64)(unsafe.Pointer(bp + 40)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 40)) |= uint64(high/Uint32FromInt32(3)+_B2) << Int32FromInt32(32)
		t = *(*float64)(unsafe.Pointer(bp + 40))
	} else {
		*(*float64)(unsafe.Pointer(bp + 48)) = t
		*(*uint64)(unsafe.Pointer(bp + 48)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 48)) |= uint64(uint32(hx/Int32FromInt32(3))+_B1) << Int32FromInt32(32)
		t = *(*float64)(unsafe.Pointer(bp + 48))
	}
	/* new cbrt to 23 bits, may be implemented in single precision */
	r = t * t / x
	s = _C + r*t
	t *= _G + _F/(s+_E+_D/s)
	/* chopped to 20 bits and make it larger than cbrt(x) */
	*(*float64)(unsafe.Pointer(bp + 56)) = t
	high = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> int32(32))
	*(*uint64)(unsafe.Pointer(bp + 64)) = uint64(high+Uint32FromInt32(0x00000001))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
	t = *(*float64)(unsafe.Pointer(bp + 64))
	/* one step newton iteration to 53 bits with error less than 0.667 ulps */
	s = t * t /* t*t is exact */
	r = x / s
	w = t + t
	r = (r - t) / (w + r) /* r-s is exact */
	t = t + t*r
	/* retore the sign bit */
	*(*float64)(unsafe.Pointer(bp + 72)) = t
	high = uint32(*(*uint64)(unsafe.Pointer(bp + 72)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 80)) = t
	*(*uint64)(unsafe.Pointer(bp + 80)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 80)) |= uint64(high|sign) << Int32FromInt32(32)
	t = *(*float64)(unsafe.Pointer(bp + 80))
	return t
}

/* cbrtf(x)
 * Return cube root of x
 */

var _B11 = uint32(709958130) /* B1 = (84+2/3-0.03306235651)*2**23 */
var _B21 = uint32(642849266) /* B2 = (76+2/3-0.03306235651)*2**23 */

var _C7 = float32(0.5428571701)                       /* 19/35     = 0x3f0af8b0 */
var _D1 = float32(-Float64FromFloat64(0.70530611277)) /* -864/1225 = 0xbf348ef1 */
var _E1 = float32(1.4142856598)                       /* 99/70     = 0x3fb50750 */
var _F1 = float32(1.6071428061)                       /* 45/28     = 0x3fcdb6db */
var _G1 = float32(0.35714286566)

func x_cbrtf(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var high, sign uint32
	var hx int32
	var r, s, t float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+12 */ Tieee_float_shape_type
	var _ /* gf_u at bp+24 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+20 */ Tieee_float_shape_type
	var _ /* sf_u at bp+28 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	sign = uint32(hx) & uint32(0x80000000) /* sign= sign(x) */
	hx = int32(uint32(hx) ^ sign)
	if hx >= int32(0x7f800000) {
		return x + x
	} /* cbrt(NaN,INF) is itself */
	if hx == 0 {
		return x
	} /* cbrt(0) is itself */
	*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(hx)
	x = *(*float32)(unsafe.Pointer(bp + 4)) /* x <- |x| */
	/* rough cbrt to 5 bits */
	if hx < int32(0x00800000) {
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(Int32FromInt32(0x4b800000))
		t = *(*float32)(unsafe.Pointer(bp + 8)) /* set t= 2**24 */
		t *= x
		*(*float32)(unsafe.Pointer(bp + 12)) = t
		high = *(*uint32)(unsafe.Pointer(bp + 12))
		*(*uint32)(unsafe.Pointer(bp + 16)) = high/Uint32FromInt32(3) + _B21
		t = *(*float32)(unsafe.Pointer(bp + 16))
	} else {
		*(*uint32)(unsafe.Pointer(bp + 20)) = uint32(hx/Int32FromInt32(3)) + _B11
		t = *(*float32)(unsafe.Pointer(bp + 20))
	}
	/* new cbrt to 23 bits */
	r = t * t / x
	s = _C7 + r*t
	t *= _G1 + _F1/(s+_E1+_D1/s)
	/* retore the sign bit */
	*(*float32)(unsafe.Pointer(bp + 24)) = t
	high = *(*uint32)(unsafe.Pointer(bp + 24))
	*(*uint32)(unsafe.Pointer(bp + 28)) = high | sign
	t = *(*float32)(unsafe.Pointer(bp + 28))
	return t
}

var _huge14 = float64(1e+300)

func x_ceil(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var i, j uint32
	var i0, i1, j0 int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* iw_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	i1 = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	j0 = i0>>Int32FromInt32(20)&int32(0x7ff) - int32(0x3ff)
	if j0 < int32(20) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge14+x > float64(0) {
				/* return 0*sign(x) if |x|<1 */
				if i0 < 0 {
					i0 = Int32FromUint32(0x80000000)
					i1 = 0
				} else if i0|i1 != 0 {
					i0 = int32(0x3ff00000)
					i1 = 0
				}
			}
		} else {
			i = uint32(int32(0x000fffff) >> j0)
			if uint32(i0)&i|uint32(i1) == uint32(0) {
				return x
			} /* x is integral */
			if _huge14+x > float64(0) {
				/* raise inexact flag */
				if i0 > 0 {
					i0 += int32(0x00100000) >> j0
				}
				i0 = int32(uint32(i0) & ^i)
				i1 = 0
			}
		}
	} else {
		if j0 > int32(51) {
			if j0 == int32(0x400) {
				return x + x
			} else {
				return x
			}
		} else {
			i = Uint32FromUint32(0xffffffff) >> (j0 - int32(20))
			if uint32(i1)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge14+x > float64(0) {
				/* raise inexact flag */
				if i0 > 0 {
					if j0 == int32(20) {
						i0 += int32(1)
					} else {
						j = uint32(i1 + int32(1)<<(int32(52)-j0))
						if j < uint32(i1) {
							i0 += int32(1)
						} /* got a carry */
						i1 = int32(j)
					}
				}
				i1 = int32(uint32(i1) & ^i)
			}
		}
	}
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(i0)<<Int32FromInt32(32) | uint64(i1)
	x = *(*float64)(unsafe.Pointer(bp + 8))
	return x
}

var _huge15 = float32(1e+30)

func x_ceilf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var i uint32
	var i0, j0 int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint32)(unsafe.Pointer(bp)))
	j0 = i0>>Int32FromInt32(23)&int32(0xff) - int32(0x7f)
	if j0 < int32(23) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge15+x > Float32FromFloat64(0) {
				/* return 0*sign(x) if |x|<1 */
				if i0 < 0 {
					i0 = Int32FromUint32(0x80000000)
				} else if i0 != 0 {
					i0 = int32(0x3f800000)
				}
			}
		} else {
			i = uint32(int32(0x007fffff) >> j0)
			if uint32(i0)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge15+x > Float32FromFloat64(0) {
				/* raise inexact flag */
				if i0 > 0 {
					i0 += int32(0x00800000) >> j0
				}
				i0 = int32(uint32(i0) & ^i)
			}
		}
	} else {
		if j0 == int32(0x80) {
			return x + x
		} else {
			return x
		}
	}
	*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(i0)
	x = *(*float32)(unsafe.Pointer(bp + 4))
	return x
}

func x_copysign(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var hx, hy uint32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = uint32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(hx&Uint32FromInt32(0x7fffffff)|hy&Uint32FromUint32(0x80000000)) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 16))
	return x
}

func x_copysignf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix, iy uint32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*uint32)(unsafe.Pointer(bp))
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	iy = *(*uint32)(unsafe.Pointer(bp + 4))
	*(*uint32)(unsafe.Pointer(bp + 8)) = ix&Uint32FromInt32(0x7fffffff) | iy&Uint32FromUint32(0x80000000)
	x = *(*float32)(unsafe.Pointer(bp + 8))
	return x
}

func x_cos(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var ix, n int32
	var z float64
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* y at bp+0 */ [2]float64
	z = float64(0)
	/* High word of x. */
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3fe921fb) {
		return x___kernel_cos(tls, x, z)
	} else {
		if ix >= int32(0x7ff00000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2(tls, x, bp)
			switch n & int32(3) {
			case 0:
				return x___kernel_cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
			case int32(1):
				return -x___kernel_sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			case int32(2):
				return -x___kernel_cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
			default:
				return x___kernel_sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			}
		}
	}
	return r
}

var _one27 = float32(1)

func x_cosf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix, n int32
	var z float32
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* y at bp+0 */ [2]float32
	z = float32(0)
	*(*float32)(unsafe.Pointer(bp + 8)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3f490fd8) {
		return x___kernel_cosf(tls, x, z)
	} else {
		if ix >= int32(0x7f800000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2f(tls, x, bp)
			switch n & int32(3) {
			case 0:
				return x___kernel_cosf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)])
			case int32(1):
				return -x___kernel_sinf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			case int32(2):
				return -x___kernel_cosf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)])
			default:
				return x___kernel_sinf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			}
		}
	}
	return r
}

var _tiny4 = float64(1e-300)
var _half6 = float64(0.5) /* 0x3FE00000, 0x00000000 */
var _one28 = float64(1)   /* 0x3FF00000, 0x00000000 */
var _two2 = float64(2)    /* 0x40000000, 0x00000000 */
/* c = (float)0.84506291151 */
var _erx = float64(0.8450629115104675) /* 0x3FEB0AC1, 0x60000000 */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx = float64(0.1283791670955126)                 /* 0x3FC06EBA, 0x8214DB69 */
var _efx8 = float64(1.0270333367641007)                /* 0x3FF06EBA, 0x8214DB69 */
var _pp0 = float64(0.12837916709551256)                /* 0x3FC06EBA, 0x8214DB68 */
var _pp1 = -Float64FromFloat64(0.3250421072470015)     /* 0xBFD4CD7D, 0x691CB913 */
var _pp2 = -Float64FromFloat64(0.02848174957559851)    /* 0xBF9D2A51, 0xDBD7194F */
var _pp3 = -Float64FromFloat64(0.005770270296489442)   /* 0xBF77A291, 0x236668E4 */
var _pp4 = -Float64FromFloat64(2.3763016656650163e-05) /* 0xBEF8EAD6, 0x120016AC */
var _qq1 = float64(0.39791722395915535)                /* 0x3FD97779, 0xCDDADC09 */
var _qq2 = float64(0.0650222499887673)                 /* 0x3FB0A54C, 0x5536CEBA */
var _qq3 = float64(0.005081306281875766)               /* 0x3F74D022, 0xC4D36B0F */
var _qq4 = float64(0.00013249473800432164)             /* 0x3F215DC9, 0x221C1A10 */
var _qq5 = -Float64FromFloat64(3.960228278775368e-06)  /* 0xBED09C43, 0x42A26120 */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa0 = -Float64FromFloat64(0.0023621185607526594) /* 0xBF6359B8, 0xBEF77538 */
var _pa1 = float64(0.41485611868374833)               /* 0x3FDA8D00, 0xAD92B34D */
var _pa2 = -Float64FromFloat64(0.3722078760357013)    /* 0xBFD7D240, 0xFBB8C3F1 */
var _pa3 = float64(0.31834661990116175)               /* 0x3FD45FCA, 0x805120E4 */
var _pa4 = -Float64FromFloat64(0.11089469428239668)   /* 0xBFBC6398, 0x3D3E28EC */
var _pa5 = float64(0.035478304325618236)              /* 0x3FA22A36, 0x599795EB */
var _pa6 = -Float64FromFloat64(0.002166375594868791)  /* 0xBF61BF38, 0x0A96073F */
var _qa1 = float64(0.10642088040084423)               /* 0x3FBB3E66, 0x18EEE323 */
var _qa2 = float64(0.540397917702171)                 /* 0x3FE14AF0, 0x92EB6F33 */
var _qa3 = float64(0.07182865441419627)               /* 0x3FB2635C, 0xD99FE9A7 */
var _qa4 = float64(0.12617121980876164)               /* 0x3FC02660, 0xE763351F */
var _qa5 = float64(0.01363708391202905)               /* 0x3F8BEDC2, 0x6B51DD1C */
var _qa6 = float64(0.011984499846799107)              /* 0x3F888B54, 0x5735151D */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra0 = -Float64FromFloat64(0.009864944034847148) /* 0xBF843412, 0x600D6435 */
var _ra1 = -Float64FromFloat64(0.6938585727071818)   /* 0xBFE63416, 0xE4BA7360 */
var _ra2 = -Float64FromFloat64(10.558626225323291)   /* 0xC0251E04, 0x41B0E726 */
var _ra3 = -Float64FromFloat64(62.375332450326006)   /* 0xC04F300A, 0xE4CBA38D */
var _ra4 = -Float64FromFloat64(162.39666946257347)   /* 0xC0644CB1, 0x84282266 */
var _ra5 = -Float64FromFloat64(184.60509290671104)   /* 0xC067135C, 0xEBCCABB2 */
var _ra6 = -Float64FromFloat64(81.2874355063066)     /* 0xC0545265, 0x57E4D2F2 */
var _ra7 = -Float64FromFloat64(9.814329344169145)    /* 0xC023A0EF, 0xC69AC25C */
var _sa1 = float64(19.651271667439257)               /* 0x4033A6B9, 0xBD707687 */
var _sa2 = float64(137.65775414351904)               /* 0x4061350C, 0x526AE721 */
var _sa3 = float64(434.56587747522923)               /* 0x407B290D, 0xD58A1A71 */
var _sa4 = float64(645.3872717332679)                /* 0x40842B19, 0x21EC2868 */
var _sa5 = float64(429.00814002756783)               /* 0x407AD021, 0x57700314 */
var _sa6 = float64(108.63500554177944)               /* 0x405B28A3, 0xEE48AE2C */
var _sa7 = float64(6.570249770319282)                /* 0x401A47EF, 0x8E484A93 */
var _sa8 = -Float64FromFloat64(0.0604244152148581)   /* 0xBFAEEFF2, 0xEE749A62 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb0 = -Float64FromFloat64(0.0098649429247001) /* 0xBF843412, 0x39E86F4A */
var _rb1 = -Float64FromFloat64(0.799283237680523)  /* 0xBFE993BA, 0x70C285DE */
var _rb2 = -Float64FromFloat64(17.757954917754752) /* 0xC031C209, 0x555F995A */
var _rb3 = -Float64FromFloat64(160.63638485582192) /* 0xC064145D, 0x43C5ED98 */
var _rb4 = -Float64FromFloat64(637.5664433683896)  /* 0xC083EC88, 0x1375F228 */
var _rb5 = -Float64FromFloat64(1025.0951316110772) /* 0xC0900461, 0x6A2E5992 */
var _rb6 = -Float64FromFloat64(483.5191916086514)  /* 0xC07E384E, 0x9BDC383F */
var _sb1 = float64(30.33806074348246)              /* 0x403E568B, 0x261D5190 */
var _sb2 = float64(325.7925129965739)              /* 0x40745CAE, 0x221B9F0A */
var _sb3 = float64(1536.729586084437)              /* 0x409802EB, 0x189D5118 */
var _sb4 = float64(3199.8582195085955)             /* 0x40A8FFB7, 0x688C246A */
var _sb5 = float64(2553.0504064331644)             /* 0x40A3F219, 0xCEDF3BE6 */
var _sb6 = float64(474.52854120695537)             /* 0x407DA874, 0xE79FE763 */
var _sb7 = -Float64FromFloat64(22.44095244658582)

func x_erf(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var P, Q, R, S, r, s, y, z float64
	var hx, i, ix int32
	var p1 uintptr
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* sl_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7ff00000) {
		/* erf(nan)=nan */
		i = int32(uint32(hx) >> int32(31) << int32(1))
		return float64(Int32FromInt32(1)-i) + _one28/x /* erf(+-inf)=+-1 */
	}
	if ix < int32(0x3feb0000) {
		/* |x|<0.84375 */
		if ix < int32(0x3e300000) {
			/* |x|<2**-28 */
			if ix < int32(0x00800000) {
				return float64(0.125) * (float64(8)*x + _efx8*x)
			} /*avoid underflow */
			return x + _efx*x
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = _one28 + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		return x + x*y
	}
	if ix < int32(0x3ff40000) {
		/* 0.84375 <= |x| < 1.25 */
		s = x_fabs(tls, x) - _one28
		P = _pa0 + s*(_pa1+s*(_pa2+s*(_pa3+s*(_pa4+s*(_pa5+s*_pa6)))))
		Q = _one28 + s*(_qa1+s*(_qa2+s*(_qa3+s*(_qa4+s*(_qa5+s*_qa6)))))
		if hx >= 0 {
			return _erx + P/Q
		} else {
			return -_erx - P/Q
		}
	}
	if ix >= int32(0x40180000) {
		/* inf>|x|>=6 */
		if hx >= 0 {
			return _one28 - _tiny4
		} else {
			return _tiny4 - _one28
		}
	}
	x = x_fabs(tls, x)
	s = _one28 / (x * x)
	if ix < int32(0x4006DB6E) { /* |x| < 1/0.35 */
		R = _ra0 + s*(_ra1+s*(_ra2+s*(_ra3+s*(_ra4+s*(_ra5+s*(_ra6+s*_ra7))))))
		S = _one28 + s*(_sa1+s*(_sa2+s*(_sa3+s*(_sa4+s*(_sa5+s*(_sa6+s*(_sa7+s*_sa8)))))))
	} else { /* |x| >= 1/0.35 */
		R = _rb0 + s*(_rb1+s*(_rb2+s*(_rb3+s*(_rb4+s*(_rb5+s*_rb6)))))
		S = _one28 + s*(_sb1+s*(_sb2+s*(_sb3+s*(_sb4+s*(_sb5+s*(_sb6+s*_sb7))))))
	}
	z = x
	*(*float64)(unsafe.Pointer(bp + 8)) = z
	p1 = bp + 8
	*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & Uint64FromUint64(0xffffffff00000000)
	*(*uint64)(unsafe.Pointer(bp + 8)) |= uint64(uint32(Int32FromInt32(0)))
	z = *(*float64)(unsafe.Pointer(bp + 8))
	r = x_exp(tls, -z*z-float64(0.5625)) * x_exp(tls, (z-x)*(z+x)+R/S)
	if hx >= 0 {
		return _one28 - r/x
	} else {
		return r/x - _one28
	}
	return r1
}

func x_erfc(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var P, Q, R, S, r, s, y, z float64
	var hx, ix int32
	var p1 uintptr
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* sl_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7ff00000) {
		/* erfc(nan)=nan */
		/* erfc(+-inf)=0,2 */
		return float64(uint32(hx)>>Int32FromInt32(31)<<Int32FromInt32(1)) + _one28/x
	}
	if ix < int32(0x3feb0000) {
		/* |x|<0.84375 */
		if ix < int32(0x3c700000) { /* |x|<2**-56 */
			return _one28 - x
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = _one28 + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		if hx < int32(0x3fd00000) { /* x<1/4 */
			return _one28 - (x + x*y)
		} else {
			r = x * y
			r += x - _half6
			return _half6 - r
		}
	}
	if ix < int32(0x3ff40000) {
		/* 0.84375 <= |x| < 1.25 */
		s = x_fabs(tls, x) - _one28
		P = _pa0 + s*(_pa1+s*(_pa2+s*(_pa3+s*(_pa4+s*(_pa5+s*_pa6)))))
		Q = _one28 + s*(_qa1+s*(_qa2+s*(_qa3+s*(_qa4+s*(_qa5+s*_qa6)))))
		if hx >= 0 {
			z = _one28 - _erx
			return z - P/Q
		} else {
			z = _erx + P/Q
			return _one28 + z
		}
	}
	if ix < int32(0x403c0000) { /* |x|<28 */
		x = x_fabs(tls, x)
		s = _one28 / (x * x)
		if ix < int32(0x4006DB6D) { /* |x| < 1/.35 ~ 2.857143*/
			R = _ra0 + s*(_ra1+s*(_ra2+s*(_ra3+s*(_ra4+s*(_ra5+s*(_ra6+s*_ra7))))))
			S = _one28 + s*(_sa1+s*(_sa2+s*(_sa3+s*(_sa4+s*(_sa5+s*(_sa6+s*(_sa7+s*_sa8)))))))
		} else { /* |x| >= 1/.35 ~ 2.857143 */
			if hx < 0 && ix >= int32(0x40180000) {
				return _two2 - _tiny4
			} /* x < -6 */
			R = _rb0 + s*(_rb1+s*(_rb2+s*(_rb3+s*(_rb4+s*(_rb5+s*_rb6)))))
			S = _one28 + s*(_sb1+s*(_sb2+s*(_sb3+s*(_sb4+s*(_sb5+s*(_sb6+s*_sb7))))))
		}
		z = x
		*(*float64)(unsafe.Pointer(bp + 8)) = z
		p1 = bp + 8
		*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & Uint64FromUint64(0xffffffff00000000)
		*(*uint64)(unsafe.Pointer(bp + 8)) |= uint64(uint32(Int32FromInt32(0)))
		z = *(*float64)(unsafe.Pointer(bp + 8))
		r = x_exp(tls, -z*z-float64(0.5625)) * x_exp(tls, (z-x)*(z+x)+R/S)
		if hx > 0 {
			return r / x
		} else {
			return _two2 - r/x
		}
	} else {
		if hx > 0 {
			return _tiny4 * _tiny4
		} else {
			return _two2 - _tiny4
		}
	}
	return r1
}

var _tiny5 = float32(1e-30)
var _half7 = float32(0.5) /* 0x3F000000 */
var _one29 = float32(1)   /* 0x3F800000 */
var _two3 = float32(2)    /* 0x40000000 */
/* c = (subfloat)0.84506291151 */
var _erx1 = float32(0.84506291151) /* 0x3f58560b */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx1 = float32(0.12837916613)                         /* 0x3e0375d4 */
var _efx81 = float32(1.027033329)                          /* 0x3f8375d4 */
var _pp01 = float32(0.12837916613)                         /* 0x3e0375d4 */
var _pp11 = float32(-Float64FromFloat64(0.32504209876))    /* 0xbea66beb */
var _pp21 = float32(-Float64FromFloat64(0.028481749818))   /* 0xbce9528f */
var _pp31 = float32(-Float64FromFloat64(0.005770270247))   /* 0xbbbd1489 */
var _pp41 = float32(-Float64FromFloat64(2.3763017452e-05)) /* 0xb7c756b1 */
var _qq11 = float32(0.39791721106)                         /* 0x3ecbbbce */
var _qq21 = float32(0.0650222525)                          /* 0x3d852a63 */
var _qq31 = float32(0.0050813062117)                       /* 0x3ba68116 */
var _qq41 = float32(0.00013249473704)                      /* 0x390aee49 */
var _qq51 = float32(-Float64FromFloat64(3.9602282413e-06)) /* 0xb684e21a */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa01 = float32(-Float64FromFloat64(0.0023621185683)) /* 0xbb1acdc6 */
var _pa11 = float32(0.41485610604)                        /* 0x3ed46805 */
var _pa21 = float32(-Float64FromFloat64(0.37220788002))   /* 0xbebe9208 */
var _pa31 = float32(0.31834661961)                        /* 0x3ea2fe54 */
var _pa41 = float32(-Float64FromFloat64(0.11089469492))   /* 0xbde31cc2 */
var _pa51 = float32(0.035478305072)                       /* 0x3d1151b3 */
var _pa61 = float32(-Float64FromFloat64(0.0021663755178)) /* 0xbb0df9c0 */
var _qa11 = float32(0.10642088205)                        /* 0x3dd9f331 */
var _qa21 = float32(0.54039794207)                        /* 0x3f0a5785 */
var _qa31 = float32(0.071828655899)                       /* 0x3d931ae7 */
var _qa41 = float32(0.12617121637)                        /* 0x3e013307 */
var _qa51 = float32(0.013637083583)                       /* 0x3c5f6e13 */
var _qa61 = float32(0.011984500103)                       /* 0x3c445aa3 */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra01 = float32(-Float64FromFloat64(0.0098649440333)) /* 0xbc21a093 */
var _ra11 = float32(-Float64FromFloat64(0.6938585639))    /* 0xbf31a0b7 */
var _ra21 = float32(-Float64FromFloat64(10.558626175))    /* 0xc128f022 */
var _ra31 = float32(-Float64FromFloat64(62.375331879))    /* 0xc2798057 */
var _ra41 = float32(-Float64FromFloat64(162.39666748))    /* 0xc322658c */
var _ra51 = float32(-Float64FromFloat64(184.60508728))    /* 0xc3389ae7 */
var _ra61 = float32(-Float64FromFloat64(81.287437439))    /* 0xc2a2932b */
var _ra71 = float32(-Float64FromFloat64(9.8143291473))    /* 0xc11d077e */
var _sa11 = float32(19.65127182)                          /* 0x419d35ce */
var _sa21 = float32(137.65776062)                         /* 0x4309a863 */
var _sa31 = float32(434.56588745)                         /* 0x43d9486f */
var _sa41 = float32(645.38726807)                         /* 0x442158c9 */
var _sa51 = float32(429.00814819)                         /* 0x43d6810b */
var _sa61 = float32(108.63500214)                         /* 0x42d9451f */
var _sa71 = float32(6.5702495575)                         /* 0x40d23f7c */
var _sa81 = float32(-Float64FromFloat64(0.060424413532))  /* 0xbd777f97 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb01 = float32(-Float64FromFloat64(0.009864943102)) /* 0xbc21a092 */
var _rb11 = float32(-Float64FromFloat64(0.79928326607))  /* 0xbf4c9dd4 */
var _rb21 = float32(-Float64FromFloat64(17.757955551))   /* 0xc18e104b */
var _rb31 = float32(-Float64FromFloat64(160.63638306))   /* 0xc320a2ea */
var _rb41 = float32(-Float64FromFloat64(637.56646729))   /* 0xc41f6441 */
var _rb51 = float32(-Float64FromFloat64(1025.0950928))   /* 0xc480230b */
var _rb61 = float32(-Float64FromFloat64(483.51919556))   /* 0xc3f1c275 */
var _sb11 = float32(30.338060379)                        /* 0x41f2b459 */
var _sb21 = float32(325.79251099)                        /* 0x43a2e571 */
var _sb31 = float32(1536.7296143)                        /* 0x44c01759 */
var _sb41 = float32(3199.8581543)                        /* 0x4547fdbb */
var _sb51 = float32(2553.050293)                         /* 0x451f90ce */
var _sb61 = float32(474.52853394)                        /* 0x43ed43a7 */
var _sb71 = float32(-Float64FromFloat64(22.440952301))

func x_erff(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var P, Q, R, S, r, s, y, z float32
	var hx, i, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7f800000) {
		/* erf(nan)=nan */
		i = int32(uint32(hx) >> int32(31) << int32(1))
		return float32(Int32FromInt32(1)-i) + _one29/x /* erf(+-inf)=+-1 */
	}
	if ix < int32(0x3f580000) {
		/* |x|<0.84375 */
		if ix < int32(0x31800000) {
			/* |x|<2**-28 */
			if ix < int32(0x04000000) {
				/*avoid underflow */
				return Float32FromFloat64(0.125) * (Float32FromFloat64(8)*x + _efx81*x)
			}
			return x + _efx1*x
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = _one29 + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		return x + x*y
	}
	if ix < int32(0x3fa00000) {
		/* 0.84375 <= |x| < 1.25 */
		s = x_fabsf(tls, x) - _one29
		P = _pa01 + s*(_pa11+s*(_pa21+s*(_pa31+s*(_pa41+s*(_pa51+s*_pa61)))))
		Q = _one29 + s*(_qa11+s*(_qa21+s*(_qa31+s*(_qa41+s*(_qa51+s*_qa61)))))
		if hx >= 0 {
			return _erx1 + P/Q
		} else {
			return -_erx1 - P/Q
		}
	}
	if ix >= int32(0x40c00000) {
		/* inf>|x|>=6 */
		if hx >= 0 {
			return _one29 - _tiny5
		} else {
			return _tiny5 - _one29
		}
	}
	x = x_fabsf(tls, x)
	s = _one29 / (x * x)
	if ix < int32(0x4036DB6E) { /* |x| < 1/0.35 */
		R = _ra01 + s*(_ra11+s*(_ra21+s*(_ra31+s*(_ra41+s*(_ra51+s*(_ra61+s*_ra71))))))
		S = _one29 + s*(_sa11+s*(_sa21+s*(_sa31+s*(_sa41+s*(_sa51+s*(_sa61+s*(_sa71+s*_sa81)))))))
	} else { /* |x| >= 1/0.35 */
		R = _rb01 + s*(_rb11+s*(_rb21+s*(_rb31+s*(_rb41+s*(_rb51+s*_rb61)))))
		S = _one29 + s*(_sb11+s*(_sb21+s*(_sb31+s*(_sb41+s*(_sb51+s*(_sb61+s*_sb71))))))
	}
	*(*float32)(unsafe.Pointer(bp + 4)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ix) & Uint32FromUint32(0xfffff000)
	z = *(*float32)(unsafe.Pointer(bp + 8))
	r = x_expf(tls, -z*z-Float32FromFloat64(0.5625)) * x_expf(tls, (z-x)*(z+x)+R/S)
	if hx >= 0 {
		return _one29 - r/x
	} else {
		return r/x - _one29
	}
	return r1
}

func x_erfcf(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var P, Q, R, S, r, s, y, z float32
	var hx, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = hx & int32(0x7fffffff)
	if ix >= int32(0x7f800000) {
		/* erfc(nan)=nan */
		/* erfc(+-inf)=0,2 */
		return float32(uint32(hx)>>Int32FromInt32(31)<<Int32FromInt32(1)) + _one29/x
	}
	if ix < int32(0x3f580000) {
		/* |x|<0.84375 */
		if ix < int32(0x23800000) { /* |x|<2**-56 */
			return _one29 - x
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = _one29 + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		if hx < int32(0x3e800000) { /* x<1/4 */
			return _one29 - (x + x*y)
		} else {
			r = x * y
			r += x - _half7
			return _half7 - r
		}
	}
	if ix < int32(0x3fa00000) {
		/* 0.84375 <= |x| < 1.25 */
		s = x_fabsf(tls, x) - _one29
		P = _pa01 + s*(_pa11+s*(_pa21+s*(_pa31+s*(_pa41+s*(_pa51+s*_pa61)))))
		Q = _one29 + s*(_qa11+s*(_qa21+s*(_qa31+s*(_qa41+s*(_qa51+s*_qa61)))))
		if hx >= 0 {
			z = _one29 - _erx1
			return z - P/Q
		} else {
			z = _erx1 + P/Q
			return _one29 + z
		}
	}
	if ix < int32(0x41e00000) { /* |x|<28 */
		x = x_fabsf(tls, x)
		s = _one29 / (x * x)
		if ix < int32(0x4036DB6D) { /* |x| < 1/.35 ~ 2.857143*/
			R = _ra01 + s*(_ra11+s*(_ra21+s*(_ra31+s*(_ra41+s*(_ra51+s*(_ra61+s*_ra71))))))
			S = _one29 + s*(_sa11+s*(_sa21+s*(_sa31+s*(_sa41+s*(_sa51+s*(_sa61+s*(_sa71+s*_sa81)))))))
		} else { /* |x| >= 1/.35 ~ 2.857143 */
			if hx < 0 && ix >= int32(0x40c00000) {
				return _two3 - _tiny5
			} /* x < -6 */
			R = _rb01 + s*(_rb11+s*(_rb21+s*(_rb31+s*(_rb41+s*(_rb51+s*_rb61)))))
			S = _one29 + s*(_sb11+s*(_sb21+s*(_sb31+s*(_sb41+s*(_sb51+s*(_sb61+s*_sb71))))))
		}
		*(*float32)(unsafe.Pointer(bp + 4)) = x
		ix = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ix) & Uint32FromUint32(0xfffff000)
		z = *(*float32)(unsafe.Pointer(bp + 8))
		r = x_expf(tls, -z*z-Float32FromFloat64(0.5625)) * x_expf(tls, (z-x)*(z+x)+R/S)
		if hx > 0 {
			return r / x
		} else {
			return _two3 - r/x
		}
	} else {
		if hx > 0 {
			return _tiny5 * _tiny5
		} else {
			return _two3 - _tiny5
		}
	}
	return r1
}

var _one30 = float64(1)
var _huge16 = float64(1e+300)
var _tiny6 = float64(1e-300)
var _o_threshold2 = float64(709.782712893384)  /* 0x40862E42, 0xFEFA39EF */
var _ln2_hi2 = float64(0.6931471803691238)     /* 0x3fe62e42, 0xfee00000 */
var _ln2_lo2 = float64(1.9082149292705877e-10) /* 0x3dea39ef, 0x35793c76 */
var _invln22 = float64(1.4426950408889634)     /* 0x3ff71547, 0x652b82fe */
/* scaled coefficients related to expm1 */
var _Q1 = -Float64FromFloat64(0.03333333333333313)  /* BFA11111 111110F4 */
var _Q2 = float64(0.0015873015872548146)            /* 3F5A01A0 19FE5585 */
var _Q3 = -Float64FromFloat64(7.93650757867488e-05) /* BF14CE19 9EAADBB7 */
var _Q4 = float64(4.008217827329362e-06)            /* 3ED0CFCA 86E65239 */
var _Q5 = -Float64FromFloat64(2.0109921818362437e-07)

func x_expm1(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(80) /* tlsAllocs 80 maxVaListSize 0 */
	defer tls.Free(80)
	var c, e, hfx, hi, hxs, lo, r1, t, y, v1, v2 float64
	var high, high1, high2, hx, low uint32
	var k, xsb int32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* gh_u at bp+40 */ Tieee_double_shape_type
	var _ /* gh_u at bp+64 */ Tieee_double_shape_type
	var _ /* gl_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+32 */ Tieee_double_shape_type
	var _ /* sh_u at bp+48 */ Tieee_double_shape_type
	var _ /* sh_u at bp+56 */ Tieee_double_shape_type
	var _ /* sh_u at bp+72 */ Tieee_double_shape_type
	c = float64(0)
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	xsb = int32(hx & uint32(0x80000000)) /* sign bit of x */
	if xsb == 0 {
		y = x
	} else {
		y = -x
	} /* y = |x| */
	hx &= uint32(0x7fffffff) /* high word of |x| */
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4043687A) {
		/* if |x|>=56*ln2 */
		if hx >= uint32(0x40862E42) {
			/* if |x|>=709.78... */
			if hx >= uint32(0x7ff00000) {
				*(*float64)(unsafe.Pointer(bp + 8)) = x
				low = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
				if hx&uint32(0xfffff)|low != uint32(0) {
					return x + x
				} else {
					if xsb == 0 {
						v1 = x
					} else {
						v1 = -Float64FromFloat64(1)
					}
					return v1
				} /* exp(+-inf)={inf,-1} */
			}
			if x > _o_threshold2 {
				return _huge16 * _huge16
			} /* overflow */
		}
		if xsb != 0 {
			/* x < -56*ln2, return -1.0 with inexact */
			if x+_tiny6 < float64(0) { /* raise inexact */
				return _tiny6 - _one30
			} /* return -1 */
		}
	}
	/* argument reduction */
	if hx > uint32(0x3fd62e42) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3FF0A2B2) { /* and |x| < 1.5 ln2 */
			if xsb == 0 {
				hi = x - _ln2_hi2
				lo = _ln2_lo2
				k = int32(1)
			} else {
				hi = x + _ln2_hi2
				lo = -_ln2_lo2
				k = -int32(1)
			}
		} else {
			if xsb == 0 {
				v2 = float64(0.5)
			} else {
				v2 = -Float64FromFloat64(0.5)
			}
			k = int32(_invln22*x + v2)
			t = float64(k)
			hi = x - t*_ln2_hi2 /* t*ln2_hi is exact here */
			lo = t * _ln2_lo2
		}
		x = hi - lo
		c = hi - x - lo
	} else {
		if hx < uint32(0x3c900000) { /* when |x|<2**-54, return x */
			t = _huge16 + x /* return x with inexact flags when x!=0 */
			return x - (t - (_huge16 + x))
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	hfx = float64(0.5) * x
	hxs = x * hfx
	r1 = _one30 + hxs*(_Q1+hxs*(_Q2+hxs*(_Q3+hxs*(_Q4+hxs*_Q5))))
	t = float64(3) - r1*hfx
	e = hxs * ((r1 - t) / (float64(6) - x*t))
	if k == 0 {
		return x - (x*e - hxs)
	} else {
		e = x*(e-c) - c
		e -= hxs
		if k == -int32(1) {
			return float64(0.5)*(x-e) - float64(0.5)
		}
		if k == int32(1) {
			if x < -Float64FromFloat64(0.25) {
				return -Float64FromFloat64(2) * (e - (x + float64(0.5)))
			} else {
				return _one30 + float64(2)*(x-e)
			}
		}
		if k <= -int32(2) || k > int32(56) {
			/* suffice to return exp(x)-1 */
			y = _one30 - (e - x)
			*(*float64)(unsafe.Pointer(bp + 16)) = y
			high = uint32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
			*(*float64)(unsafe.Pointer(bp + 24)) = y
			*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(high+uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
			y = *(*float64)(unsafe.Pointer(bp + 24)) /* add k to y's exponent */
			return y - _one30
		}
		t = _one30
		if k < int32(20) {
			*(*float64)(unsafe.Pointer(bp + 32)) = t
			*(*uint64)(unsafe.Pointer(bp + 32)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 32)) |= uint64(Int32FromInt32(0x3ff00000)-Int32FromInt32(0x200000)>>k) << Int32FromInt32(32)
			t = *(*float64)(unsafe.Pointer(bp + 32)) /* t=1-2^-k */
			y = t - (e - x)
			*(*float64)(unsafe.Pointer(bp + 40)) = y
			high1 = uint32(*(*uint64)(unsafe.Pointer(bp + 40)) >> int32(32))
			*(*float64)(unsafe.Pointer(bp + 48)) = y
			*(*uint64)(unsafe.Pointer(bp + 48)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 48)) |= uint64(high1+uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
			y = *(*float64)(unsafe.Pointer(bp + 48))
		} else {
			*(*float64)(unsafe.Pointer(bp + 56)) = t
			*(*uint64)(unsafe.Pointer(bp + 56)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 56)) |= uint64((Int32FromInt32(0x3ff)-k)<<Int32FromInt32(20)) << Int32FromInt32(32)
			t = *(*float64)(unsafe.Pointer(bp + 56)) /* 2^-k */
			y = x - (e + t)
			y += _one30
			*(*float64)(unsafe.Pointer(bp + 64)) = y
			high2 = uint32(*(*uint64)(unsafe.Pointer(bp + 64)) >> int32(32))
			*(*float64)(unsafe.Pointer(bp + 72)) = y
			*(*uint64)(unsafe.Pointer(bp + 72)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 72)) |= uint64(high2+uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
			y = *(*float64)(unsafe.Pointer(bp + 72))
		}
	}
	return y
}

var _one31 = float32(1)
var _huge17 = float32(1e+30)
var _tiny7 = float32(1e-30)
var _o_threshold3 = float32(88.721679688) /* 0x42b17180 */
var _ln2_hi3 = float32(0.69313812256)     /* 0x3f317180 */
var _ln2_lo3 = float32(9.0580006145e-06)  /* 0x3717f7d1 */
var _invln23 = float32(1.4426950216)      /* 0x3fb8aa3b */
/* scaled coefficients related to expm1 */
var _Q11 = float32(-Float64FromFloat64(0.033333335072))  /* 0xbd088889 */
var _Q21 = float32(0.0015873016091)                      /* 0x3ad00d01 */
var _Q31 = float32(-Float64FromFloat64(7.936507609e-05)) /* 0xb8a670cd */
var _Q41 = float32(4.0082177293e-06)                     /* 0x36867e54 */
var _Q51 = float32(-Float64FromFloat64(2.0109921195e-07))

func x_expm1f(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var c, e, hfx, hi, hxs, lo, r1, t, y, v2 float32
	var hx uint32
	var i, i1, i2, k, xsb int32
	var v1 float64
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+16 */ Tieee_float_shape_type
	var _ /* gf_u at bp+28 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+20 */ Tieee_float_shape_type
	var _ /* sf_u at bp+24 */ Tieee_float_shape_type
	var _ /* sf_u at bp+32 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	c = float32(0)
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = *(*uint32)(unsafe.Pointer(bp))
	xsb = int32(hx & uint32(0x80000000)) /* sign bit of x */
	if xsb == 0 {
		y = x
	} else {
		y = -x
	} /* y = |x| */
	hx &= uint32(0x7fffffff) /* high word of |x| */
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4195b844) {
		/* if |x|>=27*ln2 */
		if hx >= uint32(0x42b17218) {
			/* if |x|>=88.721... */
			if hx > uint32(0x7f800000) {
				return x + x
			} /* NaN */
			if hx == uint32(0x7f800000) {
				if xsb == 0 {
					v1 = float64(x)
				} else {
					v1 = -Float64FromFloat64(1)
				}
				return float32(v1)
			} /* exp(+-inf)={inf,-1} */
			if x > _o_threshold3 {
				return _huge17 * _huge17
			} /* overflow */
		}
		if xsb != 0 {
			/* x < -27*ln2, return -1.0 with inexact */
			if x+_tiny7 < Float32FromFloat64(0) { /* raise inexact */
				return _tiny7 - _one31
			} /* return -1 */
		}
	}
	/* argument reduction */
	if hx > uint32(0x3eb17218) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3F851592) { /* and |x| < 1.5 ln2 */
			if xsb == 0 {
				hi = x - _ln2_hi3
				lo = _ln2_lo3
				k = int32(1)
			} else {
				hi = x + _ln2_hi3
				lo = -_ln2_lo3
				k = -int32(1)
			}
		} else {
			if xsb == 0 {
				v2 = Float32FromFloat64(0.5)
			} else {
				v2 = float32(-Float64FromFloat64(0.5))
			}
			k = int32(_invln23*x + v2)
			t = float32(k)
			hi = x - t*_ln2_hi3 /* t*ln2_hi is exact here */
			lo = t * _ln2_lo3
		}
		x = hi - lo
		c = hi - x - lo
	} else {
		if hx < uint32(0x33000000) { /* when |x|<2**-25, return x */
			t = _huge17 + x /* return x with inexact flags when x!=0 */
			return x - (t - (_huge17 + x))
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	hfx = Float32FromFloat64(0.5) * x
	hxs = x * hfx
	r1 = _one31 + hxs*(_Q11+hxs*(_Q21+hxs*(_Q31+hxs*(_Q41+hxs*_Q51))))
	t = Float32FromFloat64(3) - r1*hfx
	e = hxs * ((r1 - t) / (Float32FromFloat64(6) - x*t))
	if k == 0 {
		return x - (x*e - hxs)
	} else {
		e = x*(e-c) - c
		e -= hxs
		if k == -int32(1) {
			return Float32FromFloat64(0.5)*(x-e) - Float32FromFloat64(0.5)
		}
		if k == int32(1) {
			if x < float32(-Float64FromFloat64(0.25)) {
				return -Float32FromFloat64(2) * (e - (x + Float32FromFloat64(0.5)))
			} else {
				return _one31 + Float32FromFloat64(2)*(x-e)
			}
		}
		if k <= -int32(2) || k > int32(56) {
			/* suffice to return exp(x)-1 */
			y = _one31 - (e - x)
			*(*float32)(unsafe.Pointer(bp + 4)) = y
			i = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
			*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(i + k<<Int32FromInt32(23))
			y = *(*float32)(unsafe.Pointer(bp + 8)) /* add k to y's exponent */
			return y - _one31
		}
		t = _one31
		if k < int32(23) {
			*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(Int32FromInt32(0x3f800000) - Int32FromInt32(0x1000000)>>k)
			t = *(*float32)(unsafe.Pointer(bp + 12)) /* t=1-2^-k */
			y = t - (e - x)
			*(*float32)(unsafe.Pointer(bp + 16)) = y
			i1 = int32(*(*uint32)(unsafe.Pointer(bp + 16)))
			*(*uint32)(unsafe.Pointer(bp + 20)) = uint32(i1 + k<<Int32FromInt32(23))
			y = *(*float32)(unsafe.Pointer(bp + 20))
		} else {
			*(*uint32)(unsafe.Pointer(bp + 24)) = uint32((Int32FromInt32(0x7f) - k) << Int32FromInt32(23))
			t = *(*float32)(unsafe.Pointer(bp + 24)) /* 2^-k */
			y = x - (e + t)
			y += _one31
			*(*float32)(unsafe.Pointer(bp + 28)) = y
			i2 = int32(*(*uint32)(unsafe.Pointer(bp + 28)))
			*(*uint32)(unsafe.Pointer(bp + 32)) = uint32(i2 + k<<Int32FromInt32(23))
			y = *(*float32)(unsafe.Pointer(bp + 32))
		}
	}
	return y
}

func x_fabs(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var high uint32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* sh_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	high = uint32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	*(*uint64)(unsafe.Pointer(bp + 8)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 8)) |= uint64(high&Uint32FromInt32(0x7fffffff)) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 8))
	return x
}

func x_fabsf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix uint32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*uint32)(unsafe.Pointer(bp))
	*(*uint32)(unsafe.Pointer(bp + 4)) = ix & Uint32FromInt32(0x7fffffff)
	x = *(*float32)(unsafe.Pointer(bp + 4))
	return x
}

var _huge18 = float64(1e+300)

func x_floor(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var i, j uint32
	var i0, i1, j0, v1 int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* iw_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	i1 = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	j0 = i0>>Int32FromInt32(20)&int32(0x7ff) - int32(0x3ff)
	if j0 < int32(20) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge18+x > float64(0) {
				/* return 0*sign(x) if |x|<1 */
				if i0 >= 0 {
					v1 = Int32FromInt32(0)
					i1 = v1
					i0 = v1
				} else if i0&int32(0x7fffffff)|i1 != 0 {
					i0 = Int32FromUint32(0xbff00000)
					i1 = 0
				}
			}
		} else {
			i = uint32(int32(0x000fffff) >> j0)
			if uint32(i0)&i|uint32(i1) == uint32(0) {
				return x
			} /* x is integral */
			if _huge18+x > float64(0) {
				/* raise inexact flag */
				if i0 < 0 {
					i0 += int32(0x00100000) >> j0
				}
				i0 = int32(uint32(i0) & ^i)
				i1 = 0
			}
		}
	} else {
		if j0 > int32(51) {
			if j0 == int32(0x400) {
				return x + x
			} else {
				return x
			}
		} else {
			i = Uint32FromUint32(0xffffffff) >> (j0 - int32(20))
			if uint32(i1)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge18+x > float64(0) {
				/* raise inexact flag */
				if i0 < 0 {
					if j0 == int32(20) {
						i0 += int32(1)
					} else {
						j = uint32(i1 + int32(1)<<(int32(52)-j0))
						if j < uint32(i1) {
							i0 += int32(1)
						} /* got a carry */
						i1 = int32(j)
					}
				}
				i1 = int32(uint32(i1) & ^i)
			}
		}
	}
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(i0)<<Int32FromInt32(32) | uint64(i1)
	x = *(*float64)(unsafe.Pointer(bp + 8))
	return x
}

var _huge19 = float32(1e+30)

func x_floorf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var i uint32
	var i0, j0 int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint32)(unsafe.Pointer(bp)))
	j0 = i0>>Int32FromInt32(23)&int32(0xff) - int32(0x7f)
	if j0 < int32(23) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge19+x > Float32FromFloat64(0) {
				/* return 0*sign(x) if |x|<1 */
				if i0 >= 0 {
					i0 = 0
				} else if i0&int32(0x7fffffff) != 0 {
					i0 = Int32FromUint32(0xbf800000)
				}
			}
		} else {
			i = uint32(int32(0x007fffff) >> j0)
			if uint32(i0)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge19+x > Float32FromFloat64(0) {
				/* raise inexact flag */
				if i0 < 0 {
					i0 += int32(0x00800000) >> j0
				}
				i0 = int32(uint32(i0) & ^i)
			}
		}
	} else {
		if j0 == int32(0x80) {
			return x + x
		} else {
			return x
		}
	}
	*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(i0)
	x = *(*float32)(unsafe.Pointer(bp + 4))
	return x
}

func x_ilogb(tls *TLS, x float64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, ix, lx int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	hx &= int32(0x7fffffff)
	if hx < int32(0x00100000) {
		if hx|lx == 0 {
			return int32(^(uint32(-Int32FromInt32(1)) >> Int32FromInt32(1)))
		} else { /* subnormal x */
			if hx == 0 {
				for ix = -int32(1043); lx > 0; {
					ix -= int32(1)
					goto _1
				_1:
					lx <<= int32(1)
				}
			} else {
				ix = -int32(1022)
				hx <<= int32(11)
				for hx > 0 {
					ix -= int32(1)
					goto _2
				_2:
					hx <<= int32(1)
				}
			}
		}
		return ix
	} else {
		if hx < int32(0x7ff00000) {
			return hx>>Int32FromInt32(20) - int32(1023)
		} else {
			if hx > int32(0x7ff00000) || lx != 0 {
				return int32(uint32(-Int32FromInt32(1)) >> Int32FromInt32(1))
			} else {
				return int32(m_INT_MAX)
			}
		}
	}
	return r
}

func x_ilogbf(tls *TLS, x float32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var hx, ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	hx &= int32(0x7fffffff)
	if hx < int32(0x00800000) {
		if hx == 0 {
			return int32(^(uint32(-Int32FromInt32(1)) >> Int32FromInt32(1)))
		} else { /* subnormal x */
			ix = -int32(126)
			hx <<= int32(8)
			for hx > 0 {
				ix -= int32(1)
				goto _1
			_1:
				hx <<= int32(1)
			}
		}
		return ix
	} else {
		if hx < int32(0x7f800000) {
			return hx>>Int32FromInt32(23) - int32(127)
		} else {
			if hx > int32(0x7f800000) {
				return int32(uint32(-Int32FromInt32(1)) >> Int32FromInt32(1))
			} else {
				return int32(m_INT_MAX)
			}
		}
	}
	return r
}

func x_ldexp(tls *TLS, x float64, n int32) (r float64) {
	return x_scalbn(tls, x, n)
}

func x_ldexpf(tls *TLS, x float32, n int32) (r float32) {
	return x_scalbnf(tls, x, n)
}

func x_llrint(tls *TLS, x float64) (r int64) {
	return int64(x_rint(tls, x))
}

var _ln2_hi4 = float64(0.6931471803691238)     /* 3fe62e42 fee00000 */
var _ln2_lo4 = float64(1.9082149292705877e-10) /* 3dea39ef 35793c76 */
var _two542 = float64(1.8014398509481984e+16)  /* 43500000 00000000 */
var _Lp1 = float64(0.6666666666666735)         /* 3FE55555 55555593 */
var _Lp2 = float64(0.3999999999940942)         /* 3FD99999 9997FA04 */
var _Lp3 = float64(0.2857142874366239)         /* 3FD24924 94229359 */
var _Lp4 = float64(0.22222198432149784)        /* 3FCC71C5 1D8E78AF */
var _Lp5 = float64(0.1818357216161805)         /* 3FC74664 96CB03DE */
var _Lp6 = float64(0.15313837699209373)        /* 3FC39A09 D078C69F */
var _Lp7 = float64(0.14798198605116586)        /* 3FC2F112 DF3E5244 */

var _zero16 = float64(0)

func x_log1p(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var R, c, f, hfsq, s, u, z, v1 float64
	var ax, hu, hx, k int32
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+32 */ Tieee_double_shape_type
	f = Float64FromInt32(0)
	c = Float64FromInt32(0)
	hu = 0
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ax = hx & int32(0x7fffffff)
	k = int32(1)
	if hx < int32(0x3FDA827A) {
		/* x < 0.41422  */
		if ax >= int32(0x3ff00000) {
			/* x <= -1.0 */
			if x == -Float64FromFloat64(1) {
				return -_two542 / _zero16
			} else {
				return (x - x) / (x - x)
			} /* log1p(x<-1)=NaN */
		}
		if ax < int32(0x3e200000) {
			/* |x| < 2**-29 */
			if _two542+x > _zero16 && ax < int32(0x3c900000) { /* |x| < 2**-54 */
				return x
			} else {
				return x - x*x*float64(0.5)
			}
		}
		if hx > 0 || hx <= Int32FromUint32(0xbfd2bec3) {
			k = 0
			f = x
			hu = int32(1)
		} /* -0.2929<x<0.41422 */
	}
	if hx >= int32(0x7ff00000) {
		return x + x
	}
	if k != 0 {
		if hx < int32(0x43400000) {
			u = float64(1) + x
			*(*float64)(unsafe.Pointer(bp + 8)) = u
			hu = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
			k = hu>>Int32FromInt32(20) - int32(1023)
			if k > 0 {
				v1 = float64(1) - (u - x)
			} else {
				v1 = x - (u - float64(1))
			}
			c = v1 /* correction term */
			c /= u
		} else {
			u = x
			*(*float64)(unsafe.Pointer(bp + 16)) = u
			hu = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
			k = hu>>Int32FromInt32(20) - int32(1023)
			c = Float64FromInt32(0)
		}
		hu &= int32(0x000fffff)
		if hu < int32(0x6a09e) {
			*(*float64)(unsafe.Pointer(bp + 24)) = u
			*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(hu|Int32FromInt32(0x3ff00000)) << Int32FromInt32(32)
			u = *(*float64)(unsafe.Pointer(bp + 24))
		} else {
			k += int32(1)
			*(*float64)(unsafe.Pointer(bp + 32)) = u
			*(*uint64)(unsafe.Pointer(bp + 32)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 32)) |= uint64(hu|Int32FromInt32(0x3fe00000)) << Int32FromInt32(32)
			u = *(*float64)(unsafe.Pointer(bp + 32)) /* normalize u/2 */
			hu = (int32(0x00100000) - hu) >> int32(2)
		}
		f = u - float64(1)
	}
	hfsq = float64(0.5) * f * f
	if hu == 0 {
		/* |f| < 2**-20 */
		if f == _zero16 {
			if k == 0 {
				return _zero16
			} else {
				c += float64(k) * _ln2_lo4
				return float64(k)*_ln2_hi4 + c
			}
		}
		R = hfsq * (float64(1) - float64(0.6666666666666666)*f)
		if k == 0 {
			return f - R
		} else {
			return float64(k)*_ln2_hi4 - (R - (float64(k)*_ln2_lo4 + c) - f)
		}
	}
	s = f / (float64(2) + f)
	z = s * s
	R = z * (_Lp1 + z*(_Lp2+z*(_Lp3+z*(_Lp4+z*(_Lp5+z*(_Lp6+z*_Lp7))))))
	if k == 0 {
		return f - (hfsq - s*(hfsq+R))
	} else {
		return float64(k)*_ln2_hi4 - (hfsq - (s*(hfsq+R) + (float64(k)*_ln2_lo4 + c)) - f)
	}
	return r
}

var _ln2_hi5 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo5 = float32(9.0580006145e-06) /* 0x3717f7d1 */
var _two252 = float32(3.3554432e+07)     /* 0x4c000000 */
var _Lp11 = float32(0.66666668653)       /* 3F2AAAAB */
var _Lp21 = float32(0.40000000596)       /* 3ECCCCCD */
var _Lp31 = float32(0.28571429849)       /* 3E924925 */
var _Lp41 = float32(0.22222198546)       /* 3E638E29 */
var _Lp51 = float32(0.1818357259)        /* 3E3A3325 */
var _Lp61 = float32(0.15313838422)       /* 3E1CD04F */
var _Lp71 = float32(0.1479819864)        /* 3E178897 */

var _zero17 = float32(0)

func x_log1pf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var R, c, f, hfsq, s, u, z, v1 float32
	var ax, hu, hx, k int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	f = Float32FromInt32(0)
	c = Float32FromInt32(0)
	hu = 0
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ax = hx & int32(0x7fffffff)
	k = int32(1)
	if hx < int32(0x3ed413d7) {
		/* x < 0.41422  */
		if ax >= int32(0x3f800000) {
			/* x <= -1.0 */
			if x == float32(-Float64FromFloat64(1)) {
				return -_two252 / _zero17
			} else {
				return (x - x) / (x - x)
			} /* log1p(x<-1)=NaN */
		}
		if ax < int32(0x31000000) {
			/* |x| < 2**-29 */
			if _two252+x > _zero17 && ax < int32(0x24800000) { /* |x| < 2**-54 */
				return x
			} else {
				return x - x*x*Float32FromFloat64(0.5)
			}
		}
		if hx > 0 || hx <= Int32FromUint32(0xbe95f61f) {
			k = 0
			f = x
			hu = int32(1)
		} /* -0.2929<x<0.41422 */
	}
	if hx >= int32(0x7f800000) {
		return x + x
	}
	if k != 0 {
		if hx < int32(0x5a000000) {
			u = Float32FromFloat64(1) + x
			*(*float32)(unsafe.Pointer(bp + 4)) = u
			hu = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
			k = hu>>Int32FromInt32(23) - int32(127)
			/* correction term */
			if k > 0 {
				v1 = Float32FromFloat64(1) - (u - x)
			} else {
				v1 = x - (u - Float32FromFloat64(1))
			}
			c = v1
			c /= u
		} else {
			u = x
			*(*float32)(unsafe.Pointer(bp + 8)) = u
			hu = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
			k = hu>>Int32FromInt32(23) - int32(127)
			c = Float32FromInt32(0)
		}
		hu &= int32(0x007fffff)
		if hu < int32(0x3504f7) {
			*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(hu | Int32FromInt32(0x3f800000))
			u = *(*float32)(unsafe.Pointer(bp + 12))
		} else {
			k += int32(1)
			*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(hu | Int32FromInt32(0x3f000000))
			u = *(*float32)(unsafe.Pointer(bp + 16)) /* normalize u/2 */
			hu = (int32(0x00800000) - hu) >> int32(2)
		}
		f = u - Float32FromFloat64(1)
	}
	hfsq = Float32FromFloat64(0.5) * f * f
	if hu == 0 {
		/* |f| < 2**-20 */
		if f == _zero17 {
			if k == 0 {
				return _zero17
			} else {
				c += float32(k) * _ln2_lo5
				return float32(k)*_ln2_hi5 + c
			}
		}
		R = hfsq * (Float32FromFloat64(1) - Float32FromFloat64(0.6666666666666666)*f)
		if k == 0 {
			return f - R
		} else {
			return float32(k)*_ln2_hi5 - (R - (float32(k)*_ln2_lo5 + c) - f)
		}
	}
	s = f / (Float32FromFloat64(2) + f)
	z = s * s
	R = z * (_Lp11 + z*(_Lp21+z*(_Lp31+z*(_Lp41+z*(_Lp51+z*(_Lp61+z*_Lp71))))))
	if k == 0 {
		return f - (hfsq - s*(hfsq+R))
	} else {
		return float32(k)*_ln2_hi5 - (hfsq - (s*(hfsq+R) + (float32(k)*_ln2_lo5 + c)) - f)
	}
	return r
}

func x_logb(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix, lx int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	ix &= int32(0x7fffffff) /* high |x| */
	if ix|lx == 0 {
		return -Float64FromFloat64(1) / x_fabs(tls, x)
	}
	if ix >= int32(0x7ff00000) {
		return x * x
	}
	ix >>= int32(20)
	if ix == 0 { /* IEEE 754 logb */
		return -Float64FromFloat64(1022)
	} else {
		return float64(ix - Int32FromInt32(1023))
	}
	return r
}

func x_logbf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix &= int32(0x7fffffff) /* high |x| */
	if ix == 0 {
		return float32(-Float64FromFloat64(1)) / x_fabsf(tls, x)
	}
	if ix >= int32(0x7f800000) {
		return x * x
	}
	ix >>= int32(23)
	if ix == 0 { /* IEEE 754 logb */
		return float32(-Float64FromFloat64(126))
	} else {
		return float32(ix - Int32FromInt32(127))
	}
	return r
}

func x_lrint(tls *TLS, x float64) (r int64) {
	return int64(x_rint(tls, x))
}

func x_lrintf(tls *TLS, x float32) (r int64) {
	return int64(x_rintf(tls, x))
}

var _one32 = float64(1)

func x_modf(tls *TLS, x float64, iptr uintptr) (r float64) {
	bp := tls.Alloc(80) /* tlsAllocs 80 maxVaListSize 0 */
	defer tls.Free(80)
	var high, high1, high2, i uint32
	var i0, i1, j0 int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* gh_u at bp+40 */ Tieee_double_shape_type
	var _ /* gh_u at bp+56 */ Tieee_double_shape_type
	var _ /* iw_u at bp+24 */ Tieee_double_shape_type
	var _ /* iw_u at bp+32 */ Tieee_double_shape_type
	var _ /* iw_u at bp+48 */ Tieee_double_shape_type
	var _ /* iw_u at bp+64 */ Tieee_double_shape_type
	var _ /* iw_u at bp+72 */ Tieee_double_shape_type
	var _ /* iw_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	i1 = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	j0 = i0>>Int32FromInt32(20)&int32(0x7ff) - int32(0x3ff) /* exponent of x */
	if j0 < int32(20) {                                     /* integer part in high x */
		if j0 < 0 { /* |x|<1 */
			*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(uint32(i0)&Uint32FromUint32(0x80000000))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
			*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp + 8)) /* *iptr = +-0 */
			return x
		} else {
			i = uint32(int32(0x000fffff) >> j0)
			if uint32(i0)&i|uint32(i1) == uint32(0) { /* x is integral */
				*(*float64)(unsafe.Pointer(iptr)) = x
				*(*float64)(unsafe.Pointer(bp + 16)) = x
				high = uint32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
				*(*uint64)(unsafe.Pointer(bp + 24)) = uint64(high&Uint32FromUint32(0x80000000))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
				x = *(*float64)(unsafe.Pointer(bp + 24)) /* return +-0 */
				return x
			} else {
				*(*uint64)(unsafe.Pointer(bp + 32)) = uint64(uint32(i0) & ^i)<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
				*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp + 32))
				return x - *(*float64)(unsafe.Pointer(iptr))
			}
		}
	} else {
		if j0 > int32(51) { /* no fraction part */
			*(*float64)(unsafe.Pointer(iptr)) = x * _one32
			*(*float64)(unsafe.Pointer(bp + 40)) = x
			high1 = uint32(*(*uint64)(unsafe.Pointer(bp + 40)) >> int32(32))
			*(*uint64)(unsafe.Pointer(bp + 48)) = uint64(high1&Uint32FromUint32(0x80000000))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
			x = *(*float64)(unsafe.Pointer(bp + 48)) /* return +-0 */
			return x
		} else { /* fraction part in low x */
			i = Uint32FromUint32(0xffffffff) >> (j0 - int32(20))
			if uint32(i1)&i == uint32(0) { /* x is integral */
				*(*float64)(unsafe.Pointer(iptr)) = x
				*(*float64)(unsafe.Pointer(bp + 56)) = x
				high2 = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> int32(32))
				*(*uint64)(unsafe.Pointer(bp + 64)) = uint64(high2&Uint32FromUint32(0x80000000))<<Int32FromInt32(32) | uint64(Int32FromInt32(0))
				x = *(*float64)(unsafe.Pointer(bp + 64)) /* return +-0 */
				return x
			} else {
				*(*uint64)(unsafe.Pointer(bp + 72)) = uint64(i0)<<Int32FromInt32(32) | uint64(uint32(i1) & ^i)
				*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp + 72))
				return x - *(*float64)(unsafe.Pointer(iptr))
			}
		}
	}
	return r
}

var _one33 = float32(1)

func x_modff(tls *TLS, x float32, iptr uintptr) (r float32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var i, ix, ix1 uint32
	var i0, j0 int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+20 */ Tieee_float_shape_type
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+24 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint32)(unsafe.Pointer(bp)))
	j0 = i0>>Int32FromInt32(23)&int32(0xff) - int32(0x7f) /* exponent of x */
	if j0 < int32(23) {                                   /* integer part in x */
		if j0 < 0 { /* |x|<1 */
			*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(i0) & Uint32FromUint32(0x80000000)
			*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp + 4)) /* *iptr = +-0 */
			return x
		} else {
			i = uint32(int32(0x007fffff) >> j0)
			if uint32(i0)&i == uint32(0) { /* x is integral */
				*(*float32)(unsafe.Pointer(iptr)) = x
				*(*float32)(unsafe.Pointer(bp + 8)) = x
				ix = *(*uint32)(unsafe.Pointer(bp + 8))
				*(*uint32)(unsafe.Pointer(bp + 12)) = ix & Uint32FromUint32(0x80000000)
				x = *(*float32)(unsafe.Pointer(bp + 12)) /* return +-0 */
				return x
			} else {
				*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(i0) & ^i
				*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp + 16))
				return x - *(*float32)(unsafe.Pointer(iptr))
			}
		}
	} else { /* no fraction part */
		*(*float32)(unsafe.Pointer(iptr)) = x * _one33
		*(*float32)(unsafe.Pointer(bp + 20)) = x
		ix1 = *(*uint32)(unsafe.Pointer(bp + 20))
		*(*uint32)(unsafe.Pointer(bp + 24)) = ix1 & Uint32FromUint32(0x80000000)
		x = *(*float32)(unsafe.Pointer(bp + 24)) /* return +-0 */
		return x
	}
	return r
}

func x_nextafter(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var hx, hy, ix, iy int32
	var lx, ly uint32
	var t float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* iw_u at bp+16 */ Tieee_double_shape_type
	var _ /* iw_u at bp+24 */ Tieee_double_shape_type
	var _ /* iw_u at bp+32 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	ly = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	ix = hx & int32(0x7fffffff)                                                                                                                                               /* |x| */
	iy = hy & int32(0x7fffffff)                                                                                                                                               /* |y| */
	if ix >= int32(0x7ff00000) && uint32(ix-Int32FromInt32(0x7ff00000))|lx != uint32(0) || iy >= int32(0x7ff00000) && uint32(iy-Int32FromInt32(0x7ff00000))|ly != uint32(0) { /* y is nan */
		return x + y
	}
	if x == y {
		return y
	} /* x=y, return y */
	if uint32(ix)|lx == uint32(0) {
		/* x == 0 */
		*(*uint64)(unsafe.Pointer(bp + 16)) = uint64(uint32(hy)&Uint32FromUint32(0x80000000))<<Int32FromInt32(32) | uint64(Int32FromInt32(1))
		x = *(*float64)(unsafe.Pointer(bp + 16)) /* return +-minsubnormal */
		t = x * x
		if t == x {
			return t
		} else {
			return x
		} /* raise underflow flag */
	}
	if hx >= 0 { /* x > 0 */
		if hx > hy || hx == hy && lx > ly { /* x > y, x -= ulp */
			if lx == uint32(0) {
				hx -= int32(1)
			}
			lx -= uint32(1)
		} else { /* x < y, x += ulp */
			lx += uint32(1)
			if lx == uint32(0) {
				hx += int32(1)
			}
		}
	} else { /* x < 0 */
		if hy >= 0 || hx > hy || hx == hy && lx > ly { /* x < y, x -= ulp */
			if lx == uint32(0) {
				hx -= int32(1)
			}
			lx -= uint32(1)
		} else { /* x > y, x += ulp */
			lx += uint32(1)
			if lx == uint32(0) {
				hx += int32(1)
			}
		}
	}
	hy = hx & int32(0x7ff00000)
	if hy >= int32(0x7ff00000) {
		return x + x
	} /* overflow  */
	if hy < int32(0x00100000) {
		/* underflow */
		t = x * x
		if t != x {
			/* raise underflow flag */
			*(*uint64)(unsafe.Pointer(bp + 24)) = uint64(hx)<<Int32FromInt32(32) | uint64(lx)
			y = *(*float64)(unsafe.Pointer(bp + 24))
			return y
		}
	}
	*(*uint64)(unsafe.Pointer(bp + 32)) = uint64(hx)<<Int32FromInt32(32) | uint64(lx)
	x = *(*float64)(unsafe.Pointer(bp + 32))
	return x
}

func x_nextafterf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var hx, hy, ix, iy int32
	var t float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hy = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	ix = hx & int32(0x7fffffff)                           /* |x| */
	iy = hy & int32(0x7fffffff)                           /* |y| */
	if ix > int32(0x7f800000) || iy > int32(0x7f800000) { /* y is nan */
		return x + y
	}
	if x == y {
		return y
	} /* x=y, return y */
	if ix == 0 {
		/* x == 0 */
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(hy)&Uint32FromUint32(0x80000000) | Uint32FromInt32(1)
		x = *(*float32)(unsafe.Pointer(bp + 8)) /* return +-minsubnormal */
		t = x * x
		if t == x {
			return t
		} else {
			return x
		} /* raise underflow flag */
	}
	if hx >= 0 { /* x > 0 */
		if hx > hy { /* x > y, x -= ulp */
			hx -= int32(1)
		} else { /* x < y, x += ulp */
			hx += int32(1)
		}
	} else { /* x < 0 */
		if hy >= 0 || hx > hy { /* x < y, x -= ulp */
			hx -= int32(1)
		} else { /* x > y, x += ulp */
			hx += int32(1)
		}
	}
	hy = hx & int32(0x7f800000)
	if hy >= int32(0x7f800000) {
		return x + x
	} /* overflow  */
	if hy < int32(0x00800000) {
		/* underflow */
		t = x * x
		if t != x {
			/* raise underflow flag */
			*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(hx)
			y = *(*float32)(unsafe.Pointer(bp + 12))
			return y
		}
	}
	*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(hx)
	x = *(*float32)(unsafe.Pointer(bp + 16))
	return x
}

var _Zero2 = [2]float64{
	0: float64(0),
	1: -Float64FromFloat64(0)}

// C documentation
//
//	/*
//	 * Return the IEEE remainder and set *quo to the last n bits of the
//	 * quotient, rounded to the nearest integer.  We choose n=31 because
//	 * we wind up computing all the integer bits of the quotient anyway as
//	 * a side-effect of computing the remainder by the shift and subtract
//	 * method.  In practice, this is far more bits than are needed to use
//	 * remquo in reduction algorithms.
//	 */
func x_remquo(tls *TLS, x float64, y float64, quo uintptr) (r float64) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var hx, hy, hz, i, ix, iy, n, sx, v5 int32
	var lx, ly, lz, q, sxy, v6, v7 uint32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* ew_u at bp+8 */ Tieee_double_shape_type
	var _ /* gh_u at bp+24 */ Tieee_double_shape_type
	var _ /* iw_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+32 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = uint32(*(*uint64)(unsafe.Pointer(bp)))
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	hy = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
	ly = uint32(*(*uint64)(unsafe.Pointer(bp + 8)))
	sxy = uint32(hx^hy) & uint32(0x80000000)
	sx = int32(uint32(hx) & uint32(0x80000000)) /* sign of x */
	hx ^= sx                                    /* |x| */
	hy &= int32(0x7fffffff)                     /* |y| */
	/* purge off exception values */
	if uint32(hy)|ly == uint32(0) || hx >= int32(0x7ff00000) || uint32(hy)|(ly|-ly)>>int32(31) > uint32(0x7ff00000) { /* or y is NaN */
		return x * y / (x * y)
	}
	if hx <= hy {
		if hx < hy || lx < ly {
			q = uint32(0)
			goto fixup /* |x|<|y| return x or x-y */
		}
		if lx == ly {
			*(*int32)(unsafe.Pointer(quo)) = int32(1)
			return _Zero2[uint32(sx)>>int32(31)] /* |x|=|y| return x*0*/
		}
	}
	/* determine ix = ilogb(x) */
	if hx < int32(0x00100000) { /* subnormal x */
		if hx == 0 {
			ix = -int32(1043)
			i = int32(lx)
			for i > 0 {
				ix -= int32(1)
				goto _1
			_1:
				i <<= int32(1)
			}
		} else {
			ix = -int32(1022)
			i = hx << Int32FromInt32(11)
			for i > 0 {
				ix -= int32(1)
				goto _2
			_2:
				i <<= int32(1)
			}
		}
	} else {
		ix = hx>>Int32FromInt32(20) - int32(1023)
	}
	/* determine iy = ilogb(y) */
	if hy < int32(0x00100000) { /* subnormal y */
		if hy == 0 {
			iy = -int32(1043)
			i = int32(ly)
			for i > 0 {
				iy -= int32(1)
				goto _3
			_3:
				i <<= int32(1)
			}
		} else {
			iy = -int32(1022)
			i = hy << Int32FromInt32(11)
			for i > 0 {
				iy -= int32(1)
				goto _4
			_4:
				i <<= int32(1)
			}
		}
	} else {
		iy = hy>>Int32FromInt32(20) - int32(1023)
	}
	/* set up {hx,lx}, {hy,ly} and align y to x */
	if ix >= -int32(1022) {
		hx = int32(0x00100000) | int32(0x000fffff)&hx
	} else { /* subnormal x, shift x to normal */
		n = -int32(1022) - ix
		if n <= int32(31) {
			hx = int32(uint32(hx<<n) | lx>>(Int32FromInt32(32)-n))
			lx <<= uint32(n)
		} else {
			hx = int32(lx << (n - int32(32)))
			lx = uint32(0)
		}
	}
	if iy >= -int32(1022) {
		hy = int32(0x00100000) | int32(0x000fffff)&hy
	} else { /* subnormal y, shift y to normal */
		n = -int32(1022) - iy
		if n <= int32(31) {
			hy = int32(uint32(hy<<n) | ly>>(Int32FromInt32(32)-n))
			ly <<= uint32(n)
		} else {
			hy = int32(ly << (n - int32(32)))
			ly = uint32(0)
		}
	}
	/* fix point fmod */
	n = ix - iy
	q = uint32(0)
	for {
		v5 = n
		n--
		if !(v5 != 0) {
			break
		}
		hz = hx - hy
		lz = lx - ly
		if lx < ly {
			hz -= int32(1)
		}
		if hz < 0 {
			hx = int32(uint32(hx+hx) + lx>>Int32FromInt32(31))
			lx = lx + lx
		} else {
			hx = int32(uint32(hz+hz) + lz>>Int32FromInt32(31))
			lx = lz + lz
			q++
		}
		q <<= uint32(1)
	}
	hz = hx - hy
	lz = lx - ly
	if lx < ly {
		hz -= int32(1)
	}
	if hz >= 0 {
		hx = hz
		lx = lz
		q++
	}
	/* convert back to floating value and restore the sign */
	if uint32(hx)|lx == uint32(0) {
		/* return sign(x)*0 */
		if sxy != 0 {
			v6 = -q
		} else {
			v6 = q
		}
		*(*int32)(unsafe.Pointer(quo)) = int32(v6)
		return _Zero2[uint32(sx)>>int32(31)]
	}
	for hx < int32(0x00100000) {
		/* normalize x */
		hx = int32(uint32(hx+hx) + lx>>Int32FromInt32(31))
		lx = lx + lx
		iy -= int32(1)
	}
	if iy >= -int32(1022) { /* normalize output */
		hx = hx - Int32FromInt32(0x00100000) | (iy+Int32FromInt32(1023))<<Int32FromInt32(20)
	} else { /* subnormal output */
		n = -int32(1022) - iy
		if n <= int32(20) {
			lx = lx>>n | uint32(hx)<<(Int32FromInt32(32)-n)
			hx >>= n
		} else {
			if n <= int32(31) {
				lx = uint32(hx<<(Int32FromInt32(32)-n)) | lx>>n
				hx = sx
			} else {
				lx = uint32(hx >> (n - int32(32)))
				hx = sx
			}
		}
	}
fixup:
	*(*uint64)(unsafe.Pointer(bp + 16)) = uint64(hx)<<Int32FromInt32(32) | uint64(lx)
	x = *(*float64)(unsafe.Pointer(bp + 16))
	y = x_fabs(tls, y)
	if y < float64(4.450147717014403e-308) {
		if x+x > y || x+x == y && q&uint32(1) != 0 {
			q++
			x -= y
		}
	} else if x > float64(0.5)*y || x == float64(0.5)*y && q&uint32(1) != 0 {
		q++
		x -= y
	}
	*(*float64)(unsafe.Pointer(bp + 24)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp + 24)) >> int32(32))
	*(*float64)(unsafe.Pointer(bp + 32)) = x
	*(*uint64)(unsafe.Pointer(bp + 32)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 32)) |= uint64(hx^sx) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 32))
	q &= uint32(0x7fffffff)
	if sxy != 0 {
		v7 = -q
	} else {
		v7 = q
	}
	*(*int32)(unsafe.Pointer(quo)) = int32(v7)
	return x
}

var _Zero3 = [2]float32{
	0: float32(0),
	1: float32(-Float64FromFloat64(0))}

// C documentation
//
//	/*
//	 * Return the IEEE remainder and set *quo to the last n bits of the
//	 * quotient, rounded to the nearest integer.  We choose n=31 because
//	 * we wind up computing all the integer bits of the quotient anyway as
//	 * a side-effect of computing the remainder by the shift and subtract
//	 * method.  In practice, this is far more bits than are needed to use
//	 * remquo in reduction algorithms.
//	 */
func x_remquof(tls *TLS, x float32, y float32, quo uintptr) (r float32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var hx, hy, hz, i, ix, iy, n, sx, v3 int32
	var q, sxy, v4, v5 uint32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+12 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+16 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp)))
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	hy = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
	sxy = uint32(hx^hy) & uint32(0x80000000)
	sx = int32(uint32(hx) & uint32(0x80000000)) /* sign of x */
	hx ^= sx                                    /* |x| */
	hy &= int32(0x7fffffff)                     /* |y| */
	/* purge off exception values */
	if hy == 0 || hx >= int32(0x7f800000) || hy > int32(0x7f800000) { /* y=0,NaN;or x not finite */
		return x * y / (x * y)
	}
	if hx < hy {
		q = uint32(0)
		goto fixup
	} else if hx == hy {
		*(*int32)(unsafe.Pointer(quo)) = int32(1)
		return _Zero3[uint32(sx)>>int32(31)] /* |x|=|y| return x*0*/
	}
	/* determine ix = ilogb(x) */
	if hx < int32(0x00800000) { /* subnormal x */
		ix = -int32(126)
		i = hx << Int32FromInt32(8)
		for i > 0 {
			ix -= int32(1)
			goto _1
		_1:
			i <<= int32(1)
		}
	} else {
		ix = hx>>Int32FromInt32(23) - int32(127)
	}
	/* determine iy = ilogb(y) */
	if hy < int32(0x00800000) { /* subnormal y */
		iy = -int32(126)
		i = hy << Int32FromInt32(8)
		for i > 0 {
			iy -= int32(1)
			goto _2
		_2:
			i <<= int32(1)
		}
	} else {
		iy = hy>>Int32FromInt32(23) - int32(127)
	}
	/* set up {hx,lx}, {hy,ly} and align y to x */
	if ix >= -int32(126) {
		hx = int32(0x00800000) | int32(0x007fffff)&hx
	} else { /* subnormal x, shift x to normal */
		n = -int32(126) - ix
		hx <<= n
	}
	if iy >= -int32(126) {
		hy = int32(0x00800000) | int32(0x007fffff)&hy
	} else { /* subnormal y, shift y to normal */
		n = -int32(126) - iy
		hy <<= n
	}
	/* fix point fmod */
	n = ix - iy
	q = uint32(0)
	for {
		v3 = n
		n--
		if !(v3 != 0) {
			break
		}
		hz = hx - hy
		if hz < 0 {
			hx = hx << int32(1)
		} else {
			hx = hz << int32(1)
			q++
		}
		q <<= uint32(1)
	}
	hz = hx - hy
	if hz >= 0 {
		hx = hz
		q++
	}
	/* convert back to floating value and restore the sign */
	if hx == 0 {
		/* return sign(x)*0 */
		if sxy != 0 {
			v4 = -q
		} else {
			v4 = q
		}
		*(*int32)(unsafe.Pointer(quo)) = int32(v4)
		return _Zero3[uint32(sx)>>int32(31)]
	}
	for hx < int32(0x00800000) {
		/* normalize x */
		hx <<= int32(1)
		iy -= int32(1)
	}
	if iy >= -int32(126) { /* normalize output */
		hx = hx - Int32FromInt32(0x00800000) | (iy+Int32FromInt32(127))<<Int32FromInt32(23)
	} else { /* subnormal output */
		n = -int32(126) - iy
		hx >>= n
	}
fixup:
	*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(hx)
	x = *(*float32)(unsafe.Pointer(bp + 8))
	y = x_fabsf(tls, y)
	if y < Float32FromFloat32(2.350988701644575e-38) {
		if x+x > y || x+x == y && q&uint32(1) != 0 {
			q++
			x -= y
		}
	} else if x > Float32FromFloat32(0.5)*y || x == Float32FromFloat32(0.5)*y && q&uint32(1) != 0 {
		q++
		x -= y
	}
	*(*float32)(unsafe.Pointer(bp + 12)) = x
	hx = int32(*(*uint32)(unsafe.Pointer(bp + 12)))
	*(*uint32)(unsafe.Pointer(bp + 16)) = uint32(hx ^ sx)
	x = *(*float32)(unsafe.Pointer(bp + 16))
	q &= uint32(0x7fffffff)
	if sxy != 0 {
		v5 = -q
	} else {
		v5 = q
	}
	*(*int32)(unsafe.Pointer(quo)) = int32(v5)
	return x
}

/*
 * TWO23 is long double instead of double to avoid a bug in gcc.  Without
 * this, gcc thinks that TWO23[sx]+x and w-TWO23[sx] already have double
 * precision and doesn't clip them to double precision when they are
 * assigned and returned.
 */

var _TWO52 = [2]float64{
	0: Float64FromFloat64(4.503599627370496e+15),
	1: -Float64FromFloat64(4.503599627370496e+15)}

func x_rint(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxVaListSize 0 */
	defer tls.Free(40)
	var i, i1 uint32
	var i0, j0, sx int32
	var t, w float64
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* iw_u at bp+32 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	var _ /* sh_u at bp+8 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	i1 = uint32(*(*uint64)(unsafe.Pointer(bp)))
	sx = i0 >> Int32FromInt32(31) & int32(1)
	j0 = i0>>Int32FromInt32(20)&int32(0x7ff) - int32(0x3ff)
	if j0 < int32(20) {
		if j0 < 0 {
			if uint32(i0&Int32FromInt32(0x7fffffff))|i1 == uint32(0) {
				return x
			}
			i1 |= uint32(i0 & Int32FromInt32(0x0fffff))
			i0 = int32(uint32(i0) & Uint32FromUint32(0xfffe0000))
			i0 = int32(uint32(i0) | (i1|-i1)>>Int32FromInt32(12)&Uint32FromInt32(0x80000))
			*(*float64)(unsafe.Pointer(bp + 8)) = x
			*(*uint64)(unsafe.Pointer(bp + 8)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 8)) |= uint64(i0) << Int32FromInt32(32)
			x = *(*float64)(unsafe.Pointer(bp + 8))
			w = _TWO52[sx] + x
			t = w - _TWO52[sx]
			*(*float64)(unsafe.Pointer(bp + 16)) = t
			i0 = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
			*(*float64)(unsafe.Pointer(bp + 24)) = t
			*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
			*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(i0&Int32FromInt32(0x7fffffff)|sx<<Int32FromInt32(31)) << Int32FromInt32(32)
			t = *(*float64)(unsafe.Pointer(bp + 24))
			return t
		} else {
			i = uint32(int32(0x000fffff) >> j0)
			if uint32(i0)&i|i1 == uint32(0) {
				return x
			} /* x is integral */
			i >>= uint32(1)
			if uint32(i0)&i|i1 != uint32(0) {
				if j0 == int32(19) {
					i1 = uint32(0x40000000)
				} else {
					i0 = int32(uint32(i0) & ^i | uint32(Int32FromInt32(0x20000)>>j0))
				}
			}
		}
	} else {
		if j0 > int32(51) {
			if j0 == int32(0x400) {
				return x + x
			} else {
				return x
			}
		} else {
			i = Uint32FromUint32(0xffffffff) >> (j0 - int32(20))
			if i1&i == uint32(0) {
				return x
			} /* x is integral */
			i >>= uint32(1)
			if i1&i != uint32(0) {
				i1 = i1 & ^i | uint32(Int32FromInt32(0x40000000)>>(j0-Int32FromInt32(20)))
			}
		}
	}
	*(*uint64)(unsafe.Pointer(bp + 32)) = uint64(i0)<<Int32FromInt32(32) | uint64(i1)
	x = *(*float64)(unsafe.Pointer(bp + 32))
	w = _TWO52[sx] + x
	return w - _TWO52[sx]
}

var _TWO23 = [2]float32{
	0: float32(8.388608e+06),
	1: float32(-Float64FromFloat64(8.388608e+06))}

func x_rintf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var i0, j0, sx int32
	var t, w float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	/* volatile works around gcc bug */
	*(*float32)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint32)(unsafe.Pointer(bp)))
	sx = i0 >> Int32FromInt32(31) & int32(1)
	j0 = i0>>Int32FromInt32(23)&int32(0xff) - int32(0x7f)
	if j0 < int32(23) {
		if j0 < 0 {
			if i0&int32(0x7fffffff) == 0 {
				return x
			}
			w = _TWO23[sx] + x
			t = w - _TWO23[sx]
			return t
		}
		w = _TWO23[sx] + x
		return w - _TWO23[sx]
	}
	if j0 == int32(0x80) {
		return x + x
	} else {
		return x
	} /* x is integral */
	return r
}

func x_round(tls *TLS, x float64) (r float64) {
	var t float64
	if !(x___fpclassify(tls, x) > Int32FromInt32(m_FP_INFINITE)) {
		return x
	}
	if x >= float64(0) {
		t = x_ceil(tls, x)
		if t-x > float64(0.5) {
			t -= float64(1)
		}
		return t
	} else {
		t = x_ceil(tls, -x)
		if t+x > float64(0.5) {
			t -= float64(1)
		}
		return -t
	}
	return r
}

func x_roundf(tls *TLS, x float32) (r float32) {
	var t float32
	if !(x___fpclassifyf(tls, x) > Int32FromInt32(m_FP_INFINITE)) {
		return x
	}
	if float64(x) >= float64(0) {
		t = x_ceilf(tls, x)
		if float64(t-x) > float64(0.5) {
			t = float32(float64(t) - Float64FromFloat64(1))
		}
		return t
	} else {
		t = x_ceilf(tls, -x)
		if float64(t+x) > float64(0.5) {
			t = float32(float64(t) - Float64FromFloat64(1))
		}
		return -t
	}
	return r
}

var _two543 = float64(1.8014398509481984e+16) /* 0x43500000, 0x00000000 */
var _twom54 = float64(5.551115123125783e-17)  /* 0x3C900000, 0x00000000 */
var _huge20 = float64(1e+300)
var _tiny8 = float64(1e-300)

func x_scalbln(tls *TLS, x float64, n int64) (r float64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var hx, k, lx int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* gh_u at bp+8 */ Tieee_double_shape_type
	var _ /* sh_u at bp+16 */ Tieee_double_shape_type
	var _ /* sh_u at bp+24 */ Tieee_double_shape_type
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	lx = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	k = hx & int32(0x7ff00000) >> int32(20) /* extract exponent */
	if k == 0 {
		/* 0 or subnormal x */
		if lx|hx&int32(0x7fffffff) == 0 {
			return x
		} /* +-0 */
		x *= _two543
		*(*float64)(unsafe.Pointer(bp + 8)) = x
		hx = int32(*(*uint64)(unsafe.Pointer(bp + 8)) >> int32(32))
		k = hx&int32(0x7ff00000)>>int32(20) - int32(54)
		if n < int64(-int32(50000)) {
			return _tiny8 * x
		} /*underflow*/
	}
	if k == int32(0x7ff) {
		return x + x
	} /* NaN or Inf */
	k = int32(int64(k) + n)
	if k > int32(0x7fe) {
		return _huge20 * x_copysign(tls, _huge20, x)
	} /* overflow  */
	if k > 0 {
		/* normal result */
		*(*float64)(unsafe.Pointer(bp + 16)) = x
		*(*uint64)(unsafe.Pointer(bp + 16)) &= uint64(0xffffffff)
		*(*uint64)(unsafe.Pointer(bp + 16)) |= uint64(uint32(hx)&Uint32FromUint32(0x800fffff)|uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
		x = *(*float64)(unsafe.Pointer(bp + 16))
		return x
	}
	if k <= -int32(54) {
		if n > int64(50000) { /* in case integer overflow in n+k */
			return _huge20 * x_copysign(tls, _huge20, x)
		} else {
			return _tiny8 * x_copysign(tls, _tiny8, x)
		} /*underflow*/
	}
	k += int32(54) /* subnormal result */
	*(*float64)(unsafe.Pointer(bp + 24)) = x
	*(*uint64)(unsafe.Pointer(bp + 24)) &= uint64(0xffffffff)
	*(*uint64)(unsafe.Pointer(bp + 24)) |= uint64(uint32(hx)&Uint32FromUint32(0x800fffff)|uint32(k<<Int32FromInt32(20))) << Int32FromInt32(32)
	x = *(*float64)(unsafe.Pointer(bp + 24))
	return x * _twom54
}

func x_scalbn(tls *TLS, x float64, n int32) (r float64) {
	return x_scalbln(tls, x, int64(n))
}

var _two253 = float32(3.3554432e+07)    /* 0x4c000000 */
var _twom25 = float32(2.9802322388e-08) /* 0x33000000 */
var _huge21 = float32(1e+30)
var _tiny9 = float32(1e-30)

func x_scalblnf(tls *TLS, x float32, n int64) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix, k int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* gf_u at bp+4 */ Tieee_float_shape_type
	var _ /* sf_u at bp+12 */ Tieee_float_shape_type
	var _ /* sf_u at bp+8 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp)))
	k = ix & int32(0x7f800000) >> int32(23) /* extract exponent */
	if k == 0 {
		/* 0 or subnormal x */
		if ix&int32(0x7fffffff) == 0 {
			return x
		} /* +-0 */
		x *= _two253
		*(*float32)(unsafe.Pointer(bp + 4)) = x
		ix = int32(*(*uint32)(unsafe.Pointer(bp + 4)))
		k = ix&int32(0x7f800000)>>int32(23) - int32(25)
		if n < int64(-int32(50000)) {
			return _tiny9 * x
		} /*underflow*/
	}
	if k == int32(0xff) {
		return x + x
	} /* NaN or Inf */
	k = int32(int64(k) + n)
	if k > int32(0xfe) {
		return _huge21 * x_copysignf(tls, _huge21, x)
	} /* overflow  */
	if k > 0 {
		/* normal result */
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(ix)&Uint32FromUint32(0x807fffff) | uint32(k<<Int32FromInt32(23))
		x = *(*float32)(unsafe.Pointer(bp + 8))
		return x
	}
	if k <= -int32(25) {
		if n > int64(50000) { /* in case integer overflow in n+k */
			return _huge21 * x_copysignf(tls, _huge21, x)
		} else {
			return _tiny9 * x_copysignf(tls, _tiny9, x)
		} /*underflow*/
	}
	k += int32(25) /* subnormal result */
	*(*uint32)(unsafe.Pointer(bp + 12)) = uint32(ix)&Uint32FromUint32(0x807fffff) | uint32(k<<Int32FromInt32(23))
	x = *(*float32)(unsafe.Pointer(bp + 12))
	return x * _twom25
}

func x_scalbnf(tls *TLS, x float32, n int32) (r float32) {
	return x_scalblnf(tls, x, int64(n))
}

func x_sin(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var ix, n int32
	var z float64
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* y at bp+0 */ [2]float64
	z = float64(0)
	/* High word of x. */
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3fe921fb) {
		return x___kernel_sin(tls, x, z, 0)
	} else {
		if ix >= int32(0x7ff00000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2(tls, x, bp)
			switch n & int32(3) {
			case 0:
				return x___kernel_sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			case int32(1):
				return x___kernel_cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
			case int32(2):
				return -x___kernel_sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			default:
				return -x___kernel_cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
			}
		}
	}
	return r
}

func x_sinf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix, n int32
	var z float32
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* y at bp+0 */ [2]float32
	z = float32(0)
	*(*float32)(unsafe.Pointer(bp + 8)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3f490fd8) {
		return x___kernel_sinf(tls, x, z, 0)
	} else {
		if ix >= int32(0x7f800000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2f(tls, x, bp)
			switch n & int32(3) {
			case 0:
				return x___kernel_sinf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			case int32(1):
				return x___kernel_cosf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)])
			case int32(2):
				return -x___kernel_sinf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)], int32(1))
			default:
				return -x___kernel_cosf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)])
			}
		}
	}
	return r
}

func x_tan(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var ix, n int32
	var z float64
	var _ /* gh_u at bp+16 */ Tieee_double_shape_type
	var _ /* y at bp+0 */ [2]float64
	z = float64(0)
	/* High word of x. */
	*(*float64)(unsafe.Pointer(bp + 16)) = x
	ix = int32(*(*uint64)(unsafe.Pointer(bp + 16)) >> int32(32))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3fe921fb) {
		return x___kernel_tan(tls, x, z, int32(1))
	} else {
		if ix >= int32(0x7ff00000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2(tls, x, bp)
			return x___kernel_tan(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1)-n&int32(1)<<int32(1))
		}
	}
	return r
}

func x_tanf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var ix, n int32
	var z float32
	var _ /* gf_u at bp+8 */ Tieee_float_shape_type
	var _ /* y at bp+0 */ [2]float32
	z = float32(0)
	*(*float32)(unsafe.Pointer(bp + 8)) = x
	ix = int32(*(*uint32)(unsafe.Pointer(bp + 8)))
	/* |x| ~< pi/4 */
	ix &= int32(0x7fffffff)
	if ix <= int32(0x3f490fda) {
		return x___kernel_tanf(tls, x, z, int32(1))
	} else {
		if ix >= int32(0x7f800000) {
			return x - x
		} else {
			n = x___ieee754_rem_pio2f(tls, x, bp)
			return x___kernel_tanf(tls, (*(*[2]float32)(unsafe.Pointer(bp)))[0], (*(*[2]float32)(unsafe.Pointer(bp)))[int32(1)], int32(1)-n&int32(1)<<int32(1))
		}
	}
	return r
}

var _one34 = float64(1)
var _two4 = float64(2)
var _tiny10 = float64(1e-300)

func x_tanh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix, jx int32
	var t, z, v1 float64
	var _ /* gh_u at bp+0 */ Tieee_double_shape_type
	/* High word of |x|. */
	*(*float64)(unsafe.Pointer(bp)) = x
	jx = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	ix = jx & int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7ff00000) {
		if jx >= 0 {
			return _one34/x + _one34
		} else {
			return _one34/x - _one34
		} /* tanh(NaN) = NaN */
	}
	/* |x| < 22 */
	if ix < int32(0x40360000) { /* |x|<22 */
		if ix < int32(0x3c800000) { /* |x|<2**-55 */
			return x * (_one34 + x)
		} /* tanh(small) = small */
		if ix >= int32(0x3ff00000) { /* |x|>=1  */
			t = x_expm1(tls, _two4*x_fabs(tls, x))
			z = _one34 - _two4/(t+_two4)
		} else {
			t = x_expm1(tls, -_two4*x_fabs(tls, x))
			z = -t / (t + _two4)
		}
	} else {
		z = _one34 - _tiny10
	}
	if jx >= 0 {
		v1 = z
	} else {
		v1 = -z
	}
	return v1
}

var _one35 = float32(1)
var _two5 = float32(2)
var _tiny11 = float32(1e-30)

func x_tanhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ix, jx int32
	var t, z, v1 float32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	jx = int32(*(*uint32)(unsafe.Pointer(bp)))
	ix = jx & int32(0x7fffffff)
	/* x is INF or NaN */
	if ix >= int32(0x7f800000) {
		if jx >= 0 {
			return _one35/x + _one35
		} else {
			return _one35/x - _one35
		} /* tanh(NaN) = NaN */
	}
	/* |x| < 22 */
	if ix < int32(0x41b00000) { /* |x|<22 */
		if ix < int32(0x24000000) { /* |x|<2**-55 */
			return x * (_one35 + x)
		} /* tanh(small) = small */
		if ix >= int32(0x3f800000) { /* |x|>=1  */
			t = x_expm1f(tls, _two5*x_fabsf(tls, x))
			z = _one35 - _two5/(t+_two5)
		} else {
			t = x_expm1f(tls, -_two5*x_fabsf(tls, x))
			z = -t / (t + _two5)
		}
	} else {
		z = _one35 - _tiny11
	}
	if jx >= 0 {
		v1 = z
	} else {
		v1 = -z
	}
	return v1
}

var _huge22 = float64(1e+300)

func x_trunc(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var i, j uint32
	var i0, i1, j0 int32
	var _ /* ew_u at bp+0 */ Tieee_double_shape_type
	var _ /* iw_u at bp+8 */ Tieee_double_shape_type
	_ = j
	*(*float64)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(32))
	i1 = int32(uint32(*(*uint64)(unsafe.Pointer(bp))))
	j0 = i0>>Int32FromInt32(20)&int32(0x7ff) - int32(0x3ff)
	if j0 < int32(20) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge22+x > float64(0) {
				/* |x|<1, so return 0*sign(x) */
				i0 = int32(uint32(i0) & Uint32FromUint32(0x80000000))
				i1 = 0
			}
		} else {
			i = uint32(int32(0x000fffff) >> j0)
			if uint32(i0)&i|uint32(i1) == uint32(0) {
				return x
			} /* x is integral */
			if _huge22+x > float64(0) {
				/* raise inexact flag */
				i0 = int32(uint32(i0) & ^i)
				i1 = 0
			}
		}
	} else {
		if j0 > int32(51) {
			if j0 == int32(0x400) {
				return x + x
			} else {
				return x
			}
		} else {
			i = Uint32FromUint32(0xffffffff) >> (j0 - int32(20))
			if uint32(i1)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge22+x > float64(0) { /* raise inexact flag */
				i1 = int32(uint32(i1) & ^i)
			}
		}
	}
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(i0)<<Int32FromInt32(32) | uint64(i1)
	x = *(*float64)(unsafe.Pointer(bp + 8))
	return x
}

var _huge23 = Float32FromFloat32(1e+30)

func x_truncf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var i uint32
	var i0, j0 int32
	var _ /* gf_u at bp+0 */ Tieee_float_shape_type
	var _ /* sf_u at bp+4 */ Tieee_float_shape_type
	*(*float32)(unsafe.Pointer(bp)) = x
	i0 = int32(*(*uint32)(unsafe.Pointer(bp)))
	j0 = i0>>Int32FromInt32(23)&int32(0xff) - int32(0x7f)
	if j0 < int32(23) {
		if j0 < 0 { /* raise inexact if x != 0 */
			if _huge23+x > Float32FromFloat32(0) { /* |x|<1, so return 0*sign(x) */
				i0 = int32(uint32(i0) & Uint32FromUint32(0x80000000))
			}
		} else {
			i = uint32(int32(0x007fffff) >> j0)
			if uint32(i0)&i == uint32(0) {
				return x
			} /* x is integral */
			if _huge23+x > Float32FromFloat32(0) { /* raise inexact flag */
				i0 = int32(uint32(i0) & ^i)
			}
		}
	} else {
		if j0 == int32(0x80) {
			return x + x
		} else {
			return x
		}
	}
	*(*uint32)(unsafe.Pointer(bp + 4)) = uint32(i0)
	x = *(*float32)(unsafe.Pointer(bp + 4))
	return x
}

func x_basename(tls *TLS, s uintptr) (r uintptr) {
	var i uint64
	if !(s != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) {
		return ts + 154
	}
	i = x_strlen(tls, s) - uint64(1)
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) == int32('/'); i-- {
		*(*int8)(unsafe.Pointer(s + uintptr(i))) = 0
	}
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) != int32('/'); i-- {
	}
	return s + uintptr(i)
}

func x_bswap_32(tls *TLS, x uint32) (r uint32) {
	return x>>int32(24) | x>>int32(16)&uint32(0xff00) | x<<int32(16)&uint32(0xff0000) | x<<int32(24)
}

func x_bswap_64(tls *TLS, x uint64) (r uint64) {
	return uint64((int64(x_bswap_32(tls, uint32(x)))+0)<<int32(32) | int64(x_bswap_32(tls, uint32(x>>int32(32)))))
}

const m_DES_OUT_BUFSIZE = 21

func _i64c(tls *TLS, i int32) (r int32) {
	i &= int32(0x3f)
	if i == 0 {
		return int32('.')
	}
	if i == int32(1) {
		return int32('/')
	}
	if i < int32(12) {
		return Int32FromUint8('0') - Int32FromInt32(2) + i
	}
	if i < int32(38) {
		return Int32FromUint8('A') - Int32FromInt32(12) + i
	}
	return Int32FromUint8('a') - Int32FromInt32(38) + i
}

/* Generated by const_des_init() (removed) */

var _final_perm = [64]uint8{
	0:  uint8(0x39),
	1:  uint8(0x31),
	2:  uint8(0x29),
	3:  uint8(0x21),
	4:  uint8(0x19),
	5:  uint8(0x11),
	6:  uint8(0x09),
	7:  uint8(0x01),
	8:  uint8(0x3b),
	9:  uint8(0x33),
	10: uint8(0x2b),
	11: uint8(0x23),
	12: uint8(0x1b),
	13: uint8(0x13),
	14: uint8(0x0b),
	15: uint8(0x03),
	16: uint8(0x3d),
	17: uint8(0x35),
	18: uint8(0x2d),
	19: uint8(0x25),
	20: uint8(0x1d),
	21: uint8(0x15),
	22: uint8(0x0d),
	23: uint8(0x05),
	24: uint8(0x3f),
	25: uint8(0x37),
	26: uint8(0x2f),
	27: uint8(0x27),
	28: uint8(0x1f),
	29: uint8(0x17),
	30: uint8(0x0f),
	31: uint8(0x07),
	32: uint8(0x38),
	33: uint8(0x30),
	34: uint8(0x28),
	35: uint8(0x20),
	36: uint8(0x18),
	37: uint8(0x10),
	38: uint8(0x08),
	39: uint8(0x00),
	40: uint8(0x3a),
	41: uint8(0x32),
	42: uint8(0x2a),
	43: uint8(0x22),
	44: uint8(0x1a),
	45: uint8(0x12),
	46: uint8(0x0a),
	47: uint8(0x02),
	48: uint8(0x3c),
	49: uint8(0x34),
	50: uint8(0x2c),
	51: uint8(0x24),
	52: uint8(0x1c),
	53: uint8(0x14),
	54: uint8(0x0c),
	55: uint8(0x04),
	56: uint8(0x3e),
	57: uint8(0x36),
	58: uint8(0x2e),
	59: uint8(0x26),
	60: uint8(0x1e),
	61: uint8(0x16),
	62: uint8(0x0e),
	63: uint8(0x06)}
var _m_sbox = [4][4096]uint8{
	0: {
		0:    uint8(0xef),
		1:    uint8(0xe3),
		2:    uint8(0xe1),
		3:    uint8(0xed),
		4:    uint8(0xe8),
		5:    uint8(0xe4),
		6:    uint8(0xee),
		7:    uint8(0xe7),
		8:    uint8(0xe6),
		9:    uint8(0xef),
		10:   uint8(0xeb),
		11:   uint8(0xe2),
		12:   uint8(0xe3),
		13:   uint8(0xe8),
		14:   uint8(0xe4),
		15:   uint8(0xee),
		16:   uint8(0xe9),
		17:   uint8(0xec),
		18:   uint8(0xe7),
		19:   uint8(0xe0),
		20:   uint8(0xe2),
		21:   uint8(0xe1),
		22:   uint8(0xed),
		23:   uint8(0xea),
		24:   uint8(0xec),
		25:   uint8(0xe6),
		26:   uint8(0xe0),
		27:   uint8(0xe9),
		28:   uint8(0xe5),
		29:   uint8(0xeb),
		30:   uint8(0xea),
		31:   uint8(0xe5),
		32:   uint8(0xe0),
		33:   uint8(0xed),
		34:   uint8(0xee),
		35:   uint8(0xe8),
		36:   uint8(0xe7),
		37:   uint8(0xea),
		38:   uint8(0xeb),
		39:   uint8(0xe1),
		40:   uint8(0xea),
		41:   uint8(0xe3),
		42:   uint8(0xe4),
		43:   uint8(0xef),
		44:   uint8(0xed),
		45:   uint8(0xe4),
		46:   uint8(0xe1),
		47:   uint8(0xe2),
		48:   uint8(0xe5),
		49:   uint8(0xeb),
		50:   uint8(0xe8),
		51:   uint8(0xe6),
		52:   uint8(0xec),
		53:   uint8(0xe7),
		54:   uint8(0xe6),
		55:   uint8(0xec),
		56:   uint8(0xe9),
		57:   uint8(0xe0),
		58:   uint8(0xe3),
		59:   uint8(0xe5),
		60:   uint8(0xe2),
		61:   uint8(0xee),
		62:   uint8(0xef),
		63:   uint8(0xe9),
		64:   uint8(0x0f),
		65:   uint8(0x03),
		66:   uint8(0x01),
		67:   uint8(0x0d),
		68:   uint8(0x08),
		69:   uint8(0x04),
		70:   uint8(0x0e),
		71:   uint8(0x07),
		72:   uint8(0x06),
		73:   uint8(0x0f),
		74:   uint8(0x0b),
		75:   uint8(0x02),
		76:   uint8(0x03),
		77:   uint8(0x08),
		78:   uint8(0x04),
		79:   uint8(0x0e),
		80:   uint8(0x09),
		81:   uint8(0x0c),
		82:   uint8(0x07),
		83:   uint8(0x00),
		84:   uint8(0x02),
		85:   uint8(0x01),
		86:   uint8(0x0d),
		87:   uint8(0x0a),
		88:   uint8(0x0c),
		89:   uint8(0x06),
		90:   uint8(0x00),
		91:   uint8(0x09),
		92:   uint8(0x05),
		93:   uint8(0x0b),
		94:   uint8(0x0a),
		95:   uint8(0x05),
		96:   uint8(0x00),
		97:   uint8(0x0d),
		98:   uint8(0x0e),
		99:   uint8(0x08),
		100:  uint8(0x07),
		101:  uint8(0x0a),
		102:  uint8(0x0b),
		103:  uint8(0x01),
		104:  uint8(0x0a),
		105:  uint8(0x03),
		106:  uint8(0x04),
		107:  uint8(0x0f),
		108:  uint8(0x0d),
		109:  uint8(0x04),
		110:  uint8(0x01),
		111:  uint8(0x02),
		112:  uint8(0x05),
		113:  uint8(0x0b),
		114:  uint8(0x08),
		115:  uint8(0x06),
		116:  uint8(0x0c),
		117:  uint8(0x07),
		118:  uint8(0x06),
		119:  uint8(0x0c),
		120:  uint8(0x09),
		121:  uint8(0x00),
		122:  uint8(0x03),
		123:  uint8(0x05),
		124:  uint8(0x02),
		125:  uint8(0x0e),
		126:  uint8(0x0f),
		127:  uint8(0x09),
		128:  uint8(0x4f),
		129:  uint8(0x43),
		130:  uint8(0x41),
		131:  uint8(0x4d),
		132:  uint8(0x48),
		133:  uint8(0x44),
		134:  uint8(0x4e),
		135:  uint8(0x47),
		136:  uint8(0x46),
		137:  uint8(0x4f),
		138:  uint8(0x4b),
		139:  uint8(0x42),
		140:  uint8(0x43),
		141:  uint8(0x48),
		142:  uint8(0x44),
		143:  uint8(0x4e),
		144:  uint8(0x49),
		145:  uint8(0x4c),
		146:  uint8(0x47),
		147:  uint8(0x40),
		148:  uint8(0x42),
		149:  uint8(0x41),
		150:  uint8(0x4d),
		151:  uint8(0x4a),
		152:  uint8(0x4c),
		153:  uint8(0x46),
		154:  uint8(0x40),
		155:  uint8(0x49),
		156:  uint8(0x45),
		157:  uint8(0x4b),
		158:  uint8(0x4a),
		159:  uint8(0x45),
		160:  uint8(0x40),
		161:  uint8(0x4d),
		162:  uint8(0x4e),
		163:  uint8(0x48),
		164:  uint8(0x47),
		165:  uint8(0x4a),
		166:  uint8(0x4b),
		167:  uint8(0x41),
		168:  uint8(0x4a),
		169:  uint8(0x43),
		170:  uint8(0x44),
		171:  uint8(0x4f),
		172:  uint8(0x4d),
		173:  uint8(0x44),
		174:  uint8(0x41),
		175:  uint8(0x42),
		176:  uint8(0x45),
		177:  uint8(0x4b),
		178:  uint8(0x48),
		179:  uint8(0x46),
		180:  uint8(0x4c),
		181:  uint8(0x47),
		182:  uint8(0x46),
		183:  uint8(0x4c),
		184:  uint8(0x49),
		185:  uint8(0x40),
		186:  uint8(0x43),
		187:  uint8(0x45),
		188:  uint8(0x42),
		189:  uint8(0x4e),
		190:  uint8(0x4f),
		191:  uint8(0x49),
		192:  uint8(0xff),
		193:  uint8(0xf3),
		194:  uint8(0xf1),
		195:  uint8(0xfd),
		196:  uint8(0xf8),
		197:  uint8(0xf4),
		198:  uint8(0xfe),
		199:  uint8(0xf7),
		200:  uint8(0xf6),
		201:  uint8(0xff),
		202:  uint8(0xfb),
		203:  uint8(0xf2),
		204:  uint8(0xf3),
		205:  uint8(0xf8),
		206:  uint8(0xf4),
		207:  uint8(0xfe),
		208:  uint8(0xf9),
		209:  uint8(0xfc),
		210:  uint8(0xf7),
		211:  uint8(0xf0),
		212:  uint8(0xf2),
		213:  uint8(0xf1),
		214:  uint8(0xfd),
		215:  uint8(0xfa),
		216:  uint8(0xfc),
		217:  uint8(0xf6),
		218:  uint8(0xf0),
		219:  uint8(0xf9),
		220:  uint8(0xf5),
		221:  uint8(0xfb),
		222:  uint8(0xfa),
		223:  uint8(0xf5),
		224:  uint8(0xf0),
		225:  uint8(0xfd),
		226:  uint8(0xfe),
		227:  uint8(0xf8),
		228:  uint8(0xf7),
		229:  uint8(0xfa),
		230:  uint8(0xfb),
		231:  uint8(0xf1),
		232:  uint8(0xfa),
		233:  uint8(0xf3),
		234:  uint8(0xf4),
		235:  uint8(0xff),
		236:  uint8(0xfd),
		237:  uint8(0xf4),
		238:  uint8(0xf1),
		239:  uint8(0xf2),
		240:  uint8(0xf5),
		241:  uint8(0xfb),
		242:  uint8(0xf8),
		243:  uint8(0xf6),
		244:  uint8(0xfc),
		245:  uint8(0xf7),
		246:  uint8(0xf6),
		247:  uint8(0xfc),
		248:  uint8(0xf9),
		249:  uint8(0xf0),
		250:  uint8(0xf3),
		251:  uint8(0xf5),
		252:  uint8(0xf2),
		253:  uint8(0xfe),
		254:  uint8(0xff),
		255:  uint8(0xf9),
		256:  uint8(0xdf),
		257:  uint8(0xd3),
		258:  uint8(0xd1),
		259:  uint8(0xdd),
		260:  uint8(0xd8),
		261:  uint8(0xd4),
		262:  uint8(0xde),
		263:  uint8(0xd7),
		264:  uint8(0xd6),
		265:  uint8(0xdf),
		266:  uint8(0xdb),
		267:  uint8(0xd2),
		268:  uint8(0xd3),
		269:  uint8(0xd8),
		270:  uint8(0xd4),
		271:  uint8(0xde),
		272:  uint8(0xd9),
		273:  uint8(0xdc),
		274:  uint8(0xd7),
		275:  uint8(0xd0),
		276:  uint8(0xd2),
		277:  uint8(0xd1),
		278:  uint8(0xdd),
		279:  uint8(0xda),
		280:  uint8(0xdc),
		281:  uint8(0xd6),
		282:  uint8(0xd0),
		283:  uint8(0xd9),
		284:  uint8(0xd5),
		285:  uint8(0xdb),
		286:  uint8(0xda),
		287:  uint8(0xd5),
		288:  uint8(0xd0),
		289:  uint8(0xdd),
		290:  uint8(0xde),
		291:  uint8(0xd8),
		292:  uint8(0xd7),
		293:  uint8(0xda),
		294:  uint8(0xdb),
		295:  uint8(0xd1),
		296:  uint8(0xda),
		297:  uint8(0xd3),
		298:  uint8(0xd4),
		299:  uint8(0xdf),
		300:  uint8(0xdd),
		301:  uint8(0xd4),
		302:  uint8(0xd1),
		303:  uint8(0xd2),
		304:  uint8(0xd5),
		305:  uint8(0xdb),
		306:  uint8(0xd8),
		307:  uint8(0xd6),
		308:  uint8(0xdc),
		309:  uint8(0xd7),
		310:  uint8(0xd6),
		311:  uint8(0xdc),
		312:  uint8(0xd9),
		313:  uint8(0xd0),
		314:  uint8(0xd3),
		315:  uint8(0xd5),
		316:  uint8(0xd2),
		317:  uint8(0xde),
		318:  uint8(0xdf),
		319:  uint8(0xd9),
		320:  uint8(0x7f),
		321:  uint8(0x73),
		322:  uint8(0x71),
		323:  uint8(0x7d),
		324:  uint8(0x78),
		325:  uint8(0x74),
		326:  uint8(0x7e),
		327:  uint8(0x77),
		328:  uint8(0x76),
		329:  uint8(0x7f),
		330:  uint8(0x7b),
		331:  uint8(0x72),
		332:  uint8(0x73),
		333:  uint8(0x78),
		334:  uint8(0x74),
		335:  uint8(0x7e),
		336:  uint8(0x79),
		337:  uint8(0x7c),
		338:  uint8(0x77),
		339:  uint8(0x70),
		340:  uint8(0x72),
		341:  uint8(0x71),
		342:  uint8(0x7d),
		343:  uint8(0x7a),
		344:  uint8(0x7c),
		345:  uint8(0x76),
		346:  uint8(0x70),
		347:  uint8(0x79),
		348:  uint8(0x75),
		349:  uint8(0x7b),
		350:  uint8(0x7a),
		351:  uint8(0x75),
		352:  uint8(0x70),
		353:  uint8(0x7d),
		354:  uint8(0x7e),
		355:  uint8(0x78),
		356:  uint8(0x77),
		357:  uint8(0x7a),
		358:  uint8(0x7b),
		359:  uint8(0x71),
		360:  uint8(0x7a),
		361:  uint8(0x73),
		362:  uint8(0x74),
		363:  uint8(0x7f),
		364:  uint8(0x7d),
		365:  uint8(0x74),
		366:  uint8(0x71),
		367:  uint8(0x72),
		368:  uint8(0x75),
		369:  uint8(0x7b),
		370:  uint8(0x78),
		371:  uint8(0x76),
		372:  uint8(0x7c),
		373:  uint8(0x77),
		374:  uint8(0x76),
		375:  uint8(0x7c),
		376:  uint8(0x79),
		377:  uint8(0x70),
		378:  uint8(0x73),
		379:  uint8(0x75),
		380:  uint8(0x72),
		381:  uint8(0x7e),
		382:  uint8(0x7f),
		383:  uint8(0x79),
		384:  uint8(0x1f),
		385:  uint8(0x13),
		386:  uint8(0x11),
		387:  uint8(0x1d),
		388:  uint8(0x18),
		389:  uint8(0x14),
		390:  uint8(0x1e),
		391:  uint8(0x17),
		392:  uint8(0x16),
		393:  uint8(0x1f),
		394:  uint8(0x1b),
		395:  uint8(0x12),
		396:  uint8(0x13),
		397:  uint8(0x18),
		398:  uint8(0x14),
		399:  uint8(0x1e),
		400:  uint8(0x19),
		401:  uint8(0x1c),
		402:  uint8(0x17),
		403:  uint8(0x10),
		404:  uint8(0x12),
		405:  uint8(0x11),
		406:  uint8(0x1d),
		407:  uint8(0x1a),
		408:  uint8(0x1c),
		409:  uint8(0x16),
		410:  uint8(0x10),
		411:  uint8(0x19),
		412:  uint8(0x15),
		413:  uint8(0x1b),
		414:  uint8(0x1a),
		415:  uint8(0x15),
		416:  uint8(0x10),
		417:  uint8(0x1d),
		418:  uint8(0x1e),
		419:  uint8(0x18),
		420:  uint8(0x17),
		421:  uint8(0x1a),
		422:  uint8(0x1b),
		423:  uint8(0x11),
		424:  uint8(0x1a),
		425:  uint8(0x13),
		426:  uint8(0x14),
		427:  uint8(0x1f),
		428:  uint8(0x1d),
		429:  uint8(0x14),
		430:  uint8(0x11),
		431:  uint8(0x12),
		432:  uint8(0x15),
		433:  uint8(0x1b),
		434:  uint8(0x18),
		435:  uint8(0x16),
		436:  uint8(0x1c),
		437:  uint8(0x17),
		438:  uint8(0x16),
		439:  uint8(0x1c),
		440:  uint8(0x19),
		441:  uint8(0x10),
		442:  uint8(0x13),
		443:  uint8(0x15),
		444:  uint8(0x12),
		445:  uint8(0x1e),
		446:  uint8(0x1f),
		447:  uint8(0x19),
		448:  uint8(0x4f),
		449:  uint8(0x43),
		450:  uint8(0x41),
		451:  uint8(0x4d),
		452:  uint8(0x48),
		453:  uint8(0x44),
		454:  uint8(0x4e),
		455:  uint8(0x47),
		456:  uint8(0x46),
		457:  uint8(0x4f),
		458:  uint8(0x4b),
		459:  uint8(0x42),
		460:  uint8(0x43),
		461:  uint8(0x48),
		462:  uint8(0x44),
		463:  uint8(0x4e),
		464:  uint8(0x49),
		465:  uint8(0x4c),
		466:  uint8(0x47),
		467:  uint8(0x40),
		468:  uint8(0x42),
		469:  uint8(0x41),
		470:  uint8(0x4d),
		471:  uint8(0x4a),
		472:  uint8(0x4c),
		473:  uint8(0x46),
		474:  uint8(0x40),
		475:  uint8(0x49),
		476:  uint8(0x45),
		477:  uint8(0x4b),
		478:  uint8(0x4a),
		479:  uint8(0x45),
		480:  uint8(0x40),
		481:  uint8(0x4d),
		482:  uint8(0x4e),
		483:  uint8(0x48),
		484:  uint8(0x47),
		485:  uint8(0x4a),
		486:  uint8(0x4b),
		487:  uint8(0x41),
		488:  uint8(0x4a),
		489:  uint8(0x43),
		490:  uint8(0x44),
		491:  uint8(0x4f),
		492:  uint8(0x4d),
		493:  uint8(0x44),
		494:  uint8(0x41),
		495:  uint8(0x42),
		496:  uint8(0x45),
		497:  uint8(0x4b),
		498:  uint8(0x48),
		499:  uint8(0x46),
		500:  uint8(0x4c),
		501:  uint8(0x47),
		502:  uint8(0x46),
		503:  uint8(0x4c),
		504:  uint8(0x49),
		505:  uint8(0x40),
		506:  uint8(0x43),
		507:  uint8(0x45),
		508:  uint8(0x42),
		509:  uint8(0x4e),
		510:  uint8(0x4f),
		511:  uint8(0x49),
		512:  uint8(0x2f),
		513:  uint8(0x23),
		514:  uint8(0x21),
		515:  uint8(0x2d),
		516:  uint8(0x28),
		517:  uint8(0x24),
		518:  uint8(0x2e),
		519:  uint8(0x27),
		520:  uint8(0x26),
		521:  uint8(0x2f),
		522:  uint8(0x2b),
		523:  uint8(0x22),
		524:  uint8(0x23),
		525:  uint8(0x28),
		526:  uint8(0x24),
		527:  uint8(0x2e),
		528:  uint8(0x29),
		529:  uint8(0x2c),
		530:  uint8(0x27),
		531:  uint8(0x20),
		532:  uint8(0x22),
		533:  uint8(0x21),
		534:  uint8(0x2d),
		535:  uint8(0x2a),
		536:  uint8(0x2c),
		537:  uint8(0x26),
		538:  uint8(0x20),
		539:  uint8(0x29),
		540:  uint8(0x25),
		541:  uint8(0x2b),
		542:  uint8(0x2a),
		543:  uint8(0x25),
		544:  uint8(0x20),
		545:  uint8(0x2d),
		546:  uint8(0x2e),
		547:  uint8(0x28),
		548:  uint8(0x27),
		549:  uint8(0x2a),
		550:  uint8(0x2b),
		551:  uint8(0x21),
		552:  uint8(0x2a),
		553:  uint8(0x23),
		554:  uint8(0x24),
		555:  uint8(0x2f),
		556:  uint8(0x2d),
		557:  uint8(0x24),
		558:  uint8(0x21),
		559:  uint8(0x22),
		560:  uint8(0x25),
		561:  uint8(0x2b),
		562:  uint8(0x28),
		563:  uint8(0x26),
		564:  uint8(0x2c),
		565:  uint8(0x27),
		566:  uint8(0x26),
		567:  uint8(0x2c),
		568:  uint8(0x29),
		569:  uint8(0x20),
		570:  uint8(0x23),
		571:  uint8(0x25),
		572:  uint8(0x22),
		573:  uint8(0x2e),
		574:  uint8(0x2f),
		575:  uint8(0x29),
		576:  uint8(0xef),
		577:  uint8(0xe3),
		578:  uint8(0xe1),
		579:  uint8(0xed),
		580:  uint8(0xe8),
		581:  uint8(0xe4),
		582:  uint8(0xee),
		583:  uint8(0xe7),
		584:  uint8(0xe6),
		585:  uint8(0xef),
		586:  uint8(0xeb),
		587:  uint8(0xe2),
		588:  uint8(0xe3),
		589:  uint8(0xe8),
		590:  uint8(0xe4),
		591:  uint8(0xee),
		592:  uint8(0xe9),
		593:  uint8(0xec),
		594:  uint8(0xe7),
		595:  uint8(0xe0),
		596:  uint8(0xe2),
		597:  uint8(0xe1),
		598:  uint8(0xed),
		599:  uint8(0xea),
		600:  uint8(0xec),
		601:  uint8(0xe6),
		602:  uint8(0xe0),
		603:  uint8(0xe9),
		604:  uint8(0xe5),
		605:  uint8(0xeb),
		606:  uint8(0xea),
		607:  uint8(0xe5),
		608:  uint8(0xe0),
		609:  uint8(0xed),
		610:  uint8(0xee),
		611:  uint8(0xe8),
		612:  uint8(0xe7),
		613:  uint8(0xea),
		614:  uint8(0xeb),
		615:  uint8(0xe1),
		616:  uint8(0xea),
		617:  uint8(0xe3),
		618:  uint8(0xe4),
		619:  uint8(0xef),
		620:  uint8(0xed),
		621:  uint8(0xe4),
		622:  uint8(0xe1),
		623:  uint8(0xe2),
		624:  uint8(0xe5),
		625:  uint8(0xeb),
		626:  uint8(0xe8),
		627:  uint8(0xe6),
		628:  uint8(0xec),
		629:  uint8(0xe7),
		630:  uint8(0xe6),
		631:  uint8(0xec),
		632:  uint8(0xe9),
		633:  uint8(0xe0),
		634:  uint8(0xe3),
		635:  uint8(0xe5),
		636:  uint8(0xe2),
		637:  uint8(0xee),
		638:  uint8(0xef),
		639:  uint8(0xe9),
		640:  uint8(0xff),
		641:  uint8(0xf3),
		642:  uint8(0xf1),
		643:  uint8(0xfd),
		644:  uint8(0xf8),
		645:  uint8(0xf4),
		646:  uint8(0xfe),
		647:  uint8(0xf7),
		648:  uint8(0xf6),
		649:  uint8(0xff),
		650:  uint8(0xfb),
		651:  uint8(0xf2),
		652:  uint8(0xf3),
		653:  uint8(0xf8),
		654:  uint8(0xf4),
		655:  uint8(0xfe),
		656:  uint8(0xf9),
		657:  uint8(0xfc),
		658:  uint8(0xf7),
		659:  uint8(0xf0),
		660:  uint8(0xf2),
		661:  uint8(0xf1),
		662:  uint8(0xfd),
		663:  uint8(0xfa),
		664:  uint8(0xfc),
		665:  uint8(0xf6),
		666:  uint8(0xf0),
		667:  uint8(0xf9),
		668:  uint8(0xf5),
		669:  uint8(0xfb),
		670:  uint8(0xfa),
		671:  uint8(0xf5),
		672:  uint8(0xf0),
		673:  uint8(0xfd),
		674:  uint8(0xfe),
		675:  uint8(0xf8),
		676:  uint8(0xf7),
		677:  uint8(0xfa),
		678:  uint8(0xfb),
		679:  uint8(0xf1),
		680:  uint8(0xfa),
		681:  uint8(0xf3),
		682:  uint8(0xf4),
		683:  uint8(0xff),
		684:  uint8(0xfd),
		685:  uint8(0xf4),
		686:  uint8(0xf1),
		687:  uint8(0xf2),
		688:  uint8(0xf5),
		689:  uint8(0xfb),
		690:  uint8(0xf8),
		691:  uint8(0xf6),
		692:  uint8(0xfc),
		693:  uint8(0xf7),
		694:  uint8(0xf6),
		695:  uint8(0xfc),
		696:  uint8(0xf9),
		697:  uint8(0xf0),
		698:  uint8(0xf3),
		699:  uint8(0xf5),
		700:  uint8(0xf2),
		701:  uint8(0xfe),
		702:  uint8(0xff),
		703:  uint8(0xf9),
		704:  uint8(0x2f),
		705:  uint8(0x23),
		706:  uint8(0x21),
		707:  uint8(0x2d),
		708:  uint8(0x28),
		709:  uint8(0x24),
		710:  uint8(0x2e),
		711:  uint8(0x27),
		712:  uint8(0x26),
		713:  uint8(0x2f),
		714:  uint8(0x2b),
		715:  uint8(0x22),
		716:  uint8(0x23),
		717:  uint8(0x28),
		718:  uint8(0x24),
		719:  uint8(0x2e),
		720:  uint8(0x29),
		721:  uint8(0x2c),
		722:  uint8(0x27),
		723:  uint8(0x20),
		724:  uint8(0x22),
		725:  uint8(0x21),
		726:  uint8(0x2d),
		727:  uint8(0x2a),
		728:  uint8(0x2c),
		729:  uint8(0x26),
		730:  uint8(0x20),
		731:  uint8(0x29),
		732:  uint8(0x25),
		733:  uint8(0x2b),
		734:  uint8(0x2a),
		735:  uint8(0x25),
		736:  uint8(0x20),
		737:  uint8(0x2d),
		738:  uint8(0x2e),
		739:  uint8(0x28),
		740:  uint8(0x27),
		741:  uint8(0x2a),
		742:  uint8(0x2b),
		743:  uint8(0x21),
		744:  uint8(0x2a),
		745:  uint8(0x23),
		746:  uint8(0x24),
		747:  uint8(0x2f),
		748:  uint8(0x2d),
		749:  uint8(0x24),
		750:  uint8(0x21),
		751:  uint8(0x22),
		752:  uint8(0x25),
		753:  uint8(0x2b),
		754:  uint8(0x28),
		755:  uint8(0x26),
		756:  uint8(0x2c),
		757:  uint8(0x27),
		758:  uint8(0x26),
		759:  uint8(0x2c),
		760:  uint8(0x29),
		761:  uint8(0x20),
		762:  uint8(0x23),
		763:  uint8(0x25),
		764:  uint8(0x22),
		765:  uint8(0x2e),
		766:  uint8(0x2f),
		767:  uint8(0x29),
		768:  uint8(0xbf),
		769:  uint8(0xb3),
		770:  uint8(0xb1),
		771:  uint8(0xbd),
		772:  uint8(0xb8),
		773:  uint8(0xb4),
		774:  uint8(0xbe),
		775:  uint8(0xb7),
		776:  uint8(0xb6),
		777:  uint8(0xbf),
		778:  uint8(0xbb),
		779:  uint8(0xb2),
		780:  uint8(0xb3),
		781:  uint8(0xb8),
		782:  uint8(0xb4),
		783:  uint8(0xbe),
		784:  uint8(0xb9),
		785:  uint8(0xbc),
		786:  uint8(0xb7),
		787:  uint8(0xb0),
		788:  uint8(0xb2),
		789:  uint8(0xb1),
		790:  uint8(0xbd),
		791:  uint8(0xba),
		792:  uint8(0xbc),
		793:  uint8(0xb6),
		794:  uint8(0xb0),
		795:  uint8(0xb9),
		796:  uint8(0xb5),
		797:  uint8(0xbb),
		798:  uint8(0xba),
		799:  uint8(0xb5),
		800:  uint8(0xb0),
		801:  uint8(0xbd),
		802:  uint8(0xbe),
		803:  uint8(0xb8),
		804:  uint8(0xb7),
		805:  uint8(0xba),
		806:  uint8(0xbb),
		807:  uint8(0xb1),
		808:  uint8(0xba),
		809:  uint8(0xb3),
		810:  uint8(0xb4),
		811:  uint8(0xbf),
		812:  uint8(0xbd),
		813:  uint8(0xb4),
		814:  uint8(0xb1),
		815:  uint8(0xb2),
		816:  uint8(0xb5),
		817:  uint8(0xbb),
		818:  uint8(0xb8),
		819:  uint8(0xb6),
		820:  uint8(0xbc),
		821:  uint8(0xb7),
		822:  uint8(0xb6),
		823:  uint8(0xbc),
		824:  uint8(0xb9),
		825:  uint8(0xb0),
		826:  uint8(0xb3),
		827:  uint8(0xb5),
		828:  uint8(0xb2),
		829:  uint8(0xbe),
		830:  uint8(0xbf),
		831:  uint8(0xb9),
		832:  uint8(0xdf),
		833:  uint8(0xd3),
		834:  uint8(0xd1),
		835:  uint8(0xdd),
		836:  uint8(0xd8),
		837:  uint8(0xd4),
		838:  uint8(0xde),
		839:  uint8(0xd7),
		840:  uint8(0xd6),
		841:  uint8(0xdf),
		842:  uint8(0xdb),
		843:  uint8(0xd2),
		844:  uint8(0xd3),
		845:  uint8(0xd8),
		846:  uint8(0xd4),
		847:  uint8(0xde),
		848:  uint8(0xd9),
		849:  uint8(0xdc),
		850:  uint8(0xd7),
		851:  uint8(0xd0),
		852:  uint8(0xd2),
		853:  uint8(0xd1),
		854:  uint8(0xdd),
		855:  uint8(0xda),
		856:  uint8(0xdc),
		857:  uint8(0xd6),
		858:  uint8(0xd0),
		859:  uint8(0xd9),
		860:  uint8(0xd5),
		861:  uint8(0xdb),
		862:  uint8(0xda),
		863:  uint8(0xd5),
		864:  uint8(0xd0),
		865:  uint8(0xdd),
		866:  uint8(0xde),
		867:  uint8(0xd8),
		868:  uint8(0xd7),
		869:  uint8(0xda),
		870:  uint8(0xdb),
		871:  uint8(0xd1),
		872:  uint8(0xda),
		873:  uint8(0xd3),
		874:  uint8(0xd4),
		875:  uint8(0xdf),
		876:  uint8(0xdd),
		877:  uint8(0xd4),
		878:  uint8(0xd1),
		879:  uint8(0xd2),
		880:  uint8(0xd5),
		881:  uint8(0xdb),
		882:  uint8(0xd8),
		883:  uint8(0xd6),
		884:  uint8(0xdc),
		885:  uint8(0xd7),
		886:  uint8(0xd6),
		887:  uint8(0xdc),
		888:  uint8(0xd9),
		889:  uint8(0xd0),
		890:  uint8(0xd3),
		891:  uint8(0xd5),
		892:  uint8(0xd2),
		893:  uint8(0xde),
		894:  uint8(0xdf),
		895:  uint8(0xd9),
		896:  uint8(0x8f),
		897:  uint8(0x83),
		898:  uint8(0x81),
		899:  uint8(0x8d),
		900:  uint8(0x88),
		901:  uint8(0x84),
		902:  uint8(0x8e),
		903:  uint8(0x87),
		904:  uint8(0x86),
		905:  uint8(0x8f),
		906:  uint8(0x8b),
		907:  uint8(0x82),
		908:  uint8(0x83),
		909:  uint8(0x88),
		910:  uint8(0x84),
		911:  uint8(0x8e),
		912:  uint8(0x89),
		913:  uint8(0x8c),
		914:  uint8(0x87),
		915:  uint8(0x80),
		916:  uint8(0x82),
		917:  uint8(0x81),
		918:  uint8(0x8d),
		919:  uint8(0x8a),
		920:  uint8(0x8c),
		921:  uint8(0x86),
		922:  uint8(0x80),
		923:  uint8(0x89),
		924:  uint8(0x85),
		925:  uint8(0x8b),
		926:  uint8(0x8a),
		927:  uint8(0x85),
		928:  uint8(0x80),
		929:  uint8(0x8d),
		930:  uint8(0x8e),
		931:  uint8(0x88),
		932:  uint8(0x87),
		933:  uint8(0x8a),
		934:  uint8(0x8b),
		935:  uint8(0x81),
		936:  uint8(0x8a),
		937:  uint8(0x83),
		938:  uint8(0x84),
		939:  uint8(0x8f),
		940:  uint8(0x8d),
		941:  uint8(0x84),
		942:  uint8(0x81),
		943:  uint8(0x82),
		944:  uint8(0x85),
		945:  uint8(0x8b),
		946:  uint8(0x88),
		947:  uint8(0x86),
		948:  uint8(0x8c),
		949:  uint8(0x87),
		950:  uint8(0x86),
		951:  uint8(0x8c),
		952:  uint8(0x89),
		953:  uint8(0x80),
		954:  uint8(0x83),
		955:  uint8(0x85),
		956:  uint8(0x82),
		957:  uint8(0x8e),
		958:  uint8(0x8f),
		959:  uint8(0x89),
		960:  uint8(0x1f),
		961:  uint8(0x13),
		962:  uint8(0x11),
		963:  uint8(0x1d),
		964:  uint8(0x18),
		965:  uint8(0x14),
		966:  uint8(0x1e),
		967:  uint8(0x17),
		968:  uint8(0x16),
		969:  uint8(0x1f),
		970:  uint8(0x1b),
		971:  uint8(0x12),
		972:  uint8(0x13),
		973:  uint8(0x18),
		974:  uint8(0x14),
		975:  uint8(0x1e),
		976:  uint8(0x19),
		977:  uint8(0x1c),
		978:  uint8(0x17),
		979:  uint8(0x10),
		980:  uint8(0x12),
		981:  uint8(0x11),
		982:  uint8(0x1d),
		983:  uint8(0x1a),
		984:  uint8(0x1c),
		985:  uint8(0x16),
		986:  uint8(0x10),
		987:  uint8(0x19),
		988:  uint8(0x15),
		989:  uint8(0x1b),
		990:  uint8(0x1a),
		991:  uint8(0x15),
		992:  uint8(0x10),
		993:  uint8(0x1d),
		994:  uint8(0x1e),
		995:  uint8(0x18),
		996:  uint8(0x17),
		997:  uint8(0x1a),
		998:  uint8(0x1b),
		999:  uint8(0x11),
		1000: uint8(0x1a),
		1001: uint8(0x13),
		1002: uint8(0x14),
		1003: uint8(0x1f),
		1004: uint8(0x1d),
		1005: uint8(0x14),
		1006: uint8(0x11),
		1007: uint8(0x12),
		1008: uint8(0x15),
		1009: uint8(0x1b),
		1010: uint8(0x18),
		1011: uint8(0x16),
		1012: uint8(0x1c),
		1013: uint8(0x17),
		1014: uint8(0x16),
		1015: uint8(0x1c),
		1016: uint8(0x19),
		1017: uint8(0x10),
		1018: uint8(0x13),
		1019: uint8(0x15),
		1020: uint8(0x12),
		1021: uint8(0x1e),
		1022: uint8(0x1f),
		1023: uint8(0x19),
		1024: uint8(0x3f),
		1025: uint8(0x33),
		1026: uint8(0x31),
		1027: uint8(0x3d),
		1028: uint8(0x38),
		1029: uint8(0x34),
		1030: uint8(0x3e),
		1031: uint8(0x37),
		1032: uint8(0x36),
		1033: uint8(0x3f),
		1034: uint8(0x3b),
		1035: uint8(0x32),
		1036: uint8(0x33),
		1037: uint8(0x38),
		1038: uint8(0x34),
		1039: uint8(0x3e),
		1040: uint8(0x39),
		1041: uint8(0x3c),
		1042: uint8(0x37),
		1043: uint8(0x30),
		1044: uint8(0x32),
		1045: uint8(0x31),
		1046: uint8(0x3d),
		1047: uint8(0x3a),
		1048: uint8(0x3c),
		1049: uint8(0x36),
		1050: uint8(0x30),
		1051: uint8(0x39),
		1052: uint8(0x35),
		1053: uint8(0x3b),
		1054: uint8(0x3a),
		1055: uint8(0x35),
		1056: uint8(0x30),
		1057: uint8(0x3d),
		1058: uint8(0x3e),
		1059: uint8(0x38),
		1060: uint8(0x37),
		1061: uint8(0x3a),
		1062: uint8(0x3b),
		1063: uint8(0x31),
		1064: uint8(0x3a),
		1065: uint8(0x33),
		1066: uint8(0x34),
		1067: uint8(0x3f),
		1068: uint8(0x3d),
		1069: uint8(0x34),
		1070: uint8(0x31),
		1071: uint8(0x32),
		1072: uint8(0x35),
		1073: uint8(0x3b),
		1074: uint8(0x38),
		1075: uint8(0x36),
		1076: uint8(0x3c),
		1077: uint8(0x37),
		1078: uint8(0x36),
		1079: uint8(0x3c),
		1080: uint8(0x39),
		1081: uint8(0x30),
		1082: uint8(0x33),
		1083: uint8(0x35),
		1084: uint8(0x32),
		1085: uint8(0x3e),
		1086: uint8(0x3f),
		1087: uint8(0x39),
		1088: uint8(0xaf),
		1089: uint8(0xa3),
		1090: uint8(0xa1),
		1091: uint8(0xad),
		1092: uint8(0xa8),
		1093: uint8(0xa4),
		1094: uint8(0xae),
		1095: uint8(0xa7),
		1096: uint8(0xa6),
		1097: uint8(0xaf),
		1098: uint8(0xab),
		1099: uint8(0xa2),
		1100: uint8(0xa3),
		1101: uint8(0xa8),
		1102: uint8(0xa4),
		1103: uint8(0xae),
		1104: uint8(0xa9),
		1105: uint8(0xac),
		1106: uint8(0xa7),
		1107: uint8(0xa0),
		1108: uint8(0xa2),
		1109: uint8(0xa1),
		1110: uint8(0xad),
		1111: uint8(0xaa),
		1112: uint8(0xac),
		1113: uint8(0xa6),
		1114: uint8(0xa0),
		1115: uint8(0xa9),
		1116: uint8(0xa5),
		1117: uint8(0xab),
		1118: uint8(0xaa),
		1119: uint8(0xa5),
		1120: uint8(0xa0),
		1121: uint8(0xad),
		1122: uint8(0xae),
		1123: uint8(0xa8),
		1124: uint8(0xa7),
		1125: uint8(0xaa),
		1126: uint8(0xab),
		1127: uint8(0xa1),
		1128: uint8(0xaa),
		1129: uint8(0xa3),
		1130: uint8(0xa4),
		1131: uint8(0xaf),
		1132: uint8(0xad),
		1133: uint8(0xa4),
		1134: uint8(0xa1),
		1135: uint8(0xa2),
		1136: uint8(0xa5),
		1137: uint8(0xab),
		1138: uint8(0xa8),
		1139: uint8(0xa6),
		1140: uint8(0xac),
		1141: uint8(0xa7),
		1142: uint8(0xa6),
		1143: uint8(0xac),
		1144: uint8(0xa9),
		1145: uint8(0xa0),
		1146: uint8(0xa3),
		1147: uint8(0xa5),
		1148: uint8(0xa2),
		1149: uint8(0xae),
		1150: uint8(0xaf),
		1151: uint8(0xa9),
		1152: uint8(0xaf),
		1153: uint8(0xa3),
		1154: uint8(0xa1),
		1155: uint8(0xad),
		1156: uint8(0xa8),
		1157: uint8(0xa4),
		1158: uint8(0xae),
		1159: uint8(0xa7),
		1160: uint8(0xa6),
		1161: uint8(0xaf),
		1162: uint8(0xab),
		1163: uint8(0xa2),
		1164: uint8(0xa3),
		1165: uint8(0xa8),
		1166: uint8(0xa4),
		1167: uint8(0xae),
		1168: uint8(0xa9),
		1169: uint8(0xac),
		1170: uint8(0xa7),
		1171: uint8(0xa0),
		1172: uint8(0xa2),
		1173: uint8(0xa1),
		1174: uint8(0xad),
		1175: uint8(0xaa),
		1176: uint8(0xac),
		1177: uint8(0xa6),
		1178: uint8(0xa0),
		1179: uint8(0xa9),
		1180: uint8(0xa5),
		1181: uint8(0xab),
		1182: uint8(0xaa),
		1183: uint8(0xa5),
		1184: uint8(0xa0),
		1185: uint8(0xad),
		1186: uint8(0xae),
		1187: uint8(0xa8),
		1188: uint8(0xa7),
		1189: uint8(0xaa),
		1190: uint8(0xab),
		1191: uint8(0xa1),
		1192: uint8(0xaa),
		1193: uint8(0xa3),
		1194: uint8(0xa4),
		1195: uint8(0xaf),
		1196: uint8(0xad),
		1197: uint8(0xa4),
		1198: uint8(0xa1),
		1199: uint8(0xa2),
		1200: uint8(0xa5),
		1201: uint8(0xab),
		1202: uint8(0xa8),
		1203: uint8(0xa6),
		1204: uint8(0xac),
		1205: uint8(0xa7),
		1206: uint8(0xa6),
		1207: uint8(0xac),
		1208: uint8(0xa9),
		1209: uint8(0xa0),
		1210: uint8(0xa3),
		1211: uint8(0xa5),
		1212: uint8(0xa2),
		1213: uint8(0xae),
		1214: uint8(0xaf),
		1215: uint8(0xa9),
		1216: uint8(0x6f),
		1217: uint8(0x63),
		1218: uint8(0x61),
		1219: uint8(0x6d),
		1220: uint8(0x68),
		1221: uint8(0x64),
		1222: uint8(0x6e),
		1223: uint8(0x67),
		1224: uint8(0x66),
		1225: uint8(0x6f),
		1226: uint8(0x6b),
		1227: uint8(0x62),
		1228: uint8(0x63),
		1229: uint8(0x68),
		1230: uint8(0x64),
		1231: uint8(0x6e),
		1232: uint8(0x69),
		1233: uint8(0x6c),
		1234: uint8(0x67),
		1235: uint8(0x60),
		1236: uint8(0x62),
		1237: uint8(0x61),
		1238: uint8(0x6d),
		1239: uint8(0x6a),
		1240: uint8(0x6c),
		1241: uint8(0x66),
		1242: uint8(0x60),
		1243: uint8(0x69),
		1244: uint8(0x65),
		1245: uint8(0x6b),
		1246: uint8(0x6a),
		1247: uint8(0x65),
		1248: uint8(0x60),
		1249: uint8(0x6d),
		1250: uint8(0x6e),
		1251: uint8(0x68),
		1252: uint8(0x67),
		1253: uint8(0x6a),
		1254: uint8(0x6b),
		1255: uint8(0x61),
		1256: uint8(0x6a),
		1257: uint8(0x63),
		1258: uint8(0x64),
		1259: uint8(0x6f),
		1260: uint8(0x6d),
		1261: uint8(0x64),
		1262: uint8(0x61),
		1263: uint8(0x62),
		1264: uint8(0x65),
		1265: uint8(0x6b),
		1266: uint8(0x68),
		1267: uint8(0x66),
		1268: uint8(0x6c),
		1269: uint8(0x67),
		1270: uint8(0x66),
		1271: uint8(0x6c),
		1272: uint8(0x69),
		1273: uint8(0x60),
		1274: uint8(0x63),
		1275: uint8(0x65),
		1276: uint8(0x62),
		1277: uint8(0x6e),
		1278: uint8(0x6f),
		1279: uint8(0x69),
		1280: uint8(0x6f),
		1281: uint8(0x63),
		1282: uint8(0x61),
		1283: uint8(0x6d),
		1284: uint8(0x68),
		1285: uint8(0x64),
		1286: uint8(0x6e),
		1287: uint8(0x67),
		1288: uint8(0x66),
		1289: uint8(0x6f),
		1290: uint8(0x6b),
		1291: uint8(0x62),
		1292: uint8(0x63),
		1293: uint8(0x68),
		1294: uint8(0x64),
		1295: uint8(0x6e),
		1296: uint8(0x69),
		1297: uint8(0x6c),
		1298: uint8(0x67),
		1299: uint8(0x60),
		1300: uint8(0x62),
		1301: uint8(0x61),
		1302: uint8(0x6d),
		1303: uint8(0x6a),
		1304: uint8(0x6c),
		1305: uint8(0x66),
		1306: uint8(0x60),
		1307: uint8(0x69),
		1308: uint8(0x65),
		1309: uint8(0x6b),
		1310: uint8(0x6a),
		1311: uint8(0x65),
		1312: uint8(0x60),
		1313: uint8(0x6d),
		1314: uint8(0x6e),
		1315: uint8(0x68),
		1316: uint8(0x67),
		1317: uint8(0x6a),
		1318: uint8(0x6b),
		1319: uint8(0x61),
		1320: uint8(0x6a),
		1321: uint8(0x63),
		1322: uint8(0x64),
		1323: uint8(0x6f),
		1324: uint8(0x6d),
		1325: uint8(0x64),
		1326: uint8(0x61),
		1327: uint8(0x62),
		1328: uint8(0x65),
		1329: uint8(0x6b),
		1330: uint8(0x68),
		1331: uint8(0x66),
		1332: uint8(0x6c),
		1333: uint8(0x67),
		1334: uint8(0x66),
		1335: uint8(0x6c),
		1336: uint8(0x69),
		1337: uint8(0x60),
		1338: uint8(0x63),
		1339: uint8(0x65),
		1340: uint8(0x62),
		1341: uint8(0x6e),
		1342: uint8(0x6f),
		1343: uint8(0x69),
		1344: uint8(0xcf),
		1345: uint8(0xc3),
		1346: uint8(0xc1),
		1347: uint8(0xcd),
		1348: uint8(0xc8),
		1349: uint8(0xc4),
		1350: uint8(0xce),
		1351: uint8(0xc7),
		1352: uint8(0xc6),
		1353: uint8(0xcf),
		1354: uint8(0xcb),
		1355: uint8(0xc2),
		1356: uint8(0xc3),
		1357: uint8(0xc8),
		1358: uint8(0xc4),
		1359: uint8(0xce),
		1360: uint8(0xc9),
		1361: uint8(0xcc),
		1362: uint8(0xc7),
		1363: uint8(0xc0),
		1364: uint8(0xc2),
		1365: uint8(0xc1),
		1366: uint8(0xcd),
		1367: uint8(0xca),
		1368: uint8(0xcc),
		1369: uint8(0xc6),
		1370: uint8(0xc0),
		1371: uint8(0xc9),
		1372: uint8(0xc5),
		1373: uint8(0xcb),
		1374: uint8(0xca),
		1375: uint8(0xc5),
		1376: uint8(0xc0),
		1377: uint8(0xcd),
		1378: uint8(0xce),
		1379: uint8(0xc8),
		1380: uint8(0xc7),
		1381: uint8(0xca),
		1382: uint8(0xcb),
		1383: uint8(0xc1),
		1384: uint8(0xca),
		1385: uint8(0xc3),
		1386: uint8(0xc4),
		1387: uint8(0xcf),
		1388: uint8(0xcd),
		1389: uint8(0xc4),
		1390: uint8(0xc1),
		1391: uint8(0xc2),
		1392: uint8(0xc5),
		1393: uint8(0xcb),
		1394: uint8(0xc8),
		1395: uint8(0xc6),
		1396: uint8(0xcc),
		1397: uint8(0xc7),
		1398: uint8(0xc6),
		1399: uint8(0xcc),
		1400: uint8(0xc9),
		1401: uint8(0xc0),
		1402: uint8(0xc3),
		1403: uint8(0xc5),
		1404: uint8(0xc2),
		1405: uint8(0xce),
		1406: uint8(0xcf),
		1407: uint8(0xc9),
		1408: uint8(0xcf),
		1409: uint8(0xc3),
		1410: uint8(0xc1),
		1411: uint8(0xcd),
		1412: uint8(0xc8),
		1413: uint8(0xc4),
		1414: uint8(0xce),
		1415: uint8(0xc7),
		1416: uint8(0xc6),
		1417: uint8(0xcf),
		1418: uint8(0xcb),
		1419: uint8(0xc2),
		1420: uint8(0xc3),
		1421: uint8(0xc8),
		1422: uint8(0xc4),
		1423: uint8(0xce),
		1424: uint8(0xc9),
		1425: uint8(0xcc),
		1426: uint8(0xc7),
		1427: uint8(0xc0),
		1428: uint8(0xc2),
		1429: uint8(0xc1),
		1430: uint8(0xcd),
		1431: uint8(0xca),
		1432: uint8(0xcc),
		1433: uint8(0xc6),
		1434: uint8(0xc0),
		1435: uint8(0xc9),
		1436: uint8(0xc5),
		1437: uint8(0xcb),
		1438: uint8(0xca),
		1439: uint8(0xc5),
		1440: uint8(0xc0),
		1441: uint8(0xcd),
		1442: uint8(0xce),
		1443: uint8(0xc8),
		1444: uint8(0xc7),
		1445: uint8(0xca),
		1446: uint8(0xcb),
		1447: uint8(0xc1),
		1448: uint8(0xca),
		1449: uint8(0xc3),
		1450: uint8(0xc4),
		1451: uint8(0xcf),
		1452: uint8(0xcd),
		1453: uint8(0xc4),
		1454: uint8(0xc1),
		1455: uint8(0xc2),
		1456: uint8(0xc5),
		1457: uint8(0xcb),
		1458: uint8(0xc8),
		1459: uint8(0xc6),
		1460: uint8(0xcc),
		1461: uint8(0xc7),
		1462: uint8(0xc6),
		1463: uint8(0xcc),
		1464: uint8(0xc9),
		1465: uint8(0xc0),
		1466: uint8(0xc3),
		1467: uint8(0xc5),
		1468: uint8(0xc2),
		1469: uint8(0xce),
		1470: uint8(0xcf),
		1471: uint8(0xc9),
		1472: uint8(0xbf),
		1473: uint8(0xb3),
		1474: uint8(0xb1),
		1475: uint8(0xbd),
		1476: uint8(0xb8),
		1477: uint8(0xb4),
		1478: uint8(0xbe),
		1479: uint8(0xb7),
		1480: uint8(0xb6),
		1481: uint8(0xbf),
		1482: uint8(0xbb),
		1483: uint8(0xb2),
		1484: uint8(0xb3),
		1485: uint8(0xb8),
		1486: uint8(0xb4),
		1487: uint8(0xbe),
		1488: uint8(0xb9),
		1489: uint8(0xbc),
		1490: uint8(0xb7),
		1491: uint8(0xb0),
		1492: uint8(0xb2),
		1493: uint8(0xb1),
		1494: uint8(0xbd),
		1495: uint8(0xba),
		1496: uint8(0xbc),
		1497: uint8(0xb6),
		1498: uint8(0xb0),
		1499: uint8(0xb9),
		1500: uint8(0xb5),
		1501: uint8(0xbb),
		1502: uint8(0xba),
		1503: uint8(0xb5),
		1504: uint8(0xb0),
		1505: uint8(0xbd),
		1506: uint8(0xbe),
		1507: uint8(0xb8),
		1508: uint8(0xb7),
		1509: uint8(0xba),
		1510: uint8(0xbb),
		1511: uint8(0xb1),
		1512: uint8(0xba),
		1513: uint8(0xb3),
		1514: uint8(0xb4),
		1515: uint8(0xbf),
		1516: uint8(0xbd),
		1517: uint8(0xb4),
		1518: uint8(0xb1),
		1519: uint8(0xb2),
		1520: uint8(0xb5),
		1521: uint8(0xbb),
		1522: uint8(0xb8),
		1523: uint8(0xb6),
		1524: uint8(0xbc),
		1525: uint8(0xb7),
		1526: uint8(0xb6),
		1527: uint8(0xbc),
		1528: uint8(0xb9),
		1529: uint8(0xb0),
		1530: uint8(0xb3),
		1531: uint8(0xb5),
		1532: uint8(0xb2),
		1533: uint8(0xbe),
		1534: uint8(0xbf),
		1535: uint8(0xb9),
		1536: uint8(0x5f),
		1537: uint8(0x53),
		1538: uint8(0x51),
		1539: uint8(0x5d),
		1540: uint8(0x58),
		1541: uint8(0x54),
		1542: uint8(0x5e),
		1543: uint8(0x57),
		1544: uint8(0x56),
		1545: uint8(0x5f),
		1546: uint8(0x5b),
		1547: uint8(0x52),
		1548: uint8(0x53),
		1549: uint8(0x58),
		1550: uint8(0x54),
		1551: uint8(0x5e),
		1552: uint8(0x59),
		1553: uint8(0x5c),
		1554: uint8(0x57),
		1555: uint8(0x50),
		1556: uint8(0x52),
		1557: uint8(0x51),
		1558: uint8(0x5d),
		1559: uint8(0x5a),
		1560: uint8(0x5c),
		1561: uint8(0x56),
		1562: uint8(0x50),
		1563: uint8(0x59),
		1564: uint8(0x55),
		1565: uint8(0x5b),
		1566: uint8(0x5a),
		1567: uint8(0x55),
		1568: uint8(0x50),
		1569: uint8(0x5d),
		1570: uint8(0x5e),
		1571: uint8(0x58),
		1572: uint8(0x57),
		1573: uint8(0x5a),
		1574: uint8(0x5b),
		1575: uint8(0x51),
		1576: uint8(0x5a),
		1577: uint8(0x53),
		1578: uint8(0x54),
		1579: uint8(0x5f),
		1580: uint8(0x5d),
		1581: uint8(0x54),
		1582: uint8(0x51),
		1583: uint8(0x52),
		1584: uint8(0x55),
		1585: uint8(0x5b),
		1586: uint8(0x58),
		1587: uint8(0x56),
		1588: uint8(0x5c),
		1589: uint8(0x57),
		1590: uint8(0x56),
		1591: uint8(0x5c),
		1592: uint8(0x59),
		1593: uint8(0x50),
		1594: uint8(0x53),
		1595: uint8(0x55),
		1596: uint8(0x52),
		1597: uint8(0x5e),
		1598: uint8(0x5f),
		1599: uint8(0x59),
		1600: uint8(0x9f),
		1601: uint8(0x93),
		1602: uint8(0x91),
		1603: uint8(0x9d),
		1604: uint8(0x98),
		1605: uint8(0x94),
		1606: uint8(0x9e),
		1607: uint8(0x97),
		1608: uint8(0x96),
		1609: uint8(0x9f),
		1610: uint8(0x9b),
		1611: uint8(0x92),
		1612: uint8(0x93),
		1613: uint8(0x98),
		1614: uint8(0x94),
		1615: uint8(0x9e),
		1616: uint8(0x99),
		1617: uint8(0x9c),
		1618: uint8(0x97),
		1619: uint8(0x90),
		1620: uint8(0x92),
		1621: uint8(0x91),
		1622: uint8(0x9d),
		1623: uint8(0x9a),
		1624: uint8(0x9c),
		1625: uint8(0x96),
		1626: uint8(0x90),
		1627: uint8(0x99),
		1628: uint8(0x95),
		1629: uint8(0x9b),
		1630: uint8(0x9a),
		1631: uint8(0x95),
		1632: uint8(0x90),
		1633: uint8(0x9d),
		1634: uint8(0x9e),
		1635: uint8(0x98),
		1636: uint8(0x97),
		1637: uint8(0x9a),
		1638: uint8(0x9b),
		1639: uint8(0x91),
		1640: uint8(0x9a),
		1641: uint8(0x93),
		1642: uint8(0x94),
		1643: uint8(0x9f),
		1644: uint8(0x9d),
		1645: uint8(0x94),
		1646: uint8(0x91),
		1647: uint8(0x92),
		1648: uint8(0x95),
		1649: uint8(0x9b),
		1650: uint8(0x98),
		1651: uint8(0x96),
		1652: uint8(0x9c),
		1653: uint8(0x97),
		1654: uint8(0x96),
		1655: uint8(0x9c),
		1656: uint8(0x99),
		1657: uint8(0x90),
		1658: uint8(0x93),
		1659: uint8(0x95),
		1660: uint8(0x92),
		1661: uint8(0x9e),
		1662: uint8(0x9f),
		1663: uint8(0x99),
		1664: uint8(0x9f),
		1665: uint8(0x93),
		1666: uint8(0x91),
		1667: uint8(0x9d),
		1668: uint8(0x98),
		1669: uint8(0x94),
		1670: uint8(0x9e),
		1671: uint8(0x97),
		1672: uint8(0x96),
		1673: uint8(0x9f),
		1674: uint8(0x9b),
		1675: uint8(0x92),
		1676: uint8(0x93),
		1677: uint8(0x98),
		1678: uint8(0x94),
		1679: uint8(0x9e),
		1680: uint8(0x99),
		1681: uint8(0x9c),
		1682: uint8(0x97),
		1683: uint8(0x90),
		1684: uint8(0x92),
		1685: uint8(0x91),
		1686: uint8(0x9d),
		1687: uint8(0x9a),
		1688: uint8(0x9c),
		1689: uint8(0x96),
		1690: uint8(0x90),
		1691: uint8(0x99),
		1692: uint8(0x95),
		1693: uint8(0x9b),
		1694: uint8(0x9a),
		1695: uint8(0x95),
		1696: uint8(0x90),
		1697: uint8(0x9d),
		1698: uint8(0x9e),
		1699: uint8(0x98),
		1700: uint8(0x97),
		1701: uint8(0x9a),
		1702: uint8(0x9b),
		1703: uint8(0x91),
		1704: uint8(0x9a),
		1705: uint8(0x93),
		1706: uint8(0x94),
		1707: uint8(0x9f),
		1708: uint8(0x9d),
		1709: uint8(0x94),
		1710: uint8(0x91),
		1711: uint8(0x92),
		1712: uint8(0x95),
		1713: uint8(0x9b),
		1714: uint8(0x98),
		1715: uint8(0x96),
		1716: uint8(0x9c),
		1717: uint8(0x97),
		1718: uint8(0x96),
		1719: uint8(0x9c),
		1720: uint8(0x99),
		1721: uint8(0x90),
		1722: uint8(0x93),
		1723: uint8(0x95),
		1724: uint8(0x92),
		1725: uint8(0x9e),
		1726: uint8(0x9f),
		1727: uint8(0x99),
		1728: uint8(0x5f),
		1729: uint8(0x53),
		1730: uint8(0x51),
		1731: uint8(0x5d),
		1732: uint8(0x58),
		1733: uint8(0x54),
		1734: uint8(0x5e),
		1735: uint8(0x57),
		1736: uint8(0x56),
		1737: uint8(0x5f),
		1738: uint8(0x5b),
		1739: uint8(0x52),
		1740: uint8(0x53),
		1741: uint8(0x58),
		1742: uint8(0x54),
		1743: uint8(0x5e),
		1744: uint8(0x59),
		1745: uint8(0x5c),
		1746: uint8(0x57),
		1747: uint8(0x50),
		1748: uint8(0x52),
		1749: uint8(0x51),
		1750: uint8(0x5d),
		1751: uint8(0x5a),
		1752: uint8(0x5c),
		1753: uint8(0x56),
		1754: uint8(0x50),
		1755: uint8(0x59),
		1756: uint8(0x55),
		1757: uint8(0x5b),
		1758: uint8(0x5a),
		1759: uint8(0x55),
		1760: uint8(0x50),
		1761: uint8(0x5d),
		1762: uint8(0x5e),
		1763: uint8(0x58),
		1764: uint8(0x57),
		1765: uint8(0x5a),
		1766: uint8(0x5b),
		1767: uint8(0x51),
		1768: uint8(0x5a),
		1769: uint8(0x53),
		1770: uint8(0x54),
		1771: uint8(0x5f),
		1772: uint8(0x5d),
		1773: uint8(0x54),
		1774: uint8(0x51),
		1775: uint8(0x52),
		1776: uint8(0x55),
		1777: uint8(0x5b),
		1778: uint8(0x58),
		1779: uint8(0x56),
		1780: uint8(0x5c),
		1781: uint8(0x57),
		1782: uint8(0x56),
		1783: uint8(0x5c),
		1784: uint8(0x59),
		1785: uint8(0x50),
		1786: uint8(0x53),
		1787: uint8(0x55),
		1788: uint8(0x52),
		1789: uint8(0x5e),
		1790: uint8(0x5f),
		1791: uint8(0x59),
		1792: uint8(0x0f),
		1793: uint8(0x03),
		1794: uint8(0x01),
		1795: uint8(0x0d),
		1796: uint8(0x08),
		1797: uint8(0x04),
		1798: uint8(0x0e),
		1799: uint8(0x07),
		1800: uint8(0x06),
		1801: uint8(0x0f),
		1802: uint8(0x0b),
		1803: uint8(0x02),
		1804: uint8(0x03),
		1805: uint8(0x08),
		1806: uint8(0x04),
		1807: uint8(0x0e),
		1808: uint8(0x09),
		1809: uint8(0x0c),
		1810: uint8(0x07),
		1811: uint8(0x00),
		1812: uint8(0x02),
		1813: uint8(0x01),
		1814: uint8(0x0d),
		1815: uint8(0x0a),
		1816: uint8(0x0c),
		1817: uint8(0x06),
		1818: uint8(0x00),
		1819: uint8(0x09),
		1820: uint8(0x05),
		1821: uint8(0x0b),
		1822: uint8(0x0a),
		1823: uint8(0x05),
		1824: uint8(0x00),
		1825: uint8(0x0d),
		1826: uint8(0x0e),
		1827: uint8(0x08),
		1828: uint8(0x07),
		1829: uint8(0x0a),
		1830: uint8(0x0b),
		1831: uint8(0x01),
		1832: uint8(0x0a),
		1833: uint8(0x03),
		1834: uint8(0x04),
		1835: uint8(0x0f),
		1836: uint8(0x0d),
		1837: uint8(0x04),
		1838: uint8(0x01),
		1839: uint8(0x02),
		1840: uint8(0x05),
		1841: uint8(0x0b),
		1842: uint8(0x08),
		1843: uint8(0x06),
		1844: uint8(0x0c),
		1845: uint8(0x07),
		1846: uint8(0x06),
		1847: uint8(0x0c),
		1848: uint8(0x09),
		1849: uint8(0x00),
		1850: uint8(0x03),
		1851: uint8(0x05),
		1852: uint8(0x02),
		1853: uint8(0x0e),
		1854: uint8(0x0f),
		1855: uint8(0x09),
		1856: uint8(0x3f),
		1857: uint8(0x33),
		1858: uint8(0x31),
		1859: uint8(0x3d),
		1860: uint8(0x38),
		1861: uint8(0x34),
		1862: uint8(0x3e),
		1863: uint8(0x37),
		1864: uint8(0x36),
		1865: uint8(0x3f),
		1866: uint8(0x3b),
		1867: uint8(0x32),
		1868: uint8(0x33),
		1869: uint8(0x38),
		1870: uint8(0x34),
		1871: uint8(0x3e),
		1872: uint8(0x39),
		1873: uint8(0x3c),
		1874: uint8(0x37),
		1875: uint8(0x30),
		1876: uint8(0x32),
		1877: uint8(0x31),
		1878: uint8(0x3d),
		1879: uint8(0x3a),
		1880: uint8(0x3c),
		1881: uint8(0x36),
		1882: uint8(0x30),
		1883: uint8(0x39),
		1884: uint8(0x35),
		1885: uint8(0x3b),
		1886: uint8(0x3a),
		1887: uint8(0x35),
		1888: uint8(0x30),
		1889: uint8(0x3d),
		1890: uint8(0x3e),
		1891: uint8(0x38),
		1892: uint8(0x37),
		1893: uint8(0x3a),
		1894: uint8(0x3b),
		1895: uint8(0x31),
		1896: uint8(0x3a),
		1897: uint8(0x33),
		1898: uint8(0x34),
		1899: uint8(0x3f),
		1900: uint8(0x3d),
		1901: uint8(0x34),
		1902: uint8(0x31),
		1903: uint8(0x32),
		1904: uint8(0x35),
		1905: uint8(0x3b),
		1906: uint8(0x38),
		1907: uint8(0x36),
		1908: uint8(0x3c),
		1909: uint8(0x37),
		1910: uint8(0x36),
		1911: uint8(0x3c),
		1912: uint8(0x39),
		1913: uint8(0x30),
		1914: uint8(0x33),
		1915: uint8(0x35),
		1916: uint8(0x32),
		1917: uint8(0x3e),
		1918: uint8(0x3f),
		1919: uint8(0x39),
		1920: uint8(0x7f),
		1921: uint8(0x73),
		1922: uint8(0x71),
		1923: uint8(0x7d),
		1924: uint8(0x78),
		1925: uint8(0x74),
		1926: uint8(0x7e),
		1927: uint8(0x77),
		1928: uint8(0x76),
		1929: uint8(0x7f),
		1930: uint8(0x7b),
		1931: uint8(0x72),
		1932: uint8(0x73),
		1933: uint8(0x78),
		1934: uint8(0x74),
		1935: uint8(0x7e),
		1936: uint8(0x79),
		1937: uint8(0x7c),
		1938: uint8(0x77),
		1939: uint8(0x70),
		1940: uint8(0x72),
		1941: uint8(0x71),
		1942: uint8(0x7d),
		1943: uint8(0x7a),
		1944: uint8(0x7c),
		1945: uint8(0x76),
		1946: uint8(0x70),
		1947: uint8(0x79),
		1948: uint8(0x75),
		1949: uint8(0x7b),
		1950: uint8(0x7a),
		1951: uint8(0x75),
		1952: uint8(0x70),
		1953: uint8(0x7d),
		1954: uint8(0x7e),
		1955: uint8(0x78),
		1956: uint8(0x77),
		1957: uint8(0x7a),
		1958: uint8(0x7b),
		1959: uint8(0x71),
		1960: uint8(0x7a),
		1961: uint8(0x73),
		1962: uint8(0x74),
		1963: uint8(0x7f),
		1964: uint8(0x7d),
		1965: uint8(0x74),
		1966: uint8(0x71),
		1967: uint8(0x72),
		1968: uint8(0x75),
		1969: uint8(0x7b),
		1970: uint8(0x78),
		1971: uint8(0x76),
		1972: uint8(0x7c),
		1973: uint8(0x77),
		1974: uint8(0x76),
		1975: uint8(0x7c),
		1976: uint8(0x79),
		1977: uint8(0x70),
		1978: uint8(0x73),
		1979: uint8(0x75),
		1980: uint8(0x72),
		1981: uint8(0x7e),
		1982: uint8(0x7f),
		1983: uint8(0x79),
		1984: uint8(0x8f),
		1985: uint8(0x83),
		1986: uint8(0x81),
		1987: uint8(0x8d),
		1988: uint8(0x88),
		1989: uint8(0x84),
		1990: uint8(0x8e),
		1991: uint8(0x87),
		1992: uint8(0x86),
		1993: uint8(0x8f),
		1994: uint8(0x8b),
		1995: uint8(0x82),
		1996: uint8(0x83),
		1997: uint8(0x88),
		1998: uint8(0x84),
		1999: uint8(0x8e),
		2000: uint8(0x89),
		2001: uint8(0x8c),
		2002: uint8(0x87),
		2003: uint8(0x80),
		2004: uint8(0x82),
		2005: uint8(0x81),
		2006: uint8(0x8d),
		2007: uint8(0x8a),
		2008: uint8(0x8c),
		2009: uint8(0x86),
		2010: uint8(0x80),
		2011: uint8(0x89),
		2012: uint8(0x85),
		2013: uint8(0x8b),
		2014: uint8(0x8a),
		2015: uint8(0x85),
		2016: uint8(0x80),
		2017: uint8(0x8d),
		2018: uint8(0x8e),
		2019: uint8(0x88),
		2020: uint8(0x87),
		2021: uint8(0x8a),
		2022: uint8(0x8b),
		2023: uint8(0x81),
		2024: uint8(0x8a),
		2025: uint8(0x83),
		2026: uint8(0x84),
		2027: uint8(0x8f),
		2028: uint8(0x8d),
		2029: uint8(0x84),
		2030: uint8(0x81),
		2031: uint8(0x82),
		2032: uint8(0x85),
		2033: uint8(0x8b),
		2034: uint8(0x88),
		2035: uint8(0x86),
		2036: uint8(0x8c),
		2037: uint8(0x87),
		2038: uint8(0x86),
		2039: uint8(0x8c),
		2040: uint8(0x89),
		2041: uint8(0x80),
		2042: uint8(0x83),
		2043: uint8(0x85),
		2044: uint8(0x82),
		2045: uint8(0x8e),
		2046: uint8(0x8f),
		2047: uint8(0x89),
		2048: uint8(0x4f),
		2049: uint8(0x43),
		2050: uint8(0x41),
		2051: uint8(0x4d),
		2052: uint8(0x48),
		2053: uint8(0x44),
		2054: uint8(0x4e),
		2055: uint8(0x47),
		2056: uint8(0x46),
		2057: uint8(0x4f),
		2058: uint8(0x4b),
		2059: uint8(0x42),
		2060: uint8(0x43),
		2061: uint8(0x48),
		2062: uint8(0x44),
		2063: uint8(0x4e),
		2064: uint8(0x49),
		2065: uint8(0x4c),
		2066: uint8(0x47),
		2067: uint8(0x40),
		2068: uint8(0x42),
		2069: uint8(0x41),
		2070: uint8(0x4d),
		2071: uint8(0x4a),
		2072: uint8(0x4c),
		2073: uint8(0x46),
		2074: uint8(0x40),
		2075: uint8(0x49),
		2076: uint8(0x45),
		2077: uint8(0x4b),
		2078: uint8(0x4a),
		2079: uint8(0x45),
		2080: uint8(0x40),
		2081: uint8(0x4d),
		2082: uint8(0x4e),
		2083: uint8(0x48),
		2084: uint8(0x47),
		2085: uint8(0x4a),
		2086: uint8(0x4b),
		2087: uint8(0x41),
		2088: uint8(0x4a),
		2089: uint8(0x43),
		2090: uint8(0x44),
		2091: uint8(0x4f),
		2092: uint8(0x4d),
		2093: uint8(0x44),
		2094: uint8(0x41),
		2095: uint8(0x42),
		2096: uint8(0x45),
		2097: uint8(0x4b),
		2098: uint8(0x48),
		2099: uint8(0x46),
		2100: uint8(0x4c),
		2101: uint8(0x47),
		2102: uint8(0x46),
		2103: uint8(0x4c),
		2104: uint8(0x49),
		2105: uint8(0x40),
		2106: uint8(0x43),
		2107: uint8(0x45),
		2108: uint8(0x42),
		2109: uint8(0x4e),
		2110: uint8(0x4f),
		2111: uint8(0x49),
		2112: uint8(0xff),
		2113: uint8(0xf3),
		2114: uint8(0xf1),
		2115: uint8(0xfd),
		2116: uint8(0xf8),
		2117: uint8(0xf4),
		2118: uint8(0xfe),
		2119: uint8(0xf7),
		2120: uint8(0xf6),
		2121: uint8(0xff),
		2122: uint8(0xfb),
		2123: uint8(0xf2),
		2124: uint8(0xf3),
		2125: uint8(0xf8),
		2126: uint8(0xf4),
		2127: uint8(0xfe),
		2128: uint8(0xf9),
		2129: uint8(0xfc),
		2130: uint8(0xf7),
		2131: uint8(0xf0),
		2132: uint8(0xf2),
		2133: uint8(0xf1),
		2134: uint8(0xfd),
		2135: uint8(0xfa),
		2136: uint8(0xfc),
		2137: uint8(0xf6),
		2138: uint8(0xf0),
		2139: uint8(0xf9),
		2140: uint8(0xf5),
		2141: uint8(0xfb),
		2142: uint8(0xfa),
		2143: uint8(0xf5),
		2144: uint8(0xf0),
		2145: uint8(0xfd),
		2146: uint8(0xfe),
		2147: uint8(0xf8),
		2148: uint8(0xf7),
		2149: uint8(0xfa),
		2150: uint8(0xfb),
		2151: uint8(0xf1),
		2152: uint8(0xfa),
		2153: uint8(0xf3),
		2154: uint8(0xf4),
		2155: uint8(0xff),
		2156: uint8(0xfd),
		2157: uint8(0xf4),
		2158: uint8(0xf1),
		2159: uint8(0xf2),
		2160: uint8(0xf5),
		2161: uint8(0xfb),
		2162: uint8(0xf8),
		2163: uint8(0xf6),
		2164: uint8(0xfc),
		2165: uint8(0xf7),
		2166: uint8(0xf6),
		2167: uint8(0xfc),
		2168: uint8(0xf9),
		2169: uint8(0xf0),
		2170: uint8(0xf3),
		2171: uint8(0xf5),
		2172: uint8(0xf2),
		2173: uint8(0xfe),
		2174: uint8(0xff),
		2175: uint8(0xf9),
		2176: uint8(0x1f),
		2177: uint8(0x13),
		2178: uint8(0x11),
		2179: uint8(0x1d),
		2180: uint8(0x18),
		2181: uint8(0x14),
		2182: uint8(0x1e),
		2183: uint8(0x17),
		2184: uint8(0x16),
		2185: uint8(0x1f),
		2186: uint8(0x1b),
		2187: uint8(0x12),
		2188: uint8(0x13),
		2189: uint8(0x18),
		2190: uint8(0x14),
		2191: uint8(0x1e),
		2192: uint8(0x19),
		2193: uint8(0x1c),
		2194: uint8(0x17),
		2195: uint8(0x10),
		2196: uint8(0x12),
		2197: uint8(0x11),
		2198: uint8(0x1d),
		2199: uint8(0x1a),
		2200: uint8(0x1c),
		2201: uint8(0x16),
		2202: uint8(0x10),
		2203: uint8(0x19),
		2204: uint8(0x15),
		2205: uint8(0x1b),
		2206: uint8(0x1a),
		2207: uint8(0x15),
		2208: uint8(0x10),
		2209: uint8(0x1d),
		2210: uint8(0x1e),
		2211: uint8(0x18),
		2212: uint8(0x17),
		2213: uint8(0x1a),
		2214: uint8(0x1b),
		2215: uint8(0x11),
		2216: uint8(0x1a),
		2217: uint8(0x13),
		2218: uint8(0x14),
		2219: uint8(0x1f),
		2220: uint8(0x1d),
		2221: uint8(0x14),
		2222: uint8(0x11),
		2223: uint8(0x12),
		2224: uint8(0x15),
		2225: uint8(0x1b),
		2226: uint8(0x18),
		2227: uint8(0x16),
		2228: uint8(0x1c),
		2229: uint8(0x17),
		2230: uint8(0x16),
		2231: uint8(0x1c),
		2232: uint8(0x19),
		2233: uint8(0x10),
		2234: uint8(0x13),
		2235: uint8(0x15),
		2236: uint8(0x12),
		2237: uint8(0x1e),
		2238: uint8(0x1f),
		2239: uint8(0x19),
		2240: uint8(0xcf),
		2241: uint8(0xc3),
		2242: uint8(0xc1),
		2243: uint8(0xcd),
		2244: uint8(0xc8),
		2245: uint8(0xc4),
		2246: uint8(0xce),
		2247: uint8(0xc7),
		2248: uint8(0xc6),
		2249: uint8(0xcf),
		2250: uint8(0xcb),
		2251: uint8(0xc2),
		2252: uint8(0xc3),
		2253: uint8(0xc8),
		2254: uint8(0xc4),
		2255: uint8(0xce),
		2256: uint8(0xc9),
		2257: uint8(0xcc),
		2258: uint8(0xc7),
		2259: uint8(0xc0),
		2260: uint8(0xc2),
		2261: uint8(0xc1),
		2262: uint8(0xcd),
		2263: uint8(0xca),
		2264: uint8(0xcc),
		2265: uint8(0xc6),
		2266: uint8(0xc0),
		2267: uint8(0xc9),
		2268: uint8(0xc5),
		2269: uint8(0xcb),
		2270: uint8(0xca),
		2271: uint8(0xc5),
		2272: uint8(0xc0),
		2273: uint8(0xcd),
		2274: uint8(0xce),
		2275: uint8(0xc8),
		2276: uint8(0xc7),
		2277: uint8(0xca),
		2278: uint8(0xcb),
		2279: uint8(0xc1),
		2280: uint8(0xca),
		2281: uint8(0xc3),
		2282: uint8(0xc4),
		2283: uint8(0xcf),
		2284: uint8(0xcd),
		2285: uint8(0xc4),
		2286: uint8(0xc1),
		2287: uint8(0xc2),
		2288: uint8(0xc5),
		2289: uint8(0xcb),
		2290: uint8(0xc8),
		2291: uint8(0xc6),
		2292: uint8(0xcc),
		2293: uint8(0xc7),
		2294: uint8(0xc6),
		2295: uint8(0xcc),
		2296: uint8(0xc9),
		2297: uint8(0xc0),
		2298: uint8(0xc3),
		2299: uint8(0xc5),
		2300: uint8(0xc2),
		2301: uint8(0xce),
		2302: uint8(0xcf),
		2303: uint8(0xc9),
		2304: uint8(0xef),
		2305: uint8(0xe3),
		2306: uint8(0xe1),
		2307: uint8(0xed),
		2308: uint8(0xe8),
		2309: uint8(0xe4),
		2310: uint8(0xee),
		2311: uint8(0xe7),
		2312: uint8(0xe6),
		2313: uint8(0xef),
		2314: uint8(0xeb),
		2315: uint8(0xe2),
		2316: uint8(0xe3),
		2317: uint8(0xe8),
		2318: uint8(0xe4),
		2319: uint8(0xee),
		2320: uint8(0xe9),
		2321: uint8(0xec),
		2322: uint8(0xe7),
		2323: uint8(0xe0),
		2324: uint8(0xe2),
		2325: uint8(0xe1),
		2326: uint8(0xed),
		2327: uint8(0xea),
		2328: uint8(0xec),
		2329: uint8(0xe6),
		2330: uint8(0xe0),
		2331: uint8(0xe9),
		2332: uint8(0xe5),
		2333: uint8(0xeb),
		2334: uint8(0xea),
		2335: uint8(0xe5),
		2336: uint8(0xe0),
		2337: uint8(0xed),
		2338: uint8(0xee),
		2339: uint8(0xe8),
		2340: uint8(0xe7),
		2341: uint8(0xea),
		2342: uint8(0xeb),
		2343: uint8(0xe1),
		2344: uint8(0xea),
		2345: uint8(0xe3),
		2346: uint8(0xe4),
		2347: uint8(0xef),
		2348: uint8(0xed),
		2349: uint8(0xe4),
		2350: uint8(0xe1),
		2351: uint8(0xe2),
		2352: uint8(0xe5),
		2353: uint8(0xeb),
		2354: uint8(0xe8),
		2355: uint8(0xe6),
		2356: uint8(0xec),
		2357: uint8(0xe7),
		2358: uint8(0xe6),
		2359: uint8(0xec),
		2360: uint8(0xe9),
		2361: uint8(0xe0),
		2362: uint8(0xe3),
		2363: uint8(0xe5),
		2364: uint8(0xe2),
		2365: uint8(0xee),
		2366: uint8(0xef),
		2367: uint8(0xe9),
		2368: uint8(0x8f),
		2369: uint8(0x83),
		2370: uint8(0x81),
		2371: uint8(0x8d),
		2372: uint8(0x88),
		2373: uint8(0x84),
		2374: uint8(0x8e),
		2375: uint8(0x87),
		2376: uint8(0x86),
		2377: uint8(0x8f),
		2378: uint8(0x8b),
		2379: uint8(0x82),
		2380: uint8(0x83),
		2381: uint8(0x88),
		2382: uint8(0x84),
		2383: uint8(0x8e),
		2384: uint8(0x89),
		2385: uint8(0x8c),
		2386: uint8(0x87),
		2387: uint8(0x80),
		2388: uint8(0x82),
		2389: uint8(0x81),
		2390: uint8(0x8d),
		2391: uint8(0x8a),
		2392: uint8(0x8c),
		2393: uint8(0x86),
		2394: uint8(0x80),
		2395: uint8(0x89),
		2396: uint8(0x85),
		2397: uint8(0x8b),
		2398: uint8(0x8a),
		2399: uint8(0x85),
		2400: uint8(0x80),
		2401: uint8(0x8d),
		2402: uint8(0x8e),
		2403: uint8(0x88),
		2404: uint8(0x87),
		2405: uint8(0x8a),
		2406: uint8(0x8b),
		2407: uint8(0x81),
		2408: uint8(0x8a),
		2409: uint8(0x83),
		2410: uint8(0x84),
		2411: uint8(0x8f),
		2412: uint8(0x8d),
		2413: uint8(0x84),
		2414: uint8(0x81),
		2415: uint8(0x82),
		2416: uint8(0x85),
		2417: uint8(0x8b),
		2418: uint8(0x88),
		2419: uint8(0x86),
		2420: uint8(0x8c),
		2421: uint8(0x87),
		2422: uint8(0x86),
		2423: uint8(0x8c),
		2424: uint8(0x89),
		2425: uint8(0x80),
		2426: uint8(0x83),
		2427: uint8(0x85),
		2428: uint8(0x82),
		2429: uint8(0x8e),
		2430: uint8(0x8f),
		2431: uint8(0x89),
		2432: uint8(0x8f),
		2433: uint8(0x83),
		2434: uint8(0x81),
		2435: uint8(0x8d),
		2436: uint8(0x88),
		2437: uint8(0x84),
		2438: uint8(0x8e),
		2439: uint8(0x87),
		2440: uint8(0x86),
		2441: uint8(0x8f),
		2442: uint8(0x8b),
		2443: uint8(0x82),
		2444: uint8(0x83),
		2445: uint8(0x88),
		2446: uint8(0x84),
		2447: uint8(0x8e),
		2448: uint8(0x89),
		2449: uint8(0x8c),
		2450: uint8(0x87),
		2451: uint8(0x80),
		2452: uint8(0x82),
		2453: uint8(0x81),
		2454: uint8(0x8d),
		2455: uint8(0x8a),
		2456: uint8(0x8c),
		2457: uint8(0x86),
		2458: uint8(0x80),
		2459: uint8(0x89),
		2460: uint8(0x85),
		2461: uint8(0x8b),
		2462: uint8(0x8a),
		2463: uint8(0x85),
		2464: uint8(0x80),
		2465: uint8(0x8d),
		2466: uint8(0x8e),
		2467: uint8(0x88),
		2468: uint8(0x87),
		2469: uint8(0x8a),
		2470: uint8(0x8b),
		2471: uint8(0x81),
		2472: uint8(0x8a),
		2473: uint8(0x83),
		2474: uint8(0x84),
		2475: uint8(0x8f),
		2476: uint8(0x8d),
		2477: uint8(0x84),
		2478: uint8(0x81),
		2479: uint8(0x82),
		2480: uint8(0x85),
		2481: uint8(0x8b),
		2482: uint8(0x88),
		2483: uint8(0x86),
		2484: uint8(0x8c),
		2485: uint8(0x87),
		2486: uint8(0x86),
		2487: uint8(0x8c),
		2488: uint8(0x89),
		2489: uint8(0x80),
		2490: uint8(0x83),
		2491: uint8(0x85),
		2492: uint8(0x82),
		2493: uint8(0x8e),
		2494: uint8(0x8f),
		2495: uint8(0x89),
		2496: uint8(0x2f),
		2497: uint8(0x23),
		2498: uint8(0x21),
		2499: uint8(0x2d),
		2500: uint8(0x28),
		2501: uint8(0x24),
		2502: uint8(0x2e),
		2503: uint8(0x27),
		2504: uint8(0x26),
		2505: uint8(0x2f),
		2506: uint8(0x2b),
		2507: uint8(0x22),
		2508: uint8(0x23),
		2509: uint8(0x28),
		2510: uint8(0x24),
		2511: uint8(0x2e),
		2512: uint8(0x29),
		2513: uint8(0x2c),
		2514: uint8(0x27),
		2515: uint8(0x20),
		2516: uint8(0x22),
		2517: uint8(0x21),
		2518: uint8(0x2d),
		2519: uint8(0x2a),
		2520: uint8(0x2c),
		2521: uint8(0x26),
		2522: uint8(0x20),
		2523: uint8(0x29),
		2524: uint8(0x25),
		2525: uint8(0x2b),
		2526: uint8(0x2a),
		2527: uint8(0x25),
		2528: uint8(0x20),
		2529: uint8(0x2d),
		2530: uint8(0x2e),
		2531: uint8(0x28),
		2532: uint8(0x27),
		2533: uint8(0x2a),
		2534: uint8(0x2b),
		2535: uint8(0x21),
		2536: uint8(0x2a),
		2537: uint8(0x23),
		2538: uint8(0x24),
		2539: uint8(0x2f),
		2540: uint8(0x2d),
		2541: uint8(0x24),
		2542: uint8(0x21),
		2543: uint8(0x22),
		2544: uint8(0x25),
		2545: uint8(0x2b),
		2546: uint8(0x28),
		2547: uint8(0x26),
		2548: uint8(0x2c),
		2549: uint8(0x27),
		2550: uint8(0x26),
		2551: uint8(0x2c),
		2552: uint8(0x29),
		2553: uint8(0x20),
		2554: uint8(0x23),
		2555: uint8(0x25),
		2556: uint8(0x22),
		2557: uint8(0x2e),
		2558: uint8(0x2f),
		2559: uint8(0x29),
		2560: uint8(0xdf),
		2561: uint8(0xd3),
		2562: uint8(0xd1),
		2563: uint8(0xdd),
		2564: uint8(0xd8),
		2565: uint8(0xd4),
		2566: uint8(0xde),
		2567: uint8(0xd7),
		2568: uint8(0xd6),
		2569: uint8(0xdf),
		2570: uint8(0xdb),
		2571: uint8(0xd2),
		2572: uint8(0xd3),
		2573: uint8(0xd8),
		2574: uint8(0xd4),
		2575: uint8(0xde),
		2576: uint8(0xd9),
		2577: uint8(0xdc),
		2578: uint8(0xd7),
		2579: uint8(0xd0),
		2580: uint8(0xd2),
		2581: uint8(0xd1),
		2582: uint8(0xdd),
		2583: uint8(0xda),
		2584: uint8(0xdc),
		2585: uint8(0xd6),
		2586: uint8(0xd0),
		2587: uint8(0xd9),
		2588: uint8(0xd5),
		2589: uint8(0xdb),
		2590: uint8(0xda),
		2591: uint8(0xd5),
		2592: uint8(0xd0),
		2593: uint8(0xdd),
		2594: uint8(0xde),
		2595: uint8(0xd8),
		2596: uint8(0xd7),
		2597: uint8(0xda),
		2598: uint8(0xdb),
		2599: uint8(0xd1),
		2600: uint8(0xda),
		2601: uint8(0xd3),
		2602: uint8(0xd4),
		2603: uint8(0xdf),
		2604: uint8(0xdd),
		2605: uint8(0xd4),
		2606: uint8(0xd1),
		2607: uint8(0xd2),
		2608: uint8(0xd5),
		2609: uint8(0xdb),
		2610: uint8(0xd8),
		2611: uint8(0xd6),
		2612: uint8(0xdc),
		2613: uint8(0xd7),
		2614: uint8(0xd6),
		2615: uint8(0xdc),
		2616: uint8(0xd9),
		2617: uint8(0xd0),
		2618: uint8(0xd3),
		2619: uint8(0xd5),
		2620: uint8(0xd2),
		2621: uint8(0xde),
		2622: uint8(0xdf),
		2623: uint8(0xd9),
		2624: uint8(0x4f),
		2625: uint8(0x43),
		2626: uint8(0x41),
		2627: uint8(0x4d),
		2628: uint8(0x48),
		2629: uint8(0x44),
		2630: uint8(0x4e),
		2631: uint8(0x47),
		2632: uint8(0x46),
		2633: uint8(0x4f),
		2634: uint8(0x4b),
		2635: uint8(0x42),
		2636: uint8(0x43),
		2637: uint8(0x48),
		2638: uint8(0x44),
		2639: uint8(0x4e),
		2640: uint8(0x49),
		2641: uint8(0x4c),
		2642: uint8(0x47),
		2643: uint8(0x40),
		2644: uint8(0x42),
		2645: uint8(0x41),
		2646: uint8(0x4d),
		2647: uint8(0x4a),
		2648: uint8(0x4c),
		2649: uint8(0x46),
		2650: uint8(0x40),
		2651: uint8(0x49),
		2652: uint8(0x45),
		2653: uint8(0x4b),
		2654: uint8(0x4a),
		2655: uint8(0x45),
		2656: uint8(0x40),
		2657: uint8(0x4d),
		2658: uint8(0x4e),
		2659: uint8(0x48),
		2660: uint8(0x47),
		2661: uint8(0x4a),
		2662: uint8(0x4b),
		2663: uint8(0x41),
		2664: uint8(0x4a),
		2665: uint8(0x43),
		2666: uint8(0x44),
		2667: uint8(0x4f),
		2668: uint8(0x4d),
		2669: uint8(0x44),
		2670: uint8(0x41),
		2671: uint8(0x42),
		2672: uint8(0x45),
		2673: uint8(0x4b),
		2674: uint8(0x48),
		2675: uint8(0x46),
		2676: uint8(0x4c),
		2677: uint8(0x47),
		2678: uint8(0x46),
		2679: uint8(0x4c),
		2680: uint8(0x49),
		2681: uint8(0x40),
		2682: uint8(0x43),
		2683: uint8(0x45),
		2684: uint8(0x42),
		2685: uint8(0x4e),
		2686: uint8(0x4f),
		2687: uint8(0x49),
		2688: uint8(0x6f),
		2689: uint8(0x63),
		2690: uint8(0x61),
		2691: uint8(0x6d),
		2692: uint8(0x68),
		2693: uint8(0x64),
		2694: uint8(0x6e),
		2695: uint8(0x67),
		2696: uint8(0x66),
		2697: uint8(0x6f),
		2698: uint8(0x6b),
		2699: uint8(0x62),
		2700: uint8(0x63),
		2701: uint8(0x68),
		2702: uint8(0x64),
		2703: uint8(0x6e),
		2704: uint8(0x69),
		2705: uint8(0x6c),
		2706: uint8(0x67),
		2707: uint8(0x60),
		2708: uint8(0x62),
		2709: uint8(0x61),
		2710: uint8(0x6d),
		2711: uint8(0x6a),
		2712: uint8(0x6c),
		2713: uint8(0x66),
		2714: uint8(0x60),
		2715: uint8(0x69),
		2716: uint8(0x65),
		2717: uint8(0x6b),
		2718: uint8(0x6a),
		2719: uint8(0x65),
		2720: uint8(0x60),
		2721: uint8(0x6d),
		2722: uint8(0x6e),
		2723: uint8(0x68),
		2724: uint8(0x67),
		2725: uint8(0x6a),
		2726: uint8(0x6b),
		2727: uint8(0x61),
		2728: uint8(0x6a),
		2729: uint8(0x63),
		2730: uint8(0x64),
		2731: uint8(0x6f),
		2732: uint8(0x6d),
		2733: uint8(0x64),
		2734: uint8(0x61),
		2735: uint8(0x62),
		2736: uint8(0x65),
		2737: uint8(0x6b),
		2738: uint8(0x68),
		2739: uint8(0x66),
		2740: uint8(0x6c),
		2741: uint8(0x67),
		2742: uint8(0x66),
		2743: uint8(0x6c),
		2744: uint8(0x69),
		2745: uint8(0x60),
		2746: uint8(0x63),
		2747: uint8(0x65),
		2748: uint8(0x62),
		2749: uint8(0x6e),
		2750: uint8(0x6f),
		2751: uint8(0x69),
		2752: uint8(0x9f),
		2753: uint8(0x93),
		2754: uint8(0x91),
		2755: uint8(0x9d),
		2756: uint8(0x98),
		2757: uint8(0x94),
		2758: uint8(0x9e),
		2759: uint8(0x97),
		2760: uint8(0x96),
		2761: uint8(0x9f),
		2762: uint8(0x9b),
		2763: uint8(0x92),
		2764: uint8(0x93),
		2765: uint8(0x98),
		2766: uint8(0x94),
		2767: uint8(0x9e),
		2768: uint8(0x99),
		2769: uint8(0x9c),
		2770: uint8(0x97),
		2771: uint8(0x90),
		2772: uint8(0x92),
		2773: uint8(0x91),
		2774: uint8(0x9d),
		2775: uint8(0x9a),
		2776: uint8(0x9c),
		2777: uint8(0x96),
		2778: uint8(0x90),
		2779: uint8(0x99),
		2780: uint8(0x95),
		2781: uint8(0x9b),
		2782: uint8(0x9a),
		2783: uint8(0x95),
		2784: uint8(0x90),
		2785: uint8(0x9d),
		2786: uint8(0x9e),
		2787: uint8(0x98),
		2788: uint8(0x97),
		2789: uint8(0x9a),
		2790: uint8(0x9b),
		2791: uint8(0x91),
		2792: uint8(0x9a),
		2793: uint8(0x93),
		2794: uint8(0x94),
		2795: uint8(0x9f),
		2796: uint8(0x9d),
		2797: uint8(0x94),
		2798: uint8(0x91),
		2799: uint8(0x92),
		2800: uint8(0x95),
		2801: uint8(0x9b),
		2802: uint8(0x98),
		2803: uint8(0x96),
		2804: uint8(0x9c),
		2805: uint8(0x97),
		2806: uint8(0x96),
		2807: uint8(0x9c),
		2808: uint8(0x99),
		2809: uint8(0x90),
		2810: uint8(0x93),
		2811: uint8(0x95),
		2812: uint8(0x92),
		2813: uint8(0x9e),
		2814: uint8(0x9f),
		2815: uint8(0x99),
		2816: uint8(0x2f),
		2817: uint8(0x23),
		2818: uint8(0x21),
		2819: uint8(0x2d),
		2820: uint8(0x28),
		2821: uint8(0x24),
		2822: uint8(0x2e),
		2823: uint8(0x27),
		2824: uint8(0x26),
		2825: uint8(0x2f),
		2826: uint8(0x2b),
		2827: uint8(0x22),
		2828: uint8(0x23),
		2829: uint8(0x28),
		2830: uint8(0x24),
		2831: uint8(0x2e),
		2832: uint8(0x29),
		2833: uint8(0x2c),
		2834: uint8(0x27),
		2835: uint8(0x20),
		2836: uint8(0x22),
		2837: uint8(0x21),
		2838: uint8(0x2d),
		2839: uint8(0x2a),
		2840: uint8(0x2c),
		2841: uint8(0x26),
		2842: uint8(0x20),
		2843: uint8(0x29),
		2844: uint8(0x25),
		2845: uint8(0x2b),
		2846: uint8(0x2a),
		2847: uint8(0x25),
		2848: uint8(0x20),
		2849: uint8(0x2d),
		2850: uint8(0x2e),
		2851: uint8(0x28),
		2852: uint8(0x27),
		2853: uint8(0x2a),
		2854: uint8(0x2b),
		2855: uint8(0x21),
		2856: uint8(0x2a),
		2857: uint8(0x23),
		2858: uint8(0x24),
		2859: uint8(0x2f),
		2860: uint8(0x2d),
		2861: uint8(0x24),
		2862: uint8(0x21),
		2863: uint8(0x22),
		2864: uint8(0x25),
		2865: uint8(0x2b),
		2866: uint8(0x28),
		2867: uint8(0x26),
		2868: uint8(0x2c),
		2869: uint8(0x27),
		2870: uint8(0x26),
		2871: uint8(0x2c),
		2872: uint8(0x29),
		2873: uint8(0x20),
		2874: uint8(0x23),
		2875: uint8(0x25),
		2876: uint8(0x22),
		2877: uint8(0x2e),
		2878: uint8(0x2f),
		2879: uint8(0x29),
		2880: uint8(0x1f),
		2881: uint8(0x13),
		2882: uint8(0x11),
		2883: uint8(0x1d),
		2884: uint8(0x18),
		2885: uint8(0x14),
		2886: uint8(0x1e),
		2887: uint8(0x17),
		2888: uint8(0x16),
		2889: uint8(0x1f),
		2890: uint8(0x1b),
		2891: uint8(0x12),
		2892: uint8(0x13),
		2893: uint8(0x18),
		2894: uint8(0x14),
		2895: uint8(0x1e),
		2896: uint8(0x19),
		2897: uint8(0x1c),
		2898: uint8(0x17),
		2899: uint8(0x10),
		2900: uint8(0x12),
		2901: uint8(0x11),
		2902: uint8(0x1d),
		2903: uint8(0x1a),
		2904: uint8(0x1c),
		2905: uint8(0x16),
		2906: uint8(0x10),
		2907: uint8(0x19),
		2908: uint8(0x15),
		2909: uint8(0x1b),
		2910: uint8(0x1a),
		2911: uint8(0x15),
		2912: uint8(0x10),
		2913: uint8(0x1d),
		2914: uint8(0x1e),
		2915: uint8(0x18),
		2916: uint8(0x17),
		2917: uint8(0x1a),
		2918: uint8(0x1b),
		2919: uint8(0x11),
		2920: uint8(0x1a),
		2921: uint8(0x13),
		2922: uint8(0x14),
		2923: uint8(0x1f),
		2924: uint8(0x1d),
		2925: uint8(0x14),
		2926: uint8(0x11),
		2927: uint8(0x12),
		2928: uint8(0x15),
		2929: uint8(0x1b),
		2930: uint8(0x18),
		2931: uint8(0x16),
		2932: uint8(0x1c),
		2933: uint8(0x17),
		2934: uint8(0x16),
		2935: uint8(0x1c),
		2936: uint8(0x19),
		2937: uint8(0x10),
		2938: uint8(0x13),
		2939: uint8(0x15),
		2940: uint8(0x12),
		2941: uint8(0x1e),
		2942: uint8(0x1f),
		2943: uint8(0x19),
		2944: uint8(0xbf),
		2945: uint8(0xb3),
		2946: uint8(0xb1),
		2947: uint8(0xbd),
		2948: uint8(0xb8),
		2949: uint8(0xb4),
		2950: uint8(0xbe),
		2951: uint8(0xb7),
		2952: uint8(0xb6),
		2953: uint8(0xbf),
		2954: uint8(0xbb),
		2955: uint8(0xb2),
		2956: uint8(0xb3),
		2957: uint8(0xb8),
		2958: uint8(0xb4),
		2959: uint8(0xbe),
		2960: uint8(0xb9),
		2961: uint8(0xbc),
		2962: uint8(0xb7),
		2963: uint8(0xb0),
		2964: uint8(0xb2),
		2965: uint8(0xb1),
		2966: uint8(0xbd),
		2967: uint8(0xba),
		2968: uint8(0xbc),
		2969: uint8(0xb6),
		2970: uint8(0xb0),
		2971: uint8(0xb9),
		2972: uint8(0xb5),
		2973: uint8(0xbb),
		2974: uint8(0xba),
		2975: uint8(0xb5),
		2976: uint8(0xb0),
		2977: uint8(0xbd),
		2978: uint8(0xbe),
		2979: uint8(0xb8),
		2980: uint8(0xb7),
		2981: uint8(0xba),
		2982: uint8(0xbb),
		2983: uint8(0xb1),
		2984: uint8(0xba),
		2985: uint8(0xb3),
		2986: uint8(0xb4),
		2987: uint8(0xbf),
		2988: uint8(0xbd),
		2989: uint8(0xb4),
		2990: uint8(0xb1),
		2991: uint8(0xb2),
		2992: uint8(0xb5),
		2993: uint8(0xbb),
		2994: uint8(0xb8),
		2995: uint8(0xb6),
		2996: uint8(0xbc),
		2997: uint8(0xb7),
		2998: uint8(0xb6),
		2999: uint8(0xbc),
		3000: uint8(0xb9),
		3001: uint8(0xb0),
		3002: uint8(0xb3),
		3003: uint8(0xb5),
		3004: uint8(0xb2),
		3005: uint8(0xbe),
		3006: uint8(0xbf),
		3007: uint8(0xb9),
		3008: uint8(0x7f),
		3009: uint8(0x73),
		3010: uint8(0x71),
		3011: uint8(0x7d),
		3012: uint8(0x78),
		3013: uint8(0x74),
		3014: uint8(0x7e),
		3015: uint8(0x77),
		3016: uint8(0x76),
		3017: uint8(0x7f),
		3018: uint8(0x7b),
		3019: uint8(0x72),
		3020: uint8(0x73),
		3021: uint8(0x78),
		3022: uint8(0x74),
		3023: uint8(0x7e),
		3024: uint8(0x79),
		3025: uint8(0x7c),
		3026: uint8(0x77),
		3027: uint8(0x70),
		3028: uint8(0x72),
		3029: uint8(0x71),
		3030: uint8(0x7d),
		3031: uint8(0x7a),
		3032: uint8(0x7c),
		3033: uint8(0x76),
		3034: uint8(0x70),
		3035: uint8(0x79),
		3036: uint8(0x75),
		3037: uint8(0x7b),
		3038: uint8(0x7a),
		3039: uint8(0x75),
		3040: uint8(0x70),
		3041: uint8(0x7d),
		3042: uint8(0x7e),
		3043: uint8(0x78),
		3044: uint8(0x77),
		3045: uint8(0x7a),
		3046: uint8(0x7b),
		3047: uint8(0x71),
		3048: uint8(0x7a),
		3049: uint8(0x73),
		3050: uint8(0x74),
		3051: uint8(0x7f),
		3052: uint8(0x7d),
		3053: uint8(0x74),
		3054: uint8(0x71),
		3055: uint8(0x72),
		3056: uint8(0x75),
		3057: uint8(0x7b),
		3058: uint8(0x78),
		3059: uint8(0x76),
		3060: uint8(0x7c),
		3061: uint8(0x77),
		3062: uint8(0x76),
		3063: uint8(0x7c),
		3064: uint8(0x79),
		3065: uint8(0x70),
		3066: uint8(0x73),
		3067: uint8(0x75),
		3068: uint8(0x72),
		3069: uint8(0x7e),
		3070: uint8(0x7f),
		3071: uint8(0x79),
		3072: uint8(0xff),
		3073: uint8(0xf3),
		3074: uint8(0xf1),
		3075: uint8(0xfd),
		3076: uint8(0xf8),
		3077: uint8(0xf4),
		3078: uint8(0xfe),
		3079: uint8(0xf7),
		3080: uint8(0xf6),
		3081: uint8(0xff),
		3082: uint8(0xfb),
		3083: uint8(0xf2),
		3084: uint8(0xf3),
		3085: uint8(0xf8),
		3086: uint8(0xf4),
		3087: uint8(0xfe),
		3088: uint8(0xf9),
		3089: uint8(0xfc),
		3090: uint8(0xf7),
		3091: uint8(0xf0),
		3092: uint8(0xf2),
		3093: uint8(0xf1),
		3094: uint8(0xfd),
		3095: uint8(0xfa),
		3096: uint8(0xfc),
		3097: uint8(0xf6),
		3098: uint8(0xf0),
		3099: uint8(0xf9),
		3100: uint8(0xf5),
		3101: uint8(0xfb),
		3102: uint8(0xfa),
		3103: uint8(0xf5),
		3104: uint8(0xf0),
		3105: uint8(0xfd),
		3106: uint8(0xfe),
		3107: uint8(0xf8),
		3108: uint8(0xf7),
		3109: uint8(0xfa),
		3110: uint8(0xfb),
		3111: uint8(0xf1),
		3112: uint8(0xfa),
		3113: uint8(0xf3),
		3114: uint8(0xf4),
		3115: uint8(0xff),
		3116: uint8(0xfd),
		3117: uint8(0xf4),
		3118: uint8(0xf1),
		3119: uint8(0xf2),
		3120: uint8(0xf5),
		3121: uint8(0xfb),
		3122: uint8(0xf8),
		3123: uint8(0xf6),
		3124: uint8(0xfc),
		3125: uint8(0xf7),
		3126: uint8(0xf6),
		3127: uint8(0xfc),
		3128: uint8(0xf9),
		3129: uint8(0xf0),
		3130: uint8(0xf3),
		3131: uint8(0xf5),
		3132: uint8(0xf2),
		3133: uint8(0xfe),
		3134: uint8(0xff),
		3135: uint8(0xf9),
		3136: uint8(0x5f),
		3137: uint8(0x53),
		3138: uint8(0x51),
		3139: uint8(0x5d),
		3140: uint8(0x58),
		3141: uint8(0x54),
		3142: uint8(0x5e),
		3143: uint8(0x57),
		3144: uint8(0x56),
		3145: uint8(0x5f),
		3146: uint8(0x5b),
		3147: uint8(0x52),
		3148: uint8(0x53),
		3149: uint8(0x58),
		3150: uint8(0x54),
		3151: uint8(0x5e),
		3152: uint8(0x59),
		3153: uint8(0x5c),
		3154: uint8(0x57),
		3155: uint8(0x50),
		3156: uint8(0x52),
		3157: uint8(0x51),
		3158: uint8(0x5d),
		3159: uint8(0x5a),
		3160: uint8(0x5c),
		3161: uint8(0x56),
		3162: uint8(0x50),
		3163: uint8(0x59),
		3164: uint8(0x55),
		3165: uint8(0x5b),
		3166: uint8(0x5a),
		3167: uint8(0x55),
		3168: uint8(0x50),
		3169: uint8(0x5d),
		3170: uint8(0x5e),
		3171: uint8(0x58),
		3172: uint8(0x57),
		3173: uint8(0x5a),
		3174: uint8(0x5b),
		3175: uint8(0x51),
		3176: uint8(0x5a),
		3177: uint8(0x53),
		3178: uint8(0x54),
		3179: uint8(0x5f),
		3180: uint8(0x5d),
		3181: uint8(0x54),
		3182: uint8(0x51),
		3183: uint8(0x52),
		3184: uint8(0x55),
		3185: uint8(0x5b),
		3186: uint8(0x58),
		3187: uint8(0x56),
		3188: uint8(0x5c),
		3189: uint8(0x57),
		3190: uint8(0x56),
		3191: uint8(0x5c),
		3192: uint8(0x59),
		3193: uint8(0x50),
		3194: uint8(0x53),
		3195: uint8(0x55),
		3196: uint8(0x52),
		3197: uint8(0x5e),
		3198: uint8(0x5f),
		3199: uint8(0x59),
		3200: uint8(0xcf),
		3201: uint8(0xc3),
		3202: uint8(0xc1),
		3203: uint8(0xcd),
		3204: uint8(0xc8),
		3205: uint8(0xc4),
		3206: uint8(0xce),
		3207: uint8(0xc7),
		3208: uint8(0xc6),
		3209: uint8(0xcf),
		3210: uint8(0xcb),
		3211: uint8(0xc2),
		3212: uint8(0xc3),
		3213: uint8(0xc8),
		3214: uint8(0xc4),
		3215: uint8(0xce),
		3216: uint8(0xc9),
		3217: uint8(0xcc),
		3218: uint8(0xc7),
		3219: uint8(0xc0),
		3220: uint8(0xc2),
		3221: uint8(0xc1),
		3222: uint8(0xcd),
		3223: uint8(0xca),
		3224: uint8(0xcc),
		3225: uint8(0xc6),
		3226: uint8(0xc0),
		3227: uint8(0xc9),
		3228: uint8(0xc5),
		3229: uint8(0xcb),
		3230: uint8(0xca),
		3231: uint8(0xc5),
		3232: uint8(0xc0),
		3233: uint8(0xcd),
		3234: uint8(0xce),
		3235: uint8(0xc8),
		3236: uint8(0xc7),
		3237: uint8(0xca),
		3238: uint8(0xcb),
		3239: uint8(0xc1),
		3240: uint8(0xca),
		3241: uint8(0xc3),
		3242: uint8(0xc4),
		3243: uint8(0xcf),
		3244: uint8(0xcd),
		3245: uint8(0xc4),
		3246: uint8(0xc1),
		3247: uint8(0xc2),
		3248: uint8(0xc5),
		3249: uint8(0xcb),
		3250: uint8(0xc8),
		3251: uint8(0xc6),
		3252: uint8(0xcc),
		3253: uint8(0xc7),
		3254: uint8(0xc6),
		3255: uint8(0xcc),
		3256: uint8(0xc9),
		3257: uint8(0xc0),
		3258: uint8(0xc3),
		3259: uint8(0xc5),
		3260: uint8(0xc2),
		3261: uint8(0xce),
		3262: uint8(0xcf),
		3263: uint8(0xc9),
		3264: uint8(0xbf),
		3265: uint8(0xb3),
		3266: uint8(0xb1),
		3267: uint8(0xbd),
		3268: uint8(0xb8),
		3269: uint8(0xb4),
		3270: uint8(0xbe),
		3271: uint8(0xb7),
		3272: uint8(0xb6),
		3273: uint8(0xbf),
		3274: uint8(0xbb),
		3275: uint8(0xb2),
		3276: uint8(0xb3),
		3277: uint8(0xb8),
		3278: uint8(0xb4),
		3279: uint8(0xbe),
		3280: uint8(0xb9),
		3281: uint8(0xbc),
		3282: uint8(0xb7),
		3283: uint8(0xb0),
		3284: uint8(0xb2),
		3285: uint8(0xb1),
		3286: uint8(0xbd),
		3287: uint8(0xba),
		3288: uint8(0xbc),
		3289: uint8(0xb6),
		3290: uint8(0xb0),
		3291: uint8(0xb9),
		3292: uint8(0xb5),
		3293: uint8(0xbb),
		3294: uint8(0xba),
		3295: uint8(0xb5),
		3296: uint8(0xb0),
		3297: uint8(0xbd),
		3298: uint8(0xbe),
		3299: uint8(0xb8),
		3300: uint8(0xb7),
		3301: uint8(0xba),
		3302: uint8(0xbb),
		3303: uint8(0xb1),
		3304: uint8(0xba),
		3305: uint8(0xb3),
		3306: uint8(0xb4),
		3307: uint8(0xbf),
		3308: uint8(0xbd),
		3309: uint8(0xb4),
		3310: uint8(0xb1),
		3311: uint8(0xb2),
		3312: uint8(0xb5),
		3313: uint8(0xbb),
		3314: uint8(0xb8),
		3315: uint8(0xb6),
		3316: uint8(0xbc),
		3317: uint8(0xb7),
		3318: uint8(0xb6),
		3319: uint8(0xbc),
		3320: uint8(0xb9),
		3321: uint8(0xb0),
		3322: uint8(0xb3),
		3323: uint8(0xb5),
		3324: uint8(0xb2),
		3325: uint8(0xbe),
		3326: uint8(0xbf),
		3327: uint8(0xb9),
		3328: uint8(0x9f),
		3329: uint8(0x93),
		3330: uint8(0x91),
		3331: uint8(0x9d),
		3332: uint8(0x98),
		3333: uint8(0x94),
		3334: uint8(0x9e),
		3335: uint8(0x97),
		3336: uint8(0x96),
		3337: uint8(0x9f),
		3338: uint8(0x9b),
		3339: uint8(0x92),
		3340: uint8(0x93),
		3341: uint8(0x98),
		3342: uint8(0x94),
		3343: uint8(0x9e),
		3344: uint8(0x99),
		3345: uint8(0x9c),
		3346: uint8(0x97),
		3347: uint8(0x90),
		3348: uint8(0x92),
		3349: uint8(0x91),
		3350: uint8(0x9d),
		3351: uint8(0x9a),
		3352: uint8(0x9c),
		3353: uint8(0x96),
		3354: uint8(0x90),
		3355: uint8(0x99),
		3356: uint8(0x95),
		3357: uint8(0x9b),
		3358: uint8(0x9a),
		3359: uint8(0x95),
		3360: uint8(0x90),
		3361: uint8(0x9d),
		3362: uint8(0x9e),
		3363: uint8(0x98),
		3364: uint8(0x97),
		3365: uint8(0x9a),
		3366: uint8(0x9b),
		3367: uint8(0x91),
		3368: uint8(0x9a),
		3369: uint8(0x93),
		3370: uint8(0x94),
		3371: uint8(0x9f),
		3372: uint8(0x9d),
		3373: uint8(0x94),
		3374: uint8(0x91),
		3375: uint8(0x92),
		3376: uint8(0x95),
		3377: uint8(0x9b),
		3378: uint8(0x98),
		3379: uint8(0x96),
		3380: uint8(0x9c),
		3381: uint8(0x97),
		3382: uint8(0x96),
		3383: uint8(0x9c),
		3384: uint8(0x99),
		3385: uint8(0x90),
		3386: uint8(0x93),
		3387: uint8(0x95),
		3388: uint8(0x92),
		3389: uint8(0x9e),
		3390: uint8(0x9f),
		3391: uint8(0x99),
		3392: uint8(0x3f),
		3393: uint8(0x33),
		3394: uint8(0x31),
		3395: uint8(0x3d),
		3396: uint8(0x38),
		3397: uint8(0x34),
		3398: uint8(0x3e),
		3399: uint8(0x37),
		3400: uint8(0x36),
		3401: uint8(0x3f),
		3402: uint8(0x3b),
		3403: uint8(0x32),
		3404: uint8(0x33),
		3405: uint8(0x38),
		3406: uint8(0x34),
		3407: uint8(0x3e),
		3408: uint8(0x39),
		3409: uint8(0x3c),
		3410: uint8(0x37),
		3411: uint8(0x30),
		3412: uint8(0x32),
		3413: uint8(0x31),
		3414: uint8(0x3d),
		3415: uint8(0x3a),
		3416: uint8(0x3c),
		3417: uint8(0x36),
		3418: uint8(0x30),
		3419: uint8(0x39),
		3420: uint8(0x35),
		3421: uint8(0x3b),
		3422: uint8(0x3a),
		3423: uint8(0x35),
		3424: uint8(0x30),
		3425: uint8(0x3d),
		3426: uint8(0x3e),
		3427: uint8(0x38),
		3428: uint8(0x37),
		3429: uint8(0x3a),
		3430: uint8(0x3b),
		3431: uint8(0x31),
		3432: uint8(0x3a),
		3433: uint8(0x33),
		3434: uint8(0x34),
		3435: uint8(0x3f),
		3436: uint8(0x3d),
		3437: uint8(0x34),
		3438: uint8(0x31),
		3439: uint8(0x32),
		3440: uint8(0x35),
		3441: uint8(0x3b),
		3442: uint8(0x38),
		3443: uint8(0x36),
		3444: uint8(0x3c),
		3445: uint8(0x37),
		3446: uint8(0x36),
		3447: uint8(0x3c),
		3448: uint8(0x39),
		3449: uint8(0x30),
		3450: uint8(0x33),
		3451: uint8(0x35),
		3452: uint8(0x32),
		3453: uint8(0x3e),
		3454: uint8(0x3f),
		3455: uint8(0x39),
		3456: uint8(0x7f),
		3457: uint8(0x73),
		3458: uint8(0x71),
		3459: uint8(0x7d),
		3460: uint8(0x78),
		3461: uint8(0x74),
		3462: uint8(0x7e),
		3463: uint8(0x77),
		3464: uint8(0x76),
		3465: uint8(0x7f),
		3466: uint8(0x7b),
		3467: uint8(0x72),
		3468: uint8(0x73),
		3469: uint8(0x78),
		3470: uint8(0x74),
		3471: uint8(0x7e),
		3472: uint8(0x79),
		3473: uint8(0x7c),
		3474: uint8(0x77),
		3475: uint8(0x70),
		3476: uint8(0x72),
		3477: uint8(0x71),
		3478: uint8(0x7d),
		3479: uint8(0x7a),
		3480: uint8(0x7c),
		3481: uint8(0x76),
		3482: uint8(0x70),
		3483: uint8(0x79),
		3484: uint8(0x75),
		3485: uint8(0x7b),
		3486: uint8(0x7a),
		3487: uint8(0x75),
		3488: uint8(0x70),
		3489: uint8(0x7d),
		3490: uint8(0x7e),
		3491: uint8(0x78),
		3492: uint8(0x77),
		3493: uint8(0x7a),
		3494: uint8(0x7b),
		3495: uint8(0x71),
		3496: uint8(0x7a),
		3497: uint8(0x73),
		3498: uint8(0x74),
		3499: uint8(0x7f),
		3500: uint8(0x7d),
		3501: uint8(0x74),
		3502: uint8(0x71),
		3503: uint8(0x72),
		3504: uint8(0x75),
		3505: uint8(0x7b),
		3506: uint8(0x78),
		3507: uint8(0x76),
		3508: uint8(0x7c),
		3509: uint8(0x77),
		3510: uint8(0x76),
		3511: uint8(0x7c),
		3512: uint8(0x79),
		3513: uint8(0x70),
		3514: uint8(0x73),
		3515: uint8(0x75),
		3516: uint8(0x72),
		3517: uint8(0x7e),
		3518: uint8(0x7f),
		3519: uint8(0x79),
		3520: uint8(0xef),
		3521: uint8(0xe3),
		3522: uint8(0xe1),
		3523: uint8(0xed),
		3524: uint8(0xe8),
		3525: uint8(0xe4),
		3526: uint8(0xee),
		3527: uint8(0xe7),
		3528: uint8(0xe6),
		3529: uint8(0xef),
		3530: uint8(0xeb),
		3531: uint8(0xe2),
		3532: uint8(0xe3),
		3533: uint8(0xe8),
		3534: uint8(0xe4),
		3535: uint8(0xee),
		3536: uint8(0xe9),
		3537: uint8(0xec),
		3538: uint8(0xe7),
		3539: uint8(0xe0),
		3540: uint8(0xe2),
		3541: uint8(0xe1),
		3542: uint8(0xed),
		3543: uint8(0xea),
		3544: uint8(0xec),
		3545: uint8(0xe6),
		3546: uint8(0xe0),
		3547: uint8(0xe9),
		3548: uint8(0xe5),
		3549: uint8(0xeb),
		3550: uint8(0xea),
		3551: uint8(0xe5),
		3552: uint8(0xe0),
		3553: uint8(0xed),
		3554: uint8(0xee),
		3555: uint8(0xe8),
		3556: uint8(0xe7),
		3557: uint8(0xea),
		3558: uint8(0xeb),
		3559: uint8(0xe1),
		3560: uint8(0xea),
		3561: uint8(0xe3),
		3562: uint8(0xe4),
		3563: uint8(0xef),
		3564: uint8(0xed),
		3565: uint8(0xe4),
		3566: uint8(0xe1),
		3567: uint8(0xe2),
		3568: uint8(0xe5),
		3569: uint8(0xeb),
		3570: uint8(0xe8),
		3571: uint8(0xe6),
		3572: uint8(0xec),
		3573: uint8(0xe7),
		3574: uint8(0xe6),
		3575: uint8(0xec),
		3576: uint8(0xe9),
		3577: uint8(0xe0),
		3578: uint8(0xe3),
		3579: uint8(0xe5),
		3580: uint8(0xe2),
		3581: uint8(0xee),
		3582: uint8(0xef),
		3583: uint8(0xe9),
		3584: uint8(0x3f),
		3585: uint8(0x33),
		3586: uint8(0x31),
		3587: uint8(0x3d),
		3588: uint8(0x38),
		3589: uint8(0x34),
		3590: uint8(0x3e),
		3591: uint8(0x37),
		3592: uint8(0x36),
		3593: uint8(0x3f),
		3594: uint8(0x3b),
		3595: uint8(0x32),
		3596: uint8(0x33),
		3597: uint8(0x38),
		3598: uint8(0x34),
		3599: uint8(0x3e),
		3600: uint8(0x39),
		3601: uint8(0x3c),
		3602: uint8(0x37),
		3603: uint8(0x30),
		3604: uint8(0x32),
		3605: uint8(0x31),
		3606: uint8(0x3d),
		3607: uint8(0x3a),
		3608: uint8(0x3c),
		3609: uint8(0x36),
		3610: uint8(0x30),
		3611: uint8(0x39),
		3612: uint8(0x35),
		3613: uint8(0x3b),
		3614: uint8(0x3a),
		3615: uint8(0x35),
		3616: uint8(0x30),
		3617: uint8(0x3d),
		3618: uint8(0x3e),
		3619: uint8(0x38),
		3620: uint8(0x37),
		3621: uint8(0x3a),
		3622: uint8(0x3b),
		3623: uint8(0x31),
		3624: uint8(0x3a),
		3625: uint8(0x33),
		3626: uint8(0x34),
		3627: uint8(0x3f),
		3628: uint8(0x3d),
		3629: uint8(0x34),
		3630: uint8(0x31),
		3631: uint8(0x32),
		3632: uint8(0x35),
		3633: uint8(0x3b),
		3634: uint8(0x38),
		3635: uint8(0x36),
		3636: uint8(0x3c),
		3637: uint8(0x37),
		3638: uint8(0x36),
		3639: uint8(0x3c),
		3640: uint8(0x39),
		3641: uint8(0x30),
		3642: uint8(0x33),
		3643: uint8(0x35),
		3644: uint8(0x32),
		3645: uint8(0x3e),
		3646: uint8(0x3f),
		3647: uint8(0x39),
		3648: uint8(0xaf),
		3649: uint8(0xa3),
		3650: uint8(0xa1),
		3651: uint8(0xad),
		3652: uint8(0xa8),
		3653: uint8(0xa4),
		3654: uint8(0xae),
		3655: uint8(0xa7),
		3656: uint8(0xa6),
		3657: uint8(0xaf),
		3658: uint8(0xab),
		3659: uint8(0xa2),
		3660: uint8(0xa3),
		3661: uint8(0xa8),
		3662: uint8(0xa4),
		3663: uint8(0xae),
		3664: uint8(0xa9),
		3665: uint8(0xac),
		3666: uint8(0xa7),
		3667: uint8(0xa0),
		3668: uint8(0xa2),
		3669: uint8(0xa1),
		3670: uint8(0xad),
		3671: uint8(0xaa),
		3672: uint8(0xac),
		3673: uint8(0xa6),
		3674: uint8(0xa0),
		3675: uint8(0xa9),
		3676: uint8(0xa5),
		3677: uint8(0xab),
		3678: uint8(0xaa),
		3679: uint8(0xa5),
		3680: uint8(0xa0),
		3681: uint8(0xad),
		3682: uint8(0xae),
		3683: uint8(0xa8),
		3684: uint8(0xa7),
		3685: uint8(0xaa),
		3686: uint8(0xab),
		3687: uint8(0xa1),
		3688: uint8(0xaa),
		3689: uint8(0xa3),
		3690: uint8(0xa4),
		3691: uint8(0xaf),
		3692: uint8(0xad),
		3693: uint8(0xa4),
		3694: uint8(0xa1),
		3695: uint8(0xa2),
		3696: uint8(0xa5),
		3697: uint8(0xab),
		3698: uint8(0xa8),
		3699: uint8(0xa6),
		3700: uint8(0xac),
		3701: uint8(0xa7),
		3702: uint8(0xa6),
		3703: uint8(0xac),
		3704: uint8(0xa9),
		3705: uint8(0xa0),
		3706: uint8(0xa3),
		3707: uint8(0xa5),
		3708: uint8(0xa2),
		3709: uint8(0xae),
		3710: uint8(0xaf),
		3711: uint8(0xa9),
		3712: uint8(0xaf),
		3713: uint8(0xa3),
		3714: uint8(0xa1),
		3715: uint8(0xad),
		3716: uint8(0xa8),
		3717: uint8(0xa4),
		3718: uint8(0xae),
		3719: uint8(0xa7),
		3720: uint8(0xa6),
		3721: uint8(0xaf),
		3722: uint8(0xab),
		3723: uint8(0xa2),
		3724: uint8(0xa3),
		3725: uint8(0xa8),
		3726: uint8(0xa4),
		3727: uint8(0xae),
		3728: uint8(0xa9),
		3729: uint8(0xac),
		3730: uint8(0xa7),
		3731: uint8(0xa0),
		3732: uint8(0xa2),
		3733: uint8(0xa1),
		3734: uint8(0xad),
		3735: uint8(0xaa),
		3736: uint8(0xac),
		3737: uint8(0xa6),
		3738: uint8(0xa0),
		3739: uint8(0xa9),
		3740: uint8(0xa5),
		3741: uint8(0xab),
		3742: uint8(0xaa),
		3743: uint8(0xa5),
		3744: uint8(0xa0),
		3745: uint8(0xad),
		3746: uint8(0xae),
		3747: uint8(0xa8),
		3748: uint8(0xa7),
		3749: uint8(0xaa),
		3750: uint8(0xab),
		3751: uint8(0xa1),
		3752: uint8(0xaa),
		3753: uint8(0xa3),
		3754: uint8(0xa4),
		3755: uint8(0xaf),
		3756: uint8(0xad),
		3757: uint8(0xa4),
		3758: uint8(0xa1),
		3759: uint8(0xa2),
		3760: uint8(0xa5),
		3761: uint8(0xab),
		3762: uint8(0xa8),
		3763: uint8(0xa6),
		3764: uint8(0xac),
		3765: uint8(0xa7),
		3766: uint8(0xa6),
		3767: uint8(0xac),
		3768: uint8(0xa9),
		3769: uint8(0xa0),
		3770: uint8(0xa3),
		3771: uint8(0xa5),
		3772: uint8(0xa2),
		3773: uint8(0xae),
		3774: uint8(0xaf),
		3775: uint8(0xa9),
		3776: uint8(0x0f),
		3777: uint8(0x03),
		3778: uint8(0x01),
		3779: uint8(0x0d),
		3780: uint8(0x08),
		3781: uint8(0x04),
		3782: uint8(0x0e),
		3783: uint8(0x07),
		3784: uint8(0x06),
		3785: uint8(0x0f),
		3786: uint8(0x0b),
		3787: uint8(0x02),
		3788: uint8(0x03),
		3789: uint8(0x08),
		3790: uint8(0x04),
		3791: uint8(0x0e),
		3792: uint8(0x09),
		3793: uint8(0x0c),
		3794: uint8(0x07),
		3795: uint8(0x00),
		3796: uint8(0x02),
		3797: uint8(0x01),
		3798: uint8(0x0d),
		3799: uint8(0x0a),
		3800: uint8(0x0c),
		3801: uint8(0x06),
		3802: uint8(0x00),
		3803: uint8(0x09),
		3804: uint8(0x05),
		3805: uint8(0x0b),
		3806: uint8(0x0a),
		3807: uint8(0x05),
		3808: uint8(0x00),
		3809: uint8(0x0d),
		3810: uint8(0x0e),
		3811: uint8(0x08),
		3812: uint8(0x07),
		3813: uint8(0x0a),
		3814: uint8(0x0b),
		3815: uint8(0x01),
		3816: uint8(0x0a),
		3817: uint8(0x03),
		3818: uint8(0x04),
		3819: uint8(0x0f),
		3820: uint8(0x0d),
		3821: uint8(0x04),
		3822: uint8(0x01),
		3823: uint8(0x02),
		3824: uint8(0x05),
		3825: uint8(0x0b),
		3826: uint8(0x08),
		3827: uint8(0x06),
		3828: uint8(0x0c),
		3829: uint8(0x07),
		3830: uint8(0x06),
		3831: uint8(0x0c),
		3832: uint8(0x09),
		3833: uint8(0x00),
		3834: uint8(0x03),
		3835: uint8(0x05),
		3836: uint8(0x02),
		3837: uint8(0x0e),
		3838: uint8(0x0f),
		3839: uint8(0x09),
		3840: uint8(0x5f),
		3841: uint8(0x53),
		3842: uint8(0x51),
		3843: uint8(0x5d),
		3844: uint8(0x58),
		3845: uint8(0x54),
		3846: uint8(0x5e),
		3847: uint8(0x57),
		3848: uint8(0x56),
		3849: uint8(0x5f),
		3850: uint8(0x5b),
		3851: uint8(0x52),
		3852: uint8(0x53),
		3853: uint8(0x58),
		3854: uint8(0x54),
		3855: uint8(0x5e),
		3856: uint8(0x59),
		3857: uint8(0x5c),
		3858: uint8(0x57),
		3859: uint8(0x50),
		3860: uint8(0x52),
		3861: uint8(0x51),
		3862: uint8(0x5d),
		3863: uint8(0x5a),
		3864: uint8(0x5c),
		3865: uint8(0x56),
		3866: uint8(0x50),
		3867: uint8(0x59),
		3868: uint8(0x55),
		3869: uint8(0x5b),
		3870: uint8(0x5a),
		3871: uint8(0x55),
		3872: uint8(0x50),
		3873: uint8(0x5d),
		3874: uint8(0x5e),
		3875: uint8(0x58),
		3876: uint8(0x57),
		3877: uint8(0x5a),
		3878: uint8(0x5b),
		3879: uint8(0x51),
		3880: uint8(0x5a),
		3881: uint8(0x53),
		3882: uint8(0x54),
		3883: uint8(0x5f),
		3884: uint8(0x5d),
		3885: uint8(0x54),
		3886: uint8(0x51),
		3887: uint8(0x52),
		3888: uint8(0x55),
		3889: uint8(0x5b),
		3890: uint8(0x58),
		3891: uint8(0x56),
		3892: uint8(0x5c),
		3893: uint8(0x57),
		3894: uint8(0x56),
		3895: uint8(0x5c),
		3896: uint8(0x59),
		3897: uint8(0x50),
		3898: uint8(0x53),
		3899: uint8(0x55),
		3900: uint8(0x52),
		3901: uint8(0x5e),
		3902: uint8(0x5f),
		3903: uint8(0x59),
		3904: uint8(0x6f),
		3905: uint8(0x63),
		3906: uint8(0x61),
		3907: uint8(0x6d),
		3908: uint8(0x68),
		3909: uint8(0x64),
		3910: uint8(0x6e),
		3911: uint8(0x67),
		3912: uint8(0x66),
		3913: uint8(0x6f),
		3914: uint8(0x6b),
		3915: uint8(0x62),
		3916: uint8(0x63),
		3917: uint8(0x68),
		3918: uint8(0x64),
		3919: uint8(0x6e),
		3920: uint8(0x69),
		3921: uint8(0x6c),
		3922: uint8(0x67),
		3923: uint8(0x60),
		3924: uint8(0x62),
		3925: uint8(0x61),
		3926: uint8(0x6d),
		3927: uint8(0x6a),
		3928: uint8(0x6c),
		3929: uint8(0x66),
		3930: uint8(0x60),
		3931: uint8(0x69),
		3932: uint8(0x65),
		3933: uint8(0x6b),
		3934: uint8(0x6a),
		3935: uint8(0x65),
		3936: uint8(0x60),
		3937: uint8(0x6d),
		3938: uint8(0x6e),
		3939: uint8(0x68),
		3940: uint8(0x67),
		3941: uint8(0x6a),
		3942: uint8(0x6b),
		3943: uint8(0x61),
		3944: uint8(0x6a),
		3945: uint8(0x63),
		3946: uint8(0x64),
		3947: uint8(0x6f),
		3948: uint8(0x6d),
		3949: uint8(0x64),
		3950: uint8(0x61),
		3951: uint8(0x62),
		3952: uint8(0x65),
		3953: uint8(0x6b),
		3954: uint8(0x68),
		3955: uint8(0x66),
		3956: uint8(0x6c),
		3957: uint8(0x67),
		3958: uint8(0x66),
		3959: uint8(0x6c),
		3960: uint8(0x69),
		3961: uint8(0x60),
		3962: uint8(0x63),
		3963: uint8(0x65),
		3964: uint8(0x62),
		3965: uint8(0x6e),
		3966: uint8(0x6f),
		3967: uint8(0x69),
		3968: uint8(0x0f),
		3969: uint8(0x03),
		3970: uint8(0x01),
		3971: uint8(0x0d),
		3972: uint8(0x08),
		3973: uint8(0x04),
		3974: uint8(0x0e),
		3975: uint8(0x07),
		3976: uint8(0x06),
		3977: uint8(0x0f),
		3978: uint8(0x0b),
		3979: uint8(0x02),
		3980: uint8(0x03),
		3981: uint8(0x08),
		3982: uint8(0x04),
		3983: uint8(0x0e),
		3984: uint8(0x09),
		3985: uint8(0x0c),
		3986: uint8(0x07),
		3987: uint8(0x00),
		3988: uint8(0x02),
		3989: uint8(0x01),
		3990: uint8(0x0d),
		3991: uint8(0x0a),
		3992: uint8(0x0c),
		3993: uint8(0x06),
		3994: uint8(0x00),
		3995: uint8(0x09),
		3996: uint8(0x05),
		3997: uint8(0x0b),
		3998: uint8(0x0a),
		3999: uint8(0x05),
		4000: uint8(0x00),
		4001: uint8(0x0d),
		4002: uint8(0x0e),
		4003: uint8(0x08),
		4004: uint8(0x07),
		4005: uint8(0x0a),
		4006: uint8(0x0b),
		4007: uint8(0x01),
		4008: uint8(0x0a),
		4009: uint8(0x03),
		4010: uint8(0x04),
		4011: uint8(0x0f),
		4012: uint8(0x0d),
		4013: uint8(0x04),
		4014: uint8(0x01),
		4015: uint8(0x02),
		4016: uint8(0x05),
		4017: uint8(0x0b),
		4018: uint8(0x08),
		4019: uint8(0x06),
		4020: uint8(0x0c),
		4021: uint8(0x07),
		4022: uint8(0x06),
		4023: uint8(0x0c),
		4024: uint8(0x09),
		4025: uint8(0x00),
		4026: uint8(0x03),
		4027: uint8(0x05),
		4028: uint8(0x02),
		4029: uint8(0x0e),
		4030: uint8(0x0f),
		4031: uint8(0x09),
		4032: uint8(0xdf),
		4033: uint8(0xd3),
		4034: uint8(0xd1),
		4035: uint8(0xdd),
		4036: uint8(0xd8),
		4037: uint8(0xd4),
		4038: uint8(0xde),
		4039: uint8(0xd7),
		4040: uint8(0xd6),
		4041: uint8(0xdf),
		4042: uint8(0xdb),
		4043: uint8(0xd2),
		4044: uint8(0xd3),
		4045: uint8(0xd8),
		4046: uint8(0xd4),
		4047: uint8(0xde),
		4048: uint8(0xd9),
		4049: uint8(0xdc),
		4050: uint8(0xd7),
		4051: uint8(0xd0),
		4052: uint8(0xd2),
		4053: uint8(0xd1),
		4054: uint8(0xdd),
		4055: uint8(0xda),
		4056: uint8(0xdc),
		4057: uint8(0xd6),
		4058: uint8(0xd0),
		4059: uint8(0xd9),
		4060: uint8(0xd5),
		4061: uint8(0xdb),
		4062: uint8(0xda),
		4063: uint8(0xd5),
		4064: uint8(0xd0),
		4065: uint8(0xdd),
		4066: uint8(0xde),
		4067: uint8(0xd8),
		4068: uint8(0xd7),
		4069: uint8(0xda),
		4070: uint8(0xdb),
		4071: uint8(0xd1),
		4072: uint8(0xda),
		4073: uint8(0xd3),
		4074: uint8(0xd4),
		4075: uint8(0xdf),
		4076: uint8(0xdd),
		4077: uint8(0xd4),
		4078: uint8(0xd1),
		4079: uint8(0xd2),
		4080: uint8(0xd5),
		4081: uint8(0xdb),
		4082: uint8(0xd8),
		4083: uint8(0xd6),
		4084: uint8(0xdc),
		4085: uint8(0xd7),
		4086: uint8(0xd6),
		4087: uint8(0xdc),
		4088: uint8(0xd9),
		4089: uint8(0xd0),
		4090: uint8(0xd3),
		4091: uint8(0xd5),
		4092: uint8(0xd2),
		4093: uint8(0xde),
		4094: uint8(0xdf),
		4095: uint8(0xd9)},
	1: {
		0:    uint8(0xa7),
		1:    uint8(0xad),
		2:    uint8(0xad),
		3:    uint8(0xa8),
		4:    uint8(0xae),
		5:    uint8(0xab),
		6:    uint8(0xa3),
		7:    uint8(0xa5),
		8:    uint8(0xa0),
		9:    uint8(0xa6),
		10:   uint8(0xa6),
		11:   uint8(0xaf),
		12:   uint8(0xa9),
		13:   uint8(0xa0),
		14:   uint8(0xaa),
		15:   uint8(0xa3),
		16:   uint8(0xa1),
		17:   uint8(0xa4),
		18:   uint8(0xa2),
		19:   uint8(0xa7),
		20:   uint8(0xa8),
		21:   uint8(0xa2),
		22:   uint8(0xa5),
		23:   uint8(0xac),
		24:   uint8(0xab),
		25:   uint8(0xa1),
		26:   uint8(0xac),
		27:   uint8(0xaa),
		28:   uint8(0xa4),
		29:   uint8(0xae),
		30:   uint8(0xaf),
		31:   uint8(0xa9),
		32:   uint8(0xaa),
		33:   uint8(0xa3),
		34:   uint8(0xa6),
		35:   uint8(0xaf),
		36:   uint8(0xa9),
		37:   uint8(0xa0),
		38:   uint8(0xa0),
		39:   uint8(0xa6),
		40:   uint8(0xac),
		41:   uint8(0xaa),
		42:   uint8(0xab),
		43:   uint8(0xa1),
		44:   uint8(0xa7),
		45:   uint8(0xad),
		46:   uint8(0xad),
		47:   uint8(0xa8),
		48:   uint8(0xaf),
		49:   uint8(0xa9),
		50:   uint8(0xa1),
		51:   uint8(0xa4),
		52:   uint8(0xa3),
		53:   uint8(0xa5),
		54:   uint8(0xae),
		55:   uint8(0xab),
		56:   uint8(0xa5),
		57:   uint8(0xac),
		58:   uint8(0xa2),
		59:   uint8(0xa7),
		60:   uint8(0xa8),
		61:   uint8(0xa2),
		62:   uint8(0xa4),
		63:   uint8(0xae),
		64:   uint8(0xd7),
		65:   uint8(0xdd),
		66:   uint8(0xdd),
		67:   uint8(0xd8),
		68:   uint8(0xde),
		69:   uint8(0xdb),
		70:   uint8(0xd3),
		71:   uint8(0xd5),
		72:   uint8(0xd0),
		73:   uint8(0xd6),
		74:   uint8(0xd6),
		75:   uint8(0xdf),
		76:   uint8(0xd9),
		77:   uint8(0xd0),
		78:   uint8(0xda),
		79:   uint8(0xd3),
		80:   uint8(0xd1),
		81:   uint8(0xd4),
		82:   uint8(0xd2),
		83:   uint8(0xd7),
		84:   uint8(0xd8),
		85:   uint8(0xd2),
		86:   uint8(0xd5),
		87:   uint8(0xdc),
		88:   uint8(0xdb),
		89:   uint8(0xd1),
		90:   uint8(0xdc),
		91:   uint8(0xda),
		92:   uint8(0xd4),
		93:   uint8(0xde),
		94:   uint8(0xdf),
		95:   uint8(0xd9),
		96:   uint8(0xda),
		97:   uint8(0xd3),
		98:   uint8(0xd6),
		99:   uint8(0xdf),
		100:  uint8(0xd9),
		101:  uint8(0xd0),
		102:  uint8(0xd0),
		103:  uint8(0xd6),
		104:  uint8(0xdc),
		105:  uint8(0xda),
		106:  uint8(0xdb),
		107:  uint8(0xd1),
		108:  uint8(0xd7),
		109:  uint8(0xdd),
		110:  uint8(0xdd),
		111:  uint8(0xd8),
		112:  uint8(0xdf),
		113:  uint8(0xd9),
		114:  uint8(0xd1),
		115:  uint8(0xd4),
		116:  uint8(0xd3),
		117:  uint8(0xd5),
		118:  uint8(0xde),
		119:  uint8(0xdb),
		120:  uint8(0xd5),
		121:  uint8(0xdc),
		122:  uint8(0xd2),
		123:  uint8(0xd7),
		124:  uint8(0xd8),
		125:  uint8(0xd2),
		126:  uint8(0xd4),
		127:  uint8(0xde),
		128:  uint8(0x07),
		129:  uint8(0x0d),
		130:  uint8(0x0d),
		131:  uint8(0x08),
		132:  uint8(0x0e),
		133:  uint8(0x0b),
		134:  uint8(0x03),
		135:  uint8(0x05),
		136:  uint8(0x00),
		137:  uint8(0x06),
		138:  uint8(0x06),
		139:  uint8(0x0f),
		140:  uint8(0x09),
		141:  uint8(0x00),
		142:  uint8(0x0a),
		143:  uint8(0x03),
		144:  uint8(0x01),
		145:  uint8(0x04),
		146:  uint8(0x02),
		147:  uint8(0x07),
		148:  uint8(0x08),
		149:  uint8(0x02),
		150:  uint8(0x05),
		151:  uint8(0x0c),
		152:  uint8(0x0b),
		153:  uint8(0x01),
		154:  uint8(0x0c),
		155:  uint8(0x0a),
		156:  uint8(0x04),
		157:  uint8(0x0e),
		158:  uint8(0x0f),
		159:  uint8(0x09),
		160:  uint8(0x0a),
		161:  uint8(0x03),
		162:  uint8(0x06),
		163:  uint8(0x0f),
		164:  uint8(0x09),
		165:  uint8(0x00),
		166:  uint8(0x00),
		167:  uint8(0x06),
		168:  uint8(0x0c),
		169:  uint8(0x0a),
		170:  uint8(0x0b),
		171:  uint8(0x01),
		172:  uint8(0x07),
		173:  uint8(0x0d),
		174:  uint8(0x0d),
		175:  uint8(0x08),
		176:  uint8(0x0f),
		177:  uint8(0x09),
		178:  uint8(0x01),
		179:  uint8(0x04),
		180:  uint8(0x03),
		181:  uint8(0x05),
		182:  uint8(0x0e),
		183:  uint8(0x0b),
		184:  uint8(0x05),
		185:  uint8(0x0c),
		186:  uint8(0x02),
		187:  uint8(0x07),
		188:  uint8(0x08),
		189:  uint8(0x02),
		190:  uint8(0x04),
		191:  uint8(0x0e),
		192:  uint8(0x77),
		193:  uint8(0x7d),
		194:  uint8(0x7d),
		195:  uint8(0x78),
		196:  uint8(0x7e),
		197:  uint8(0x7b),
		198:  uint8(0x73),
		199:  uint8(0x75),
		200:  uint8(0x70),
		201:  uint8(0x76),
		202:  uint8(0x76),
		203:  uint8(0x7f),
		204:  uint8(0x79),
		205:  uint8(0x70),
		206:  uint8(0x7a),
		207:  uint8(0x73),
		208:  uint8(0x71),
		209:  uint8(0x74),
		210:  uint8(0x72),
		211:  uint8(0x77),
		212:  uint8(0x78),
		213:  uint8(0x72),
		214:  uint8(0x75),
		215:  uint8(0x7c),
		216:  uint8(0x7b),
		217:  uint8(0x71),
		218:  uint8(0x7c),
		219:  uint8(0x7a),
		220:  uint8(0x74),
		221:  uint8(0x7e),
		222:  uint8(0x7f),
		223:  uint8(0x79),
		224:  uint8(0x7a),
		225:  uint8(0x73),
		226:  uint8(0x76),
		227:  uint8(0x7f),
		228:  uint8(0x79),
		229:  uint8(0x70),
		230:  uint8(0x70),
		231:  uint8(0x76),
		232:  uint8(0x7c),
		233:  uint8(0x7a),
		234:  uint8(0x7b),
		235:  uint8(0x71),
		236:  uint8(0x77),
		237:  uint8(0x7d),
		238:  uint8(0x7d),
		239:  uint8(0x78),
		240:  uint8(0x7f),
		241:  uint8(0x79),
		242:  uint8(0x71),
		243:  uint8(0x74),
		244:  uint8(0x73),
		245:  uint8(0x75),
		246:  uint8(0x7e),
		247:  uint8(0x7b),
		248:  uint8(0x75),
		249:  uint8(0x7c),
		250:  uint8(0x72),
		251:  uint8(0x77),
		252:  uint8(0x78),
		253:  uint8(0x72),
		254:  uint8(0x74),
		255:  uint8(0x7e),
		256:  uint8(0x97),
		257:  uint8(0x9d),
		258:  uint8(0x9d),
		259:  uint8(0x98),
		260:  uint8(0x9e),
		261:  uint8(0x9b),
		262:  uint8(0x93),
		263:  uint8(0x95),
		264:  uint8(0x90),
		265:  uint8(0x96),
		266:  uint8(0x96),
		267:  uint8(0x9f),
		268:  uint8(0x99),
		269:  uint8(0x90),
		270:  uint8(0x9a),
		271:  uint8(0x93),
		272:  uint8(0x91),
		273:  uint8(0x94),
		274:  uint8(0x92),
		275:  uint8(0x97),
		276:  uint8(0x98),
		277:  uint8(0x92),
		278:  uint8(0x95),
		279:  uint8(0x9c),
		280:  uint8(0x9b),
		281:  uint8(0x91),
		282:  uint8(0x9c),
		283:  uint8(0x9a),
		284:  uint8(0x94),
		285:  uint8(0x9e),
		286:  uint8(0x9f),
		287:  uint8(0x99),
		288:  uint8(0x9a),
		289:  uint8(0x93),
		290:  uint8(0x96),
		291:  uint8(0x9f),
		292:  uint8(0x99),
		293:  uint8(0x90),
		294:  uint8(0x90),
		295:  uint8(0x96),
		296:  uint8(0x9c),
		297:  uint8(0x9a),
		298:  uint8(0x9b),
		299:  uint8(0x91),
		300:  uint8(0x97),
		301:  uint8(0x9d),
		302:  uint8(0x9d),
		303:  uint8(0x98),
		304:  uint8(0x9f),
		305:  uint8(0x99),
		306:  uint8(0x91),
		307:  uint8(0x94),
		308:  uint8(0x93),
		309:  uint8(0x95),
		310:  uint8(0x9e),
		311:  uint8(0x9b),
		312:  uint8(0x95),
		313:  uint8(0x9c),
		314:  uint8(0x92),
		315:  uint8(0x97),
		316:  uint8(0x98),
		317:  uint8(0x92),
		318:  uint8(0x94),
		319:  uint8(0x9e),
		320:  uint8(0x07),
		321:  uint8(0x0d),
		322:  uint8(0x0d),
		323:  uint8(0x08),
		324:  uint8(0x0e),
		325:  uint8(0x0b),
		326:  uint8(0x03),
		327:  uint8(0x05),
		328:  uint8(0x00),
		329:  uint8(0x06),
		330:  uint8(0x06),
		331:  uint8(0x0f),
		332:  uint8(0x09),
		333:  uint8(0x00),
		334:  uint8(0x0a),
		335:  uint8(0x03),
		336:  uint8(0x01),
		337:  uint8(0x04),
		338:  uint8(0x02),
		339:  uint8(0x07),
		340:  uint8(0x08),
		341:  uint8(0x02),
		342:  uint8(0x05),
		343:  uint8(0x0c),
		344:  uint8(0x0b),
		345:  uint8(0x01),
		346:  uint8(0x0c),
		347:  uint8(0x0a),
		348:  uint8(0x04),
		349:  uint8(0x0e),
		350:  uint8(0x0f),
		351:  uint8(0x09),
		352:  uint8(0x0a),
		353:  uint8(0x03),
		354:  uint8(0x06),
		355:  uint8(0x0f),
		356:  uint8(0x09),
		357:  uint8(0x00),
		358:  uint8(0x00),
		359:  uint8(0x06),
		360:  uint8(0x0c),
		361:  uint8(0x0a),
		362:  uint8(0x0b),
		363:  uint8(0x01),
		364:  uint8(0x07),
		365:  uint8(0x0d),
		366:  uint8(0x0d),
		367:  uint8(0x08),
		368:  uint8(0x0f),
		369:  uint8(0x09),
		370:  uint8(0x01),
		371:  uint8(0x04),
		372:  uint8(0x03),
		373:  uint8(0x05),
		374:  uint8(0x0e),
		375:  uint8(0x0b),
		376:  uint8(0x05),
		377:  uint8(0x0c),
		378:  uint8(0x02),
		379:  uint8(0x07),
		380:  uint8(0x08),
		381:  uint8(0x02),
		382:  uint8(0x04),
		383:  uint8(0x0e),
		384:  uint8(0xe7),
		385:  uint8(0xed),
		386:  uint8(0xed),
		387:  uint8(0xe8),
		388:  uint8(0xee),
		389:  uint8(0xeb),
		390:  uint8(0xe3),
		391:  uint8(0xe5),
		392:  uint8(0xe0),
		393:  uint8(0xe6),
		394:  uint8(0xe6),
		395:  uint8(0xef),
		396:  uint8(0xe9),
		397:  uint8(0xe0),
		398:  uint8(0xea),
		399:  uint8(0xe3),
		400:  uint8(0xe1),
		401:  uint8(0xe4),
		402:  uint8(0xe2),
		403:  uint8(0xe7),
		404:  uint8(0xe8),
		405:  uint8(0xe2),
		406:  uint8(0xe5),
		407:  uint8(0xec),
		408:  uint8(0xeb),
		409:  uint8(0xe1),
		410:  uint8(0xec),
		411:  uint8(0xea),
		412:  uint8(0xe4),
		413:  uint8(0xee),
		414:  uint8(0xef),
		415:  uint8(0xe9),
		416:  uint8(0xea),
		417:  uint8(0xe3),
		418:  uint8(0xe6),
		419:  uint8(0xef),
		420:  uint8(0xe9),
		421:  uint8(0xe0),
		422:  uint8(0xe0),
		423:  uint8(0xe6),
		424:  uint8(0xec),
		425:  uint8(0xea),
		426:  uint8(0xeb),
		427:  uint8(0xe1),
		428:  uint8(0xe7),
		429:  uint8(0xed),
		430:  uint8(0xed),
		431:  uint8(0xe8),
		432:  uint8(0xef),
		433:  uint8(0xe9),
		434:  uint8(0xe1),
		435:  uint8(0xe4),
		436:  uint8(0xe3),
		437:  uint8(0xe5),
		438:  uint8(0xee),
		439:  uint8(0xeb),
		440:  uint8(0xe5),
		441:  uint8(0xec),
		442:  uint8(0xe2),
		443:  uint8(0xe7),
		444:  uint8(0xe8),
		445:  uint8(0xe2),
		446:  uint8(0xe4),
		447:  uint8(0xee),
		448:  uint8(0x97),
		449:  uint8(0x9d),
		450:  uint8(0x9d),
		451:  uint8(0x98),
		452:  uint8(0x9e),
		453:  uint8(0x9b),
		454:  uint8(0x93),
		455:  uint8(0x95),
		456:  uint8(0x90),
		457:  uint8(0x96),
		458:  uint8(0x96),
		459:  uint8(0x9f),
		460:  uint8(0x99),
		461:  uint8(0x90),
		462:  uint8(0x9a),
		463:  uint8(0x93),
		464:  uint8(0x91),
		465:  uint8(0x94),
		466:  uint8(0x92),
		467:  uint8(0x97),
		468:  uint8(0x98),
		469:  uint8(0x92),
		470:  uint8(0x95),
		471:  uint8(0x9c),
		472:  uint8(0x9b),
		473:  uint8(0x91),
		474:  uint8(0x9c),
		475:  uint8(0x9a),
		476:  uint8(0x94),
		477:  uint8(0x9e),
		478:  uint8(0x9f),
		479:  uint8(0x99),
		480:  uint8(0x9a),
		481:  uint8(0x93),
		482:  uint8(0x96),
		483:  uint8(0x9f),
		484:  uint8(0x99),
		485:  uint8(0x90),
		486:  uint8(0x90),
		487:  uint8(0x96),
		488:  uint8(0x9c),
		489:  uint8(0x9a),
		490:  uint8(0x9b),
		491:  uint8(0x91),
		492:  uint8(0x97),
		493:  uint8(0x9d),
		494:  uint8(0x9d),
		495:  uint8(0x98),
		496:  uint8(0x9f),
		497:  uint8(0x99),
		498:  uint8(0x91),
		499:  uint8(0x94),
		500:  uint8(0x93),
		501:  uint8(0x95),
		502:  uint8(0x9e),
		503:  uint8(0x9b),
		504:  uint8(0x95),
		505:  uint8(0x9c),
		506:  uint8(0x92),
		507:  uint8(0x97),
		508:  uint8(0x98),
		509:  uint8(0x92),
		510:  uint8(0x94),
		511:  uint8(0x9e),
		512:  uint8(0x67),
		513:  uint8(0x6d),
		514:  uint8(0x6d),
		515:  uint8(0x68),
		516:  uint8(0x6e),
		517:  uint8(0x6b),
		518:  uint8(0x63),
		519:  uint8(0x65),
		520:  uint8(0x60),
		521:  uint8(0x66),
		522:  uint8(0x66),
		523:  uint8(0x6f),
		524:  uint8(0x69),
		525:  uint8(0x60),
		526:  uint8(0x6a),
		527:  uint8(0x63),
		528:  uint8(0x61),
		529:  uint8(0x64),
		530:  uint8(0x62),
		531:  uint8(0x67),
		532:  uint8(0x68),
		533:  uint8(0x62),
		534:  uint8(0x65),
		535:  uint8(0x6c),
		536:  uint8(0x6b),
		537:  uint8(0x61),
		538:  uint8(0x6c),
		539:  uint8(0x6a),
		540:  uint8(0x64),
		541:  uint8(0x6e),
		542:  uint8(0x6f),
		543:  uint8(0x69),
		544:  uint8(0x6a),
		545:  uint8(0x63),
		546:  uint8(0x66),
		547:  uint8(0x6f),
		548:  uint8(0x69),
		549:  uint8(0x60),
		550:  uint8(0x60),
		551:  uint8(0x66),
		552:  uint8(0x6c),
		553:  uint8(0x6a),
		554:  uint8(0x6b),
		555:  uint8(0x61),
		556:  uint8(0x67),
		557:  uint8(0x6d),
		558:  uint8(0x6d),
		559:  uint8(0x68),
		560:  uint8(0x6f),
		561:  uint8(0x69),
		562:  uint8(0x61),
		563:  uint8(0x64),
		564:  uint8(0x63),
		565:  uint8(0x65),
		566:  uint8(0x6e),
		567:  uint8(0x6b),
		568:  uint8(0x65),
		569:  uint8(0x6c),
		570:  uint8(0x62),
		571:  uint8(0x67),
		572:  uint8(0x68),
		573:  uint8(0x62),
		574:  uint8(0x64),
		575:  uint8(0x6e),
		576:  uint8(0x37),
		577:  uint8(0x3d),
		578:  uint8(0x3d),
		579:  uint8(0x38),
		580:  uint8(0x3e),
		581:  uint8(0x3b),
		582:  uint8(0x33),
		583:  uint8(0x35),
		584:  uint8(0x30),
		585:  uint8(0x36),
		586:  uint8(0x36),
		587:  uint8(0x3f),
		588:  uint8(0x39),
		589:  uint8(0x30),
		590:  uint8(0x3a),
		591:  uint8(0x33),
		592:  uint8(0x31),
		593:  uint8(0x34),
		594:  uint8(0x32),
		595:  uint8(0x37),
		596:  uint8(0x38),
		597:  uint8(0x32),
		598:  uint8(0x35),
		599:  uint8(0x3c),
		600:  uint8(0x3b),
		601:  uint8(0x31),
		602:  uint8(0x3c),
		603:  uint8(0x3a),
		604:  uint8(0x34),
		605:  uint8(0x3e),
		606:  uint8(0x3f),
		607:  uint8(0x39),
		608:  uint8(0x3a),
		609:  uint8(0x33),
		610:  uint8(0x36),
		611:  uint8(0x3f),
		612:  uint8(0x39),
		613:  uint8(0x30),
		614:  uint8(0x30),
		615:  uint8(0x36),
		616:  uint8(0x3c),
		617:  uint8(0x3a),
		618:  uint8(0x3b),
		619:  uint8(0x31),
		620:  uint8(0x37),
		621:  uint8(0x3d),
		622:  uint8(0x3d),
		623:  uint8(0x38),
		624:  uint8(0x3f),
		625:  uint8(0x39),
		626:  uint8(0x31),
		627:  uint8(0x34),
		628:  uint8(0x33),
		629:  uint8(0x35),
		630:  uint8(0x3e),
		631:  uint8(0x3b),
		632:  uint8(0x35),
		633:  uint8(0x3c),
		634:  uint8(0x32),
		635:  uint8(0x37),
		636:  uint8(0x38),
		637:  uint8(0x32),
		638:  uint8(0x34),
		639:  uint8(0x3e),
		640:  uint8(0x37),
		641:  uint8(0x3d),
		642:  uint8(0x3d),
		643:  uint8(0x38),
		644:  uint8(0x3e),
		645:  uint8(0x3b),
		646:  uint8(0x33),
		647:  uint8(0x35),
		648:  uint8(0x30),
		649:  uint8(0x36),
		650:  uint8(0x36),
		651:  uint8(0x3f),
		652:  uint8(0x39),
		653:  uint8(0x30),
		654:  uint8(0x3a),
		655:  uint8(0x33),
		656:  uint8(0x31),
		657:  uint8(0x34),
		658:  uint8(0x32),
		659:  uint8(0x37),
		660:  uint8(0x38),
		661:  uint8(0x32),
		662:  uint8(0x35),
		663:  uint8(0x3c),
		664:  uint8(0x3b),
		665:  uint8(0x31),
		666:  uint8(0x3c),
		667:  uint8(0x3a),
		668:  uint8(0x34),
		669:  uint8(0x3e),
		670:  uint8(0x3f),
		671:  uint8(0x39),
		672:  uint8(0x3a),
		673:  uint8(0x33),
		674:  uint8(0x36),
		675:  uint8(0x3f),
		676:  uint8(0x39),
		677:  uint8(0x30),
		678:  uint8(0x30),
		679:  uint8(0x36),
		680:  uint8(0x3c),
		681:  uint8(0x3a),
		682:  uint8(0x3b),
		683:  uint8(0x31),
		684:  uint8(0x37),
		685:  uint8(0x3d),
		686:  uint8(0x3d),
		687:  uint8(0x38),
		688:  uint8(0x3f),
		689:  uint8(0x39),
		690:  uint8(0x31),
		691:  uint8(0x34),
		692:  uint8(0x33),
		693:  uint8(0x35),
		694:  uint8(0x3e),
		695:  uint8(0x3b),
		696:  uint8(0x35),
		697:  uint8(0x3c),
		698:  uint8(0x32),
		699:  uint8(0x37),
		700:  uint8(0x38),
		701:  uint8(0x32),
		702:  uint8(0x34),
		703:  uint8(0x3e),
		704:  uint8(0x47),
		705:  uint8(0x4d),
		706:  uint8(0x4d),
		707:  uint8(0x48),
		708:  uint8(0x4e),
		709:  uint8(0x4b),
		710:  uint8(0x43),
		711:  uint8(0x45),
		712:  uint8(0x40),
		713:  uint8(0x46),
		714:  uint8(0x46),
		715:  uint8(0x4f),
		716:  uint8(0x49),
		717:  uint8(0x40),
		718:  uint8(0x4a),
		719:  uint8(0x43),
		720:  uint8(0x41),
		721:  uint8(0x44),
		722:  uint8(0x42),
		723:  uint8(0x47),
		724:  uint8(0x48),
		725:  uint8(0x42),
		726:  uint8(0x45),
		727:  uint8(0x4c),
		728:  uint8(0x4b),
		729:  uint8(0x41),
		730:  uint8(0x4c),
		731:  uint8(0x4a),
		732:  uint8(0x44),
		733:  uint8(0x4e),
		734:  uint8(0x4f),
		735:  uint8(0x49),
		736:  uint8(0x4a),
		737:  uint8(0x43),
		738:  uint8(0x46),
		739:  uint8(0x4f),
		740:  uint8(0x49),
		741:  uint8(0x40),
		742:  uint8(0x40),
		743:  uint8(0x46),
		744:  uint8(0x4c),
		745:  uint8(0x4a),
		746:  uint8(0x4b),
		747:  uint8(0x41),
		748:  uint8(0x47),
		749:  uint8(0x4d),
		750:  uint8(0x4d),
		751:  uint8(0x48),
		752:  uint8(0x4f),
		753:  uint8(0x49),
		754:  uint8(0x41),
		755:  uint8(0x44),
		756:  uint8(0x43),
		757:  uint8(0x45),
		758:  uint8(0x4e),
		759:  uint8(0x4b),
		760:  uint8(0x45),
		761:  uint8(0x4c),
		762:  uint8(0x42),
		763:  uint8(0x47),
		764:  uint8(0x48),
		765:  uint8(0x42),
		766:  uint8(0x44),
		767:  uint8(0x4e),
		768:  uint8(0xf7),
		769:  uint8(0xfd),
		770:  uint8(0xfd),
		771:  uint8(0xf8),
		772:  uint8(0xfe),
		773:  uint8(0xfb),
		774:  uint8(0xf3),
		775:  uint8(0xf5),
		776:  uint8(0xf0),
		777:  uint8(0xf6),
		778:  uint8(0xf6),
		779:  uint8(0xff),
		780:  uint8(0xf9),
		781:  uint8(0xf0),
		782:  uint8(0xfa),
		783:  uint8(0xf3),
		784:  uint8(0xf1),
		785:  uint8(0xf4),
		786:  uint8(0xf2),
		787:  uint8(0xf7),
		788:  uint8(0xf8),
		789:  uint8(0xf2),
		790:  uint8(0xf5),
		791:  uint8(0xfc),
		792:  uint8(0xfb),
		793:  uint8(0xf1),
		794:  uint8(0xfc),
		795:  uint8(0xfa),
		796:  uint8(0xf4),
		797:  uint8(0xfe),
		798:  uint8(0xff),
		799:  uint8(0xf9),
		800:  uint8(0xfa),
		801:  uint8(0xf3),
		802:  uint8(0xf6),
		803:  uint8(0xff),
		804:  uint8(0xf9),
		805:  uint8(0xf0),
		806:  uint8(0xf0),
		807:  uint8(0xf6),
		808:  uint8(0xfc),
		809:  uint8(0xfa),
		810:  uint8(0xfb),
		811:  uint8(0xf1),
		812:  uint8(0xf7),
		813:  uint8(0xfd),
		814:  uint8(0xfd),
		815:  uint8(0xf8),
		816:  uint8(0xff),
		817:  uint8(0xf9),
		818:  uint8(0xf1),
		819:  uint8(0xf4),
		820:  uint8(0xf3),
		821:  uint8(0xf5),
		822:  uint8(0xfe),
		823:  uint8(0xfb),
		824:  uint8(0xf5),
		825:  uint8(0xfc),
		826:  uint8(0xf2),
		827:  uint8(0xf7),
		828:  uint8(0xf8),
		829:  uint8(0xf2),
		830:  uint8(0xf4),
		831:  uint8(0xfe),
		832:  uint8(0x67),
		833:  uint8(0x6d),
		834:  uint8(0x6d),
		835:  uint8(0x68),
		836:  uint8(0x6e),
		837:  uint8(0x6b),
		838:  uint8(0x63),
		839:  uint8(0x65),
		840:  uint8(0x60),
		841:  uint8(0x66),
		842:  uint8(0x66),
		843:  uint8(0x6f),
		844:  uint8(0x69),
		845:  uint8(0x60),
		846:  uint8(0x6a),
		847:  uint8(0x63),
		848:  uint8(0x61),
		849:  uint8(0x64),
		850:  uint8(0x62),
		851:  uint8(0x67),
		852:  uint8(0x68),
		853:  uint8(0x62),
		854:  uint8(0x65),
		855:  uint8(0x6c),
		856:  uint8(0x6b),
		857:  uint8(0x61),
		858:  uint8(0x6c),
		859:  uint8(0x6a),
		860:  uint8(0x64),
		861:  uint8(0x6e),
		862:  uint8(0x6f),
		863:  uint8(0x69),
		864:  uint8(0x6a),
		865:  uint8(0x63),
		866:  uint8(0x66),
		867:  uint8(0x6f),
		868:  uint8(0x69),
		869:  uint8(0x60),
		870:  uint8(0x60),
		871:  uint8(0x66),
		872:  uint8(0x6c),
		873:  uint8(0x6a),
		874:  uint8(0x6b),
		875:  uint8(0x61),
		876:  uint8(0x67),
		877:  uint8(0x6d),
		878:  uint8(0x6d),
		879:  uint8(0x68),
		880:  uint8(0x6f),
		881:  uint8(0x69),
		882:  uint8(0x61),
		883:  uint8(0x64),
		884:  uint8(0x63),
		885:  uint8(0x65),
		886:  uint8(0x6e),
		887:  uint8(0x6b),
		888:  uint8(0x65),
		889:  uint8(0x6c),
		890:  uint8(0x62),
		891:  uint8(0x67),
		892:  uint8(0x68),
		893:  uint8(0x62),
		894:  uint8(0x64),
		895:  uint8(0x6e),
		896:  uint8(0x57),
		897:  uint8(0x5d),
		898:  uint8(0x5d),
		899:  uint8(0x58),
		900:  uint8(0x5e),
		901:  uint8(0x5b),
		902:  uint8(0x53),
		903:  uint8(0x55),
		904:  uint8(0x50),
		905:  uint8(0x56),
		906:  uint8(0x56),
		907:  uint8(0x5f),
		908:  uint8(0x59),
		909:  uint8(0x50),
		910:  uint8(0x5a),
		911:  uint8(0x53),
		912:  uint8(0x51),
		913:  uint8(0x54),
		914:  uint8(0x52),
		915:  uint8(0x57),
		916:  uint8(0x58),
		917:  uint8(0x52),
		918:  uint8(0x55),
		919:  uint8(0x5c),
		920:  uint8(0x5b),
		921:  uint8(0x51),
		922:  uint8(0x5c),
		923:  uint8(0x5a),
		924:  uint8(0x54),
		925:  uint8(0x5e),
		926:  uint8(0x5f),
		927:  uint8(0x59),
		928:  uint8(0x5a),
		929:  uint8(0x53),
		930:  uint8(0x56),
		931:  uint8(0x5f),
		932:  uint8(0x59),
		933:  uint8(0x50),
		934:  uint8(0x50),
		935:  uint8(0x56),
		936:  uint8(0x5c),
		937:  uint8(0x5a),
		938:  uint8(0x5b),
		939:  uint8(0x51),
		940:  uint8(0x57),
		941:  uint8(0x5d),
		942:  uint8(0x5d),
		943:  uint8(0x58),
		944:  uint8(0x5f),
		945:  uint8(0x59),
		946:  uint8(0x51),
		947:  uint8(0x54),
		948:  uint8(0x53),
		949:  uint8(0x55),
		950:  uint8(0x5e),
		951:  uint8(0x5b),
		952:  uint8(0x55),
		953:  uint8(0x5c),
		954:  uint8(0x52),
		955:  uint8(0x57),
		956:  uint8(0x58),
		957:  uint8(0x52),
		958:  uint8(0x54),
		959:  uint8(0x5e),
		960:  uint8(0xa7),
		961:  uint8(0xad),
		962:  uint8(0xad),
		963:  uint8(0xa8),
		964:  uint8(0xae),
		965:  uint8(0xab),
		966:  uint8(0xa3),
		967:  uint8(0xa5),
		968:  uint8(0xa0),
		969:  uint8(0xa6),
		970:  uint8(0xa6),
		971:  uint8(0xaf),
		972:  uint8(0xa9),
		973:  uint8(0xa0),
		974:  uint8(0xaa),
		975:  uint8(0xa3),
		976:  uint8(0xa1),
		977:  uint8(0xa4),
		978:  uint8(0xa2),
		979:  uint8(0xa7),
		980:  uint8(0xa8),
		981:  uint8(0xa2),
		982:  uint8(0xa5),
		983:  uint8(0xac),
		984:  uint8(0xab),
		985:  uint8(0xa1),
		986:  uint8(0xac),
		987:  uint8(0xaa),
		988:  uint8(0xa4),
		989:  uint8(0xae),
		990:  uint8(0xaf),
		991:  uint8(0xa9),
		992:  uint8(0xaa),
		993:  uint8(0xa3),
		994:  uint8(0xa6),
		995:  uint8(0xaf),
		996:  uint8(0xa9),
		997:  uint8(0xa0),
		998:  uint8(0xa0),
		999:  uint8(0xa6),
		1000: uint8(0xac),
		1001: uint8(0xaa),
		1002: uint8(0xab),
		1003: uint8(0xa1),
		1004: uint8(0xa7),
		1005: uint8(0xad),
		1006: uint8(0xad),
		1007: uint8(0xa8),
		1008: uint8(0xaf),
		1009: uint8(0xa9),
		1010: uint8(0xa1),
		1011: uint8(0xa4),
		1012: uint8(0xa3),
		1013: uint8(0xa5),
		1014: uint8(0xae),
		1015: uint8(0xab),
		1016: uint8(0xa5),
		1017: uint8(0xac),
		1018: uint8(0xa2),
		1019: uint8(0xa7),
		1020: uint8(0xa8),
		1021: uint8(0xa2),
		1022: uint8(0xa4),
		1023: uint8(0xae),
		1024: uint8(0x17),
		1025: uint8(0x1d),
		1026: uint8(0x1d),
		1027: uint8(0x18),
		1028: uint8(0x1e),
		1029: uint8(0x1b),
		1030: uint8(0x13),
		1031: uint8(0x15),
		1032: uint8(0x10),
		1033: uint8(0x16),
		1034: uint8(0x16),
		1035: uint8(0x1f),
		1036: uint8(0x19),
		1037: uint8(0x10),
		1038: uint8(0x1a),
		1039: uint8(0x13),
		1040: uint8(0x11),
		1041: uint8(0x14),
		1042: uint8(0x12),
		1043: uint8(0x17),
		1044: uint8(0x18),
		1045: uint8(0x12),
		1046: uint8(0x15),
		1047: uint8(0x1c),
		1048: uint8(0x1b),
		1049: uint8(0x11),
		1050: uint8(0x1c),
		1051: uint8(0x1a),
		1052: uint8(0x14),
		1053: uint8(0x1e),
		1054: uint8(0x1f),
		1055: uint8(0x19),
		1056: uint8(0x1a),
		1057: uint8(0x13),
		1058: uint8(0x16),
		1059: uint8(0x1f),
		1060: uint8(0x19),
		1061: uint8(0x10),
		1062: uint8(0x10),
		1063: uint8(0x16),
		1064: uint8(0x1c),
		1065: uint8(0x1a),
		1066: uint8(0x1b),
		1067: uint8(0x11),
		1068: uint8(0x17),
		1069: uint8(0x1d),
		1070: uint8(0x1d),
		1071: uint8(0x18),
		1072: uint8(0x1f),
		1073: uint8(0x19),
		1074: uint8(0x11),
		1075: uint8(0x14),
		1076: uint8(0x13),
		1077: uint8(0x15),
		1078: uint8(0x1e),
		1079: uint8(0x1b),
		1080: uint8(0x15),
		1081: uint8(0x1c),
		1082: uint8(0x12),
		1083: uint8(0x17),
		1084: uint8(0x18),
		1085: uint8(0x12),
		1086: uint8(0x14),
		1087: uint8(0x1e),
		1088: uint8(0x27),
		1089: uint8(0x2d),
		1090: uint8(0x2d),
		1091: uint8(0x28),
		1092: uint8(0x2e),
		1093: uint8(0x2b),
		1094: uint8(0x23),
		1095: uint8(0x25),
		1096: uint8(0x20),
		1097: uint8(0x26),
		1098: uint8(0x26),
		1099: uint8(0x2f),
		1100: uint8(0x29),
		1101: uint8(0x20),
		1102: uint8(0x2a),
		1103: uint8(0x23),
		1104: uint8(0x21),
		1105: uint8(0x24),
		1106: uint8(0x22),
		1107: uint8(0x27),
		1108: uint8(0x28),
		1109: uint8(0x22),
		1110: uint8(0x25),
		1111: uint8(0x2c),
		1112: uint8(0x2b),
		1113: uint8(0x21),
		1114: uint8(0x2c),
		1115: uint8(0x2a),
		1116: uint8(0x24),
		1117: uint8(0x2e),
		1118: uint8(0x2f),
		1119: uint8(0x29),
		1120: uint8(0x2a),
		1121: uint8(0x23),
		1122: uint8(0x26),
		1123: uint8(0x2f),
		1124: uint8(0x29),
		1125: uint8(0x20),
		1126: uint8(0x20),
		1127: uint8(0x26),
		1128: uint8(0x2c),
		1129: uint8(0x2a),
		1130: uint8(0x2b),
		1131: uint8(0x21),
		1132: uint8(0x27),
		1133: uint8(0x2d),
		1134: uint8(0x2d),
		1135: uint8(0x28),
		1136: uint8(0x2f),
		1137: uint8(0x29),
		1138: uint8(0x21),
		1139: uint8(0x24),
		1140: uint8(0x23),
		1141: uint8(0x25),
		1142: uint8(0x2e),
		1143: uint8(0x2b),
		1144: uint8(0x25),
		1145: uint8(0x2c),
		1146: uint8(0x22),
		1147: uint8(0x27),
		1148: uint8(0x28),
		1149: uint8(0x22),
		1150: uint8(0x24),
		1151: uint8(0x2e),
		1152: uint8(0xd7),
		1153: uint8(0xdd),
		1154: uint8(0xdd),
		1155: uint8(0xd8),
		1156: uint8(0xde),
		1157: uint8(0xdb),
		1158: uint8(0xd3),
		1159: uint8(0xd5),
		1160: uint8(0xd0),
		1161: uint8(0xd6),
		1162: uint8(0xd6),
		1163: uint8(0xdf),
		1164: uint8(0xd9),
		1165: uint8(0xd0),
		1166: uint8(0xda),
		1167: uint8(0xd3),
		1168: uint8(0xd1),
		1169: uint8(0xd4),
		1170: uint8(0xd2),
		1171: uint8(0xd7),
		1172: uint8(0xd8),
		1173: uint8(0xd2),
		1174: uint8(0xd5),
		1175: uint8(0xdc),
		1176: uint8(0xdb),
		1177: uint8(0xd1),
		1178: uint8(0xdc),
		1179: uint8(0xda),
		1180: uint8(0xd4),
		1181: uint8(0xde),
		1182: uint8(0xdf),
		1183: uint8(0xd9),
		1184: uint8(0xda),
		1185: uint8(0xd3),
		1186: uint8(0xd6),
		1187: uint8(0xdf),
		1188: uint8(0xd9),
		1189: uint8(0xd0),
		1190: uint8(0xd0),
		1191: uint8(0xd6),
		1192: uint8(0xdc),
		1193: uint8(0xda),
		1194: uint8(0xdb),
		1195: uint8(0xd1),
		1196: uint8(0xd7),
		1197: uint8(0xdd),
		1198: uint8(0xdd),
		1199: uint8(0xd8),
		1200: uint8(0xdf),
		1201: uint8(0xd9),
		1202: uint8(0xd1),
		1203: uint8(0xd4),
		1204: uint8(0xd3),
		1205: uint8(0xd5),
		1206: uint8(0xde),
		1207: uint8(0xdb),
		1208: uint8(0xd5),
		1209: uint8(0xdc),
		1210: uint8(0xd2),
		1211: uint8(0xd7),
		1212: uint8(0xd8),
		1213: uint8(0xd2),
		1214: uint8(0xd4),
		1215: uint8(0xde),
		1216: uint8(0x87),
		1217: uint8(0x8d),
		1218: uint8(0x8d),
		1219: uint8(0x88),
		1220: uint8(0x8e),
		1221: uint8(0x8b),
		1222: uint8(0x83),
		1223: uint8(0x85),
		1224: uint8(0x80),
		1225: uint8(0x86),
		1226: uint8(0x86),
		1227: uint8(0x8f),
		1228: uint8(0x89),
		1229: uint8(0x80),
		1230: uint8(0x8a),
		1231: uint8(0x83),
		1232: uint8(0x81),
		1233: uint8(0x84),
		1234: uint8(0x82),
		1235: uint8(0x87),
		1236: uint8(0x88),
		1237: uint8(0x82),
		1238: uint8(0x85),
		1239: uint8(0x8c),
		1240: uint8(0x8b),
		1241: uint8(0x81),
		1242: uint8(0x8c),
		1243: uint8(0x8a),
		1244: uint8(0x84),
		1245: uint8(0x8e),
		1246: uint8(0x8f),
		1247: uint8(0x89),
		1248: uint8(0x8a),
		1249: uint8(0x83),
		1250: uint8(0x86),
		1251: uint8(0x8f),
		1252: uint8(0x89),
		1253: uint8(0x80),
		1254: uint8(0x80),
		1255: uint8(0x86),
		1256: uint8(0x8c),
		1257: uint8(0x8a),
		1258: uint8(0x8b),
		1259: uint8(0x81),
		1260: uint8(0x87),
		1261: uint8(0x8d),
		1262: uint8(0x8d),
		1263: uint8(0x88),
		1264: uint8(0x8f),
		1265: uint8(0x89),
		1266: uint8(0x81),
		1267: uint8(0x84),
		1268: uint8(0x83),
		1269: uint8(0x85),
		1270: uint8(0x8e),
		1271: uint8(0x8b),
		1272: uint8(0x85),
		1273: uint8(0x8c),
		1274: uint8(0x82),
		1275: uint8(0x87),
		1276: uint8(0x88),
		1277: uint8(0x82),
		1278: uint8(0x84),
		1279: uint8(0x8e),
		1280: uint8(0xc7),
		1281: uint8(0xcd),
		1282: uint8(0xcd),
		1283: uint8(0xc8),
		1284: uint8(0xce),
		1285: uint8(0xcb),
		1286: uint8(0xc3),
		1287: uint8(0xc5),
		1288: uint8(0xc0),
		1289: uint8(0xc6),
		1290: uint8(0xc6),
		1291: uint8(0xcf),
		1292: uint8(0xc9),
		1293: uint8(0xc0),
		1294: uint8(0xca),
		1295: uint8(0xc3),
		1296: uint8(0xc1),
		1297: uint8(0xc4),
		1298: uint8(0xc2),
		1299: uint8(0xc7),
		1300: uint8(0xc8),
		1301: uint8(0xc2),
		1302: uint8(0xc5),
		1303: uint8(0xcc),
		1304: uint8(0xcb),
		1305: uint8(0xc1),
		1306: uint8(0xcc),
		1307: uint8(0xca),
		1308: uint8(0xc4),
		1309: uint8(0xce),
		1310: uint8(0xcf),
		1311: uint8(0xc9),
		1312: uint8(0xca),
		1313: uint8(0xc3),
		1314: uint8(0xc6),
		1315: uint8(0xcf),
		1316: uint8(0xc9),
		1317: uint8(0xc0),
		1318: uint8(0xc0),
		1319: uint8(0xc6),
		1320: uint8(0xcc),
		1321: uint8(0xca),
		1322: uint8(0xcb),
		1323: uint8(0xc1),
		1324: uint8(0xc7),
		1325: uint8(0xcd),
		1326: uint8(0xcd),
		1327: uint8(0xc8),
		1328: uint8(0xcf),
		1329: uint8(0xc9),
		1330: uint8(0xc1),
		1331: uint8(0xc4),
		1332: uint8(0xc3),
		1333: uint8(0xc5),
		1334: uint8(0xce),
		1335: uint8(0xcb),
		1336: uint8(0xc5),
		1337: uint8(0xcc),
		1338: uint8(0xc2),
		1339: uint8(0xc7),
		1340: uint8(0xc8),
		1341: uint8(0xc2),
		1342: uint8(0xc4),
		1343: uint8(0xce),
		1344: uint8(0x57),
		1345: uint8(0x5d),
		1346: uint8(0x5d),
		1347: uint8(0x58),
		1348: uint8(0x5e),
		1349: uint8(0x5b),
		1350: uint8(0x53),
		1351: uint8(0x55),
		1352: uint8(0x50),
		1353: uint8(0x56),
		1354: uint8(0x56),
		1355: uint8(0x5f),
		1356: uint8(0x59),
		1357: uint8(0x50),
		1358: uint8(0x5a),
		1359: uint8(0x53),
		1360: uint8(0x51),
		1361: uint8(0x54),
		1362: uint8(0x52),
		1363: uint8(0x57),
		1364: uint8(0x58),
		1365: uint8(0x52),
		1366: uint8(0x55),
		1367: uint8(0x5c),
		1368: uint8(0x5b),
		1369: uint8(0x51),
		1370: uint8(0x5c),
		1371: uint8(0x5a),
		1372: uint8(0x54),
		1373: uint8(0x5e),
		1374: uint8(0x5f),
		1375: uint8(0x59),
		1376: uint8(0x5a),
		1377: uint8(0x53),
		1378: uint8(0x56),
		1379: uint8(0x5f),
		1380: uint8(0x59),
		1381: uint8(0x50),
		1382: uint8(0x50),
		1383: uint8(0x56),
		1384: uint8(0x5c),
		1385: uint8(0x5a),
		1386: uint8(0x5b),
		1387: uint8(0x51),
		1388: uint8(0x57),
		1389: uint8(0x5d),
		1390: uint8(0x5d),
		1391: uint8(0x58),
		1392: uint8(0x5f),
		1393: uint8(0x59),
		1394: uint8(0x51),
		1395: uint8(0x54),
		1396: uint8(0x53),
		1397: uint8(0x55),
		1398: uint8(0x5e),
		1399: uint8(0x5b),
		1400: uint8(0x55),
		1401: uint8(0x5c),
		1402: uint8(0x52),
		1403: uint8(0x57),
		1404: uint8(0x58),
		1405: uint8(0x52),
		1406: uint8(0x54),
		1407: uint8(0x5e),
		1408: uint8(0x77),
		1409: uint8(0x7d),
		1410: uint8(0x7d),
		1411: uint8(0x78),
		1412: uint8(0x7e),
		1413: uint8(0x7b),
		1414: uint8(0x73),
		1415: uint8(0x75),
		1416: uint8(0x70),
		1417: uint8(0x76),
		1418: uint8(0x76),
		1419: uint8(0x7f),
		1420: uint8(0x79),
		1421: uint8(0x70),
		1422: uint8(0x7a),
		1423: uint8(0x73),
		1424: uint8(0x71),
		1425: uint8(0x74),
		1426: uint8(0x72),
		1427: uint8(0x77),
		1428: uint8(0x78),
		1429: uint8(0x72),
		1430: uint8(0x75),
		1431: uint8(0x7c),
		1432: uint8(0x7b),
		1433: uint8(0x71),
		1434: uint8(0x7c),
		1435: uint8(0x7a),
		1436: uint8(0x74),
		1437: uint8(0x7e),
		1438: uint8(0x7f),
		1439: uint8(0x79),
		1440: uint8(0x7a),
		1441: uint8(0x73),
		1442: uint8(0x76),
		1443: uint8(0x7f),
		1444: uint8(0x79),
		1445: uint8(0x70),
		1446: uint8(0x70),
		1447: uint8(0x76),
		1448: uint8(0x7c),
		1449: uint8(0x7a),
		1450: uint8(0x7b),
		1451: uint8(0x71),
		1452: uint8(0x77),
		1453: uint8(0x7d),
		1454: uint8(0x7d),
		1455: uint8(0x78),
		1456: uint8(0x7f),
		1457: uint8(0x79),
		1458: uint8(0x71),
		1459: uint8(0x74),
		1460: uint8(0x73),
		1461: uint8(0x75),
		1462: uint8(0x7e),
		1463: uint8(0x7b),
		1464: uint8(0x75),
		1465: uint8(0x7c),
		1466: uint8(0x72),
		1467: uint8(0x77),
		1468: uint8(0x78),
		1469: uint8(0x72),
		1470: uint8(0x74),
		1471: uint8(0x7e),
		1472: uint8(0xe7),
		1473: uint8(0xed),
		1474: uint8(0xed),
		1475: uint8(0xe8),
		1476: uint8(0xee),
		1477: uint8(0xeb),
		1478: uint8(0xe3),
		1479: uint8(0xe5),
		1480: uint8(0xe0),
		1481: uint8(0xe6),
		1482: uint8(0xe6),
		1483: uint8(0xef),
		1484: uint8(0xe9),
		1485: uint8(0xe0),
		1486: uint8(0xea),
		1487: uint8(0xe3),
		1488: uint8(0xe1),
		1489: uint8(0xe4),
		1490: uint8(0xe2),
		1491: uint8(0xe7),
		1492: uint8(0xe8),
		1493: uint8(0xe2),
		1494: uint8(0xe5),
		1495: uint8(0xec),
		1496: uint8(0xeb),
		1497: uint8(0xe1),
		1498: uint8(0xec),
		1499: uint8(0xea),
		1500: uint8(0xe4),
		1501: uint8(0xee),
		1502: uint8(0xef),
		1503: uint8(0xe9),
		1504: uint8(0xea),
		1505: uint8(0xe3),
		1506: uint8(0xe6),
		1507: uint8(0xef),
		1508: uint8(0xe9),
		1509: uint8(0xe0),
		1510: uint8(0xe0),
		1511: uint8(0xe6),
		1512: uint8(0xec),
		1513: uint8(0xea),
		1514: uint8(0xeb),
		1515: uint8(0xe1),
		1516: uint8(0xe7),
		1517: uint8(0xed),
		1518: uint8(0xed),
		1519: uint8(0xe8),
		1520: uint8(0xef),
		1521: uint8(0xe9),
		1522: uint8(0xe1),
		1523: uint8(0xe4),
		1524: uint8(0xe3),
		1525: uint8(0xe5),
		1526: uint8(0xee),
		1527: uint8(0xeb),
		1528: uint8(0xe5),
		1529: uint8(0xec),
		1530: uint8(0xe2),
		1531: uint8(0xe7),
		1532: uint8(0xe8),
		1533: uint8(0xe2),
		1534: uint8(0xe4),
		1535: uint8(0xee),
		1536: uint8(0xb7),
		1537: uint8(0xbd),
		1538: uint8(0xbd),
		1539: uint8(0xb8),
		1540: uint8(0xbe),
		1541: uint8(0xbb),
		1542: uint8(0xb3),
		1543: uint8(0xb5),
		1544: uint8(0xb0),
		1545: uint8(0xb6),
		1546: uint8(0xb6),
		1547: uint8(0xbf),
		1548: uint8(0xb9),
		1549: uint8(0xb0),
		1550: uint8(0xba),
		1551: uint8(0xb3),
		1552: uint8(0xb1),
		1553: uint8(0xb4),
		1554: uint8(0xb2),
		1555: uint8(0xb7),
		1556: uint8(0xb8),
		1557: uint8(0xb2),
		1558: uint8(0xb5),
		1559: uint8(0xbc),
		1560: uint8(0xbb),
		1561: uint8(0xb1),
		1562: uint8(0xbc),
		1563: uint8(0xba),
		1564: uint8(0xb4),
		1565: uint8(0xbe),
		1566: uint8(0xbf),
		1567: uint8(0xb9),
		1568: uint8(0xba),
		1569: uint8(0xb3),
		1570: uint8(0xb6),
		1571: uint8(0xbf),
		1572: uint8(0xb9),
		1573: uint8(0xb0),
		1574: uint8(0xb0),
		1575: uint8(0xb6),
		1576: uint8(0xbc),
		1577: uint8(0xba),
		1578: uint8(0xbb),
		1579: uint8(0xb1),
		1580: uint8(0xb7),
		1581: uint8(0xbd),
		1582: uint8(0xbd),
		1583: uint8(0xb8),
		1584: uint8(0xbf),
		1585: uint8(0xb9),
		1586: uint8(0xb1),
		1587: uint8(0xb4),
		1588: uint8(0xb3),
		1589: uint8(0xb5),
		1590: uint8(0xbe),
		1591: uint8(0xbb),
		1592: uint8(0xb5),
		1593: uint8(0xbc),
		1594: uint8(0xb2),
		1595: uint8(0xb7),
		1596: uint8(0xb8),
		1597: uint8(0xb2),
		1598: uint8(0xb4),
		1599: uint8(0xbe),
		1600: uint8(0xc7),
		1601: uint8(0xcd),
		1602: uint8(0xcd),
		1603: uint8(0xc8),
		1604: uint8(0xce),
		1605: uint8(0xcb),
		1606: uint8(0xc3),
		1607: uint8(0xc5),
		1608: uint8(0xc0),
		1609: uint8(0xc6),
		1610: uint8(0xc6),
		1611: uint8(0xcf),
		1612: uint8(0xc9),
		1613: uint8(0xc0),
		1614: uint8(0xca),
		1615: uint8(0xc3),
		1616: uint8(0xc1),
		1617: uint8(0xc4),
		1618: uint8(0xc2),
		1619: uint8(0xc7),
		1620: uint8(0xc8),
		1621: uint8(0xc2),
		1622: uint8(0xc5),
		1623: uint8(0xcc),
		1624: uint8(0xcb),
		1625: uint8(0xc1),
		1626: uint8(0xcc),
		1627: uint8(0xca),
		1628: uint8(0xc4),
		1629: uint8(0xce),
		1630: uint8(0xcf),
		1631: uint8(0xc9),
		1632: uint8(0xca),
		1633: uint8(0xc3),
		1634: uint8(0xc6),
		1635: uint8(0xcf),
		1636: uint8(0xc9),
		1637: uint8(0xc0),
		1638: uint8(0xc0),
		1639: uint8(0xc6),
		1640: uint8(0xcc),
		1641: uint8(0xca),
		1642: uint8(0xcb),
		1643: uint8(0xc1),
		1644: uint8(0xc7),
		1645: uint8(0xcd),
		1646: uint8(0xcd),
		1647: uint8(0xc8),
		1648: uint8(0xcf),
		1649: uint8(0xc9),
		1650: uint8(0xc1),
		1651: uint8(0xc4),
		1652: uint8(0xc3),
		1653: uint8(0xc5),
		1654: uint8(0xce),
		1655: uint8(0xcb),
		1656: uint8(0xc5),
		1657: uint8(0xcc),
		1658: uint8(0xc2),
		1659: uint8(0xc7),
		1660: uint8(0xc8),
		1661: uint8(0xc2),
		1662: uint8(0xc4),
		1663: uint8(0xce),
		1664: uint8(0x47),
		1665: uint8(0x4d),
		1666: uint8(0x4d),
		1667: uint8(0x48),
		1668: uint8(0x4e),
		1669: uint8(0x4b),
		1670: uint8(0x43),
		1671: uint8(0x45),
		1672: uint8(0x40),
		1673: uint8(0x46),
		1674: uint8(0x46),
		1675: uint8(0x4f),
		1676: uint8(0x49),
		1677: uint8(0x40),
		1678: uint8(0x4a),
		1679: uint8(0x43),
		1680: uint8(0x41),
		1681: uint8(0x44),
		1682: uint8(0x42),
		1683: uint8(0x47),
		1684: uint8(0x48),
		1685: uint8(0x42),
		1686: uint8(0x45),
		1687: uint8(0x4c),
		1688: uint8(0x4b),
		1689: uint8(0x41),
		1690: uint8(0x4c),
		1691: uint8(0x4a),
		1692: uint8(0x44),
		1693: uint8(0x4e),
		1694: uint8(0x4f),
		1695: uint8(0x49),
		1696: uint8(0x4a),
		1697: uint8(0x43),
		1698: uint8(0x46),
		1699: uint8(0x4f),
		1700: uint8(0x49),
		1701: uint8(0x40),
		1702: uint8(0x40),
		1703: uint8(0x46),
		1704: uint8(0x4c),
		1705: uint8(0x4a),
		1706: uint8(0x4b),
		1707: uint8(0x41),
		1708: uint8(0x47),
		1709: uint8(0x4d),
		1710: uint8(0x4d),
		1711: uint8(0x48),
		1712: uint8(0x4f),
		1713: uint8(0x49),
		1714: uint8(0x41),
		1715: uint8(0x44),
		1716: uint8(0x43),
		1717: uint8(0x45),
		1718: uint8(0x4e),
		1719: uint8(0x4b),
		1720: uint8(0x45),
		1721: uint8(0x4c),
		1722: uint8(0x42),
		1723: uint8(0x47),
		1724: uint8(0x48),
		1725: uint8(0x42),
		1726: uint8(0x44),
		1727: uint8(0x4e),
		1728: uint8(0xb7),
		1729: uint8(0xbd),
		1730: uint8(0xbd),
		1731: uint8(0xb8),
		1732: uint8(0xbe),
		1733: uint8(0xbb),
		1734: uint8(0xb3),
		1735: uint8(0xb5),
		1736: uint8(0xb0),
		1737: uint8(0xb6),
		1738: uint8(0xb6),
		1739: uint8(0xbf),
		1740: uint8(0xb9),
		1741: uint8(0xb0),
		1742: uint8(0xba),
		1743: uint8(0xb3),
		1744: uint8(0xb1),
		1745: uint8(0xb4),
		1746: uint8(0xb2),
		1747: uint8(0xb7),
		1748: uint8(0xb8),
		1749: uint8(0xb2),
		1750: uint8(0xb5),
		1751: uint8(0xbc),
		1752: uint8(0xbb),
		1753: uint8(0xb1),
		1754: uint8(0xbc),
		1755: uint8(0xba),
		1756: uint8(0xb4),
		1757: uint8(0xbe),
		1758: uint8(0xbf),
		1759: uint8(0xb9),
		1760: uint8(0xba),
		1761: uint8(0xb3),
		1762: uint8(0xb6),
		1763: uint8(0xbf),
		1764: uint8(0xb9),
		1765: uint8(0xb0),
		1766: uint8(0xb0),
		1767: uint8(0xb6),
		1768: uint8(0xbc),
		1769: uint8(0xba),
		1770: uint8(0xbb),
		1771: uint8(0xb1),
		1772: uint8(0xb7),
		1773: uint8(0xbd),
		1774: uint8(0xbd),
		1775: uint8(0xb8),
		1776: uint8(0xbf),
		1777: uint8(0xb9),
		1778: uint8(0xb1),
		1779: uint8(0xb4),
		1780: uint8(0xb3),
		1781: uint8(0xb5),
		1782: uint8(0xbe),
		1783: uint8(0xbb),
		1784: uint8(0xb5),
		1785: uint8(0xbc),
		1786: uint8(0xb2),
		1787: uint8(0xb7),
		1788: uint8(0xb8),
		1789: uint8(0xb2),
		1790: uint8(0xb4),
		1791: uint8(0xbe),
		1792: uint8(0x27),
		1793: uint8(0x2d),
		1794: uint8(0x2d),
		1795: uint8(0x28),
		1796: uint8(0x2e),
		1797: uint8(0x2b),
		1798: uint8(0x23),
		1799: uint8(0x25),
		1800: uint8(0x20),
		1801: uint8(0x26),
		1802: uint8(0x26),
		1803: uint8(0x2f),
		1804: uint8(0x29),
		1805: uint8(0x20),
		1806: uint8(0x2a),
		1807: uint8(0x23),
		1808: uint8(0x21),
		1809: uint8(0x24),
		1810: uint8(0x22),
		1811: uint8(0x27),
		1812: uint8(0x28),
		1813: uint8(0x22),
		1814: uint8(0x25),
		1815: uint8(0x2c),
		1816: uint8(0x2b),
		1817: uint8(0x21),
		1818: uint8(0x2c),
		1819: uint8(0x2a),
		1820: uint8(0x24),
		1821: uint8(0x2e),
		1822: uint8(0x2f),
		1823: uint8(0x29),
		1824: uint8(0x2a),
		1825: uint8(0x23),
		1826: uint8(0x26),
		1827: uint8(0x2f),
		1828: uint8(0x29),
		1829: uint8(0x20),
		1830: uint8(0x20),
		1831: uint8(0x26),
		1832: uint8(0x2c),
		1833: uint8(0x2a),
		1834: uint8(0x2b),
		1835: uint8(0x21),
		1836: uint8(0x27),
		1837: uint8(0x2d),
		1838: uint8(0x2d),
		1839: uint8(0x28),
		1840: uint8(0x2f),
		1841: uint8(0x29),
		1842: uint8(0x21),
		1843: uint8(0x24),
		1844: uint8(0x23),
		1845: uint8(0x25),
		1846: uint8(0x2e),
		1847: uint8(0x2b),
		1848: uint8(0x25),
		1849: uint8(0x2c),
		1850: uint8(0x22),
		1851: uint8(0x27),
		1852: uint8(0x28),
		1853: uint8(0x22),
		1854: uint8(0x24),
		1855: uint8(0x2e),
		1856: uint8(0xf7),
		1857: uint8(0xfd),
		1858: uint8(0xfd),
		1859: uint8(0xf8),
		1860: uint8(0xfe),
		1861: uint8(0xfb),
		1862: uint8(0xf3),
		1863: uint8(0xf5),
		1864: uint8(0xf0),
		1865: uint8(0xf6),
		1866: uint8(0xf6),
		1867: uint8(0xff),
		1868: uint8(0xf9),
		1869: uint8(0xf0),
		1870: uint8(0xfa),
		1871: uint8(0xf3),
		1872: uint8(0xf1),
		1873: uint8(0xf4),
		1874: uint8(0xf2),
		1875: uint8(0xf7),
		1876: uint8(0xf8),
		1877: uint8(0xf2),
		1878: uint8(0xf5),
		1879: uint8(0xfc),
		1880: uint8(0xfb),
		1881: uint8(0xf1),
		1882: uint8(0xfc),
		1883: uint8(0xfa),
		1884: uint8(0xf4),
		1885: uint8(0xfe),
		1886: uint8(0xff),
		1887: uint8(0xf9),
		1888: uint8(0xfa),
		1889: uint8(0xf3),
		1890: uint8(0xf6),
		1891: uint8(0xff),
		1892: uint8(0xf9),
		1893: uint8(0xf0),
		1894: uint8(0xf0),
		1895: uint8(0xf6),
		1896: uint8(0xfc),
		1897: uint8(0xfa),
		1898: uint8(0xfb),
		1899: uint8(0xf1),
		1900: uint8(0xf7),
		1901: uint8(0xfd),
		1902: uint8(0xfd),
		1903: uint8(0xf8),
		1904: uint8(0xff),
		1905: uint8(0xf9),
		1906: uint8(0xf1),
		1907: uint8(0xf4),
		1908: uint8(0xf3),
		1909: uint8(0xf5),
		1910: uint8(0xfe),
		1911: uint8(0xfb),
		1912: uint8(0xf5),
		1913: uint8(0xfc),
		1914: uint8(0xf2),
		1915: uint8(0xf7),
		1916: uint8(0xf8),
		1917: uint8(0xf2),
		1918: uint8(0xf4),
		1919: uint8(0xfe),
		1920: uint8(0x87),
		1921: uint8(0x8d),
		1922: uint8(0x8d),
		1923: uint8(0x88),
		1924: uint8(0x8e),
		1925: uint8(0x8b),
		1926: uint8(0x83),
		1927: uint8(0x85),
		1928: uint8(0x80),
		1929: uint8(0x86),
		1930: uint8(0x86),
		1931: uint8(0x8f),
		1932: uint8(0x89),
		1933: uint8(0x80),
		1934: uint8(0x8a),
		1935: uint8(0x83),
		1936: uint8(0x81),
		1937: uint8(0x84),
		1938: uint8(0x82),
		1939: uint8(0x87),
		1940: uint8(0x88),
		1941: uint8(0x82),
		1942: uint8(0x85),
		1943: uint8(0x8c),
		1944: uint8(0x8b),
		1945: uint8(0x81),
		1946: uint8(0x8c),
		1947: uint8(0x8a),
		1948: uint8(0x84),
		1949: uint8(0x8e),
		1950: uint8(0x8f),
		1951: uint8(0x89),
		1952: uint8(0x8a),
		1953: uint8(0x83),
		1954: uint8(0x86),
		1955: uint8(0x8f),
		1956: uint8(0x89),
		1957: uint8(0x80),
		1958: uint8(0x80),
		1959: uint8(0x86),
		1960: uint8(0x8c),
		1961: uint8(0x8a),
		1962: uint8(0x8b),
		1963: uint8(0x81),
		1964: uint8(0x87),
		1965: uint8(0x8d),
		1966: uint8(0x8d),
		1967: uint8(0x88),
		1968: uint8(0x8f),
		1969: uint8(0x89),
		1970: uint8(0x81),
		1971: uint8(0x84),
		1972: uint8(0x83),
		1973: uint8(0x85),
		1974: uint8(0x8e),
		1975: uint8(0x8b),
		1976: uint8(0x85),
		1977: uint8(0x8c),
		1978: uint8(0x82),
		1979: uint8(0x87),
		1980: uint8(0x88),
		1981: uint8(0x82),
		1982: uint8(0x84),
		1983: uint8(0x8e),
		1984: uint8(0x17),
		1985: uint8(0x1d),
		1986: uint8(0x1d),
		1987: uint8(0x18),
		1988: uint8(0x1e),
		1989: uint8(0x1b),
		1990: uint8(0x13),
		1991: uint8(0x15),
		1992: uint8(0x10),
		1993: uint8(0x16),
		1994: uint8(0x16),
		1995: uint8(0x1f),
		1996: uint8(0x19),
		1997: uint8(0x10),
		1998: uint8(0x1a),
		1999: uint8(0x13),
		2000: uint8(0x11),
		2001: uint8(0x14),
		2002: uint8(0x12),
		2003: uint8(0x17),
		2004: uint8(0x18),
		2005: uint8(0x12),
		2006: uint8(0x15),
		2007: uint8(0x1c),
		2008: uint8(0x1b),
		2009: uint8(0x11),
		2010: uint8(0x1c),
		2011: uint8(0x1a),
		2012: uint8(0x14),
		2013: uint8(0x1e),
		2014: uint8(0x1f),
		2015: uint8(0x19),
		2016: uint8(0x1a),
		2017: uint8(0x13),
		2018: uint8(0x16),
		2019: uint8(0x1f),
		2020: uint8(0x19),
		2021: uint8(0x10),
		2022: uint8(0x10),
		2023: uint8(0x16),
		2024: uint8(0x1c),
		2025: uint8(0x1a),
		2026: uint8(0x1b),
		2027: uint8(0x11),
		2028: uint8(0x17),
		2029: uint8(0x1d),
		2030: uint8(0x1d),
		2031: uint8(0x18),
		2032: uint8(0x1f),
		2033: uint8(0x19),
		2034: uint8(0x11),
		2035: uint8(0x14),
		2036: uint8(0x13),
		2037: uint8(0x15),
		2038: uint8(0x1e),
		2039: uint8(0x1b),
		2040: uint8(0x15),
		2041: uint8(0x1c),
		2042: uint8(0x12),
		2043: uint8(0x17),
		2044: uint8(0x18),
		2045: uint8(0x12),
		2046: uint8(0x14),
		2047: uint8(0x1e),
		2048: uint8(0xd7),
		2049: uint8(0xdd),
		2050: uint8(0xdd),
		2051: uint8(0xd8),
		2052: uint8(0xde),
		2053: uint8(0xdb),
		2054: uint8(0xd3),
		2055: uint8(0xd5),
		2056: uint8(0xd0),
		2057: uint8(0xd6),
		2058: uint8(0xd6),
		2059: uint8(0xdf),
		2060: uint8(0xd9),
		2061: uint8(0xd0),
		2062: uint8(0xda),
		2063: uint8(0xd3),
		2064: uint8(0xd1),
		2065: uint8(0xd4),
		2066: uint8(0xd2),
		2067: uint8(0xd7),
		2068: uint8(0xd8),
		2069: uint8(0xd2),
		2070: uint8(0xd5),
		2071: uint8(0xdc),
		2072: uint8(0xdb),
		2073: uint8(0xd1),
		2074: uint8(0xdc),
		2075: uint8(0xda),
		2076: uint8(0xd4),
		2077: uint8(0xde),
		2078: uint8(0xdf),
		2079: uint8(0xd9),
		2080: uint8(0xda),
		2081: uint8(0xd3),
		2082: uint8(0xd6),
		2083: uint8(0xdf),
		2084: uint8(0xd9),
		2085: uint8(0xd0),
		2086: uint8(0xd0),
		2087: uint8(0xd6),
		2088: uint8(0xdc),
		2089: uint8(0xda),
		2090: uint8(0xdb),
		2091: uint8(0xd1),
		2092: uint8(0xd7),
		2093: uint8(0xdd),
		2094: uint8(0xdd),
		2095: uint8(0xd8),
		2096: uint8(0xdf),
		2097: uint8(0xd9),
		2098: uint8(0xd1),
		2099: uint8(0xd4),
		2100: uint8(0xd3),
		2101: uint8(0xd5),
		2102: uint8(0xde),
		2103: uint8(0xdb),
		2104: uint8(0xd5),
		2105: uint8(0xdc),
		2106: uint8(0xd2),
		2107: uint8(0xd7),
		2108: uint8(0xd8),
		2109: uint8(0xd2),
		2110: uint8(0xd4),
		2111: uint8(0xde),
		2112: uint8(0x17),
		2113: uint8(0x1d),
		2114: uint8(0x1d),
		2115: uint8(0x18),
		2116: uint8(0x1e),
		2117: uint8(0x1b),
		2118: uint8(0x13),
		2119: uint8(0x15),
		2120: uint8(0x10),
		2121: uint8(0x16),
		2122: uint8(0x16),
		2123: uint8(0x1f),
		2124: uint8(0x19),
		2125: uint8(0x10),
		2126: uint8(0x1a),
		2127: uint8(0x13),
		2128: uint8(0x11),
		2129: uint8(0x14),
		2130: uint8(0x12),
		2131: uint8(0x17),
		2132: uint8(0x18),
		2133: uint8(0x12),
		2134: uint8(0x15),
		2135: uint8(0x1c),
		2136: uint8(0x1b),
		2137: uint8(0x11),
		2138: uint8(0x1c),
		2139: uint8(0x1a),
		2140: uint8(0x14),
		2141: uint8(0x1e),
		2142: uint8(0x1f),
		2143: uint8(0x19),
		2144: uint8(0x1a),
		2145: uint8(0x13),
		2146: uint8(0x16),
		2147: uint8(0x1f),
		2148: uint8(0x19),
		2149: uint8(0x10),
		2150: uint8(0x10),
		2151: uint8(0x16),
		2152: uint8(0x1c),
		2153: uint8(0x1a),
		2154: uint8(0x1b),
		2155: uint8(0x11),
		2156: uint8(0x17),
		2157: uint8(0x1d),
		2158: uint8(0x1d),
		2159: uint8(0x18),
		2160: uint8(0x1f),
		2161: uint8(0x19),
		2162: uint8(0x11),
		2163: uint8(0x14),
		2164: uint8(0x13),
		2165: uint8(0x15),
		2166: uint8(0x1e),
		2167: uint8(0x1b),
		2168: uint8(0x15),
		2169: uint8(0x1c),
		2170: uint8(0x12),
		2171: uint8(0x17),
		2172: uint8(0x18),
		2173: uint8(0x12),
		2174: uint8(0x14),
		2175: uint8(0x1e),
		2176: uint8(0x67),
		2177: uint8(0x6d),
		2178: uint8(0x6d),
		2179: uint8(0x68),
		2180: uint8(0x6e),
		2181: uint8(0x6b),
		2182: uint8(0x63),
		2183: uint8(0x65),
		2184: uint8(0x60),
		2185: uint8(0x66),
		2186: uint8(0x66),
		2187: uint8(0x6f),
		2188: uint8(0x69),
		2189: uint8(0x60),
		2190: uint8(0x6a),
		2191: uint8(0x63),
		2192: uint8(0x61),
		2193: uint8(0x64),
		2194: uint8(0x62),
		2195: uint8(0x67),
		2196: uint8(0x68),
		2197: uint8(0x62),
		2198: uint8(0x65),
		2199: uint8(0x6c),
		2200: uint8(0x6b),
		2201: uint8(0x61),
		2202: uint8(0x6c),
		2203: uint8(0x6a),
		2204: uint8(0x64),
		2205: uint8(0x6e),
		2206: uint8(0x6f),
		2207: uint8(0x69),
		2208: uint8(0x6a),
		2209: uint8(0x63),
		2210: uint8(0x66),
		2211: uint8(0x6f),
		2212: uint8(0x69),
		2213: uint8(0x60),
		2214: uint8(0x60),
		2215: uint8(0x66),
		2216: uint8(0x6c),
		2217: uint8(0x6a),
		2218: uint8(0x6b),
		2219: uint8(0x61),
		2220: uint8(0x67),
		2221: uint8(0x6d),
		2222: uint8(0x6d),
		2223: uint8(0x68),
		2224: uint8(0x6f),
		2225: uint8(0x69),
		2226: uint8(0x61),
		2227: uint8(0x64),
		2228: uint8(0x63),
		2229: uint8(0x65),
		2230: uint8(0x6e),
		2231: uint8(0x6b),
		2232: uint8(0x65),
		2233: uint8(0x6c),
		2234: uint8(0x62),
		2235: uint8(0x67),
		2236: uint8(0x68),
		2237: uint8(0x62),
		2238: uint8(0x64),
		2239: uint8(0x6e),
		2240: uint8(0xa7),
		2241: uint8(0xad),
		2242: uint8(0xad),
		2243: uint8(0xa8),
		2244: uint8(0xae),
		2245: uint8(0xab),
		2246: uint8(0xa3),
		2247: uint8(0xa5),
		2248: uint8(0xa0),
		2249: uint8(0xa6),
		2250: uint8(0xa6),
		2251: uint8(0xaf),
		2252: uint8(0xa9),
		2253: uint8(0xa0),
		2254: uint8(0xaa),
		2255: uint8(0xa3),
		2256: uint8(0xa1),
		2257: uint8(0xa4),
		2258: uint8(0xa2),
		2259: uint8(0xa7),
		2260: uint8(0xa8),
		2261: uint8(0xa2),
		2262: uint8(0xa5),
		2263: uint8(0xac),
		2264: uint8(0xab),
		2265: uint8(0xa1),
		2266: uint8(0xac),
		2267: uint8(0xaa),
		2268: uint8(0xa4),
		2269: uint8(0xae),
		2270: uint8(0xaf),
		2271: uint8(0xa9),
		2272: uint8(0xaa),
		2273: uint8(0xa3),
		2274: uint8(0xa6),
		2275: uint8(0xaf),
		2276: uint8(0xa9),
		2277: uint8(0xa0),
		2278: uint8(0xa0),
		2279: uint8(0xa6),
		2280: uint8(0xac),
		2281: uint8(0xaa),
		2282: uint8(0xab),
		2283: uint8(0xa1),
		2284: uint8(0xa7),
		2285: uint8(0xad),
		2286: uint8(0xad),
		2287: uint8(0xa8),
		2288: uint8(0xaf),
		2289: uint8(0xa9),
		2290: uint8(0xa1),
		2291: uint8(0xa4),
		2292: uint8(0xa3),
		2293: uint8(0xa5),
		2294: uint8(0xae),
		2295: uint8(0xab),
		2296: uint8(0xa5),
		2297: uint8(0xac),
		2298: uint8(0xa2),
		2299: uint8(0xa7),
		2300: uint8(0xa8),
		2301: uint8(0xa2),
		2302: uint8(0xa4),
		2303: uint8(0xae),
		2304: uint8(0x47),
		2305: uint8(0x4d),
		2306: uint8(0x4d),
		2307: uint8(0x48),
		2308: uint8(0x4e),
		2309: uint8(0x4b),
		2310: uint8(0x43),
		2311: uint8(0x45),
		2312: uint8(0x40),
		2313: uint8(0x46),
		2314: uint8(0x46),
		2315: uint8(0x4f),
		2316: uint8(0x49),
		2317: uint8(0x40),
		2318: uint8(0x4a),
		2319: uint8(0x43),
		2320: uint8(0x41),
		2321: uint8(0x44),
		2322: uint8(0x42),
		2323: uint8(0x47),
		2324: uint8(0x48),
		2325: uint8(0x42),
		2326: uint8(0x45),
		2327: uint8(0x4c),
		2328: uint8(0x4b),
		2329: uint8(0x41),
		2330: uint8(0x4c),
		2331: uint8(0x4a),
		2332: uint8(0x44),
		2333: uint8(0x4e),
		2334: uint8(0x4f),
		2335: uint8(0x49),
		2336: uint8(0x4a),
		2337: uint8(0x43),
		2338: uint8(0x46),
		2339: uint8(0x4f),
		2340: uint8(0x49),
		2341: uint8(0x40),
		2342: uint8(0x40),
		2343: uint8(0x46),
		2344: uint8(0x4c),
		2345: uint8(0x4a),
		2346: uint8(0x4b),
		2347: uint8(0x41),
		2348: uint8(0x47),
		2349: uint8(0x4d),
		2350: uint8(0x4d),
		2351: uint8(0x48),
		2352: uint8(0x4f),
		2353: uint8(0x49),
		2354: uint8(0x41),
		2355: uint8(0x44),
		2356: uint8(0x43),
		2357: uint8(0x45),
		2358: uint8(0x4e),
		2359: uint8(0x4b),
		2360: uint8(0x45),
		2361: uint8(0x4c),
		2362: uint8(0x42),
		2363: uint8(0x47),
		2364: uint8(0x48),
		2365: uint8(0x42),
		2366: uint8(0x44),
		2367: uint8(0x4e),
		2368: uint8(0xd7),
		2369: uint8(0xdd),
		2370: uint8(0xdd),
		2371: uint8(0xd8),
		2372: uint8(0xde),
		2373: uint8(0xdb),
		2374: uint8(0xd3),
		2375: uint8(0xd5),
		2376: uint8(0xd0),
		2377: uint8(0xd6),
		2378: uint8(0xd6),
		2379: uint8(0xdf),
		2380: uint8(0xd9),
		2381: uint8(0xd0),
		2382: uint8(0xda),
		2383: uint8(0xd3),
		2384: uint8(0xd1),
		2385: uint8(0xd4),
		2386: uint8(0xd2),
		2387: uint8(0xd7),
		2388: uint8(0xd8),
		2389: uint8(0xd2),
		2390: uint8(0xd5),
		2391: uint8(0xdc),
		2392: uint8(0xdb),
		2393: uint8(0xd1),
		2394: uint8(0xdc),
		2395: uint8(0xda),
		2396: uint8(0xd4),
		2397: uint8(0xde),
		2398: uint8(0xdf),
		2399: uint8(0xd9),
		2400: uint8(0xda),
		2401: uint8(0xd3),
		2402: uint8(0xd6),
		2403: uint8(0xdf),
		2404: uint8(0xd9),
		2405: uint8(0xd0),
		2406: uint8(0xd0),
		2407: uint8(0xd6),
		2408: uint8(0xdc),
		2409: uint8(0xda),
		2410: uint8(0xdb),
		2411: uint8(0xd1),
		2412: uint8(0xd7),
		2413: uint8(0xdd),
		2414: uint8(0xdd),
		2415: uint8(0xd8),
		2416: uint8(0xdf),
		2417: uint8(0xd9),
		2418: uint8(0xd1),
		2419: uint8(0xd4),
		2420: uint8(0xd3),
		2421: uint8(0xd5),
		2422: uint8(0xde),
		2423: uint8(0xdb),
		2424: uint8(0xd5),
		2425: uint8(0xdc),
		2426: uint8(0xd2),
		2427: uint8(0xd7),
		2428: uint8(0xd8),
		2429: uint8(0xd2),
		2430: uint8(0xd4),
		2431: uint8(0xde),
		2432: uint8(0x97),
		2433: uint8(0x9d),
		2434: uint8(0x9d),
		2435: uint8(0x98),
		2436: uint8(0x9e),
		2437: uint8(0x9b),
		2438: uint8(0x93),
		2439: uint8(0x95),
		2440: uint8(0x90),
		2441: uint8(0x96),
		2442: uint8(0x96),
		2443: uint8(0x9f),
		2444: uint8(0x99),
		2445: uint8(0x90),
		2446: uint8(0x9a),
		2447: uint8(0x93),
		2448: uint8(0x91),
		2449: uint8(0x94),
		2450: uint8(0x92),
		2451: uint8(0x97),
		2452: uint8(0x98),
		2453: uint8(0x92),
		2454: uint8(0x95),
		2455: uint8(0x9c),
		2456: uint8(0x9b),
		2457: uint8(0x91),
		2458: uint8(0x9c),
		2459: uint8(0x9a),
		2460: uint8(0x94),
		2461: uint8(0x9e),
		2462: uint8(0x9f),
		2463: uint8(0x99),
		2464: uint8(0x9a),
		2465: uint8(0x93),
		2466: uint8(0x96),
		2467: uint8(0x9f),
		2468: uint8(0x99),
		2469: uint8(0x90),
		2470: uint8(0x90),
		2471: uint8(0x96),
		2472: uint8(0x9c),
		2473: uint8(0x9a),
		2474: uint8(0x9b),
		2475: uint8(0x91),
		2476: uint8(0x97),
		2477: uint8(0x9d),
		2478: uint8(0x9d),
		2479: uint8(0x98),
		2480: uint8(0x9f),
		2481: uint8(0x99),
		2482: uint8(0x91),
		2483: uint8(0x94),
		2484: uint8(0x93),
		2485: uint8(0x95),
		2486: uint8(0x9e),
		2487: uint8(0x9b),
		2488: uint8(0x95),
		2489: uint8(0x9c),
		2490: uint8(0x92),
		2491: uint8(0x97),
		2492: uint8(0x98),
		2493: uint8(0x92),
		2494: uint8(0x94),
		2495: uint8(0x9e),
		2496: uint8(0x07),
		2497: uint8(0x0d),
		2498: uint8(0x0d),
		2499: uint8(0x08),
		2500: uint8(0x0e),
		2501: uint8(0x0b),
		2502: uint8(0x03),
		2503: uint8(0x05),
		2504: uint8(0x00),
		2505: uint8(0x06),
		2506: uint8(0x06),
		2507: uint8(0x0f),
		2508: uint8(0x09),
		2509: uint8(0x00),
		2510: uint8(0x0a),
		2511: uint8(0x03),
		2512: uint8(0x01),
		2513: uint8(0x04),
		2514: uint8(0x02),
		2515: uint8(0x07),
		2516: uint8(0x08),
		2517: uint8(0x02),
		2518: uint8(0x05),
		2519: uint8(0x0c),
		2520: uint8(0x0b),
		2521: uint8(0x01),
		2522: uint8(0x0c),
		2523: uint8(0x0a),
		2524: uint8(0x04),
		2525: uint8(0x0e),
		2526: uint8(0x0f),
		2527: uint8(0x09),
		2528: uint8(0x0a),
		2529: uint8(0x03),
		2530: uint8(0x06),
		2531: uint8(0x0f),
		2532: uint8(0x09),
		2533: uint8(0x00),
		2534: uint8(0x00),
		2535: uint8(0x06),
		2536: uint8(0x0c),
		2537: uint8(0x0a),
		2538: uint8(0x0b),
		2539: uint8(0x01),
		2540: uint8(0x07),
		2541: uint8(0x0d),
		2542: uint8(0x0d),
		2543: uint8(0x08),
		2544: uint8(0x0f),
		2545: uint8(0x09),
		2546: uint8(0x01),
		2547: uint8(0x04),
		2548: uint8(0x03),
		2549: uint8(0x05),
		2550: uint8(0x0e),
		2551: uint8(0x0b),
		2552: uint8(0x05),
		2553: uint8(0x0c),
		2554: uint8(0x02),
		2555: uint8(0x07),
		2556: uint8(0x08),
		2557: uint8(0x02),
		2558: uint8(0x04),
		2559: uint8(0x0e),
		2560: uint8(0x87),
		2561: uint8(0x8d),
		2562: uint8(0x8d),
		2563: uint8(0x88),
		2564: uint8(0x8e),
		2565: uint8(0x8b),
		2566: uint8(0x83),
		2567: uint8(0x85),
		2568: uint8(0x80),
		2569: uint8(0x86),
		2570: uint8(0x86),
		2571: uint8(0x8f),
		2572: uint8(0x89),
		2573: uint8(0x80),
		2574: uint8(0x8a),
		2575: uint8(0x83),
		2576: uint8(0x81),
		2577: uint8(0x84),
		2578: uint8(0x82),
		2579: uint8(0x87),
		2580: uint8(0x88),
		2581: uint8(0x82),
		2582: uint8(0x85),
		2583: uint8(0x8c),
		2584: uint8(0x8b),
		2585: uint8(0x81),
		2586: uint8(0x8c),
		2587: uint8(0x8a),
		2588: uint8(0x84),
		2589: uint8(0x8e),
		2590: uint8(0x8f),
		2591: uint8(0x89),
		2592: uint8(0x8a),
		2593: uint8(0x83),
		2594: uint8(0x86),
		2595: uint8(0x8f),
		2596: uint8(0x89),
		2597: uint8(0x80),
		2598: uint8(0x80),
		2599: uint8(0x86),
		2600: uint8(0x8c),
		2601: uint8(0x8a),
		2602: uint8(0x8b),
		2603: uint8(0x81),
		2604: uint8(0x87),
		2605: uint8(0x8d),
		2606: uint8(0x8d),
		2607: uint8(0x88),
		2608: uint8(0x8f),
		2609: uint8(0x89),
		2610: uint8(0x81),
		2611: uint8(0x84),
		2612: uint8(0x83),
		2613: uint8(0x85),
		2614: uint8(0x8e),
		2615: uint8(0x8b),
		2616: uint8(0x85),
		2617: uint8(0x8c),
		2618: uint8(0x82),
		2619: uint8(0x87),
		2620: uint8(0x88),
		2621: uint8(0x82),
		2622: uint8(0x84),
		2623: uint8(0x8e),
		2624: uint8(0x67),
		2625: uint8(0x6d),
		2626: uint8(0x6d),
		2627: uint8(0x68),
		2628: uint8(0x6e),
		2629: uint8(0x6b),
		2630: uint8(0x63),
		2631: uint8(0x65),
		2632: uint8(0x60),
		2633: uint8(0x66),
		2634: uint8(0x66),
		2635: uint8(0x6f),
		2636: uint8(0x69),
		2637: uint8(0x60),
		2638: uint8(0x6a),
		2639: uint8(0x63),
		2640: uint8(0x61),
		2641: uint8(0x64),
		2642: uint8(0x62),
		2643: uint8(0x67),
		2644: uint8(0x68),
		2645: uint8(0x62),
		2646: uint8(0x65),
		2647: uint8(0x6c),
		2648: uint8(0x6b),
		2649: uint8(0x61),
		2650: uint8(0x6c),
		2651: uint8(0x6a),
		2652: uint8(0x64),
		2653: uint8(0x6e),
		2654: uint8(0x6f),
		2655: uint8(0x69),
		2656: uint8(0x6a),
		2657: uint8(0x63),
		2658: uint8(0x66),
		2659: uint8(0x6f),
		2660: uint8(0x69),
		2661: uint8(0x60),
		2662: uint8(0x60),
		2663: uint8(0x66),
		2664: uint8(0x6c),
		2665: uint8(0x6a),
		2666: uint8(0x6b),
		2667: uint8(0x61),
		2668: uint8(0x67),
		2669: uint8(0x6d),
		2670: uint8(0x6d),
		2671: uint8(0x68),
		2672: uint8(0x6f),
		2673: uint8(0x69),
		2674: uint8(0x61),
		2675: uint8(0x64),
		2676: uint8(0x63),
		2677: uint8(0x65),
		2678: uint8(0x6e),
		2679: uint8(0x6b),
		2680: uint8(0x65),
		2681: uint8(0x6c),
		2682: uint8(0x62),
		2683: uint8(0x67),
		2684: uint8(0x68),
		2685: uint8(0x62),
		2686: uint8(0x64),
		2687: uint8(0x6e),
		2688: uint8(0xf7),
		2689: uint8(0xfd),
		2690: uint8(0xfd),
		2691: uint8(0xf8),
		2692: uint8(0xfe),
		2693: uint8(0xfb),
		2694: uint8(0xf3),
		2695: uint8(0xf5),
		2696: uint8(0xf0),
		2697: uint8(0xf6),
		2698: uint8(0xf6),
		2699: uint8(0xff),
		2700: uint8(0xf9),
		2701: uint8(0xf0),
		2702: uint8(0xfa),
		2703: uint8(0xf3),
		2704: uint8(0xf1),
		2705: uint8(0xf4),
		2706: uint8(0xf2),
		2707: uint8(0xf7),
		2708: uint8(0xf8),
		2709: uint8(0xf2),
		2710: uint8(0xf5),
		2711: uint8(0xfc),
		2712: uint8(0xfb),
		2713: uint8(0xf1),
		2714: uint8(0xfc),
		2715: uint8(0xfa),
		2716: uint8(0xf4),
		2717: uint8(0xfe),
		2718: uint8(0xff),
		2719: uint8(0xf9),
		2720: uint8(0xfa),
		2721: uint8(0xf3),
		2722: uint8(0xf6),
		2723: uint8(0xff),
		2724: uint8(0xf9),
		2725: uint8(0xf0),
		2726: uint8(0xf0),
		2727: uint8(0xf6),
		2728: uint8(0xfc),
		2729: uint8(0xfa),
		2730: uint8(0xfb),
		2731: uint8(0xf1),
		2732: uint8(0xf7),
		2733: uint8(0xfd),
		2734: uint8(0xfd),
		2735: uint8(0xf8),
		2736: uint8(0xff),
		2737: uint8(0xf9),
		2738: uint8(0xf1),
		2739: uint8(0xf4),
		2740: uint8(0xf3),
		2741: uint8(0xf5),
		2742: uint8(0xfe),
		2743: uint8(0xfb),
		2744: uint8(0xf5),
		2745: uint8(0xfc),
		2746: uint8(0xf2),
		2747: uint8(0xf7),
		2748: uint8(0xf8),
		2749: uint8(0xf2),
		2750: uint8(0xf4),
		2751: uint8(0xfe),
		2752: uint8(0x97),
		2753: uint8(0x9d),
		2754: uint8(0x9d),
		2755: uint8(0x98),
		2756: uint8(0x9e),
		2757: uint8(0x9b),
		2758: uint8(0x93),
		2759: uint8(0x95),
		2760: uint8(0x90),
		2761: uint8(0x96),
		2762: uint8(0x96),
		2763: uint8(0x9f),
		2764: uint8(0x99),
		2765: uint8(0x90),
		2766: uint8(0x9a),
		2767: uint8(0x93),
		2768: uint8(0x91),
		2769: uint8(0x94),
		2770: uint8(0x92),
		2771: uint8(0x97),
		2772: uint8(0x98),
		2773: uint8(0x92),
		2774: uint8(0x95),
		2775: uint8(0x9c),
		2776: uint8(0x9b),
		2777: uint8(0x91),
		2778: uint8(0x9c),
		2779: uint8(0x9a),
		2780: uint8(0x94),
		2781: uint8(0x9e),
		2782: uint8(0x9f),
		2783: uint8(0x99),
		2784: uint8(0x9a),
		2785: uint8(0x93),
		2786: uint8(0x96),
		2787: uint8(0x9f),
		2788: uint8(0x99),
		2789: uint8(0x90),
		2790: uint8(0x90),
		2791: uint8(0x96),
		2792: uint8(0x9c),
		2793: uint8(0x9a),
		2794: uint8(0x9b),
		2795: uint8(0x91),
		2796: uint8(0x97),
		2797: uint8(0x9d),
		2798: uint8(0x9d),
		2799: uint8(0x98),
		2800: uint8(0x9f),
		2801: uint8(0x99),
		2802: uint8(0x91),
		2803: uint8(0x94),
		2804: uint8(0x93),
		2805: uint8(0x95),
		2806: uint8(0x9e),
		2807: uint8(0x9b),
		2808: uint8(0x95),
		2809: uint8(0x9c),
		2810: uint8(0x92),
		2811: uint8(0x97),
		2812: uint8(0x98),
		2813: uint8(0x92),
		2814: uint8(0x94),
		2815: uint8(0x9e),
		2816: uint8(0x37),
		2817: uint8(0x3d),
		2818: uint8(0x3d),
		2819: uint8(0x38),
		2820: uint8(0x3e),
		2821: uint8(0x3b),
		2822: uint8(0x33),
		2823: uint8(0x35),
		2824: uint8(0x30),
		2825: uint8(0x36),
		2826: uint8(0x36),
		2827: uint8(0x3f),
		2828: uint8(0x39),
		2829: uint8(0x30),
		2830: uint8(0x3a),
		2831: uint8(0x33),
		2832: uint8(0x31),
		2833: uint8(0x34),
		2834: uint8(0x32),
		2835: uint8(0x37),
		2836: uint8(0x38),
		2837: uint8(0x32),
		2838: uint8(0x35),
		2839: uint8(0x3c),
		2840: uint8(0x3b),
		2841: uint8(0x31),
		2842: uint8(0x3c),
		2843: uint8(0x3a),
		2844: uint8(0x34),
		2845: uint8(0x3e),
		2846: uint8(0x3f),
		2847: uint8(0x39),
		2848: uint8(0x3a),
		2849: uint8(0x33),
		2850: uint8(0x36),
		2851: uint8(0x3f),
		2852: uint8(0x39),
		2853: uint8(0x30),
		2854: uint8(0x30),
		2855: uint8(0x36),
		2856: uint8(0x3c),
		2857: uint8(0x3a),
		2858: uint8(0x3b),
		2859: uint8(0x31),
		2860: uint8(0x37),
		2861: uint8(0x3d),
		2862: uint8(0x3d),
		2863: uint8(0x38),
		2864: uint8(0x3f),
		2865: uint8(0x39),
		2866: uint8(0x31),
		2867: uint8(0x34),
		2868: uint8(0x33),
		2869: uint8(0x35),
		2870: uint8(0x3e),
		2871: uint8(0x3b),
		2872: uint8(0x35),
		2873: uint8(0x3c),
		2874: uint8(0x32),
		2875: uint8(0x37),
		2876: uint8(0x38),
		2877: uint8(0x32),
		2878: uint8(0x34),
		2879: uint8(0x3e),
		2880: uint8(0x87),
		2881: uint8(0x8d),
		2882: uint8(0x8d),
		2883: uint8(0x88),
		2884: uint8(0x8e),
		2885: uint8(0x8b),
		2886: uint8(0x83),
		2887: uint8(0x85),
		2888: uint8(0x80),
		2889: uint8(0x86),
		2890: uint8(0x86),
		2891: uint8(0x8f),
		2892: uint8(0x89),
		2893: uint8(0x80),
		2894: uint8(0x8a),
		2895: uint8(0x83),
		2896: uint8(0x81),
		2897: uint8(0x84),
		2898: uint8(0x82),
		2899: uint8(0x87),
		2900: uint8(0x88),
		2901: uint8(0x82),
		2902: uint8(0x85),
		2903: uint8(0x8c),
		2904: uint8(0x8b),
		2905: uint8(0x81),
		2906: uint8(0x8c),
		2907: uint8(0x8a),
		2908: uint8(0x84),
		2909: uint8(0x8e),
		2910: uint8(0x8f),
		2911: uint8(0x89),
		2912: uint8(0x8a),
		2913: uint8(0x83),
		2914: uint8(0x86),
		2915: uint8(0x8f),
		2916: uint8(0x89),
		2917: uint8(0x80),
		2918: uint8(0x80),
		2919: uint8(0x86),
		2920: uint8(0x8c),
		2921: uint8(0x8a),
		2922: uint8(0x8b),
		2923: uint8(0x81),
		2924: uint8(0x87),
		2925: uint8(0x8d),
		2926: uint8(0x8d),
		2927: uint8(0x88),
		2928: uint8(0x8f),
		2929: uint8(0x89),
		2930: uint8(0x81),
		2931: uint8(0x84),
		2932: uint8(0x83),
		2933: uint8(0x85),
		2934: uint8(0x8e),
		2935: uint8(0x8b),
		2936: uint8(0x85),
		2937: uint8(0x8c),
		2938: uint8(0x82),
		2939: uint8(0x87),
		2940: uint8(0x88),
		2941: uint8(0x82),
		2942: uint8(0x84),
		2943: uint8(0x8e),
		2944: uint8(0x07),
		2945: uint8(0x0d),
		2946: uint8(0x0d),
		2947: uint8(0x08),
		2948: uint8(0x0e),
		2949: uint8(0x0b),
		2950: uint8(0x03),
		2951: uint8(0x05),
		2952: uint8(0x00),
		2953: uint8(0x06),
		2954: uint8(0x06),
		2955: uint8(0x0f),
		2956: uint8(0x09),
		2957: uint8(0x00),
		2958: uint8(0x0a),
		2959: uint8(0x03),
		2960: uint8(0x01),
		2961: uint8(0x04),
		2962: uint8(0x02),
		2963: uint8(0x07),
		2964: uint8(0x08),
		2965: uint8(0x02),
		2966: uint8(0x05),
		2967: uint8(0x0c),
		2968: uint8(0x0b),
		2969: uint8(0x01),
		2970: uint8(0x0c),
		2971: uint8(0x0a),
		2972: uint8(0x04),
		2973: uint8(0x0e),
		2974: uint8(0x0f),
		2975: uint8(0x09),
		2976: uint8(0x0a),
		2977: uint8(0x03),
		2978: uint8(0x06),
		2979: uint8(0x0f),
		2980: uint8(0x09),
		2981: uint8(0x00),
		2982: uint8(0x00),
		2983: uint8(0x06),
		2984: uint8(0x0c),
		2985: uint8(0x0a),
		2986: uint8(0x0b),
		2987: uint8(0x01),
		2988: uint8(0x07),
		2989: uint8(0x0d),
		2990: uint8(0x0d),
		2991: uint8(0x08),
		2992: uint8(0x0f),
		2993: uint8(0x09),
		2994: uint8(0x01),
		2995: uint8(0x04),
		2996: uint8(0x03),
		2997: uint8(0x05),
		2998: uint8(0x0e),
		2999: uint8(0x0b),
		3000: uint8(0x05),
		3001: uint8(0x0c),
		3002: uint8(0x02),
		3003: uint8(0x07),
		3004: uint8(0x08),
		3005: uint8(0x02),
		3006: uint8(0x04),
		3007: uint8(0x0e),
		3008: uint8(0x77),
		3009: uint8(0x7d),
		3010: uint8(0x7d),
		3011: uint8(0x78),
		3012: uint8(0x7e),
		3013: uint8(0x7b),
		3014: uint8(0x73),
		3015: uint8(0x75),
		3016: uint8(0x70),
		3017: uint8(0x76),
		3018: uint8(0x76),
		3019: uint8(0x7f),
		3020: uint8(0x79),
		3021: uint8(0x70),
		3022: uint8(0x7a),
		3023: uint8(0x73),
		3024: uint8(0x71),
		3025: uint8(0x74),
		3026: uint8(0x72),
		3027: uint8(0x77),
		3028: uint8(0x78),
		3029: uint8(0x72),
		3030: uint8(0x75),
		3031: uint8(0x7c),
		3032: uint8(0x7b),
		3033: uint8(0x71),
		3034: uint8(0x7c),
		3035: uint8(0x7a),
		3036: uint8(0x74),
		3037: uint8(0x7e),
		3038: uint8(0x7f),
		3039: uint8(0x79),
		3040: uint8(0x7a),
		3041: uint8(0x73),
		3042: uint8(0x76),
		3043: uint8(0x7f),
		3044: uint8(0x79),
		3045: uint8(0x70),
		3046: uint8(0x70),
		3047: uint8(0x76),
		3048: uint8(0x7c),
		3049: uint8(0x7a),
		3050: uint8(0x7b),
		3051: uint8(0x71),
		3052: uint8(0x77),
		3053: uint8(0x7d),
		3054: uint8(0x7d),
		3055: uint8(0x78),
		3056: uint8(0x7f),
		3057: uint8(0x79),
		3058: uint8(0x71),
		3059: uint8(0x74),
		3060: uint8(0x73),
		3061: uint8(0x75),
		3062: uint8(0x7e),
		3063: uint8(0x7b),
		3064: uint8(0x75),
		3065: uint8(0x7c),
		3066: uint8(0x72),
		3067: uint8(0x77),
		3068: uint8(0x78),
		3069: uint8(0x72),
		3070: uint8(0x74),
		3071: uint8(0x7e),
		3072: uint8(0xb7),
		3073: uint8(0xbd),
		3074: uint8(0xbd),
		3075: uint8(0xb8),
		3076: uint8(0xbe),
		3077: uint8(0xbb),
		3078: uint8(0xb3),
		3079: uint8(0xb5),
		3080: uint8(0xb0),
		3081: uint8(0xb6),
		3082: uint8(0xb6),
		3083: uint8(0xbf),
		3084: uint8(0xb9),
		3085: uint8(0xb0),
		3086: uint8(0xba),
		3087: uint8(0xb3),
		3088: uint8(0xb1),
		3089: uint8(0xb4),
		3090: uint8(0xb2),
		3091: uint8(0xb7),
		3092: uint8(0xb8),
		3093: uint8(0xb2),
		3094: uint8(0xb5),
		3095: uint8(0xbc),
		3096: uint8(0xbb),
		3097: uint8(0xb1),
		3098: uint8(0xbc),
		3099: uint8(0xba),
		3100: uint8(0xb4),
		3101: uint8(0xbe),
		3102: uint8(0xbf),
		3103: uint8(0xb9),
		3104: uint8(0xba),
		3105: uint8(0xb3),
		3106: uint8(0xb6),
		3107: uint8(0xbf),
		3108: uint8(0xb9),
		3109: uint8(0xb0),
		3110: uint8(0xb0),
		3111: uint8(0xb6),
		3112: uint8(0xbc),
		3113: uint8(0xba),
		3114: uint8(0xbb),
		3115: uint8(0xb1),
		3116: uint8(0xb7),
		3117: uint8(0xbd),
		3118: uint8(0xbd),
		3119: uint8(0xb8),
		3120: uint8(0xbf),
		3121: uint8(0xb9),
		3122: uint8(0xb1),
		3123: uint8(0xb4),
		3124: uint8(0xb3),
		3125: uint8(0xb5),
		3126: uint8(0xbe),
		3127: uint8(0xbb),
		3128: uint8(0xb5),
		3129: uint8(0xbc),
		3130: uint8(0xb2),
		3131: uint8(0xb7),
		3132: uint8(0xb8),
		3133: uint8(0xb2),
		3134: uint8(0xb4),
		3135: uint8(0xbe),
		3136: uint8(0x47),
		3137: uint8(0x4d),
		3138: uint8(0x4d),
		3139: uint8(0x48),
		3140: uint8(0x4e),
		3141: uint8(0x4b),
		3142: uint8(0x43),
		3143: uint8(0x45),
		3144: uint8(0x40),
		3145: uint8(0x46),
		3146: uint8(0x46),
		3147: uint8(0x4f),
		3148: uint8(0x49),
		3149: uint8(0x40),
		3150: uint8(0x4a),
		3151: uint8(0x43),
		3152: uint8(0x41),
		3153: uint8(0x44),
		3154: uint8(0x42),
		3155: uint8(0x47),
		3156: uint8(0x48),
		3157: uint8(0x42),
		3158: uint8(0x45),
		3159: uint8(0x4c),
		3160: uint8(0x4b),
		3161: uint8(0x41),
		3162: uint8(0x4c),
		3163: uint8(0x4a),
		3164: uint8(0x44),
		3165: uint8(0x4e),
		3166: uint8(0x4f),
		3167: uint8(0x49),
		3168: uint8(0x4a),
		3169: uint8(0x43),
		3170: uint8(0x46),
		3171: uint8(0x4f),
		3172: uint8(0x49),
		3173: uint8(0x40),
		3174: uint8(0x40),
		3175: uint8(0x46),
		3176: uint8(0x4c),
		3177: uint8(0x4a),
		3178: uint8(0x4b),
		3179: uint8(0x41),
		3180: uint8(0x47),
		3181: uint8(0x4d),
		3182: uint8(0x4d),
		3183: uint8(0x48),
		3184: uint8(0x4f),
		3185: uint8(0x49),
		3186: uint8(0x41),
		3187: uint8(0x44),
		3188: uint8(0x43),
		3189: uint8(0x45),
		3190: uint8(0x4e),
		3191: uint8(0x4b),
		3192: uint8(0x45),
		3193: uint8(0x4c),
		3194: uint8(0x42),
		3195: uint8(0x47),
		3196: uint8(0x48),
		3197: uint8(0x42),
		3198: uint8(0x44),
		3199: uint8(0x4e),
		3200: uint8(0x17),
		3201: uint8(0x1d),
		3202: uint8(0x1d),
		3203: uint8(0x18),
		3204: uint8(0x1e),
		3205: uint8(0x1b),
		3206: uint8(0x13),
		3207: uint8(0x15),
		3208: uint8(0x10),
		3209: uint8(0x16),
		3210: uint8(0x16),
		3211: uint8(0x1f),
		3212: uint8(0x19),
		3213: uint8(0x10),
		3214: uint8(0x1a),
		3215: uint8(0x13),
		3216: uint8(0x11),
		3217: uint8(0x14),
		3218: uint8(0x12),
		3219: uint8(0x17),
		3220: uint8(0x18),
		3221: uint8(0x12),
		3222: uint8(0x15),
		3223: uint8(0x1c),
		3224: uint8(0x1b),
		3225: uint8(0x11),
		3226: uint8(0x1c),
		3227: uint8(0x1a),
		3228: uint8(0x14),
		3229: uint8(0x1e),
		3230: uint8(0x1f),
		3231: uint8(0x19),
		3232: uint8(0x1a),
		3233: uint8(0x13),
		3234: uint8(0x16),
		3235: uint8(0x1f),
		3236: uint8(0x19),
		3237: uint8(0x10),
		3238: uint8(0x10),
		3239: uint8(0x16),
		3240: uint8(0x1c),
		3241: uint8(0x1a),
		3242: uint8(0x1b),
		3243: uint8(0x11),
		3244: uint8(0x17),
		3245: uint8(0x1d),
		3246: uint8(0x1d),
		3247: uint8(0x18),
		3248: uint8(0x1f),
		3249: uint8(0x19),
		3250: uint8(0x11),
		3251: uint8(0x14),
		3252: uint8(0x13),
		3253: uint8(0x15),
		3254: uint8(0x1e),
		3255: uint8(0x1b),
		3256: uint8(0x15),
		3257: uint8(0x1c),
		3258: uint8(0x12),
		3259: uint8(0x17),
		3260: uint8(0x18),
		3261: uint8(0x12),
		3262: uint8(0x14),
		3263: uint8(0x1e),
		3264: uint8(0xf7),
		3265: uint8(0xfd),
		3266: uint8(0xfd),
		3267: uint8(0xf8),
		3268: uint8(0xfe),
		3269: uint8(0xfb),
		3270: uint8(0xf3),
		3271: uint8(0xf5),
		3272: uint8(0xf0),
		3273: uint8(0xf6),
		3274: uint8(0xf6),
		3275: uint8(0xff),
		3276: uint8(0xf9),
		3277: uint8(0xf0),
		3278: uint8(0xfa),
		3279: uint8(0xf3),
		3280: uint8(0xf1),
		3281: uint8(0xf4),
		3282: uint8(0xf2),
		3283: uint8(0xf7),
		3284: uint8(0xf8),
		3285: uint8(0xf2),
		3286: uint8(0xf5),
		3287: uint8(0xfc),
		3288: uint8(0xfb),
		3289: uint8(0xf1),
		3290: uint8(0xfc),
		3291: uint8(0xfa),
		3292: uint8(0xf4),
		3293: uint8(0xfe),
		3294: uint8(0xff),
		3295: uint8(0xf9),
		3296: uint8(0xfa),
		3297: uint8(0xf3),
		3298: uint8(0xf6),
		3299: uint8(0xff),
		3300: uint8(0xf9),
		3301: uint8(0xf0),
		3302: uint8(0xf0),
		3303: uint8(0xf6),
		3304: uint8(0xfc),
		3305: uint8(0xfa),
		3306: uint8(0xfb),
		3307: uint8(0xf1),
		3308: uint8(0xf7),
		3309: uint8(0xfd),
		3310: uint8(0xfd),
		3311: uint8(0xf8),
		3312: uint8(0xff),
		3313: uint8(0xf9),
		3314: uint8(0xf1),
		3315: uint8(0xf4),
		3316: uint8(0xf3),
		3317: uint8(0xf5),
		3318: uint8(0xfe),
		3319: uint8(0xfb),
		3320: uint8(0xf5),
		3321: uint8(0xfc),
		3322: uint8(0xf2),
		3323: uint8(0xf7),
		3324: uint8(0xf8),
		3325: uint8(0xf2),
		3326: uint8(0xf4),
		3327: uint8(0xfe),
		3328: uint8(0x27),
		3329: uint8(0x2d),
		3330: uint8(0x2d),
		3331: uint8(0x28),
		3332: uint8(0x2e),
		3333: uint8(0x2b),
		3334: uint8(0x23),
		3335: uint8(0x25),
		3336: uint8(0x20),
		3337: uint8(0x26),
		3338: uint8(0x26),
		3339: uint8(0x2f),
		3340: uint8(0x29),
		3341: uint8(0x20),
		3342: uint8(0x2a),
		3343: uint8(0x23),
		3344: uint8(0x21),
		3345: uint8(0x24),
		3346: uint8(0x22),
		3347: uint8(0x27),
		3348: uint8(0x28),
		3349: uint8(0x22),
		3350: uint8(0x25),
		3351: uint8(0x2c),
		3352: uint8(0x2b),
		3353: uint8(0x21),
		3354: uint8(0x2c),
		3355: uint8(0x2a),
		3356: uint8(0x24),
		3357: uint8(0x2e),
		3358: uint8(0x2f),
		3359: uint8(0x29),
		3360: uint8(0x2a),
		3361: uint8(0x23),
		3362: uint8(0x26),
		3363: uint8(0x2f),
		3364: uint8(0x29),
		3365: uint8(0x20),
		3366: uint8(0x20),
		3367: uint8(0x26),
		3368: uint8(0x2c),
		3369: uint8(0x2a),
		3370: uint8(0x2b),
		3371: uint8(0x21),
		3372: uint8(0x27),
		3373: uint8(0x2d),
		3374: uint8(0x2d),
		3375: uint8(0x28),
		3376: uint8(0x2f),
		3377: uint8(0x29),
		3378: uint8(0x21),
		3379: uint8(0x24),
		3380: uint8(0x23),
		3381: uint8(0x25),
		3382: uint8(0x2e),
		3383: uint8(0x2b),
		3384: uint8(0x25),
		3385: uint8(0x2c),
		3386: uint8(0x22),
		3387: uint8(0x27),
		3388: uint8(0x28),
		3389: uint8(0x22),
		3390: uint8(0x24),
		3391: uint8(0x2e),
		3392: uint8(0xe7),
		3393: uint8(0xed),
		3394: uint8(0xed),
		3395: uint8(0xe8),
		3396: uint8(0xee),
		3397: uint8(0xeb),
		3398: uint8(0xe3),
		3399: uint8(0xe5),
		3400: uint8(0xe0),
		3401: uint8(0xe6),
		3402: uint8(0xe6),
		3403: uint8(0xef),
		3404: uint8(0xe9),
		3405: uint8(0xe0),
		3406: uint8(0xea),
		3407: uint8(0xe3),
		3408: uint8(0xe1),
		3409: uint8(0xe4),
		3410: uint8(0xe2),
		3411: uint8(0xe7),
		3412: uint8(0xe8),
		3413: uint8(0xe2),
		3414: uint8(0xe5),
		3415: uint8(0xec),
		3416: uint8(0xeb),
		3417: uint8(0xe1),
		3418: uint8(0xec),
		3419: uint8(0xea),
		3420: uint8(0xe4),
		3421: uint8(0xee),
		3422: uint8(0xef),
		3423: uint8(0xe9),
		3424: uint8(0xea),
		3425: uint8(0xe3),
		3426: uint8(0xe6),
		3427: uint8(0xef),
		3428: uint8(0xe9),
		3429: uint8(0xe0),
		3430: uint8(0xe0),
		3431: uint8(0xe6),
		3432: uint8(0xec),
		3433: uint8(0xea),
		3434: uint8(0xeb),
		3435: uint8(0xe1),
		3436: uint8(0xe7),
		3437: uint8(0xed),
		3438: uint8(0xed),
		3439: uint8(0xe8),
		3440: uint8(0xef),
		3441: uint8(0xe9),
		3442: uint8(0xe1),
		3443: uint8(0xe4),
		3444: uint8(0xe3),
		3445: uint8(0xe5),
		3446: uint8(0xee),
		3447: uint8(0xeb),
		3448: uint8(0xe5),
		3449: uint8(0xec),
		3450: uint8(0xe2),
		3451: uint8(0xe7),
		3452: uint8(0xe8),
		3453: uint8(0xe2),
		3454: uint8(0xe4),
		3455: uint8(0xee),
		3456: uint8(0xc7),
		3457: uint8(0xcd),
		3458: uint8(0xcd),
		3459: uint8(0xc8),
		3460: uint8(0xce),
		3461: uint8(0xcb),
		3462: uint8(0xc3),
		3463: uint8(0xc5),
		3464: uint8(0xc0),
		3465: uint8(0xc6),
		3466: uint8(0xc6),
		3467: uint8(0xcf),
		3468: uint8(0xc9),
		3469: uint8(0xc0),
		3470: uint8(0xca),
		3471: uint8(0xc3),
		3472: uint8(0xc1),
		3473: uint8(0xc4),
		3474: uint8(0xc2),
		3475: uint8(0xc7),
		3476: uint8(0xc8),
		3477: uint8(0xc2),
		3478: uint8(0xc5),
		3479: uint8(0xcc),
		3480: uint8(0xcb),
		3481: uint8(0xc1),
		3482: uint8(0xcc),
		3483: uint8(0xca),
		3484: uint8(0xc4),
		3485: uint8(0xce),
		3486: uint8(0xcf),
		3487: uint8(0xc9),
		3488: uint8(0xca),
		3489: uint8(0xc3),
		3490: uint8(0xc6),
		3491: uint8(0xcf),
		3492: uint8(0xc9),
		3493: uint8(0xc0),
		3494: uint8(0xc0),
		3495: uint8(0xc6),
		3496: uint8(0xcc),
		3497: uint8(0xca),
		3498: uint8(0xcb),
		3499: uint8(0xc1),
		3500: uint8(0xc7),
		3501: uint8(0xcd),
		3502: uint8(0xcd),
		3503: uint8(0xc8),
		3504: uint8(0xcf),
		3505: uint8(0xc9),
		3506: uint8(0xc1),
		3507: uint8(0xc4),
		3508: uint8(0xc3),
		3509: uint8(0xc5),
		3510: uint8(0xce),
		3511: uint8(0xcb),
		3512: uint8(0xc5),
		3513: uint8(0xcc),
		3514: uint8(0xc2),
		3515: uint8(0xc7),
		3516: uint8(0xc8),
		3517: uint8(0xc2),
		3518: uint8(0xc4),
		3519: uint8(0xce),
		3520: uint8(0x37),
		3521: uint8(0x3d),
		3522: uint8(0x3d),
		3523: uint8(0x38),
		3524: uint8(0x3e),
		3525: uint8(0x3b),
		3526: uint8(0x33),
		3527: uint8(0x35),
		3528: uint8(0x30),
		3529: uint8(0x36),
		3530: uint8(0x36),
		3531: uint8(0x3f),
		3532: uint8(0x39),
		3533: uint8(0x30),
		3534: uint8(0x3a),
		3535: uint8(0x33),
		3536: uint8(0x31),
		3537: uint8(0x34),
		3538: uint8(0x32),
		3539: uint8(0x37),
		3540: uint8(0x38),
		3541: uint8(0x32),
		3542: uint8(0x35),
		3543: uint8(0x3c),
		3544: uint8(0x3b),
		3545: uint8(0x31),
		3546: uint8(0x3c),
		3547: uint8(0x3a),
		3548: uint8(0x34),
		3549: uint8(0x3e),
		3550: uint8(0x3f),
		3551: uint8(0x39),
		3552: uint8(0x3a),
		3553: uint8(0x33),
		3554: uint8(0x36),
		3555: uint8(0x3f),
		3556: uint8(0x39),
		3557: uint8(0x30),
		3558: uint8(0x30),
		3559: uint8(0x36),
		3560: uint8(0x3c),
		3561: uint8(0x3a),
		3562: uint8(0x3b),
		3563: uint8(0x31),
		3564: uint8(0x37),
		3565: uint8(0x3d),
		3566: uint8(0x3d),
		3567: uint8(0x38),
		3568: uint8(0x3f),
		3569: uint8(0x39),
		3570: uint8(0x31),
		3571: uint8(0x34),
		3572: uint8(0x33),
		3573: uint8(0x35),
		3574: uint8(0x3e),
		3575: uint8(0x3b),
		3576: uint8(0x35),
		3577: uint8(0x3c),
		3578: uint8(0x32),
		3579: uint8(0x37),
		3580: uint8(0x38),
		3581: uint8(0x32),
		3582: uint8(0x34),
		3583: uint8(0x3e),
		3584: uint8(0x57),
		3585: uint8(0x5d),
		3586: uint8(0x5d),
		3587: uint8(0x58),
		3588: uint8(0x5e),
		3589: uint8(0x5b),
		3590: uint8(0x53),
		3591: uint8(0x55),
		3592: uint8(0x50),
		3593: uint8(0x56),
		3594: uint8(0x56),
		3595: uint8(0x5f),
		3596: uint8(0x59),
		3597: uint8(0x50),
		3598: uint8(0x5a),
		3599: uint8(0x53),
		3600: uint8(0x51),
		3601: uint8(0x54),
		3602: uint8(0x52),
		3603: uint8(0x57),
		3604: uint8(0x58),
		3605: uint8(0x52),
		3606: uint8(0x55),
		3607: uint8(0x5c),
		3608: uint8(0x5b),
		3609: uint8(0x51),
		3610: uint8(0x5c),
		3611: uint8(0x5a),
		3612: uint8(0x54),
		3613: uint8(0x5e),
		3614: uint8(0x5f),
		3615: uint8(0x59),
		3616: uint8(0x5a),
		3617: uint8(0x53),
		3618: uint8(0x56),
		3619: uint8(0x5f),
		3620: uint8(0x59),
		3621: uint8(0x50),
		3622: uint8(0x50),
		3623: uint8(0x56),
		3624: uint8(0x5c),
		3625: uint8(0x5a),
		3626: uint8(0x5b),
		3627: uint8(0x51),
		3628: uint8(0x57),
		3629: uint8(0x5d),
		3630: uint8(0x5d),
		3631: uint8(0x58),
		3632: uint8(0x5f),
		3633: uint8(0x59),
		3634: uint8(0x51),
		3635: uint8(0x54),
		3636: uint8(0x53),
		3637: uint8(0x55),
		3638: uint8(0x5e),
		3639: uint8(0x5b),
		3640: uint8(0x55),
		3641: uint8(0x5c),
		3642: uint8(0x52),
		3643: uint8(0x57),
		3644: uint8(0x58),
		3645: uint8(0x52),
		3646: uint8(0x54),
		3647: uint8(0x5e),
		3648: uint8(0xb7),
		3649: uint8(0xbd),
		3650: uint8(0xbd),
		3651: uint8(0xb8),
		3652: uint8(0xbe),
		3653: uint8(0xbb),
		3654: uint8(0xb3),
		3655: uint8(0xb5),
		3656: uint8(0xb0),
		3657: uint8(0xb6),
		3658: uint8(0xb6),
		3659: uint8(0xbf),
		3660: uint8(0xb9),
		3661: uint8(0xb0),
		3662: uint8(0xba),
		3663: uint8(0xb3),
		3664: uint8(0xb1),
		3665: uint8(0xb4),
		3666: uint8(0xb2),
		3667: uint8(0xb7),
		3668: uint8(0xb8),
		3669: uint8(0xb2),
		3670: uint8(0xb5),
		3671: uint8(0xbc),
		3672: uint8(0xbb),
		3673: uint8(0xb1),
		3674: uint8(0xbc),
		3675: uint8(0xba),
		3676: uint8(0xb4),
		3677: uint8(0xbe),
		3678: uint8(0xbf),
		3679: uint8(0xb9),
		3680: uint8(0xba),
		3681: uint8(0xb3),
		3682: uint8(0xb6),
		3683: uint8(0xbf),
		3684: uint8(0xb9),
		3685: uint8(0xb0),
		3686: uint8(0xb0),
		3687: uint8(0xb6),
		3688: uint8(0xbc),
		3689: uint8(0xba),
		3690: uint8(0xbb),
		3691: uint8(0xb1),
		3692: uint8(0xb7),
		3693: uint8(0xbd),
		3694: uint8(0xbd),
		3695: uint8(0xb8),
		3696: uint8(0xbf),
		3697: uint8(0xb9),
		3698: uint8(0xb1),
		3699: uint8(0xb4),
		3700: uint8(0xb3),
		3701: uint8(0xb5),
		3702: uint8(0xbe),
		3703: uint8(0xbb),
		3704: uint8(0xb5),
		3705: uint8(0xbc),
		3706: uint8(0xb2),
		3707: uint8(0xb7),
		3708: uint8(0xb8),
		3709: uint8(0xb2),
		3710: uint8(0xb4),
		3711: uint8(0xbe),
		3712: uint8(0xa7),
		3713: uint8(0xad),
		3714: uint8(0xad),
		3715: uint8(0xa8),
		3716: uint8(0xae),
		3717: uint8(0xab),
		3718: uint8(0xa3),
		3719: uint8(0xa5),
		3720: uint8(0xa0),
		3721: uint8(0xa6),
		3722: uint8(0xa6),
		3723: uint8(0xaf),
		3724: uint8(0xa9),
		3725: uint8(0xa0),
		3726: uint8(0xaa),
		3727: uint8(0xa3),
		3728: uint8(0xa1),
		3729: uint8(0xa4),
		3730: uint8(0xa2),
		3731: uint8(0xa7),
		3732: uint8(0xa8),
		3733: uint8(0xa2),
		3734: uint8(0xa5),
		3735: uint8(0xac),
		3736: uint8(0xab),
		3737: uint8(0xa1),
		3738: uint8(0xac),
		3739: uint8(0xaa),
		3740: uint8(0xa4),
		3741: uint8(0xae),
		3742: uint8(0xaf),
		3743: uint8(0xa9),
		3744: uint8(0xaa),
		3745: uint8(0xa3),
		3746: uint8(0xa6),
		3747: uint8(0xaf),
		3748: uint8(0xa9),
		3749: uint8(0xa0),
		3750: uint8(0xa0),
		3751: uint8(0xa6),
		3752: uint8(0xac),
		3753: uint8(0xaa),
		3754: uint8(0xab),
		3755: uint8(0xa1),
		3756: uint8(0xa7),
		3757: uint8(0xad),
		3758: uint8(0xad),
		3759: uint8(0xa8),
		3760: uint8(0xaf),
		3761: uint8(0xa9),
		3762: uint8(0xa1),
		3763: uint8(0xa4),
		3764: uint8(0xa3),
		3765: uint8(0xa5),
		3766: uint8(0xae),
		3767: uint8(0xab),
		3768: uint8(0xa5),
		3769: uint8(0xac),
		3770: uint8(0xa2),
		3771: uint8(0xa7),
		3772: uint8(0xa8),
		3773: uint8(0xa2),
		3774: uint8(0xa4),
		3775: uint8(0xae),
		3776: uint8(0x57),
		3777: uint8(0x5d),
		3778: uint8(0x5d),
		3779: uint8(0x58),
		3780: uint8(0x5e),
		3781: uint8(0x5b),
		3782: uint8(0x53),
		3783: uint8(0x55),
		3784: uint8(0x50),
		3785: uint8(0x56),
		3786: uint8(0x56),
		3787: uint8(0x5f),
		3788: uint8(0x59),
		3789: uint8(0x50),
		3790: uint8(0x5a),
		3791: uint8(0x53),
		3792: uint8(0x51),
		3793: uint8(0x54),
		3794: uint8(0x52),
		3795: uint8(0x57),
		3796: uint8(0x58),
		3797: uint8(0x52),
		3798: uint8(0x55),
		3799: uint8(0x5c),
		3800: uint8(0x5b),
		3801: uint8(0x51),
		3802: uint8(0x5c),
		3803: uint8(0x5a),
		3804: uint8(0x54),
		3805: uint8(0x5e),
		3806: uint8(0x5f),
		3807: uint8(0x59),
		3808: uint8(0x5a),
		3809: uint8(0x53),
		3810: uint8(0x56),
		3811: uint8(0x5f),
		3812: uint8(0x59),
		3813: uint8(0x50),
		3814: uint8(0x50),
		3815: uint8(0x56),
		3816: uint8(0x5c),
		3817: uint8(0x5a),
		3818: uint8(0x5b),
		3819: uint8(0x51),
		3820: uint8(0x57),
		3821: uint8(0x5d),
		3822: uint8(0x5d),
		3823: uint8(0x58),
		3824: uint8(0x5f),
		3825: uint8(0x59),
		3826: uint8(0x51),
		3827: uint8(0x54),
		3828: uint8(0x53),
		3829: uint8(0x55),
		3830: uint8(0x5e),
		3831: uint8(0x5b),
		3832: uint8(0x55),
		3833: uint8(0x5c),
		3834: uint8(0x52),
		3835: uint8(0x57),
		3836: uint8(0x58),
		3837: uint8(0x52),
		3838: uint8(0x54),
		3839: uint8(0x5e),
		3840: uint8(0xe7),
		3841: uint8(0xed),
		3842: uint8(0xed),
		3843: uint8(0xe8),
		3844: uint8(0xee),
		3845: uint8(0xeb),
		3846: uint8(0xe3),
		3847: uint8(0xe5),
		3848: uint8(0xe0),
		3849: uint8(0xe6),
		3850: uint8(0xe6),
		3851: uint8(0xef),
		3852: uint8(0xe9),
		3853: uint8(0xe0),
		3854: uint8(0xea),
		3855: uint8(0xe3),
		3856: uint8(0xe1),
		3857: uint8(0xe4),
		3858: uint8(0xe2),
		3859: uint8(0xe7),
		3860: uint8(0xe8),
		3861: uint8(0xe2),
		3862: uint8(0xe5),
		3863: uint8(0xec),
		3864: uint8(0xeb),
		3865: uint8(0xe1),
		3866: uint8(0xec),
		3867: uint8(0xea),
		3868: uint8(0xe4),
		3869: uint8(0xee),
		3870: uint8(0xef),
		3871: uint8(0xe9),
		3872: uint8(0xea),
		3873: uint8(0xe3),
		3874: uint8(0xe6),
		3875: uint8(0xef),
		3876: uint8(0xe9),
		3877: uint8(0xe0),
		3878: uint8(0xe0),
		3879: uint8(0xe6),
		3880: uint8(0xec),
		3881: uint8(0xea),
		3882: uint8(0xeb),
		3883: uint8(0xe1),
		3884: uint8(0xe7),
		3885: uint8(0xed),
		3886: uint8(0xed),
		3887: uint8(0xe8),
		3888: uint8(0xef),
		3889: uint8(0xe9),
		3890: uint8(0xe1),
		3891: uint8(0xe4),
		3892: uint8(0xe3),
		3893: uint8(0xe5),
		3894: uint8(0xee),
		3895: uint8(0xeb),
		3896: uint8(0xe5),
		3897: uint8(0xec),
		3898: uint8(0xe2),
		3899: uint8(0xe7),
		3900: uint8(0xe8),
		3901: uint8(0xe2),
		3902: uint8(0xe4),
		3903: uint8(0xee),
		3904: uint8(0x27),
		3905: uint8(0x2d),
		3906: uint8(0x2d),
		3907: uint8(0x28),
		3908: uint8(0x2e),
		3909: uint8(0x2b),
		3910: uint8(0x23),
		3911: uint8(0x25),
		3912: uint8(0x20),
		3913: uint8(0x26),
		3914: uint8(0x26),
		3915: uint8(0x2f),
		3916: uint8(0x29),
		3917: uint8(0x20),
		3918: uint8(0x2a),
		3919: uint8(0x23),
		3920: uint8(0x21),
		3921: uint8(0x24),
		3922: uint8(0x22),
		3923: uint8(0x27),
		3924: uint8(0x28),
		3925: uint8(0x22),
		3926: uint8(0x25),
		3927: uint8(0x2c),
		3928: uint8(0x2b),
		3929: uint8(0x21),
		3930: uint8(0x2c),
		3931: uint8(0x2a),
		3932: uint8(0x24),
		3933: uint8(0x2e),
		3934: uint8(0x2f),
		3935: uint8(0x29),
		3936: uint8(0x2a),
		3937: uint8(0x23),
		3938: uint8(0x26),
		3939: uint8(0x2f),
		3940: uint8(0x29),
		3941: uint8(0x20),
		3942: uint8(0x20),
		3943: uint8(0x26),
		3944: uint8(0x2c),
		3945: uint8(0x2a),
		3946: uint8(0x2b),
		3947: uint8(0x21),
		3948: uint8(0x27),
		3949: uint8(0x2d),
		3950: uint8(0x2d),
		3951: uint8(0x28),
		3952: uint8(0x2f),
		3953: uint8(0x29),
		3954: uint8(0x21),
		3955: uint8(0x24),
		3956: uint8(0x23),
		3957: uint8(0x25),
		3958: uint8(0x2e),
		3959: uint8(0x2b),
		3960: uint8(0x25),
		3961: uint8(0x2c),
		3962: uint8(0x22),
		3963: uint8(0x27),
		3964: uint8(0x28),
		3965: uint8(0x22),
		3966: uint8(0x24),
		3967: uint8(0x2e),
		3968: uint8(0x77),
		3969: uint8(0x7d),
		3970: uint8(0x7d),
		3971: uint8(0x78),
		3972: uint8(0x7e),
		3973: uint8(0x7b),
		3974: uint8(0x73),
		3975: uint8(0x75),
		3976: uint8(0x70),
		3977: uint8(0x76),
		3978: uint8(0x76),
		3979: uint8(0x7f),
		3980: uint8(0x79),
		3981: uint8(0x70),
		3982: uint8(0x7a),
		3983: uint8(0x73),
		3984: uint8(0x71),
		3985: uint8(0x74),
		3986: uint8(0x72),
		3987: uint8(0x77),
		3988: uint8(0x78),
		3989: uint8(0x72),
		3990: uint8(0x75),
		3991: uint8(0x7c),
		3992: uint8(0x7b),
		3993: uint8(0x71),
		3994: uint8(0x7c),
		3995: uint8(0x7a),
		3996: uint8(0x74),
		3997: uint8(0x7e),
		3998: uint8(0x7f),
		3999: uint8(0x79),
		4000: uint8(0x7a),
		4001: uint8(0x73),
		4002: uint8(0x76),
		4003: uint8(0x7f),
		4004: uint8(0x79),
		4005: uint8(0x70),
		4006: uint8(0x70),
		4007: uint8(0x76),
		4008: uint8(0x7c),
		4009: uint8(0x7a),
		4010: uint8(0x7b),
		4011: uint8(0x71),
		4012: uint8(0x77),
		4013: uint8(0x7d),
		4014: uint8(0x7d),
		4015: uint8(0x78),
		4016: uint8(0x7f),
		4017: uint8(0x79),
		4018: uint8(0x71),
		4019: uint8(0x74),
		4020: uint8(0x73),
		4021: uint8(0x75),
		4022: uint8(0x7e),
		4023: uint8(0x7b),
		4024: uint8(0x75),
		4025: uint8(0x7c),
		4026: uint8(0x72),
		4027: uint8(0x77),
		4028: uint8(0x78),
		4029: uint8(0x72),
		4030: uint8(0x74),
		4031: uint8(0x7e),
		4032: uint8(0xc7),
		4033: uint8(0xcd),
		4034: uint8(0xcd),
		4035: uint8(0xc8),
		4036: uint8(0xce),
		4037: uint8(0xcb),
		4038: uint8(0xc3),
		4039: uint8(0xc5),
		4040: uint8(0xc0),
		4041: uint8(0xc6),
		4042: uint8(0xc6),
		4043: uint8(0xcf),
		4044: uint8(0xc9),
		4045: uint8(0xc0),
		4046: uint8(0xca),
		4047: uint8(0xc3),
		4048: uint8(0xc1),
		4049: uint8(0xc4),
		4050: uint8(0xc2),
		4051: uint8(0xc7),
		4052: uint8(0xc8),
		4053: uint8(0xc2),
		4054: uint8(0xc5),
		4055: uint8(0xcc),
		4056: uint8(0xcb),
		4057: uint8(0xc1),
		4058: uint8(0xcc),
		4059: uint8(0xca),
		4060: uint8(0xc4),
		4061: uint8(0xce),
		4062: uint8(0xcf),
		4063: uint8(0xc9),
		4064: uint8(0xca),
		4065: uint8(0xc3),
		4066: uint8(0xc6),
		4067: uint8(0xcf),
		4068: uint8(0xc9),
		4069: uint8(0xc0),
		4070: uint8(0xc0),
		4071: uint8(0xc6),
		4072: uint8(0xcc),
		4073: uint8(0xca),
		4074: uint8(0xcb),
		4075: uint8(0xc1),
		4076: uint8(0xc7),
		4077: uint8(0xcd),
		4078: uint8(0xcd),
		4079: uint8(0xc8),
		4080: uint8(0xcf),
		4081: uint8(0xc9),
		4082: uint8(0xc1),
		4083: uint8(0xc4),
		4084: uint8(0xc3),
		4085: uint8(0xc5),
		4086: uint8(0xce),
		4087: uint8(0xcb),
		4088: uint8(0xc5),
		4089: uint8(0xcc),
		4090: uint8(0xc2),
		4091: uint8(0xc7),
		4092: uint8(0xc8),
		4093: uint8(0xc2),
		4094: uint8(0xc4),
		4095: uint8(0xce)},
	2: {
		0:    uint8(0x2c),
		1:    uint8(0x2a),
		2:    uint8(0x21),
		3:    uint8(0x2f),
		4:    uint8(0x2a),
		5:    uint8(0x24),
		6:    uint8(0x2f),
		7:    uint8(0x22),
		8:    uint8(0x29),
		9:    uint8(0x27),
		10:   uint8(0x22),
		11:   uint8(0x2c),
		12:   uint8(0x26),
		13:   uint8(0x29),
		14:   uint8(0x28),
		15:   uint8(0x25),
		16:   uint8(0x20),
		17:   uint8(0x26),
		18:   uint8(0x2d),
		19:   uint8(0x21),
		20:   uint8(0x23),
		21:   uint8(0x2d),
		22:   uint8(0x24),
		23:   uint8(0x2e),
		24:   uint8(0x2e),
		25:   uint8(0x20),
		26:   uint8(0x27),
		27:   uint8(0x2b),
		28:   uint8(0x25),
		29:   uint8(0x23),
		30:   uint8(0x2b),
		31:   uint8(0x28),
		32:   uint8(0x29),
		33:   uint8(0x24),
		34:   uint8(0x2e),
		35:   uint8(0x23),
		36:   uint8(0x2f),
		37:   uint8(0x22),
		38:   uint8(0x25),
		39:   uint8(0x2c),
		40:   uint8(0x22),
		41:   uint8(0x29),
		42:   uint8(0x28),
		43:   uint8(0x25),
		44:   uint8(0x2c),
		45:   uint8(0x2f),
		46:   uint8(0x23),
		47:   uint8(0x2a),
		48:   uint8(0x27),
		49:   uint8(0x2b),
		50:   uint8(0x20),
		51:   uint8(0x2e),
		52:   uint8(0x24),
		53:   uint8(0x21),
		54:   uint8(0x2a),
		55:   uint8(0x27),
		56:   uint8(0x21),
		57:   uint8(0x26),
		58:   uint8(0x2d),
		59:   uint8(0x20),
		60:   uint8(0x2b),
		61:   uint8(0x28),
		62:   uint8(0x26),
		63:   uint8(0x2d),
		64:   uint8(0xec),
		65:   uint8(0xea),
		66:   uint8(0xe1),
		67:   uint8(0xef),
		68:   uint8(0xea),
		69:   uint8(0xe4),
		70:   uint8(0xef),
		71:   uint8(0xe2),
		72:   uint8(0xe9),
		73:   uint8(0xe7),
		74:   uint8(0xe2),
		75:   uint8(0xec),
		76:   uint8(0xe6),
		77:   uint8(0xe9),
		78:   uint8(0xe8),
		79:   uint8(0xe5),
		80:   uint8(0xe0),
		81:   uint8(0xe6),
		82:   uint8(0xed),
		83:   uint8(0xe1),
		84:   uint8(0xe3),
		85:   uint8(0xed),
		86:   uint8(0xe4),
		87:   uint8(0xee),
		88:   uint8(0xee),
		89:   uint8(0xe0),
		90:   uint8(0xe7),
		91:   uint8(0xeb),
		92:   uint8(0xe5),
		93:   uint8(0xe3),
		94:   uint8(0xeb),
		95:   uint8(0xe8),
		96:   uint8(0xe9),
		97:   uint8(0xe4),
		98:   uint8(0xee),
		99:   uint8(0xe3),
		100:  uint8(0xef),
		101:  uint8(0xe2),
		102:  uint8(0xe5),
		103:  uint8(0xec),
		104:  uint8(0xe2),
		105:  uint8(0xe9),
		106:  uint8(0xe8),
		107:  uint8(0xe5),
		108:  uint8(0xec),
		109:  uint8(0xef),
		110:  uint8(0xe3),
		111:  uint8(0xea),
		112:  uint8(0xe7),
		113:  uint8(0xeb),
		114:  uint8(0xe0),
		115:  uint8(0xee),
		116:  uint8(0xe4),
		117:  uint8(0xe1),
		118:  uint8(0xea),
		119:  uint8(0xe7),
		120:  uint8(0xe1),
		121:  uint8(0xe6),
		122:  uint8(0xed),
		123:  uint8(0xe0),
		124:  uint8(0xeb),
		125:  uint8(0xe8),
		126:  uint8(0xe6),
		127:  uint8(0xed),
		128:  uint8(0xcc),
		129:  uint8(0xca),
		130:  uint8(0xc1),
		131:  uint8(0xcf),
		132:  uint8(0xca),
		133:  uint8(0xc4),
		134:  uint8(0xcf),
		135:  uint8(0xc2),
		136:  uint8(0xc9),
		137:  uint8(0xc7),
		138:  uint8(0xc2),
		139:  uint8(0xcc),
		140:  uint8(0xc6),
		141:  uint8(0xc9),
		142:  uint8(0xc8),
		143:  uint8(0xc5),
		144:  uint8(0xc0),
		145:  uint8(0xc6),
		146:  uint8(0xcd),
		147:  uint8(0xc1),
		148:  uint8(0xc3),
		149:  uint8(0xcd),
		150:  uint8(0xc4),
		151:  uint8(0xce),
		152:  uint8(0xce),
		153:  uint8(0xc0),
		154:  uint8(0xc7),
		155:  uint8(0xcb),
		156:  uint8(0xc5),
		157:  uint8(0xc3),
		158:  uint8(0xcb),
		159:  uint8(0xc8),
		160:  uint8(0xc9),
		161:  uint8(0xc4),
		162:  uint8(0xce),
		163:  uint8(0xc3),
		164:  uint8(0xcf),
		165:  uint8(0xc2),
		166:  uint8(0xc5),
		167:  uint8(0xcc),
		168:  uint8(0xc2),
		169:  uint8(0xc9),
		170:  uint8(0xc8),
		171:  uint8(0xc5),
		172:  uint8(0xcc),
		173:  uint8(0xcf),
		174:  uint8(0xc3),
		175:  uint8(0xca),
		176:  uint8(0xc7),
		177:  uint8(0xcb),
		178:  uint8(0xc0),
		179:  uint8(0xce),
		180:  uint8(0xc4),
		181:  uint8(0xc1),
		182:  uint8(0xca),
		183:  uint8(0xc7),
		184:  uint8(0xc1),
		185:  uint8(0xc6),
		186:  uint8(0xcd),
		187:  uint8(0xc0),
		188:  uint8(0xcb),
		189:  uint8(0xc8),
		190:  uint8(0xc6),
		191:  uint8(0xcd),
		192:  uint8(0xbc),
		193:  uint8(0xba),
		194:  uint8(0xb1),
		195:  uint8(0xbf),
		196:  uint8(0xba),
		197:  uint8(0xb4),
		198:  uint8(0xbf),
		199:  uint8(0xb2),
		200:  uint8(0xb9),
		201:  uint8(0xb7),
		202:  uint8(0xb2),
		203:  uint8(0xbc),
		204:  uint8(0xb6),
		205:  uint8(0xb9),
		206:  uint8(0xb8),
		207:  uint8(0xb5),
		208:  uint8(0xb0),
		209:  uint8(0xb6),
		210:  uint8(0xbd),
		211:  uint8(0xb1),
		212:  uint8(0xb3),
		213:  uint8(0xbd),
		214:  uint8(0xb4),
		215:  uint8(0xbe),
		216:  uint8(0xbe),
		217:  uint8(0xb0),
		218:  uint8(0xb7),
		219:  uint8(0xbb),
		220:  uint8(0xb5),
		221:  uint8(0xb3),
		222:  uint8(0xbb),
		223:  uint8(0xb8),
		224:  uint8(0xb9),
		225:  uint8(0xb4),
		226:  uint8(0xbe),
		227:  uint8(0xb3),
		228:  uint8(0xbf),
		229:  uint8(0xb2),
		230:  uint8(0xb5),
		231:  uint8(0xbc),
		232:  uint8(0xb2),
		233:  uint8(0xb9),
		234:  uint8(0xb8),
		235:  uint8(0xb5),
		236:  uint8(0xbc),
		237:  uint8(0xbf),
		238:  uint8(0xb3),
		239:  uint8(0xba),
		240:  uint8(0xb7),
		241:  uint8(0xbb),
		242:  uint8(0xb0),
		243:  uint8(0xbe),
		244:  uint8(0xb4),
		245:  uint8(0xb1),
		246:  uint8(0xba),
		247:  uint8(0xb7),
		248:  uint8(0xb1),
		249:  uint8(0xb6),
		250:  uint8(0xbd),
		251:  uint8(0xb0),
		252:  uint8(0xbb),
		253:  uint8(0xb8),
		254:  uint8(0xb6),
		255:  uint8(0xbd),
		256:  uint8(0x4c),
		257:  uint8(0x4a),
		258:  uint8(0x41),
		259:  uint8(0x4f),
		260:  uint8(0x4a),
		261:  uint8(0x44),
		262:  uint8(0x4f),
		263:  uint8(0x42),
		264:  uint8(0x49),
		265:  uint8(0x47),
		266:  uint8(0x42),
		267:  uint8(0x4c),
		268:  uint8(0x46),
		269:  uint8(0x49),
		270:  uint8(0x48),
		271:  uint8(0x45),
		272:  uint8(0x40),
		273:  uint8(0x46),
		274:  uint8(0x4d),
		275:  uint8(0x41),
		276:  uint8(0x43),
		277:  uint8(0x4d),
		278:  uint8(0x44),
		279:  uint8(0x4e),
		280:  uint8(0x4e),
		281:  uint8(0x40),
		282:  uint8(0x47),
		283:  uint8(0x4b),
		284:  uint8(0x45),
		285:  uint8(0x43),
		286:  uint8(0x4b),
		287:  uint8(0x48),
		288:  uint8(0x49),
		289:  uint8(0x44),
		290:  uint8(0x4e),
		291:  uint8(0x43),
		292:  uint8(0x4f),
		293:  uint8(0x42),
		294:  uint8(0x45),
		295:  uint8(0x4c),
		296:  uint8(0x42),
		297:  uint8(0x49),
		298:  uint8(0x48),
		299:  uint8(0x45),
		300:  uint8(0x4c),
		301:  uint8(0x4f),
		302:  uint8(0x43),
		303:  uint8(0x4a),
		304:  uint8(0x47),
		305:  uint8(0x4b),
		306:  uint8(0x40),
		307:  uint8(0x4e),
		308:  uint8(0x44),
		309:  uint8(0x41),
		310:  uint8(0x4a),
		311:  uint8(0x47),
		312:  uint8(0x41),
		313:  uint8(0x46),
		314:  uint8(0x4d),
		315:  uint8(0x40),
		316:  uint8(0x4b),
		317:  uint8(0x48),
		318:  uint8(0x46),
		319:  uint8(0x4d),
		320:  uint8(0x2c),
		321:  uint8(0x2a),
		322:  uint8(0x21),
		323:  uint8(0x2f),
		324:  uint8(0x2a),
		325:  uint8(0x24),
		326:  uint8(0x2f),
		327:  uint8(0x22),
		328:  uint8(0x29),
		329:  uint8(0x27),
		330:  uint8(0x22),
		331:  uint8(0x2c),
		332:  uint8(0x26),
		333:  uint8(0x29),
		334:  uint8(0x28),
		335:  uint8(0x25),
		336:  uint8(0x20),
		337:  uint8(0x26),
		338:  uint8(0x2d),
		339:  uint8(0x21),
		340:  uint8(0x23),
		341:  uint8(0x2d),
		342:  uint8(0x24),
		343:  uint8(0x2e),
		344:  uint8(0x2e),
		345:  uint8(0x20),
		346:  uint8(0x27),
		347:  uint8(0x2b),
		348:  uint8(0x25),
		349:  uint8(0x23),
		350:  uint8(0x2b),
		351:  uint8(0x28),
		352:  uint8(0x29),
		353:  uint8(0x24),
		354:  uint8(0x2e),
		355:  uint8(0x23),
		356:  uint8(0x2f),
		357:  uint8(0x22),
		358:  uint8(0x25),
		359:  uint8(0x2c),
		360:  uint8(0x22),
		361:  uint8(0x29),
		362:  uint8(0x28),
		363:  uint8(0x25),
		364:  uint8(0x2c),
		365:  uint8(0x2f),
		366:  uint8(0x23),
		367:  uint8(0x2a),
		368:  uint8(0x27),
		369:  uint8(0x2b),
		370:  uint8(0x20),
		371:  uint8(0x2e),
		372:  uint8(0x24),
		373:  uint8(0x21),
		374:  uint8(0x2a),
		375:  uint8(0x27),
		376:  uint8(0x21),
		377:  uint8(0x26),
		378:  uint8(0x2d),
		379:  uint8(0x20),
		380:  uint8(0x2b),
		381:  uint8(0x28),
		382:  uint8(0x26),
		383:  uint8(0x2d),
		384:  uint8(0x1c),
		385:  uint8(0x1a),
		386:  uint8(0x11),
		387:  uint8(0x1f),
		388:  uint8(0x1a),
		389:  uint8(0x14),
		390:  uint8(0x1f),
		391:  uint8(0x12),
		392:  uint8(0x19),
		393:  uint8(0x17),
		394:  uint8(0x12),
		395:  uint8(0x1c),
		396:  uint8(0x16),
		397:  uint8(0x19),
		398:  uint8(0x18),
		399:  uint8(0x15),
		400:  uint8(0x10),
		401:  uint8(0x16),
		402:  uint8(0x1d),
		403:  uint8(0x11),
		404:  uint8(0x13),
		405:  uint8(0x1d),
		406:  uint8(0x14),
		407:  uint8(0x1e),
		408:  uint8(0x1e),
		409:  uint8(0x10),
		410:  uint8(0x17),
		411:  uint8(0x1b),
		412:  uint8(0x15),
		413:  uint8(0x13),
		414:  uint8(0x1b),
		415:  uint8(0x18),
		416:  uint8(0x19),
		417:  uint8(0x14),
		418:  uint8(0x1e),
		419:  uint8(0x13),
		420:  uint8(0x1f),
		421:  uint8(0x12),
		422:  uint8(0x15),
		423:  uint8(0x1c),
		424:  uint8(0x12),
		425:  uint8(0x19),
		426:  uint8(0x18),
		427:  uint8(0x15),
		428:  uint8(0x1c),
		429:  uint8(0x1f),
		430:  uint8(0x13),
		431:  uint8(0x1a),
		432:  uint8(0x17),
		433:  uint8(0x1b),
		434:  uint8(0x10),
		435:  uint8(0x1e),
		436:  uint8(0x14),
		437:  uint8(0x11),
		438:  uint8(0x1a),
		439:  uint8(0x17),
		440:  uint8(0x11),
		441:  uint8(0x16),
		442:  uint8(0x1d),
		443:  uint8(0x10),
		444:  uint8(0x1b),
		445:  uint8(0x18),
		446:  uint8(0x16),
		447:  uint8(0x1d),
		448:  uint8(0xcc),
		449:  uint8(0xca),
		450:  uint8(0xc1),
		451:  uint8(0xcf),
		452:  uint8(0xca),
		453:  uint8(0xc4),
		454:  uint8(0xcf),
		455:  uint8(0xc2),
		456:  uint8(0xc9),
		457:  uint8(0xc7),
		458:  uint8(0xc2),
		459:  uint8(0xcc),
		460:  uint8(0xc6),
		461:  uint8(0xc9),
		462:  uint8(0xc8),
		463:  uint8(0xc5),
		464:  uint8(0xc0),
		465:  uint8(0xc6),
		466:  uint8(0xcd),
		467:  uint8(0xc1),
		468:  uint8(0xc3),
		469:  uint8(0xcd),
		470:  uint8(0xc4),
		471:  uint8(0xce),
		472:  uint8(0xce),
		473:  uint8(0xc0),
		474:  uint8(0xc7),
		475:  uint8(0xcb),
		476:  uint8(0xc5),
		477:  uint8(0xc3),
		478:  uint8(0xcb),
		479:  uint8(0xc8),
		480:  uint8(0xc9),
		481:  uint8(0xc4),
		482:  uint8(0xce),
		483:  uint8(0xc3),
		484:  uint8(0xcf),
		485:  uint8(0xc2),
		486:  uint8(0xc5),
		487:  uint8(0xcc),
		488:  uint8(0xc2),
		489:  uint8(0xc9),
		490:  uint8(0xc8),
		491:  uint8(0xc5),
		492:  uint8(0xcc),
		493:  uint8(0xcf),
		494:  uint8(0xc3),
		495:  uint8(0xca),
		496:  uint8(0xc7),
		497:  uint8(0xcb),
		498:  uint8(0xc0),
		499:  uint8(0xce),
		500:  uint8(0xc4),
		501:  uint8(0xc1),
		502:  uint8(0xca),
		503:  uint8(0xc7),
		504:  uint8(0xc1),
		505:  uint8(0xc6),
		506:  uint8(0xcd),
		507:  uint8(0xc0),
		508:  uint8(0xcb),
		509:  uint8(0xc8),
		510:  uint8(0xc6),
		511:  uint8(0xcd),
		512:  uint8(0x7c),
		513:  uint8(0x7a),
		514:  uint8(0x71),
		515:  uint8(0x7f),
		516:  uint8(0x7a),
		517:  uint8(0x74),
		518:  uint8(0x7f),
		519:  uint8(0x72),
		520:  uint8(0x79),
		521:  uint8(0x77),
		522:  uint8(0x72),
		523:  uint8(0x7c),
		524:  uint8(0x76),
		525:  uint8(0x79),
		526:  uint8(0x78),
		527:  uint8(0x75),
		528:  uint8(0x70),
		529:  uint8(0x76),
		530:  uint8(0x7d),
		531:  uint8(0x71),
		532:  uint8(0x73),
		533:  uint8(0x7d),
		534:  uint8(0x74),
		535:  uint8(0x7e),
		536:  uint8(0x7e),
		537:  uint8(0x70),
		538:  uint8(0x77),
		539:  uint8(0x7b),
		540:  uint8(0x75),
		541:  uint8(0x73),
		542:  uint8(0x7b),
		543:  uint8(0x78),
		544:  uint8(0x79),
		545:  uint8(0x74),
		546:  uint8(0x7e),
		547:  uint8(0x73),
		548:  uint8(0x7f),
		549:  uint8(0x72),
		550:  uint8(0x75),
		551:  uint8(0x7c),
		552:  uint8(0x72),
		553:  uint8(0x79),
		554:  uint8(0x78),
		555:  uint8(0x75),
		556:  uint8(0x7c),
		557:  uint8(0x7f),
		558:  uint8(0x73),
		559:  uint8(0x7a),
		560:  uint8(0x77),
		561:  uint8(0x7b),
		562:  uint8(0x70),
		563:  uint8(0x7e),
		564:  uint8(0x74),
		565:  uint8(0x71),
		566:  uint8(0x7a),
		567:  uint8(0x77),
		568:  uint8(0x71),
		569:  uint8(0x76),
		570:  uint8(0x7d),
		571:  uint8(0x70),
		572:  uint8(0x7b),
		573:  uint8(0x78),
		574:  uint8(0x76),
		575:  uint8(0x7d),
		576:  uint8(0x4c),
		577:  uint8(0x4a),
		578:  uint8(0x41),
		579:  uint8(0x4f),
		580:  uint8(0x4a),
		581:  uint8(0x44),
		582:  uint8(0x4f),
		583:  uint8(0x42),
		584:  uint8(0x49),
		585:  uint8(0x47),
		586:  uint8(0x42),
		587:  uint8(0x4c),
		588:  uint8(0x46),
		589:  uint8(0x49),
		590:  uint8(0x48),
		591:  uint8(0x45),
		592:  uint8(0x40),
		593:  uint8(0x46),
		594:  uint8(0x4d),
		595:  uint8(0x41),
		596:  uint8(0x43),
		597:  uint8(0x4d),
		598:  uint8(0x44),
		599:  uint8(0x4e),
		600:  uint8(0x4e),
		601:  uint8(0x40),
		602:  uint8(0x47),
		603:  uint8(0x4b),
		604:  uint8(0x45),
		605:  uint8(0x43),
		606:  uint8(0x4b),
		607:  uint8(0x48),
		608:  uint8(0x49),
		609:  uint8(0x44),
		610:  uint8(0x4e),
		611:  uint8(0x43),
		612:  uint8(0x4f),
		613:  uint8(0x42),
		614:  uint8(0x45),
		615:  uint8(0x4c),
		616:  uint8(0x42),
		617:  uint8(0x49),
		618:  uint8(0x48),
		619:  uint8(0x45),
		620:  uint8(0x4c),
		621:  uint8(0x4f),
		622:  uint8(0x43),
		623:  uint8(0x4a),
		624:  uint8(0x47),
		625:  uint8(0x4b),
		626:  uint8(0x40),
		627:  uint8(0x4e),
		628:  uint8(0x44),
		629:  uint8(0x41),
		630:  uint8(0x4a),
		631:  uint8(0x47),
		632:  uint8(0x41),
		633:  uint8(0x46),
		634:  uint8(0x4d),
		635:  uint8(0x40),
		636:  uint8(0x4b),
		637:  uint8(0x48),
		638:  uint8(0x46),
		639:  uint8(0x4d),
		640:  uint8(0xac),
		641:  uint8(0xaa),
		642:  uint8(0xa1),
		643:  uint8(0xaf),
		644:  uint8(0xaa),
		645:  uint8(0xa4),
		646:  uint8(0xaf),
		647:  uint8(0xa2),
		648:  uint8(0xa9),
		649:  uint8(0xa7),
		650:  uint8(0xa2),
		651:  uint8(0xac),
		652:  uint8(0xa6),
		653:  uint8(0xa9),
		654:  uint8(0xa8),
		655:  uint8(0xa5),
		656:  uint8(0xa0),
		657:  uint8(0xa6),
		658:  uint8(0xad),
		659:  uint8(0xa1),
		660:  uint8(0xa3),
		661:  uint8(0xad),
		662:  uint8(0xa4),
		663:  uint8(0xae),
		664:  uint8(0xae),
		665:  uint8(0xa0),
		666:  uint8(0xa7),
		667:  uint8(0xab),
		668:  uint8(0xa5),
		669:  uint8(0xa3),
		670:  uint8(0xab),
		671:  uint8(0xa8),
		672:  uint8(0xa9),
		673:  uint8(0xa4),
		674:  uint8(0xae),
		675:  uint8(0xa3),
		676:  uint8(0xaf),
		677:  uint8(0xa2),
		678:  uint8(0xa5),
		679:  uint8(0xac),
		680:  uint8(0xa2),
		681:  uint8(0xa9),
		682:  uint8(0xa8),
		683:  uint8(0xa5),
		684:  uint8(0xac),
		685:  uint8(0xaf),
		686:  uint8(0xa3),
		687:  uint8(0xaa),
		688:  uint8(0xa7),
		689:  uint8(0xab),
		690:  uint8(0xa0),
		691:  uint8(0xae),
		692:  uint8(0xa4),
		693:  uint8(0xa1),
		694:  uint8(0xaa),
		695:  uint8(0xa7),
		696:  uint8(0xa1),
		697:  uint8(0xa6),
		698:  uint8(0xad),
		699:  uint8(0xa0),
		700:  uint8(0xab),
		701:  uint8(0xa8),
		702:  uint8(0xa6),
		703:  uint8(0xad),
		704:  uint8(0x7c),
		705:  uint8(0x7a),
		706:  uint8(0x71),
		707:  uint8(0x7f),
		708:  uint8(0x7a),
		709:  uint8(0x74),
		710:  uint8(0x7f),
		711:  uint8(0x72),
		712:  uint8(0x79),
		713:  uint8(0x77),
		714:  uint8(0x72),
		715:  uint8(0x7c),
		716:  uint8(0x76),
		717:  uint8(0x79),
		718:  uint8(0x78),
		719:  uint8(0x75),
		720:  uint8(0x70),
		721:  uint8(0x76),
		722:  uint8(0x7d),
		723:  uint8(0x71),
		724:  uint8(0x73),
		725:  uint8(0x7d),
		726:  uint8(0x74),
		727:  uint8(0x7e),
		728:  uint8(0x7e),
		729:  uint8(0x70),
		730:  uint8(0x77),
		731:  uint8(0x7b),
		732:  uint8(0x75),
		733:  uint8(0x73),
		734:  uint8(0x7b),
		735:  uint8(0x78),
		736:  uint8(0x79),
		737:  uint8(0x74),
		738:  uint8(0x7e),
		739:  uint8(0x73),
		740:  uint8(0x7f),
		741:  uint8(0x72),
		742:  uint8(0x75),
		743:  uint8(0x7c),
		744:  uint8(0x72),
		745:  uint8(0x79),
		746:  uint8(0x78),
		747:  uint8(0x75),
		748:  uint8(0x7c),
		749:  uint8(0x7f),
		750:  uint8(0x73),
		751:  uint8(0x7a),
		752:  uint8(0x77),
		753:  uint8(0x7b),
		754:  uint8(0x70),
		755:  uint8(0x7e),
		756:  uint8(0x74),
		757:  uint8(0x71),
		758:  uint8(0x7a),
		759:  uint8(0x77),
		760:  uint8(0x71),
		761:  uint8(0x76),
		762:  uint8(0x7d),
		763:  uint8(0x70),
		764:  uint8(0x7b),
		765:  uint8(0x78),
		766:  uint8(0x76),
		767:  uint8(0x7d),
		768:  uint8(0xbc),
		769:  uint8(0xba),
		770:  uint8(0xb1),
		771:  uint8(0xbf),
		772:  uint8(0xba),
		773:  uint8(0xb4),
		774:  uint8(0xbf),
		775:  uint8(0xb2),
		776:  uint8(0xb9),
		777:  uint8(0xb7),
		778:  uint8(0xb2),
		779:  uint8(0xbc),
		780:  uint8(0xb6),
		781:  uint8(0xb9),
		782:  uint8(0xb8),
		783:  uint8(0xb5),
		784:  uint8(0xb0),
		785:  uint8(0xb6),
		786:  uint8(0xbd),
		787:  uint8(0xb1),
		788:  uint8(0xb3),
		789:  uint8(0xbd),
		790:  uint8(0xb4),
		791:  uint8(0xbe),
		792:  uint8(0xbe),
		793:  uint8(0xb0),
		794:  uint8(0xb7),
		795:  uint8(0xbb),
		796:  uint8(0xb5),
		797:  uint8(0xb3),
		798:  uint8(0xbb),
		799:  uint8(0xb8),
		800:  uint8(0xb9),
		801:  uint8(0xb4),
		802:  uint8(0xbe),
		803:  uint8(0xb3),
		804:  uint8(0xbf),
		805:  uint8(0xb2),
		806:  uint8(0xb5),
		807:  uint8(0xbc),
		808:  uint8(0xb2),
		809:  uint8(0xb9),
		810:  uint8(0xb8),
		811:  uint8(0xb5),
		812:  uint8(0xbc),
		813:  uint8(0xbf),
		814:  uint8(0xb3),
		815:  uint8(0xba),
		816:  uint8(0xb7),
		817:  uint8(0xbb),
		818:  uint8(0xb0),
		819:  uint8(0xbe),
		820:  uint8(0xb4),
		821:  uint8(0xb1),
		822:  uint8(0xba),
		823:  uint8(0xb7),
		824:  uint8(0xb1),
		825:  uint8(0xb6),
		826:  uint8(0xbd),
		827:  uint8(0xb0),
		828:  uint8(0xbb),
		829:  uint8(0xb8),
		830:  uint8(0xb6),
		831:  uint8(0xbd),
		832:  uint8(0xdc),
		833:  uint8(0xda),
		834:  uint8(0xd1),
		835:  uint8(0xdf),
		836:  uint8(0xda),
		837:  uint8(0xd4),
		838:  uint8(0xdf),
		839:  uint8(0xd2),
		840:  uint8(0xd9),
		841:  uint8(0xd7),
		842:  uint8(0xd2),
		843:  uint8(0xdc),
		844:  uint8(0xd6),
		845:  uint8(0xd9),
		846:  uint8(0xd8),
		847:  uint8(0xd5),
		848:  uint8(0xd0),
		849:  uint8(0xd6),
		850:  uint8(0xdd),
		851:  uint8(0xd1),
		852:  uint8(0xd3),
		853:  uint8(0xdd),
		854:  uint8(0xd4),
		855:  uint8(0xde),
		856:  uint8(0xde),
		857:  uint8(0xd0),
		858:  uint8(0xd7),
		859:  uint8(0xdb),
		860:  uint8(0xd5),
		861:  uint8(0xd3),
		862:  uint8(0xdb),
		863:  uint8(0xd8),
		864:  uint8(0xd9),
		865:  uint8(0xd4),
		866:  uint8(0xde),
		867:  uint8(0xd3),
		868:  uint8(0xdf),
		869:  uint8(0xd2),
		870:  uint8(0xd5),
		871:  uint8(0xdc),
		872:  uint8(0xd2),
		873:  uint8(0xd9),
		874:  uint8(0xd8),
		875:  uint8(0xd5),
		876:  uint8(0xdc),
		877:  uint8(0xdf),
		878:  uint8(0xd3),
		879:  uint8(0xda),
		880:  uint8(0xd7),
		881:  uint8(0xdb),
		882:  uint8(0xd0),
		883:  uint8(0xde),
		884:  uint8(0xd4),
		885:  uint8(0xd1),
		886:  uint8(0xda),
		887:  uint8(0xd7),
		888:  uint8(0xd1),
		889:  uint8(0xd6),
		890:  uint8(0xdd),
		891:  uint8(0xd0),
		892:  uint8(0xdb),
		893:  uint8(0xd8),
		894:  uint8(0xd6),
		895:  uint8(0xdd),
		896:  uint8(0x6c),
		897:  uint8(0x6a),
		898:  uint8(0x61),
		899:  uint8(0x6f),
		900:  uint8(0x6a),
		901:  uint8(0x64),
		902:  uint8(0x6f),
		903:  uint8(0x62),
		904:  uint8(0x69),
		905:  uint8(0x67),
		906:  uint8(0x62),
		907:  uint8(0x6c),
		908:  uint8(0x66),
		909:  uint8(0x69),
		910:  uint8(0x68),
		911:  uint8(0x65),
		912:  uint8(0x60),
		913:  uint8(0x66),
		914:  uint8(0x6d),
		915:  uint8(0x61),
		916:  uint8(0x63),
		917:  uint8(0x6d),
		918:  uint8(0x64),
		919:  uint8(0x6e),
		920:  uint8(0x6e),
		921:  uint8(0x60),
		922:  uint8(0x67),
		923:  uint8(0x6b),
		924:  uint8(0x65),
		925:  uint8(0x63),
		926:  uint8(0x6b),
		927:  uint8(0x68),
		928:  uint8(0x69),
		929:  uint8(0x64),
		930:  uint8(0x6e),
		931:  uint8(0x63),
		932:  uint8(0x6f),
		933:  uint8(0x62),
		934:  uint8(0x65),
		935:  uint8(0x6c),
		936:  uint8(0x62),
		937:  uint8(0x69),
		938:  uint8(0x68),
		939:  uint8(0x65),
		940:  uint8(0x6c),
		941:  uint8(0x6f),
		942:  uint8(0x63),
		943:  uint8(0x6a),
		944:  uint8(0x67),
		945:  uint8(0x6b),
		946:  uint8(0x60),
		947:  uint8(0x6e),
		948:  uint8(0x64),
		949:  uint8(0x61),
		950:  uint8(0x6a),
		951:  uint8(0x67),
		952:  uint8(0x61),
		953:  uint8(0x66),
		954:  uint8(0x6d),
		955:  uint8(0x60),
		956:  uint8(0x6b),
		957:  uint8(0x68),
		958:  uint8(0x66),
		959:  uint8(0x6d),
		960:  uint8(0x1c),
		961:  uint8(0x1a),
		962:  uint8(0x11),
		963:  uint8(0x1f),
		964:  uint8(0x1a),
		965:  uint8(0x14),
		966:  uint8(0x1f),
		967:  uint8(0x12),
		968:  uint8(0x19),
		969:  uint8(0x17),
		970:  uint8(0x12),
		971:  uint8(0x1c),
		972:  uint8(0x16),
		973:  uint8(0x19),
		974:  uint8(0x18),
		975:  uint8(0x15),
		976:  uint8(0x10),
		977:  uint8(0x16),
		978:  uint8(0x1d),
		979:  uint8(0x11),
		980:  uint8(0x13),
		981:  uint8(0x1d),
		982:  uint8(0x14),
		983:  uint8(0x1e),
		984:  uint8(0x1e),
		985:  uint8(0x10),
		986:  uint8(0x17),
		987:  uint8(0x1b),
		988:  uint8(0x15),
		989:  uint8(0x13),
		990:  uint8(0x1b),
		991:  uint8(0x18),
		992:  uint8(0x19),
		993:  uint8(0x14),
		994:  uint8(0x1e),
		995:  uint8(0x13),
		996:  uint8(0x1f),
		997:  uint8(0x12),
		998:  uint8(0x15),
		999:  uint8(0x1c),
		1000: uint8(0x12),
		1001: uint8(0x19),
		1002: uint8(0x18),
		1003: uint8(0x15),
		1004: uint8(0x1c),
		1005: uint8(0x1f),
		1006: uint8(0x13),
		1007: uint8(0x1a),
		1008: uint8(0x17),
		1009: uint8(0x1b),
		1010: uint8(0x10),
		1011: uint8(0x1e),
		1012: uint8(0x14),
		1013: uint8(0x11),
		1014: uint8(0x1a),
		1015: uint8(0x17),
		1016: uint8(0x11),
		1017: uint8(0x16),
		1018: uint8(0x1d),
		1019: uint8(0x10),
		1020: uint8(0x1b),
		1021: uint8(0x18),
		1022: uint8(0x16),
		1023: uint8(0x1d),
		1024: uint8(0x8c),
		1025: uint8(0x8a),
		1026: uint8(0x81),
		1027: uint8(0x8f),
		1028: uint8(0x8a),
		1029: uint8(0x84),
		1030: uint8(0x8f),
		1031: uint8(0x82),
		1032: uint8(0x89),
		1033: uint8(0x87),
		1034: uint8(0x82),
		1035: uint8(0x8c),
		1036: uint8(0x86),
		1037: uint8(0x89),
		1038: uint8(0x88),
		1039: uint8(0x85),
		1040: uint8(0x80),
		1041: uint8(0x86),
		1042: uint8(0x8d),
		1043: uint8(0x81),
		1044: uint8(0x83),
		1045: uint8(0x8d),
		1046: uint8(0x84),
		1047: uint8(0x8e),
		1048: uint8(0x8e),
		1049: uint8(0x80),
		1050: uint8(0x87),
		1051: uint8(0x8b),
		1052: uint8(0x85),
		1053: uint8(0x83),
		1054: uint8(0x8b),
		1055: uint8(0x88),
		1056: uint8(0x89),
		1057: uint8(0x84),
		1058: uint8(0x8e),
		1059: uint8(0x83),
		1060: uint8(0x8f),
		1061: uint8(0x82),
		1062: uint8(0x85),
		1063: uint8(0x8c),
		1064: uint8(0x82),
		1065: uint8(0x89),
		1066: uint8(0x88),
		1067: uint8(0x85),
		1068: uint8(0x8c),
		1069: uint8(0x8f),
		1070: uint8(0x83),
		1071: uint8(0x8a),
		1072: uint8(0x87),
		1073: uint8(0x8b),
		1074: uint8(0x80),
		1075: uint8(0x8e),
		1076: uint8(0x84),
		1077: uint8(0x81),
		1078: uint8(0x8a),
		1079: uint8(0x87),
		1080: uint8(0x81),
		1081: uint8(0x86),
		1082: uint8(0x8d),
		1083: uint8(0x80),
		1084: uint8(0x8b),
		1085: uint8(0x88),
		1086: uint8(0x86),
		1087: uint8(0x8d),
		1088: uint8(0x5c),
		1089: uint8(0x5a),
		1090: uint8(0x51),
		1091: uint8(0x5f),
		1092: uint8(0x5a),
		1093: uint8(0x54),
		1094: uint8(0x5f),
		1095: uint8(0x52),
		1096: uint8(0x59),
		1097: uint8(0x57),
		1098: uint8(0x52),
		1099: uint8(0x5c),
		1100: uint8(0x56),
		1101: uint8(0x59),
		1102: uint8(0x58),
		1103: uint8(0x55),
		1104: uint8(0x50),
		1105: uint8(0x56),
		1106: uint8(0x5d),
		1107: uint8(0x51),
		1108: uint8(0x53),
		1109: uint8(0x5d),
		1110: uint8(0x54),
		1111: uint8(0x5e),
		1112: uint8(0x5e),
		1113: uint8(0x50),
		1114: uint8(0x57),
		1115: uint8(0x5b),
		1116: uint8(0x55),
		1117: uint8(0x53),
		1118: uint8(0x5b),
		1119: uint8(0x58),
		1120: uint8(0x59),
		1121: uint8(0x54),
		1122: uint8(0x5e),
		1123: uint8(0x53),
		1124: uint8(0x5f),
		1125: uint8(0x52),
		1126: uint8(0x55),
		1127: uint8(0x5c),
		1128: uint8(0x52),
		1129: uint8(0x59),
		1130: uint8(0x58),
		1131: uint8(0x55),
		1132: uint8(0x5c),
		1133: uint8(0x5f),
		1134: uint8(0x53),
		1135: uint8(0x5a),
		1136: uint8(0x57),
		1137: uint8(0x5b),
		1138: uint8(0x50),
		1139: uint8(0x5e),
		1140: uint8(0x54),
		1141: uint8(0x51),
		1142: uint8(0x5a),
		1143: uint8(0x57),
		1144: uint8(0x51),
		1145: uint8(0x56),
		1146: uint8(0x5d),
		1147: uint8(0x50),
		1148: uint8(0x5b),
		1149: uint8(0x58),
		1150: uint8(0x56),
		1151: uint8(0x5d),
		1152: uint8(0x5c),
		1153: uint8(0x5a),
		1154: uint8(0x51),
		1155: uint8(0x5f),
		1156: uint8(0x5a),
		1157: uint8(0x54),
		1158: uint8(0x5f),
		1159: uint8(0x52),
		1160: uint8(0x59),
		1161: uint8(0x57),
		1162: uint8(0x52),
		1163: uint8(0x5c),
		1164: uint8(0x56),
		1165: uint8(0x59),
		1166: uint8(0x58),
		1167: uint8(0x55),
		1168: uint8(0x50),
		1169: uint8(0x56),
		1170: uint8(0x5d),
		1171: uint8(0x51),
		1172: uint8(0x53),
		1173: uint8(0x5d),
		1174: uint8(0x54),
		1175: uint8(0x5e),
		1176: uint8(0x5e),
		1177: uint8(0x50),
		1178: uint8(0x57),
		1179: uint8(0x5b),
		1180: uint8(0x55),
		1181: uint8(0x53),
		1182: uint8(0x5b),
		1183: uint8(0x58),
		1184: uint8(0x59),
		1185: uint8(0x54),
		1186: uint8(0x5e),
		1187: uint8(0x53),
		1188: uint8(0x5f),
		1189: uint8(0x52),
		1190: uint8(0x55),
		1191: uint8(0x5c),
		1192: uint8(0x52),
		1193: uint8(0x59),
		1194: uint8(0x58),
		1195: uint8(0x55),
		1196: uint8(0x5c),
		1197: uint8(0x5f),
		1198: uint8(0x53),
		1199: uint8(0x5a),
		1200: uint8(0x57),
		1201: uint8(0x5b),
		1202: uint8(0x50),
		1203: uint8(0x5e),
		1204: uint8(0x54),
		1205: uint8(0x51),
		1206: uint8(0x5a),
		1207: uint8(0x57),
		1208: uint8(0x51),
		1209: uint8(0x56),
		1210: uint8(0x5d),
		1211: uint8(0x50),
		1212: uint8(0x5b),
		1213: uint8(0x58),
		1214: uint8(0x56),
		1215: uint8(0x5d),
		1216: uint8(0x0c),
		1217: uint8(0x0a),
		1218: uint8(0x01),
		1219: uint8(0x0f),
		1220: uint8(0x0a),
		1221: uint8(0x04),
		1222: uint8(0x0f),
		1223: uint8(0x02),
		1224: uint8(0x09),
		1225: uint8(0x07),
		1226: uint8(0x02),
		1227: uint8(0x0c),
		1228: uint8(0x06),
		1229: uint8(0x09),
		1230: uint8(0x08),
		1231: uint8(0x05),
		1232: uint8(0x00),
		1233: uint8(0x06),
		1234: uint8(0x0d),
		1235: uint8(0x01),
		1236: uint8(0x03),
		1237: uint8(0x0d),
		1238: uint8(0x04),
		1239: uint8(0x0e),
		1240: uint8(0x0e),
		1241: uint8(0x00),
		1242: uint8(0x07),
		1243: uint8(0x0b),
		1244: uint8(0x05),
		1245: uint8(0x03),
		1246: uint8(0x0b),
		1247: uint8(0x08),
		1248: uint8(0x09),
		1249: uint8(0x04),
		1250: uint8(0x0e),
		1251: uint8(0x03),
		1252: uint8(0x0f),
		1253: uint8(0x02),
		1254: uint8(0x05),
		1255: uint8(0x0c),
		1256: uint8(0x02),
		1257: uint8(0x09),
		1258: uint8(0x08),
		1259: uint8(0x05),
		1260: uint8(0x0c),
		1261: uint8(0x0f),
		1262: uint8(0x03),
		1263: uint8(0x0a),
		1264: uint8(0x07),
		1265: uint8(0x0b),
		1266: uint8(0x00),
		1267: uint8(0x0e),
		1268: uint8(0x04),
		1269: uint8(0x01),
		1270: uint8(0x0a),
		1271: uint8(0x07),
		1272: uint8(0x01),
		1273: uint8(0x06),
		1274: uint8(0x0d),
		1275: uint8(0x00),
		1276: uint8(0x0b),
		1277: uint8(0x08),
		1278: uint8(0x06),
		1279: uint8(0x0d),
		1280: uint8(0x3c),
		1281: uint8(0x3a),
		1282: uint8(0x31),
		1283: uint8(0x3f),
		1284: uint8(0x3a),
		1285: uint8(0x34),
		1286: uint8(0x3f),
		1287: uint8(0x32),
		1288: uint8(0x39),
		1289: uint8(0x37),
		1290: uint8(0x32),
		1291: uint8(0x3c),
		1292: uint8(0x36),
		1293: uint8(0x39),
		1294: uint8(0x38),
		1295: uint8(0x35),
		1296: uint8(0x30),
		1297: uint8(0x36),
		1298: uint8(0x3d),
		1299: uint8(0x31),
		1300: uint8(0x33),
		1301: uint8(0x3d),
		1302: uint8(0x34),
		1303: uint8(0x3e),
		1304: uint8(0x3e),
		1305: uint8(0x30),
		1306: uint8(0x37),
		1307: uint8(0x3b),
		1308: uint8(0x35),
		1309: uint8(0x33),
		1310: uint8(0x3b),
		1311: uint8(0x38),
		1312: uint8(0x39),
		1313: uint8(0x34),
		1314: uint8(0x3e),
		1315: uint8(0x33),
		1316: uint8(0x3f),
		1317: uint8(0x32),
		1318: uint8(0x35),
		1319: uint8(0x3c),
		1320: uint8(0x32),
		1321: uint8(0x39),
		1322: uint8(0x38),
		1323: uint8(0x35),
		1324: uint8(0x3c),
		1325: uint8(0x3f),
		1326: uint8(0x33),
		1327: uint8(0x3a),
		1328: uint8(0x37),
		1329: uint8(0x3b),
		1330: uint8(0x30),
		1331: uint8(0x3e),
		1332: uint8(0x34),
		1333: uint8(0x31),
		1334: uint8(0x3a),
		1335: uint8(0x37),
		1336: uint8(0x31),
		1337: uint8(0x36),
		1338: uint8(0x3d),
		1339: uint8(0x30),
		1340: uint8(0x3b),
		1341: uint8(0x38),
		1342: uint8(0x36),
		1343: uint8(0x3d),
		1344: uint8(0xfc),
		1345: uint8(0xfa),
		1346: uint8(0xf1),
		1347: uint8(0xff),
		1348: uint8(0xfa),
		1349: uint8(0xf4),
		1350: uint8(0xff),
		1351: uint8(0xf2),
		1352: uint8(0xf9),
		1353: uint8(0xf7),
		1354: uint8(0xf2),
		1355: uint8(0xfc),
		1356: uint8(0xf6),
		1357: uint8(0xf9),
		1358: uint8(0xf8),
		1359: uint8(0xf5),
		1360: uint8(0xf0),
		1361: uint8(0xf6),
		1362: uint8(0xfd),
		1363: uint8(0xf1),
		1364: uint8(0xf3),
		1365: uint8(0xfd),
		1366: uint8(0xf4),
		1367: uint8(0xfe),
		1368: uint8(0xfe),
		1369: uint8(0xf0),
		1370: uint8(0xf7),
		1371: uint8(0xfb),
		1372: uint8(0xf5),
		1373: uint8(0xf3),
		1374: uint8(0xfb),
		1375: uint8(0xf8),
		1376: uint8(0xf9),
		1377: uint8(0xf4),
		1378: uint8(0xfe),
		1379: uint8(0xf3),
		1380: uint8(0xff),
		1381: uint8(0xf2),
		1382: uint8(0xf5),
		1383: uint8(0xfc),
		1384: uint8(0xf2),
		1385: uint8(0xf9),
		1386: uint8(0xf8),
		1387: uint8(0xf5),
		1388: uint8(0xfc),
		1389: uint8(0xff),
		1390: uint8(0xf3),
		1391: uint8(0xfa),
		1392: uint8(0xf7),
		1393: uint8(0xfb),
		1394: uint8(0xf0),
		1395: uint8(0xfe),
		1396: uint8(0xf4),
		1397: uint8(0xf1),
		1398: uint8(0xfa),
		1399: uint8(0xf7),
		1400: uint8(0xf1),
		1401: uint8(0xf6),
		1402: uint8(0xfd),
		1403: uint8(0xf0),
		1404: uint8(0xfb),
		1405: uint8(0xf8),
		1406: uint8(0xf6),
		1407: uint8(0xfd),
		1408: uint8(0xfc),
		1409: uint8(0xfa),
		1410: uint8(0xf1),
		1411: uint8(0xff),
		1412: uint8(0xfa),
		1413: uint8(0xf4),
		1414: uint8(0xff),
		1415: uint8(0xf2),
		1416: uint8(0xf9),
		1417: uint8(0xf7),
		1418: uint8(0xf2),
		1419: uint8(0xfc),
		1420: uint8(0xf6),
		1421: uint8(0xf9),
		1422: uint8(0xf8),
		1423: uint8(0xf5),
		1424: uint8(0xf0),
		1425: uint8(0xf6),
		1426: uint8(0xfd),
		1427: uint8(0xf1),
		1428: uint8(0xf3),
		1429: uint8(0xfd),
		1430: uint8(0xf4),
		1431: uint8(0xfe),
		1432: uint8(0xfe),
		1433: uint8(0xf0),
		1434: uint8(0xf7),
		1435: uint8(0xfb),
		1436: uint8(0xf5),
		1437: uint8(0xf3),
		1438: uint8(0xfb),
		1439: uint8(0xf8),
		1440: uint8(0xf9),
		1441: uint8(0xf4),
		1442: uint8(0xfe),
		1443: uint8(0xf3),
		1444: uint8(0xff),
		1445: uint8(0xf2),
		1446: uint8(0xf5),
		1447: uint8(0xfc),
		1448: uint8(0xf2),
		1449: uint8(0xf9),
		1450: uint8(0xf8),
		1451: uint8(0xf5),
		1452: uint8(0xfc),
		1453: uint8(0xff),
		1454: uint8(0xf3),
		1455: uint8(0xfa),
		1456: uint8(0xf7),
		1457: uint8(0xfb),
		1458: uint8(0xf0),
		1459: uint8(0xfe),
		1460: uint8(0xf4),
		1461: uint8(0xf1),
		1462: uint8(0xfa),
		1463: uint8(0xf7),
		1464: uint8(0xf1),
		1465: uint8(0xf6),
		1466: uint8(0xfd),
		1467: uint8(0xf0),
		1468: uint8(0xfb),
		1469: uint8(0xf8),
		1470: uint8(0xf6),
		1471: uint8(0xfd),
		1472: uint8(0xac),
		1473: uint8(0xaa),
		1474: uint8(0xa1),
		1475: uint8(0xaf),
		1476: uint8(0xaa),
		1477: uint8(0xa4),
		1478: uint8(0xaf),
		1479: uint8(0xa2),
		1480: uint8(0xa9),
		1481: uint8(0xa7),
		1482: uint8(0xa2),
		1483: uint8(0xac),
		1484: uint8(0xa6),
		1485: uint8(0xa9),
		1486: uint8(0xa8),
		1487: uint8(0xa5),
		1488: uint8(0xa0),
		1489: uint8(0xa6),
		1490: uint8(0xad),
		1491: uint8(0xa1),
		1492: uint8(0xa3),
		1493: uint8(0xad),
		1494: uint8(0xa4),
		1495: uint8(0xae),
		1496: uint8(0xae),
		1497: uint8(0xa0),
		1498: uint8(0xa7),
		1499: uint8(0xab),
		1500: uint8(0xa5),
		1501: uint8(0xa3),
		1502: uint8(0xab),
		1503: uint8(0xa8),
		1504: uint8(0xa9),
		1505: uint8(0xa4),
		1506: uint8(0xae),
		1507: uint8(0xa3),
		1508: uint8(0xaf),
		1509: uint8(0xa2),
		1510: uint8(0xa5),
		1511: uint8(0xac),
		1512: uint8(0xa2),
		1513: uint8(0xa9),
		1514: uint8(0xa8),
		1515: uint8(0xa5),
		1516: uint8(0xac),
		1517: uint8(0xaf),
		1518: uint8(0xa3),
		1519: uint8(0xaa),
		1520: uint8(0xa7),
		1521: uint8(0xab),
		1522: uint8(0xa0),
		1523: uint8(0xae),
		1524: uint8(0xa4),
		1525: uint8(0xa1),
		1526: uint8(0xaa),
		1527: uint8(0xa7),
		1528: uint8(0xa1),
		1529: uint8(0xa6),
		1530: uint8(0xad),
		1531: uint8(0xa0),
		1532: uint8(0xab),
		1533: uint8(0xa8),
		1534: uint8(0xa6),
		1535: uint8(0xad),
		1536: uint8(0xdc),
		1537: uint8(0xda),
		1538: uint8(0xd1),
		1539: uint8(0xdf),
		1540: uint8(0xda),
		1541: uint8(0xd4),
		1542: uint8(0xdf),
		1543: uint8(0xd2),
		1544: uint8(0xd9),
		1545: uint8(0xd7),
		1546: uint8(0xd2),
		1547: uint8(0xdc),
		1548: uint8(0xd6),
		1549: uint8(0xd9),
		1550: uint8(0xd8),
		1551: uint8(0xd5),
		1552: uint8(0xd0),
		1553: uint8(0xd6),
		1554: uint8(0xdd),
		1555: uint8(0xd1),
		1556: uint8(0xd3),
		1557: uint8(0xdd),
		1558: uint8(0xd4),
		1559: uint8(0xde),
		1560: uint8(0xde),
		1561: uint8(0xd0),
		1562: uint8(0xd7),
		1563: uint8(0xdb),
		1564: uint8(0xd5),
		1565: uint8(0xd3),
		1566: uint8(0xdb),
		1567: uint8(0xd8),
		1568: uint8(0xd9),
		1569: uint8(0xd4),
		1570: uint8(0xde),
		1571: uint8(0xd3),
		1572: uint8(0xdf),
		1573: uint8(0xd2),
		1574: uint8(0xd5),
		1575: uint8(0xdc),
		1576: uint8(0xd2),
		1577: uint8(0xd9),
		1578: uint8(0xd8),
		1579: uint8(0xd5),
		1580: uint8(0xdc),
		1581: uint8(0xdf),
		1582: uint8(0xd3),
		1583: uint8(0xda),
		1584: uint8(0xd7),
		1585: uint8(0xdb),
		1586: uint8(0xd0),
		1587: uint8(0xde),
		1588: uint8(0xd4),
		1589: uint8(0xd1),
		1590: uint8(0xda),
		1591: uint8(0xd7),
		1592: uint8(0xd1),
		1593: uint8(0xd6),
		1594: uint8(0xdd),
		1595: uint8(0xd0),
		1596: uint8(0xdb),
		1597: uint8(0xd8),
		1598: uint8(0xd6),
		1599: uint8(0xdd),
		1600: uint8(0x3c),
		1601: uint8(0x3a),
		1602: uint8(0x31),
		1603: uint8(0x3f),
		1604: uint8(0x3a),
		1605: uint8(0x34),
		1606: uint8(0x3f),
		1607: uint8(0x32),
		1608: uint8(0x39),
		1609: uint8(0x37),
		1610: uint8(0x32),
		1611: uint8(0x3c),
		1612: uint8(0x36),
		1613: uint8(0x39),
		1614: uint8(0x38),
		1615: uint8(0x35),
		1616: uint8(0x30),
		1617: uint8(0x36),
		1618: uint8(0x3d),
		1619: uint8(0x31),
		1620: uint8(0x33),
		1621: uint8(0x3d),
		1622: uint8(0x34),
		1623: uint8(0x3e),
		1624: uint8(0x3e),
		1625: uint8(0x30),
		1626: uint8(0x37),
		1627: uint8(0x3b),
		1628: uint8(0x35),
		1629: uint8(0x33),
		1630: uint8(0x3b),
		1631: uint8(0x38),
		1632: uint8(0x39),
		1633: uint8(0x34),
		1634: uint8(0x3e),
		1635: uint8(0x33),
		1636: uint8(0x3f),
		1637: uint8(0x32),
		1638: uint8(0x35),
		1639: uint8(0x3c),
		1640: uint8(0x32),
		1641: uint8(0x39),
		1642: uint8(0x38),
		1643: uint8(0x35),
		1644: uint8(0x3c),
		1645: uint8(0x3f),
		1646: uint8(0x33),
		1647: uint8(0x3a),
		1648: uint8(0x37),
		1649: uint8(0x3b),
		1650: uint8(0x30),
		1651: uint8(0x3e),
		1652: uint8(0x34),
		1653: uint8(0x31),
		1654: uint8(0x3a),
		1655: uint8(0x37),
		1656: uint8(0x31),
		1657: uint8(0x36),
		1658: uint8(0x3d),
		1659: uint8(0x30),
		1660: uint8(0x3b),
		1661: uint8(0x38),
		1662: uint8(0x36),
		1663: uint8(0x3d),
		1664: uint8(0x0c),
		1665: uint8(0x0a),
		1666: uint8(0x01),
		1667: uint8(0x0f),
		1668: uint8(0x0a),
		1669: uint8(0x04),
		1670: uint8(0x0f),
		1671: uint8(0x02),
		1672: uint8(0x09),
		1673: uint8(0x07),
		1674: uint8(0x02),
		1675: uint8(0x0c),
		1676: uint8(0x06),
		1677: uint8(0x09),
		1678: uint8(0x08),
		1679: uint8(0x05),
		1680: uint8(0x00),
		1681: uint8(0x06),
		1682: uint8(0x0d),
		1683: uint8(0x01),
		1684: uint8(0x03),
		1685: uint8(0x0d),
		1686: uint8(0x04),
		1687: uint8(0x0e),
		1688: uint8(0x0e),
		1689: uint8(0x00),
		1690: uint8(0x07),
		1691: uint8(0x0b),
		1692: uint8(0x05),
		1693: uint8(0x03),
		1694: uint8(0x0b),
		1695: uint8(0x08),
		1696: uint8(0x09),
		1697: uint8(0x04),
		1698: uint8(0x0e),
		1699: uint8(0x03),
		1700: uint8(0x0f),
		1701: uint8(0x02),
		1702: uint8(0x05),
		1703: uint8(0x0c),
		1704: uint8(0x02),
		1705: uint8(0x09),
		1706: uint8(0x08),
		1707: uint8(0x05),
		1708: uint8(0x0c),
		1709: uint8(0x0f),
		1710: uint8(0x03),
		1711: uint8(0x0a),
		1712: uint8(0x07),
		1713: uint8(0x0b),
		1714: uint8(0x00),
		1715: uint8(0x0e),
		1716: uint8(0x04),
		1717: uint8(0x01),
		1718: uint8(0x0a),
		1719: uint8(0x07),
		1720: uint8(0x01),
		1721: uint8(0x06),
		1722: uint8(0x0d),
		1723: uint8(0x00),
		1724: uint8(0x0b),
		1725: uint8(0x08),
		1726: uint8(0x06),
		1727: uint8(0x0d),
		1728: uint8(0x9c),
		1729: uint8(0x9a),
		1730: uint8(0x91),
		1731: uint8(0x9f),
		1732: uint8(0x9a),
		1733: uint8(0x94),
		1734: uint8(0x9f),
		1735: uint8(0x92),
		1736: uint8(0x99),
		1737: uint8(0x97),
		1738: uint8(0x92),
		1739: uint8(0x9c),
		1740: uint8(0x96),
		1741: uint8(0x99),
		1742: uint8(0x98),
		1743: uint8(0x95),
		1744: uint8(0x90),
		1745: uint8(0x96),
		1746: uint8(0x9d),
		1747: uint8(0x91),
		1748: uint8(0x93),
		1749: uint8(0x9d),
		1750: uint8(0x94),
		1751: uint8(0x9e),
		1752: uint8(0x9e),
		1753: uint8(0x90),
		1754: uint8(0x97),
		1755: uint8(0x9b),
		1756: uint8(0x95),
		1757: uint8(0x93),
		1758: uint8(0x9b),
		1759: uint8(0x98),
		1760: uint8(0x99),
		1761: uint8(0x94),
		1762: uint8(0x9e),
		1763: uint8(0x93),
		1764: uint8(0x9f),
		1765: uint8(0x92),
		1766: uint8(0x95),
		1767: uint8(0x9c),
		1768: uint8(0x92),
		1769: uint8(0x99),
		1770: uint8(0x98),
		1771: uint8(0x95),
		1772: uint8(0x9c),
		1773: uint8(0x9f),
		1774: uint8(0x93),
		1775: uint8(0x9a),
		1776: uint8(0x97),
		1777: uint8(0x9b),
		1778: uint8(0x90),
		1779: uint8(0x9e),
		1780: uint8(0x94),
		1781: uint8(0x91),
		1782: uint8(0x9a),
		1783: uint8(0x97),
		1784: uint8(0x91),
		1785: uint8(0x96),
		1786: uint8(0x9d),
		1787: uint8(0x90),
		1788: uint8(0x9b),
		1789: uint8(0x98),
		1790: uint8(0x96),
		1791: uint8(0x9d),
		1792: uint8(0xec),
		1793: uint8(0xea),
		1794: uint8(0xe1),
		1795: uint8(0xef),
		1796: uint8(0xea),
		1797: uint8(0xe4),
		1798: uint8(0xef),
		1799: uint8(0xe2),
		1800: uint8(0xe9),
		1801: uint8(0xe7),
		1802: uint8(0xe2),
		1803: uint8(0xec),
		1804: uint8(0xe6),
		1805: uint8(0xe9),
		1806: uint8(0xe8),
		1807: uint8(0xe5),
		1808: uint8(0xe0),
		1809: uint8(0xe6),
		1810: uint8(0xed),
		1811: uint8(0xe1),
		1812: uint8(0xe3),
		1813: uint8(0xed),
		1814: uint8(0xe4),
		1815: uint8(0xee),
		1816: uint8(0xee),
		1817: uint8(0xe0),
		1818: uint8(0xe7),
		1819: uint8(0xeb),
		1820: uint8(0xe5),
		1821: uint8(0xe3),
		1822: uint8(0xeb),
		1823: uint8(0xe8),
		1824: uint8(0xe9),
		1825: uint8(0xe4),
		1826: uint8(0xee),
		1827: uint8(0xe3),
		1828: uint8(0xef),
		1829: uint8(0xe2),
		1830: uint8(0xe5),
		1831: uint8(0xec),
		1832: uint8(0xe2),
		1833: uint8(0xe9),
		1834: uint8(0xe8),
		1835: uint8(0xe5),
		1836: uint8(0xec),
		1837: uint8(0xef),
		1838: uint8(0xe3),
		1839: uint8(0xea),
		1840: uint8(0xe7),
		1841: uint8(0xeb),
		1842: uint8(0xe0),
		1843: uint8(0xee),
		1844: uint8(0xe4),
		1845: uint8(0xe1),
		1846: uint8(0xea),
		1847: uint8(0xe7),
		1848: uint8(0xe1),
		1849: uint8(0xe6),
		1850: uint8(0xed),
		1851: uint8(0xe0),
		1852: uint8(0xeb),
		1853: uint8(0xe8),
		1854: uint8(0xe6),
		1855: uint8(0xed),
		1856: uint8(0x8c),
		1857: uint8(0x8a),
		1858: uint8(0x81),
		1859: uint8(0x8f),
		1860: uint8(0x8a),
		1861: uint8(0x84),
		1862: uint8(0x8f),
		1863: uint8(0x82),
		1864: uint8(0x89),
		1865: uint8(0x87),
		1866: uint8(0x82),
		1867: uint8(0x8c),
		1868: uint8(0x86),
		1869: uint8(0x89),
		1870: uint8(0x88),
		1871: uint8(0x85),
		1872: uint8(0x80),
		1873: uint8(0x86),
		1874: uint8(0x8d),
		1875: uint8(0x81),
		1876: uint8(0x83),
		1877: uint8(0x8d),
		1878: uint8(0x84),
		1879: uint8(0x8e),
		1880: uint8(0x8e),
		1881: uint8(0x80),
		1882: uint8(0x87),
		1883: uint8(0x8b),
		1884: uint8(0x85),
		1885: uint8(0x83),
		1886: uint8(0x8b),
		1887: uint8(0x88),
		1888: uint8(0x89),
		1889: uint8(0x84),
		1890: uint8(0x8e),
		1891: uint8(0x83),
		1892: uint8(0x8f),
		1893: uint8(0x82),
		1894: uint8(0x85),
		1895: uint8(0x8c),
		1896: uint8(0x82),
		1897: uint8(0x89),
		1898: uint8(0x88),
		1899: uint8(0x85),
		1900: uint8(0x8c),
		1901: uint8(0x8f),
		1902: uint8(0x83),
		1903: uint8(0x8a),
		1904: uint8(0x87),
		1905: uint8(0x8b),
		1906: uint8(0x80),
		1907: uint8(0x8e),
		1908: uint8(0x84),
		1909: uint8(0x81),
		1910: uint8(0x8a),
		1911: uint8(0x87),
		1912: uint8(0x81),
		1913: uint8(0x86),
		1914: uint8(0x8d),
		1915: uint8(0x80),
		1916: uint8(0x8b),
		1917: uint8(0x88),
		1918: uint8(0x86),
		1919: uint8(0x8d),
		1920: uint8(0x9c),
		1921: uint8(0x9a),
		1922: uint8(0x91),
		1923: uint8(0x9f),
		1924: uint8(0x9a),
		1925: uint8(0x94),
		1926: uint8(0x9f),
		1927: uint8(0x92),
		1928: uint8(0x99),
		1929: uint8(0x97),
		1930: uint8(0x92),
		1931: uint8(0x9c),
		1932: uint8(0x96),
		1933: uint8(0x99),
		1934: uint8(0x98),
		1935: uint8(0x95),
		1936: uint8(0x90),
		1937: uint8(0x96),
		1938: uint8(0x9d),
		1939: uint8(0x91),
		1940: uint8(0x93),
		1941: uint8(0x9d),
		1942: uint8(0x94),
		1943: uint8(0x9e),
		1944: uint8(0x9e),
		1945: uint8(0x90),
		1946: uint8(0x97),
		1947: uint8(0x9b),
		1948: uint8(0x95),
		1949: uint8(0x93),
		1950: uint8(0x9b),
		1951: uint8(0x98),
		1952: uint8(0x99),
		1953: uint8(0x94),
		1954: uint8(0x9e),
		1955: uint8(0x93),
		1956: uint8(0x9f),
		1957: uint8(0x92),
		1958: uint8(0x95),
		1959: uint8(0x9c),
		1960: uint8(0x92),
		1961: uint8(0x99),
		1962: uint8(0x98),
		1963: uint8(0x95),
		1964: uint8(0x9c),
		1965: uint8(0x9f),
		1966: uint8(0x93),
		1967: uint8(0x9a),
		1968: uint8(0x97),
		1969: uint8(0x9b),
		1970: uint8(0x90),
		1971: uint8(0x9e),
		1972: uint8(0x94),
		1973: uint8(0x91),
		1974: uint8(0x9a),
		1975: uint8(0x97),
		1976: uint8(0x91),
		1977: uint8(0x96),
		1978: uint8(0x9d),
		1979: uint8(0x90),
		1980: uint8(0x9b),
		1981: uint8(0x98),
		1982: uint8(0x96),
		1983: uint8(0x9d),
		1984: uint8(0x6c),
		1985: uint8(0x6a),
		1986: uint8(0x61),
		1987: uint8(0x6f),
		1988: uint8(0x6a),
		1989: uint8(0x64),
		1990: uint8(0x6f),
		1991: uint8(0x62),
		1992: uint8(0x69),
		1993: uint8(0x67),
		1994: uint8(0x62),
		1995: uint8(0x6c),
		1996: uint8(0x66),
		1997: uint8(0x69),
		1998: uint8(0x68),
		1999: uint8(0x65),
		2000: uint8(0x60),
		2001: uint8(0x66),
		2002: uint8(0x6d),
		2003: uint8(0x61),
		2004: uint8(0x63),
		2005: uint8(0x6d),
		2006: uint8(0x64),
		2007: uint8(0x6e),
		2008: uint8(0x6e),
		2009: uint8(0x60),
		2010: uint8(0x67),
		2011: uint8(0x6b),
		2012: uint8(0x65),
		2013: uint8(0x63),
		2014: uint8(0x6b),
		2015: uint8(0x68),
		2016: uint8(0x69),
		2017: uint8(0x64),
		2018: uint8(0x6e),
		2019: uint8(0x63),
		2020: uint8(0x6f),
		2021: uint8(0x62),
		2022: uint8(0x65),
		2023: uint8(0x6c),
		2024: uint8(0x62),
		2025: uint8(0x69),
		2026: uint8(0x68),
		2027: uint8(0x65),
		2028: uint8(0x6c),
		2029: uint8(0x6f),
		2030: uint8(0x63),
		2031: uint8(0x6a),
		2032: uint8(0x67),
		2033: uint8(0x6b),
		2034: uint8(0x60),
		2035: uint8(0x6e),
		2036: uint8(0x64),
		2037: uint8(0x61),
		2038: uint8(0x6a),
		2039: uint8(0x67),
		2040: uint8(0x61),
		2041: uint8(0x66),
		2042: uint8(0x6d),
		2043: uint8(0x60),
		2044: uint8(0x6b),
		2045: uint8(0x68),
		2046: uint8(0x66),
		2047: uint8(0x6d),
		2048: uint8(0x4c),
		2049: uint8(0x4a),
		2050: uint8(0x41),
		2051: uint8(0x4f),
		2052: uint8(0x4a),
		2053: uint8(0x44),
		2054: uint8(0x4f),
		2055: uint8(0x42),
		2056: uint8(0x49),
		2057: uint8(0x47),
		2058: uint8(0x42),
		2059: uint8(0x4c),
		2060: uint8(0x46),
		2061: uint8(0x49),
		2062: uint8(0x48),
		2063: uint8(0x45),
		2064: uint8(0x40),
		2065: uint8(0x46),
		2066: uint8(0x4d),
		2067: uint8(0x41),
		2068: uint8(0x43),
		2069: uint8(0x4d),
		2070: uint8(0x44),
		2071: uint8(0x4e),
		2072: uint8(0x4e),
		2073: uint8(0x40),
		2074: uint8(0x47),
		2075: uint8(0x4b),
		2076: uint8(0x45),
		2077: uint8(0x43),
		2078: uint8(0x4b),
		2079: uint8(0x48),
		2080: uint8(0x49),
		2081: uint8(0x44),
		2082: uint8(0x4e),
		2083: uint8(0x43),
		2084: uint8(0x4f),
		2085: uint8(0x42),
		2086: uint8(0x45),
		2087: uint8(0x4c),
		2088: uint8(0x42),
		2089: uint8(0x49),
		2090: uint8(0x48),
		2091: uint8(0x45),
		2092: uint8(0x4c),
		2093: uint8(0x4f),
		2094: uint8(0x43),
		2095: uint8(0x4a),
		2096: uint8(0x47),
		2097: uint8(0x4b),
		2098: uint8(0x40),
		2099: uint8(0x4e),
		2100: uint8(0x44),
		2101: uint8(0x41),
		2102: uint8(0x4a),
		2103: uint8(0x47),
		2104: uint8(0x41),
		2105: uint8(0x46),
		2106: uint8(0x4d),
		2107: uint8(0x40),
		2108: uint8(0x4b),
		2109: uint8(0x48),
		2110: uint8(0x46),
		2111: uint8(0x4d),
		2112: uint8(0xbc),
		2113: uint8(0xba),
		2114: uint8(0xb1),
		2115: uint8(0xbf),
		2116: uint8(0xba),
		2117: uint8(0xb4),
		2118: uint8(0xbf),
		2119: uint8(0xb2),
		2120: uint8(0xb9),
		2121: uint8(0xb7),
		2122: uint8(0xb2),
		2123: uint8(0xbc),
		2124: uint8(0xb6),
		2125: uint8(0xb9),
		2126: uint8(0xb8),
		2127: uint8(0xb5),
		2128: uint8(0xb0),
		2129: uint8(0xb6),
		2130: uint8(0xbd),
		2131: uint8(0xb1),
		2132: uint8(0xb3),
		2133: uint8(0xbd),
		2134: uint8(0xb4),
		2135: uint8(0xbe),
		2136: uint8(0xbe),
		2137: uint8(0xb0),
		2138: uint8(0xb7),
		2139: uint8(0xbb),
		2140: uint8(0xb5),
		2141: uint8(0xb3),
		2142: uint8(0xbb),
		2143: uint8(0xb8),
		2144: uint8(0xb9),
		2145: uint8(0xb4),
		2146: uint8(0xbe),
		2147: uint8(0xb3),
		2148: uint8(0xbf),
		2149: uint8(0xb2),
		2150: uint8(0xb5),
		2151: uint8(0xbc),
		2152: uint8(0xb2),
		2153: uint8(0xb9),
		2154: uint8(0xb8),
		2155: uint8(0xb5),
		2156: uint8(0xbc),
		2157: uint8(0xbf),
		2158: uint8(0xb3),
		2159: uint8(0xba),
		2160: uint8(0xb7),
		2161: uint8(0xbb),
		2162: uint8(0xb0),
		2163: uint8(0xbe),
		2164: uint8(0xb4),
		2165: uint8(0xb1),
		2166: uint8(0xba),
		2167: uint8(0xb7),
		2168: uint8(0xb1),
		2169: uint8(0xb6),
		2170: uint8(0xbd),
		2171: uint8(0xb0),
		2172: uint8(0xbb),
		2173: uint8(0xb8),
		2174: uint8(0xb6),
		2175: uint8(0xbd),
		2176: uint8(0x2c),
		2177: uint8(0x2a),
		2178: uint8(0x21),
		2179: uint8(0x2f),
		2180: uint8(0x2a),
		2181: uint8(0x24),
		2182: uint8(0x2f),
		2183: uint8(0x22),
		2184: uint8(0x29),
		2185: uint8(0x27),
		2186: uint8(0x22),
		2187: uint8(0x2c),
		2188: uint8(0x26),
		2189: uint8(0x29),
		2190: uint8(0x28),
		2191: uint8(0x25),
		2192: uint8(0x20),
		2193: uint8(0x26),
		2194: uint8(0x2d),
		2195: uint8(0x21),
		2196: uint8(0x23),
		2197: uint8(0x2d),
		2198: uint8(0x24),
		2199: uint8(0x2e),
		2200: uint8(0x2e),
		2201: uint8(0x20),
		2202: uint8(0x27),
		2203: uint8(0x2b),
		2204: uint8(0x25),
		2205: uint8(0x23),
		2206: uint8(0x2b),
		2207: uint8(0x28),
		2208: uint8(0x29),
		2209: uint8(0x24),
		2210: uint8(0x2e),
		2211: uint8(0x23),
		2212: uint8(0x2f),
		2213: uint8(0x22),
		2214: uint8(0x25),
		2215: uint8(0x2c),
		2216: uint8(0x22),
		2217: uint8(0x29),
		2218: uint8(0x28),
		2219: uint8(0x25),
		2220: uint8(0x2c),
		2221: uint8(0x2f),
		2222: uint8(0x23),
		2223: uint8(0x2a),
		2224: uint8(0x27),
		2225: uint8(0x2b),
		2226: uint8(0x20),
		2227: uint8(0x2e),
		2228: uint8(0x24),
		2229: uint8(0x21),
		2230: uint8(0x2a),
		2231: uint8(0x27),
		2232: uint8(0x21),
		2233: uint8(0x26),
		2234: uint8(0x2d),
		2235: uint8(0x20),
		2236: uint8(0x2b),
		2237: uint8(0x28),
		2238: uint8(0x26),
		2239: uint8(0x2d),
		2240: uint8(0x8c),
		2241: uint8(0x8a),
		2242: uint8(0x81),
		2243: uint8(0x8f),
		2244: uint8(0x8a),
		2245: uint8(0x84),
		2246: uint8(0x8f),
		2247: uint8(0x82),
		2248: uint8(0x89),
		2249: uint8(0x87),
		2250: uint8(0x82),
		2251: uint8(0x8c),
		2252: uint8(0x86),
		2253: uint8(0x89),
		2254: uint8(0x88),
		2255: uint8(0x85),
		2256: uint8(0x80),
		2257: uint8(0x86),
		2258: uint8(0x8d),
		2259: uint8(0x81),
		2260: uint8(0x83),
		2261: uint8(0x8d),
		2262: uint8(0x84),
		2263: uint8(0x8e),
		2264: uint8(0x8e),
		2265: uint8(0x80),
		2266: uint8(0x87),
		2267: uint8(0x8b),
		2268: uint8(0x85),
		2269: uint8(0x83),
		2270: uint8(0x8b),
		2271: uint8(0x88),
		2272: uint8(0x89),
		2273: uint8(0x84),
		2274: uint8(0x8e),
		2275: uint8(0x83),
		2276: uint8(0x8f),
		2277: uint8(0x82),
		2278: uint8(0x85),
		2279: uint8(0x8c),
		2280: uint8(0x82),
		2281: uint8(0x89),
		2282: uint8(0x88),
		2283: uint8(0x85),
		2284: uint8(0x8c),
		2285: uint8(0x8f),
		2286: uint8(0x83),
		2287: uint8(0x8a),
		2288: uint8(0x87),
		2289: uint8(0x8b),
		2290: uint8(0x80),
		2291: uint8(0x8e),
		2292: uint8(0x84),
		2293: uint8(0x81),
		2294: uint8(0x8a),
		2295: uint8(0x87),
		2296: uint8(0x81),
		2297: uint8(0x86),
		2298: uint8(0x8d),
		2299: uint8(0x80),
		2300: uint8(0x8b),
		2301: uint8(0x88),
		2302: uint8(0x86),
		2303: uint8(0x8d),
		2304: uint8(0x1c),
		2305: uint8(0x1a),
		2306: uint8(0x11),
		2307: uint8(0x1f),
		2308: uint8(0x1a),
		2309: uint8(0x14),
		2310: uint8(0x1f),
		2311: uint8(0x12),
		2312: uint8(0x19),
		2313: uint8(0x17),
		2314: uint8(0x12),
		2315: uint8(0x1c),
		2316: uint8(0x16),
		2317: uint8(0x19),
		2318: uint8(0x18),
		2319: uint8(0x15),
		2320: uint8(0x10),
		2321: uint8(0x16),
		2322: uint8(0x1d),
		2323: uint8(0x11),
		2324: uint8(0x13),
		2325: uint8(0x1d),
		2326: uint8(0x14),
		2327: uint8(0x1e),
		2328: uint8(0x1e),
		2329: uint8(0x10),
		2330: uint8(0x17),
		2331: uint8(0x1b),
		2332: uint8(0x15),
		2333: uint8(0x13),
		2334: uint8(0x1b),
		2335: uint8(0x18),
		2336: uint8(0x19),
		2337: uint8(0x14),
		2338: uint8(0x1e),
		2339: uint8(0x13),
		2340: uint8(0x1f),
		2341: uint8(0x12),
		2342: uint8(0x15),
		2343: uint8(0x1c),
		2344: uint8(0x12),
		2345: uint8(0x19),
		2346: uint8(0x18),
		2347: uint8(0x15),
		2348: uint8(0x1c),
		2349: uint8(0x1f),
		2350: uint8(0x13),
		2351: uint8(0x1a),
		2352: uint8(0x17),
		2353: uint8(0x1b),
		2354: uint8(0x10),
		2355: uint8(0x1e),
		2356: uint8(0x14),
		2357: uint8(0x11),
		2358: uint8(0x1a),
		2359: uint8(0x17),
		2360: uint8(0x11),
		2361: uint8(0x16),
		2362: uint8(0x1d),
		2363: uint8(0x10),
		2364: uint8(0x1b),
		2365: uint8(0x18),
		2366: uint8(0x16),
		2367: uint8(0x1d),
		2368: uint8(0xcc),
		2369: uint8(0xca),
		2370: uint8(0xc1),
		2371: uint8(0xcf),
		2372: uint8(0xca),
		2373: uint8(0xc4),
		2374: uint8(0xcf),
		2375: uint8(0xc2),
		2376: uint8(0xc9),
		2377: uint8(0xc7),
		2378: uint8(0xc2),
		2379: uint8(0xcc),
		2380: uint8(0xc6),
		2381: uint8(0xc9),
		2382: uint8(0xc8),
		2383: uint8(0xc5),
		2384: uint8(0xc0),
		2385: uint8(0xc6),
		2386: uint8(0xcd),
		2387: uint8(0xc1),
		2388: uint8(0xc3),
		2389: uint8(0xcd),
		2390: uint8(0xc4),
		2391: uint8(0xce),
		2392: uint8(0xce),
		2393: uint8(0xc0),
		2394: uint8(0xc7),
		2395: uint8(0xcb),
		2396: uint8(0xc5),
		2397: uint8(0xc3),
		2398: uint8(0xcb),
		2399: uint8(0xc8),
		2400: uint8(0xc9),
		2401: uint8(0xc4),
		2402: uint8(0xce),
		2403: uint8(0xc3),
		2404: uint8(0xcf),
		2405: uint8(0xc2),
		2406: uint8(0xc5),
		2407: uint8(0xcc),
		2408: uint8(0xc2),
		2409: uint8(0xc9),
		2410: uint8(0xc8),
		2411: uint8(0xc5),
		2412: uint8(0xcc),
		2413: uint8(0xcf),
		2414: uint8(0xc3),
		2415: uint8(0xca),
		2416: uint8(0xc7),
		2417: uint8(0xcb),
		2418: uint8(0xc0),
		2419: uint8(0xce),
		2420: uint8(0xc4),
		2421: uint8(0xc1),
		2422: uint8(0xca),
		2423: uint8(0xc7),
		2424: uint8(0xc1),
		2425: uint8(0xc6),
		2426: uint8(0xcd),
		2427: uint8(0xc0),
		2428: uint8(0xcb),
		2429: uint8(0xc8),
		2430: uint8(0xc6),
		2431: uint8(0xcd),
		2432: uint8(0xbc),
		2433: uint8(0xba),
		2434: uint8(0xb1),
		2435: uint8(0xbf),
		2436: uint8(0xba),
		2437: uint8(0xb4),
		2438: uint8(0xbf),
		2439: uint8(0xb2),
		2440: uint8(0xb9),
		2441: uint8(0xb7),
		2442: uint8(0xb2),
		2443: uint8(0xbc),
		2444: uint8(0xb6),
		2445: uint8(0xb9),
		2446: uint8(0xb8),
		2447: uint8(0xb5),
		2448: uint8(0xb0),
		2449: uint8(0xb6),
		2450: uint8(0xbd),
		2451: uint8(0xb1),
		2452: uint8(0xb3),
		2453: uint8(0xbd),
		2454: uint8(0xb4),
		2455: uint8(0xbe),
		2456: uint8(0xbe),
		2457: uint8(0xb0),
		2458: uint8(0xb7),
		2459: uint8(0xbb),
		2460: uint8(0xb5),
		2461: uint8(0xb3),
		2462: uint8(0xbb),
		2463: uint8(0xb8),
		2464: uint8(0xb9),
		2465: uint8(0xb4),
		2466: uint8(0xbe),
		2467: uint8(0xb3),
		2468: uint8(0xbf),
		2469: uint8(0xb2),
		2470: uint8(0xb5),
		2471: uint8(0xbc),
		2472: uint8(0xb2),
		2473: uint8(0xb9),
		2474: uint8(0xb8),
		2475: uint8(0xb5),
		2476: uint8(0xbc),
		2477: uint8(0xbf),
		2478: uint8(0xb3),
		2479: uint8(0xba),
		2480: uint8(0xb7),
		2481: uint8(0xbb),
		2482: uint8(0xb0),
		2483: uint8(0xbe),
		2484: uint8(0xb4),
		2485: uint8(0xb1),
		2486: uint8(0xba),
		2487: uint8(0xb7),
		2488: uint8(0xb1),
		2489: uint8(0xb6),
		2490: uint8(0xbd),
		2491: uint8(0xb0),
		2492: uint8(0xbb),
		2493: uint8(0xb8),
		2494: uint8(0xb6),
		2495: uint8(0xbd),
		2496: uint8(0x7c),
		2497: uint8(0x7a),
		2498: uint8(0x71),
		2499: uint8(0x7f),
		2500: uint8(0x7a),
		2501: uint8(0x74),
		2502: uint8(0x7f),
		2503: uint8(0x72),
		2504: uint8(0x79),
		2505: uint8(0x77),
		2506: uint8(0x72),
		2507: uint8(0x7c),
		2508: uint8(0x76),
		2509: uint8(0x79),
		2510: uint8(0x78),
		2511: uint8(0x75),
		2512: uint8(0x70),
		2513: uint8(0x76),
		2514: uint8(0x7d),
		2515: uint8(0x71),
		2516: uint8(0x73),
		2517: uint8(0x7d),
		2518: uint8(0x74),
		2519: uint8(0x7e),
		2520: uint8(0x7e),
		2521: uint8(0x70),
		2522: uint8(0x77),
		2523: uint8(0x7b),
		2524: uint8(0x75),
		2525: uint8(0x73),
		2526: uint8(0x7b),
		2527: uint8(0x78),
		2528: uint8(0x79),
		2529: uint8(0x74),
		2530: uint8(0x7e),
		2531: uint8(0x73),
		2532: uint8(0x7f),
		2533: uint8(0x72),
		2534: uint8(0x75),
		2535: uint8(0x7c),
		2536: uint8(0x72),
		2537: uint8(0x79),
		2538: uint8(0x78),
		2539: uint8(0x75),
		2540: uint8(0x7c),
		2541: uint8(0x7f),
		2542: uint8(0x73),
		2543: uint8(0x7a),
		2544: uint8(0x77),
		2545: uint8(0x7b),
		2546: uint8(0x70),
		2547: uint8(0x7e),
		2548: uint8(0x74),
		2549: uint8(0x71),
		2550: uint8(0x7a),
		2551: uint8(0x77),
		2552: uint8(0x71),
		2553: uint8(0x76),
		2554: uint8(0x7d),
		2555: uint8(0x70),
		2556: uint8(0x7b),
		2557: uint8(0x78),
		2558: uint8(0x76),
		2559: uint8(0x7d),
		2560: uint8(0xac),
		2561: uint8(0xaa),
		2562: uint8(0xa1),
		2563: uint8(0xaf),
		2564: uint8(0xaa),
		2565: uint8(0xa4),
		2566: uint8(0xaf),
		2567: uint8(0xa2),
		2568: uint8(0xa9),
		2569: uint8(0xa7),
		2570: uint8(0xa2),
		2571: uint8(0xac),
		2572: uint8(0xa6),
		2573: uint8(0xa9),
		2574: uint8(0xa8),
		2575: uint8(0xa5),
		2576: uint8(0xa0),
		2577: uint8(0xa6),
		2578: uint8(0xad),
		2579: uint8(0xa1),
		2580: uint8(0xa3),
		2581: uint8(0xad),
		2582: uint8(0xa4),
		2583: uint8(0xae),
		2584: uint8(0xae),
		2585: uint8(0xa0),
		2586: uint8(0xa7),
		2587: uint8(0xab),
		2588: uint8(0xa5),
		2589: uint8(0xa3),
		2590: uint8(0xab),
		2591: uint8(0xa8),
		2592: uint8(0xa9),
		2593: uint8(0xa4),
		2594: uint8(0xae),
		2595: uint8(0xa3),
		2596: uint8(0xaf),
		2597: uint8(0xa2),
		2598: uint8(0xa5),
		2599: uint8(0xac),
		2600: uint8(0xa2),
		2601: uint8(0xa9),
		2602: uint8(0xa8),
		2603: uint8(0xa5),
		2604: uint8(0xac),
		2605: uint8(0xaf),
		2606: uint8(0xa3),
		2607: uint8(0xaa),
		2608: uint8(0xa7),
		2609: uint8(0xab),
		2610: uint8(0xa0),
		2611: uint8(0xae),
		2612: uint8(0xa4),
		2613: uint8(0xa1),
		2614: uint8(0xaa),
		2615: uint8(0xa7),
		2616: uint8(0xa1),
		2617: uint8(0xa6),
		2618: uint8(0xad),
		2619: uint8(0xa0),
		2620: uint8(0xab),
		2621: uint8(0xa8),
		2622: uint8(0xa6),
		2623: uint8(0xad),
		2624: uint8(0x1c),
		2625: uint8(0x1a),
		2626: uint8(0x11),
		2627: uint8(0x1f),
		2628: uint8(0x1a),
		2629: uint8(0x14),
		2630: uint8(0x1f),
		2631: uint8(0x12),
		2632: uint8(0x19),
		2633: uint8(0x17),
		2634: uint8(0x12),
		2635: uint8(0x1c),
		2636: uint8(0x16),
		2637: uint8(0x19),
		2638: uint8(0x18),
		2639: uint8(0x15),
		2640: uint8(0x10),
		2641: uint8(0x16),
		2642: uint8(0x1d),
		2643: uint8(0x11),
		2644: uint8(0x13),
		2645: uint8(0x1d),
		2646: uint8(0x14),
		2647: uint8(0x1e),
		2648: uint8(0x1e),
		2649: uint8(0x10),
		2650: uint8(0x17),
		2651: uint8(0x1b),
		2652: uint8(0x15),
		2653: uint8(0x13),
		2654: uint8(0x1b),
		2655: uint8(0x18),
		2656: uint8(0x19),
		2657: uint8(0x14),
		2658: uint8(0x1e),
		2659: uint8(0x13),
		2660: uint8(0x1f),
		2661: uint8(0x12),
		2662: uint8(0x15),
		2663: uint8(0x1c),
		2664: uint8(0x12),
		2665: uint8(0x19),
		2666: uint8(0x18),
		2667: uint8(0x15),
		2668: uint8(0x1c),
		2669: uint8(0x1f),
		2670: uint8(0x13),
		2671: uint8(0x1a),
		2672: uint8(0x17),
		2673: uint8(0x1b),
		2674: uint8(0x10),
		2675: uint8(0x1e),
		2676: uint8(0x14),
		2677: uint8(0x11),
		2678: uint8(0x1a),
		2679: uint8(0x17),
		2680: uint8(0x11),
		2681: uint8(0x16),
		2682: uint8(0x1d),
		2683: uint8(0x10),
		2684: uint8(0x1b),
		2685: uint8(0x18),
		2686: uint8(0x16),
		2687: uint8(0x1d),
		2688: uint8(0xdc),
		2689: uint8(0xda),
		2690: uint8(0xd1),
		2691: uint8(0xdf),
		2692: uint8(0xda),
		2693: uint8(0xd4),
		2694: uint8(0xdf),
		2695: uint8(0xd2),
		2696: uint8(0xd9),
		2697: uint8(0xd7),
		2698: uint8(0xd2),
		2699: uint8(0xdc),
		2700: uint8(0xd6),
		2701: uint8(0xd9),
		2702: uint8(0xd8),
		2703: uint8(0xd5),
		2704: uint8(0xd0),
		2705: uint8(0xd6),
		2706: uint8(0xdd),
		2707: uint8(0xd1),
		2708: uint8(0xd3),
		2709: uint8(0xdd),
		2710: uint8(0xd4),
		2711: uint8(0xde),
		2712: uint8(0xde),
		2713: uint8(0xd0),
		2714: uint8(0xd7),
		2715: uint8(0xdb),
		2716: uint8(0xd5),
		2717: uint8(0xd3),
		2718: uint8(0xdb),
		2719: uint8(0xd8),
		2720: uint8(0xd9),
		2721: uint8(0xd4),
		2722: uint8(0xde),
		2723: uint8(0xd3),
		2724: uint8(0xdf),
		2725: uint8(0xd2),
		2726: uint8(0xd5),
		2727: uint8(0xdc),
		2728: uint8(0xd2),
		2729: uint8(0xd9),
		2730: uint8(0xd8),
		2731: uint8(0xd5),
		2732: uint8(0xdc),
		2733: uint8(0xdf),
		2734: uint8(0xd3),
		2735: uint8(0xda),
		2736: uint8(0xd7),
		2737: uint8(0xdb),
		2738: uint8(0xd0),
		2739: uint8(0xde),
		2740: uint8(0xd4),
		2741: uint8(0xd1),
		2742: uint8(0xda),
		2743: uint8(0xd7),
		2744: uint8(0xd1),
		2745: uint8(0xd6),
		2746: uint8(0xdd),
		2747: uint8(0xd0),
		2748: uint8(0xdb),
		2749: uint8(0xd8),
		2750: uint8(0xd6),
		2751: uint8(0xdd),
		2752: uint8(0xec),
		2753: uint8(0xea),
		2754: uint8(0xe1),
		2755: uint8(0xef),
		2756: uint8(0xea),
		2757: uint8(0xe4),
		2758: uint8(0xef),
		2759: uint8(0xe2),
		2760: uint8(0xe9),
		2761: uint8(0xe7),
		2762: uint8(0xe2),
		2763: uint8(0xec),
		2764: uint8(0xe6),
		2765: uint8(0xe9),
		2766: uint8(0xe8),
		2767: uint8(0xe5),
		2768: uint8(0xe0),
		2769: uint8(0xe6),
		2770: uint8(0xed),
		2771: uint8(0xe1),
		2772: uint8(0xe3),
		2773: uint8(0xed),
		2774: uint8(0xe4),
		2775: uint8(0xee),
		2776: uint8(0xee),
		2777: uint8(0xe0),
		2778: uint8(0xe7),
		2779: uint8(0xeb),
		2780: uint8(0xe5),
		2781: uint8(0xe3),
		2782: uint8(0xeb),
		2783: uint8(0xe8),
		2784: uint8(0xe9),
		2785: uint8(0xe4),
		2786: uint8(0xee),
		2787: uint8(0xe3),
		2788: uint8(0xef),
		2789: uint8(0xe2),
		2790: uint8(0xe5),
		2791: uint8(0xec),
		2792: uint8(0xe2),
		2793: uint8(0xe9),
		2794: uint8(0xe8),
		2795: uint8(0xe5),
		2796: uint8(0xec),
		2797: uint8(0xef),
		2798: uint8(0xe3),
		2799: uint8(0xea),
		2800: uint8(0xe7),
		2801: uint8(0xeb),
		2802: uint8(0xe0),
		2803: uint8(0xee),
		2804: uint8(0xe4),
		2805: uint8(0xe1),
		2806: uint8(0xea),
		2807: uint8(0xe7),
		2808: uint8(0xe1),
		2809: uint8(0xe6),
		2810: uint8(0xed),
		2811: uint8(0xe0),
		2812: uint8(0xeb),
		2813: uint8(0xe8),
		2814: uint8(0xe6),
		2815: uint8(0xed),
		2816: uint8(0x7c),
		2817: uint8(0x7a),
		2818: uint8(0x71),
		2819: uint8(0x7f),
		2820: uint8(0x7a),
		2821: uint8(0x74),
		2822: uint8(0x7f),
		2823: uint8(0x72),
		2824: uint8(0x79),
		2825: uint8(0x77),
		2826: uint8(0x72),
		2827: uint8(0x7c),
		2828: uint8(0x76),
		2829: uint8(0x79),
		2830: uint8(0x78),
		2831: uint8(0x75),
		2832: uint8(0x70),
		2833: uint8(0x76),
		2834: uint8(0x7d),
		2835: uint8(0x71),
		2836: uint8(0x73),
		2837: uint8(0x7d),
		2838: uint8(0x74),
		2839: uint8(0x7e),
		2840: uint8(0x7e),
		2841: uint8(0x70),
		2842: uint8(0x77),
		2843: uint8(0x7b),
		2844: uint8(0x75),
		2845: uint8(0x73),
		2846: uint8(0x7b),
		2847: uint8(0x78),
		2848: uint8(0x79),
		2849: uint8(0x74),
		2850: uint8(0x7e),
		2851: uint8(0x73),
		2852: uint8(0x7f),
		2853: uint8(0x72),
		2854: uint8(0x75),
		2855: uint8(0x7c),
		2856: uint8(0x72),
		2857: uint8(0x79),
		2858: uint8(0x78),
		2859: uint8(0x75),
		2860: uint8(0x7c),
		2861: uint8(0x7f),
		2862: uint8(0x73),
		2863: uint8(0x7a),
		2864: uint8(0x77),
		2865: uint8(0x7b),
		2866: uint8(0x70),
		2867: uint8(0x7e),
		2868: uint8(0x74),
		2869: uint8(0x71),
		2870: uint8(0x7a),
		2871: uint8(0x77),
		2872: uint8(0x71),
		2873: uint8(0x76),
		2874: uint8(0x7d),
		2875: uint8(0x70),
		2876: uint8(0x7b),
		2877: uint8(0x78),
		2878: uint8(0x76),
		2879: uint8(0x7d),
		2880: uint8(0x2c),
		2881: uint8(0x2a),
		2882: uint8(0x21),
		2883: uint8(0x2f),
		2884: uint8(0x2a),
		2885: uint8(0x24),
		2886: uint8(0x2f),
		2887: uint8(0x22),
		2888: uint8(0x29),
		2889: uint8(0x27),
		2890: uint8(0x22),
		2891: uint8(0x2c),
		2892: uint8(0x26),
		2893: uint8(0x29),
		2894: uint8(0x28),
		2895: uint8(0x25),
		2896: uint8(0x20),
		2897: uint8(0x26),
		2898: uint8(0x2d),
		2899: uint8(0x21),
		2900: uint8(0x23),
		2901: uint8(0x2d),
		2902: uint8(0x24),
		2903: uint8(0x2e),
		2904: uint8(0x2e),
		2905: uint8(0x20),
		2906: uint8(0x27),
		2907: uint8(0x2b),
		2908: uint8(0x25),
		2909: uint8(0x23),
		2910: uint8(0x2b),
		2911: uint8(0x28),
		2912: uint8(0x29),
		2913: uint8(0x24),
		2914: uint8(0x2e),
		2915: uint8(0x23),
		2916: uint8(0x2f),
		2917: uint8(0x22),
		2918: uint8(0x25),
		2919: uint8(0x2c),
		2920: uint8(0x22),
		2921: uint8(0x29),
		2922: uint8(0x28),
		2923: uint8(0x25),
		2924: uint8(0x2c),
		2925: uint8(0x2f),
		2926: uint8(0x23),
		2927: uint8(0x2a),
		2928: uint8(0x27),
		2929: uint8(0x2b),
		2930: uint8(0x20),
		2931: uint8(0x2e),
		2932: uint8(0x24),
		2933: uint8(0x21),
		2934: uint8(0x2a),
		2935: uint8(0x27),
		2936: uint8(0x21),
		2937: uint8(0x26),
		2938: uint8(0x2d),
		2939: uint8(0x20),
		2940: uint8(0x2b),
		2941: uint8(0x28),
		2942: uint8(0x26),
		2943: uint8(0x2d),
		2944: uint8(0x8c),
		2945: uint8(0x8a),
		2946: uint8(0x81),
		2947: uint8(0x8f),
		2948: uint8(0x8a),
		2949: uint8(0x84),
		2950: uint8(0x8f),
		2951: uint8(0x82),
		2952: uint8(0x89),
		2953: uint8(0x87),
		2954: uint8(0x82),
		2955: uint8(0x8c),
		2956: uint8(0x86),
		2957: uint8(0x89),
		2958: uint8(0x88),
		2959: uint8(0x85),
		2960: uint8(0x80),
		2961: uint8(0x86),
		2962: uint8(0x8d),
		2963: uint8(0x81),
		2964: uint8(0x83),
		2965: uint8(0x8d),
		2966: uint8(0x84),
		2967: uint8(0x8e),
		2968: uint8(0x8e),
		2969: uint8(0x80),
		2970: uint8(0x87),
		2971: uint8(0x8b),
		2972: uint8(0x85),
		2973: uint8(0x83),
		2974: uint8(0x8b),
		2975: uint8(0x88),
		2976: uint8(0x89),
		2977: uint8(0x84),
		2978: uint8(0x8e),
		2979: uint8(0x83),
		2980: uint8(0x8f),
		2981: uint8(0x82),
		2982: uint8(0x85),
		2983: uint8(0x8c),
		2984: uint8(0x82),
		2985: uint8(0x89),
		2986: uint8(0x88),
		2987: uint8(0x85),
		2988: uint8(0x8c),
		2989: uint8(0x8f),
		2990: uint8(0x83),
		2991: uint8(0x8a),
		2992: uint8(0x87),
		2993: uint8(0x8b),
		2994: uint8(0x80),
		2995: uint8(0x8e),
		2996: uint8(0x84),
		2997: uint8(0x81),
		2998: uint8(0x8a),
		2999: uint8(0x87),
		3000: uint8(0x81),
		3001: uint8(0x86),
		3002: uint8(0x8d),
		3003: uint8(0x80),
		3004: uint8(0x8b),
		3005: uint8(0x88),
		3006: uint8(0x86),
		3007: uint8(0x8d),
		3008: uint8(0xdc),
		3009: uint8(0xda),
		3010: uint8(0xd1),
		3011: uint8(0xdf),
		3012: uint8(0xda),
		3013: uint8(0xd4),
		3014: uint8(0xdf),
		3015: uint8(0xd2),
		3016: uint8(0xd9),
		3017: uint8(0xd7),
		3018: uint8(0xd2),
		3019: uint8(0xdc),
		3020: uint8(0xd6),
		3021: uint8(0xd9),
		3022: uint8(0xd8),
		3023: uint8(0xd5),
		3024: uint8(0xd0),
		3025: uint8(0xd6),
		3026: uint8(0xdd),
		3027: uint8(0xd1),
		3028: uint8(0xd3),
		3029: uint8(0xdd),
		3030: uint8(0xd4),
		3031: uint8(0xde),
		3032: uint8(0xde),
		3033: uint8(0xd0),
		3034: uint8(0xd7),
		3035: uint8(0xdb),
		3036: uint8(0xd5),
		3037: uint8(0xd3),
		3038: uint8(0xdb),
		3039: uint8(0xd8),
		3040: uint8(0xd9),
		3041: uint8(0xd4),
		3042: uint8(0xde),
		3043: uint8(0xd3),
		3044: uint8(0xdf),
		3045: uint8(0xd2),
		3046: uint8(0xd5),
		3047: uint8(0xdc),
		3048: uint8(0xd2),
		3049: uint8(0xd9),
		3050: uint8(0xd8),
		3051: uint8(0xd5),
		3052: uint8(0xdc),
		3053: uint8(0xdf),
		3054: uint8(0xd3),
		3055: uint8(0xda),
		3056: uint8(0xd7),
		3057: uint8(0xdb),
		3058: uint8(0xd0),
		3059: uint8(0xde),
		3060: uint8(0xd4),
		3061: uint8(0xd1),
		3062: uint8(0xda),
		3063: uint8(0xd7),
		3064: uint8(0xd1),
		3065: uint8(0xd6),
		3066: uint8(0xdd),
		3067: uint8(0xd0),
		3068: uint8(0xdb),
		3069: uint8(0xd8),
		3070: uint8(0xd6),
		3071: uint8(0xdd),
		3072: uint8(0xfc),
		3073: uint8(0xfa),
		3074: uint8(0xf1),
		3075: uint8(0xff),
		3076: uint8(0xfa),
		3077: uint8(0xf4),
		3078: uint8(0xff),
		3079: uint8(0xf2),
		3080: uint8(0xf9),
		3081: uint8(0xf7),
		3082: uint8(0xf2),
		3083: uint8(0xfc),
		3084: uint8(0xf6),
		3085: uint8(0xf9),
		3086: uint8(0xf8),
		3087: uint8(0xf5),
		3088: uint8(0xf0),
		3089: uint8(0xf6),
		3090: uint8(0xfd),
		3091: uint8(0xf1),
		3092: uint8(0xf3),
		3093: uint8(0xfd),
		3094: uint8(0xf4),
		3095: uint8(0xfe),
		3096: uint8(0xfe),
		3097: uint8(0xf0),
		3098: uint8(0xf7),
		3099: uint8(0xfb),
		3100: uint8(0xf5),
		3101: uint8(0xf3),
		3102: uint8(0xfb),
		3103: uint8(0xf8),
		3104: uint8(0xf9),
		3105: uint8(0xf4),
		3106: uint8(0xfe),
		3107: uint8(0xf3),
		3108: uint8(0xff),
		3109: uint8(0xf2),
		3110: uint8(0xf5),
		3111: uint8(0xfc),
		3112: uint8(0xf2),
		3113: uint8(0xf9),
		3114: uint8(0xf8),
		3115: uint8(0xf5),
		3116: uint8(0xfc),
		3117: uint8(0xff),
		3118: uint8(0xf3),
		3119: uint8(0xfa),
		3120: uint8(0xf7),
		3121: uint8(0xfb),
		3122: uint8(0xf0),
		3123: uint8(0xfe),
		3124: uint8(0xf4),
		3125: uint8(0xf1),
		3126: uint8(0xfa),
		3127: uint8(0xf7),
		3128: uint8(0xf1),
		3129: uint8(0xf6),
		3130: uint8(0xfd),
		3131: uint8(0xf0),
		3132: uint8(0xfb),
		3133: uint8(0xf8),
		3134: uint8(0xf6),
		3135: uint8(0xfd),
		3136: uint8(0x6c),
		3137: uint8(0x6a),
		3138: uint8(0x61),
		3139: uint8(0x6f),
		3140: uint8(0x6a),
		3141: uint8(0x64),
		3142: uint8(0x6f),
		3143: uint8(0x62),
		3144: uint8(0x69),
		3145: uint8(0x67),
		3146: uint8(0x62),
		3147: uint8(0x6c),
		3148: uint8(0x66),
		3149: uint8(0x69),
		3150: uint8(0x68),
		3151: uint8(0x65),
		3152: uint8(0x60),
		3153: uint8(0x66),
		3154: uint8(0x6d),
		3155: uint8(0x61),
		3156: uint8(0x63),
		3157: uint8(0x6d),
		3158: uint8(0x64),
		3159: uint8(0x6e),
		3160: uint8(0x6e),
		3161: uint8(0x60),
		3162: uint8(0x67),
		3163: uint8(0x6b),
		3164: uint8(0x65),
		3165: uint8(0x63),
		3166: uint8(0x6b),
		3167: uint8(0x68),
		3168: uint8(0x69),
		3169: uint8(0x64),
		3170: uint8(0x6e),
		3171: uint8(0x63),
		3172: uint8(0x6f),
		3173: uint8(0x62),
		3174: uint8(0x65),
		3175: uint8(0x6c),
		3176: uint8(0x62),
		3177: uint8(0x69),
		3178: uint8(0x68),
		3179: uint8(0x65),
		3180: uint8(0x6c),
		3181: uint8(0x6f),
		3182: uint8(0x63),
		3183: uint8(0x6a),
		3184: uint8(0x67),
		3185: uint8(0x6b),
		3186: uint8(0x60),
		3187: uint8(0x6e),
		3188: uint8(0x64),
		3189: uint8(0x61),
		3190: uint8(0x6a),
		3191: uint8(0x67),
		3192: uint8(0x61),
		3193: uint8(0x66),
		3194: uint8(0x6d),
		3195: uint8(0x60),
		3196: uint8(0x6b),
		3197: uint8(0x68),
		3198: uint8(0x66),
		3199: uint8(0x6d),
		3200: uint8(0x9c),
		3201: uint8(0x9a),
		3202: uint8(0x91),
		3203: uint8(0x9f),
		3204: uint8(0x9a),
		3205: uint8(0x94),
		3206: uint8(0x9f),
		3207: uint8(0x92),
		3208: uint8(0x99),
		3209: uint8(0x97),
		3210: uint8(0x92),
		3211: uint8(0x9c),
		3212: uint8(0x96),
		3213: uint8(0x99),
		3214: uint8(0x98),
		3215: uint8(0x95),
		3216: uint8(0x90),
		3217: uint8(0x96),
		3218: uint8(0x9d),
		3219: uint8(0x91),
		3220: uint8(0x93),
		3221: uint8(0x9d),
		3222: uint8(0x94),
		3223: uint8(0x9e),
		3224: uint8(0x9e),
		3225: uint8(0x90),
		3226: uint8(0x97),
		3227: uint8(0x9b),
		3228: uint8(0x95),
		3229: uint8(0x93),
		3230: uint8(0x9b),
		3231: uint8(0x98),
		3232: uint8(0x99),
		3233: uint8(0x94),
		3234: uint8(0x9e),
		3235: uint8(0x93),
		3236: uint8(0x9f),
		3237: uint8(0x92),
		3238: uint8(0x95),
		3239: uint8(0x9c),
		3240: uint8(0x92),
		3241: uint8(0x99),
		3242: uint8(0x98),
		3243: uint8(0x95),
		3244: uint8(0x9c),
		3245: uint8(0x9f),
		3246: uint8(0x93),
		3247: uint8(0x9a),
		3248: uint8(0x97),
		3249: uint8(0x9b),
		3250: uint8(0x90),
		3251: uint8(0x9e),
		3252: uint8(0x94),
		3253: uint8(0x91),
		3254: uint8(0x9a),
		3255: uint8(0x97),
		3256: uint8(0x91),
		3257: uint8(0x96),
		3258: uint8(0x9d),
		3259: uint8(0x90),
		3260: uint8(0x9b),
		3261: uint8(0x98),
		3262: uint8(0x96),
		3263: uint8(0x9d),
		3264: uint8(0xfc),
		3265: uint8(0xfa),
		3266: uint8(0xf1),
		3267: uint8(0xff),
		3268: uint8(0xfa),
		3269: uint8(0xf4),
		3270: uint8(0xff),
		3271: uint8(0xf2),
		3272: uint8(0xf9),
		3273: uint8(0xf7),
		3274: uint8(0xf2),
		3275: uint8(0xfc),
		3276: uint8(0xf6),
		3277: uint8(0xf9),
		3278: uint8(0xf8),
		3279: uint8(0xf5),
		3280: uint8(0xf0),
		3281: uint8(0xf6),
		3282: uint8(0xfd),
		3283: uint8(0xf1),
		3284: uint8(0xf3),
		3285: uint8(0xfd),
		3286: uint8(0xf4),
		3287: uint8(0xfe),
		3288: uint8(0xfe),
		3289: uint8(0xf0),
		3290: uint8(0xf7),
		3291: uint8(0xfb),
		3292: uint8(0xf5),
		3293: uint8(0xf3),
		3294: uint8(0xfb),
		3295: uint8(0xf8),
		3296: uint8(0xf9),
		3297: uint8(0xf4),
		3298: uint8(0xfe),
		3299: uint8(0xf3),
		3300: uint8(0xff),
		3301: uint8(0xf2),
		3302: uint8(0xf5),
		3303: uint8(0xfc),
		3304: uint8(0xf2),
		3305: uint8(0xf9),
		3306: uint8(0xf8),
		3307: uint8(0xf5),
		3308: uint8(0xfc),
		3309: uint8(0xff),
		3310: uint8(0xf3),
		3311: uint8(0xfa),
		3312: uint8(0xf7),
		3313: uint8(0xfb),
		3314: uint8(0xf0),
		3315: uint8(0xfe),
		3316: uint8(0xf4),
		3317: uint8(0xf1),
		3318: uint8(0xfa),
		3319: uint8(0xf7),
		3320: uint8(0xf1),
		3321: uint8(0xf6),
		3322: uint8(0xfd),
		3323: uint8(0xf0),
		3324: uint8(0xfb),
		3325: uint8(0xf8),
		3326: uint8(0xf6),
		3327: uint8(0xfd),
		3328: uint8(0xcc),
		3329: uint8(0xca),
		3330: uint8(0xc1),
		3331: uint8(0xcf),
		3332: uint8(0xca),
		3333: uint8(0xc4),
		3334: uint8(0xcf),
		3335: uint8(0xc2),
		3336: uint8(0xc9),
		3337: uint8(0xc7),
		3338: uint8(0xc2),
		3339: uint8(0xcc),
		3340: uint8(0xc6),
		3341: uint8(0xc9),
		3342: uint8(0xc8),
		3343: uint8(0xc5),
		3344: uint8(0xc0),
		3345: uint8(0xc6),
		3346: uint8(0xcd),
		3347: uint8(0xc1),
		3348: uint8(0xc3),
		3349: uint8(0xcd),
		3350: uint8(0xc4),
		3351: uint8(0xce),
		3352: uint8(0xce),
		3353: uint8(0xc0),
		3354: uint8(0xc7),
		3355: uint8(0xcb),
		3356: uint8(0xc5),
		3357: uint8(0xc3),
		3358: uint8(0xcb),
		3359: uint8(0xc8),
		3360: uint8(0xc9),
		3361: uint8(0xc4),
		3362: uint8(0xce),
		3363: uint8(0xc3),
		3364: uint8(0xcf),
		3365: uint8(0xc2),
		3366: uint8(0xc5),
		3367: uint8(0xcc),
		3368: uint8(0xc2),
		3369: uint8(0xc9),
		3370: uint8(0xc8),
		3371: uint8(0xc5),
		3372: uint8(0xcc),
		3373: uint8(0xcf),
		3374: uint8(0xc3),
		3375: uint8(0xca),
		3376: uint8(0xc7),
		3377: uint8(0xcb),
		3378: uint8(0xc0),
		3379: uint8(0xce),
		3380: uint8(0xc4),
		3381: uint8(0xc1),
		3382: uint8(0xca),
		3383: uint8(0xc7),
		3384: uint8(0xc1),
		3385: uint8(0xc6),
		3386: uint8(0xcd),
		3387: uint8(0xc0),
		3388: uint8(0xcb),
		3389: uint8(0xc8),
		3390: uint8(0xc6),
		3391: uint8(0xcd),
		3392: uint8(0x0c),
		3393: uint8(0x0a),
		3394: uint8(0x01),
		3395: uint8(0x0f),
		3396: uint8(0x0a),
		3397: uint8(0x04),
		3398: uint8(0x0f),
		3399: uint8(0x02),
		3400: uint8(0x09),
		3401: uint8(0x07),
		3402: uint8(0x02),
		3403: uint8(0x0c),
		3404: uint8(0x06),
		3405: uint8(0x09),
		3406: uint8(0x08),
		3407: uint8(0x05),
		3408: uint8(0x00),
		3409: uint8(0x06),
		3410: uint8(0x0d),
		3411: uint8(0x01),
		3412: uint8(0x03),
		3413: uint8(0x0d),
		3414: uint8(0x04),
		3415: uint8(0x0e),
		3416: uint8(0x0e),
		3417: uint8(0x00),
		3418: uint8(0x07),
		3419: uint8(0x0b),
		3420: uint8(0x05),
		3421: uint8(0x03),
		3422: uint8(0x0b),
		3423: uint8(0x08),
		3424: uint8(0x09),
		3425: uint8(0x04),
		3426: uint8(0x0e),
		3427: uint8(0x03),
		3428: uint8(0x0f),
		3429: uint8(0x02),
		3430: uint8(0x05),
		3431: uint8(0x0c),
		3432: uint8(0x02),
		3433: uint8(0x09),
		3434: uint8(0x08),
		3435: uint8(0x05),
		3436: uint8(0x0c),
		3437: uint8(0x0f),
		3438: uint8(0x03),
		3439: uint8(0x0a),
		3440: uint8(0x07),
		3441: uint8(0x0b),
		3442: uint8(0x00),
		3443: uint8(0x0e),
		3444: uint8(0x04),
		3445: uint8(0x01),
		3446: uint8(0x0a),
		3447: uint8(0x07),
		3448: uint8(0x01),
		3449: uint8(0x06),
		3450: uint8(0x0d),
		3451: uint8(0x00),
		3452: uint8(0x0b),
		3453: uint8(0x08),
		3454: uint8(0x06),
		3455: uint8(0x0d),
		3456: uint8(0x5c),
		3457: uint8(0x5a),
		3458: uint8(0x51),
		3459: uint8(0x5f),
		3460: uint8(0x5a),
		3461: uint8(0x54),
		3462: uint8(0x5f),
		3463: uint8(0x52),
		3464: uint8(0x59),
		3465: uint8(0x57),
		3466: uint8(0x52),
		3467: uint8(0x5c),
		3468: uint8(0x56),
		3469: uint8(0x59),
		3470: uint8(0x58),
		3471: uint8(0x55),
		3472: uint8(0x50),
		3473: uint8(0x56),
		3474: uint8(0x5d),
		3475: uint8(0x51),
		3476: uint8(0x53),
		3477: uint8(0x5d),
		3478: uint8(0x54),
		3479: uint8(0x5e),
		3480: uint8(0x5e),
		3481: uint8(0x50),
		3482: uint8(0x57),
		3483: uint8(0x5b),
		3484: uint8(0x55),
		3485: uint8(0x53),
		3486: uint8(0x5b),
		3487: uint8(0x58),
		3488: uint8(0x59),
		3489: uint8(0x54),
		3490: uint8(0x5e),
		3491: uint8(0x53),
		3492: uint8(0x5f),
		3493: uint8(0x52),
		3494: uint8(0x55),
		3495: uint8(0x5c),
		3496: uint8(0x52),
		3497: uint8(0x59),
		3498: uint8(0x58),
		3499: uint8(0x55),
		3500: uint8(0x5c),
		3501: uint8(0x5f),
		3502: uint8(0x53),
		3503: uint8(0x5a),
		3504: uint8(0x57),
		3505: uint8(0x5b),
		3506: uint8(0x50),
		3507: uint8(0x5e),
		3508: uint8(0x54),
		3509: uint8(0x51),
		3510: uint8(0x5a),
		3511: uint8(0x57),
		3512: uint8(0x51),
		3513: uint8(0x56),
		3514: uint8(0x5d),
		3515: uint8(0x50),
		3516: uint8(0x5b),
		3517: uint8(0x58),
		3518: uint8(0x56),
		3519: uint8(0x5d),
		3520: uint8(0x9c),
		3521: uint8(0x9a),
		3522: uint8(0x91),
		3523: uint8(0x9f),
		3524: uint8(0x9a),
		3525: uint8(0x94),
		3526: uint8(0x9f),
		3527: uint8(0x92),
		3528: uint8(0x99),
		3529: uint8(0x97),
		3530: uint8(0x92),
		3531: uint8(0x9c),
		3532: uint8(0x96),
		3533: uint8(0x99),
		3534: uint8(0x98),
		3535: uint8(0x95),
		3536: uint8(0x90),
		3537: uint8(0x96),
		3538: uint8(0x9d),
		3539: uint8(0x91),
		3540: uint8(0x93),
		3541: uint8(0x9d),
		3542: uint8(0x94),
		3543: uint8(0x9e),
		3544: uint8(0x9e),
		3545: uint8(0x90),
		3546: uint8(0x97),
		3547: uint8(0x9b),
		3548: uint8(0x95),
		3549: uint8(0x93),
		3550: uint8(0x9b),
		3551: uint8(0x98),
		3552: uint8(0x99),
		3553: uint8(0x94),
		3554: uint8(0x9e),
		3555: uint8(0x93),
		3556: uint8(0x9f),
		3557: uint8(0x92),
		3558: uint8(0x95),
		3559: uint8(0x9c),
		3560: uint8(0x92),
		3561: uint8(0x99),
		3562: uint8(0x98),
		3563: uint8(0x95),
		3564: uint8(0x9c),
		3565: uint8(0x9f),
		3566: uint8(0x93),
		3567: uint8(0x9a),
		3568: uint8(0x97),
		3569: uint8(0x9b),
		3570: uint8(0x90),
		3571: uint8(0x9e),
		3572: uint8(0x94),
		3573: uint8(0x91),
		3574: uint8(0x9a),
		3575: uint8(0x97),
		3576: uint8(0x91),
		3577: uint8(0x96),
		3578: uint8(0x9d),
		3579: uint8(0x90),
		3580: uint8(0x9b),
		3581: uint8(0x98),
		3582: uint8(0x96),
		3583: uint8(0x9d),
		3584: uint8(0x6c),
		3585: uint8(0x6a),
		3586: uint8(0x61),
		3587: uint8(0x6f),
		3588: uint8(0x6a),
		3589: uint8(0x64),
		3590: uint8(0x6f),
		3591: uint8(0x62),
		3592: uint8(0x69),
		3593: uint8(0x67),
		3594: uint8(0x62),
		3595: uint8(0x6c),
		3596: uint8(0x66),
		3597: uint8(0x69),
		3598: uint8(0x68),
		3599: uint8(0x65),
		3600: uint8(0x60),
		3601: uint8(0x66),
		3602: uint8(0x6d),
		3603: uint8(0x61),
		3604: uint8(0x63),
		3605: uint8(0x6d),
		3606: uint8(0x64),
		3607: uint8(0x6e),
		3608: uint8(0x6e),
		3609: uint8(0x60),
		3610: uint8(0x67),
		3611: uint8(0x6b),
		3612: uint8(0x65),
		3613: uint8(0x63),
		3614: uint8(0x6b),
		3615: uint8(0x68),
		3616: uint8(0x69),
		3617: uint8(0x64),
		3618: uint8(0x6e),
		3619: uint8(0x63),
		3620: uint8(0x6f),
		3621: uint8(0x62),
		3622: uint8(0x65),
		3623: uint8(0x6c),
		3624: uint8(0x62),
		3625: uint8(0x69),
		3626: uint8(0x68),
		3627: uint8(0x65),
		3628: uint8(0x6c),
		3629: uint8(0x6f),
		3630: uint8(0x63),
		3631: uint8(0x6a),
		3632: uint8(0x67),
		3633: uint8(0x6b),
		3634: uint8(0x60),
		3635: uint8(0x6e),
		3636: uint8(0x64),
		3637: uint8(0x61),
		3638: uint8(0x6a),
		3639: uint8(0x67),
		3640: uint8(0x61),
		3641: uint8(0x66),
		3642: uint8(0x6d),
		3643: uint8(0x60),
		3644: uint8(0x6b),
		3645: uint8(0x68),
		3646: uint8(0x66),
		3647: uint8(0x6d),
		3648: uint8(0xac),
		3649: uint8(0xaa),
		3650: uint8(0xa1),
		3651: uint8(0xaf),
		3652: uint8(0xaa),
		3653: uint8(0xa4),
		3654: uint8(0xaf),
		3655: uint8(0xa2),
		3656: uint8(0xa9),
		3657: uint8(0xa7),
		3658: uint8(0xa2),
		3659: uint8(0xac),
		3660: uint8(0xa6),
		3661: uint8(0xa9),
		3662: uint8(0xa8),
		3663: uint8(0xa5),
		3664: uint8(0xa0),
		3665: uint8(0xa6),
		3666: uint8(0xad),
		3667: uint8(0xa1),
		3668: uint8(0xa3),
		3669: uint8(0xad),
		3670: uint8(0xa4),
		3671: uint8(0xae),
		3672: uint8(0xae),
		3673: uint8(0xa0),
		3674: uint8(0xa7),
		3675: uint8(0xab),
		3676: uint8(0xa5),
		3677: uint8(0xa3),
		3678: uint8(0xab),
		3679: uint8(0xa8),
		3680: uint8(0xa9),
		3681: uint8(0xa4),
		3682: uint8(0xae),
		3683: uint8(0xa3),
		3684: uint8(0xaf),
		3685: uint8(0xa2),
		3686: uint8(0xa5),
		3687: uint8(0xac),
		3688: uint8(0xa2),
		3689: uint8(0xa9),
		3690: uint8(0xa8),
		3691: uint8(0xa5),
		3692: uint8(0xac),
		3693: uint8(0xaf),
		3694: uint8(0xa3),
		3695: uint8(0xaa),
		3696: uint8(0xa7),
		3697: uint8(0xab),
		3698: uint8(0xa0),
		3699: uint8(0xae),
		3700: uint8(0xa4),
		3701: uint8(0xa1),
		3702: uint8(0xaa),
		3703: uint8(0xa7),
		3704: uint8(0xa1),
		3705: uint8(0xa6),
		3706: uint8(0xad),
		3707: uint8(0xa0),
		3708: uint8(0xab),
		3709: uint8(0xa8),
		3710: uint8(0xa6),
		3711: uint8(0xad),
		3712: uint8(0x3c),
		3713: uint8(0x3a),
		3714: uint8(0x31),
		3715: uint8(0x3f),
		3716: uint8(0x3a),
		3717: uint8(0x34),
		3718: uint8(0x3f),
		3719: uint8(0x32),
		3720: uint8(0x39),
		3721: uint8(0x37),
		3722: uint8(0x32),
		3723: uint8(0x3c),
		3724: uint8(0x36),
		3725: uint8(0x39),
		3726: uint8(0x38),
		3727: uint8(0x35),
		3728: uint8(0x30),
		3729: uint8(0x36),
		3730: uint8(0x3d),
		3731: uint8(0x31),
		3732: uint8(0x33),
		3733: uint8(0x3d),
		3734: uint8(0x34),
		3735: uint8(0x3e),
		3736: uint8(0x3e),
		3737: uint8(0x30),
		3738: uint8(0x37),
		3739: uint8(0x3b),
		3740: uint8(0x35),
		3741: uint8(0x33),
		3742: uint8(0x3b),
		3743: uint8(0x38),
		3744: uint8(0x39),
		3745: uint8(0x34),
		3746: uint8(0x3e),
		3747: uint8(0x33),
		3748: uint8(0x3f),
		3749: uint8(0x32),
		3750: uint8(0x35),
		3751: uint8(0x3c),
		3752: uint8(0x32),
		3753: uint8(0x39),
		3754: uint8(0x38),
		3755: uint8(0x35),
		3756: uint8(0x3c),
		3757: uint8(0x3f),
		3758: uint8(0x33),
		3759: uint8(0x3a),
		3760: uint8(0x37),
		3761: uint8(0x3b),
		3762: uint8(0x30),
		3763: uint8(0x3e),
		3764: uint8(0x34),
		3765: uint8(0x31),
		3766: uint8(0x3a),
		3767: uint8(0x37),
		3768: uint8(0x31),
		3769: uint8(0x36),
		3770: uint8(0x3d),
		3771: uint8(0x30),
		3772: uint8(0x3b),
		3773: uint8(0x38),
		3774: uint8(0x36),
		3775: uint8(0x3d),
		3776: uint8(0x4c),
		3777: uint8(0x4a),
		3778: uint8(0x41),
		3779: uint8(0x4f),
		3780: uint8(0x4a),
		3781: uint8(0x44),
		3782: uint8(0x4f),
		3783: uint8(0x42),
		3784: uint8(0x49),
		3785: uint8(0x47),
		3786: uint8(0x42),
		3787: uint8(0x4c),
		3788: uint8(0x46),
		3789: uint8(0x49),
		3790: uint8(0x48),
		3791: uint8(0x45),
		3792: uint8(0x40),
		3793: uint8(0x46),
		3794: uint8(0x4d),
		3795: uint8(0x41),
		3796: uint8(0x43),
		3797: uint8(0x4d),
		3798: uint8(0x44),
		3799: uint8(0x4e),
		3800: uint8(0x4e),
		3801: uint8(0x40),
		3802: uint8(0x47),
		3803: uint8(0x4b),
		3804: uint8(0x45),
		3805: uint8(0x43),
		3806: uint8(0x4b),
		3807: uint8(0x48),
		3808: uint8(0x49),
		3809: uint8(0x44),
		3810: uint8(0x4e),
		3811: uint8(0x43),
		3812: uint8(0x4f),
		3813: uint8(0x42),
		3814: uint8(0x45),
		3815: uint8(0x4c),
		3816: uint8(0x42),
		3817: uint8(0x49),
		3818: uint8(0x48),
		3819: uint8(0x45),
		3820: uint8(0x4c),
		3821: uint8(0x4f),
		3822: uint8(0x43),
		3823: uint8(0x4a),
		3824: uint8(0x47),
		3825: uint8(0x4b),
		3826: uint8(0x40),
		3827: uint8(0x4e),
		3828: uint8(0x44),
		3829: uint8(0x41),
		3830: uint8(0x4a),
		3831: uint8(0x47),
		3832: uint8(0x41),
		3833: uint8(0x46),
		3834: uint8(0x4d),
		3835: uint8(0x40),
		3836: uint8(0x4b),
		3837: uint8(0x48),
		3838: uint8(0x46),
		3839: uint8(0x4d),
		3840: uint8(0x0c),
		3841: uint8(0x0a),
		3842: uint8(0x01),
		3843: uint8(0x0f),
		3844: uint8(0x0a),
		3845: uint8(0x04),
		3846: uint8(0x0f),
		3847: uint8(0x02),
		3848: uint8(0x09),
		3849: uint8(0x07),
		3850: uint8(0x02),
		3851: uint8(0x0c),
		3852: uint8(0x06),
		3853: uint8(0x09),
		3854: uint8(0x08),
		3855: uint8(0x05),
		3856: uint8(0x00),
		3857: uint8(0x06),
		3858: uint8(0x0d),
		3859: uint8(0x01),
		3860: uint8(0x03),
		3861: uint8(0x0d),
		3862: uint8(0x04),
		3863: uint8(0x0e),
		3864: uint8(0x0e),
		3865: uint8(0x00),
		3866: uint8(0x07),
		3867: uint8(0x0b),
		3868: uint8(0x05),
		3869: uint8(0x03),
		3870: uint8(0x0b),
		3871: uint8(0x08),
		3872: uint8(0x09),
		3873: uint8(0x04),
		3874: uint8(0x0e),
		3875: uint8(0x03),
		3876: uint8(0x0f),
		3877: uint8(0x02),
		3878: uint8(0x05),
		3879: uint8(0x0c),
		3880: uint8(0x02),
		3881: uint8(0x09),
		3882: uint8(0x08),
		3883: uint8(0x05),
		3884: uint8(0x0c),
		3885: uint8(0x0f),
		3886: uint8(0x03),
		3887: uint8(0x0a),
		3888: uint8(0x07),
		3889: uint8(0x0b),
		3890: uint8(0x00),
		3891: uint8(0x0e),
		3892: uint8(0x04),
		3893: uint8(0x01),
		3894: uint8(0x0a),
		3895: uint8(0x07),
		3896: uint8(0x01),
		3897: uint8(0x06),
		3898: uint8(0x0d),
		3899: uint8(0x00),
		3900: uint8(0x0b),
		3901: uint8(0x08),
		3902: uint8(0x06),
		3903: uint8(0x0d),
		3904: uint8(0x5c),
		3905: uint8(0x5a),
		3906: uint8(0x51),
		3907: uint8(0x5f),
		3908: uint8(0x5a),
		3909: uint8(0x54),
		3910: uint8(0x5f),
		3911: uint8(0x52),
		3912: uint8(0x59),
		3913: uint8(0x57),
		3914: uint8(0x52),
		3915: uint8(0x5c),
		3916: uint8(0x56),
		3917: uint8(0x59),
		3918: uint8(0x58),
		3919: uint8(0x55),
		3920: uint8(0x50),
		3921: uint8(0x56),
		3922: uint8(0x5d),
		3923: uint8(0x51),
		3924: uint8(0x53),
		3925: uint8(0x5d),
		3926: uint8(0x54),
		3927: uint8(0x5e),
		3928: uint8(0x5e),
		3929: uint8(0x50),
		3930: uint8(0x57),
		3931: uint8(0x5b),
		3932: uint8(0x55),
		3933: uint8(0x53),
		3934: uint8(0x5b),
		3935: uint8(0x58),
		3936: uint8(0x59),
		3937: uint8(0x54),
		3938: uint8(0x5e),
		3939: uint8(0x53),
		3940: uint8(0x5f),
		3941: uint8(0x52),
		3942: uint8(0x55),
		3943: uint8(0x5c),
		3944: uint8(0x52),
		3945: uint8(0x59),
		3946: uint8(0x58),
		3947: uint8(0x55),
		3948: uint8(0x5c),
		3949: uint8(0x5f),
		3950: uint8(0x53),
		3951: uint8(0x5a),
		3952: uint8(0x57),
		3953: uint8(0x5b),
		3954: uint8(0x50),
		3955: uint8(0x5e),
		3956: uint8(0x54),
		3957: uint8(0x51),
		3958: uint8(0x5a),
		3959: uint8(0x57),
		3960: uint8(0x51),
		3961: uint8(0x56),
		3962: uint8(0x5d),
		3963: uint8(0x50),
		3964: uint8(0x5b),
		3965: uint8(0x58),
		3966: uint8(0x56),
		3967: uint8(0x5d),
		3968: uint8(0xec),
		3969: uint8(0xea),
		3970: uint8(0xe1),
		3971: uint8(0xef),
		3972: uint8(0xea),
		3973: uint8(0xe4),
		3974: uint8(0xef),
		3975: uint8(0xe2),
		3976: uint8(0xe9),
		3977: uint8(0xe7),
		3978: uint8(0xe2),
		3979: uint8(0xec),
		3980: uint8(0xe6),
		3981: uint8(0xe9),
		3982: uint8(0xe8),
		3983: uint8(0xe5),
		3984: uint8(0xe0),
		3985: uint8(0xe6),
		3986: uint8(0xed),
		3987: uint8(0xe1),
		3988: uint8(0xe3),
		3989: uint8(0xed),
		3990: uint8(0xe4),
		3991: uint8(0xee),
		3992: uint8(0xee),
		3993: uint8(0xe0),
		3994: uint8(0xe7),
		3995: uint8(0xeb),
		3996: uint8(0xe5),
		3997: uint8(0xe3),
		3998: uint8(0xeb),
		3999: uint8(0xe8),
		4000: uint8(0xe9),
		4001: uint8(0xe4),
		4002: uint8(0xee),
		4003: uint8(0xe3),
		4004: uint8(0xef),
		4005: uint8(0xe2),
		4006: uint8(0xe5),
		4007: uint8(0xec),
		4008: uint8(0xe2),
		4009: uint8(0xe9),
		4010: uint8(0xe8),
		4011: uint8(0xe5),
		4012: uint8(0xec),
		4013: uint8(0xef),
		4014: uint8(0xe3),
		4015: uint8(0xea),
		4016: uint8(0xe7),
		4017: uint8(0xeb),
		4018: uint8(0xe0),
		4019: uint8(0xee),
		4020: uint8(0xe4),
		4021: uint8(0xe1),
		4022: uint8(0xea),
		4023: uint8(0xe7),
		4024: uint8(0xe1),
		4025: uint8(0xe6),
		4026: uint8(0xed),
		4027: uint8(0xe0),
		4028: uint8(0xeb),
		4029: uint8(0xe8),
		4030: uint8(0xe6),
		4031: uint8(0xed),
		4032: uint8(0x3c),
		4033: uint8(0x3a),
		4034: uint8(0x31),
		4035: uint8(0x3f),
		4036: uint8(0x3a),
		4037: uint8(0x34),
		4038: uint8(0x3f),
		4039: uint8(0x32),
		4040: uint8(0x39),
		4041: uint8(0x37),
		4042: uint8(0x32),
		4043: uint8(0x3c),
		4044: uint8(0x36),
		4045: uint8(0x39),
		4046: uint8(0x38),
		4047: uint8(0x35),
		4048: uint8(0x30),
		4049: uint8(0x36),
		4050: uint8(0x3d),
		4051: uint8(0x31),
		4052: uint8(0x33),
		4053: uint8(0x3d),
		4054: uint8(0x34),
		4055: uint8(0x3e),
		4056: uint8(0x3e),
		4057: uint8(0x30),
		4058: uint8(0x37),
		4059: uint8(0x3b),
		4060: uint8(0x35),
		4061: uint8(0x33),
		4062: uint8(0x3b),
		4063: uint8(0x38),
		4064: uint8(0x39),
		4065: uint8(0x34),
		4066: uint8(0x3e),
		4067: uint8(0x33),
		4068: uint8(0x3f),
		4069: uint8(0x32),
		4070: uint8(0x35),
		4071: uint8(0x3c),
		4072: uint8(0x32),
		4073: uint8(0x39),
		4074: uint8(0x38),
		4075: uint8(0x35),
		4076: uint8(0x3c),
		4077: uint8(0x3f),
		4078: uint8(0x33),
		4079: uint8(0x3a),
		4080: uint8(0x37),
		4081: uint8(0x3b),
		4082: uint8(0x30),
		4083: uint8(0x3e),
		4084: uint8(0x34),
		4085: uint8(0x31),
		4086: uint8(0x3a),
		4087: uint8(0x37),
		4088: uint8(0x31),
		4089: uint8(0x36),
		4090: uint8(0x3d),
		4091: uint8(0x30),
		4092: uint8(0x3b),
		4093: uint8(0x38),
		4094: uint8(0x36),
		4095: uint8(0x3d)},
	3: {
		0:    uint8(0x4d),
		1:    uint8(0x41),
		2:    uint8(0x42),
		3:    uint8(0x4f),
		4:    uint8(0x48),
		5:    uint8(0x4d),
		6:    uint8(0x44),
		7:    uint8(0x48),
		8:    uint8(0x46),
		9:    uint8(0x4a),
		10:   uint8(0x4f),
		11:   uint8(0x43),
		12:   uint8(0x4b),
		13:   uint8(0x47),
		14:   uint8(0x41),
		15:   uint8(0x44),
		16:   uint8(0x4a),
		17:   uint8(0x4c),
		18:   uint8(0x49),
		19:   uint8(0x45),
		20:   uint8(0x43),
		21:   uint8(0x46),
		22:   uint8(0x4e),
		23:   uint8(0x4b),
		24:   uint8(0x45),
		25:   uint8(0x40),
		26:   uint8(0x40),
		27:   uint8(0x4e),
		28:   uint8(0x4c),
		29:   uint8(0x49),
		30:   uint8(0x47),
		31:   uint8(0x42),
		32:   uint8(0x47),
		33:   uint8(0x42),
		34:   uint8(0x4b),
		35:   uint8(0x41),
		36:   uint8(0x44),
		37:   uint8(0x4e),
		38:   uint8(0x41),
		39:   uint8(0x47),
		40:   uint8(0x49),
		41:   uint8(0x44),
		42:   uint8(0x4c),
		43:   uint8(0x4a),
		44:   uint8(0x4e),
		45:   uint8(0x48),
		46:   uint8(0x42),
		47:   uint8(0x4d),
		48:   uint8(0x40),
		49:   uint8(0x4f),
		50:   uint8(0x46),
		51:   uint8(0x4c),
		52:   uint8(0x4a),
		53:   uint8(0x49),
		54:   uint8(0x4d),
		55:   uint8(0x40),
		56:   uint8(0x4f),
		57:   uint8(0x43),
		58:   uint8(0x43),
		59:   uint8(0x45),
		60:   uint8(0x45),
		61:   uint8(0x46),
		62:   uint8(0x48),
		63:   uint8(0x4b),
		64:   uint8(0xdd),
		65:   uint8(0xd1),
		66:   uint8(0xd2),
		67:   uint8(0xdf),
		68:   uint8(0xd8),
		69:   uint8(0xdd),
		70:   uint8(0xd4),
		71:   uint8(0xd8),
		72:   uint8(0xd6),
		73:   uint8(0xda),
		74:   uint8(0xdf),
		75:   uint8(0xd3),
		76:   uint8(0xdb),
		77:   uint8(0xd7),
		78:   uint8(0xd1),
		79:   uint8(0xd4),
		80:   uint8(0xda),
		81:   uint8(0xdc),
		82:   uint8(0xd9),
		83:   uint8(0xd5),
		84:   uint8(0xd3),
		85:   uint8(0xd6),
		86:   uint8(0xde),
		87:   uint8(0xdb),
		88:   uint8(0xd5),
		89:   uint8(0xd0),
		90:   uint8(0xd0),
		91:   uint8(0xde),
		92:   uint8(0xdc),
		93:   uint8(0xd9),
		94:   uint8(0xd7),
		95:   uint8(0xd2),
		96:   uint8(0xd7),
		97:   uint8(0xd2),
		98:   uint8(0xdb),
		99:   uint8(0xd1),
		100:  uint8(0xd4),
		101:  uint8(0xde),
		102:  uint8(0xd1),
		103:  uint8(0xd7),
		104:  uint8(0xd9),
		105:  uint8(0xd4),
		106:  uint8(0xdc),
		107:  uint8(0xda),
		108:  uint8(0xde),
		109:  uint8(0xd8),
		110:  uint8(0xd2),
		111:  uint8(0xdd),
		112:  uint8(0xd0),
		113:  uint8(0xdf),
		114:  uint8(0xd6),
		115:  uint8(0xdc),
		116:  uint8(0xda),
		117:  uint8(0xd9),
		118:  uint8(0xdd),
		119:  uint8(0xd0),
		120:  uint8(0xdf),
		121:  uint8(0xd3),
		122:  uint8(0xd3),
		123:  uint8(0xd5),
		124:  uint8(0xd5),
		125:  uint8(0xd6),
		126:  uint8(0xd8),
		127:  uint8(0xdb),
		128:  uint8(0xbd),
		129:  uint8(0xb1),
		130:  uint8(0xb2),
		131:  uint8(0xbf),
		132:  uint8(0xb8),
		133:  uint8(0xbd),
		134:  uint8(0xb4),
		135:  uint8(0xb8),
		136:  uint8(0xb6),
		137:  uint8(0xba),
		138:  uint8(0xbf),
		139:  uint8(0xb3),
		140:  uint8(0xbb),
		141:  uint8(0xb7),
		142:  uint8(0xb1),
		143:  uint8(0xb4),
		144:  uint8(0xba),
		145:  uint8(0xbc),
		146:  uint8(0xb9),
		147:  uint8(0xb5),
		148:  uint8(0xb3),
		149:  uint8(0xb6),
		150:  uint8(0xbe),
		151:  uint8(0xbb),
		152:  uint8(0xb5),
		153:  uint8(0xb0),
		154:  uint8(0xb0),
		155:  uint8(0xbe),
		156:  uint8(0xbc),
		157:  uint8(0xb9),
		158:  uint8(0xb7),
		159:  uint8(0xb2),
		160:  uint8(0xb7),
		161:  uint8(0xb2),
		162:  uint8(0xbb),
		163:  uint8(0xb1),
		164:  uint8(0xb4),
		165:  uint8(0xbe),
		166:  uint8(0xb1),
		167:  uint8(0xb7),
		168:  uint8(0xb9),
		169:  uint8(0xb4),
		170:  uint8(0xbc),
		171:  uint8(0xba),
		172:  uint8(0xbe),
		173:  uint8(0xb8),
		174:  uint8(0xb2),
		175:  uint8(0xbd),
		176:  uint8(0xb0),
		177:  uint8(0xbf),
		178:  uint8(0xb6),
		179:  uint8(0xbc),
		180:  uint8(0xba),
		181:  uint8(0xb9),
		182:  uint8(0xbd),
		183:  uint8(0xb0),
		184:  uint8(0xbf),
		185:  uint8(0xb3),
		186:  uint8(0xb3),
		187:  uint8(0xb5),
		188:  uint8(0xb5),
		189:  uint8(0xb6),
		190:  uint8(0xb8),
		191:  uint8(0xbb),
		192:  uint8(0x0d),
		193:  uint8(0x01),
		194:  uint8(0x02),
		195:  uint8(0x0f),
		196:  uint8(0x08),
		197:  uint8(0x0d),
		198:  uint8(0x04),
		199:  uint8(0x08),
		200:  uint8(0x06),
		201:  uint8(0x0a),
		202:  uint8(0x0f),
		203:  uint8(0x03),
		204:  uint8(0x0b),
		205:  uint8(0x07),
		206:  uint8(0x01),
		207:  uint8(0x04),
		208:  uint8(0x0a),
		209:  uint8(0x0c),
		210:  uint8(0x09),
		211:  uint8(0x05),
		212:  uint8(0x03),
		213:  uint8(0x06),
		214:  uint8(0x0e),
		215:  uint8(0x0b),
		216:  uint8(0x05),
		217:  uint8(0x00),
		218:  uint8(0x00),
		219:  uint8(0x0e),
		220:  uint8(0x0c),
		221:  uint8(0x09),
		222:  uint8(0x07),
		223:  uint8(0x02),
		224:  uint8(0x07),
		225:  uint8(0x02),
		226:  uint8(0x0b),
		227:  uint8(0x01),
		228:  uint8(0x04),
		229:  uint8(0x0e),
		230:  uint8(0x01),
		231:  uint8(0x07),
		232:  uint8(0x09),
		233:  uint8(0x04),
		234:  uint8(0x0c),
		235:  uint8(0x0a),
		236:  uint8(0x0e),
		237:  uint8(0x08),
		238:  uint8(0x02),
		239:  uint8(0x0d),
		240:  uint8(0x00),
		241:  uint8(0x0f),
		242:  uint8(0x06),
		243:  uint8(0x0c),
		244:  uint8(0x0a),
		245:  uint8(0x09),
		246:  uint8(0x0d),
		247:  uint8(0x00),
		248:  uint8(0x0f),
		249:  uint8(0x03),
		250:  uint8(0x03),
		251:  uint8(0x05),
		252:  uint8(0x05),
		253:  uint8(0x06),
		254:  uint8(0x08),
		255:  uint8(0x0b),
		256:  uint8(0x2d),
		257:  uint8(0x21),
		258:  uint8(0x22),
		259:  uint8(0x2f),
		260:  uint8(0x28),
		261:  uint8(0x2d),
		262:  uint8(0x24),
		263:  uint8(0x28),
		264:  uint8(0x26),
		265:  uint8(0x2a),
		266:  uint8(0x2f),
		267:  uint8(0x23),
		268:  uint8(0x2b),
		269:  uint8(0x27),
		270:  uint8(0x21),
		271:  uint8(0x24),
		272:  uint8(0x2a),
		273:  uint8(0x2c),
		274:  uint8(0x29),
		275:  uint8(0x25),
		276:  uint8(0x23),
		277:  uint8(0x26),
		278:  uint8(0x2e),
		279:  uint8(0x2b),
		280:  uint8(0x25),
		281:  uint8(0x20),
		282:  uint8(0x20),
		283:  uint8(0x2e),
		284:  uint8(0x2c),
		285:  uint8(0x29),
		286:  uint8(0x27),
		287:  uint8(0x22),
		288:  uint8(0x27),
		289:  uint8(0x22),
		290:  uint8(0x2b),
		291:  uint8(0x21),
		292:  uint8(0x24),
		293:  uint8(0x2e),
		294:  uint8(0x21),
		295:  uint8(0x27),
		296:  uint8(0x29),
		297:  uint8(0x24),
		298:  uint8(0x2c),
		299:  uint8(0x2a),
		300:  uint8(0x2e),
		301:  uint8(0x28),
		302:  uint8(0x22),
		303:  uint8(0x2d),
		304:  uint8(0x20),
		305:  uint8(0x2f),
		306:  uint8(0x26),
		307:  uint8(0x2c),
		308:  uint8(0x2a),
		309:  uint8(0x29),
		310:  uint8(0x2d),
		311:  uint8(0x20),
		312:  uint8(0x2f),
		313:  uint8(0x23),
		314:  uint8(0x23),
		315:  uint8(0x25),
		316:  uint8(0x25),
		317:  uint8(0x26),
		318:  uint8(0x28),
		319:  uint8(0x2b),
		320:  uint8(0xbd),
		321:  uint8(0xb1),
		322:  uint8(0xb2),
		323:  uint8(0xbf),
		324:  uint8(0xb8),
		325:  uint8(0xbd),
		326:  uint8(0xb4),
		327:  uint8(0xb8),
		328:  uint8(0xb6),
		329:  uint8(0xba),
		330:  uint8(0xbf),
		331:  uint8(0xb3),
		332:  uint8(0xbb),
		333:  uint8(0xb7),
		334:  uint8(0xb1),
		335:  uint8(0xb4),
		336:  uint8(0xba),
		337:  uint8(0xbc),
		338:  uint8(0xb9),
		339:  uint8(0xb5),
		340:  uint8(0xb3),
		341:  uint8(0xb6),
		342:  uint8(0xbe),
		343:  uint8(0xbb),
		344:  uint8(0xb5),
		345:  uint8(0xb0),
		346:  uint8(0xb0),
		347:  uint8(0xbe),
		348:  uint8(0xbc),
		349:  uint8(0xb9),
		350:  uint8(0xb7),
		351:  uint8(0xb2),
		352:  uint8(0xb7),
		353:  uint8(0xb2),
		354:  uint8(0xbb),
		355:  uint8(0xb1),
		356:  uint8(0xb4),
		357:  uint8(0xbe),
		358:  uint8(0xb1),
		359:  uint8(0xb7),
		360:  uint8(0xb9),
		361:  uint8(0xb4),
		362:  uint8(0xbc),
		363:  uint8(0xba),
		364:  uint8(0xbe),
		365:  uint8(0xb8),
		366:  uint8(0xb2),
		367:  uint8(0xbd),
		368:  uint8(0xb0),
		369:  uint8(0xbf),
		370:  uint8(0xb6),
		371:  uint8(0xbc),
		372:  uint8(0xba),
		373:  uint8(0xb9),
		374:  uint8(0xbd),
		375:  uint8(0xb0),
		376:  uint8(0xbf),
		377:  uint8(0xb3),
		378:  uint8(0xb3),
		379:  uint8(0xb5),
		380:  uint8(0xb5),
		381:  uint8(0xb6),
		382:  uint8(0xb8),
		383:  uint8(0xbb),
		384:  uint8(0xed),
		385:  uint8(0xe1),
		386:  uint8(0xe2),
		387:  uint8(0xef),
		388:  uint8(0xe8),
		389:  uint8(0xed),
		390:  uint8(0xe4),
		391:  uint8(0xe8),
		392:  uint8(0xe6),
		393:  uint8(0xea),
		394:  uint8(0xef),
		395:  uint8(0xe3),
		396:  uint8(0xeb),
		397:  uint8(0xe7),
		398:  uint8(0xe1),
		399:  uint8(0xe4),
		400:  uint8(0xea),
		401:  uint8(0xec),
		402:  uint8(0xe9),
		403:  uint8(0xe5),
		404:  uint8(0xe3),
		405:  uint8(0xe6),
		406:  uint8(0xee),
		407:  uint8(0xeb),
		408:  uint8(0xe5),
		409:  uint8(0xe0),
		410:  uint8(0xe0),
		411:  uint8(0xee),
		412:  uint8(0xec),
		413:  uint8(0xe9),
		414:  uint8(0xe7),
		415:  uint8(0xe2),
		416:  uint8(0xe7),
		417:  uint8(0xe2),
		418:  uint8(0xeb),
		419:  uint8(0xe1),
		420:  uint8(0xe4),
		421:  uint8(0xee),
		422:  uint8(0xe1),
		423:  uint8(0xe7),
		424:  uint8(0xe9),
		425:  uint8(0xe4),
		426:  uint8(0xec),
		427:  uint8(0xea),
		428:  uint8(0xee),
		429:  uint8(0xe8),
		430:  uint8(0xe2),
		431:  uint8(0xed),
		432:  uint8(0xe0),
		433:  uint8(0xef),
		434:  uint8(0xe6),
		435:  uint8(0xec),
		436:  uint8(0xea),
		437:  uint8(0xe9),
		438:  uint8(0xed),
		439:  uint8(0xe0),
		440:  uint8(0xef),
		441:  uint8(0xe3),
		442:  uint8(0xe3),
		443:  uint8(0xe5),
		444:  uint8(0xe5),
		445:  uint8(0xe6),
		446:  uint8(0xe8),
		447:  uint8(0xeb),
		448:  uint8(0x7d),
		449:  uint8(0x71),
		450:  uint8(0x72),
		451:  uint8(0x7f),
		452:  uint8(0x78),
		453:  uint8(0x7d),
		454:  uint8(0x74),
		455:  uint8(0x78),
		456:  uint8(0x76),
		457:  uint8(0x7a),
		458:  uint8(0x7f),
		459:  uint8(0x73),
		460:  uint8(0x7b),
		461:  uint8(0x77),
		462:  uint8(0x71),
		463:  uint8(0x74),
		464:  uint8(0x7a),
		465:  uint8(0x7c),
		466:  uint8(0x79),
		467:  uint8(0x75),
		468:  uint8(0x73),
		469:  uint8(0x76),
		470:  uint8(0x7e),
		471:  uint8(0x7b),
		472:  uint8(0x75),
		473:  uint8(0x70),
		474:  uint8(0x70),
		475:  uint8(0x7e),
		476:  uint8(0x7c),
		477:  uint8(0x79),
		478:  uint8(0x77),
		479:  uint8(0x72),
		480:  uint8(0x77),
		481:  uint8(0x72),
		482:  uint8(0x7b),
		483:  uint8(0x71),
		484:  uint8(0x74),
		485:  uint8(0x7e),
		486:  uint8(0x71),
		487:  uint8(0x77),
		488:  uint8(0x79),
		489:  uint8(0x74),
		490:  uint8(0x7c),
		491:  uint8(0x7a),
		492:  uint8(0x7e),
		493:  uint8(0x78),
		494:  uint8(0x72),
		495:  uint8(0x7d),
		496:  uint8(0x70),
		497:  uint8(0x7f),
		498:  uint8(0x76),
		499:  uint8(0x7c),
		500:  uint8(0x7a),
		501:  uint8(0x79),
		502:  uint8(0x7d),
		503:  uint8(0x70),
		504:  uint8(0x7f),
		505:  uint8(0x73),
		506:  uint8(0x73),
		507:  uint8(0x75),
		508:  uint8(0x75),
		509:  uint8(0x76),
		510:  uint8(0x78),
		511:  uint8(0x7b),
		512:  uint8(0xfd),
		513:  uint8(0xf1),
		514:  uint8(0xf2),
		515:  uint8(0xff),
		516:  uint8(0xf8),
		517:  uint8(0xfd),
		518:  uint8(0xf4),
		519:  uint8(0xf8),
		520:  uint8(0xf6),
		521:  uint8(0xfa),
		522:  uint8(0xff),
		523:  uint8(0xf3),
		524:  uint8(0xfb),
		525:  uint8(0xf7),
		526:  uint8(0xf1),
		527:  uint8(0xf4),
		528:  uint8(0xfa),
		529:  uint8(0xfc),
		530:  uint8(0xf9),
		531:  uint8(0xf5),
		532:  uint8(0xf3),
		533:  uint8(0xf6),
		534:  uint8(0xfe),
		535:  uint8(0xfb),
		536:  uint8(0xf5),
		537:  uint8(0xf0),
		538:  uint8(0xf0),
		539:  uint8(0xfe),
		540:  uint8(0xfc),
		541:  uint8(0xf9),
		542:  uint8(0xf7),
		543:  uint8(0xf2),
		544:  uint8(0xf7),
		545:  uint8(0xf2),
		546:  uint8(0xfb),
		547:  uint8(0xf1),
		548:  uint8(0xf4),
		549:  uint8(0xfe),
		550:  uint8(0xf1),
		551:  uint8(0xf7),
		552:  uint8(0xf9),
		553:  uint8(0xf4),
		554:  uint8(0xfc),
		555:  uint8(0xfa),
		556:  uint8(0xfe),
		557:  uint8(0xf8),
		558:  uint8(0xf2),
		559:  uint8(0xfd),
		560:  uint8(0xf0),
		561:  uint8(0xff),
		562:  uint8(0xf6),
		563:  uint8(0xfc),
		564:  uint8(0xfa),
		565:  uint8(0xf9),
		566:  uint8(0xfd),
		567:  uint8(0xf0),
		568:  uint8(0xff),
		569:  uint8(0xf3),
		570:  uint8(0xf3),
		571:  uint8(0xf5),
		572:  uint8(0xf5),
		573:  uint8(0xf6),
		574:  uint8(0xf8),
		575:  uint8(0xfb),
		576:  uint8(0x4d),
		577:  uint8(0x41),
		578:  uint8(0x42),
		579:  uint8(0x4f),
		580:  uint8(0x48),
		581:  uint8(0x4d),
		582:  uint8(0x44),
		583:  uint8(0x48),
		584:  uint8(0x46),
		585:  uint8(0x4a),
		586:  uint8(0x4f),
		587:  uint8(0x43),
		588:  uint8(0x4b),
		589:  uint8(0x47),
		590:  uint8(0x41),
		591:  uint8(0x44),
		592:  uint8(0x4a),
		593:  uint8(0x4c),
		594:  uint8(0x49),
		595:  uint8(0x45),
		596:  uint8(0x43),
		597:  uint8(0x46),
		598:  uint8(0x4e),
		599:  uint8(0x4b),
		600:  uint8(0x45),
		601:  uint8(0x40),
		602:  uint8(0x40),
		603:  uint8(0x4e),
		604:  uint8(0x4c),
		605:  uint8(0x49),
		606:  uint8(0x47),
		607:  uint8(0x42),
		608:  uint8(0x47),
		609:  uint8(0x42),
		610:  uint8(0x4b),
		611:  uint8(0x41),
		612:  uint8(0x44),
		613:  uint8(0x4e),
		614:  uint8(0x41),
		615:  uint8(0x47),
		616:  uint8(0x49),
		617:  uint8(0x44),
		618:  uint8(0x4c),
		619:  uint8(0x4a),
		620:  uint8(0x4e),
		621:  uint8(0x48),
		622:  uint8(0x42),
		623:  uint8(0x4d),
		624:  uint8(0x40),
		625:  uint8(0x4f),
		626:  uint8(0x46),
		627:  uint8(0x4c),
		628:  uint8(0x4a),
		629:  uint8(0x49),
		630:  uint8(0x4d),
		631:  uint8(0x40),
		632:  uint8(0x4f),
		633:  uint8(0x43),
		634:  uint8(0x43),
		635:  uint8(0x45),
		636:  uint8(0x45),
		637:  uint8(0x46),
		638:  uint8(0x48),
		639:  uint8(0x4b),
		640:  uint8(0x0d),
		641:  uint8(0x01),
		642:  uint8(0x02),
		643:  uint8(0x0f),
		644:  uint8(0x08),
		645:  uint8(0x0d),
		646:  uint8(0x04),
		647:  uint8(0x08),
		648:  uint8(0x06),
		649:  uint8(0x0a),
		650:  uint8(0x0f),
		651:  uint8(0x03),
		652:  uint8(0x0b),
		653:  uint8(0x07),
		654:  uint8(0x01),
		655:  uint8(0x04),
		656:  uint8(0x0a),
		657:  uint8(0x0c),
		658:  uint8(0x09),
		659:  uint8(0x05),
		660:  uint8(0x03),
		661:  uint8(0x06),
		662:  uint8(0x0e),
		663:  uint8(0x0b),
		664:  uint8(0x05),
		665:  uint8(0x00),
		666:  uint8(0x00),
		667:  uint8(0x0e),
		668:  uint8(0x0c),
		669:  uint8(0x09),
		670:  uint8(0x07),
		671:  uint8(0x02),
		672:  uint8(0x07),
		673:  uint8(0x02),
		674:  uint8(0x0b),
		675:  uint8(0x01),
		676:  uint8(0x04),
		677:  uint8(0x0e),
		678:  uint8(0x01),
		679:  uint8(0x07),
		680:  uint8(0x09),
		681:  uint8(0x04),
		682:  uint8(0x0c),
		683:  uint8(0x0a),
		684:  uint8(0x0e),
		685:  uint8(0x08),
		686:  uint8(0x02),
		687:  uint8(0x0d),
		688:  uint8(0x00),
		689:  uint8(0x0f),
		690:  uint8(0x06),
		691:  uint8(0x0c),
		692:  uint8(0x0a),
		693:  uint8(0x09),
		694:  uint8(0x0d),
		695:  uint8(0x00),
		696:  uint8(0x0f),
		697:  uint8(0x03),
		698:  uint8(0x03),
		699:  uint8(0x05),
		700:  uint8(0x05),
		701:  uint8(0x06),
		702:  uint8(0x08),
		703:  uint8(0x0b),
		704:  uint8(0x9d),
		705:  uint8(0x91),
		706:  uint8(0x92),
		707:  uint8(0x9f),
		708:  uint8(0x98),
		709:  uint8(0x9d),
		710:  uint8(0x94),
		711:  uint8(0x98),
		712:  uint8(0x96),
		713:  uint8(0x9a),
		714:  uint8(0x9f),
		715:  uint8(0x93),
		716:  uint8(0x9b),
		717:  uint8(0x97),
		718:  uint8(0x91),
		719:  uint8(0x94),
		720:  uint8(0x9a),
		721:  uint8(0x9c),
		722:  uint8(0x99),
		723:  uint8(0x95),
		724:  uint8(0x93),
		725:  uint8(0x96),
		726:  uint8(0x9e),
		727:  uint8(0x9b),
		728:  uint8(0x95),
		729:  uint8(0x90),
		730:  uint8(0x90),
		731:  uint8(0x9e),
		732:  uint8(0x9c),
		733:  uint8(0x99),
		734:  uint8(0x97),
		735:  uint8(0x92),
		736:  uint8(0x97),
		737:  uint8(0x92),
		738:  uint8(0x9b),
		739:  uint8(0x91),
		740:  uint8(0x94),
		741:  uint8(0x9e),
		742:  uint8(0x91),
		743:  uint8(0x97),
		744:  uint8(0x99),
		745:  uint8(0x94),
		746:  uint8(0x9c),
		747:  uint8(0x9a),
		748:  uint8(0x9e),
		749:  uint8(0x98),
		750:  uint8(0x92),
		751:  uint8(0x9d),
		752:  uint8(0x90),
		753:  uint8(0x9f),
		754:  uint8(0x96),
		755:  uint8(0x9c),
		756:  uint8(0x9a),
		757:  uint8(0x99),
		758:  uint8(0x9d),
		759:  uint8(0x90),
		760:  uint8(0x9f),
		761:  uint8(0x93),
		762:  uint8(0x93),
		763:  uint8(0x95),
		764:  uint8(0x95),
		765:  uint8(0x96),
		766:  uint8(0x98),
		767:  uint8(0x9b),
		768:  uint8(0x8d),
		769:  uint8(0x81),
		770:  uint8(0x82),
		771:  uint8(0x8f),
		772:  uint8(0x88),
		773:  uint8(0x8d),
		774:  uint8(0x84),
		775:  uint8(0x88),
		776:  uint8(0x86),
		777:  uint8(0x8a),
		778:  uint8(0x8f),
		779:  uint8(0x83),
		780:  uint8(0x8b),
		781:  uint8(0x87),
		782:  uint8(0x81),
		783:  uint8(0x84),
		784:  uint8(0x8a),
		785:  uint8(0x8c),
		786:  uint8(0x89),
		787:  uint8(0x85),
		788:  uint8(0x83),
		789:  uint8(0x86),
		790:  uint8(0x8e),
		791:  uint8(0x8b),
		792:  uint8(0x85),
		793:  uint8(0x80),
		794:  uint8(0x80),
		795:  uint8(0x8e),
		796:  uint8(0x8c),
		797:  uint8(0x89),
		798:  uint8(0x87),
		799:  uint8(0x82),
		800:  uint8(0x87),
		801:  uint8(0x82),
		802:  uint8(0x8b),
		803:  uint8(0x81),
		804:  uint8(0x84),
		805:  uint8(0x8e),
		806:  uint8(0x81),
		807:  uint8(0x87),
		808:  uint8(0x89),
		809:  uint8(0x84),
		810:  uint8(0x8c),
		811:  uint8(0x8a),
		812:  uint8(0x8e),
		813:  uint8(0x88),
		814:  uint8(0x82),
		815:  uint8(0x8d),
		816:  uint8(0x80),
		817:  uint8(0x8f),
		818:  uint8(0x86),
		819:  uint8(0x8c),
		820:  uint8(0x8a),
		821:  uint8(0x89),
		822:  uint8(0x8d),
		823:  uint8(0x80),
		824:  uint8(0x8f),
		825:  uint8(0x83),
		826:  uint8(0x83),
		827:  uint8(0x85),
		828:  uint8(0x85),
		829:  uint8(0x86),
		830:  uint8(0x88),
		831:  uint8(0x8b),
		832:  uint8(0x1d),
		833:  uint8(0x11),
		834:  uint8(0x12),
		835:  uint8(0x1f),
		836:  uint8(0x18),
		837:  uint8(0x1d),
		838:  uint8(0x14),
		839:  uint8(0x18),
		840:  uint8(0x16),
		841:  uint8(0x1a),
		842:  uint8(0x1f),
		843:  uint8(0x13),
		844:  uint8(0x1b),
		845:  uint8(0x17),
		846:  uint8(0x11),
		847:  uint8(0x14),
		848:  uint8(0x1a),
		849:  uint8(0x1c),
		850:  uint8(0x19),
		851:  uint8(0x15),
		852:  uint8(0x13),
		853:  uint8(0x16),
		854:  uint8(0x1e),
		855:  uint8(0x1b),
		856:  uint8(0x15),
		857:  uint8(0x10),
		858:  uint8(0x10),
		859:  uint8(0x1e),
		860:  uint8(0x1c),
		861:  uint8(0x19),
		862:  uint8(0x17),
		863:  uint8(0x12),
		864:  uint8(0x17),
		865:  uint8(0x12),
		866:  uint8(0x1b),
		867:  uint8(0x11),
		868:  uint8(0x14),
		869:  uint8(0x1e),
		870:  uint8(0x11),
		871:  uint8(0x17),
		872:  uint8(0x19),
		873:  uint8(0x14),
		874:  uint8(0x1c),
		875:  uint8(0x1a),
		876:  uint8(0x1e),
		877:  uint8(0x18),
		878:  uint8(0x12),
		879:  uint8(0x1d),
		880:  uint8(0x10),
		881:  uint8(0x1f),
		882:  uint8(0x16),
		883:  uint8(0x1c),
		884:  uint8(0x1a),
		885:  uint8(0x19),
		886:  uint8(0x1d),
		887:  uint8(0x10),
		888:  uint8(0x1f),
		889:  uint8(0x13),
		890:  uint8(0x13),
		891:  uint8(0x15),
		892:  uint8(0x15),
		893:  uint8(0x16),
		894:  uint8(0x18),
		895:  uint8(0x1b),
		896:  uint8(0xdd),
		897:  uint8(0xd1),
		898:  uint8(0xd2),
		899:  uint8(0xdf),
		900:  uint8(0xd8),
		901:  uint8(0xdd),
		902:  uint8(0xd4),
		903:  uint8(0xd8),
		904:  uint8(0xd6),
		905:  uint8(0xda),
		906:  uint8(0xdf),
		907:  uint8(0xd3),
		908:  uint8(0xdb),
		909:  uint8(0xd7),
		910:  uint8(0xd1),
		911:  uint8(0xd4),
		912:  uint8(0xda),
		913:  uint8(0xdc),
		914:  uint8(0xd9),
		915:  uint8(0xd5),
		916:  uint8(0xd3),
		917:  uint8(0xd6),
		918:  uint8(0xde),
		919:  uint8(0xdb),
		920:  uint8(0xd5),
		921:  uint8(0xd0),
		922:  uint8(0xd0),
		923:  uint8(0xde),
		924:  uint8(0xdc),
		925:  uint8(0xd9),
		926:  uint8(0xd7),
		927:  uint8(0xd2),
		928:  uint8(0xd7),
		929:  uint8(0xd2),
		930:  uint8(0xdb),
		931:  uint8(0xd1),
		932:  uint8(0xd4),
		933:  uint8(0xde),
		934:  uint8(0xd1),
		935:  uint8(0xd7),
		936:  uint8(0xd9),
		937:  uint8(0xd4),
		938:  uint8(0xdc),
		939:  uint8(0xda),
		940:  uint8(0xde),
		941:  uint8(0xd8),
		942:  uint8(0xd2),
		943:  uint8(0xdd),
		944:  uint8(0xd0),
		945:  uint8(0xdf),
		946:  uint8(0xd6),
		947:  uint8(0xdc),
		948:  uint8(0xda),
		949:  uint8(0xd9),
		950:  uint8(0xdd),
		951:  uint8(0xd0),
		952:  uint8(0xdf),
		953:  uint8(0xd3),
		954:  uint8(0xd3),
		955:  uint8(0xd5),
		956:  uint8(0xd5),
		957:  uint8(0xd6),
		958:  uint8(0xd8),
		959:  uint8(0xdb),
		960:  uint8(0xad),
		961:  uint8(0xa1),
		962:  uint8(0xa2),
		963:  uint8(0xaf),
		964:  uint8(0xa8),
		965:  uint8(0xad),
		966:  uint8(0xa4),
		967:  uint8(0xa8),
		968:  uint8(0xa6),
		969:  uint8(0xaa),
		970:  uint8(0xaf),
		971:  uint8(0xa3),
		972:  uint8(0xab),
		973:  uint8(0xa7),
		974:  uint8(0xa1),
		975:  uint8(0xa4),
		976:  uint8(0xaa),
		977:  uint8(0xac),
		978:  uint8(0xa9),
		979:  uint8(0xa5),
		980:  uint8(0xa3),
		981:  uint8(0xa6),
		982:  uint8(0xae),
		983:  uint8(0xab),
		984:  uint8(0xa5),
		985:  uint8(0xa0),
		986:  uint8(0xa0),
		987:  uint8(0xae),
		988:  uint8(0xac),
		989:  uint8(0xa9),
		990:  uint8(0xa7),
		991:  uint8(0xa2),
		992:  uint8(0xa7),
		993:  uint8(0xa2),
		994:  uint8(0xab),
		995:  uint8(0xa1),
		996:  uint8(0xa4),
		997:  uint8(0xae),
		998:  uint8(0xa1),
		999:  uint8(0xa7),
		1000: uint8(0xa9),
		1001: uint8(0xa4),
		1002: uint8(0xac),
		1003: uint8(0xaa),
		1004: uint8(0xae),
		1005: uint8(0xa8),
		1006: uint8(0xa2),
		1007: uint8(0xad),
		1008: uint8(0xa0),
		1009: uint8(0xaf),
		1010: uint8(0xa6),
		1011: uint8(0xac),
		1012: uint8(0xaa),
		1013: uint8(0xa9),
		1014: uint8(0xad),
		1015: uint8(0xa0),
		1016: uint8(0xaf),
		1017: uint8(0xa3),
		1018: uint8(0xa3),
		1019: uint8(0xa5),
		1020: uint8(0xa5),
		1021: uint8(0xa6),
		1022: uint8(0xa8),
		1023: uint8(0xab),
		1024: uint8(0x3d),
		1025: uint8(0x31),
		1026: uint8(0x32),
		1027: uint8(0x3f),
		1028: uint8(0x38),
		1029: uint8(0x3d),
		1030: uint8(0x34),
		1031: uint8(0x38),
		1032: uint8(0x36),
		1033: uint8(0x3a),
		1034: uint8(0x3f),
		1035: uint8(0x33),
		1036: uint8(0x3b),
		1037: uint8(0x37),
		1038: uint8(0x31),
		1039: uint8(0x34),
		1040: uint8(0x3a),
		1041: uint8(0x3c),
		1042: uint8(0x39),
		1043: uint8(0x35),
		1044: uint8(0x33),
		1045: uint8(0x36),
		1046: uint8(0x3e),
		1047: uint8(0x3b),
		1048: uint8(0x35),
		1049: uint8(0x30),
		1050: uint8(0x30),
		1051: uint8(0x3e),
		1052: uint8(0x3c),
		1053: uint8(0x39),
		1054: uint8(0x37),
		1055: uint8(0x32),
		1056: uint8(0x37),
		1057: uint8(0x32),
		1058: uint8(0x3b),
		1059: uint8(0x31),
		1060: uint8(0x34),
		1061: uint8(0x3e),
		1062: uint8(0x31),
		1063: uint8(0x37),
		1064: uint8(0x39),
		1065: uint8(0x34),
		1066: uint8(0x3c),
		1067: uint8(0x3a),
		1068: uint8(0x3e),
		1069: uint8(0x38),
		1070: uint8(0x32),
		1071: uint8(0x3d),
		1072: uint8(0x30),
		1073: uint8(0x3f),
		1074: uint8(0x36),
		1075: uint8(0x3c),
		1076: uint8(0x3a),
		1077: uint8(0x39),
		1078: uint8(0x3d),
		1079: uint8(0x30),
		1080: uint8(0x3f),
		1081: uint8(0x33),
		1082: uint8(0x33),
		1083: uint8(0x35),
		1084: uint8(0x35),
		1085: uint8(0x36),
		1086: uint8(0x38),
		1087: uint8(0x3b),
		1088: uint8(0xed),
		1089: uint8(0xe1),
		1090: uint8(0xe2),
		1091: uint8(0xef),
		1092: uint8(0xe8),
		1093: uint8(0xed),
		1094: uint8(0xe4),
		1095: uint8(0xe8),
		1096: uint8(0xe6),
		1097: uint8(0xea),
		1098: uint8(0xef),
		1099: uint8(0xe3),
		1100: uint8(0xeb),
		1101: uint8(0xe7),
		1102: uint8(0xe1),
		1103: uint8(0xe4),
		1104: uint8(0xea),
		1105: uint8(0xec),
		1106: uint8(0xe9),
		1107: uint8(0xe5),
		1108: uint8(0xe3),
		1109: uint8(0xe6),
		1110: uint8(0xee),
		1111: uint8(0xeb),
		1112: uint8(0xe5),
		1113: uint8(0xe0),
		1114: uint8(0xe0),
		1115: uint8(0xee),
		1116: uint8(0xec),
		1117: uint8(0xe9),
		1118: uint8(0xe7),
		1119: uint8(0xe2),
		1120: uint8(0xe7),
		1121: uint8(0xe2),
		1122: uint8(0xeb),
		1123: uint8(0xe1),
		1124: uint8(0xe4),
		1125: uint8(0xee),
		1126: uint8(0xe1),
		1127: uint8(0xe7),
		1128: uint8(0xe9),
		1129: uint8(0xe4),
		1130: uint8(0xec),
		1131: uint8(0xea),
		1132: uint8(0xee),
		1133: uint8(0xe8),
		1134: uint8(0xe2),
		1135: uint8(0xed),
		1136: uint8(0xe0),
		1137: uint8(0xef),
		1138: uint8(0xe6),
		1139: uint8(0xec),
		1140: uint8(0xea),
		1141: uint8(0xe9),
		1142: uint8(0xed),
		1143: uint8(0xe0),
		1144: uint8(0xef),
		1145: uint8(0xe3),
		1146: uint8(0xe3),
		1147: uint8(0xe5),
		1148: uint8(0xe5),
		1149: uint8(0xe6),
		1150: uint8(0xe8),
		1151: uint8(0xeb),
		1152: uint8(0xcd),
		1153: uint8(0xc1),
		1154: uint8(0xc2),
		1155: uint8(0xcf),
		1156: uint8(0xc8),
		1157: uint8(0xcd),
		1158: uint8(0xc4),
		1159: uint8(0xc8),
		1160: uint8(0xc6),
		1161: uint8(0xca),
		1162: uint8(0xcf),
		1163: uint8(0xc3),
		1164: uint8(0xcb),
		1165: uint8(0xc7),
		1166: uint8(0xc1),
		1167: uint8(0xc4),
		1168: uint8(0xca),
		1169: uint8(0xcc),
		1170: uint8(0xc9),
		1171: uint8(0xc5),
		1172: uint8(0xc3),
		1173: uint8(0xc6),
		1174: uint8(0xce),
		1175: uint8(0xcb),
		1176: uint8(0xc5),
		1177: uint8(0xc0),
		1178: uint8(0xc0),
		1179: uint8(0xce),
		1180: uint8(0xcc),
		1181: uint8(0xc9),
		1182: uint8(0xc7),
		1183: uint8(0xc2),
		1184: uint8(0xc7),
		1185: uint8(0xc2),
		1186: uint8(0xcb),
		1187: uint8(0xc1),
		1188: uint8(0xc4),
		1189: uint8(0xce),
		1190: uint8(0xc1),
		1191: uint8(0xc7),
		1192: uint8(0xc9),
		1193: uint8(0xc4),
		1194: uint8(0xcc),
		1195: uint8(0xca),
		1196: uint8(0xce),
		1197: uint8(0xc8),
		1198: uint8(0xc2),
		1199: uint8(0xcd),
		1200: uint8(0xc0),
		1201: uint8(0xcf),
		1202: uint8(0xc6),
		1203: uint8(0xcc),
		1204: uint8(0xca),
		1205: uint8(0xc9),
		1206: uint8(0xcd),
		1207: uint8(0xc0),
		1208: uint8(0xcf),
		1209: uint8(0xc3),
		1210: uint8(0xc3),
		1211: uint8(0xc5),
		1212: uint8(0xc5),
		1213: uint8(0xc6),
		1214: uint8(0xc8),
		1215: uint8(0xcb),
		1216: uint8(0x3d),
		1217: uint8(0x31),
		1218: uint8(0x32),
		1219: uint8(0x3f),
		1220: uint8(0x38),
		1221: uint8(0x3d),
		1222: uint8(0x34),
		1223: uint8(0x38),
		1224: uint8(0x36),
		1225: uint8(0x3a),
		1226: uint8(0x3f),
		1227: uint8(0x33),
		1228: uint8(0x3b),
		1229: uint8(0x37),
		1230: uint8(0x31),
		1231: uint8(0x34),
		1232: uint8(0x3a),
		1233: uint8(0x3c),
		1234: uint8(0x39),
		1235: uint8(0x35),
		1236: uint8(0x33),
		1237: uint8(0x36),
		1238: uint8(0x3e),
		1239: uint8(0x3b),
		1240: uint8(0x35),
		1241: uint8(0x30),
		1242: uint8(0x30),
		1243: uint8(0x3e),
		1244: uint8(0x3c),
		1245: uint8(0x39),
		1246: uint8(0x37),
		1247: uint8(0x32),
		1248: uint8(0x37),
		1249: uint8(0x32),
		1250: uint8(0x3b),
		1251: uint8(0x31),
		1252: uint8(0x34),
		1253: uint8(0x3e),
		1254: uint8(0x31),
		1255: uint8(0x37),
		1256: uint8(0x39),
		1257: uint8(0x34),
		1258: uint8(0x3c),
		1259: uint8(0x3a),
		1260: uint8(0x3e),
		1261: uint8(0x38),
		1262: uint8(0x32),
		1263: uint8(0x3d),
		1264: uint8(0x30),
		1265: uint8(0x3f),
		1266: uint8(0x36),
		1267: uint8(0x3c),
		1268: uint8(0x3a),
		1269: uint8(0x39),
		1270: uint8(0x3d),
		1271: uint8(0x30),
		1272: uint8(0x3f),
		1273: uint8(0x33),
		1274: uint8(0x33),
		1275: uint8(0x35),
		1276: uint8(0x35),
		1277: uint8(0x36),
		1278: uint8(0x38),
		1279: uint8(0x3b),
		1280: uint8(0x9d),
		1281: uint8(0x91),
		1282: uint8(0x92),
		1283: uint8(0x9f),
		1284: uint8(0x98),
		1285: uint8(0x9d),
		1286: uint8(0x94),
		1287: uint8(0x98),
		1288: uint8(0x96),
		1289: uint8(0x9a),
		1290: uint8(0x9f),
		1291: uint8(0x93),
		1292: uint8(0x9b),
		1293: uint8(0x97),
		1294: uint8(0x91),
		1295: uint8(0x94),
		1296: uint8(0x9a),
		1297: uint8(0x9c),
		1298: uint8(0x99),
		1299: uint8(0x95),
		1300: uint8(0x93),
		1301: uint8(0x96),
		1302: uint8(0x9e),
		1303: uint8(0x9b),
		1304: uint8(0x95),
		1305: uint8(0x90),
		1306: uint8(0x90),
		1307: uint8(0x9e),
		1308: uint8(0x9c),
		1309: uint8(0x99),
		1310: uint8(0x97),
		1311: uint8(0x92),
		1312: uint8(0x97),
		1313: uint8(0x92),
		1314: uint8(0x9b),
		1315: uint8(0x91),
		1316: uint8(0x94),
		1317: uint8(0x9e),
		1318: uint8(0x91),
		1319: uint8(0x97),
		1320: uint8(0x99),
		1321: uint8(0x94),
		1322: uint8(0x9c),
		1323: uint8(0x9a),
		1324: uint8(0x9e),
		1325: uint8(0x98),
		1326: uint8(0x92),
		1327: uint8(0x9d),
		1328: uint8(0x90),
		1329: uint8(0x9f),
		1330: uint8(0x96),
		1331: uint8(0x9c),
		1332: uint8(0x9a),
		1333: uint8(0x99),
		1334: uint8(0x9d),
		1335: uint8(0x90),
		1336: uint8(0x9f),
		1337: uint8(0x93),
		1338: uint8(0x93),
		1339: uint8(0x95),
		1340: uint8(0x95),
		1341: uint8(0x96),
		1342: uint8(0x98),
		1343: uint8(0x9b),
		1344: uint8(0x5d),
		1345: uint8(0x51),
		1346: uint8(0x52),
		1347: uint8(0x5f),
		1348: uint8(0x58),
		1349: uint8(0x5d),
		1350: uint8(0x54),
		1351: uint8(0x58),
		1352: uint8(0x56),
		1353: uint8(0x5a),
		1354: uint8(0x5f),
		1355: uint8(0x53),
		1356: uint8(0x5b),
		1357: uint8(0x57),
		1358: uint8(0x51),
		1359: uint8(0x54),
		1360: uint8(0x5a),
		1361: uint8(0x5c),
		1362: uint8(0x59),
		1363: uint8(0x55),
		1364: uint8(0x53),
		1365: uint8(0x56),
		1366: uint8(0x5e),
		1367: uint8(0x5b),
		1368: uint8(0x55),
		1369: uint8(0x50),
		1370: uint8(0x50),
		1371: uint8(0x5e),
		1372: uint8(0x5c),
		1373: uint8(0x59),
		1374: uint8(0x57),
		1375: uint8(0x52),
		1376: uint8(0x57),
		1377: uint8(0x52),
		1378: uint8(0x5b),
		1379: uint8(0x51),
		1380: uint8(0x54),
		1381: uint8(0x5e),
		1382: uint8(0x51),
		1383: uint8(0x57),
		1384: uint8(0x59),
		1385: uint8(0x54),
		1386: uint8(0x5c),
		1387: uint8(0x5a),
		1388: uint8(0x5e),
		1389: uint8(0x58),
		1390: uint8(0x52),
		1391: uint8(0x5d),
		1392: uint8(0x50),
		1393: uint8(0x5f),
		1394: uint8(0x56),
		1395: uint8(0x5c),
		1396: uint8(0x5a),
		1397: uint8(0x59),
		1398: uint8(0x5d),
		1399: uint8(0x50),
		1400: uint8(0x5f),
		1401: uint8(0x53),
		1402: uint8(0x53),
		1403: uint8(0x55),
		1404: uint8(0x55),
		1405: uint8(0x56),
		1406: uint8(0x58),
		1407: uint8(0x5b),
		1408: uint8(0x7d),
		1409: uint8(0x71),
		1410: uint8(0x72),
		1411: uint8(0x7f),
		1412: uint8(0x78),
		1413: uint8(0x7d),
		1414: uint8(0x74),
		1415: uint8(0x78),
		1416: uint8(0x76),
		1417: uint8(0x7a),
		1418: uint8(0x7f),
		1419: uint8(0x73),
		1420: uint8(0x7b),
		1421: uint8(0x77),
		1422: uint8(0x71),
		1423: uint8(0x74),
		1424: uint8(0x7a),
		1425: uint8(0x7c),
		1426: uint8(0x79),
		1427: uint8(0x75),
		1428: uint8(0x73),
		1429: uint8(0x76),
		1430: uint8(0x7e),
		1431: uint8(0x7b),
		1432: uint8(0x75),
		1433: uint8(0x70),
		1434: uint8(0x70),
		1435: uint8(0x7e),
		1436: uint8(0x7c),
		1437: uint8(0x79),
		1438: uint8(0x77),
		1439: uint8(0x72),
		1440: uint8(0x77),
		1441: uint8(0x72),
		1442: uint8(0x7b),
		1443: uint8(0x71),
		1444: uint8(0x74),
		1445: uint8(0x7e),
		1446: uint8(0x71),
		1447: uint8(0x77),
		1448: uint8(0x79),
		1449: uint8(0x74),
		1450: uint8(0x7c),
		1451: uint8(0x7a),
		1452: uint8(0x7e),
		1453: uint8(0x78),
		1454: uint8(0x72),
		1455: uint8(0x7d),
		1456: uint8(0x70),
		1457: uint8(0x7f),
		1458: uint8(0x76),
		1459: uint8(0x7c),
		1460: uint8(0x7a),
		1461: uint8(0x79),
		1462: uint8(0x7d),
		1463: uint8(0x70),
		1464: uint8(0x7f),
		1465: uint8(0x73),
		1466: uint8(0x73),
		1467: uint8(0x75),
		1468: uint8(0x75),
		1469: uint8(0x76),
		1470: uint8(0x78),
		1471: uint8(0x7b),
		1472: uint8(0xcd),
		1473: uint8(0xc1),
		1474: uint8(0xc2),
		1475: uint8(0xcf),
		1476: uint8(0xc8),
		1477: uint8(0xcd),
		1478: uint8(0xc4),
		1479: uint8(0xc8),
		1480: uint8(0xc6),
		1481: uint8(0xca),
		1482: uint8(0xcf),
		1483: uint8(0xc3),
		1484: uint8(0xcb),
		1485: uint8(0xc7),
		1486: uint8(0xc1),
		1487: uint8(0xc4),
		1488: uint8(0xca),
		1489: uint8(0xcc),
		1490: uint8(0xc9),
		1491: uint8(0xc5),
		1492: uint8(0xc3),
		1493: uint8(0xc6),
		1494: uint8(0xce),
		1495: uint8(0xcb),
		1496: uint8(0xc5),
		1497: uint8(0xc0),
		1498: uint8(0xc0),
		1499: uint8(0xce),
		1500: uint8(0xcc),
		1501: uint8(0xc9),
		1502: uint8(0xc7),
		1503: uint8(0xc2),
		1504: uint8(0xc7),
		1505: uint8(0xc2),
		1506: uint8(0xcb),
		1507: uint8(0xc1),
		1508: uint8(0xc4),
		1509: uint8(0xce),
		1510: uint8(0xc1),
		1511: uint8(0xc7),
		1512: uint8(0xc9),
		1513: uint8(0xc4),
		1514: uint8(0xcc),
		1515: uint8(0xca),
		1516: uint8(0xce),
		1517: uint8(0xc8),
		1518: uint8(0xc2),
		1519: uint8(0xcd),
		1520: uint8(0xc0),
		1521: uint8(0xcf),
		1522: uint8(0xc6),
		1523: uint8(0xcc),
		1524: uint8(0xca),
		1525: uint8(0xc9),
		1526: uint8(0xcd),
		1527: uint8(0xc0),
		1528: uint8(0xcf),
		1529: uint8(0xc3),
		1530: uint8(0xc3),
		1531: uint8(0xc5),
		1532: uint8(0xc5),
		1533: uint8(0xc6),
		1534: uint8(0xc8),
		1535: uint8(0xcb),
		1536: uint8(0x5d),
		1537: uint8(0x51),
		1538: uint8(0x52),
		1539: uint8(0x5f),
		1540: uint8(0x58),
		1541: uint8(0x5d),
		1542: uint8(0x54),
		1543: uint8(0x58),
		1544: uint8(0x56),
		1545: uint8(0x5a),
		1546: uint8(0x5f),
		1547: uint8(0x53),
		1548: uint8(0x5b),
		1549: uint8(0x57),
		1550: uint8(0x51),
		1551: uint8(0x54),
		1552: uint8(0x5a),
		1553: uint8(0x5c),
		1554: uint8(0x59),
		1555: uint8(0x55),
		1556: uint8(0x53),
		1557: uint8(0x56),
		1558: uint8(0x5e),
		1559: uint8(0x5b),
		1560: uint8(0x55),
		1561: uint8(0x50),
		1562: uint8(0x50),
		1563: uint8(0x5e),
		1564: uint8(0x5c),
		1565: uint8(0x59),
		1566: uint8(0x57),
		1567: uint8(0x52),
		1568: uint8(0x57),
		1569: uint8(0x52),
		1570: uint8(0x5b),
		1571: uint8(0x51),
		1572: uint8(0x54),
		1573: uint8(0x5e),
		1574: uint8(0x51),
		1575: uint8(0x57),
		1576: uint8(0x59),
		1577: uint8(0x54),
		1578: uint8(0x5c),
		1579: uint8(0x5a),
		1580: uint8(0x5e),
		1581: uint8(0x58),
		1582: uint8(0x52),
		1583: uint8(0x5d),
		1584: uint8(0x50),
		1585: uint8(0x5f),
		1586: uint8(0x56),
		1587: uint8(0x5c),
		1588: uint8(0x5a),
		1589: uint8(0x59),
		1590: uint8(0x5d),
		1591: uint8(0x50),
		1592: uint8(0x5f),
		1593: uint8(0x53),
		1594: uint8(0x53),
		1595: uint8(0x55),
		1596: uint8(0x55),
		1597: uint8(0x56),
		1598: uint8(0x58),
		1599: uint8(0x5b),
		1600: uint8(0x2d),
		1601: uint8(0x21),
		1602: uint8(0x22),
		1603: uint8(0x2f),
		1604: uint8(0x28),
		1605: uint8(0x2d),
		1606: uint8(0x24),
		1607: uint8(0x28),
		1608: uint8(0x26),
		1609: uint8(0x2a),
		1610: uint8(0x2f),
		1611: uint8(0x23),
		1612: uint8(0x2b),
		1613: uint8(0x27),
		1614: uint8(0x21),
		1615: uint8(0x24),
		1616: uint8(0x2a),
		1617: uint8(0x2c),
		1618: uint8(0x29),
		1619: uint8(0x25),
		1620: uint8(0x23),
		1621: uint8(0x26),
		1622: uint8(0x2e),
		1623: uint8(0x2b),
		1624: uint8(0x25),
		1625: uint8(0x20),
		1626: uint8(0x20),
		1627: uint8(0x2e),
		1628: uint8(0x2c),
		1629: uint8(0x29),
		1630: uint8(0x27),
		1631: uint8(0x22),
		1632: uint8(0x27),
		1633: uint8(0x22),
		1634: uint8(0x2b),
		1635: uint8(0x21),
		1636: uint8(0x24),
		1637: uint8(0x2e),
		1638: uint8(0x21),
		1639: uint8(0x27),
		1640: uint8(0x29),
		1641: uint8(0x24),
		1642: uint8(0x2c),
		1643: uint8(0x2a),
		1644: uint8(0x2e),
		1645: uint8(0x28),
		1646: uint8(0x22),
		1647: uint8(0x2d),
		1648: uint8(0x20),
		1649: uint8(0x2f),
		1650: uint8(0x26),
		1651: uint8(0x2c),
		1652: uint8(0x2a),
		1653: uint8(0x29),
		1654: uint8(0x2d),
		1655: uint8(0x20),
		1656: uint8(0x2f),
		1657: uint8(0x23),
		1658: uint8(0x23),
		1659: uint8(0x25),
		1660: uint8(0x25),
		1661: uint8(0x26),
		1662: uint8(0x28),
		1663: uint8(0x2b),
		1664: uint8(0xad),
		1665: uint8(0xa1),
		1666: uint8(0xa2),
		1667: uint8(0xaf),
		1668: uint8(0xa8),
		1669: uint8(0xad),
		1670: uint8(0xa4),
		1671: uint8(0xa8),
		1672: uint8(0xa6),
		1673: uint8(0xaa),
		1674: uint8(0xaf),
		1675: uint8(0xa3),
		1676: uint8(0xab),
		1677: uint8(0xa7),
		1678: uint8(0xa1),
		1679: uint8(0xa4),
		1680: uint8(0xaa),
		1681: uint8(0xac),
		1682: uint8(0xa9),
		1683: uint8(0xa5),
		1684: uint8(0xa3),
		1685: uint8(0xa6),
		1686: uint8(0xae),
		1687: uint8(0xab),
		1688: uint8(0xa5),
		1689: uint8(0xa0),
		1690: uint8(0xa0),
		1691: uint8(0xae),
		1692: uint8(0xac),
		1693: uint8(0xa9),
		1694: uint8(0xa7),
		1695: uint8(0xa2),
		1696: uint8(0xa7),
		1697: uint8(0xa2),
		1698: uint8(0xab),
		1699: uint8(0xa1),
		1700: uint8(0xa4),
		1701: uint8(0xae),
		1702: uint8(0xa1),
		1703: uint8(0xa7),
		1704: uint8(0xa9),
		1705: uint8(0xa4),
		1706: uint8(0xac),
		1707: uint8(0xaa),
		1708: uint8(0xae),
		1709: uint8(0xa8),
		1710: uint8(0xa2),
		1711: uint8(0xad),
		1712: uint8(0xa0),
		1713: uint8(0xaf),
		1714: uint8(0xa6),
		1715: uint8(0xac),
		1716: uint8(0xaa),
		1717: uint8(0xa9),
		1718: uint8(0xad),
		1719: uint8(0xa0),
		1720: uint8(0xaf),
		1721: uint8(0xa3),
		1722: uint8(0xa3),
		1723: uint8(0xa5),
		1724: uint8(0xa5),
		1725: uint8(0xa6),
		1726: uint8(0xa8),
		1727: uint8(0xab),
		1728: uint8(0xfd),
		1729: uint8(0xf1),
		1730: uint8(0xf2),
		1731: uint8(0xff),
		1732: uint8(0xf8),
		1733: uint8(0xfd),
		1734: uint8(0xf4),
		1735: uint8(0xf8),
		1736: uint8(0xf6),
		1737: uint8(0xfa),
		1738: uint8(0xff),
		1739: uint8(0xf3),
		1740: uint8(0xfb),
		1741: uint8(0xf7),
		1742: uint8(0xf1),
		1743: uint8(0xf4),
		1744: uint8(0xfa),
		1745: uint8(0xfc),
		1746: uint8(0xf9),
		1747: uint8(0xf5),
		1748: uint8(0xf3),
		1749: uint8(0xf6),
		1750: uint8(0xfe),
		1751: uint8(0xfb),
		1752: uint8(0xf5),
		1753: uint8(0xf0),
		1754: uint8(0xf0),
		1755: uint8(0xfe),
		1756: uint8(0xfc),
		1757: uint8(0xf9),
		1758: uint8(0xf7),
		1759: uint8(0xf2),
		1760: uint8(0xf7),
		1761: uint8(0xf2),
		1762: uint8(0xfb),
		1763: uint8(0xf1),
		1764: uint8(0xf4),
		1765: uint8(0xfe),
		1766: uint8(0xf1),
		1767: uint8(0xf7),
		1768: uint8(0xf9),
		1769: uint8(0xf4),
		1770: uint8(0xfc),
		1771: uint8(0xfa),
		1772: uint8(0xfe),
		1773: uint8(0xf8),
		1774: uint8(0xf2),
		1775: uint8(0xfd),
		1776: uint8(0xf0),
		1777: uint8(0xff),
		1778: uint8(0xf6),
		1779: uint8(0xfc),
		1780: uint8(0xfa),
		1781: uint8(0xf9),
		1782: uint8(0xfd),
		1783: uint8(0xf0),
		1784: uint8(0xff),
		1785: uint8(0xf3),
		1786: uint8(0xf3),
		1787: uint8(0xf5),
		1788: uint8(0xf5),
		1789: uint8(0xf6),
		1790: uint8(0xf8),
		1791: uint8(0xfb),
		1792: uint8(0x6d),
		1793: uint8(0x61),
		1794: uint8(0x62),
		1795: uint8(0x6f),
		1796: uint8(0x68),
		1797: uint8(0x6d),
		1798: uint8(0x64),
		1799: uint8(0x68),
		1800: uint8(0x66),
		1801: uint8(0x6a),
		1802: uint8(0x6f),
		1803: uint8(0x63),
		1804: uint8(0x6b),
		1805: uint8(0x67),
		1806: uint8(0x61),
		1807: uint8(0x64),
		1808: uint8(0x6a),
		1809: uint8(0x6c),
		1810: uint8(0x69),
		1811: uint8(0x65),
		1812: uint8(0x63),
		1813: uint8(0x66),
		1814: uint8(0x6e),
		1815: uint8(0x6b),
		1816: uint8(0x65),
		1817: uint8(0x60),
		1818: uint8(0x60),
		1819: uint8(0x6e),
		1820: uint8(0x6c),
		1821: uint8(0x69),
		1822: uint8(0x67),
		1823: uint8(0x62),
		1824: uint8(0x67),
		1825: uint8(0x62),
		1826: uint8(0x6b),
		1827: uint8(0x61),
		1828: uint8(0x64),
		1829: uint8(0x6e),
		1830: uint8(0x61),
		1831: uint8(0x67),
		1832: uint8(0x69),
		1833: uint8(0x64),
		1834: uint8(0x6c),
		1835: uint8(0x6a),
		1836: uint8(0x6e),
		1837: uint8(0x68),
		1838: uint8(0x62),
		1839: uint8(0x6d),
		1840: uint8(0x60),
		1841: uint8(0x6f),
		1842: uint8(0x66),
		1843: uint8(0x6c),
		1844: uint8(0x6a),
		1845: uint8(0x69),
		1846: uint8(0x6d),
		1847: uint8(0x60),
		1848: uint8(0x6f),
		1849: uint8(0x63),
		1850: uint8(0x63),
		1851: uint8(0x65),
		1852: uint8(0x65),
		1853: uint8(0x66),
		1854: uint8(0x68),
		1855: uint8(0x6b),
		1856: uint8(0x8d),
		1857: uint8(0x81),
		1858: uint8(0x82),
		1859: uint8(0x8f),
		1860: uint8(0x88),
		1861: uint8(0x8d),
		1862: uint8(0x84),
		1863: uint8(0x88),
		1864: uint8(0x86),
		1865: uint8(0x8a),
		1866: uint8(0x8f),
		1867: uint8(0x83),
		1868: uint8(0x8b),
		1869: uint8(0x87),
		1870: uint8(0x81),
		1871: uint8(0x84),
		1872: uint8(0x8a),
		1873: uint8(0x8c),
		1874: uint8(0x89),
		1875: uint8(0x85),
		1876: uint8(0x83),
		1877: uint8(0x86),
		1878: uint8(0x8e),
		1879: uint8(0x8b),
		1880: uint8(0x85),
		1881: uint8(0x80),
		1882: uint8(0x80),
		1883: uint8(0x8e),
		1884: uint8(0x8c),
		1885: uint8(0x89),
		1886: uint8(0x87),
		1887: uint8(0x82),
		1888: uint8(0x87),
		1889: uint8(0x82),
		1890: uint8(0x8b),
		1891: uint8(0x81),
		1892: uint8(0x84),
		1893: uint8(0x8e),
		1894: uint8(0x81),
		1895: uint8(0x87),
		1896: uint8(0x89),
		1897: uint8(0x84),
		1898: uint8(0x8c),
		1899: uint8(0x8a),
		1900: uint8(0x8e),
		1901: uint8(0x88),
		1902: uint8(0x82),
		1903: uint8(0x8d),
		1904: uint8(0x80),
		1905: uint8(0x8f),
		1906: uint8(0x86),
		1907: uint8(0x8c),
		1908: uint8(0x8a),
		1909: uint8(0x89),
		1910: uint8(0x8d),
		1911: uint8(0x80),
		1912: uint8(0x8f),
		1913: uint8(0x83),
		1914: uint8(0x83),
		1915: uint8(0x85),
		1916: uint8(0x85),
		1917: uint8(0x86),
		1918: uint8(0x88),
		1919: uint8(0x8b),
		1920: uint8(0x1d),
		1921: uint8(0x11),
		1922: uint8(0x12),
		1923: uint8(0x1f),
		1924: uint8(0x18),
		1925: uint8(0x1d),
		1926: uint8(0x14),
		1927: uint8(0x18),
		1928: uint8(0x16),
		1929: uint8(0x1a),
		1930: uint8(0x1f),
		1931: uint8(0x13),
		1932: uint8(0x1b),
		1933: uint8(0x17),
		1934: uint8(0x11),
		1935: uint8(0x14),
		1936: uint8(0x1a),
		1937: uint8(0x1c),
		1938: uint8(0x19),
		1939: uint8(0x15),
		1940: uint8(0x13),
		1941: uint8(0x16),
		1942: uint8(0x1e),
		1943: uint8(0x1b),
		1944: uint8(0x15),
		1945: uint8(0x10),
		1946: uint8(0x10),
		1947: uint8(0x1e),
		1948: uint8(0x1c),
		1949: uint8(0x19),
		1950: uint8(0x17),
		1951: uint8(0x12),
		1952: uint8(0x17),
		1953: uint8(0x12),
		1954: uint8(0x1b),
		1955: uint8(0x11),
		1956: uint8(0x14),
		1957: uint8(0x1e),
		1958: uint8(0x11),
		1959: uint8(0x17),
		1960: uint8(0x19),
		1961: uint8(0x14),
		1962: uint8(0x1c),
		1963: uint8(0x1a),
		1964: uint8(0x1e),
		1965: uint8(0x18),
		1966: uint8(0x12),
		1967: uint8(0x1d),
		1968: uint8(0x10),
		1969: uint8(0x1f),
		1970: uint8(0x16),
		1971: uint8(0x1c),
		1972: uint8(0x1a),
		1973: uint8(0x19),
		1974: uint8(0x1d),
		1975: uint8(0x10),
		1976: uint8(0x1f),
		1977: uint8(0x13),
		1978: uint8(0x13),
		1979: uint8(0x15),
		1980: uint8(0x15),
		1981: uint8(0x16),
		1982: uint8(0x18),
		1983: uint8(0x1b),
		1984: uint8(0x6d),
		1985: uint8(0x61),
		1986: uint8(0x62),
		1987: uint8(0x6f),
		1988: uint8(0x68),
		1989: uint8(0x6d),
		1990: uint8(0x64),
		1991: uint8(0x68),
		1992: uint8(0x66),
		1993: uint8(0x6a),
		1994: uint8(0x6f),
		1995: uint8(0x63),
		1996: uint8(0x6b),
		1997: uint8(0x67),
		1998: uint8(0x61),
		1999: uint8(0x64),
		2000: uint8(0x6a),
		2001: uint8(0x6c),
		2002: uint8(0x69),
		2003: uint8(0x65),
		2004: uint8(0x63),
		2005: uint8(0x66),
		2006: uint8(0x6e),
		2007: uint8(0x6b),
		2008: uint8(0x65),
		2009: uint8(0x60),
		2010: uint8(0x60),
		2011: uint8(0x6e),
		2012: uint8(0x6c),
		2013: uint8(0x69),
		2014: uint8(0x67),
		2015: uint8(0x62),
		2016: uint8(0x67),
		2017: uint8(0x62),
		2018: uint8(0x6b),
		2019: uint8(0x61),
		2020: uint8(0x64),
		2021: uint8(0x6e),
		2022: uint8(0x61),
		2023: uint8(0x67),
		2024: uint8(0x69),
		2025: uint8(0x64),
		2026: uint8(0x6c),
		2027: uint8(0x6a),
		2028: uint8(0x6e),
		2029: uint8(0x68),
		2030: uint8(0x62),
		2031: uint8(0x6d),
		2032: uint8(0x60),
		2033: uint8(0x6f),
		2034: uint8(0x66),
		2035: uint8(0x6c),
		2036: uint8(0x6a),
		2037: uint8(0x69),
		2038: uint8(0x6d),
		2039: uint8(0x60),
		2040: uint8(0x6f),
		2041: uint8(0x63),
		2042: uint8(0x63),
		2043: uint8(0x65),
		2044: uint8(0x65),
		2045: uint8(0x66),
		2046: uint8(0x68),
		2047: uint8(0x6b),
		2048: uint8(0x1d),
		2049: uint8(0x11),
		2050: uint8(0x12),
		2051: uint8(0x1f),
		2052: uint8(0x18),
		2053: uint8(0x1d),
		2054: uint8(0x14),
		2055: uint8(0x18),
		2056: uint8(0x16),
		2057: uint8(0x1a),
		2058: uint8(0x1f),
		2059: uint8(0x13),
		2060: uint8(0x1b),
		2061: uint8(0x17),
		2062: uint8(0x11),
		2063: uint8(0x14),
		2064: uint8(0x1a),
		2065: uint8(0x1c),
		2066: uint8(0x19),
		2067: uint8(0x15),
		2068: uint8(0x13),
		2069: uint8(0x16),
		2070: uint8(0x1e),
		2071: uint8(0x1b),
		2072: uint8(0x15),
		2073: uint8(0x10),
		2074: uint8(0x10),
		2075: uint8(0x1e),
		2076: uint8(0x1c),
		2077: uint8(0x19),
		2078: uint8(0x17),
		2079: uint8(0x12),
		2080: uint8(0x17),
		2081: uint8(0x12),
		2082: uint8(0x1b),
		2083: uint8(0x11),
		2084: uint8(0x14),
		2085: uint8(0x1e),
		2086: uint8(0x11),
		2087: uint8(0x17),
		2088: uint8(0x19),
		2089: uint8(0x14),
		2090: uint8(0x1c),
		2091: uint8(0x1a),
		2092: uint8(0x1e),
		2093: uint8(0x18),
		2094: uint8(0x12),
		2095: uint8(0x1d),
		2096: uint8(0x10),
		2097: uint8(0x1f),
		2098: uint8(0x16),
		2099: uint8(0x1c),
		2100: uint8(0x1a),
		2101: uint8(0x19),
		2102: uint8(0x1d),
		2103: uint8(0x10),
		2104: uint8(0x1f),
		2105: uint8(0x13),
		2106: uint8(0x13),
		2107: uint8(0x15),
		2108: uint8(0x15),
		2109: uint8(0x16),
		2110: uint8(0x18),
		2111: uint8(0x1b),
		2112: uint8(0x6d),
		2113: uint8(0x61),
		2114: uint8(0x62),
		2115: uint8(0x6f),
		2116: uint8(0x68),
		2117: uint8(0x6d),
		2118: uint8(0x64),
		2119: uint8(0x68),
		2120: uint8(0x66),
		2121: uint8(0x6a),
		2122: uint8(0x6f),
		2123: uint8(0x63),
		2124: uint8(0x6b),
		2125: uint8(0x67),
		2126: uint8(0x61),
		2127: uint8(0x64),
		2128: uint8(0x6a),
		2129: uint8(0x6c),
		2130: uint8(0x69),
		2131: uint8(0x65),
		2132: uint8(0x63),
		2133: uint8(0x66),
		2134: uint8(0x6e),
		2135: uint8(0x6b),
		2136: uint8(0x65),
		2137: uint8(0x60),
		2138: uint8(0x60),
		2139: uint8(0x6e),
		2140: uint8(0x6c),
		2141: uint8(0x69),
		2142: uint8(0x67),
		2143: uint8(0x62),
		2144: uint8(0x67),
		2145: uint8(0x62),
		2146: uint8(0x6b),
		2147: uint8(0x61),
		2148: uint8(0x64),
		2149: uint8(0x6e),
		2150: uint8(0x61),
		2151: uint8(0x67),
		2152: uint8(0x69),
		2153: uint8(0x64),
		2154: uint8(0x6c),
		2155: uint8(0x6a),
		2156: uint8(0x6e),
		2157: uint8(0x68),
		2158: uint8(0x62),
		2159: uint8(0x6d),
		2160: uint8(0x60),
		2161: uint8(0x6f),
		2162: uint8(0x66),
		2163: uint8(0x6c),
		2164: uint8(0x6a),
		2165: uint8(0x69),
		2166: uint8(0x6d),
		2167: uint8(0x60),
		2168: uint8(0x6f),
		2169: uint8(0x63),
		2170: uint8(0x63),
		2171: uint8(0x65),
		2172: uint8(0x65),
		2173: uint8(0x66),
		2174: uint8(0x68),
		2175: uint8(0x6b),
		2176: uint8(0x4d),
		2177: uint8(0x41),
		2178: uint8(0x42),
		2179: uint8(0x4f),
		2180: uint8(0x48),
		2181: uint8(0x4d),
		2182: uint8(0x44),
		2183: uint8(0x48),
		2184: uint8(0x46),
		2185: uint8(0x4a),
		2186: uint8(0x4f),
		2187: uint8(0x43),
		2188: uint8(0x4b),
		2189: uint8(0x47),
		2190: uint8(0x41),
		2191: uint8(0x44),
		2192: uint8(0x4a),
		2193: uint8(0x4c),
		2194: uint8(0x49),
		2195: uint8(0x45),
		2196: uint8(0x43),
		2197: uint8(0x46),
		2198: uint8(0x4e),
		2199: uint8(0x4b),
		2200: uint8(0x45),
		2201: uint8(0x40),
		2202: uint8(0x40),
		2203: uint8(0x4e),
		2204: uint8(0x4c),
		2205: uint8(0x49),
		2206: uint8(0x47),
		2207: uint8(0x42),
		2208: uint8(0x47),
		2209: uint8(0x42),
		2210: uint8(0x4b),
		2211: uint8(0x41),
		2212: uint8(0x44),
		2213: uint8(0x4e),
		2214: uint8(0x41),
		2215: uint8(0x47),
		2216: uint8(0x49),
		2217: uint8(0x44),
		2218: uint8(0x4c),
		2219: uint8(0x4a),
		2220: uint8(0x4e),
		2221: uint8(0x48),
		2222: uint8(0x42),
		2223: uint8(0x4d),
		2224: uint8(0x40),
		2225: uint8(0x4f),
		2226: uint8(0x46),
		2227: uint8(0x4c),
		2228: uint8(0x4a),
		2229: uint8(0x49),
		2230: uint8(0x4d),
		2231: uint8(0x40),
		2232: uint8(0x4f),
		2233: uint8(0x43),
		2234: uint8(0x43),
		2235: uint8(0x45),
		2236: uint8(0x45),
		2237: uint8(0x46),
		2238: uint8(0x48),
		2239: uint8(0x4b),
		2240: uint8(0xbd),
		2241: uint8(0xb1),
		2242: uint8(0xb2),
		2243: uint8(0xbf),
		2244: uint8(0xb8),
		2245: uint8(0xbd),
		2246: uint8(0xb4),
		2247: uint8(0xb8),
		2248: uint8(0xb6),
		2249: uint8(0xba),
		2250: uint8(0xbf),
		2251: uint8(0xb3),
		2252: uint8(0xbb),
		2253: uint8(0xb7),
		2254: uint8(0xb1),
		2255: uint8(0xb4),
		2256: uint8(0xba),
		2257: uint8(0xbc),
		2258: uint8(0xb9),
		2259: uint8(0xb5),
		2260: uint8(0xb3),
		2261: uint8(0xb6),
		2262: uint8(0xbe),
		2263: uint8(0xbb),
		2264: uint8(0xb5),
		2265: uint8(0xb0),
		2266: uint8(0xb0),
		2267: uint8(0xbe),
		2268: uint8(0xbc),
		2269: uint8(0xb9),
		2270: uint8(0xb7),
		2271: uint8(0xb2),
		2272: uint8(0xb7),
		2273: uint8(0xb2),
		2274: uint8(0xbb),
		2275: uint8(0xb1),
		2276: uint8(0xb4),
		2277: uint8(0xbe),
		2278: uint8(0xb1),
		2279: uint8(0xb7),
		2280: uint8(0xb9),
		2281: uint8(0xb4),
		2282: uint8(0xbc),
		2283: uint8(0xba),
		2284: uint8(0xbe),
		2285: uint8(0xb8),
		2286: uint8(0xb2),
		2287: uint8(0xbd),
		2288: uint8(0xb0),
		2289: uint8(0xbf),
		2290: uint8(0xb6),
		2291: uint8(0xbc),
		2292: uint8(0xba),
		2293: uint8(0xb9),
		2294: uint8(0xbd),
		2295: uint8(0xb0),
		2296: uint8(0xbf),
		2297: uint8(0xb3),
		2298: uint8(0xb3),
		2299: uint8(0xb5),
		2300: uint8(0xb5),
		2301: uint8(0xb6),
		2302: uint8(0xb8),
		2303: uint8(0xbb),
		2304: uint8(0xbd),
		2305: uint8(0xb1),
		2306: uint8(0xb2),
		2307: uint8(0xbf),
		2308: uint8(0xb8),
		2309: uint8(0xbd),
		2310: uint8(0xb4),
		2311: uint8(0xb8),
		2312: uint8(0xb6),
		2313: uint8(0xba),
		2314: uint8(0xbf),
		2315: uint8(0xb3),
		2316: uint8(0xbb),
		2317: uint8(0xb7),
		2318: uint8(0xb1),
		2319: uint8(0xb4),
		2320: uint8(0xba),
		2321: uint8(0xbc),
		2322: uint8(0xb9),
		2323: uint8(0xb5),
		2324: uint8(0xb3),
		2325: uint8(0xb6),
		2326: uint8(0xbe),
		2327: uint8(0xbb),
		2328: uint8(0xb5),
		2329: uint8(0xb0),
		2330: uint8(0xb0),
		2331: uint8(0xbe),
		2332: uint8(0xbc),
		2333: uint8(0xb9),
		2334: uint8(0xb7),
		2335: uint8(0xb2),
		2336: uint8(0xb7),
		2337: uint8(0xb2),
		2338: uint8(0xbb),
		2339: uint8(0xb1),
		2340: uint8(0xb4),
		2341: uint8(0xbe),
		2342: uint8(0xb1),
		2343: uint8(0xb7),
		2344: uint8(0xb9),
		2345: uint8(0xb4),
		2346: uint8(0xbc),
		2347: uint8(0xba),
		2348: uint8(0xbe),
		2349: uint8(0xb8),
		2350: uint8(0xb2),
		2351: uint8(0xbd),
		2352: uint8(0xb0),
		2353: uint8(0xbf),
		2354: uint8(0xb6),
		2355: uint8(0xbc),
		2356: uint8(0xba),
		2357: uint8(0xb9),
		2358: uint8(0xbd),
		2359: uint8(0xb0),
		2360: uint8(0xbf),
		2361: uint8(0xb3),
		2362: uint8(0xb3),
		2363: uint8(0xb5),
		2364: uint8(0xb5),
		2365: uint8(0xb6),
		2366: uint8(0xb8),
		2367: uint8(0xbb),
		2368: uint8(0xdd),
		2369: uint8(0xd1),
		2370: uint8(0xd2),
		2371: uint8(0xdf),
		2372: uint8(0xd8),
		2373: uint8(0xdd),
		2374: uint8(0xd4),
		2375: uint8(0xd8),
		2376: uint8(0xd6),
		2377: uint8(0xda),
		2378: uint8(0xdf),
		2379: uint8(0xd3),
		2380: uint8(0xdb),
		2381: uint8(0xd7),
		2382: uint8(0xd1),
		2383: uint8(0xd4),
		2384: uint8(0xda),
		2385: uint8(0xdc),
		2386: uint8(0xd9),
		2387: uint8(0xd5),
		2388: uint8(0xd3),
		2389: uint8(0xd6),
		2390: uint8(0xde),
		2391: uint8(0xdb),
		2392: uint8(0xd5),
		2393: uint8(0xd0),
		2394: uint8(0xd0),
		2395: uint8(0xde),
		2396: uint8(0xdc),
		2397: uint8(0xd9),
		2398: uint8(0xd7),
		2399: uint8(0xd2),
		2400: uint8(0xd7),
		2401: uint8(0xd2),
		2402: uint8(0xdb),
		2403: uint8(0xd1),
		2404: uint8(0xd4),
		2405: uint8(0xde),
		2406: uint8(0xd1),
		2407: uint8(0xd7),
		2408: uint8(0xd9),
		2409: uint8(0xd4),
		2410: uint8(0xdc),
		2411: uint8(0xda),
		2412: uint8(0xde),
		2413: uint8(0xd8),
		2414: uint8(0xd2),
		2415: uint8(0xdd),
		2416: uint8(0xd0),
		2417: uint8(0xdf),
		2418: uint8(0xd6),
		2419: uint8(0xdc),
		2420: uint8(0xda),
		2421: uint8(0xd9),
		2422: uint8(0xdd),
		2423: uint8(0xd0),
		2424: uint8(0xdf),
		2425: uint8(0xd3),
		2426: uint8(0xd3),
		2427: uint8(0xd5),
		2428: uint8(0xd5),
		2429: uint8(0xd6),
		2430: uint8(0xd8),
		2431: uint8(0xdb),
		2432: uint8(0xdd),
		2433: uint8(0xd1),
		2434: uint8(0xd2),
		2435: uint8(0xdf),
		2436: uint8(0xd8),
		2437: uint8(0xdd),
		2438: uint8(0xd4),
		2439: uint8(0xd8),
		2440: uint8(0xd6),
		2441: uint8(0xda),
		2442: uint8(0xdf),
		2443: uint8(0xd3),
		2444: uint8(0xdb),
		2445: uint8(0xd7),
		2446: uint8(0xd1),
		2447: uint8(0xd4),
		2448: uint8(0xda),
		2449: uint8(0xdc),
		2450: uint8(0xd9),
		2451: uint8(0xd5),
		2452: uint8(0xd3),
		2453: uint8(0xd6),
		2454: uint8(0xde),
		2455: uint8(0xdb),
		2456: uint8(0xd5),
		2457: uint8(0xd0),
		2458: uint8(0xd0),
		2459: uint8(0xde),
		2460: uint8(0xdc),
		2461: uint8(0xd9),
		2462: uint8(0xd7),
		2463: uint8(0xd2),
		2464: uint8(0xd7),
		2465: uint8(0xd2),
		2466: uint8(0xdb),
		2467: uint8(0xd1),
		2468: uint8(0xd4),
		2469: uint8(0xde),
		2470: uint8(0xd1),
		2471: uint8(0xd7),
		2472: uint8(0xd9),
		2473: uint8(0xd4),
		2474: uint8(0xdc),
		2475: uint8(0xda),
		2476: uint8(0xde),
		2477: uint8(0xd8),
		2478: uint8(0xd2),
		2479: uint8(0xdd),
		2480: uint8(0xd0),
		2481: uint8(0xdf),
		2482: uint8(0xd6),
		2483: uint8(0xdc),
		2484: uint8(0xda),
		2485: uint8(0xd9),
		2486: uint8(0xdd),
		2487: uint8(0xd0),
		2488: uint8(0xdf),
		2489: uint8(0xd3),
		2490: uint8(0xd3),
		2491: uint8(0xd5),
		2492: uint8(0xd5),
		2493: uint8(0xd6),
		2494: uint8(0xd8),
		2495: uint8(0xdb),
		2496: uint8(0x8d),
		2497: uint8(0x81),
		2498: uint8(0x82),
		2499: uint8(0x8f),
		2500: uint8(0x88),
		2501: uint8(0x8d),
		2502: uint8(0x84),
		2503: uint8(0x88),
		2504: uint8(0x86),
		2505: uint8(0x8a),
		2506: uint8(0x8f),
		2507: uint8(0x83),
		2508: uint8(0x8b),
		2509: uint8(0x87),
		2510: uint8(0x81),
		2511: uint8(0x84),
		2512: uint8(0x8a),
		2513: uint8(0x8c),
		2514: uint8(0x89),
		2515: uint8(0x85),
		2516: uint8(0x83),
		2517: uint8(0x86),
		2518: uint8(0x8e),
		2519: uint8(0x8b),
		2520: uint8(0x85),
		2521: uint8(0x80),
		2522: uint8(0x80),
		2523: uint8(0x8e),
		2524: uint8(0x8c),
		2525: uint8(0x89),
		2526: uint8(0x87),
		2527: uint8(0x82),
		2528: uint8(0x87),
		2529: uint8(0x82),
		2530: uint8(0x8b),
		2531: uint8(0x81),
		2532: uint8(0x84),
		2533: uint8(0x8e),
		2534: uint8(0x81),
		2535: uint8(0x87),
		2536: uint8(0x89),
		2537: uint8(0x84),
		2538: uint8(0x8c),
		2539: uint8(0x8a),
		2540: uint8(0x8e),
		2541: uint8(0x88),
		2542: uint8(0x82),
		2543: uint8(0x8d),
		2544: uint8(0x80),
		2545: uint8(0x8f),
		2546: uint8(0x86),
		2547: uint8(0x8c),
		2548: uint8(0x8a),
		2549: uint8(0x89),
		2550: uint8(0x8d),
		2551: uint8(0x80),
		2552: uint8(0x8f),
		2553: uint8(0x83),
		2554: uint8(0x83),
		2555: uint8(0x85),
		2556: uint8(0x85),
		2557: uint8(0x86),
		2558: uint8(0x88),
		2559: uint8(0x8b),
		2560: uint8(0xcd),
		2561: uint8(0xc1),
		2562: uint8(0xc2),
		2563: uint8(0xcf),
		2564: uint8(0xc8),
		2565: uint8(0xcd),
		2566: uint8(0xc4),
		2567: uint8(0xc8),
		2568: uint8(0xc6),
		2569: uint8(0xca),
		2570: uint8(0xcf),
		2571: uint8(0xc3),
		2572: uint8(0xcb),
		2573: uint8(0xc7),
		2574: uint8(0xc1),
		2575: uint8(0xc4),
		2576: uint8(0xca),
		2577: uint8(0xcc),
		2578: uint8(0xc9),
		2579: uint8(0xc5),
		2580: uint8(0xc3),
		2581: uint8(0xc6),
		2582: uint8(0xce),
		2583: uint8(0xcb),
		2584: uint8(0xc5),
		2585: uint8(0xc0),
		2586: uint8(0xc0),
		2587: uint8(0xce),
		2588: uint8(0xcc),
		2589: uint8(0xc9),
		2590: uint8(0xc7),
		2591: uint8(0xc2),
		2592: uint8(0xc7),
		2593: uint8(0xc2),
		2594: uint8(0xcb),
		2595: uint8(0xc1),
		2596: uint8(0xc4),
		2597: uint8(0xce),
		2598: uint8(0xc1),
		2599: uint8(0xc7),
		2600: uint8(0xc9),
		2601: uint8(0xc4),
		2602: uint8(0xcc),
		2603: uint8(0xca),
		2604: uint8(0xce),
		2605: uint8(0xc8),
		2606: uint8(0xc2),
		2607: uint8(0xcd),
		2608: uint8(0xc0),
		2609: uint8(0xcf),
		2610: uint8(0xc6),
		2611: uint8(0xcc),
		2612: uint8(0xca),
		2613: uint8(0xc9),
		2614: uint8(0xcd),
		2615: uint8(0xc0),
		2616: uint8(0xcf),
		2617: uint8(0xc3),
		2618: uint8(0xc3),
		2619: uint8(0xc5),
		2620: uint8(0xc5),
		2621: uint8(0xc6),
		2622: uint8(0xc8),
		2623: uint8(0xcb),
		2624: uint8(0x1d),
		2625: uint8(0x11),
		2626: uint8(0x12),
		2627: uint8(0x1f),
		2628: uint8(0x18),
		2629: uint8(0x1d),
		2630: uint8(0x14),
		2631: uint8(0x18),
		2632: uint8(0x16),
		2633: uint8(0x1a),
		2634: uint8(0x1f),
		2635: uint8(0x13),
		2636: uint8(0x1b),
		2637: uint8(0x17),
		2638: uint8(0x11),
		2639: uint8(0x14),
		2640: uint8(0x1a),
		2641: uint8(0x1c),
		2642: uint8(0x19),
		2643: uint8(0x15),
		2644: uint8(0x13),
		2645: uint8(0x16),
		2646: uint8(0x1e),
		2647: uint8(0x1b),
		2648: uint8(0x15),
		2649: uint8(0x10),
		2650: uint8(0x10),
		2651: uint8(0x1e),
		2652: uint8(0x1c),
		2653: uint8(0x19),
		2654: uint8(0x17),
		2655: uint8(0x12),
		2656: uint8(0x17),
		2657: uint8(0x12),
		2658: uint8(0x1b),
		2659: uint8(0x11),
		2660: uint8(0x14),
		2661: uint8(0x1e),
		2662: uint8(0x11),
		2663: uint8(0x17),
		2664: uint8(0x19),
		2665: uint8(0x14),
		2666: uint8(0x1c),
		2667: uint8(0x1a),
		2668: uint8(0x1e),
		2669: uint8(0x18),
		2670: uint8(0x12),
		2671: uint8(0x1d),
		2672: uint8(0x10),
		2673: uint8(0x1f),
		2674: uint8(0x16),
		2675: uint8(0x1c),
		2676: uint8(0x1a),
		2677: uint8(0x19),
		2678: uint8(0x1d),
		2679: uint8(0x10),
		2680: uint8(0x1f),
		2681: uint8(0x13),
		2682: uint8(0x13),
		2683: uint8(0x15),
		2684: uint8(0x15),
		2685: uint8(0x16),
		2686: uint8(0x18),
		2687: uint8(0x1b),
		2688: uint8(0x3d),
		2689: uint8(0x31),
		2690: uint8(0x32),
		2691: uint8(0x3f),
		2692: uint8(0x38),
		2693: uint8(0x3d),
		2694: uint8(0x34),
		2695: uint8(0x38),
		2696: uint8(0x36),
		2697: uint8(0x3a),
		2698: uint8(0x3f),
		2699: uint8(0x33),
		2700: uint8(0x3b),
		2701: uint8(0x37),
		2702: uint8(0x31),
		2703: uint8(0x34),
		2704: uint8(0x3a),
		2705: uint8(0x3c),
		2706: uint8(0x39),
		2707: uint8(0x35),
		2708: uint8(0x33),
		2709: uint8(0x36),
		2710: uint8(0x3e),
		2711: uint8(0x3b),
		2712: uint8(0x35),
		2713: uint8(0x30),
		2714: uint8(0x30),
		2715: uint8(0x3e),
		2716: uint8(0x3c),
		2717: uint8(0x39),
		2718: uint8(0x37),
		2719: uint8(0x32),
		2720: uint8(0x37),
		2721: uint8(0x32),
		2722: uint8(0x3b),
		2723: uint8(0x31),
		2724: uint8(0x34),
		2725: uint8(0x3e),
		2726: uint8(0x31),
		2727: uint8(0x37),
		2728: uint8(0x39),
		2729: uint8(0x34),
		2730: uint8(0x3c),
		2731: uint8(0x3a),
		2732: uint8(0x3e),
		2733: uint8(0x38),
		2734: uint8(0x32),
		2735: uint8(0x3d),
		2736: uint8(0x30),
		2737: uint8(0x3f),
		2738: uint8(0x36),
		2739: uint8(0x3c),
		2740: uint8(0x3a),
		2741: uint8(0x39),
		2742: uint8(0x3d),
		2743: uint8(0x30),
		2744: uint8(0x3f),
		2745: uint8(0x33),
		2746: uint8(0x33),
		2747: uint8(0x35),
		2748: uint8(0x35),
		2749: uint8(0x36),
		2750: uint8(0x38),
		2751: uint8(0x3b),
		2752: uint8(0x4d),
		2753: uint8(0x41),
		2754: uint8(0x42),
		2755: uint8(0x4f),
		2756: uint8(0x48),
		2757: uint8(0x4d),
		2758: uint8(0x44),
		2759: uint8(0x48),
		2760: uint8(0x46),
		2761: uint8(0x4a),
		2762: uint8(0x4f),
		2763: uint8(0x43),
		2764: uint8(0x4b),
		2765: uint8(0x47),
		2766: uint8(0x41),
		2767: uint8(0x44),
		2768: uint8(0x4a),
		2769: uint8(0x4c),
		2770: uint8(0x49),
		2771: uint8(0x45),
		2772: uint8(0x43),
		2773: uint8(0x46),
		2774: uint8(0x4e),
		2775: uint8(0x4b),
		2776: uint8(0x45),
		2777: uint8(0x40),
		2778: uint8(0x40),
		2779: uint8(0x4e),
		2780: uint8(0x4c),
		2781: uint8(0x49),
		2782: uint8(0x47),
		2783: uint8(0x42),
		2784: uint8(0x47),
		2785: uint8(0x42),
		2786: uint8(0x4b),
		2787: uint8(0x41),
		2788: uint8(0x44),
		2789: uint8(0x4e),
		2790: uint8(0x41),
		2791: uint8(0x47),
		2792: uint8(0x49),
		2793: uint8(0x44),
		2794: uint8(0x4c),
		2795: uint8(0x4a),
		2796: uint8(0x4e),
		2797: uint8(0x48),
		2798: uint8(0x42),
		2799: uint8(0x4d),
		2800: uint8(0x40),
		2801: uint8(0x4f),
		2802: uint8(0x46),
		2803: uint8(0x4c),
		2804: uint8(0x4a),
		2805: uint8(0x49),
		2806: uint8(0x4d),
		2807: uint8(0x40),
		2808: uint8(0x4f),
		2809: uint8(0x43),
		2810: uint8(0x43),
		2811: uint8(0x45),
		2812: uint8(0x45),
		2813: uint8(0x46),
		2814: uint8(0x48),
		2815: uint8(0x4b),
		2816: uint8(0x7d),
		2817: uint8(0x71),
		2818: uint8(0x72),
		2819: uint8(0x7f),
		2820: uint8(0x78),
		2821: uint8(0x7d),
		2822: uint8(0x74),
		2823: uint8(0x78),
		2824: uint8(0x76),
		2825: uint8(0x7a),
		2826: uint8(0x7f),
		2827: uint8(0x73),
		2828: uint8(0x7b),
		2829: uint8(0x77),
		2830: uint8(0x71),
		2831: uint8(0x74),
		2832: uint8(0x7a),
		2833: uint8(0x7c),
		2834: uint8(0x79),
		2835: uint8(0x75),
		2836: uint8(0x73),
		2837: uint8(0x76),
		2838: uint8(0x7e),
		2839: uint8(0x7b),
		2840: uint8(0x75),
		2841: uint8(0x70),
		2842: uint8(0x70),
		2843: uint8(0x7e),
		2844: uint8(0x7c),
		2845: uint8(0x79),
		2846: uint8(0x77),
		2847: uint8(0x72),
		2848: uint8(0x77),
		2849: uint8(0x72),
		2850: uint8(0x7b),
		2851: uint8(0x71),
		2852: uint8(0x74),
		2853: uint8(0x7e),
		2854: uint8(0x71),
		2855: uint8(0x77),
		2856: uint8(0x79),
		2857: uint8(0x74),
		2858: uint8(0x7c),
		2859: uint8(0x7a),
		2860: uint8(0x7e),
		2861: uint8(0x78),
		2862: uint8(0x72),
		2863: uint8(0x7d),
		2864: uint8(0x70),
		2865: uint8(0x7f),
		2866: uint8(0x76),
		2867: uint8(0x7c),
		2868: uint8(0x7a),
		2869: uint8(0x79),
		2870: uint8(0x7d),
		2871: uint8(0x70),
		2872: uint8(0x7f),
		2873: uint8(0x73),
		2874: uint8(0x73),
		2875: uint8(0x75),
		2876: uint8(0x75),
		2877: uint8(0x76),
		2878: uint8(0x78),
		2879: uint8(0x7b),
		2880: uint8(0xad),
		2881: uint8(0xa1),
		2882: uint8(0xa2),
		2883: uint8(0xaf),
		2884: uint8(0xa8),
		2885: uint8(0xad),
		2886: uint8(0xa4),
		2887: uint8(0xa8),
		2888: uint8(0xa6),
		2889: uint8(0xaa),
		2890: uint8(0xaf),
		2891: uint8(0xa3),
		2892: uint8(0xab),
		2893: uint8(0xa7),
		2894: uint8(0xa1),
		2895: uint8(0xa4),
		2896: uint8(0xaa),
		2897: uint8(0xac),
		2898: uint8(0xa9),
		2899: uint8(0xa5),
		2900: uint8(0xa3),
		2901: uint8(0xa6),
		2902: uint8(0xae),
		2903: uint8(0xab),
		2904: uint8(0xa5),
		2905: uint8(0xa0),
		2906: uint8(0xa0),
		2907: uint8(0xae),
		2908: uint8(0xac),
		2909: uint8(0xa9),
		2910: uint8(0xa7),
		2911: uint8(0xa2),
		2912: uint8(0xa7),
		2913: uint8(0xa2),
		2914: uint8(0xab),
		2915: uint8(0xa1),
		2916: uint8(0xa4),
		2917: uint8(0xae),
		2918: uint8(0xa1),
		2919: uint8(0xa7),
		2920: uint8(0xa9),
		2921: uint8(0xa4),
		2922: uint8(0xac),
		2923: uint8(0xaa),
		2924: uint8(0xae),
		2925: uint8(0xa8),
		2926: uint8(0xa2),
		2927: uint8(0xad),
		2928: uint8(0xa0),
		2929: uint8(0xaf),
		2930: uint8(0xa6),
		2931: uint8(0xac),
		2932: uint8(0xaa),
		2933: uint8(0xa9),
		2934: uint8(0xad),
		2935: uint8(0xa0),
		2936: uint8(0xaf),
		2937: uint8(0xa3),
		2938: uint8(0xa3),
		2939: uint8(0xa5),
		2940: uint8(0xa5),
		2941: uint8(0xa6),
		2942: uint8(0xa8),
		2943: uint8(0xab),
		2944: uint8(0xed),
		2945: uint8(0xe1),
		2946: uint8(0xe2),
		2947: uint8(0xef),
		2948: uint8(0xe8),
		2949: uint8(0xed),
		2950: uint8(0xe4),
		2951: uint8(0xe8),
		2952: uint8(0xe6),
		2953: uint8(0xea),
		2954: uint8(0xef),
		2955: uint8(0xe3),
		2956: uint8(0xeb),
		2957: uint8(0xe7),
		2958: uint8(0xe1),
		2959: uint8(0xe4),
		2960: uint8(0xea),
		2961: uint8(0xec),
		2962: uint8(0xe9),
		2963: uint8(0xe5),
		2964: uint8(0xe3),
		2965: uint8(0xe6),
		2966: uint8(0xee),
		2967: uint8(0xeb),
		2968: uint8(0xe5),
		2969: uint8(0xe0),
		2970: uint8(0xe0),
		2971: uint8(0xee),
		2972: uint8(0xec),
		2973: uint8(0xe9),
		2974: uint8(0xe7),
		2975: uint8(0xe2),
		2976: uint8(0xe7),
		2977: uint8(0xe2),
		2978: uint8(0xeb),
		2979: uint8(0xe1),
		2980: uint8(0xe4),
		2981: uint8(0xee),
		2982: uint8(0xe1),
		2983: uint8(0xe7),
		2984: uint8(0xe9),
		2985: uint8(0xe4),
		2986: uint8(0xec),
		2987: uint8(0xea),
		2988: uint8(0xee),
		2989: uint8(0xe8),
		2990: uint8(0xe2),
		2991: uint8(0xed),
		2992: uint8(0xe0),
		2993: uint8(0xef),
		2994: uint8(0xe6),
		2995: uint8(0xec),
		2996: uint8(0xea),
		2997: uint8(0xe9),
		2998: uint8(0xed),
		2999: uint8(0xe0),
		3000: uint8(0xef),
		3001: uint8(0xe3),
		3002: uint8(0xe3),
		3003: uint8(0xe5),
		3004: uint8(0xe5),
		3005: uint8(0xe6),
		3006: uint8(0xe8),
		3007: uint8(0xeb),
		3008: uint8(0x7d),
		3009: uint8(0x71),
		3010: uint8(0x72),
		3011: uint8(0x7f),
		3012: uint8(0x78),
		3013: uint8(0x7d),
		3014: uint8(0x74),
		3015: uint8(0x78),
		3016: uint8(0x76),
		3017: uint8(0x7a),
		3018: uint8(0x7f),
		3019: uint8(0x73),
		3020: uint8(0x7b),
		3021: uint8(0x77),
		3022: uint8(0x71),
		3023: uint8(0x74),
		3024: uint8(0x7a),
		3025: uint8(0x7c),
		3026: uint8(0x79),
		3027: uint8(0x75),
		3028: uint8(0x73),
		3029: uint8(0x76),
		3030: uint8(0x7e),
		3031: uint8(0x7b),
		3032: uint8(0x75),
		3033: uint8(0x70),
		3034: uint8(0x70),
		3035: uint8(0x7e),
		3036: uint8(0x7c),
		3037: uint8(0x79),
		3038: uint8(0x77),
		3039: uint8(0x72),
		3040: uint8(0x77),
		3041: uint8(0x72),
		3042: uint8(0x7b),
		3043: uint8(0x71),
		3044: uint8(0x74),
		3045: uint8(0x7e),
		3046: uint8(0x71),
		3047: uint8(0x77),
		3048: uint8(0x79),
		3049: uint8(0x74),
		3050: uint8(0x7c),
		3051: uint8(0x7a),
		3052: uint8(0x7e),
		3053: uint8(0x78),
		3054: uint8(0x72),
		3055: uint8(0x7d),
		3056: uint8(0x70),
		3057: uint8(0x7f),
		3058: uint8(0x76),
		3059: uint8(0x7c),
		3060: uint8(0x7a),
		3061: uint8(0x79),
		3062: uint8(0x7d),
		3063: uint8(0x70),
		3064: uint8(0x7f),
		3065: uint8(0x73),
		3066: uint8(0x73),
		3067: uint8(0x75),
		3068: uint8(0x75),
		3069: uint8(0x76),
		3070: uint8(0x78),
		3071: uint8(0x7b),
		3072: uint8(0xad),
		3073: uint8(0xa1),
		3074: uint8(0xa2),
		3075: uint8(0xaf),
		3076: uint8(0xa8),
		3077: uint8(0xad),
		3078: uint8(0xa4),
		3079: uint8(0xa8),
		3080: uint8(0xa6),
		3081: uint8(0xaa),
		3082: uint8(0xaf),
		3083: uint8(0xa3),
		3084: uint8(0xab),
		3085: uint8(0xa7),
		3086: uint8(0xa1),
		3087: uint8(0xa4),
		3088: uint8(0xaa),
		3089: uint8(0xac),
		3090: uint8(0xa9),
		3091: uint8(0xa5),
		3092: uint8(0xa3),
		3093: uint8(0xa6),
		3094: uint8(0xae),
		3095: uint8(0xab),
		3096: uint8(0xa5),
		3097: uint8(0xa0),
		3098: uint8(0xa0),
		3099: uint8(0xae),
		3100: uint8(0xac),
		3101: uint8(0xa9),
		3102: uint8(0xa7),
		3103: uint8(0xa2),
		3104: uint8(0xa7),
		3105: uint8(0xa2),
		3106: uint8(0xab),
		3107: uint8(0xa1),
		3108: uint8(0xa4),
		3109: uint8(0xae),
		3110: uint8(0xa1),
		3111: uint8(0xa7),
		3112: uint8(0xa9),
		3113: uint8(0xa4),
		3114: uint8(0xac),
		3115: uint8(0xaa),
		3116: uint8(0xae),
		3117: uint8(0xa8),
		3118: uint8(0xa2),
		3119: uint8(0xad),
		3120: uint8(0xa0),
		3121: uint8(0xaf),
		3122: uint8(0xa6),
		3123: uint8(0xac),
		3124: uint8(0xaa),
		3125: uint8(0xa9),
		3126: uint8(0xad),
		3127: uint8(0xa0),
		3128: uint8(0xaf),
		3129: uint8(0xa3),
		3130: uint8(0xa3),
		3131: uint8(0xa5),
		3132: uint8(0xa5),
		3133: uint8(0xa6),
		3134: uint8(0xa8),
		3135: uint8(0xab),
		3136: uint8(0x9d),
		3137: uint8(0x91),
		3138: uint8(0x92),
		3139: uint8(0x9f),
		3140: uint8(0x98),
		3141: uint8(0x9d),
		3142: uint8(0x94),
		3143: uint8(0x98),
		3144: uint8(0x96),
		3145: uint8(0x9a),
		3146: uint8(0x9f),
		3147: uint8(0x93),
		3148: uint8(0x9b),
		3149: uint8(0x97),
		3150: uint8(0x91),
		3151: uint8(0x94),
		3152: uint8(0x9a),
		3153: uint8(0x9c),
		3154: uint8(0x99),
		3155: uint8(0x95),
		3156: uint8(0x93),
		3157: uint8(0x96),
		3158: uint8(0x9e),
		3159: uint8(0x9b),
		3160: uint8(0x95),
		3161: uint8(0x90),
		3162: uint8(0x90),
		3163: uint8(0x9e),
		3164: uint8(0x9c),
		3165: uint8(0x99),
		3166: uint8(0x97),
		3167: uint8(0x92),
		3168: uint8(0x97),
		3169: uint8(0x92),
		3170: uint8(0x9b),
		3171: uint8(0x91),
		3172: uint8(0x94),
		3173: uint8(0x9e),
		3174: uint8(0x91),
		3175: uint8(0x97),
		3176: uint8(0x99),
		3177: uint8(0x94),
		3178: uint8(0x9c),
		3179: uint8(0x9a),
		3180: uint8(0x9e),
		3181: uint8(0x98),
		3182: uint8(0x92),
		3183: uint8(0x9d),
		3184: uint8(0x90),
		3185: uint8(0x9f),
		3186: uint8(0x96),
		3187: uint8(0x9c),
		3188: uint8(0x9a),
		3189: uint8(0x99),
		3190: uint8(0x9d),
		3191: uint8(0x90),
		3192: uint8(0x9f),
		3193: uint8(0x93),
		3194: uint8(0x93),
		3195: uint8(0x95),
		3196: uint8(0x95),
		3197: uint8(0x96),
		3198: uint8(0x98),
		3199: uint8(0x9b),
		3200: uint8(0xfd),
		3201: uint8(0xf1),
		3202: uint8(0xf2),
		3203: uint8(0xff),
		3204: uint8(0xf8),
		3205: uint8(0xfd),
		3206: uint8(0xf4),
		3207: uint8(0xf8),
		3208: uint8(0xf6),
		3209: uint8(0xfa),
		3210: uint8(0xff),
		3211: uint8(0xf3),
		3212: uint8(0xfb),
		3213: uint8(0xf7),
		3214: uint8(0xf1),
		3215: uint8(0xf4),
		3216: uint8(0xfa),
		3217: uint8(0xfc),
		3218: uint8(0xf9),
		3219: uint8(0xf5),
		3220: uint8(0xf3),
		3221: uint8(0xf6),
		3222: uint8(0xfe),
		3223: uint8(0xfb),
		3224: uint8(0xf5),
		3225: uint8(0xf0),
		3226: uint8(0xf0),
		3227: uint8(0xfe),
		3228: uint8(0xfc),
		3229: uint8(0xf9),
		3230: uint8(0xf7),
		3231: uint8(0xf2),
		3232: uint8(0xf7),
		3233: uint8(0xf2),
		3234: uint8(0xfb),
		3235: uint8(0xf1),
		3236: uint8(0xf4),
		3237: uint8(0xfe),
		3238: uint8(0xf1),
		3239: uint8(0xf7),
		3240: uint8(0xf9),
		3241: uint8(0xf4),
		3242: uint8(0xfc),
		3243: uint8(0xfa),
		3244: uint8(0xfe),
		3245: uint8(0xf8),
		3246: uint8(0xf2),
		3247: uint8(0xfd),
		3248: uint8(0xf0),
		3249: uint8(0xff),
		3250: uint8(0xf6),
		3251: uint8(0xfc),
		3252: uint8(0xfa),
		3253: uint8(0xf9),
		3254: uint8(0xfd),
		3255: uint8(0xf0),
		3256: uint8(0xff),
		3257: uint8(0xf3),
		3258: uint8(0xf3),
		3259: uint8(0xf5),
		3260: uint8(0xf5),
		3261: uint8(0xf6),
		3262: uint8(0xf8),
		3263: uint8(0xfb),
		3264: uint8(0x5d),
		3265: uint8(0x51),
		3266: uint8(0x52),
		3267: uint8(0x5f),
		3268: uint8(0x58),
		3269: uint8(0x5d),
		3270: uint8(0x54),
		3271: uint8(0x58),
		3272: uint8(0x56),
		3273: uint8(0x5a),
		3274: uint8(0x5f),
		3275: uint8(0x53),
		3276: uint8(0x5b),
		3277: uint8(0x57),
		3278: uint8(0x51),
		3279: uint8(0x54),
		3280: uint8(0x5a),
		3281: uint8(0x5c),
		3282: uint8(0x59),
		3283: uint8(0x55),
		3284: uint8(0x53),
		3285: uint8(0x56),
		3286: uint8(0x5e),
		3287: uint8(0x5b),
		3288: uint8(0x55),
		3289: uint8(0x50),
		3290: uint8(0x50),
		3291: uint8(0x5e),
		3292: uint8(0x5c),
		3293: uint8(0x59),
		3294: uint8(0x57),
		3295: uint8(0x52),
		3296: uint8(0x57),
		3297: uint8(0x52),
		3298: uint8(0x5b),
		3299: uint8(0x51),
		3300: uint8(0x54),
		3301: uint8(0x5e),
		3302: uint8(0x51),
		3303: uint8(0x57),
		3304: uint8(0x59),
		3305: uint8(0x54),
		3306: uint8(0x5c),
		3307: uint8(0x5a),
		3308: uint8(0x5e),
		3309: uint8(0x58),
		3310: uint8(0x52),
		3311: uint8(0x5d),
		3312: uint8(0x50),
		3313: uint8(0x5f),
		3314: uint8(0x56),
		3315: uint8(0x5c),
		3316: uint8(0x5a),
		3317: uint8(0x59),
		3318: uint8(0x5d),
		3319: uint8(0x50),
		3320: uint8(0x5f),
		3321: uint8(0x53),
		3322: uint8(0x53),
		3323: uint8(0x55),
		3324: uint8(0x55),
		3325: uint8(0x56),
		3326: uint8(0x58),
		3327: uint8(0x5b),
		3328: uint8(0x6d),
		3329: uint8(0x61),
		3330: uint8(0x62),
		3331: uint8(0x6f),
		3332: uint8(0x68),
		3333: uint8(0x6d),
		3334: uint8(0x64),
		3335: uint8(0x68),
		3336: uint8(0x66),
		3337: uint8(0x6a),
		3338: uint8(0x6f),
		3339: uint8(0x63),
		3340: uint8(0x6b),
		3341: uint8(0x67),
		3342: uint8(0x61),
		3343: uint8(0x64),
		3344: uint8(0x6a),
		3345: uint8(0x6c),
		3346: uint8(0x69),
		3347: uint8(0x65),
		3348: uint8(0x63),
		3349: uint8(0x66),
		3350: uint8(0x6e),
		3351: uint8(0x6b),
		3352: uint8(0x65),
		3353: uint8(0x60),
		3354: uint8(0x60),
		3355: uint8(0x6e),
		3356: uint8(0x6c),
		3357: uint8(0x69),
		3358: uint8(0x67),
		3359: uint8(0x62),
		3360: uint8(0x67),
		3361: uint8(0x62),
		3362: uint8(0x6b),
		3363: uint8(0x61),
		3364: uint8(0x64),
		3365: uint8(0x6e),
		3366: uint8(0x61),
		3367: uint8(0x67),
		3368: uint8(0x69),
		3369: uint8(0x64),
		3370: uint8(0x6c),
		3371: uint8(0x6a),
		3372: uint8(0x6e),
		3373: uint8(0x68),
		3374: uint8(0x62),
		3375: uint8(0x6d),
		3376: uint8(0x60),
		3377: uint8(0x6f),
		3378: uint8(0x66),
		3379: uint8(0x6c),
		3380: uint8(0x6a),
		3381: uint8(0x69),
		3382: uint8(0x6d),
		3383: uint8(0x60),
		3384: uint8(0x6f),
		3385: uint8(0x63),
		3386: uint8(0x63),
		3387: uint8(0x65),
		3388: uint8(0x65),
		3389: uint8(0x66),
		3390: uint8(0x68),
		3391: uint8(0x6b),
		3392: uint8(0x0d),
		3393: uint8(0x01),
		3394: uint8(0x02),
		3395: uint8(0x0f),
		3396: uint8(0x08),
		3397: uint8(0x0d),
		3398: uint8(0x04),
		3399: uint8(0x08),
		3400: uint8(0x06),
		3401: uint8(0x0a),
		3402: uint8(0x0f),
		3403: uint8(0x03),
		3404: uint8(0x0b),
		3405: uint8(0x07),
		3406: uint8(0x01),
		3407: uint8(0x04),
		3408: uint8(0x0a),
		3409: uint8(0x0c),
		3410: uint8(0x09),
		3411: uint8(0x05),
		3412: uint8(0x03),
		3413: uint8(0x06),
		3414: uint8(0x0e),
		3415: uint8(0x0b),
		3416: uint8(0x05),
		3417: uint8(0x00),
		3418: uint8(0x00),
		3419: uint8(0x0e),
		3420: uint8(0x0c),
		3421: uint8(0x09),
		3422: uint8(0x07),
		3423: uint8(0x02),
		3424: uint8(0x07),
		3425: uint8(0x02),
		3426: uint8(0x0b),
		3427: uint8(0x01),
		3428: uint8(0x04),
		3429: uint8(0x0e),
		3430: uint8(0x01),
		3431: uint8(0x07),
		3432: uint8(0x09),
		3433: uint8(0x04),
		3434: uint8(0x0c),
		3435: uint8(0x0a),
		3436: uint8(0x0e),
		3437: uint8(0x08),
		3438: uint8(0x02),
		3439: uint8(0x0d),
		3440: uint8(0x00),
		3441: uint8(0x0f),
		3442: uint8(0x06),
		3443: uint8(0x0c),
		3444: uint8(0x0a),
		3445: uint8(0x09),
		3446: uint8(0x0d),
		3447: uint8(0x00),
		3448: uint8(0x0f),
		3449: uint8(0x03),
		3450: uint8(0x03),
		3451: uint8(0x05),
		3452: uint8(0x05),
		3453: uint8(0x06),
		3454: uint8(0x08),
		3455: uint8(0x0b),
		3456: uint8(0x8d),
		3457: uint8(0x81),
		3458: uint8(0x82),
		3459: uint8(0x8f),
		3460: uint8(0x88),
		3461: uint8(0x8d),
		3462: uint8(0x84),
		3463: uint8(0x88),
		3464: uint8(0x86),
		3465: uint8(0x8a),
		3466: uint8(0x8f),
		3467: uint8(0x83),
		3468: uint8(0x8b),
		3469: uint8(0x87),
		3470: uint8(0x81),
		3471: uint8(0x84),
		3472: uint8(0x8a),
		3473: uint8(0x8c),
		3474: uint8(0x89),
		3475: uint8(0x85),
		3476: uint8(0x83),
		3477: uint8(0x86),
		3478: uint8(0x8e),
		3479: uint8(0x8b),
		3480: uint8(0x85),
		3481: uint8(0x80),
		3482: uint8(0x80),
		3483: uint8(0x8e),
		3484: uint8(0x8c),
		3485: uint8(0x89),
		3486: uint8(0x87),
		3487: uint8(0x82),
		3488: uint8(0x87),
		3489: uint8(0x82),
		3490: uint8(0x8b),
		3491: uint8(0x81),
		3492: uint8(0x84),
		3493: uint8(0x8e),
		3494: uint8(0x81),
		3495: uint8(0x87),
		3496: uint8(0x89),
		3497: uint8(0x84),
		3498: uint8(0x8c),
		3499: uint8(0x8a),
		3500: uint8(0x8e),
		3501: uint8(0x88),
		3502: uint8(0x82),
		3503: uint8(0x8d),
		3504: uint8(0x80),
		3505: uint8(0x8f),
		3506: uint8(0x86),
		3507: uint8(0x8c),
		3508: uint8(0x8a),
		3509: uint8(0x89),
		3510: uint8(0x8d),
		3511: uint8(0x80),
		3512: uint8(0x8f),
		3513: uint8(0x83),
		3514: uint8(0x83),
		3515: uint8(0x85),
		3516: uint8(0x85),
		3517: uint8(0x86),
		3518: uint8(0x88),
		3519: uint8(0x8b),
		3520: uint8(0xfd),
		3521: uint8(0xf1),
		3522: uint8(0xf2),
		3523: uint8(0xff),
		3524: uint8(0xf8),
		3525: uint8(0xfd),
		3526: uint8(0xf4),
		3527: uint8(0xf8),
		3528: uint8(0xf6),
		3529: uint8(0xfa),
		3530: uint8(0xff),
		3531: uint8(0xf3),
		3532: uint8(0xfb),
		3533: uint8(0xf7),
		3534: uint8(0xf1),
		3535: uint8(0xf4),
		3536: uint8(0xfa),
		3537: uint8(0xfc),
		3538: uint8(0xf9),
		3539: uint8(0xf5),
		3540: uint8(0xf3),
		3541: uint8(0xf6),
		3542: uint8(0xfe),
		3543: uint8(0xfb),
		3544: uint8(0xf5),
		3545: uint8(0xf0),
		3546: uint8(0xf0),
		3547: uint8(0xfe),
		3548: uint8(0xfc),
		3549: uint8(0xf9),
		3550: uint8(0xf7),
		3551: uint8(0xf2),
		3552: uint8(0xf7),
		3553: uint8(0xf2),
		3554: uint8(0xfb),
		3555: uint8(0xf1),
		3556: uint8(0xf4),
		3557: uint8(0xfe),
		3558: uint8(0xf1),
		3559: uint8(0xf7),
		3560: uint8(0xf9),
		3561: uint8(0xf4),
		3562: uint8(0xfc),
		3563: uint8(0xfa),
		3564: uint8(0xfe),
		3565: uint8(0xf8),
		3566: uint8(0xf2),
		3567: uint8(0xfd),
		3568: uint8(0xf0),
		3569: uint8(0xff),
		3570: uint8(0xf6),
		3571: uint8(0xfc),
		3572: uint8(0xfa),
		3573: uint8(0xf9),
		3574: uint8(0xfd),
		3575: uint8(0xf0),
		3576: uint8(0xff),
		3577: uint8(0xf3),
		3578: uint8(0xf3),
		3579: uint8(0xf5),
		3580: uint8(0xf5),
		3581: uint8(0xf6),
		3582: uint8(0xf8),
		3583: uint8(0xfb),
		3584: uint8(0x0d),
		3585: uint8(0x01),
		3586: uint8(0x02),
		3587: uint8(0x0f),
		3588: uint8(0x08),
		3589: uint8(0x0d),
		3590: uint8(0x04),
		3591: uint8(0x08),
		3592: uint8(0x06),
		3593: uint8(0x0a),
		3594: uint8(0x0f),
		3595: uint8(0x03),
		3596: uint8(0x0b),
		3597: uint8(0x07),
		3598: uint8(0x01),
		3599: uint8(0x04),
		3600: uint8(0x0a),
		3601: uint8(0x0c),
		3602: uint8(0x09),
		3603: uint8(0x05),
		3604: uint8(0x03),
		3605: uint8(0x06),
		3606: uint8(0x0e),
		3607: uint8(0x0b),
		3608: uint8(0x05),
		3609: uint8(0x00),
		3610: uint8(0x00),
		3611: uint8(0x0e),
		3612: uint8(0x0c),
		3613: uint8(0x09),
		3614: uint8(0x07),
		3615: uint8(0x02),
		3616: uint8(0x07),
		3617: uint8(0x02),
		3618: uint8(0x0b),
		3619: uint8(0x01),
		3620: uint8(0x04),
		3621: uint8(0x0e),
		3622: uint8(0x01),
		3623: uint8(0x07),
		3624: uint8(0x09),
		3625: uint8(0x04),
		3626: uint8(0x0c),
		3627: uint8(0x0a),
		3628: uint8(0x0e),
		3629: uint8(0x08),
		3630: uint8(0x02),
		3631: uint8(0x0d),
		3632: uint8(0x00),
		3633: uint8(0x0f),
		3634: uint8(0x06),
		3635: uint8(0x0c),
		3636: uint8(0x0a),
		3637: uint8(0x09),
		3638: uint8(0x0d),
		3639: uint8(0x00),
		3640: uint8(0x0f),
		3641: uint8(0x03),
		3642: uint8(0x03),
		3643: uint8(0x05),
		3644: uint8(0x05),
		3645: uint8(0x06),
		3646: uint8(0x08),
		3647: uint8(0x0b),
		3648: uint8(0xed),
		3649: uint8(0xe1),
		3650: uint8(0xe2),
		3651: uint8(0xef),
		3652: uint8(0xe8),
		3653: uint8(0xed),
		3654: uint8(0xe4),
		3655: uint8(0xe8),
		3656: uint8(0xe6),
		3657: uint8(0xea),
		3658: uint8(0xef),
		3659: uint8(0xe3),
		3660: uint8(0xeb),
		3661: uint8(0xe7),
		3662: uint8(0xe1),
		3663: uint8(0xe4),
		3664: uint8(0xea),
		3665: uint8(0xec),
		3666: uint8(0xe9),
		3667: uint8(0xe5),
		3668: uint8(0xe3),
		3669: uint8(0xe6),
		3670: uint8(0xee),
		3671: uint8(0xeb),
		3672: uint8(0xe5),
		3673: uint8(0xe0),
		3674: uint8(0xe0),
		3675: uint8(0xee),
		3676: uint8(0xec),
		3677: uint8(0xe9),
		3678: uint8(0xe7),
		3679: uint8(0xe2),
		3680: uint8(0xe7),
		3681: uint8(0xe2),
		3682: uint8(0xeb),
		3683: uint8(0xe1),
		3684: uint8(0xe4),
		3685: uint8(0xee),
		3686: uint8(0xe1),
		3687: uint8(0xe7),
		3688: uint8(0xe9),
		3689: uint8(0xe4),
		3690: uint8(0xec),
		3691: uint8(0xea),
		3692: uint8(0xee),
		3693: uint8(0xe8),
		3694: uint8(0xe2),
		3695: uint8(0xed),
		3696: uint8(0xe0),
		3697: uint8(0xef),
		3698: uint8(0xe6),
		3699: uint8(0xec),
		3700: uint8(0xea),
		3701: uint8(0xe9),
		3702: uint8(0xed),
		3703: uint8(0xe0),
		3704: uint8(0xef),
		3705: uint8(0xe3),
		3706: uint8(0xe3),
		3707: uint8(0xe5),
		3708: uint8(0xe5),
		3709: uint8(0xe6),
		3710: uint8(0xe8),
		3711: uint8(0xeb),
		3712: uint8(0x5d),
		3713: uint8(0x51),
		3714: uint8(0x52),
		3715: uint8(0x5f),
		3716: uint8(0x58),
		3717: uint8(0x5d),
		3718: uint8(0x54),
		3719: uint8(0x58),
		3720: uint8(0x56),
		3721: uint8(0x5a),
		3722: uint8(0x5f),
		3723: uint8(0x53),
		3724: uint8(0x5b),
		3725: uint8(0x57),
		3726: uint8(0x51),
		3727: uint8(0x54),
		3728: uint8(0x5a),
		3729: uint8(0x5c),
		3730: uint8(0x59),
		3731: uint8(0x55),
		3732: uint8(0x53),
		3733: uint8(0x56),
		3734: uint8(0x5e),
		3735: uint8(0x5b),
		3736: uint8(0x55),
		3737: uint8(0x50),
		3738: uint8(0x50),
		3739: uint8(0x5e),
		3740: uint8(0x5c),
		3741: uint8(0x59),
		3742: uint8(0x57),
		3743: uint8(0x52),
		3744: uint8(0x57),
		3745: uint8(0x52),
		3746: uint8(0x5b),
		3747: uint8(0x51),
		3748: uint8(0x54),
		3749: uint8(0x5e),
		3750: uint8(0x51),
		3751: uint8(0x57),
		3752: uint8(0x59),
		3753: uint8(0x54),
		3754: uint8(0x5c),
		3755: uint8(0x5a),
		3756: uint8(0x5e),
		3757: uint8(0x58),
		3758: uint8(0x52),
		3759: uint8(0x5d),
		3760: uint8(0x50),
		3761: uint8(0x5f),
		3762: uint8(0x56),
		3763: uint8(0x5c),
		3764: uint8(0x5a),
		3765: uint8(0x59),
		3766: uint8(0x5d),
		3767: uint8(0x50),
		3768: uint8(0x5f),
		3769: uint8(0x53),
		3770: uint8(0x53),
		3771: uint8(0x55),
		3772: uint8(0x55),
		3773: uint8(0x56),
		3774: uint8(0x58),
		3775: uint8(0x5b),
		3776: uint8(0x2d),
		3777: uint8(0x21),
		3778: uint8(0x22),
		3779: uint8(0x2f),
		3780: uint8(0x28),
		3781: uint8(0x2d),
		3782: uint8(0x24),
		3783: uint8(0x28),
		3784: uint8(0x26),
		3785: uint8(0x2a),
		3786: uint8(0x2f),
		3787: uint8(0x23),
		3788: uint8(0x2b),
		3789: uint8(0x27),
		3790: uint8(0x21),
		3791: uint8(0x24),
		3792: uint8(0x2a),
		3793: uint8(0x2c),
		3794: uint8(0x29),
		3795: uint8(0x25),
		3796: uint8(0x23),
		3797: uint8(0x26),
		3798: uint8(0x2e),
		3799: uint8(0x2b),
		3800: uint8(0x25),
		3801: uint8(0x20),
		3802: uint8(0x20),
		3803: uint8(0x2e),
		3804: uint8(0x2c),
		3805: uint8(0x29),
		3806: uint8(0x27),
		3807: uint8(0x22),
		3808: uint8(0x27),
		3809: uint8(0x22),
		3810: uint8(0x2b),
		3811: uint8(0x21),
		3812: uint8(0x24),
		3813: uint8(0x2e),
		3814: uint8(0x21),
		3815: uint8(0x27),
		3816: uint8(0x29),
		3817: uint8(0x24),
		3818: uint8(0x2c),
		3819: uint8(0x2a),
		3820: uint8(0x2e),
		3821: uint8(0x28),
		3822: uint8(0x22),
		3823: uint8(0x2d),
		3824: uint8(0x20),
		3825: uint8(0x2f),
		3826: uint8(0x26),
		3827: uint8(0x2c),
		3828: uint8(0x2a),
		3829: uint8(0x29),
		3830: uint8(0x2d),
		3831: uint8(0x20),
		3832: uint8(0x2f),
		3833: uint8(0x23),
		3834: uint8(0x23),
		3835: uint8(0x25),
		3836: uint8(0x25),
		3837: uint8(0x26),
		3838: uint8(0x28),
		3839: uint8(0x2b),
		3840: uint8(0x9d),
		3841: uint8(0x91),
		3842: uint8(0x92),
		3843: uint8(0x9f),
		3844: uint8(0x98),
		3845: uint8(0x9d),
		3846: uint8(0x94),
		3847: uint8(0x98),
		3848: uint8(0x96),
		3849: uint8(0x9a),
		3850: uint8(0x9f),
		3851: uint8(0x93),
		3852: uint8(0x9b),
		3853: uint8(0x97),
		3854: uint8(0x91),
		3855: uint8(0x94),
		3856: uint8(0x9a),
		3857: uint8(0x9c),
		3858: uint8(0x99),
		3859: uint8(0x95),
		3860: uint8(0x93),
		3861: uint8(0x96),
		3862: uint8(0x9e),
		3863: uint8(0x9b),
		3864: uint8(0x95),
		3865: uint8(0x90),
		3866: uint8(0x90),
		3867: uint8(0x9e),
		3868: uint8(0x9c),
		3869: uint8(0x99),
		3870: uint8(0x97),
		3871: uint8(0x92),
		3872: uint8(0x97),
		3873: uint8(0x92),
		3874: uint8(0x9b),
		3875: uint8(0x91),
		3876: uint8(0x94),
		3877: uint8(0x9e),
		3878: uint8(0x91),
		3879: uint8(0x97),
		3880: uint8(0x99),
		3881: uint8(0x94),
		3882: uint8(0x9c),
		3883: uint8(0x9a),
		3884: uint8(0x9e),
		3885: uint8(0x98),
		3886: uint8(0x92),
		3887: uint8(0x9d),
		3888: uint8(0x90),
		3889: uint8(0x9f),
		3890: uint8(0x96),
		3891: uint8(0x9c),
		3892: uint8(0x9a),
		3893: uint8(0x99),
		3894: uint8(0x9d),
		3895: uint8(0x90),
		3896: uint8(0x9f),
		3897: uint8(0x93),
		3898: uint8(0x93),
		3899: uint8(0x95),
		3900: uint8(0x95),
		3901: uint8(0x96),
		3902: uint8(0x98),
		3903: uint8(0x9b),
		3904: uint8(0x3d),
		3905: uint8(0x31),
		3906: uint8(0x32),
		3907: uint8(0x3f),
		3908: uint8(0x38),
		3909: uint8(0x3d),
		3910: uint8(0x34),
		3911: uint8(0x38),
		3912: uint8(0x36),
		3913: uint8(0x3a),
		3914: uint8(0x3f),
		3915: uint8(0x33),
		3916: uint8(0x3b),
		3917: uint8(0x37),
		3918: uint8(0x31),
		3919: uint8(0x34),
		3920: uint8(0x3a),
		3921: uint8(0x3c),
		3922: uint8(0x39),
		3923: uint8(0x35),
		3924: uint8(0x33),
		3925: uint8(0x36),
		3926: uint8(0x3e),
		3927: uint8(0x3b),
		3928: uint8(0x35),
		3929: uint8(0x30),
		3930: uint8(0x30),
		3931: uint8(0x3e),
		3932: uint8(0x3c),
		3933: uint8(0x39),
		3934: uint8(0x37),
		3935: uint8(0x32),
		3936: uint8(0x37),
		3937: uint8(0x32),
		3938: uint8(0x3b),
		3939: uint8(0x31),
		3940: uint8(0x34),
		3941: uint8(0x3e),
		3942: uint8(0x31),
		3943: uint8(0x37),
		3944: uint8(0x39),
		3945: uint8(0x34),
		3946: uint8(0x3c),
		3947: uint8(0x3a),
		3948: uint8(0x3e),
		3949: uint8(0x38),
		3950: uint8(0x32),
		3951: uint8(0x3d),
		3952: uint8(0x30),
		3953: uint8(0x3f),
		3954: uint8(0x36),
		3955: uint8(0x3c),
		3956: uint8(0x3a),
		3957: uint8(0x39),
		3958: uint8(0x3d),
		3959: uint8(0x30),
		3960: uint8(0x3f),
		3961: uint8(0x33),
		3962: uint8(0x33),
		3963: uint8(0x35),
		3964: uint8(0x35),
		3965: uint8(0x36),
		3966: uint8(0x38),
		3967: uint8(0x3b),
		3968: uint8(0x2d),
		3969: uint8(0x21),
		3970: uint8(0x22),
		3971: uint8(0x2f),
		3972: uint8(0x28),
		3973: uint8(0x2d),
		3974: uint8(0x24),
		3975: uint8(0x28),
		3976: uint8(0x26),
		3977: uint8(0x2a),
		3978: uint8(0x2f),
		3979: uint8(0x23),
		3980: uint8(0x2b),
		3981: uint8(0x27),
		3982: uint8(0x21),
		3983: uint8(0x24),
		3984: uint8(0x2a),
		3985: uint8(0x2c),
		3986: uint8(0x29),
		3987: uint8(0x25),
		3988: uint8(0x23),
		3989: uint8(0x26),
		3990: uint8(0x2e),
		3991: uint8(0x2b),
		3992: uint8(0x25),
		3993: uint8(0x20),
		3994: uint8(0x20),
		3995: uint8(0x2e),
		3996: uint8(0x2c),
		3997: uint8(0x29),
		3998: uint8(0x27),
		3999: uint8(0x22),
		4000: uint8(0x27),
		4001: uint8(0x22),
		4002: uint8(0x2b),
		4003: uint8(0x21),
		4004: uint8(0x24),
		4005: uint8(0x2e),
		4006: uint8(0x21),
		4007: uint8(0x27),
		4008: uint8(0x29),
		4009: uint8(0x24),
		4010: uint8(0x2c),
		4011: uint8(0x2a),
		4012: uint8(0x2e),
		4013: uint8(0x28),
		4014: uint8(0x22),
		4015: uint8(0x2d),
		4016: uint8(0x20),
		4017: uint8(0x2f),
		4018: uint8(0x26),
		4019: uint8(0x2c),
		4020: uint8(0x2a),
		4021: uint8(0x29),
		4022: uint8(0x2d),
		4023: uint8(0x20),
		4024: uint8(0x2f),
		4025: uint8(0x23),
		4026: uint8(0x23),
		4027: uint8(0x25),
		4028: uint8(0x25),
		4029: uint8(0x26),
		4030: uint8(0x28),
		4031: uint8(0x2b),
		4032: uint8(0xcd),
		4033: uint8(0xc1),
		4034: uint8(0xc2),
		4035: uint8(0xcf),
		4036: uint8(0xc8),
		4037: uint8(0xcd),
		4038: uint8(0xc4),
		4039: uint8(0xc8),
		4040: uint8(0xc6),
		4041: uint8(0xca),
		4042: uint8(0xcf),
		4043: uint8(0xc3),
		4044: uint8(0xcb),
		4045: uint8(0xc7),
		4046: uint8(0xc1),
		4047: uint8(0xc4),
		4048: uint8(0xca),
		4049: uint8(0xcc),
		4050: uint8(0xc9),
		4051: uint8(0xc5),
		4052: uint8(0xc3),
		4053: uint8(0xc6),
		4054: uint8(0xce),
		4055: uint8(0xcb),
		4056: uint8(0xc5),
		4057: uint8(0xc0),
		4058: uint8(0xc0),
		4059: uint8(0xce),
		4060: uint8(0xcc),
		4061: uint8(0xc9),
		4062: uint8(0xc7),
		4063: uint8(0xc2),
		4064: uint8(0xc7),
		4065: uint8(0xc2),
		4066: uint8(0xcb),
		4067: uint8(0xc1),
		4068: uint8(0xc4),
		4069: uint8(0xce),
		4070: uint8(0xc1),
		4071: uint8(0xc7),
		4072: uint8(0xc9),
		4073: uint8(0xc4),
		4074: uint8(0xcc),
		4075: uint8(0xca),
		4076: uint8(0xce),
		4077: uint8(0xc8),
		4078: uint8(0xc2),
		4079: uint8(0xcd),
		4080: uint8(0xc0),
		4081: uint8(0xcf),
		4082: uint8(0xc6),
		4083: uint8(0xcc),
		4084: uint8(0xca),
		4085: uint8(0xc9),
		4086: uint8(0xcd),
		4087: uint8(0xc0),
		4088: uint8(0xcf),
		4089: uint8(0xc3),
		4090: uint8(0xc3),
		4091: uint8(0xc5),
		4092: uint8(0xc5),
		4093: uint8(0xc6),
		4094: uint8(0xc8),
		4095: uint8(0xcb)}}

var _key_perm = [56]uint8{
	0:  uint8(57),
	1:  uint8(49),
	2:  uint8(41),
	3:  uint8(33),
	4:  uint8(25),
	5:  uint8(17),
	6:  uint8(9),
	7:  uint8(1),
	8:  uint8(58),
	9:  uint8(50),
	10: uint8(42),
	11: uint8(34),
	12: uint8(26),
	13: uint8(18),
	14: uint8(10),
	15: uint8(2),
	16: uint8(59),
	17: uint8(51),
	18: uint8(43),
	19: uint8(35),
	20: uint8(27),
	21: uint8(19),
	22: uint8(11),
	23: uint8(3),
	24: uint8(60),
	25: uint8(52),
	26: uint8(44),
	27: uint8(36),
	28: uint8(63),
	29: uint8(55),
	30: uint8(47),
	31: uint8(39),
	32: uint8(31),
	33: uint8(23),
	34: uint8(15),
	35: uint8(7),
	36: uint8(62),
	37: uint8(54),
	38: uint8(46),
	39: uint8(38),
	40: uint8(30),
	41: uint8(22),
	42: uint8(14),
	43: uint8(6),
	44: uint8(61),
	45: uint8(53),
	46: uint8(45),
	47: uint8(37),
	48: uint8(29),
	49: uint8(21),
	50: uint8(13),
	51: uint8(5),
	52: uint8(28),
	53: uint8(20),
	54: uint8(12),
	55: uint8(4)}

var _key_shifts = [16]uint8{
	0:  uint8(1),
	1:  uint8(1),
	2:  uint8(2),
	3:  uint8(2),
	4:  uint8(2),
	5:  uint8(2),
	6:  uint8(2),
	7:  uint8(2),
	8:  uint8(1),
	9:  uint8(2),
	10: uint8(2),
	11: uint8(2),
	12: uint8(2),
	13: uint8(2),
	14: uint8(2),
	15: uint8(1)}

var _comp_perm = [48]uint8{
	0:  uint8(14),
	1:  uint8(17),
	2:  uint8(11),
	3:  uint8(24),
	4:  uint8(1),
	5:  uint8(5),
	6:  uint8(3),
	7:  uint8(28),
	8:  uint8(15),
	9:  uint8(6),
	10: uint8(21),
	11: uint8(10),
	12: uint8(23),
	13: uint8(19),
	14: uint8(12),
	15: uint8(4),
	16: uint8(26),
	17: uint8(8),
	18: uint8(16),
	19: uint8(7),
	20: uint8(27),
	21: uint8(20),
	22: uint8(13),
	23: uint8(2),
	24: uint8(41),
	25: uint8(52),
	26: uint8(31),
	27: uint8(37),
	28: uint8(47),
	29: uint8(55),
	30: uint8(30),
	31: uint8(40),
	32: uint8(51),
	33: uint8(45),
	34: uint8(33),
	35: uint8(48),
	36: uint8(44),
	37: uint8(49),
	38: uint8(39),
	39: uint8(56),
	40: uint8(34),
	41: uint8(53),
	42: uint8(46),
	43: uint8(42),
	44: uint8(50),
	45: uint8(36),
	46: uint8(29),
	47: uint8(32)}

var _pbox = [32]uint8{
	0:  uint8(16),
	1:  uint8(7),
	2:  uint8(20),
	3:  uint8(21),
	4:  uint8(29),
	5:  uint8(12),
	6:  uint8(28),
	7:  uint8(17),
	8:  uint8(1),
	9:  uint8(15),
	10: uint8(23),
	11: uint8(26),
	12: uint8(5),
	13: uint8(18),
	14: uint8(31),
	15: uint8(10),
	16: uint8(2),
	17: uint8(8),
	18: uint8(24),
	19: uint8(14),
	20: uint8(32),
	21: uint8(27),
	22: uint8(3),
	23: uint8(9),
	24: uint8(19),
	25: uint8(13),
	26: uint8(30),
	27: uint8(6),
	28: uint8(22),
	29: uint8(11),
	30: uint8(4),
	31: uint8(25)}

func _ascii_to_bin(tls *TLS, ch int8) (r int32) {
	if int32(ch) > int32('z') {
		return 0
	}
	if int32(ch) >= int32('a') {
		return int32(ch) - int32('a') + int32(38)
	}
	if int32(ch) > int32('Z') {
		return 0
	}
	if int32(ch) >= int32('A') {
		return int32(ch) - int32('A') + int32(12)
	}
	if int32(ch) > int32('9') {
		return 0
	}
	if int32(ch) >= int32('.') {
		return int32(ch) - int32('.')
	}
	return 0
}

type Tdes_ctx = struct {
	Fsaltbits       uint32
	Fun_pbox        [32]uint8
	Finv_comp_perm  [56]uint8
	Finv_key_perm   [64]uint8
	Fen_keysl       [16]uint32
	Fen_keysr       [16]uint32
	Ffp_maskl       [8][256]uint32
	Ffp_maskr       [8][256]uint32
	Fkey_perm_maskl [8][128]uint32
	Fkey_perm_maskr [8][128]uint32
	Fcomp_maskl     [8][128]uint32
	Fcomp_maskr     [8][128]uint32
	Fpsbox          [4][256]uint32
}

func _des_init(tls *TLS, ctx uintptr) (r uintptr) {
	var b, i, inbit, j, k, obit int32
	var fl, fr, il, ir, p uint32
	(*Tdes_ctx)(unsafe.Pointer(ctx)).Fsaltbits = uint32(0)
	/* Initialise the inverted key permutation. */
	for i = 0; i < int32(64); i++ {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_key_perm)) + uintptr(i))) = uint8(255)
	}
	/*
	 * Invert the key permutation and initialise the inverted key
	 * compression permutation.
	 */
	for i = 0; i < int32(56); i++ {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_key_perm)) + uintptr(int32(_key_perm[i])-int32(1)))) = uint8(i)
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_comp_perm)) + uintptr(i))) = uint8(255)
	}
	/* Invert the key compression permutation. */
	for i = 0; i < int32(48); i++ {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_comp_perm)) + uintptr(int32(_comp_perm[i])-int32(1)))) = uint8(i)
	}
	/*
	 * Set up the OR-mask arrays for the initial and final permutations,
	 * and for the key initial and compression permutations.
	 */
	for k = 0; k < int32(8); k++ {
		for i = 0; i < int32(256); i++ {
			fl = uint32(0)
			fr = uint32(0)
			for j = 0; j < int32(8); j++ {
				inbit = int32(8)*k + j
				if i&(int32(0x80)>>j) != 0 {
					obit = int32(_final_perm[inbit])
					if obit < int32(32) {
						fl = uint32(uint64(fl) | Uint64FromUint64(0x80000000)>>obit)
					} else {
						fr = uint32(uint64(fr) | Uint64FromUint64(0x80000000)>>(obit-Int32FromInt32(32)))
					}
				}
			}
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + uintptr(k)*1024 + uintptr(i)*4)) = fl
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + uintptr(k)*1024 + uintptr(i)*4)) = fr
		}
		for i = 0; i < int32(128); i++ {
			il = uint32(0)
			ir = uint32(0)
			for j = 0; j < int32(7); j++ {
				inbit = int32(8)*k + j
				if i&(int32(0x80)>>(j+int32(1))) != 0 {
					obit = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_key_perm)) + uintptr(inbit))))
					if obit == int32(255) {
						continue
					}
					if obit < int32(28) {
						il = uint32(uint64(il) | Uint64FromUint64(0x8000000)>>obit)
					} else {
						ir = uint32(uint64(ir) | Uint64FromUint64(0x8000000)>>(obit-Int32FromInt32(28)))
					}
				}
			}
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + uintptr(k)*512 + uintptr(i)*4)) = il
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + uintptr(k)*512 + uintptr(i)*4)) = ir
			il = uint32(0)
			ir = uint32(0)
			for j = 0; j < int32(7); j++ {
				inbit = int32(7)*k + j
				if i&(int32(0x80)>>(j+int32(1))) != 0 {
					obit = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Finv_comp_perm)) + uintptr(inbit))))
					if obit == int32(255) {
						continue
					}
					if obit < int32(24) {
						il = uint32(uint64(il) | Uint64FromUint64(0x800000)>>obit)
					} else {
						ir = uint32(uint64(ir) | Uint64FromUint64(0x800000)>>(obit-Int32FromInt32(24)))
					}
				}
			}
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + uintptr(k)*512 + uintptr(i)*4)) = il
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + uintptr(k)*512 + uintptr(i)*4)) = ir
		}
	}
	/*
	 * Invert the P-box permutation, and convert into OR-masks for
	 * handling the output of the S-box arrays setup above.
	 */
	for i = 0; i < int32(32); i++ {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fun_pbox)) + uintptr(int32(_pbox[i])-int32(1)))) = uint8(i)
	}
	for b = 0; b < int32(4); b++ {
		for i = 0; i < int32(256); i++ {
			p = uint32(0)
			for j = 0; j < int32(8); j++ {
				if i&(int32(0x80)>>j) != 0 {
					p |= uint32(0x80000000) >> *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fun_pbox)) + uintptr(int32(8)*b+j)))
				}
			}
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fpsbox)) + uintptr(b)*1024 + uintptr(i)*4)) = p
		}
	}
	return ctx
}

func _setup_salt(tls *TLS, ctx uintptr, salt uint32) {
	var i int32
	var obit, saltbit uint32
	(*Tdes_ctx)(unsafe.Pointer(ctx)).Fsaltbits = uint32(0)
	saltbit = uint32(1)
	obit = uint32(0x800000)
	for i = 0; i < int32(24); i++ {
		if salt&saltbit != 0 {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fsaltbits)))) |= obit
		}
		saltbit <<= uint32(1)
		obit >>= uint32(1)
	}
}

func _des_setkey(tls *TLS, ctx uintptr, key uintptr) {
	var k0, k1, rawkey0, rawkey1, t0, t1 uint32
	var round, shifts int32
	rawkey0 = uint32(int32(*(*uint8)(unsafe.Pointer(key)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(key + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(key + 2)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(key + 3))))
	rawkey1 = uint32(int32(*(*uint8)(unsafe.Pointer(key + 4)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(key + 5)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(key + 6)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(key + 7))))
	/*
	 * Do key permutation and split into two 28-bit subkeys.
	 */
	k0 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + uintptr(rawkey0>>int32(25))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 1*512 + uintptr(rawkey0>>Int32FromInt32(17)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 2*512 + uintptr(rawkey0>>Int32FromInt32(9)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 3*512 + uintptr(rawkey0>>Int32FromInt32(1)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 4*512 + uintptr(rawkey1>>int32(25))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 5*512 + uintptr(rawkey1>>Int32FromInt32(17)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 6*512 + uintptr(rawkey1>>Int32FromInt32(9)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskl)) + 7*512 + uintptr(rawkey1>>Int32FromInt32(1)&uint32(0x7f))*4))
	k1 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + uintptr(rawkey0>>int32(25))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 1*512 + uintptr(rawkey0>>Int32FromInt32(17)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 2*512 + uintptr(rawkey0>>Int32FromInt32(9)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 3*512 + uintptr(rawkey0>>Int32FromInt32(1)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 4*512 + uintptr(rawkey1>>int32(25))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 5*512 + uintptr(rawkey1>>Int32FromInt32(17)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 6*512 + uintptr(rawkey1>>Int32FromInt32(9)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fkey_perm_maskr)) + 7*512 + uintptr(rawkey1>>Int32FromInt32(1)&uint32(0x7f))*4))
	/*
	 * Rotate subkeys and do compression permutation.
	 */
	shifts = 0
	for round = 0; round < int32(16); round++ {
		shifts += int32(_key_shifts[round])
		t0 = k0<<shifts | k0>>(Int32FromInt32(28)-shifts)
		t1 = k1<<shifts | k1>>(Int32FromInt32(28)-shifts)
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fen_keysl)) + uintptr(round)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + uintptr(t0>>Int32FromInt32(21)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 1*512 + uintptr(t0>>Int32FromInt32(14)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 2*512 + uintptr(t0>>Int32FromInt32(7)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 3*512 + uintptr(t0&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 4*512 + uintptr(t1>>Int32FromInt32(21)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 5*512 + uintptr(t1>>Int32FromInt32(14)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 6*512 + uintptr(t1>>Int32FromInt32(7)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskl)) + 7*512 + uintptr(t1&uint32(0x7f))*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fen_keysr)) + uintptr(round)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + uintptr(t0>>Int32FromInt32(21)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 1*512 + uintptr(t0>>Int32FromInt32(14)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 2*512 + uintptr(t0>>Int32FromInt32(7)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 3*512 + uintptr(t0&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 4*512 + uintptr(t1>>Int32FromInt32(21)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 5*512 + uintptr(t1>>Int32FromInt32(14)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 6*512 + uintptr(t1>>Int32FromInt32(7)&uint32(0x7f))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fcomp_maskr)) + 7*512 + uintptr(t1&uint32(0x7f))*4))
	}
}

func _do_des(tls *TLS, ctx uintptr, l_out uintptr, r_out uintptr, count int32) {
	var f, l, r, r48l, r48r, v1 uint32
	var kl, kr, v4, v5 uintptr
	var round, v2, v3 int32
	f = f /* silence gcc */
	/* Do initial permutation (IP). */
	v1 = Uint32FromInt32(0)
	r = v1
	l = v1
	for first := true; ; first = false {
		if !first {
			count--
			v2 = count
			if !(v2 != 0) {
				break
			}
		}
		/* Do each round. */
		kl = uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fen_keysl))
		kr = uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fen_keysr))
		round = int32(16)
		for first := true; ; first = false {
			if !first {
				round--
				v3 = round
				if !(v3 != 0) {
					break
				}
			}
			/* Expand R to 48 bits (simulate the E-box). */
			r48l = r&uint32(0x00000001)<<int32(23) | r&uint32(0xf8000000)>>int32(9) | r&uint32(0x1f800000)>>int32(11) | r&uint32(0x01f80000)>>int32(13) | r&uint32(0x001f8000)>>int32(15)
			r48r = r&uint32(0x0001f800)<<int32(7) | r&uint32(0x00001f80)<<int32(5) | r&uint32(0x000001f8)<<int32(3) | r&uint32(0x0000001f)<<int32(1) | r&uint32(0x80000000)>>int32(31)
			/*
			 * Do salting for crypt() and friends, and
			 * XOR with the permuted key.
			 */
			f = (r48l ^ r48r) & (*Tdes_ctx)(unsafe.Pointer(ctx)).Fsaltbits
			v4 = kl
			kl += 4
			r48l ^= f ^ *(*uint32)(unsafe.Pointer(v4))
			v5 = kr
			kr += 4
			r48r ^= f ^ *(*uint32)(unsafe.Pointer(v5))
			/*
			 * Do sbox lookups (which shrink it back to 32 bits)
			 * and do the pbox permutation at the same time.
			 */
			f = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fpsbox)) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_m_sbox)) + uintptr(r48l>>int32(12)))))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fpsbox)) + 1*1024 + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_m_sbox)) + 1*4096 + uintptr(r48l&uint32(0xfff)))))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fpsbox)) + 2*1024 + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_m_sbox)) + 2*4096 + uintptr(r48r>>int32(12)))))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Fpsbox)) + 3*1024 + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_m_sbox)) + 3*4096 + uintptr(r48r&uint32(0xfff)))))*4))
			/* Now that we've permuted things, complete f(). */
			f ^= l
			l = r
			r = f
		}
		r = l
		l = f
	}
	/* Do final permutation (inverse of IP). */
	*(*uint32)(unsafe.Pointer(l_out)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + uintptr(l>>int32(24))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 1*1024 + uintptr(l>>Int32FromInt32(16)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 2*1024 + uintptr(l>>Int32FromInt32(8)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 3*1024 + uintptr(l&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 4*1024 + uintptr(r>>int32(24))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 5*1024 + uintptr(r>>Int32FromInt32(16)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 6*1024 + uintptr(r>>Int32FromInt32(8)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskl)) + 7*1024 + uintptr(r&uint32(0xff))*4))
	*(*uint32)(unsafe.Pointer(r_out)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + uintptr(l>>int32(24))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 1*1024 + uintptr(l>>Int32FromInt32(16)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 2*1024 + uintptr(l>>Int32FromInt32(8)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 3*1024 + uintptr(l&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 4*1024 + uintptr(r>>int32(24))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 5*1024 + uintptr(r>>Int32FromInt32(16)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 6*1024 + uintptr(r>>Int32FromInt32(8)&uint32(0xff))*4)) | *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tdes_ctx)(unsafe.Pointer(ctx))).Ffp_maskr)) + 7*1024 + uintptr(r&uint32(0xff))*4))
}

func _to64_msb_first(tls *TLS, s uintptr, v uint32) {
	var v1, v2, v3 uintptr
	v1 = s
	s++
	*(*int8)(unsafe.Pointer(v1)) = int8(_i64c(tls, int32(v>>int32(18)))) /* bits 23..18 */
	v2 = s
	s++
	*(*int8)(unsafe.Pointer(v2)) = int8(_i64c(tls, int32(v>>int32(12)))) /* bits 17..12 */
	v3 = s
	s++
	*(*int8)(unsafe.Pointer(v3)) = int8(_i64c(tls, int32(v>>int32(6)))) /* bits 11..6 */
	*(*int8)(unsafe.Pointer(s)) = int8(_i64c(tls, int32(v)))            /* bits 5..0 */
}

func _des_crypt(tls *TLS, ctx uintptr, output uintptr, key uintptr, setting uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var q uintptr
	var salt uint32
	var v1 int32
	var _ /* keybuf at bp+8 */ [2]uint32
	var _ /* r0 at bp+0 */ uint32
	var _ /* r1 at bp+4 */ uint32
	/*
	 * Copy the key, shifting each character up by one bit
	 * and padding with zeros.
	 */
	q = bp + 8
	for int64(q)-int64(bp+8) != int64(8) {
		*(*uint8)(unsafe.Pointer(q)) = uint8(int32(*(*uint8)(unsafe.Pointer(key))) << int32(1))
		if *(*uint8)(unsafe.Pointer(q)) != 0 {
			key++
		}
		q++
	}
	_des_setkey(tls, ctx, bp+8)
	/*
	 * setting - 2 bytes of salt
	 * key - up to 8 characters
	 */
	salt = uint32(_ascii_to_bin(tls, int8(*(*uint8)(unsafe.Pointer(setting + 1))))<<int32(6) | _ascii_to_bin(tls, int8(*(*uint8)(unsafe.Pointer(setting)))))
	*(*int8)(unsafe.Pointer(output)) = int8(*(*uint8)(unsafe.Pointer(setting)))
	/*
	 * If the encrypted password that the salt was extracted from
	 * is only 1 character long, the salt will be corrupted.  We
	 * need to ensure that the output string doesn't have an extra
	 * NUL in it!
	 */
	if *(*uint8)(unsafe.Pointer(setting + 1)) != 0 {
		v1 = int32(*(*uint8)(unsafe.Pointer(setting + 1)))
	} else {
		v1 = int32(*(*int8)(unsafe.Pointer(output)))
	}
	*(*int8)(unsafe.Pointer(output + 1)) = int8(v1)
	_setup_salt(tls, ctx, salt)
	/* Do it. */
	_do_des(tls, ctx, bp, bp+4, int32(25))
	/* Now encode the result. */
	/* Each call takes low-order 24 bits and stores 4 chars */
	/* bits 31..8 of r0 */
	_to64_msb_first(tls, output+uintptr(2), *(*uint32)(unsafe.Pointer(bp))>>Int32FromInt32(8))
	/* bits 7..0 of r0 and 31..16 of r1 */
	_to64_msb_first(tls, output+uintptr(6), *(*uint32)(unsafe.Pointer(bp))<<Int32FromInt32(16)|*(*uint32)(unsafe.Pointer(bp + 4))>>Int32FromInt32(16))
	/* bits 15..0 of r1 and two zero bits (plus extra zero byte) */
	_to64_msb_first(tls, output+uintptr(10), *(*uint32)(unsafe.Pointer(bp + 4))<<Int32FromInt32(8))
	/* extra zero byte is encoded as '.', fixing it */
	*(*int8)(unsafe.Pointer(output + 13)) = int8('\000')
	return output
}

func x___crypt_r(tls *TLS, clear uintptr, salt uintptr, data uintptr) (r uintptr) {
	bp := tls.Alloc(37152) /* tlsAllocs 37152 maxVaListSize 0 */
	defer tls.Free(37152)
	var _ /* des_ctx at bp+0 */ Tdes_ctx
	*(*Tdes_ctx)(unsafe.Pointer(bp)) = Tdes_ctx{}
	_des_init(tls, bp)
	return _des_crypt(tls, bp, data, clear, salt)
}

func x_crypt(tls *TLS, clear uintptr, salt uintptr) (r uintptr) {
	return x___crypt_r(tls, clear, salt, uintptr(unsafe.Pointer(&_buf)))
}

var _buf [128]int8

const m_L_cuserid = 20

type Tpasswd = struct {
	Fpw_name   uintptr
	Fpw_passwd uintptr
	Fpw_uid    uint32
	Fpw_gid    uint32
	Fpw_gecos  uintptr
	Fpw_dir    uintptr
	Fpw_shell  uintptr
}

func x_cuserid(tls *TLS, buf uintptr) (r uintptr) {
	bp := tls.Alloc(2120) /* tlsAllocs 2104 maxVaListSize 8 */
	defer tls.Free(2120)
	var _ /* ppw at bp+48 */ uintptr
	var _ /* pw at bp+0 */ Tpasswd
	var _ /* pwb at bp+56 */ [256]int64
	if x_getpwuid_r(tls, x_geteuid(tls), bp, bp+56, uint64(2048), bp+48) != 0 {
		return uintptr(0)
	}
	x_snprintf(tls, buf, uint64(m_L_cuserid), ts+15, VaList(bp+2112, (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_name))
	return buf
}

func x_dirname(tls *TLS, s uintptr) (r uintptr) {
	var i uint64
	if !(s != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) || !(x_strchr(tls, s, int32('/')) != 0) {
		return ts + 154
	}
	i = x_strlen(tls, s) - uint64(1)
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) == int32('/'); i-- {
	}
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) != int32('/'); i-- {
	}
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) == int32('/'); i-- {
	}
	if !(i != 0) && int32(*(*int8)(unsafe.Pointer(s))) == int32('/') {
		i++
	}
	*(*int8)(unsafe.Pointer(s + uintptr(i))) = 0
	return s
}

func x_ffs(tls *TLS, i int32) (r int32) {
	var j uint32
	j = uint32(i)
	for i = int32(1); j != 0 && !(j&Uint32FromInt32(1) != 0); {
		goto _1
	_1:
		j >>= uint32(1)
		i++
	}
	if j != 0 {
		return i
	}
	return 0
}

const m_FTW_PHYS = 1

type TFTW = struct {
	Fbase  int32
	Flevel int32
}

func x_ftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32) (r int32) {
	return x_nftw(tls, path, fn, fd_limit, int32(m_FTW_PHYS))
}

type Tutsname = struct {
	Fsysname      [65]int8
	Fnodename     [65]int8
	Frelease      [65]int8
	Fversion      [65]int8
	Fmachine      [65]int8
	F__domainname [65]int8
}

func x_getdomainname(tls *TLS, name uintptr, len1 uint64) (r int32) {
	*(*int8)(unsafe.Pointer(name)) = 0
	return 0
}

func x_getgrouplist(tls *TLS, user uintptr, gid uint32, groups uintptr, ngroups uintptr) (r int32) {
	if *(*int32)(unsafe.Pointer(ngroups)) < int32(1) {
		return -int32(1)
	}
	*(*uint32)(unsafe.Pointer(groups)) = gid
	*(*int32)(unsafe.Pointer(ngroups)) = int32(1)
	return 0
}

const m_MB_LEN_MAX = 4

var _optpos int32

func x_getopt(tls *TLS, argc int32, argv uintptr, optstring uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var i, k, l, v1, v2, v3, v5 int32
	var optchar uintptr
	var _ /* c at bp+0 */ int32
	var _ /* d at bp+4 */ int32
	if x_optind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) != 0) || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))))) != int32('-') || !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 1)) != 0) {
		return -int32(1)
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 1))) == int32('-') && !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + 2)) != 0) {
		x_optind++
		return -Int32FromInt32(1)
	}
	if !(_optpos != 0) {
		_optpos++
	}
	v1 = x_mbtowc(tls, bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))+uintptr(_optpos), uint64(m_MB_LEN_MAX))
	k = v1
	if v1 < 0 {
		k = int32(1)
		*(*int32)(unsafe.Pointer(bp)) = int32(0xfffd) /* replacement char */
	}
	optchar = *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(_optpos)
	x_optopt = *(*int32)(unsafe.Pointer(bp))
	_optpos += k
	if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(_optpos))) != 0) {
		x_optind++
		_optpos = 0
	}
	for i = 0; ; {
		v2 = x_mbtowc(tls, bp+4, optstring+uintptr(i), uint64(m_MB_LEN_MAX))
		l = v2
		if !(v2 != 0 && *(*int32)(unsafe.Pointer(bp + 4)) != *(*int32)(unsafe.Pointer(bp))) {
			break
		}
		goto _4
	_4:
		if l > 0 {
			v3 = l
		} else {
			v3 = int32(1)
		}
		i += v3
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) != *(*int32)(unsafe.Pointer(bp)) {
		if int32(*(*int8)(unsafe.Pointer(optstring))) != int32(':') && x_opterr != 0 {
			x_write(tls, int32(2), *(*uintptr)(unsafe.Pointer(argv)), x_strlen(tls, *(*uintptr)(unsafe.Pointer(argv))))
			x_write(tls, int32(2), ts+174, uint64(18))
			x_write(tls, int32(2), optchar, uint64(k))
			x_write(tls, int32(2), ts+193, uint64(1))
		}
		return int32('?')
	}
	if int32(*(*int8)(unsafe.Pointer(optstring + uintptr(i+int32(1))))) == int32(':') {
		if x_optind >= argc {
			if int32(*(*int8)(unsafe.Pointer(optstring))) == int32(':') {
				return int32(':')
			}
			if x_opterr != 0 {
				x_write(tls, int32(2), *(*uintptr)(unsafe.Pointer(argv)), x_strlen(tls, *(*uintptr)(unsafe.Pointer(argv))))
				x_write(tls, int32(2), ts+195, uint64(31))
				x_write(tls, int32(2), optchar, uint64(k))
				x_write(tls, int32(2), ts+193, uint64(1))
			}
			return int32('?')
		}
		v5 = x_optind
		x_optind++
		x_optarg = *(*uintptr)(unsafe.Pointer(argv + uintptr(v5)*8)) + uintptr(_optpos)
		_optpos = 0
	}
	return *(*int32)(unsafe.Pointer(bp))
}

const m___NR_getpriority = 140

func x_getpriority(tls *TLS, which int32, who int32) (r int32) {
	var ret int32
	ret = int32(_syscall2(tls, int64(m___NR_getpriority), int64(which), int64(who)))
	if ret < 0 {
		return ret
	}
	return int32(20) - ret
}

const m___NR_getrlimit = 97

func x_getrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1, v2 uint64
	var _ /* k_rlim at bp+0 */ [2]int64
	if _syscall2(tls, int64(m___NR_getrlimit), int64(resource), int64(bp)) < 0 {
		return -int32(1)
	}
	if (*(*[2]int64)(unsafe.Pointer(bp)))[0] == int64(-int32(1)) {
		v1 = uint64(-Int32FromInt32(1))
	} else {
		v1 = uint64((*(*[2]int64)(unsafe.Pointer(bp)))[0])
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = v1
	if (*(*[2]int64)(unsafe.Pointer(bp)))[int32(1)] == int64(-int32(1)) {
		v2 = uint64(-Int32FromInt32(1))
	} else {
		v2 = uint64((*(*[2]int64)(unsafe.Pointer(bp)))[int32(1)])
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = v2
	return 0
}

const m___NR_getrusage = 98

func x_getrusage(tls *TLS, who int32, ru uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var fakeaddr uintptr
	var _ /* ktv at bp+0 */ [2]struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	fakeaddr = ru + UintptrFromInt64(32) - UintptrFromInt64(32)
	if _syscall2(tls, int64(m___NR_getrusage), int64(who), int64(fakeaddr)) < 0 {
		return -int32(1)
	}
	x_memcpy(tls, bp, fakeaddr, uint64(32))
	(*Trusage)(unsafe.Pointer(ru)).Fru_utime.Ftv_sec = (*(*[2]struct {
		Ftv_sec  int64
		Ftv_usec int64
	})(unsafe.Pointer(bp)))[0].Ftv_sec
	(*Trusage)(unsafe.Pointer(ru)).Fru_utime.Ftv_usec = int32((*(*[2]struct {
		Ftv_sec  int64
		Ftv_usec int64
	})(unsafe.Pointer(bp)))[0].Ftv_usec)
	(*Trusage)(unsafe.Pointer(ru)).Fru_stime.Ftv_sec = (*(*[2]struct {
		Ftv_sec  int64
		Ftv_usec int64
	})(unsafe.Pointer(bp)))[int32(1)].Ftv_sec
	(*Trusage)(unsafe.Pointer(ru)).Fru_stime.Ftv_usec = int32((*(*[2]struct {
		Ftv_sec  int64
		Ftv_usec int64
	})(unsafe.Pointer(bp)))[int32(1)].Ftv_usec)
	return 0
}

func x_getsubopt(tls *TLS, opt uintptr, keys uintptr, val uintptr) (r int32) {
	var i int32
	var l uint64
	var s, v1, v2 uintptr
	s = *(*uintptr)(unsafe.Pointer(opt))
	*(*uintptr)(unsafe.Pointer(val)) = UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(opt)) = x_strchr(tls, s, int32(','))
	if *(*uintptr)(unsafe.Pointer(opt)) != 0 {
		v2 = opt
		v1 = *(*uintptr)(unsafe.Pointer(v2))
		*(*uintptr)(unsafe.Pointer(v2))++
		*(*int8)(unsafe.Pointer(v1)) = 0
	} else {
		*(*uintptr)(unsafe.Pointer(opt)) = s + uintptr(x_strlen(tls, s))
	}
	for i = 0; *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)) != 0; i++ {
		l = x_strlen(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)))
		if x_strncmp(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)), s, l) != 0 {
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(s + uintptr(l)))) == int32('=') {
			*(*uintptr)(unsafe.Pointer(val)) = s + uintptr(l)
		} else if *(*int8)(unsafe.Pointer(s + uintptr(l))) != 0 {
			continue
		}
		return i
	}
	return -int32(1)
}

const m___NR_ioctl = 16

type Twinsize = struct {
	Fws_row    uint16
	Fws_col    uint16
	Fws_xpixel uint16
	Fws_ypixel uint16
}

func x_ioctl(tls *TLS, fd int32, req int32, va uintptr) (r int32) {
	var ap, arg uintptr
	ap = va
	arg = VaUintptr(&ap)
	_ = ap
	return int32(_syscall3(tls, int64(m___NR_ioctl), int64(fd), int64(req), int64(arg)))
}

const m_EACCES = 13
const m_F_GETLK = 12
const m_F_LOCK = 1
const m_F_RDLCK = 0
const m_F_SETLK = 13
const m_F_TEST = 3
const m_F_TLOCK = 2
const m_F_ULOCK = 0
const m_F_UNLCK = 2
const m_F_WRLCK = 1
const m_SEEK_CUR = 1

func x_lockf(tls *TLS, fd int32, op int32, size int64) (r int32) {
	bp := tls.Alloc(48) /* tlsAllocs 32 maxVaListSize 8 */
	defer tls.Free(48)
	var _ /* l at bp+0 */ Tflock
	*(*Tflock)(unsafe.Pointer(bp)) = Tflock{Fl_type: int16(m_F_WRLCK), Fl_whence: int16(m_SEEK_CUR), Fl_len: size}
	switch op {
	case int32(m_F_TEST):
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = m_F_RDLCK
		if x_fcntl(tls, fd, int32(m_F_GETLK), VaList(bp+40, bp)) < 0 {
			return -int32(1)
		}
		if int32((*(*Tflock)(unsafe.Pointer(bp))).Fl_type) == int32(m_F_UNLCK) || (*(*Tflock)(unsafe.Pointer(bp))).Fl_pid == x_getpid(tls) {
			return 0
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EACCES)
		return -int32(1)
	case m_F_ULOCK:
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = int16(m_F_UNLCK)
		fallthrough
	case int32(m_F_TLOCK):
		return x_fcntl(tls, fd, int32(m_F_SETLK), VaList(bp+40, bp))
	case int32(m_F_LOCK):
		return x_fcntl(tls, fd, int32(m_F_SETLKW), VaList(bp+40, bp))
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
	return -int32(1)
}

const m_ENAMETOOLONG = 36
const m_ENOENT = 2
const m_FTW_D = 2
const m_FTW_DEPTH = 8
const m_FTW_DNR = 3
const m_FTW_DP = 6
const m_FTW_F = 1
const m_FTW_MOUNT = 2
const m_FTW_NS = 4
const m_FTW_SL = 5
const m_FTW_SLN = 7
const m_R_OK = 4
const m_S_IFLNK = 40960

//#define LFS64_2(x, y) weak_alias(x, y)

type Thistory = struct {
	Fchain uintptr
	Fdev   uint64
	Fino   uint64
	Flevel int32
	Fbase  int32
}

func _do_nftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32, h uintptr) (r1 int32) {
	bp := tls.Alloc(184) /* tlsAllocs 184 maxVaListSize 0 */
	defer tls.Free(184)
	var d, de, name, v6, v9 uintptr
	var j, l, v1 uint64
	var r, type1, v10, v11, v2, v3, v7 int32
	var v12, v8 bool
	var v4, v5 int64
	var _ /* lev at bp+176 */ TFTW
	var _ /* new at bp+144 */ Thistory
	var _ /* st at bp+0 */ Tstat
	l = x_strlen(tls, path)
	if l != 0 && int32(*(*int8)(unsafe.Pointer(path + uintptr(l-uint64(1))))) == int32('/') {
		v1 = l - uint64(1)
	} else {
		v1 = l
	}
	j = v1
	if flags&int32(m_FTW_PHYS) != 0 {
		v2 = x_lstat(tls, path, bp)
	} else {
		v2 = BoolInt32(x_stat(tls, path, bp) < 0)
	}
	if v2 != 0 {
		if !(flags&Int32FromInt32(m_FTW_PHYS) != 0) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOENT) && !(x_lstat(tls, path, bp) != 0) {
			type1 = int32(m_FTW_SLN)
		} else {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EACCES) {
				return -int32(1)
			} else {
				type1 = int32(m_FTW_NS)
			}
		}
	} else {
		if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFDIR) {
			if x_access(tls, path, int32(m_R_OK)) < 0 {
				type1 = int32(m_FTW_DNR)
			} else {
				if flags&int32(m_FTW_DEPTH) != 0 {
					type1 = int32(m_FTW_DP)
				} else {
					type1 = int32(m_FTW_D)
				}
			}
		} else {
			if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFLNK) {
				if flags&int32(m_FTW_PHYS) != 0 {
					type1 = int32(m_FTW_SL)
				} else {
					type1 = int32(m_FTW_SLN)
				}
			} else {
				type1 = int32(m_FTW_F)
			}
		}
	}
	if flags&int32(m_FTW_MOUNT) != 0 && h != 0 && ((*(*Tstat)(unsafe.Pointer(bp))).Fst_dev != (*Thistory)(unsafe.Pointer(h)).Fdev || (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino != (*Thistory)(unsafe.Pointer(h)).Fino) {
		return 0
	}
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fchain = h
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fdev = (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fino = (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino
	if h != 0 {
		v3 = (*Thistory)(unsafe.Pointer(h)).Flevel + int32(1)
	} else {
		v3 = 0
	}
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Flevel = v3
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fbase = int32(l + uint64(1))
	(*(*TFTW)(unsafe.Pointer(bp + 176))).Flevel = (*(*Thistory)(unsafe.Pointer(bp + 144))).Flevel
	if h != 0 {
		v4 = int64((*Thistory)(unsafe.Pointer(h)).Fbase)
	} else {
		v6 = x_strrchr(tls, path, int32('/'))
		name = v6
		if v6 != 0 {
			v5 = int64(name) - int64(path)
		} else {
			v5 = 0
		}
		v4 = v5
	}
	(*(*TFTW)(unsafe.Pointer(bp + 176))).Fbase = int32(v4)
	if v8 = !(flags&Int32FromInt32(m_FTW_DEPTH) != 0); v8 {
		v7 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+176)
		r = v7
	}
	if v8 && v7 != 0 {
		return r
	}
	for ; h != 0; h = (*Thistory)(unsafe.Pointer(h)).Fchain {
		if (*Thistory)(unsafe.Pointer(h)).Fdev == (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev && (*Thistory)(unsafe.Pointer(h)).Fino == (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino {
			return 0
		}
	}
	if (type1 == int32(m_FTW_D) || type1 == int32(m_FTW_DP)) && fd_limit != 0 {
		d = x_opendir(tls, path)
		if d != 0 {
			for {
				v9 = x_readdir(tls, d)
				de = v9
				if !(v9 != 0) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(de + 19))) == int32('.') && (!(*(*int8)(unsafe.Pointer(de + 19 + 1)) != 0) || int32(*(*int8)(unsafe.Pointer(de + 19 + 1))) == int32('.') && !(*(*int8)(unsafe.Pointer(de + 19 + 2)) != 0)) {
					continue
				}
				if x_strlen(tls, de+19) >= uint64(m_PATH_MAX)-l {
					*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENAMETOOLONG)
					x_closedir(tls, d)
					return -int32(1)
				}
				*(*int8)(unsafe.Pointer(path + uintptr(j))) = int8('/')
				x_strcpy(tls, path+uintptr(j)+uintptr(1), de+19)
				v10 = _do_nftw(tls, path, fn, fd_limit-int32(1), flags, bp+144)
				r = v10
				if v10 != 0 {
					x_closedir(tls, d)
					return r
				}
			}
			x_closedir(tls, d)
		} else if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EACCES) {
			return -int32(1)
		}
	}
	*(*int8)(unsafe.Pointer(path + uintptr(l))) = 0
	if v12 = flags&int32(m_FTW_DEPTH) != 0; v12 {
		v11 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+176)
		r = v11
	}
	if v12 && v11 != 0 {
		return r
	}
	return 0
}

func x_nftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32) (r int32) {
	bp := tls.Alloc(4104) /* tlsAllocs 4104 maxVaListSize 0 */
	defer tls.Free(4104)
	var l uint64
	var _ /* pathbuf at bp+0 */ [4097]int8
	if fd_limit <= 0 {
		return 0
	}
	l = x_strlen(tls, path)
	if l > uint64(m_PATH_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENAMETOOLONG)
		return -int32(1)
	}
	x_memcpy(tls, bp, path, l+uint64(1))
	return _do_nftw(tls, bp, fn, fd_limit, flags, UintptrFromInt32(0))
}

const m_TCSANOW = 0
const m_TIOCGPTN = 2147767344
const m_TIOCSPTLCK = 1074025521
const m_TIOCSWINSZ = 21524

func x_openpty(tls *TLS, m uintptr, s uintptr, name uintptr, tio uintptr, ws uintptr) (r int32) {
	bp := tls.Alloc(40) /* tlsAllocs 24 maxVaListSize 8 */
	defer tls.Free(40)
	var v1 int32
	var _ /* buf at bp+4 */ [20]int8
	var _ /* n at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = 0
	*(*int32)(unsafe.Pointer(m)) = x_open(tls, ts+227, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOCTTY), 0)
	if !(*(*int32)(unsafe.Pointer(m)) != 0) {
		return -int32(1)
	}
	if x_ioctl(tls, *(*int32)(unsafe.Pointer(m)), int32(m_TIOCSPTLCK), VaList(bp+32, bp)) != 0 || x_ioctl(tls, *(*int32)(unsafe.Pointer(m)), Int32FromUint32(m_TIOCGPTN), VaList(bp+32, bp)) != 0 {
		x_close(tls, *(*int32)(unsafe.Pointer(m)))
		return -int32(1)
	}
	if !(name != 0) {
		name = bp + 4
	}
	x_snprintf(tls, name, uint64(20), ts+237, VaList(bp+32, *(*int32)(unsafe.Pointer(bp))))
	v1 = x_open(tls, name, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOCTTY), 0)
	*(*int32)(unsafe.Pointer(s)) = v1
	if v1 < 0 {
		x_close(tls, *(*int32)(unsafe.Pointer(m)))
		return -int32(1)
	}
	if tio != 0 {
		x_tcsetattr(tls, *(*int32)(unsafe.Pointer(s)), m_TCSANOW, tio)
	}
	if ws != 0 {
		x_ioctl(tls, *(*int32)(unsafe.Pointer(s)), int32(m_TIOCSWINSZ), VaList(bp+32, ws))
	}
	return 0
}

func x_posix_openpt(tls *TLS, flags int32) (r int32) {
	return x_open(tls, ts+227, flags, 0)
}

func x_grantpt(tls *TLS, fd int32) (r int32) {
	return 0
}

func x_unlockpt(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var _ /* unlock at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = 0
	return x_ioctl(tls, fd, int32(m_TIOCSPTLCK), VaList(bp+16, bp))
}

func x_ptsname(tls *TLS, fd int32) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var s, v2, v3 uintptr
	var _ /* pty at bp+0 */ int32
	s = uintptr(unsafe.Pointer(&_buf1)) + uintptr(22) - uintptr(1)
	if x_ioctl(tls, fd, Int32FromUint32(m_TIOCGPTN), VaList(bp+16, bp)) != 0 {
		return UintptrFromInt32(0)
	}
	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		for *(*int32)(unsafe.Pointer(bp)) != 0 {
			s--
			v2 = s
			*(*int8)(unsafe.Pointer(v2)) = int8(int32('0') + *(*int32)(unsafe.Pointer(bp))%int32(10))
			goto _1
		_1:
			*(*int32)(unsafe.Pointer(bp)) /= int32(10)
		}
	} else {
		s--
		v3 = s
		*(*int8)(unsafe.Pointer(v3)) = int8('0')
	}
	s -= uintptr(9)
	*(*int8)(unsafe.Pointer(s)) = int8('/')
	*(*int8)(unsafe.Pointer(s + 1)) = int8('d')
	*(*int8)(unsafe.Pointer(s + 2)) = int8('e')
	*(*int8)(unsafe.Pointer(s + 3)) = int8('v')
	*(*int8)(unsafe.Pointer(s + 4)) = int8('/')
	*(*int8)(unsafe.Pointer(s + 5)) = int8('p')
	*(*int8)(unsafe.Pointer(s + 6)) = int8('t')
	*(*int8)(unsafe.Pointer(s + 7)) = int8('s')
	*(*int8)(unsafe.Pointer(s + 8)) = int8('/')
	return s
}

var _buf1 [22]int8

func x_realpath(tls *TLS, filename uintptr, resolved uintptr) (r uintptr) {
	return uintptr(0)
}

const m___NR_sched_yield = 24

func x___yield(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_sched_yield)))
}

func x_setpriority(tls *TLS, which int32, who int32, prio int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_getpriority), int64(which), int64(who), int64(prio)))
}

const m___NR_setrlimit = 160

func x_setrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* k_rlim at bp+0 */ [2]int64
	*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
		0: int64((*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur),
		1: int64((*Trlimit)(unsafe.Pointer(rlim)).Frlim_max)}
	return int32(_syscall2(tls, int64(m___NR_setrlimit), int64(resource), int64(bp)))
}

const m_LOG_NDELAY = 8
const m_LOG_PID = 1
const m_PF_LOCAL = 1
const m_SIGPIPE = 13
const m_SOCK_STREAM = 1

type Tsocklen_t = uint32

type Tsa_family_t = uint16

type Tiovec = struct {
	Fiov_base uintptr
	Fiov_len  uint64
}

type Tmsghdr = struct {
	Fmsg_name       uintptr
	Fmsg_namelen    uint32
	Fmsg_iov        uintptr
	Fmsg_iovlen     int32
	Fmsg_control    uintptr
	Fmsg_controllen uint32
	Fmsg_flags      int32
}

type Tcmsghdr = struct {
	Fcmsg_len   uint32
	Fcmsg_level int32
	Fcmsg_type  int32
}

type Tucred = struct {
	Fpid int32
	Fuid uint32
	Fgid uint32
}

type Tlinger = struct {
	Fl_onoff  int32
	Fl_linger int32
}

type Tsockaddr = struct {
	Fsa_family uint16
	Fsa_data   [14]int8
}

type Tsockaddr_storage = struct {
	Fss_family    uint16
	F__ss_align   int64
	F__ss_padding [118]int8
	F__ccgo_pad3  [2]byte
}

//#define LFS64_2(x, y) weak_alias(x, y)

var _lock4 int32
var _log_ident uintptr
var _log_opt int32
var _log_facility = Int32FromInt32(1) << Int32FromInt32(3)
var _log_mask = int32(0xff)
var _log_f uintptr

func x_setlogmask(tls *TLS, maskpri int32) (r int32) {
	var old int32
	old = _log_mask
	if maskpri != 0 {
		_log_mask = maskpri
	}
	return old
}

var _log_addr = struct {
	Fsun_family  int16
	Fsun_path    [9]int8
	F__ccgo_pad2 [1]byte
}{Fsun_family: int16(m_PF_LOCAL), Fsun_path: [9]int8{'/', 'd', 'e', 'v', '/', 'l', 'o', 'g'}}

func x_closelog(tls *TLS) {
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock4))
		_ = Int32FromInt32(1)
	}
	if _log_f != 0 {
		x_fclose(tls, _log_f)
	}
	_log_f = UintptrFromInt32(0)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock4)))) = 0
}

func ___openlog(tls *TLS, ident uintptr, opt int32, facility int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	var fd int32
	_log_ident = ident
	_log_opt = opt
	_log_facility = facility
	if !(opt&Int32FromInt32(m_LOG_NDELAY) != 0) || _log_f != 0 {
		return
	}
	fd = x_socket(tls, int32(m_PF_LOCAL), int32(m_SOCK_STREAM), 0)
	x_fcntl(tls, fd, int32(m_F_SETFD), VaList(bp+8, int32(m_FD_CLOEXEC)))
	if x_connect(tls, fd, uintptr(unsafe.Pointer(&_log_addr)), uint32(Uint64FromInt64(2)+Uint64FromInt64(9))) < 0 {
		x_close(tls, fd)
	} else {
		_log_f = x___fdopen(tls, fd, ts+249)
	}
}

func x_openlog(tls *TLS, ident uintptr, opt int32, facility int32) {
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock4))
		_ = Int32FromInt32(1)
	}
	___openlog(tls, ident, opt, facility)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock4)))) = 0
}

func x_syslog(tls *TLS, priority int32, message uintptr, va uintptr) {
	bp := tls.Alloc(256) /* tlsAllocs 232 maxVaListSize 16 */
	defer tls.Free(256)
	var ap uintptr
	var _ /* now at bp+168 */ int64
	var _ /* sa at bp+0 */ Tsigaction
	var _ /* timebuf at bp+152 */ [16]int8
	var _ /* tm at bp+176 */ Ttm
	//const char *fmt, *ident, *sep;
	//int i;
	if !(_log_mask&(Int32FromInt32(1)<<(priority&Int32FromInt32(7))) != 0) || priority & ^Int32FromInt32(0x3ff) != 0 {
		return
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock4))
		_ = Int32FromInt32(1)
	}
	if !(_log_f != 0) {
		___openlog(tls, _log_ident, _log_opt|int32(m_LOG_NDELAY), _log_facility)
	}
	if !(_log_f != 0) {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock4)))) = 0
		return
	}
	x_memset(tls, bp, 0, uint64(152))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = UintptrFromInt32(1)
	if x___sigaction(tls, int32(m_SIGPIPE), bp, bp) < 0 {
		// we must abandon logging or we might cause SIGPIPE
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock4)))) = 0
		return
	}
	*(*int64)(unsafe.Pointer(bp + 168)) = x_time(tls, UintptrFromInt32(0))
	x_gmtime_r(tls, bp+168, bp+176)
	x_strftime(tls, bp+152, uint64(16), ts+252, bp+176)
	x_fprintf(tls, _log_f, ts+261, VaList(bp+240, priority, bp+152))
	if _log_ident != 0 {
		x_fprintf(tls, _log_f, ts+15, VaList(bp+240, _log_ident))
	}
	if _log_opt&int32(m_LOG_PID) != 0 {
		x_fprintf(tls, _log_f, ts+269, VaList(bp+240, x_getpid(tls)))
	}
	if _log_ident != 0 {
		x_fprintf(tls, _log_f, ts+274, 0)
	}
	ap = va
	x_vfprintf(tls, _log_f, message, ap)
	_ = ap
	x_fputc(tls, 0, _log_f)
	x_fflush(tls, _log_f)
	// Note: LOG_CONS is not supported because it is annoying!!
	// syslogd will send messages to console if it deems them appropriate!
	x___sigaction(tls, int32(m_SIGPIPE), bp, UintptrFromInt32(0))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock4)))) = 0
}

const m___NR_uname = 63

func x_uname(tls *TLS, uts uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_uname), int64(uts)))
}

const m___NR_madvise = 28

func x___madvise(tls *TLS, addr uintptr, len1 uint64, advice int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_madvise), int64(addr), int64(len1), int64(advice)))
}

const m___NR_mlock = 149

func x_mlock(tls *TLS, addr uintptr, len1 uint64) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_mlock), int64(addr), int64(len1)))
}

const m___NR_mlockall = 151

func x_mlockall(tls *TLS, flags int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_mlockall), int64(flags)))
}

const m___NR_mmap = 9

func x___mmap(tls *TLS, start uintptr, len1 uint64, prot int32, flags int32, fd int32, off int64) (r uintptr) {
	if uint64(8) > uint64(8) {
		if off&int64(0xfff)|int64(uint64(off)>>(Uint64FromInt32(12)+Uint64FromInt32(8)*(Uint64FromInt64(8)-Uint64FromInt64(8)))) != 0 {
			start = uintptr(-Int32FromInt32(1))
		}
	}
	return uintptr(_syscall6(tls, int64(m___NR_mmap), int64(start), int64(len1), int64(prot), int64(flags), int64(fd), off))
}

const m___NR_mprotect = 10

func x_mprotect(tls *TLS, addr uintptr, len1 uint64, prot int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_mprotect), int64(addr), int64(len1), int64(prot)))
}

const m___NR_mremap = 25

func x___mremap(tls *TLS, old_addr uintptr, old_len uint64, new_len uint64, flags int32, va uintptr) (r uintptr) {
	var ap, new_addr uintptr
	ap = va
	new_addr = VaUintptr(&ap)
	_ = ap
	return uintptr(_syscall5(tls, int64(m___NR_mremap), int64(old_addr), int64(old_len), int64(new_len), int64(flags), int64(new_addr)))
}

const m___NR_msync = 26

func x_msync(tls *TLS, start uintptr, len1 uint64, flags int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_msync), int64(start), int64(len1), int64(flags)))
}

const m___NR_munlock = 150

func x_munlock(tls *TLS, addr uintptr, len1 uint64) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_munlock), int64(addr), int64(len1)))
}

const m___NR_munlockall = 152

func x_munlockall(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_munlockall)))
}

const m___NR_munmap = 11

func x___munmap(tls *TLS, start uintptr, len1 uint64) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_munmap), int64(start), int64(len1)))
}

func x_posix_madvise(tls *TLS, addr uintptr, len1 uint64, advice int32) (r int32) {
	return 0
}

func x_btowc(tls *TLS, c int32) (r int32) {
	var v1 int32
	if uint32(c) < uint32(128) {
		v1 = c
	} else {
		v1 = -int32(1)
	}
	return v1
}

const m_SA = 194
const m_SB = 245

func x_decode(tls *TLS, c uintptr, b uint32) (r int32) {
	if !(*(*uint32)(unsafe.Pointer(c)) != 0) {
		if b < uint32(0x80) {
			*(*uint32)(unsafe.Pointer(c)) = b
			return int32(1)
		} else if b-uint32(0xc2) >= Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
			*(*uint32)(unsafe.Pointer(c)) = uint32((Int32FromInt32(0x40) - Int32FromInt32(0x80)) << Int32FromInt32(23))
			return -int32(1)
		}
		*(*uint32)(unsafe.Pointer(c)) = x___fsmu8[b-uint32(0xc2)]
		return 0
	}
	if (b>>int32(3)-uint32(0x10)|(b>>int32(3)+uint32(int32(*(*uint32)(unsafe.Pointer(c)))>>Int32FromInt32(26))))&uint32(^Int32FromInt32(7)) != 0 {
		*(*uint32)(unsafe.Pointer(c)) = uint32(0)
		return -int32(1)
	}
	*(*uint32)(unsafe.Pointer(c)) = *(*uint32)(unsafe.Pointer(c))<<int32(6) | (b - uint32(0x80))
	return BoolInt32(!(*(*uint32)(unsafe.Pointer(c))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0))
}

func x_mblen(tls *TLS, s uintptr, n uint64) (r int32) {
	return x_mbtowc(tls, uintptr(0), s, n)
}

func x_mbrlen(tls *TLS, s uintptr, n uint64, st uintptr) (r uint64) {
	var v1 uintptr
	if st != 0 {
		v1 = st
	} else {
		v1 = uintptr(unsafe.Pointer(&_internal))
	}
	return x_mbrtowc(tls, uintptr(0), s, n, v1)
}

var _internal uint32

func x_mbrtowc(tls *TLS, _wc uintptr, src uintptr, n uint64, st uintptr) (r uint64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _wc
	var N, c uint32
	var s, v2, v3 uintptr
	var v1 int32
	s = src
	N = uint32(n)
	if !(st != 0) {
		st = uintptr(unsafe.Pointer(&_internal_state))
	}
	c = *(*uint32)(unsafe.Pointer(st))
	if !(s != 0) {
		s = ts
		*(*uintptr)(unsafe.Pointer(bp)) = bp
		n = uint64(1)
	} else if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
		*(*uintptr)(unsafe.Pointer(bp)) = bp
	}
	if !(n != 0) {
		return uint64(-Int32FromInt32(2))
	}
	if !(c != 0) {
		if int32(*(*uint8)(unsafe.Pointer(s))) < int32(0x80) {
			v1 = int32(*(*uint8)(unsafe.Pointer(s)))
			*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) = v1
			return BoolUint64(!!(v1 != 0))
		}
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
			goto ilseq
		}
		v2 = s
		s++
		c = x___fsmu8[uint32(*(*uint8)(unsafe.Pointer(v2)))-uint32(0xc2)]
		n--
	}
	if n != 0 {
		if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
			goto ilseq
		}
	loop:
		v3 = s
		s++
		c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v3)))-int32(0x80))
		n--
		if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
			*(*uint32)(unsafe.Pointer(st)) = uint32(0)
			*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) = int32(c)
			return uint64(N) - n
		}
		if n != 0 {
			if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
				goto ilseq
			}
			goto loop
		}
	}
	*(*uint32)(unsafe.Pointer(st)) = c
	return uint64(-Int32FromInt32(2))
ilseq:
	*(*uint32)(unsafe.Pointer(st)) = uint32((Int32FromInt32(0x40) - Int32FromInt32(0x80)) << Int32FromInt32(23))
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

var _internal_state uint32

func x_mbsinit(tls *TLS, st uintptr) (r int32) {
	return BoolInt32(!(*(*uint32)(unsafe.Pointer(st)) != 0))
}

func x_mbsnrtowcs(tls *TLS, wcs uintptr, src uintptr, n uint64, wn uint64, st uintptr) (r uint64) {
	bp := tls.Alloc(1032) /* tlsAllocs 1032 maxVaListSize 0 */
	defer tls.Free(1032)
	var cnt, l, n2, v1 uint64
	var ws uintptr
	var v2 bool
	var _ /* s at bp+1024 */ uintptr
	var _ /* wbuf at bp+0 */ [256]int32
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 1024)) = *(*uintptr)(unsafe.Pointer(src))
	if !(wcs != 0) {
		ws = bp
		wn = Uint64FromInt64(1024) / Uint64FromInt64(4)
	} else {
		ws = wcs
	}
	/* making sure output buffer size is at most n/4 will ensure
	 * that mbsrtowcs never reads more than n input bytes. thus
	 * we can use mbsrtowcs as long as it's practical.. */
	for {
		if v2 = *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 && wn != 0; v2 {
			v1 = n / Uint64FromInt32(4)
			n2 = v1
		}
		if !(v2 && (v1 >= wn || n2 > uint64(32))) {
			break
		}
		if n2 >= wn {
			n2 = wn
		}
		n -= n2
		l = x_mbsrtowcs(tls, ws, bp+1024, n2, st)
		if !(l+Uint64FromInt32(1) != 0) {
			cnt = l
			wn = uint64(0)
			break
		}
		if ws != bp {
			ws += uintptr(l) * 4
			wn -= l
		}
		cnt += l
	}
	if *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 {
		for wn != 0 && n != 0 {
			l = x_mbrtowc(tls, ws, *(*uintptr)(unsafe.Pointer(bp + 1024)), n, st)
			if l+uint64(2) <= uint64(2) {
				if !(l+Uint64FromInt32(1) != 0) {
					cnt = l
					break
				}
				/* have to roll back partial character */
				*(*uint32)(unsafe.Pointer(st)) = uint32(0)
				break
			}
			*(*uintptr)(unsafe.Pointer(bp + 1024)) += uintptr(l)
			n -= l
			/* safe - this loop runs fewer than sizeof(wbuf)/8 times */
			ws += 4
			wn--
			cnt++
		}
	}
	if wcs != 0 {
		*(*uintptr)(unsafe.Pointer(src)) = *(*uintptr)(unsafe.Pointer(bp + 1024))
	}
	return cnt
}

func x_mbsrtowcs(tls *TLS, ws uintptr, src uintptr, wn uint64, st uintptr) (r uint64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var s, wsorig, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v27, v28, v29, v30, v5, v8, v9 uintptr
	var _ /* c at bp+0 */ uint32
	s = *(*uintptr)(unsafe.Pointer(src))
	wsorig = ws
	if !(st != 0) {
		st = bp
		*(*uint32)(unsafe.Pointer(bp)) = Uint32FromInt32(0)
	} else {
		*(*uint32)(unsafe.Pointer(bp)) = *(*uint32)(unsafe.Pointer(st))
	}
	if *(*uint32)(unsafe.Pointer(bp)) != 0 {
		*(*uint32)(unsafe.Pointer(st)) = uint32(0)
		if !(ws != 0) {
			wn = uint64(0)
			goto resume0
		}
		goto resume
	}
	if !!(ws != 0) {
		goto _1
	}
	wn = uint64(0)
_4:
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) >= Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
		for uint64(s)&uint64(3) != 0 && uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
			s++
			wn++
		}
		for !((*(*uint32)(unsafe.Pointer(s))|(*(*uint32)(unsafe.Pointer(s))-Uint32FromInt32(0x01010101)))&Uint32FromUint32(0x80808080) != 0) {
			s += uintptr(4)
			wn += uint64(4)
		}
		for uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
			s++
			wn++
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			return wn
		}
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) >= Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
			goto ilseq2
		}
	}
	v5 = s
	s++
	*(*uint32)(unsafe.Pointer(bp)) = x___fsmu8[uint32(*(*uint8)(unsafe.Pointer(v5)))-uint32(0xc2)]
_7:
resume0:
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(*(*uint32)(unsafe.Pointer(bp)))>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		goto ilseq2
	}
	s++
	*(*uint32)(unsafe.Pointer(bp)) <<= uint32(6)
	if !(*(*uint32)(unsafe.Pointer(bp))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		goto _6
	}
	v8 = s
	s++
	if uint32(*(*uint8)(unsafe.Pointer(v8)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq2
	}
	*(*uint32)(unsafe.Pointer(bp)) <<= uint32(6)
	if !(*(*uint32)(unsafe.Pointer(bp))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		goto _6
	}
	v9 = s
	s++
	if uint32(*(*uint8)(unsafe.Pointer(v9)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq2
	}
	if 0 != 0 {
		goto _7
	}
	goto _6
_6:
	wn++
	*(*uint32)(unsafe.Pointer(bp)) = uint32(0)
	goto _3
_3:
	goto _4
	goto _2
_2:
_1:
_11:
	if !(wn != 0) {
		goto _10
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) >= Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
		if wn >= uint64(7) {
			for uint64(s)&uint64(3) != 0 && uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
				v12 = ws
				ws += 4
				v13 = s
				s++
				*(*int32)(unsafe.Pointer(v12)) = int32(*(*uint8)(unsafe.Pointer(v13)))
				wn--
			}
			for wn >= uint64(4) && !((*(*uint32)(unsafe.Pointer(s))|(*(*uint32)(unsafe.Pointer(s))-Uint32FromInt32(0x01010101)))&Uint32FromUint32(0x80808080) != 0) {
				v14 = ws
				ws += 4
				v15 = s
				s++
				*(*int32)(unsafe.Pointer(v14)) = int32(*(*uint8)(unsafe.Pointer(v15)))
				v16 = ws
				ws += 4
				v17 = s
				s++
				*(*int32)(unsafe.Pointer(v16)) = int32(*(*uint8)(unsafe.Pointer(v17)))
				v18 = ws
				ws += 4
				v19 = s
				s++
				*(*int32)(unsafe.Pointer(v18)) = int32(*(*uint8)(unsafe.Pointer(v19)))
				v20 = ws
				ws += 4
				v21 = s
				s++
				*(*int32)(unsafe.Pointer(v20)) = int32(*(*uint8)(unsafe.Pointer(v21)))
				wn -= uint64(4)
			}
		}
		for wn != 0 && uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
			v22 = ws
			ws += 4
			v23 = s
			s++
			*(*int32)(unsafe.Pointer(v22)) = int32(*(*uint8)(unsafe.Pointer(v23)))
			wn--
		}
		if !(wn != 0) {
			goto _10
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			*(*int32)(unsafe.Pointer(ws)) = 0
			*(*uintptr)(unsafe.Pointer(src)) = uintptr(0)
			return uint64((int64(ws) - int64(wsorig)) / 4)
		}
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) >= Uint32FromUint32(0xf5)-Uint32FromUint32(0xc2) {
			goto ilseq
		}
	}
	v24 = s
	s++
	*(*uint32)(unsafe.Pointer(bp)) = x___fsmu8[uint32(*(*uint8)(unsafe.Pointer(v24)))-uint32(0xc2)]
_26:
resume:
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(*(*uint32)(unsafe.Pointer(bp)))>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		goto ilseq
	}
	v27 = s
	s++
	*(*uint32)(unsafe.Pointer(bp)) = *(*uint32)(unsafe.Pointer(bp))<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v27)))-int32(0x80))
	if !(*(*uint32)(unsafe.Pointer(bp))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		goto _25
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v28 = s
	s++
	*(*uint32)(unsafe.Pointer(bp)) = *(*uint32)(unsafe.Pointer(bp))<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v28)))-int32(0x80))
	if !(*(*uint32)(unsafe.Pointer(bp))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		goto _25
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v29 = s
	s++
	*(*uint32)(unsafe.Pointer(bp)) = *(*uint32)(unsafe.Pointer(bp))<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v29)))-int32(0x80))
	if 0 != 0 {
		goto _26
	}
	goto _25
_25:
	v30 = ws
	ws += 4
	*(*int32)(unsafe.Pointer(v30)) = int32(*(*uint32)(unsafe.Pointer(bp)))
	wn--
	*(*uint32)(unsafe.Pointer(bp)) = uint32(0)
	goto _11
_10:
	*(*uintptr)(unsafe.Pointer(src)) = s
	return uint64((int64(ws) - int64(wsorig)) / 4)
ilseq:
	*(*uintptr)(unsafe.Pointer(src)) = s
ilseq2:
	/* enter permanently failing state */
	*(*uint32)(unsafe.Pointer(st)) = uint32((Int32FromInt32(0x40) - Int32FromInt32(0x80)) << Int32FromInt32(23))
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

func x_mbstowcs(tls *TLS, ws uintptr, _s uintptr, wn uint64) (r uint64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _s
	var _ /* st at bp+8 */ Tmbstate_t
	*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
	return x_mbsrtowcs(tls, ws, bp, wn, bp+8)
}

func x_mbtowc(tls *TLS, wc uintptr, s uintptr, n uint64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var v1 uint64
	var _ /* st at bp+0 */ Tmbstate_t
	*(*Tmbstate_t)(unsafe.Pointer(bp)) = Tmbstate_t{}
	n = x_mbrtowc(tls, wc, s, n, bp)
	if n+uint64(2) != 0 {
		v1 = n
	} else {
		v1 = uint64(-Int32FromInt32(1))
	}
	return int32(v1)
}

func x_wcrtomb(tls *TLS, s uintptr, wc int32, st uintptr) (r uint64) {
	var v1, v2, v3, v4, v5, v6 uintptr
	if !(s != 0) {
		return uint64(1)
	}
	if uint32(wc) < uint32(0x80) {
		*(*int8)(unsafe.Pointer(s)) = int8(wc)
		return uint64(1)
	} else {
		if uint32(wc) < uint32(0x800) {
			v1 = s
			s++
			*(*int8)(unsafe.Pointer(v1)) = int8(int32(0xc0) | wc>>Int32FromInt32(6))
			*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
			return uint64(2)
		} else {
			if uint32(wc) < uint32(0xd800) || uint32(wc)-uint32(0xe000) < uint32(0x2000) {
				v2 = s
				s++
				*(*int8)(unsafe.Pointer(v2)) = int8(int32(0xe0) | wc>>Int32FromInt32(12))
				v3 = s
				s++
				*(*int8)(unsafe.Pointer(v3)) = int8(int32(0x80) | wc>>Int32FromInt32(6)&int32(0x3f))
				*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
				return uint64(3)
			} else if uint32(wc)-uint32(0x10000) < uint32(0x100000) {
				v4 = s
				s++
				*(*int8)(unsafe.Pointer(v4)) = int8(int32(0xf0) | wc>>Int32FromInt32(18))
				v5 = s
				s++
				*(*int8)(unsafe.Pointer(v5)) = int8(int32(0x80) | wc>>Int32FromInt32(12)&int32(0x3f))
				v6 = s
				s++
				*(*int8)(unsafe.Pointer(v6)) = int8(int32(0x80) | wc>>Int32FromInt32(6)&int32(0x3f))
				*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
				return uint64(4)
			}
		}
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

func x_wcsnrtombs(tls *TLS, dst uintptr, wcs uintptr, wn uint64, n uint64, st uintptr) (r uint64) {
	bp := tls.Alloc(264) /* tlsAllocs 264 maxVaListSize 0 */
	defer tls.Free(264)
	var cnt, l, n2, v1 uint64
	var s uintptr
	var v2 bool
	var _ /* buf at bp+0 */ [256]int8
	var _ /* ws at bp+256 */ uintptr
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 256)) = *(*uintptr)(unsafe.Pointer(wcs))
	if !(dst != 0) {
		s = bp
		n = Uint64FromInt64(256)
	} else {
		s = dst
	}
	for {
		if v2 = n != 0; v2 {
			v1 = wn
			n2 = v1
		}
		if !(v2 && (v1 >= n || n2 > uint64(32))) {
			break
		}
		if n2 >= n {
			n2 = n
		}
		wn -= n2
		l = x_wcsrtombs(tls, s, bp+256, n2, uintptr(0))
		if !(l+Uint64FromInt32(1) != 0) {
			cnt = l
			n = uint64(0)
			break
		}
		if s != bp {
			s += uintptr(l)
			n -= l
		}
		cnt += l
	}
	for n != 0 && wn != 0 {
		l = x_wcrtomb(tls, s, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 256)))), uintptr(0))
		if !(l+Uint64FromInt32(1) != 0) {
			cnt = l
			break
		}
		*(*uintptr)(unsafe.Pointer(bp + 256)) += 4
		wn--
		/* safe - this loop runs fewer than sizeof(buf) times */
		s += uintptr(l)
		n -= l
		cnt++
	}
	if dst != 0 {
		*(*uintptr)(unsafe.Pointer(wcs)) = *(*uintptr)(unsafe.Pointer(bp + 256))
	}
	return cnt
}

func x_wcsrtombs(tls *TLS, s uintptr, ws uintptr, n uint64, st uintptr) (r uint64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var N, l uint64
	var ws2, v1, v2 uintptr
	var _ /* buf at bp+0 */ [4]int8
	N = n
	if !(s != 0) {
		n = uint64(0)
		ws2 = *(*uintptr)(unsafe.Pointer(ws))
		for ; *(*int32)(unsafe.Pointer(ws2)) != 0; ws2 += 4 {
			if *(*int32)(unsafe.Pointer(ws2)) >= int32(0x80) {
				l = x_wcrtomb(tls, bp, *(*int32)(unsafe.Pointer(ws2)), uintptr(0))
				if !(l+Uint64FromInt32(1) != 0) {
					return uint64(-Int32FromInt32(1))
				}
				n += l
			} else {
				n++
			}
		}
		return n
	}
	for n >= uint64(4) && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0 {
		if *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) >= int32(0x80) {
			l = x_wcrtomb(tls, s, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			s += uintptr(l)
			n -= l
		} else {
			v1 = s
			s++
			*(*int8)(unsafe.Pointer(v1)) = int8(*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	for n != 0 && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0 {
		if *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) >= int32(0x80) {
			l = x_wcrtomb(tls, bp, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			if l > n {
				return N - n
			}
			x_wcrtomb(tls, s, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			s += uintptr(l)
			n -= l
		} else {
			v2 = s
			s++
			*(*int8)(unsafe.Pointer(v2)) = int8(*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	if n != 0 {
		*(*int8)(unsafe.Pointer(s)) = 0
	}
	*(*uintptr)(unsafe.Pointer(ws)) = uintptr(0)
	return N - n
}

func x_wcstombs(tls *TLS, s uintptr, _ws uintptr, n uint64) (r uint64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _ws
	return x_wcsrtombs(tls, s, bp, n, uintptr(0))
}

func x_wctob(tls *TLS, c int32) (r int32) {
	if uint32(c) < uint32(128) {
		return c
	}
	return -int32(1)
}

func x_wctomb(tls *TLS, s uintptr, wc int32) (r int32) {
	if !(s != 0) {
		return 0
	}
	return int32(x_wcrtomb(tls, s, wc, uintptr(0)))
}

const m_F_GETFL = 3
const m_MSG_NOSIGNAL = 16384
const m_O_NONBLOCK = 2048
const m_PACKET_MAX = 512
const m_PF_INET = 2
const m_PF_INET6 = 10
const m_RETRY = 1
const m_RR_A = 1
const m_RR_AAAA = 28
const m_RR_PTR = 12
const m_SOCK_DGRAM = 2
const m_TIMEOUT = 5

type Taddrinfo = struct {
	Fai_flags     int32
	Fai_family    int32
	Fai_socktype  int32
	Fai_protocol  int32
	Fai_addrlen   uint32
	Fai_addr      uintptr
	Fai_canonname uintptr
	Fai_next      uintptr
}

type Tnetent = struct {
	Fn_name     uintptr
	Fn_aliases  uintptr
	Fn_addrtype int32
	Fn_net      uint32
}

type Thostent = struct {
	Fh_name      uintptr
	Fh_aliases   uintptr
	Fh_addrtype  int32
	Fh_length    int32
	Fh_addr_list uintptr
}

type Tservent = struct {
	Fs_name    uintptr
	Fs_aliases uintptr
	Fs_port    int32
	Fs_proto   uintptr
}

type Tprotoent = struct {
	Fp_name      uintptr
	Fp_aliases   uintptr
	Fp_proto     int32
	F__ccgo_pad3 [4]byte
}

type TFILE = struct {
	Fflags     uint32
	Frpos      uintptr
	Frstop     uintptr
	Frend      uintptr
	Fwend      uintptr
	Fwpos      uintptr
	Fwstop     uintptr
	Fwbase     uintptr
	Fdummy01   [3]uintptr
	Fbuf       uintptr
	Fbuf_size  uint64
	Fprev      uintptr
	Fnext      uintptr
	Ffd        int32
	Fpipe_pid  int32
	Fdummy2    int64
	Fdummy3    int16
	Fdummy4    int8
	Flbf       int8
	Flock      int32
	Flockcount int32
	Fowner     uintptr
	Foff       int64
	Fflush     uintptr
	Fwide_data uintptr
	Fread      uintptr
	Fwrite     uintptr
	Fseek      uintptr
	Fmode      int32
	Fclose1    uintptr
}

type T__FILE_s = TFILE

type Tin_port_t = uint16

type Tin_addr_t = uint32

type Tin_addr = struct {
	Fs_addr uint32
}

type Tsockaddr_in = struct {
	Fsin_family uint16
	Fsin_port   uint16
	Fsin_addr   Tin_addr
	Fsin_zero   [8]uint8
}

type Tin6_addr = struct {
	F__in6_union struct {
		F__s6_addr32 [0][4]uint32
		F__s6_addr   [16]uint8
	}
}

type Tsockaddr_in6 = struct {
	Fsin6_family   uint16
	Fsin6_port     uint16
	Fsin6_flowinfo uint32
	Fsin6_addr     Tin6_addr
	Fsin6_scope_id uint32
}

type Tipv6_mreq = struct {
	Fipv6mr_multiaddr Tin6_addr
	Fipv6mr_interface uint32
}

type Tip_opts = struct {
	Fip_dst  Tin_addr
	Fip_opts [40]int8
}

type Tip_mreq = struct {
	Fimr_multiaddr Tin_addr
	Fimr_interface Tin_addr
}

type Tip_mreqn = struct {
	Fimr_multiaddr Tin_addr
	Fimr_address   Tin_addr
	Fimr_ifindex   int32
}

type Tin_pktinfo = struct {
	Fipi_ifindex  int32
	Fipi_spec_dst Tin_addr
	Fipi_addr     Tin_addr
}

func x___dns_doqueries(tls *TLS, dest uintptr, name uintptr, rr uintptr, rrcnt int32) (r1 int32) {
	bp := tls.Alloc(912) /* tlsAllocs 896 maxVaListSize 8 */
	defer tls.Free(912)
	var __b, f, r, s, z, v4 uintptr
	var __i, errcode, failed, family, fd, got, i, id, j, nns, ql, rlen, v2, v5 int32
	var sl uint32
	var t0 int64
	var v1 uint8
	var v3 uint64
	var v6 bool
	var _ /* _buf at bp+232 */ [64]uint8
	var _ /* _f at bp+8 */ TFILE
	var _ /* fds at bp+768 */ Tfd_set
	var _ /* line at bp+296 */ [64]int8
	var _ /* ns at bp+388 */ [3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	var _ /* q at bp+472 */ [280]uint8
	var _ /* sa at bp+360 */ struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	var _ /* tv at bp+752 */ Ttimeval
	t0 = x_time(tls, uintptr(0))
	*(*uint16)(unsafe.Pointer(bp + 360)) = uint16(0)
	*(*[3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp + 388)) = [3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}{}
	*(*[280]uint8)(unsafe.Pointer(bp + 472)) = [280]uint8{}
	r = dest
	_ = rlen
	got = 0
	failed = 0
	errcode = -int32(3)
	/* Construct query template - RR and ID will be filled later */
	if x_strlen(tls, name)-uint64(1) >= uint64(254) {
		return -int32(1)
	}
	v1 = Uint8FromInt32(1)
	(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[int32(5)] = v1
	(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[int32(2)] = v1
	x_strcpy(tls, bp+472+uintptr(13), name)
	for i = int32(13); (*(*[280]uint8)(unsafe.Pointer(bp + 472)))[i] != 0; i = j + int32(1) {
		for j = i; (*(*[280]uint8)(unsafe.Pointer(bp + 472)))[j] != 0 && int32((*(*[280]uint8)(unsafe.Pointer(bp + 472)))[j]) != int32('.'); j++ {
		}
		if uint32(j-i)-uint32(1) > uint32(62) {
			return -int32(1)
		}
		(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[i-int32(1)] = uint8(j - i)
	}
	(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[i+int32(3)] = uint8(1)
	ql = i + int32(4)
	/* Make a reasonably unpredictable id */
	x_gettimeofday(tls, bp+752, uintptr(0))
	id = ((*(*Ttimeval)(unsafe.Pointer(bp + 752))).Ftv_usec + (*(*Ttimeval)(unsafe.Pointer(bp + 752))).Ftv_usec/int32(256)) & int32(0xffff)
	/* Get nameservers from resolv.conf, fallback to localhost */
	f = x___fopen_rb_ca(tls, ts+277, bp+8, bp+232, uint64(64))
	if f != 0 {
		for nns = 0; nns < int32(3) && x_fgets(tls, bp+296, int32(64), f) != 0; {
			if x_strncmp(tls, bp+296, ts+294, uint64(10)) != 0 || !(x_isspace(tls, int32((*(*[64]int8)(unsafe.Pointer(bp + 296)))[int32(10)])) != 0) {
				continue
			}
			for s = bp + 296 + uintptr(11); x_isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0; s++ {
			}
			for z = s; *(*int8)(unsafe.Pointer(z)) != 0 && !(x_isspace(tls, int32(*(*int8)(unsafe.Pointer(z)))) != 0); z++ {
			}
			*(*int8)(unsafe.Pointer(z)) = 0
			if x___ipparse(tls, bp+388+uintptr(nns)*28, family, s) < 0 {
				continue
			}
			(*(*[3]struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp + 388)))[nns].Fsin.Fsin_port = x_htons(tls, uint16(53))
			v2 = nns
			nns++
			family = int32((*(*[3]struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp + 388)))[v2].Fsin.Fsin_family)
			if family == int32(m_PF_INET6) {
				v3 = uint64(28)
			} else {
				v3 = uint64(16)
			}
			sl = uint32(v3)
		}
	}
	if f != 0 {
		x___fclose_ca(tls, f)
	}
	if !(nns != 0) {
		(*(*[3]struct {
			Fsin6        [0]Tsockaddr_in6
			Fsin         Tsockaddr_in
			F__ccgo_pad2 [12]byte
		})(unsafe.Pointer(bp + 388)))[0].Fsin.Fsin_family = uint16(m_PF_INET)
		(*(*[3]struct {
			Fsin6        [0]Tsockaddr_in6
			Fsin         Tsockaddr_in
			F__ccgo_pad2 [12]byte
		})(unsafe.Pointer(bp + 388)))[0].Fsin.Fsin_port = x_htons(tls, uint16(53))
		nns = int32(1)
		sl = uint32(16)
	}
	/* Get local address and open/bind a socket */
	(*(*struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp + 360))).Fsin.Fsin_family = uint16(family)
	fd = x_socket(tls, family, int32(m_SOCK_DGRAM), 0)
	if x_bind(tls, fd, bp+360, sl) < 0 {
		x_close(tls, fd)
		return -int32(1)
	}
	/* Nonblocking to work around Linux UDP select bug */
	x_fcntl(tls, fd, int32(m_F_SETFL), VaList(bp+904, x_fcntl(tls, fd, int32(m_F_GETFL), VaList(bp+904, 0))|int32(m_O_NONBLOCK)))
	/* Loop until we timeout; break early on success */
	for x_time(tls, uintptr(0))-t0 < int64(m_TIMEOUT) {
		/* Query all configured namservers in parallel */
		for i = 0; i < rrcnt; i++ {
			if *(*int32)(unsafe.Pointer(rr + uintptr(i)*4)) != 0 {
				for j = 0; j < nns; j++ {
					(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[0] = uint8((id + i) >> int32(8))
					(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[int32(1)] = uint8(id + i)
					(*(*[280]uint8)(unsafe.Pointer(bp + 472)))[ql-int32(3)] = uint8(*(*int32)(unsafe.Pointer(rr + uintptr(i)*4)))
					x_sendto(tls, fd, bp+472, uint64(ql), int32(m_MSG_NOSIGNAL), bp+388+uintptr(j)*28, sl)
				}
			}
		}
		/* Wait for a response, or until time to retry */
		__b = bp + 768
		for __i = int32(Uint64FromInt64(128) / Uint64FromInt64(8)); __i != 0; __i-- {
			v4 = __b
			__b += 8
			*(*uint64)(unsafe.Pointer(v4)) = uint64(0)
		}
		*(*uint64)(unsafe.Pointer(bp + 768 + uintptr(uint64(fd)/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= uint64(Int32FromInt32(1) << (uint64(fd) % (Uint64FromInt32(8) * Uint64FromInt64(8))))
		(*(*Ttimeval)(unsafe.Pointer(bp + 752))).Ftv_sec = int64(m_RETRY)
		(*(*Ttimeval)(unsafe.Pointer(bp + 752))).Ftv_usec = 0
		if x_select(tls, fd+int32(1), bp+768, uintptr(0), uintptr(0), bp+752) <= 0 {
			continue
		}
		/* Process any and all replies */
		for {
			if v6 = got+failed < rrcnt; v6 {
				*(*[1]uint32)(unsafe.Pointer(bp)) = [1]uint32{
					0: sl}
				v5 = int32(x_recvfrom(tls, fd, r, uint64(512), 0, bp+360, bp))
				rlen = v5
			}
			if !(v6 && v5 >= int32(2)) {
				break
			}
			/* Ignore replies from addresses we didn't send to */
			for i = 0; i < nns; i++ {
				if !(x_memcmp(tls, bp+388+uintptr(i)*28, bp+360, uint64(sl)) != 0) {
					break
				}
			}
			if i == nns {
				continue
			}
			/* Compute index of the query from id */
			i = (int32(*(*uint8)(unsafe.Pointer(r)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + 1))) - id) & int32(0xffff)
			if uint32(i) >= uint32(rrcnt) || !(*(*int32)(unsafe.Pointer(rr + uintptr(i)*4)) != 0) {
				continue
			}
			/* Interpret the result code */
			switch int32(*(*uint8)(unsafe.Pointer(r + 3))) & int32(15) {
			case 0:
				goto _7
			default:
				goto _8
			case int32(3):
				goto _9
			}
			goto _10
		_7:
			got++
			goto _10
		_9:
			if !(int32(1) != 0) {
				goto _11
			}
			errcode = -int32(2)
			goto _12
		_11:
		_8:
			errcode = -int32(4)
		_12:
			failed++
		_10:
			/* Mark this record as answered */
			*(*int32)(unsafe.Pointer(rr + uintptr(i)*4)) = 0
			r += uintptr(512)
		}
		/* Check to see if we have answers to all queries */
		if got+failed == rrcnt {
			break
		}
	}
	x_close(tls, fd)
	/* Return the number of results, or an error code if none */
	if got != 0 {
		return got
	}
	return errcode
}

func _mkptr4(tls *TLS, s uintptr, ip uintptr) {
	bp := tls.Alloc(40) /* tlsAllocs 0 maxVaListSize 32 */
	defer tls.Free(40)
	x_sprintf(tls, s, ts+305, VaList(bp+8, int32(*(*uint8)(unsafe.Pointer(ip + 3))), int32(*(*uint8)(unsafe.Pointer(ip + 2))), int32(*(*uint8)(unsafe.Pointer(ip + 1))), int32(*(*uint8)(unsafe.Pointer(ip)))))
}

func _mkptr6(tls *TLS, s uintptr, ip uintptr) {
	var i int32
	var v1, v2, v3, v4 uintptr
	for i = int32(15); i >= 0; i-- {
		v1 = s
		s++
		*(*int8)(unsafe.Pointer(v1)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))&int32(15)]
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v2)) = int8('.')
		v3 = s
		s++
		*(*int8)(unsafe.Pointer(v3)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))>>int32(4)]
		v4 = s
		s++
		*(*int8)(unsafe.Pointer(v4)) = int8('.')
	}
	x_strcpy(tls, s, ts+330)
}

var _xdigits = [17]int8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}

func x___dns_query(tls *TLS, r uintptr, a uintptr, family int32, ptr int32) (r1 int32) {
	bp := tls.Alloc(88) /* tlsAllocs 88 maxVaListSize 0 */
	defer tls.Free(88)
	var rrcnt, v1 int32
	var _ /* buf at bp+0 */ [78]int8
	var _ /* rr at bp+80 */ [2]int32
	rrcnt = int32(1)
	if ptr != 0 {
		if family == int32(m_PF_INET6) {
			_mkptr6(tls, bp, a)
		} else {
			_mkptr4(tls, bp, a)
		}
		(*(*[2]int32)(unsafe.Pointer(bp + 80)))[0] = int32(m_RR_PTR)
		a = bp
	} else {
		if family == int32(m_PF_INET6) {
			(*(*[2]int32)(unsafe.Pointer(bp + 80)))[0] = int32(m_RR_AAAA)
		} else {
			(*(*[2]int32)(unsafe.Pointer(bp + 80)))[0] = int32(m_RR_A)
			if family != int32(m_PF_INET) {
				v1 = rrcnt
				rrcnt++
				(*(*[2]int32)(unsafe.Pointer(bp + 80)))[v1] = int32(m_RR_AAAA)
			}
		}
	}
	return x___dns_doqueries(tls, r, a, bp+80, rrcnt)
}

func _decname(tls *TLS, s uintptr, b uintptr, p uintptr) (r int32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var j, v1 int32
	var pz, sz uintptr
	var _ /* seen at bp+0 */ [8]uint64
	/* Remember jump destinations to detect loops and abort */
	*(*[8]uint64)(unsafe.Pointer(bp)) = [8]uint64{}
	sz = s + uintptr(m_HOST_NAME_MAX)
	pz = b + uintptr(512)
	for {
		if p >= pz {
			return -int32(1)
		} else {
			if int32(*(*uint8)(unsafe.Pointer(p)))&int32(0xc0) != 0 {
				j = int32(*(*uint8)(unsafe.Pointer(p)))&int32(1) | int32(*(*uint8)(unsafe.Pointer(p + 1)))
				if (*(*[8]uint64)(unsafe.Pointer(bp)))[uint64(j)/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(j)%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
					return -int32(1)
				}
				*(*uint64)(unsafe.Pointer(bp + uintptr(uint64(j)/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= Uint64FromInt32(1) << (uint64(j) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
				p = b + uintptr(j)
			} else {
				if *(*uint8)(unsafe.Pointer(p)) != 0 {
					if p+uintptr(*(*uint8)(unsafe.Pointer(p)))+uintptr(1) >= pz || s+uintptr(*(*uint8)(unsafe.Pointer(p))) >= sz {
						return -int32(1)
					}
					x_memcpy(tls, s, p+uintptr(1), uint64(*(*uint8)(unsafe.Pointer(p))))
					s += uintptr(int32(*(*uint8)(unsafe.Pointer(p))) + int32(1))
					p += uintptr(int32(*(*uint8)(unsafe.Pointer(p))) + int32(1))
					if *(*uint8)(unsafe.Pointer(p)) != 0 {
						v1 = int32('.')
					} else {
						v1 = 0
					}
					*(*int8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1)))) = int8(v1)
				} else {
					return 0
				}
			}
		}
	}
	return r
}

func x___dns_get_rr(tls *TLS, dest uintptr, stride uint64, maxlen uint64, limit uint64, r uintptr, rr int32, dec int32) (r1 int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxVaListSize 0 */
	defer tls.Free(256)
	var ancount, found, len1, qdcount, v1, v2 int32
	var p uintptr
	var _ /* tmp at bp+0 */ [256]int8
	found = 0
	if int32(*(*uint8)(unsafe.Pointer(r + 3)))&int32(15) != 0 {
		return 0
	}
	p = r + uintptr(12)
	qdcount = int32(*(*uint8)(unsafe.Pointer(r + 4)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + 5)))
	ancount = int32(*(*uint8)(unsafe.Pointer(r + 6)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + 7)))
	if qdcount+ancount > int32(64) {
		return -int32(1)
	}
	for {
		v1 = qdcount
		qdcount--
		if !(v1 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(512) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) > int32(193) || int32(*(*uint8)(unsafe.Pointer(p))) == int32(193) && int32(*(*uint8)(unsafe.Pointer(p + 1))) > int32(254) || p > r+uintptr(506) {
			return -int32(1)
		}
		p += uintptr(int32(5) + BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
	}
	for {
		v2 = ancount
		ancount--
		if !(v2 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(512) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) > int32(193) || int32(*(*uint8)(unsafe.Pointer(p))) == int32(193) && int32(*(*uint8)(unsafe.Pointer(p + 1))) > int32(254) || p > r+uintptr(506) {
			return -int32(1)
		}
		p += uintptr(int32(1) + BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
		len1 = int32(*(*uint8)(unsafe.Pointer(p + 8)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(p + 9)))
		if p+uintptr(len1) > r+uintptr(512) {
			return -int32(1)
		}
		if int32(*(*uint8)(unsafe.Pointer(p + 1))) == rr && uint64(len1) <= maxlen {
			if dec != 0 && _decname(tls, bp, r, p+uintptr(10)) < 0 {
				return -int32(1)
			}
			if dest != 0 && limit != 0 {
				if dec != 0 {
					x_strcpy(tls, dest, bp)
				} else {
					x_memcpy(tls, dest, p+uintptr(10), uint64(len1))
				}
				dest = dest + uintptr(stride)
				limit--
			}
			found++
		}
		p += uintptr(int32(10) + len1)
	}
	return found
}

func x___dns_count_addrs(tls *TLS, r uintptr, cnt int32) (r1 int32) {
	var found, i, res, v1 int32
	found = 0
	for {
		v1 = cnt
		cnt--
		if !(v1 != 0) {
			break
		}
		for i = 0; i < int32(2); i++ {
			res = x___dns_get_rr(tls, uintptr(0), uint64(0), uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_p)) + uintptr(i)*8))), uint64(-Int32FromInt32(1)), r, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_p)) + uintptr(i)*8 + 1*4)), 0)
			if res < 0 {
				return res
			}
			found += res
			r += uintptr(512)
		}
	}
	return found
}

var _p = [2][2]int32{
	0: {
		0: int32(4),
		1: int32(m_RR_A)},
	1: {
		0: int32(16),
		1: int32(m_RR_AAAA)}}

func x___ipparse(tls *TLS, dest uintptr, family int32, s uintptr) (r int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxVaListSize 0 */
	defer tls.Free(136)
	var d uintptr
	var i int32
	var _ /* a at bp+0 */ [16]uint64
	var _ /* z at bp+128 */ uintptr
	d = dest
	*(*[16]uint64)(unsafe.Pointer(bp)) = [16]uint64{}
	if family == int32(m_PF_INET6) {
		goto not_v4
	}
	for i = 0; i < int32(4) && *(*int8)(unsafe.Pointer(s)) != 0; i++ {
		(*(*[16]uint64)(unsafe.Pointer(bp)))[i] = x_strtoul(tls, s, bp+128, 0)
		if *(*uintptr)(unsafe.Pointer(bp + 128)) == s || *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))) != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128))))) != int32('.') {
			goto not_v4
		}
		s = *(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(1)
	}
	switch i {
	case 0:
		(*(*[16]uint64)(unsafe.Pointer(bp)))[int32(1)] = (*(*[16]uint64)(unsafe.Pointer(bp)))[0] & uint64(0xffffff)
		*(*uint64)(unsafe.Pointer(bp)) >>= uint64(24)
		fallthrough
	case int32(1):
		(*(*[16]uint64)(unsafe.Pointer(bp)))[int32(2)] = (*(*[16]uint64)(unsafe.Pointer(bp)))[int32(1)] & uint64(0xffff)
		*(*uint64)(unsafe.Pointer(bp + 1*8)) >>= uint64(16)
		fallthrough
	case int32(2):
		(*(*[16]uint64)(unsafe.Pointer(bp)))[int32(3)] = (*(*[16]uint64)(unsafe.Pointer(bp)))[int32(2)] & uint64(0xff)
		*(*uint64)(unsafe.Pointer(bp + 2*8)) >>= uint64(8)
	}
	(*Tsockaddr_in)(unsafe.Pointer(d)).Fsin_family = uint16(m_PF_INET)
	d = d + 4
	for i = 0; i < int32(4); i++ {
		*(*uint8)(unsafe.Pointer(d + uintptr(i))) = uint8((*(*[16]uint64)(unsafe.Pointer(bp)))[i])
	}
	return 0
not_v4:
	return -int32(1)
	return r
}

const m___NR_accept = 43

func x_accept(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	var ret int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	ret = int32(_syscall6(tls, int64(m___NR_accept), int64(fd), int64(addr), int64(len1), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return ret
}

const m___NR_bind = 49

func x_bind(tls *TLS, fd int32, addr uintptr, len1 uint32) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_bind), int64(fd), int64(addr), int64(len1), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

const m___NR_connect = 42

func x_connect(tls *TLS, fd int32, addr uintptr, len1 uint32) (r int32) {
	var ret int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	ret = int32(_syscall6(tls, int64(m___NR_connect), int64(fd), int64(addr), int64(len1), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return ret
}

const m_MAXDNSRCH = 6
const m_MAXNS = 3
const m_MAXRESOLVSORT = 10
const m_NS_MAXDNAME = 1025
const m_NS_PACKETSZ = 512

type Tns_sect = int32

type ___ns_sect = int32

const _ns_s_qd = 0
const _ns_s_zn = 0
const _ns_s_an = 1
const _ns_s_pr = 1
const _ns_s_ns = 2
const _ns_s_ud = 2
const _ns_s_ar = 3
const _ns_s_max = 4

type Tns_msg = struct {
	F_msg      uintptr
	F_eom      uintptr
	F_id       uint16
	F_flags    uint16
	F_counts   [4]uint16
	F_sections [4]uintptr
	F_sect     ___ns_sect
	F_rrnum    int32
	F_msg_ptr  uintptr
}

type T__ns_msg = Tns_msg

type T_ns_flagdata = struct {
	Fmask  int32
	Fshift int32
}

type Tns_rr = struct {
	Fname     [1025]int8
	Ftype1    uint16
	Frr_class uint16
	Fttl      uint32
	Frdlength uint16
	Frdata    uintptr
}

type T__ns_rr = Tns_rr

type Tns_flag = int32

type ___ns_flag = int32

const _ns_f_qr = 0
const _ns_f_opcode = 1
const _ns_f_aa = 2
const _ns_f_tc = 3
const _ns_f_rd = 4
const _ns_f_ra = 5
const _ns_f_z = 6
const _ns_f_ad = 7
const _ns_f_cd = 8
const _ns_f_rcode = 9
const _ns_f_max = 10

type Tns_opcode = int32

type ___ns_opcode = int32

const _ns_o_query = 0
const _ns_o_iquery = 1
const _ns_o_status = 2
const _ns_o_notify = 4
const _ns_o_update = 5
const _ns_o_max = 6

type Tns_rcode = int32

type ___ns_rcode = int32

const _ns_r_noerror = 0
const _ns_r_formerr = 1
const _ns_r_servfail = 2
const _ns_r_nxdomain = 3
const _ns_r_notimpl = 4
const _ns_r_refused = 5
const _ns_r_yxdomain = 6
const _ns_r_yxrrset = 7
const _ns_r_nxrrset = 8
const _ns_r_notauth = 9
const _ns_r_notzone = 10
const _ns_r_max = 11
const _ns_r_badvers = 16
const _ns_r_badsig = 16
const _ns_r_badkey = 17
const _ns_r_badtime = 18

type Tns_update_operation = int32

type ___ns_update_operation = int32

const _ns_uop_delete = 0
const _ns_uop_add = 1
const _ns_uop_max = 2

type Tns_tsig_key1 = struct {
	Fname        [1025]int8
	Falg         [1025]int8
	Fdata        uintptr
	Flen1        int32
	F__ccgo_pad4 [4]byte
}

type Tns_tsig_key = struct {
	Fname        [1025]int8
	Falg         [1025]int8
	Fdata        uintptr
	Flen1        int32
	F__ccgo_pad4 [4]byte
}

type Tns_tcp_tsig_state1 = struct {
	Fcounter     int32
	Fkey         uintptr
	Fctx         uintptr
	Fsig         [512]uint8
	Fsiglen      int32
	F__ccgo_pad5 [4]byte
}

type Tns_tcp_tsig_state = struct {
	Fcounter     int32
	Fkey         uintptr
	Fctx         uintptr
	Fsig         [512]uint8
	Fsiglen      int32
	F__ccgo_pad5 [4]byte
}

type Tns_type = int32

type ___ns_type = int32

const _ns_t_invalid = 0
const _ns_t_a = 1
const _ns_t_ns = 2
const _ns_t_md = 3
const _ns_t_mf = 4
const _ns_t_cname = 5
const _ns_t_soa = 6
const _ns_t_mb = 7
const _ns_t_mg = 8
const _ns_t_mr = 9
const _ns_t_null = 10
const _ns_t_wks = 11
const _ns_t_ptr = 12
const _ns_t_hinfo = 13
const _ns_t_minfo = 14
const _ns_t_mx = 15
const _ns_t_txt = 16
const _ns_t_rp = 17
const _ns_t_afsdb = 18
const _ns_t_x25 = 19
const _ns_t_isdn = 20
const _ns_t_rt = 21
const _ns_t_nsap = 22
const _ns_t_nsap_ptr = 23
const _ns_t_sig = 24
const _ns_t_key = 25
const _ns_t_px = 26
const _ns_t_gpos = 27
const _ns_t_aaaa = 28
const _ns_t_loc = 29
const _ns_t_nxt = 30
const _ns_t_eid = 31
const _ns_t_nimloc = 32
const _ns_t_srv = 33
const _ns_t_atma = 34
const _ns_t_naptr = 35
const _ns_t_kx = 36
const _ns_t_cert = 37
const _ns_t_a6 = 38
const _ns_t_dname = 39
const _ns_t_sink = 40
const _ns_t_opt = 41
const _ns_t_apl = 42
const _ns_t_tkey = 249
const _ns_t_tsig = 250
const _ns_t_ixfr = 251
const _ns_t_axfr = 252
const _ns_t_mailb = 253
const _ns_t_maila = 254
const _ns_t_any = 255
const _ns_t_zxfr = 256
const _ns_t_max = 65536

type Tns_class = int32

type ___ns_class = int32

const _ns_c_invalid = 0
const _ns_c_in = 1
const _ns_c_2 = 2
const _ns_c_chaos = 3
const _ns_c_hs = 4
const _ns_c_none = 254
const _ns_c_any = 255
const _ns_c_max = 65536

type Tns_key_types = int32

type ___ns_key_types = int32

const _ns_kt_rsa = 1
const _ns_kt_dh = 2
const _ns_kt_dsa = 3
const _ns_kt_private = 254

type Tns_cert_types = int32

type ___ns_cert_types = int32

const _cert_t_pkix = 1
const _cert_t_spki = 2
const _cert_t_pgp = 3
const _cert_t_url = 253
const _cert_t_oid = 254

type THEADER = struct {
	F__ccgo0 uint32
	F__ccgo4 uint32
	F__ccgo8 uint32
}

type Tres_state = uintptr

type T__res_state = struct {
	Fretrans     int32
	Fretry       int32
	Foptions     uint64
	Fnscount     int32
	Fnsaddr_list [3]Tsockaddr_in
	Fid          uint16
	Fdnsrch      [7]uintptr
	Fdefdname    [256]int8
	Fpfcode      uint64
	F__ccgo392   uint32
	Fsort_list   [10]struct {
		Faddr Tin_addr
		Fmask uint32
	}
	Fqhook       uintptr
	Frhook       uintptr
	Fres_h_errno int32
	F_vcsock     int32
	F_flags      uint32
	F_u          struct {
		F_ext [0]struct {
			Fnscount    uint16
			Fnsmap      [3]uint16
			Fnssocks    [3]int32
			Fnscount6   uint16
			Fnsinit     uint16
			Fnsaddrs    [3]uintptr
			F_initstamp [2]uint32
		}
		Fpad         [52]int8
		F__ccgo_pad2 [4]byte
	}
}

type Tres_sym = struct {
	Fnumber    int32
	Fname      uintptr
	Fhumanname uintptr
}

func x_dn_expand(tls *TLS, b uintptr, pz uintptr, p uintptr, s uintptr, outlen int32) (r int32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var j, v1 int32
	var sz uintptr
	var _ /* seen at bp+0 */ [8]uint64
	/* Remember jump destinations to detect loops and abort */
	*(*[8]uint64)(unsafe.Pointer(bp)) = [8]uint64{}
	sz = s + uintptr(outlen)
	if int64(pz)-int64(b) > int64(512) {
		return -int32(1)
	}
	for {
		if p >= pz {
			return -int32(1)
		} else {
			if int32(*(*uint8)(unsafe.Pointer(p)))&int32(0xc0) != 0 {
				j = int32(*(*uint8)(unsafe.Pointer(p)))&int32(1) | int32(*(*uint8)(unsafe.Pointer(p + 1)))
				if (*(*[8]uint64)(unsafe.Pointer(bp)))[uint64(j)/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(j)%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
					return -int32(1)
				}
				*(*uint64)(unsafe.Pointer(bp + uintptr(uint64(j)/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= Uint64FromInt32(1) << (uint64(j) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
				p = b + uintptr(j)
			} else {
				if *(*uint8)(unsafe.Pointer(p)) != 0 {
					if p+uintptr(*(*uint8)(unsafe.Pointer(p)))+uintptr(1) >= pz || s+uintptr(*(*uint8)(unsafe.Pointer(p))) >= sz {
						return -int32(1)
					}
					x_memcpy(tls, s, p+uintptr(1), uint64(*(*uint8)(unsafe.Pointer(p))))
					s += uintptr(int32(*(*uint8)(unsafe.Pointer(p))) + int32(1))
					p += uintptr(int32(*(*uint8)(unsafe.Pointer(p))) + int32(1))
					if *(*uint8)(unsafe.Pointer(p)) != 0 {
						v1 = int32('.')
					} else {
						v1 = 0
					}
					*(*uint8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1)))) = uint8(v1)
				} else {
					return 0
				}
			}
		}
	}
	return r
}

func x_sethostent(tls *TLS, x int32) {
}

func x_gethostent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

func x_endhostent(tls *TLS) {
}

func x_freeaddrinfo(tls *TLS, p uintptr) {
	x_free(tls, p)
}

var _msgs = [211]int8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'f', 'l', 'a', 'g', 's', 0, 'N', 'a', 'm', 'e', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r', 'e', 's', 'o', 'l', 'v', 'e', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'o', 'r', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'e', 'n', 'g', 't', 'h', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'S', 'y', 's', 't', 'e', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func x_gai_strerror(tls *TLS, ecode int32) (r uintptr) {
	var s, v2 uintptr
	s = uintptr(unsafe.Pointer(&_msgs))
	ecode++
	for ecode != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
		goto _1
	_1:
		ecode++
		s++
	}
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		v2 = s
	} else {
		v2 = s + uintptr(1)
	}
	return v2
}

const m_AI_NUMERICHOST = 4
const m_AI_NUMERICSERV = 1024
const m_AI_PASSIVE = 1
const m_IPPROTO_TCP = 6
const m_IPPROTO_UDP = 17
const m_PF_UNSPEC = 0
const m_RR_CNAME = 5

func _is_valid(tls *TLS, host uintptr) (r int32) {
	var s uintptr
	if x_strlen(tls, host)-uint64(1) > uint64(254) || x_mbstowcs(tls, uintptr(0), host, uint64(0)) > uint64(255) {
		return 0
	}
	for s = host; int32(*(*uint8)(unsafe.Pointer(s))) >= int32(0x80) || int32(*(*uint8)(unsafe.Pointer(s))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') || x_isalnum(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0; s++ {
	}
	return BoolInt32(!(*(*uint8)(unsafe.Pointer(s)) != 0))
}

type Tsa = struct {
	Fsin6        [0]Tsockaddr_in6
	Fsin         Tsockaddr_in
	F__ccgo_pad2 [12]byte
}

type Taibuf = struct {
	Fai          Taddrinfo
	Fsa          Tsa
	F__ccgo_pad2 [4]byte
}

func x_getaddrinfo(tls *TLS, host uintptr, serv uintptr, hint uintptr, res uintptr) (r int32) {
	bp := tls.Alloc(1880) /* tlsAllocs 1864 maxVaListSize 8 */
	defer tls.Free(1880)
	var buf, f, p, v10, v11, v12, v9 uintptr
	var cnt, family, flags, i, j, proto, result, type1, v1, v14, v15, v16, v17, v18, v19, v2, v20, v21, v3, v4, v5, v6 int32
	var l, port, v13, v22, v7, v8 uint64
	var _ /* _buf at bp+1792 */ [64]uint8
	var _ /* _f at bp+1568 */ TFILE
	var _ /* line at bp+1052 */ [512]int8
	var _ /* reply at bp+28 */ [1024]uint8
	var _ /* sa at bp+0 */ Tsa
	var _ /* z at bp+1856 */ uintptr
	if hint != 0 {
		v1 = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_flags
	} else {
		v1 = 0
	}
	flags = v1
	if hint != 0 {
		v2 = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_family
	} else {
		v2 = m_PF_UNSPEC
	}
	family = v2
	if hint != 0 {
		v3 = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_socktype
	} else {
		v3 = 0
	}
	type1 = v3
	if hint != 0 {
		v4 = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_protocol
	} else {
		v4 = 0
	}
	proto = v4
	port = uint64(0)
	*(*Tsa)(unsafe.Pointer(bp)) = Tsa{}
	//char hostbuf[256];
	if host != 0 && x_strlen(tls, host) > uint64(255) {
		return -int32(2)
	}
	if serv != 0 && x_strlen(tls, serv) > uint64(32) {
		return -int32(8)
	}
	if type1 != 0 && !(proto != 0) {
		if type1 == int32(m_SOCK_DGRAM) {
			v5 = int32(m_IPPROTO_UDP)
		} else {
			v5 = int32(m_IPPROTO_TCP)
		}
		proto = v5
	}
	if !(type1 != 0) && proto != 0 {
		if proto == int32(m_IPPROTO_UDP) {
			v6 = int32(m_SOCK_DGRAM)
		} else {
			v6 = int32(m_SOCK_STREAM)
		}
		type1 = v6
	}
	if serv != 0 {
		port = x_strtoul(tls, serv, bp+1856, 0)
		if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1856)))) != 0) && port > uint64(65535) {
			return -int32(8)
		}
		if !(port != 0) {
			if flags&int32(m_AI_NUMERICSERV) != 0 {
				return -int32(8)
			}
			//f = fopen("/etc/services", "rb");
			return -int32(8)
		}
		port = uint64(x_htons(tls, uint16(port)))
	}
	if !(host != 0) {
		if family == m_PF_UNSPEC {
			family = int32(m_PF_INET)
		}
		buf = x_calloc(tls, uint64(80), Uint64FromInt32(1)+(Uint64FromInt32(256)+Uint64FromInt64(80)-Uint64FromInt32(1))/Uint64FromInt64(80))
		if !(buf != 0) {
			return -int32(10)
		}
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_protocol = proto
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_socktype = type1
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addr = buf + 48
		if family == int32(m_PF_INET6) {
			v7 = uint64(28)
		} else {
			v7 = uint64(16)
		}
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addrlen = uint32(v7)
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_family = family
		(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_family = uint16(family)
		(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_port = uint16(port)
		if !(flags&Int32FromInt32(m_AI_PASSIVE) != 0) {
			if family == int32(m_PF_INET) {
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_addr.Fs_addr)))) = uint8(127)
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_addr.Fs_addr)) + 3)) = uint8(1)
			} else {
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					F__s6_addr32 [0][4]uint32
					F__s6_addr   [16]uint8
				})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf))).Fsa)) + 8))).F__s6_addr)) + 15)) = uint8(1)
			}
		}
		*(*uintptr)(unsafe.Pointer(res)) = buf
		return 0
	}
	/* Try as a numeric address */
	if x___ipparse(tls, bp, family, host) >= 0 {
		buf = x_calloc(tls, uint64(80), Uint64FromInt32(1)+(Uint64FromInt32(256)+Uint64FromInt64(80)-Uint64FromInt32(1))/Uint64FromInt64(80))
		if !(buf != 0) {
			return -int32(10)
		}
		family = int32((*(*Tsa)(unsafe.Pointer(bp))).Fsin.Fsin_family)
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_protocol = proto
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_socktype = type1
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addr = buf + 48
		if family == int32(m_PF_INET6) {
			v8 = uint64(28)
		} else {
			v8 = uint64(16)
		}
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addrlen = uint32(v8)
		(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_family = family
		(*Taibuf)(unsafe.Pointer(buf)).Fsa = *(*Tsa)(unsafe.Pointer(bp))
		(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_port = uint16(port)
		*(*uintptr)(unsafe.Pointer(res)) = buf
		return 0
	}
	if flags&int32(m_AI_NUMERICHOST) != 0 {
		return -int32(2)
	}
	f = x___fopen_rb_ca(tls, ts+339, bp+1568, bp+1792, uint64(64))
	if f != 0 {
		for x_fgets(tls, bp+1052, int32(512), f) != 0 {
			l = x_strlen(tls, host)
			v9 = x_strchr(tls, bp+1052, int32('#'))
			p = v9
			if v9 != 0 {
				v10 = p
				p++
				*(*int8)(unsafe.Pointer(v10)) = int8('\n')
				*(*int8)(unsafe.Pointer(p)) = Int8FromInt32(0)
			}
			for p = bp + 1052 + uintptr(1); ; p++ {
				v11 = x_strstr(tls, p, host)
				p = v11
				if !(v11 != 0 && (!(x_isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))) != 0) || !(x_isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(l))))) != 0))) {
					break
				}
			}
			if !(p != 0) {
				continue
			}
			x___fclose_ca(tls, f)
			/* Isolate IP address to parse */
			for p = bp + 1052; *(*int8)(unsafe.Pointer(p)) != 0 && !(x_isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
			}
			v12 = p
			p++
			*(*int8)(unsafe.Pointer(v12)) = 0
			if x___ipparse(tls, bp, family, bp+1052) < 0 {
				return -int32(2)
			}
			/* Allocate and fill result buffer */
			buf = x_calloc(tls, uint64(80), Uint64FromInt32(1)+(Uint64FromInt32(256)+Uint64FromInt64(80)-Uint64FromInt32(1))/Uint64FromInt64(80))
			if !(buf != 0) {
				return -int32(10)
			}
			family = int32((*(*Tsa)(unsafe.Pointer(bp))).Fsin.Fsin_family)
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_protocol = proto
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_socktype = type1
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addr = buf + 48
			if family == int32(m_PF_INET6) {
				v13 = uint64(28)
			} else {
				v13 = uint64(16)
			}
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_addrlen = uint32(v13)
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_family = family
			(*Taibuf)(unsafe.Pointer(buf)).Fsa = *(*Tsa)(unsafe.Pointer(bp))
			(*Taibuf)(unsafe.Pointer(buf)).Fsa.Fsin.Fsin_port = uint16(port)
			/* Extract first name as canonical name */
			for ; *(*int8)(unsafe.Pointer(p)) != 0 && x_isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
			}
			(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_canonname = buf + UintptrFromInt32(1)*80
			x_snprintf(tls, (*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_canonname, uint64(256), ts+15, VaList(bp+1872, p))
			for p = (*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_canonname; *(*int8)(unsafe.Pointer(p)) != 0 && !(x_isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
			}
			*(*int8)(unsafe.Pointer(p)) = 0
			if !(_is_valid(tls, (*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_canonname) != 0) {
				(*Taibuf)(unsafe.Pointer(buf)).Fai.Fai_canonname = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(res)) = buf
			return 0
		}
	}
	if f != 0 {
		x___fclose_ca(tls, f)
	}
	/* Perform one or more DNS queries for host */
	x_memset(tls, bp+28, 0, uint64(1024))
	result = x___dns_query(tls, bp+28, host, family, 0)
	if result < 0 {
		return result
	}
	cnt = x___dns_count_addrs(tls, bp+28, result)
	if cnt <= 0 {
		return -int32(2)
	}
	buf = x_calloc(tls, uint64(80), uint64(cnt)+(Uint64FromInt32(256)+Uint64FromInt64(80)-Uint64FromInt32(1))/Uint64FromInt64(80))
	if !(buf != 0) {
		return -int32(10)
	}
	i = 0
	if family != int32(m_PF_INET6) {
		j = x___dns_get_rr(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))))).Fsin_addr)), uint64(80), uint64(4), uint64(cnt-i), bp+28, int32(m_RR_A), 0)
		for {
			v14 = j
			j--
			if !(v14 != 0) {
				break
			}
			v15 = i
			i++
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(v15)*80))).Fsa)))) = uint16(m_PF_INET)
		}
	}
	if family != int32(m_PF_INET) {
		j = x___dns_get_rr(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))))).Fsin6_addr)), uint64(80), uint64(16), uint64(cnt-i), bp+28, int32(m_RR_AAAA), 0)
		for {
			v16 = j
			j--
			if !(v16 != 0) {
				break
			}
			v17 = i
			i++
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(v17)*80))).Fsa)))) = uint16(m_PF_INET6)
		}
	}
	if result > int32(1) {
		j = x___dns_get_rr(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))))).Fsin_addr)), uint64(80), uint64(4), uint64(cnt-i), bp+28+uintptr(512), int32(m_RR_A), 0)
		for {
			v18 = j
			j--
			if !(v18 != 0) {
				break
			}
			v19 = i
			i++
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(v19)*80))).Fsa)))) = uint16(m_PF_INET)
		}
		j = x___dns_get_rr(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))))).Fsin6_addr)), uint64(80), uint64(16), uint64(cnt-i), bp+28+uintptr(512), int32(m_RR_AAAA), 0)
		for {
			v20 = j
			j--
			if !(v20 != 0) {
				break
			}
			v21 = i
			i++
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(v21)*80))).Fsa)))) = uint16(m_PF_INET6)
		}
	}
	if x___dns_get_rr(tls, buf+uintptr(cnt)*80, uint64(0), uint64(256), uint64(1), bp+28, int32(m_RR_CNAME), int32(1)) < 0 {
		x_strcpy(tls, buf+uintptr(cnt)*80, host)
	}
	for i = 0; i < cnt; i++ {
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_protocol = proto
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_socktype = type1
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_addr = uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))
		if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa))))) == int32(m_PF_INET6) {
			v22 = uint64(28)
		} else {
			v22 = uint64(16)
		}
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_addrlen = uint32(v22)
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_family = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa)))))
		*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fsa)) + 2)) = uint16(port)
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_next = uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i+int32(1))*80))).Fai))
		(*(*Taibuf)(unsafe.Pointer(buf + uintptr(i)*80))).Fai.Fai_canonname = buf + uintptr(cnt)*80
	}
	(*(*Taibuf)(unsafe.Pointer(buf + uintptr(cnt-int32(1))*80))).Fai.Fai_next = uintptr(0)
	*(*uintptr)(unsafe.Pointer(res)) = buf
	return 0
}

func x_gethostbyaddr(tls *TLS, a uintptr, l uint32, af int32) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_gethostbyaddr_r(tls, a, l, af, uintptr(unsafe.Pointer(&_h)), uintptr(unsafe.Pointer(&_buf2)), uint64(512), bp, uintptr(unsafe.Pointer(&x_h_errno))) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_h))
}

var _h Thostent

var _buf2 [64]int64

const m_ERANGE = 34
const m_NO_RECOVERY = 3
const m_TRY_AGAIN = 2

func x_gethostbyaddr_r(tls *TLS, a uintptr, l uint32, af int32, h uintptr, buf uintptr, buflen uint64, res uintptr, err uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var i int32
	var sl uint32
	var v1 uint64
	var _ /* sa at bp+0 */ struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	*(*uint16)(unsafe.Pointer(bp)) = uint16(af)
	if af == int32(m_PF_INET6) {
		v1 = uint64(28)
	} else {
		v1 = uint64(16)
	}
	sl = uint32(v1)
	/* Load address argument into sockaddr structure */
	if af == int32(m_PF_INET6) && l == uint32(16) {
		x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp))).Fsin6_addr)), a, uint64(16))
	} else {
		if af == int32(m_PF_INET) && l == uint32(4) {
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp))).Fsin.Fsin_addr)), a, uint64(4))
		} else {
			*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
			return -int32(1)
		}
	}
	/* Align buffer and check for space for pointers and ip address */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen <= Uint64FromInt32(5)*Uint64FromInt64(8)-uint64(i)+uint64(l) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return -int32(1)
	}
	buf += uintptr(uint64(8) - uint64(i))
	buflen -= Uint64FromInt32(5)*Uint64FromInt64(8) - uint64(i) + uint64(l)
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf += uintptr(Uint64FromInt32(2) * Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf += uintptr(Uint64FromInt32(2) * Uint64FromInt64(8))
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list)) = buf
	x_memcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list)), a, uint64(l))
	buf += uintptr(l)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + 1*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases)) = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = uintptr(0)
	switch x_getnameinfo(tls, bp, sl, buf, uint32(buflen), uintptr(0), uint32(0), 0) {
	case -int32(3):
		*(*int32)(unsafe.Pointer(err)) = int32(m_TRY_AGAIN)
		return -int32(1)
	case -int32(12):
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		fallthrough
	default:
		fallthrough
	case -int32(10):
		fallthrough
	case -int32(11):
		fallthrough
	case -int32(4):
		*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
		return -int32(1)
	case 0:
		break
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	(*Thostent)(unsafe.Pointer(h)).Fh_name = *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases))
	*(*uintptr)(unsafe.Pointer(res)) = h
	return 0
}

func x_gethostbyname(tls *TLS, name uintptr) (r uintptr) {
	return x_gethostbyname2(tls, name, int32(m_PF_INET))
}

func x_gethostbyname2(tls *TLS, name uintptr, af int32) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_gethostbyname2_r(tls, name, af, uintptr(unsafe.Pointer(&_h1)), uintptr(unsafe.Pointer(&_buf3)), uint64(512), bp, uintptr(unsafe.Pointer(&x_h_errno))) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_h1))
}

var _h1 Thostent

var _buf3 [64]int64

const m_AI_CANONNAME = 2
const m_HOST_NOT_FOUND = 1

func x_gethostbyname2_r(tls *TLS, name uintptr, af int32, h uintptr, buf uintptr, buflen uint64, res uintptr, err uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var canon, p, v3, v5 uintptr
	var i, v1, v2 int32
	var need uint64
	var _ /* ai at bp+48 */ uintptr
	var _ /* hint at bp+0 */ Taddrinfo
	if af == int32(m_PF_INET6) {
		v1 = af
	} else {
		v1 = int32(m_PF_INET)
	}
	*(*Taddrinfo)(unsafe.Pointer(bp)) = Taddrinfo{Fai_flags: int32(m_AI_CANONNAME), Fai_family: v1}
	af = (*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_family
	/* Align buffer */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if i != 0 {
		if buflen < uint64(8)-uint64(i) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
			return -int32(1)
		}
		buf += uintptr(uint64(8) - uint64(i))
		buflen -= uint64(8) - uint64(i)
	}
	x_getaddrinfo(tls, name, uintptr(0), bp, bp+48)
	switch x_getaddrinfo(tls, name, uintptr(0), bp, bp+48) {
	case -int32(2):
		*(*int32)(unsafe.Pointer(err)) = int32(m_HOST_NOT_FOUND)
		return -int32(1)
	case -int32(3):
		*(*int32)(unsafe.Pointer(err)) = int32(m_TRY_AGAIN)
		return -int32(1)
	default:
		fallthrough
	case -int32(10):
		fallthrough
	case -int32(11):
		fallthrough
	case -int32(4):
		*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
		return -int32(1)
	case 0:
		break
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	if af == int32(m_PF_INET6) {
		v2 = int32(16)
	} else {
		v2 = int32(4)
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_length = v2
	if (*Taddrinfo)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).Fai_canonname != 0 {
		v3 = (*Taddrinfo)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).Fai_canonname
	} else {
		v3 = name
	}
	canon = v3
	need = Uint64FromInt32(4) * Uint64FromInt64(8)
	i = 0
	p = *(*uintptr)(unsafe.Pointer(bp + 48))
	for p != 0 {
		need += uint64(8) + uint64((*Thostent)(unsafe.Pointer(h)).Fh_length)
		goto _4
	_4:
		i++
		p = (*Taddrinfo)(unsafe.Pointer(p)).Fai_next
	}
	need += x_strlen(tls, name) + uint64(1)
	need += x_strlen(tls, canon) + uint64(1)
	if need > buflen {
		x_freeaddrinfo(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return -int32(1)
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf += uintptr(Uint64FromInt32(3) * Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf += uintptr(uint64(i+Int32FromInt32(1)) * uint64(8))
	v5 = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases)) = v5
	(*Thostent)(unsafe.Pointer(h)).Fh_name = v5
	x_strcpy(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, canon)
	buf += uintptr(x_strlen(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name) + uint64(1))
	if x_strcmp(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, name) != 0 {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = buf
		x_strcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)), name)
		buf += uintptr(x_strlen(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8))) + uint64(1))
	} else {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 2*8)) = uintptr(0)
	i = 0
	p = *(*uintptr)(unsafe.Pointer(bp + 48))
	for p != 0 {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = buf
		buf += uintptr((*Thostent)(unsafe.Pointer(h)).Fh_length)
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)), (*Taddrinfo)(unsafe.Pointer(p)).Fai_addr+4, uint64((*Thostent)(unsafe.Pointer(h)).Fh_length))
		goto _6
	_6:
		i++
		p = (*Taddrinfo)(unsafe.Pointer(p)).Fai_next
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(res)) = h
	x_freeaddrinfo(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
	return 0
}

func x_gethostbyname_r(tls *TLS, name uintptr, h uintptr, buf uintptr, buflen uint64, res uintptr, err uintptr) (r int32) {
	return x_gethostbyname2_r(tls, name, int32(m_PF_INET), h, buf, buflen, res, err)
}

const m_NI_NAMEREQD = 8
const m_NI_NUMERICHOST = 1

func x_getnameinfo(tls *TLS, sa uintptr, sl uint32, node uintptr, nodelen uint32, serv uintptr, servlen uint32, flags int32) (r int32) {
	bp := tls.Alloc(784) /* tlsAllocs 768 maxVaListSize 8 */
	defer tls.Free(784)
	var a uintptr
	var af int32
	var _ /* buf at bp+0 */ [256]int8
	var _ /* reply at bp+256 */ [512]uint8
	af = int32((*Tsockaddr)(unsafe.Pointer(sa)).Fsa_family)
	switch af {
	case int32(m_PF_INET):
		a = sa + 4
		if uint64(sl) != uint64(16) {
			return -int32(6)
		}
	case int32(m_PF_INET6):
		a = sa + 8
		if uint64(sl) != uint64(28) {
			return -int32(6)
		}
	default:
		return -int32(6)
	}
	if node != 0 && nodelen != 0 {
		if flags&int32(m_NI_NUMERICHOST) != 0 || x___dns_query(tls, bp+256, a, af, int32(1)) <= 0 || x___dns_get_rr(tls, bp, uint64(0), uint64(256), uint64(1), bp+256, int32(m_RR_PTR), int32(1)) <= 0 {
			if flags&int32(m_NI_NAMEREQD) != 0 {
				return -int32(2)
			}
			x_inet_ntop(tls, af, a, bp, uint32(256))
		}
		if x_strlen(tls, bp) >= uint64(nodelen) {
			return -int32(12)
		}
		x_strcpy(tls, node, bp)
	}
	if serv != 0 && servlen != 0 {
		if uint32(x_snprintf(tls, bp, uint64(256), ts+350, VaList(bp+776, int32(x_ntohs(tls, (*Tsockaddr_in)(unsafe.Pointer(sa)).Fsin_port))))) >= servlen {
			return -int32(12)
		}
		x_strcpy(tls, serv, bp)
	}
	return 0
}

const m___NR_getpeername = 52

func x_getpeername(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_getpeername), int64(fd), int64(addr), int64(len1), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

func x_getservbyname(tls *TLS, name uintptr, prots uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_getservbyname_r(tls, name, prots, uintptr(unsafe.Pointer(&_se)), uintptr(unsafe.Pointer(&_buf4)), uint64(32), bp) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_se))
}

var _se Tservent

var _buf4 [4]int64

func x_getservbyname_r(tls *TLS, name uintptr, prots uintptr, se uintptr, buf uintptr, buflen uint64, res uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var i int32
	var _ /* ai at bp+0 */ uintptr
	var _ /* hint at bp+8 */ Taddrinfo
	*(*Taddrinfo)(unsafe.Pointer(bp + 8)) = Taddrinfo{Fai_family: int32(m_PF_INET)}
	/* Align buffer */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen < Uint64FromInt32(3)*Uint64FromInt64(8)-uint64(i) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return -int32(1)
	}
	buf += uintptr(uint64(8) - uint64(i))
	buflen -= uint64(8) - uint64(i)
	if !(x_strcmp(tls, prots, ts+353) != 0) {
		(*(*Taddrinfo)(unsafe.Pointer(bp + 8))).Fai_protocol = int32(m_IPPROTO_TCP)
	} else {
		if !(x_strcmp(tls, prots, ts+357) != 0) {
			(*(*Taddrinfo)(unsafe.Pointer(bp + 8))).Fai_protocol = int32(m_IPPROTO_UDP)
		} else {
			return -int32(1)
		}
	}
	if x_getaddrinfo(tls, uintptr(0), name, bp+8, bp) < 0 {
		return -int32(1)
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_name = name
	(*Tservent)(unsafe.Pointer(se)).Fs_aliases = buf
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases)) = (*Tservent)(unsafe.Pointer(se)).Fs_name
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + 1*8)) = uintptr(0)
	(*Tservent)(unsafe.Pointer(se)).Fs_port = int32((*Tsockaddr_in)(unsafe.Pointer((*Taddrinfo)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fai_addr)).Fsin_port)
	(*Tservent)(unsafe.Pointer(se)).Fs_proto = prots
	x_freeaddrinfo(tls, *(*uintptr)(unsafe.Pointer(bp)))
	*(*uintptr)(unsafe.Pointer(res)) = se
	return 0
}

func x_getservbyport(tls *TLS, port int32, prots uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_getservbyport_r(tls, port, prots, uintptr(unsafe.Pointer(&_se1)), uintptr(unsafe.Pointer(&_buf5)), uint64(32), bp) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_se1))
}

var _se1 Tservent

var _buf5 [4]int64

const m_NI_DGRAM = 16

func x_getservbyport_r(tls *TLS, port int32, prots uintptr, se uintptr, buf uintptr, buflen uint64, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var i, v2 int32
	var v1 uintptr
	var _ /* sin at bp+0 */ Tsockaddr_in
	*(*Tsockaddr_in)(unsafe.Pointer(bp)) = Tsockaddr_in{Fsin_family: uint16(m_PF_INET), Fsin_port: uint16(port)}
	/* Align buffer */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen < Uint64FromInt32(3)*Uint64FromInt64(8)-uint64(i) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return -int32(1)
	}
	buf += uintptr(uint64(8) - uint64(i))
	buflen -= uint64(8) - uint64(i)
	if x_strcmp(tls, prots, ts+353) != 0 && x_strcmp(tls, prots, ts+357) != 0 {
		return -int32(1)
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_port = port
	(*Tservent)(unsafe.Pointer(se)).Fs_proto = prots
	(*Tservent)(unsafe.Pointer(se)).Fs_aliases = buf
	buf += uintptr(Uint64FromInt32(2) * Uint64FromInt64(8))
	buflen -= Uint64FromInt32(2) * Uint64FromInt64(8)
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + 1*8)) = uintptr(0)
	v1 = buf
	(*Tservent)(unsafe.Pointer(se)).Fs_name = v1
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases)) = v1
	if x_strcmp(tls, prots, ts+357) != 0 {
		v2 = 0
	} else {
		v2 = int32(m_NI_DGRAM)
	}
	if x_getnameinfo(tls, bp, uint32(16), uintptr(0), uint32(0), buf, uint32(buflen), v2) < 0 {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(res)) = se
	return 0
}

const m___NR_getsockname = 51

func x_getsockname(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_getsockname), int64(fd), int64(addr), int64(len1), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

const m___NR_getsockopt = 55

func x_getsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen uintptr) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_getsockopt), int64(fd), int64(level), int64(optname), int64(optval), int64(optlen), Int64FromInt32(0)))
}

var _msgs1 = [84]int8{'H', 'o', 's', 't', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func x_hstrerror(tls *TLS, ecode int32) (r uintptr) {
	var s, v2 uintptr
	s = uintptr(unsafe.Pointer(&_msgs1))
	ecode--
	for ecode != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
		goto _1
	_1:
		ecode--
		s++
	}
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		v2 = s
	} else {
		v2 = s + uintptr(1)
	}
	return v2
}

func x_htonl(tls *TLS, n uint32) (r uint32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fi [0]uint32
		Fb [4]uint8
	}
	*(*struct {
		Fi [0]uint32
		Fb [4]uint8
	})(unsafe.Pointer(bp)) = *(*struct {
		Fi [0]uint32
		Fb [4]uint8
	})(unsafe.Pointer(&[4]uint8{
		0: uint8(n >> int32(24)),
		1: uint8(n >> int32(16)),
		2: uint8(n >> int32(8)),
		3: uint8(n)}))
	return *(*uint32)(unsafe.Pointer(bp))
}

func x_htons(tls *TLS, n uint16) (r uint16) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fs [0]uint16
		Fb [2]uint8
	}
	*(*struct {
		Fs [0]uint16
		Fb [2]uint8
	})(unsafe.Pointer(bp)) = *(*struct {
		Fs [0]uint16
		Fb [2]uint8
	})(unsafe.Pointer(&[2]uint8{
		0: uint8(int32(n) >> int32(8)),
		1: uint8(n)}))
	return *(*uint16)(unsafe.Pointer(bp))
}

func x_inet_addr(tls *TLS, p uintptr) (r uint32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* sin at bp+0 */ Tsockaddr_in
	if x___ipparse(tls, bp, int32(m_PF_INET), p) != 0 {
		return uint32(-Int32FromInt32(1))
	}
	return (*(*Tsockaddr_in)(unsafe.Pointer(bp))).Fsin_addr.Fs_addr
}

func x_inet_aton(tls *TLS, cp uintptr, inp uintptr) (r int32) {
	return BoolInt32(x_inet_pton(tls, int32(m_PF_INET), cp, inp) > 0)
}

func x_inet_ntoa(tls *TLS, _in Tin_addr) (r uintptr) {
	bp := tls.Alloc(48) /* tlsAllocs 8 maxVaListSize 32 */
	defer tls.Free(48)
	*(*Tin_addr)(unsafe.Pointer(bp)) = _in
	var a uintptr
	a = bp
	x_snprintf(tls, uintptr(unsafe.Pointer(&_buf6)), uint64(16), ts+361, VaList(bp+16, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3)))))
	return uintptr(unsafe.Pointer(&_buf6))
}

var _buf6 [16]int8

const m_EAFNOSUPPORT = 97
const m_ENOSPC = 28

func x_inet_ntop(tls *TLS, af int32, a0 uintptr, s uintptr, l uint32) (r uintptr) {
	bp := tls.Alloc(240) /* tlsAllocs 104 maxVaListSize 128 */
	defer tls.Free(240)
	var a uintptr
	var best, i, j, max, v1 int32
	var v2 int8
	var _ /* buf at bp+0 */ [100]int8
	a = a0
	switch af {
	case int32(m_PF_INET):
		if uint32(x_snprintf(tls, s, uint64(l), ts+361, VaList(bp+112, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3)))))) < l {
			return s
		}
	case int32(m_PF_INET6):
		x_memset(tls, bp, int32('x'), uint64(100))
		(*(*[100]int8)(unsafe.Pointer(bp)))[Uint64FromInt64(100)-Uint64FromInt32(1)] = 0
		x_snprintf(tls, bp, uint64(100), ts+373, VaList(bp+112, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3))), int32(*(*uint8)(unsafe.Pointer(a + 4))), int32(*(*uint8)(unsafe.Pointer(a + 5))), int32(*(*uint8)(unsafe.Pointer(a + 6))), int32(*(*uint8)(unsafe.Pointer(a + 7))), int32(*(*uint8)(unsafe.Pointer(a + 8))), int32(*(*uint8)(unsafe.Pointer(a + 9))), int32(*(*uint8)(unsafe.Pointer(a + 10))), int32(*(*uint8)(unsafe.Pointer(a + 11))), int32(*(*uint8)(unsafe.Pointer(a + 12))), int32(*(*uint8)(unsafe.Pointer(a + 13))), int32(*(*uint8)(unsafe.Pointer(a + 14))), int32(*(*uint8)(unsafe.Pointer(a + 15)))))
		/* Replace longest /(^0|:)[:0]{2,}/ with "::" */
		v1 = Int32FromInt32(0)
		best = v1
		i = v1
		max = Int32FromInt32(2)
		for ; (*(*[100]int8)(unsafe.Pointer(bp)))[i] != 0; i++ {
			if i != 0 && int32((*(*[100]int8)(unsafe.Pointer(bp)))[i]) != int32(':') {
				continue
			}
			j = int32(x_strspn(tls, bp+uintptr(i), ts+429))
			if j > max {
				best = i
				max = j
			}
		}
		if max > int32(2) {
			v2 = Int8FromUint8(':')
			(*(*[100]int8)(unsafe.Pointer(bp)))[best+int32(1)] = v2
			(*(*[100]int8)(unsafe.Pointer(bp)))[best] = v2
			x_strcpy(tls, bp+uintptr(best)+uintptr(2), bp+uintptr(best)+uintptr(max))
		}
		if x_strlen(tls, bp) < uint64(l) {
			x_strcpy(tls, s, bp)
			return s
		}
	default:
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAFNOSUPPORT)
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOSPC)
	return uintptr(0)
}

func x_inet_pton(tls *TLS, af int32, s uintptr, a0 uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var a uintptr
	var i int32
	var x, v1 uint64
	var _ /* z at bp+0 */ uintptr
	a = a0
	/* Reimplement this because inet_pton cannot accept special v4 forms */
	if af == int32(m_PF_INET) {
		for i = 0; i < int32(4) && *(*int8)(unsafe.Pointer(s)) != 0; i++ {
			v1 = x_strtoul(tls, s, bp, int32(10))
			x = v1
			*(*uint8)(unsafe.Pointer(a + uintptr(i))) = uint8(v1)
			if !(uint32(int32(*(*int8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < Uint32FromInt32(10)) || *(*uintptr)(unsafe.Pointer(bp)) == s || *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('.') || x > uint64(255) {
				return 0
			}
			s = *(*uintptr)(unsafe.Pointer(bp)) + uintptr(1)
		}
		return 0
	} else if af == int32(m_PF_INET6) {
		return BoolInt32(!(x___ipparse(tls, a, int32(m_PF_INET6), s) != 0))
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAFNOSUPPORT)
	return 0
}

const m___NR_listen = 50

func x_listen(tls *TLS, fd int32, backlog int32) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_listen), int64(fd), int64(backlog), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

func x_ntohl(tls *TLS, n uint32) (r uint32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fb [0][4]uint8
		Fi uint32
	}
	*(*uint32)(unsafe.Pointer(bp)) = n
	return uint32(int32(*(*uint8)(unsafe.Pointer(bp)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(bp + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(bp + 2)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(bp + 3))))
}

func x_ntohs(tls *TLS, n uint16) (r uint16) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fb [0][2]uint8
		Fs uint16
	}
	*(*uint16)(unsafe.Pointer(bp)) = n
	return uint16(int32(*(*uint8)(unsafe.Pointer(bp)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(bp + 1))))
}

/* do we really need all these?? */

var _idx int32
var _protos = [9][6]uint8{
	0: {0, 'i', 'p'},
	1: {1, 'i', 'c', 'm', 'p'},
	2: {2, 'i', 'g', 'm', 'p'},
	3: {3, 'g', 'g', 'p'},
	4: {6, 't', 'c', 'p'},
	5: {12, 'p', 'u', 'p'},
	6: {17, 'u', 'd', 'p'},
	7: {22, 'i', 'd', 'p'},
	8: {255, 'r', 'a', 'w'}}

func x_endprotoent(tls *TLS) {
	_idx = 0
}

func x_setprotoent(tls *TLS, stayopen int32) {
	_idx = 0
}

func x_getprotoent(tls *TLS) (r uintptr) {
	var v1 int32
	if !(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_protos)) + uintptr(_idx)*6 + 1)) != 0) {
		return UintptrFromInt32(0)
	}
	_p1.Fp_proto = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_protos)) + uintptr(_idx)*6)))
	v1 = _idx
	_idx++
	_p1.Fp_name = uintptr(unsafe.Pointer(&_protos)) + uintptr(v1)*6 + uintptr(1)
	_p1.Fp_aliases = uintptr(unsafe.Pointer(&_aliases))
	return uintptr(unsafe.Pointer(&_p1))
}

var _p1 Tprotoent

var _aliases uintptr

func x_getprotobyname(tls *TLS, name uintptr) (r uintptr) {
	var p uintptr
	x_endprotoent(tls)
	for cond := true; cond; cond = p != 0 && x_strcmp(tls, name, (*Tprotoent)(unsafe.Pointer(p)).Fp_name) != 0 {
		p = x_getprotoent(tls)
	}
	return p
}

func x_getprotobynumber(tls *TLS, num int32) (r uintptr) {
	var p uintptr
	x_endprotoent(tls)
	for cond := true; cond; cond = p != 0 && (*Tprotoent)(unsafe.Pointer(p)).Fp_proto != num {
		p = x_getprotoent(tls)
	}
	return p
}

func x_recv(tls *TLS, fd int32, buf uintptr, len1 uint64, flags int32) (r int64) {
	return x_recvfrom(tls, fd, buf, len1, flags, uintptr(0), uintptr(0))
}

const m___NR_recvfrom = 45

func x_recvfrom(tls *TLS, fd int32, buf uintptr, len1 uint64, flags int32, addr uintptr, alen uintptr) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall6(tls, int64(m___NR_recvfrom), int64(fd), int64(buf), int64(len1), int64(flags), int64(addr), int64(alen))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_recvmsg = 47

func x_recvmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall6(tls, int64(m___NR_recvmsg), int64(fd), int64(msg), int64(flags), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

func x_res_init(tls *TLS) (r int32) {
	return 0
}

func x_res_query(tls *TLS, name uintptr, class int32, _type int32, dest uintptr, len1 int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*int32)(unsafe.Pointer(bp)) = _type
	if class != int32(1) || len1 < int32(512) {
		return -int32(1)
	}
	switch x___dns_doqueries(tls, dest, name, bp, int32(1)) {
	case -int32(2):
		x_h_errno = int32(m_HOST_NOT_FOUND)
		return -int32(1)
	case -int32(3):
		x_h_errno = int32(m_TRY_AGAIN)
		return -int32(1)
	case -int32(4):
		x_h_errno = int32(m_NO_RECOVERY)
		return -int32(1)
	}
	return int32(512)
}

func x_send(tls *TLS, fd int32, buf uintptr, len1 uint64, flags int32) (r int64) {
	return x_sendto(tls, fd, buf, len1, flags, uintptr(0), uint32(0))
}

const m___NR_sendmsg = 46

func x_sendmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall6(tls, int64(m___NR_sendmsg), int64(fd), int64(msg), int64(flags), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_sendto = 44

func x_sendto(tls *TLS, fd int32, buf uintptr, len1 uint64, flags int32, addr uintptr, alen uint32) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall6(tls, int64(m___NR_sendto), int64(fd), int64(buf), int64(len1), int64(flags), int64(addr), int64(alen))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

func x_endservent(tls *TLS) {
}

func x_setservent(tls *TLS, stayopen int32) {
}

func x_getservent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

const m___NR_setsockopt = 54

func x_setsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen uint32) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_setsockopt), int64(fd), int64(level), int64(optname), int64(optval), int64(optlen), Int64FromInt32(0)))
}

const m___NR_shutdown = 48

func x_shutdown(tls *TLS, fd int32, how int32) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_shutdown), int64(fd), int64(how), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

const m_SIOCATMARK = 35077

func x_sockatmark(tls *TLS, s int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var _ /* ret at bp+0 */ int32
	if x_ioctl(tls, s, int32(m_SIOCATMARK), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

const m___NR_socket = 41

func x_socket(tls *TLS, domain int32, type1 int32, protocol int32) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_socket), int64(domain), int64(type1), int64(protocol), Int64FromInt32(0), Int64FromInt32(0), Int64FromInt32(0)))
}

const m___NR_socketpair = 53

func x_socketpair(tls *TLS, domain int32, type1 int32, protocol int32, fd uintptr) (r int32) {
	return int32(_syscall6(tls, int64(m___NR_socketpair), int64(domain), int64(type1), int64(protocol), int64(fd), Int64FromInt32(0), Int64FromInt32(0)))
}

type Tspwd = struct {
	Fsp_namp   uintptr
	Fsp_pwdp   uintptr
	Fsp_lstchg int64
	Fsp_min    int64
	Fsp_max    int64
	Fsp_warn   int64
	Fsp_inact  int64
	Fsp_expire int64
	Fsp_flag   uint64
}

func _getgr_r(tls *TLS, name uintptr, gid uint32, gr uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var f uintptr
	var i uint64
	var rv int32
	var _ /* len at bp+8 */ uint64
	var _ /* line at bp+0 */ uintptr
	var _ /* mem at bp+16 */ uintptr
	var _ /* nmem at bp+24 */ uint64
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	*(*uint64)(unsafe.Pointer(bp + 24)) = uint64(0)
	rv = 0
	f = x_fopen(tls, ts+432, ts+443)
	if !(f != 0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	for x___getgrent_a(tls, f, gr, bp, bp+8, bp+16, bp+24) != 0 {
		if name != 0 && !(x_strcmp(tls, name, (*Tgroup)(unsafe.Pointer(gr)).Fgr_name) != 0) || !(name != 0) && (*Tgroup)(unsafe.Pointer(gr)).Fgr_gid == gid {
			if size < *(*uint64)(unsafe.Pointer(bp + 8))+*(*uint64)(unsafe.Pointer(bp + 24))*uint64(8)+uint64(32) {
				rv = int32(m_ERANGE)
				break
			}
			*(*uintptr)(unsafe.Pointer(res)) = gr
			buf += uintptr((uint64(16) - uint64(buf)) % uint64(16))
			(*Tgroup)(unsafe.Pointer(gr)).Fgr_mem = buf
			buf += uintptr(*(*uint64)(unsafe.Pointer(bp + 24)) * uint64(8))
			x_memcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*uint64)(unsafe.Pointer(bp + 8)))
			(*Tgroup)(unsafe.Pointer(gr)).Fgr_name = uintptr(int64((*Tgroup)(unsafe.Pointer(gr)).Fgr_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			(*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd = uintptr(int64((*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			for i = uint64(0); *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)) != 0; i++ {
				*(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(int64(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)))-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			}
			*(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(0)
			break
		}
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	x_fclose(tls, f)
	return rv
}

func x_getgrnam_r(tls *TLS, name uintptr, gr uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	return _getgr_r(tls, name, uint32(0), gr, buf, size, res)
}

func x_getgruid_r(tls *TLS, gid uint32, gr uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	return _getgr_r(tls, uintptr(0), gid, gr, buf, size, res)
}

var _f uintptr

func x_setgrent(tls *TLS) {
	if _f != 0 {
		x_fclose(tls, _f)
	}
	_f = uintptr(0)
}

func x_getgrent(tls *TLS) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* nmem at bp+8 */ uint64
	var _ /* size at bp+0 */ uint64
	*(*uint64)(unsafe.Pointer(bp)) = uint64(0)
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(0)
	if !(_f != 0) {
		_f = x_fopen(tls, ts+432, ts+443)
	}
	if !(_f != 0) {
		return uintptr(0)
	}
	return x___getgrent_a(tls, _f, uintptr(unsafe.Pointer(&_gr)), uintptr(unsafe.Pointer(&_line)), bp, uintptr(unsafe.Pointer(&_mem)), bp+8)
}

var _line uintptr

var _mem uintptr

var _gr Tgroup

func x_getgrgid(tls *TLS, gid uint32) (r uintptr) {
	var gr, v1 uintptr
	x_setgrent(tls)
	for {
		v1 = x_getgrent(tls)
		gr = v1
		if !(v1 != 0 && (*Tgroup)(unsafe.Pointer(gr)).Fgr_gid != gid) {
			break
		}
	}
	x_setgrent(tls)
	return gr
}

func x_getgrnam(tls *TLS, name uintptr) (r uintptr) {
	var gr, v1 uintptr
	x_setgrent(tls)
	for {
		v1 = x_getgrent(tls)
		gr = v1
		if !(v1 != 0 && x_strcmp(tls, (*Tgroup)(unsafe.Pointer(gr)).Fgr_name, name) != 0) {
			break
		}
	}
	x_setgrent(tls)
	return gr
}

func x___getgrent_a(tls *TLS, f uintptr, gr uintptr, line uintptr, size uintptr, mem uintptr, nmem uintptr) (r uintptr) {
	var i, v10, v11 uint64
	var l, v1 int64
	var mems, s, v2, v3, v4, v5, v6, v7, v8, v9 uintptr
	for {
		v1 = x_getline(tls, line, size, f)
		l = v1
		if v1 < 0 {
			x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			return uintptr(0)
		}
		*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line)) + uintptr(l-int64(1)))) = 0
		s = *(*uintptr)(unsafe.Pointer(line))
		v2 = s
		s++
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_name = v2
		v3 = x_strchr(tls, s, int32(':'))
		s = v3
		if !(v3 != 0) {
			continue
		}
		v4 = s
		s++
		*(*int8)(unsafe.Pointer(v4)) = 0
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd = s
		v5 = x_strchr(tls, s, int32(':'))
		s = v5
		if !(v5 != 0) {
			continue
		}
		v6 = s
		s++
		*(*int8)(unsafe.Pointer(v6)) = 0
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_gid = uint32(x_atoi(tls, s))
		v7 = x_strchr(tls, s, int32(':'))
		s = v7
		if !(v7 != 0) {
			continue
		}
		v8 = s
		s++
		*(*int8)(unsafe.Pointer(v8)) = 0
		mems = s
		break
	}
	for *(*uint64)(unsafe.Pointer(nmem)) = BoolUint64(!!(*(*int8)(unsafe.Pointer(s)) != 0)); *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(',') {
			*(*uint64)(unsafe.Pointer(nmem))++
		}
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(mem)))
	*(*uintptr)(unsafe.Pointer(mem)) = x_calloc(tls, uint64(8), *(*uint64)(unsafe.Pointer(nmem))+uint64(1))
	if !(*(*uintptr)(unsafe.Pointer(mem)) != 0) {
		x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
		*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
		return uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)))) = mems
	s = mems
	i = Uint64FromInt32(0)
	for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(',') {
			v9 = s
			s++
			*(*int8)(unsafe.Pointer(v9)) = 0
			i++
			v10 = i
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(v10)*8)) = s
		}
	}
	i++
	v11 = i
	*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(v11)*8)) = uintptr(0)
	(*Tgroup)(unsafe.Pointer(gr)).Fgr_mem = *(*uintptr)(unsafe.Pointer(mem))
	return gr
}

func _getpw_r(tls *TLS, name uintptr, uid uint32, pw uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var f uintptr
	var rv int32
	var _ /* len at bp+8 */ uint64
	var _ /* line at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(0)
	rv = 0
	f = x_fopen(tls, ts+446, ts+443)
	if !(f != 0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	for x___getpwent_a(tls, f, pw, bp, bp+8) != 0 {
		if name != 0 && !(x_strcmp(tls, name, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name) != 0) || !(name != 0) && (*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid == uid {
			if size < *(*uint64)(unsafe.Pointer(bp + 8)) {
				rv = int32(m_ERANGE)
				break
			}
			*(*uintptr)(unsafe.Pointer(res)) = pw
			x_memcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*uint64)(unsafe.Pointer(bp + 8)))
			(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			break
		}
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	x_fclose(tls, f)
	return rv
}

func x_getpwnam_r(tls *TLS, name uintptr, pw uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	return _getpw_r(tls, name, uint32(0), pw, buf, size, res)
}

func x_getpwuid_r(tls *TLS, uid uint32, pw uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	return _getpw_r(tls, uintptr(0), uid, pw, buf, size, res)
}

var _f1 uintptr

func x_setpwent(tls *TLS) {
	if _f1 != 0 {
		x_fclose(tls, _f1)
	}
	_f1 = uintptr(0)
}

func x_getpwent(tls *TLS) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* size at bp+0 */ uint64
	*(*uint64)(unsafe.Pointer(bp)) = uint64(0)
	if !(_f1 != 0) {
		_f1 = x_fopen(tls, ts+446, ts+443)
	}
	if !(_f1 != 0) {
		return uintptr(0)
	}
	return x___getpwent_a(tls, _f1, uintptr(unsafe.Pointer(&_pw)), uintptr(unsafe.Pointer(&_line1)), bp)
}

var _line1 uintptr

var _pw Tpasswd

func x_getpwuid(tls *TLS, uid uint32) (r uintptr) {
	var pw, v1 uintptr
	x_setpwent(tls)
	for {
		v1 = x_getpwent(tls)
		pw = v1
		if !(v1 != 0 && (*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid != uid) {
			break
		}
	}
	x_setpwent(tls)
	return pw
}

func x_getpwnam(tls *TLS, name uintptr) (r uintptr) {
	var pw, v1 uintptr
	x_setpwent(tls)
	for {
		v1 = x_getpwent(tls)
		pw = v1
		if !(v1 != 0 && x_strcmp(tls, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name, name) != 0) {
			break
		}
	}
	x_setpwent(tls)
	return pw
}

func x___getpwent_a(tls *TLS, f uintptr, pw uintptr, line uintptr, size uintptr) (r uintptr) {
	var l, v1 int64
	var s, v10, v11, v12, v13, v14, v2, v3, v4, v5, v6, v7, v8, v9 uintptr
	for {
		v1 = x_getline(tls, line, size, f)
		l = v1
		if v1 < 0 {
			x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			return uintptr(0)
		}
		*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line)) + uintptr(l-int64(1)))) = 0
		s = *(*uintptr)(unsafe.Pointer(line))
		v2 = s
		s++
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = v2
		v3 = x_strchr(tls, s, int32(':'))
		s = v3
		if !(v3 != 0) {
			continue
		}
		v4 = s
		s++
		*(*int8)(unsafe.Pointer(v4)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = s
		v5 = x_strchr(tls, s, int32(':'))
		s = v5
		if !(v5 != 0) {
			continue
		}
		v6 = s
		s++
		*(*int8)(unsafe.Pointer(v6)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid = uint32(x_atoi(tls, s))
		v7 = x_strchr(tls, s, int32(':'))
		s = v7
		if !(v7 != 0) {
			continue
		}
		v8 = s
		s++
		*(*int8)(unsafe.Pointer(v8)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid = uint32(x_atoi(tls, s))
		v9 = x_strchr(tls, s, int32(':'))
		s = v9
		if !(v9 != 0) {
			continue
		}
		v10 = s
		s++
		*(*int8)(unsafe.Pointer(v10)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = s
		v11 = x_strchr(tls, s, int32(':'))
		s = v11
		if !(v11 != 0) {
			continue
		}
		v12 = s
		s++
		*(*int8)(unsafe.Pointer(v12)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = s
		v13 = x_strchr(tls, s, int32(':'))
		s = v13
		if !(v13 != 0) {
			continue
		}
		v14 = s
		s++
		*(*int8)(unsafe.Pointer(v14)) = 0
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = s
		return pw
	}
	return r
}

func x_setspent(tls *TLS) {
}

func x_endspent(tls *TLS) {
}

func x_getspent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

const m_LINE_LIM = 256

func x_getspnam(tls *TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var e int32
	var _ /* res at bp+0 */ uintptr
	if !(_line2 != 0) {
		_line2 = x_malloc(tls, uint64(m_LINE_LIM))
	}
	if !(_line2 != 0) {
		return uintptr(0)
	}
	e = x_getspnam_r(tls, name, uintptr(unsafe.Pointer(&_sp)), _line2, uint64(m_LINE_LIM), bp)
	if e != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = e
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _sp Tspwd

var _line2 uintptr

const m_O_NOFOLLOW = 131072
const m_S_IFREG = 32768

func x_getspnam_r(tls *TLS, name uintptr, sp uintptr, buf uintptr, size uint64, res uintptr) (r int32) {
	bp := tls.Alloc(440) /* tlsAllocs 424 maxVaListSize 8 */
	defer tls.Free(440)
	var f, s, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v5, v6, v7, v8, v9 uintptr
	var fd, rv, skip int32
	var k, l, v3 uint64
	var v2, v4 bool
	var _ /* path at bp+0 */ [275]int8
	var _ /* st at bp+280 */ Tstat
	f = uintptr(0)
	rv = 0
	l = x_strlen(tls, name)
	skip = 0
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Disallow potentially-malicious user names */
	if int32(*(*int8)(unsafe.Pointer(name))) == int32('.') || x_strchr(tls, name, int32('/')) != 0 || !(l != 0) {
		return int32(m_EINVAL)
	}
	/* Buffer size must at least be able to hold name, plus some.. */
	if size < l+uint64(100) {
		return int32(m_ERANGE)
	}
	/* Protect against truncation */
	if uint64(x_snprintf(tls, bp, uint64(275), ts+458, VaList(bp+432, name))) >= uint64(275) {
		return int32(m_EINVAL)
	}
	fd = x_open(tls, bp, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_NOFOLLOW)|Int32FromInt32(m_O_NONBLOCK), 0)
	if fd >= 0 {
		*(*Tstat)(unsafe.Pointer(bp + 280)) = Tstat{}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		if v2 = x_fstat(tls, fd, bp+280) != 0 || !((*(*Tstat)(unsafe.Pointer(bp + 280))).Fst_mode&Uint32FromInt32(m_S_IFMT) == Uint32FromInt32(m_S_IFREG)); !v2 {
			v1 = x___fdopen(tls, fd, ts+443)
			f = v1
		}
		if v2 || !(v1 != 0) {
			x_close(tls, fd)
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
	} else {
		f = x_fopen(tls, ts+477, ts+443)
		if !(f != 0) {
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
	}
	for {
		if v4 = x_fgets(tls, buf, int32(size), f) != 0; v4 {
			v3 = x_strlen(tls, buf)
			k = v3
		}
		if !(v4 && v3 > uint64(0)) {
			break
		}
		if skip != 0 || x_strncmp(tls, name, buf, l) != 0 {
			skip = BoolInt32(int32(*(*int8)(unsafe.Pointer(buf + uintptr(k-uint64(1))))) != int32('\n'))
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(buf + uintptr(k-uint64(1))))) != int32('\n') {
			rv = int32(m_ERANGE)
			break
		}
		*(*int8)(unsafe.Pointer(buf + uintptr(k-uint64(1)))) = 0
		s = buf
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_namp = s
		v5 = x_strchr(tls, s, int32(':'))
		s = v5
		if !(v5 != 0) {
			continue
		}
		v6 = s
		s++
		*(*int8)(unsafe.Pointer(v6)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp = s
		v7 = x_strchr(tls, s, int32(':'))
		s = v7
		if !(v7 != 0) {
			continue
		}
		v8 = s
		s++
		*(*int8)(unsafe.Pointer(v8)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg = x_atol(tls, s)
		v9 = x_strchr(tls, s, int32(':'))
		s = v9
		if !(v9 != 0) {
			continue
		}
		v10 = s
		s++
		*(*int8)(unsafe.Pointer(v10)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_min = x_atol(tls, s)
		v11 = x_strchr(tls, s, int32(':'))
		s = v11
		if !(v11 != 0) {
			continue
		}
		v12 = s
		s++
		*(*int8)(unsafe.Pointer(v12)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_max = x_atol(tls, s)
		v13 = x_strchr(tls, s, int32(':'))
		s = v13
		if !(v13 != 0) {
			continue
		}
		v14 = s
		s++
		*(*int8)(unsafe.Pointer(v14)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_warn = x_atol(tls, s)
		v15 = x_strchr(tls, s, int32(':'))
		s = v15
		if !(v15 != 0) {
			continue
		}
		v16 = s
		s++
		*(*int8)(unsafe.Pointer(v16)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_inact = x_atol(tls, s)
		v17 = x_strchr(tls, s, int32(':'))
		s = v17
		if !(v17 != 0) {
			continue
		}
		v18 = s
		s++
		*(*int8)(unsafe.Pointer(v18)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_expire = x_atol(tls, s)
		v19 = x_strchr(tls, s, int32(':'))
		s = v19
		if !(v19 != 0) {
			continue
		}
		v20 = s
		s++
		*(*int8)(unsafe.Pointer(v20)) = 0
		(*Tspwd)(unsafe.Pointer(sp)).Fsp_flag = uint64(x_atol(tls, s))
		*(*uintptr)(unsafe.Pointer(res)) = sp
		break
	}
	x_fclose(tls, f)
	return rv
}

func x_lckpwdf(tls *TLS) (r int32) {
	return 0
}

func x_ulckpwdf(tls *TLS) (r int32) {
	return 0
}

func x___rand48_step(tls *TLS, xi uintptr, lc uintptr) (r uint64) {
	var a, x uint64
	x = uint64(int32(*(*uint16)(unsafe.Pointer(xi)))|int32(*(*uint16)(unsafe.Pointer(xi + 1*2)))<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(xi + 2*2)))+0)<<int32(32)
	a = uint64(int32(*(*uint16)(unsafe.Pointer(lc)))|int32(*(*uint16)(unsafe.Pointer(lc + 1*2)))<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(lc + 2*2)))+0)<<int32(32)
	x = a*x + uint64(*(*uint16)(unsafe.Pointer(lc + 3*2)))
	*(*uint16)(unsafe.Pointer(xi)) = uint16(x)
	*(*uint16)(unsafe.Pointer(xi + 1*2)) = uint16(x >> int32(16))
	*(*uint16)(unsafe.Pointer(xi + 2*2)) = uint16(x >> int32(32))
	return x & uint64(0xffffffffffff)
}

func x_erand48(tls *TLS, s uintptr) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* x at bp+0 */ struct {
		Ff [0]float64
		Fu uint64
	}
	*(*uint64)(unsafe.Pointer(bp)) = uint64(0x3ff0000000000000) | x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2)<<int32(4)
	return *(*float64)(unsafe.Pointer(bp)) - float64(1)
}

func x_drand48(tls *TLS) (r float64) {
	return x_erand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

func x_lcong48(tls *TLS, p uintptr) {
	x_memcpy(tls, uintptr(unsafe.Pointer(&x___seed48)), p, uint64(14))
}

func x_nrand48(tls *TLS, s uintptr) (r int64) {
	return int64(x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2) >> int32(17))
}

func x_lrand48(tls *TLS) (r int64) {
	return x_nrand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

func x_jrand48(tls *TLS, s uintptr) (r int64) {
	return int64(x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2) >> int32(16))
}

func x_mrand48(tls *TLS) (r int64) {
	return x_jrand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

var _seed uint32

func x_srand(tls *TLS, s uint32) {
	_seed = s - uint32(1)
}

func x_rand(tls *TLS) (r int32) {
	var v1 uint32
	v1 = (_seed+Uint32FromInt32(1))*Uint32FromInt32(1103515245) + Uint32FromInt32(12345) - Uint32FromInt32(1)
	_seed = v1
	return int32((v1 + uint32(1)) & uint32(0x7fffffff))
}

func x_rand_r(tls *TLS, seed uintptr) (r int32) {
	var v1 uint32
	v1 = *(*uint32)(unsafe.Pointer(seed))*Uint32FromInt32(1103515245) + Uint32FromInt32(12345)
	*(*uint32)(unsafe.Pointer(seed)) = v1
	return int32(v1 & uint32(0x7fffffff))
}

func x_random(tls *TLS) (r int64) {
	return int64(x_rand(tls))
}

func x_seed48(tls *TLS, s uintptr) (r uintptr) {
	x_memcpy(tls, uintptr(unsafe.Pointer(&_p2)), uintptr(unsafe.Pointer(&x___seed48)), uint64(6))
	x_memcpy(tls, uintptr(unsafe.Pointer(&x___seed48)), s, uint64(6))
	return uintptr(unsafe.Pointer(&_p2))
}

var _p2 [3]uint16

func x_srand48(tls *TLS, seed int64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*[3]uint16)(unsafe.Pointer(bp)) = [3]uint16{
		0: uint16(0x330e),
		1: uint16(seed),
		2: uint16(seed >> int32(16))}
	x_seed48(tls, bp)
}

func x_srandom(tls *TLS, seed uint32) {
	x_srand(tls, seed)
	return
}

func x_execl(tls *TLS, path uintptr, va uintptr) (r int32) {
	var ap, argv uintptr
	var argc, i int32
	var v1 uint64
	defer func() { x_realloc(tls, argv, 0) }()
	ap = va
	for argc = 0; VaUintptr(&ap) != 0; argc++ {
	}
	_ = ap
	{
		v1 = uint64(argc+int32(1)) * 8
		argv = x_realloc(tls, argv, v1)
		ap = va
		for i = 0; i < argc; i++ {
			*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = UintptrFromInt32(0)
		return x_execv(tls, path, argv)
	}
	return r
}

func x_execle(tls *TLS, path uintptr, va uintptr) (r int32) {
	var ap, argv, envp uintptr
	var argc, i int32
	var v1 uint64
	defer func() { x_realloc(tls, argv, 0) }()
	ap = va
	for argc = 0; VaUintptr(&ap) != 0; argc++ {
	}
	_ = ap
	{
		v1 = uint64(argc+int32(1)) * 8
		argv = x_realloc(tls, argv, v1)
		ap = va
		for i = 0; i < argc; i++ {
			*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = UintptrFromInt32(0)
		envp = VaUintptr(&ap)
		return x_execve(tls, path, argv, envp)
	}
	return r
}

func x_execlp(tls *TLS, file uintptr, va uintptr) (r int32) {
	var ap, argv uintptr
	var argc, i int32
	var v1 uint64
	defer func() { x_realloc(tls, argv, 0) }()
	ap = va
	for argc = 0; VaUintptr(&ap) != 0; argc++ {
	}
	_ = ap
	{
		v1 = uint64(argc+int32(1)) * 8
		argv = x_realloc(tls, argv, v1)
		ap = va
		for i = 0; i < argc; i++ {
			*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = UintptrFromInt32(0)
		return x_execvp(tls, file, argv)
	}
	return r
}

func x_execv(tls *TLS, path uintptr, argv uintptr) (r int32) {
	return x_execve(tls, path, argv, x____environ)
}

const m___NR_execve = 59

func x_execve(tls *TLS, path uintptr, argv uintptr, envp uintptr) (r int32) {
	/* do we need to use environ if envp is null? */
	return int32(_syscall3(tls, int64(m___NR_execve), int64(path), int64(argv), int64(envp)))
}

const m_X_OK = 1

func x_execvp(tls *TLS, file uintptr, argv uintptr) (r int32) {
	var b, p, path, z, v2 uintptr
	var l int32
	var v1 uint64
	defer func() { x_realloc(tls, b, 0) }()
	path = x_getenv(tls, ts+489)
	if x_strchr(tls, file, int32('/')) != 0 {
		return x_execve(tls, file, argv, x____environ)
	}
	/* FIXME: integer overflows */
	if !(path != 0) {
		path = ts + 494
	}
	l = int32(x_strlen(tls, file) + x_strlen(tls, path) + uint64(2))
	for p = path; p != 0 && *(*int8)(unsafe.Pointer(p)) != 0; p = z {
		v1 = uint64(l)
		b = x_realloc(tls, b, v1)
		z = x_strchr(tls, p, int32(':'))
		if z != 0 {
			x_memcpy(tls, b, p, uint64(int64(z)-int64(p)))
			v2 = z
			z++
			*(*int8)(unsafe.Add(unsafe.Pointer(b), int64(v2)-int64(p))) = 0
		} else {
			x_strcpy(tls, b, p)
		}
		x_strcat(tls, b, ts+69)
		x_strcat(tls, b, file)
		if !(x_access(tls, b, int32(m_X_OK)) != 0) {
			return x_execve(tls, b, argv, x____environ)
		}
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
	return -int32(1)
}

const m___NR_fork = 57

func x_fork(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_fork)))
}

const m_EINTR = 4
const m_SIGCHLD = 17
const m_SIGINT = 2
const m_SIGQUIT = 3
const m_SIG_BLOCK = 0
const m_SIG_SETMASK = 2

func x_vfork(tls *TLS) (r int32) {
	/* vfork syscall cannot be made from C code */
	return int32(_syscall0(tls, int64(m___NR_fork)))
}

func x_wait(tls *TLS, status uintptr) (r int32) {
	return x_waitpid(tls, -Int32FromInt32(1), status, 0)
}

const m___NR_waitid = 247

func x_waitid(tls *TLS, type1 int32, id int32, info uintptr, options int32) (r int32) {
	return int32(_syscall5(tls, int64(m___NR_waitid), int64(type1), int64(id), int64(info), int64(options), 0))
}

func x_waitpid(tls *TLS, pid int32, status uintptr, options int32) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_wait4), int64(pid), int64(status), int64(options), 0))
}

const m_FNM_NOESCAPE = 2
const m_FNM_NOMATCH = 1
const m_FNM_PATHNAME = 1
const m_FNM_PERIOD = 4
const m___FNM_CONT = 32768

func _next(tls *TLS, s uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var l int32
	var v1, v2 uintptr
	var _ /* c at bp+0 */ int32
	l = x_mbtowc(tls, bp, *(*uintptr)(unsafe.Pointer(s)), uint64(m_MB_LEN_MAX))
	/* hack to allow literal matches of invalid byte sequences */
	if l < 0 {
		v2 = s
		v1 = *(*uintptr)(unsafe.Pointer(v2))
		*(*uintptr)(unsafe.Pointer(v2))++
		return int32(uint8(*(*int8)(unsafe.Pointer(v1)))) - int32(0x100)
	}
	*(*uintptr)(unsafe.Pointer(s)) += uintptr(l)
	return *(*int32)(unsafe.Pointer(bp))
}

func _bracket_next(tls *TLS, s uintptr) (r int32) {
	var c, type1 int32
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32('[') {
		type1 = int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + UintptrFromInt32(1))))
		if type1 == int32('.') || type1 == int32('=') {
			*(*uintptr)(unsafe.Pointer(s)) += uintptr(2)
			c = _next(tls, s)
			if c <= 0 {
				return -int32(0x100)
			}
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == type1 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + UintptrFromInt32(1)))) == int32(']') {
				*(*uintptr)(unsafe.Pointer(s)) += uintptr(2)
				return c
			}
			for ; *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))) != 0 && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) != type1 || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + UintptrFromInt32(1)))) != int32(']')); *(*uintptr)(unsafe.Pointer(s))++ {
			}
			if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))) != 0) {
				return -int32(0x100)
			}
			*(*uintptr)(unsafe.Pointer(s)) += uintptr(2)
			return -int32(0x101)
		}
	}
	c = _next(tls, s)
	if c <= 0 {
		return -int32(0x100)
	}
	return c
}

func x_fnmatch(tls *TLS, _p uintptr, _s uintptr, flags int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _p
	*(*uintptr)(unsafe.Pointer(bp + 8)) = _s
	var c, d, first, k, match, no_period, no_slash, not, v1, v2, v3 int32
	var class, z, v11, v12, v17, v4 uintptr
	var v16 uint64
	defer func() { x_realloc(tls, class, 0) }()
	if flags&int32(m_FNM_PATHNAME) != 0 {
		v1 = int32('/')
	} else {
		v1 = 0
	}
	no_slash = v1
	if flags&int32(m_FNM_PERIOD) != 0 && !(flags&Int32FromInt32(m___FNM_CONT) != 0) {
		v2 = int32('.')
	} else {
		v2 = int32(0x100)
	}
	no_period = v2
	flags |= int32(m___FNM_CONT)
	for {
		v4 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		v3 = int32(*(*int8)(unsafe.Pointer(v4)))
		c = v3
		if !(v3 != 0) {
			break
		}
		switch c {
		case int32('?'):
			goto _5
		case int32('\\'):
			goto _6
		case int32('*'):
			goto _7
		case int32('['):
			goto _8
		default:
			goto _9
		}
		goto _10
	_5:
		k = _next(tls, bp+8)
		if !(k != 0) || k == no_period || k == no_slash {
			return int32(m_FNM_NOMATCH)
		}
		goto _10
	_6:
		if !(flags&Int32FromInt32(m_FNM_NOESCAPE) != 0) {
			v11 = *(*uintptr)(unsafe.Pointer(bp))
			*(*uintptr)(unsafe.Pointer(bp))++
			c = int32(*(*int8)(unsafe.Pointer(v11)))
			goto literal
		}
		v12 = *(*uintptr)(unsafe.Pointer(bp + 8))
		*(*uintptr)(unsafe.Pointer(bp + 8))++
		if int32(*(*int8)(unsafe.Pointer(v12))) != c {
			return int32(m_FNM_NOMATCH)
		}
		goto _10
	_7:
	_15:
		if !(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('*')) {
			goto _13
		}
		goto _14
	_14:
		*(*uintptr)(unsafe.Pointer(bp))++
		goto _15
		goto _13
	_13:
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 && !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0) {
			return int32(m_FNM_NOMATCH)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == no_period {
			return int32(m_FNM_NOMATCH)
		}
		if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) && (!(no_slash != 0) || !(x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), no_slash) != 0)) {
			return 0
		}
		for ; *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0; *(*uintptr)(unsafe.Pointer(bp + 8))++ {
			if !(x_fnmatch(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(bp + 8)), flags) != 0) {
				return 0
			} else if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == no_slash {
				break
			}
		}
		return int32(m_FNM_NOMATCH)
	_8:
		not = BoolInt32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('!') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('^'))
		if not != 0 {
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		k = _next(tls, bp+8)
		if !(k != 0) || k == no_slash || k == no_period {
			return int32(m_FNM_NOMATCH)
		}
		match = 0
		first = int32(1)
		for {
			if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) {
				return int32(m_FNM_NOMATCH)
			}
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32(']') && !(first != 0) {
				break
			}
			first = 0
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('[') && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + UintptrFromInt32(1)))) == int32(':') {
				*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2)
				for z = *(*uintptr)(unsafe.Pointer(bp)); *(*int8)(unsafe.Pointer(z)) != 0 && (int32(*(*int8)(unsafe.Pointer(z))) != int32(':') || int32(*(*int8)(unsafe.Pointer(z + UintptrFromInt32(1)))) != int32(']')); z++ {
				}
				if !(*(*int8)(unsafe.Pointer(z)) != 0) || int64(z)-int64(*(*uintptr)(unsafe.Pointer(bp))) > int64(32) { /* FIXME: symbolic const? */
					return int32(m_FNM_NOMATCH)
				} else {
					v16 = uint64(int64(z) - int64(*(*uintptr)(unsafe.Pointer(bp))) + int64(1))
					class = x_realloc(tls, class, v16)
					x_memcpy(tls, class, *(*uintptr)(unsafe.Pointer(bp)), uint64(int64(z)-int64(*(*uintptr)(unsafe.Pointer(bp)))))
					*(*int8)(unsafe.Add(unsafe.Pointer(class), int64(z)-int64(*(*uintptr)(unsafe.Pointer(bp))))) = 0
					if x_iswctype(tls, k, x_wctype(tls, class)) != 0 {
						match = int32(1)
					}
				}
				*(*uintptr)(unsafe.Pointer(bp)) = z + uintptr(2)
				continue
			}
			c = _bracket_next(tls, bp)
			if c == -int32(0x100) {
				return int32(m_FNM_NOMATCH)
			}
			if c == -int32(0x101) {
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('-') && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + UintptrFromInt32(1)))) != int32(']') {
				*(*uintptr)(unsafe.Pointer(bp))++
				d = _bracket_next(tls, bp)
				if d == -int32(0x100) {
					return int32(m_FNM_NOMATCH)
				}
				if d == -int32(0x101) {
					continue
				}
				if k >= c && k <= d {
					match = int32(1)
				}
				continue
			}
			if k == c {
				match = int32(1)
			}
		}
		*(*uintptr)(unsafe.Pointer(bp))++
		if not == match {
			return int32(m_FNM_NOMATCH)
		}
		goto _10
	_9:
	literal:
		v17 = *(*uintptr)(unsafe.Pointer(bp + 8))
		*(*uintptr)(unsafe.Pointer(bp + 8))++
		if int32(*(*int8)(unsafe.Pointer(v17))) != c {
			return int32(m_FNM_NOMATCH)
		}
		if c == no_slash && flags&int32(m_FNM_PERIOD) != 0 {
			no_period = int32('.')
			continue
		}
		goto _10
	_10:
		no_period = int32(0x100)
	}
	if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0 {
		return int32(m_FNM_NOMATCH)
	}
	return 0
}

const m_GLOB_ABORTED = 2
const m_GLOB_APPEND = 32
const m_GLOB_DOOFFS = 8
const m_GLOB_ERR = 1
const m_GLOB_MARK = 2
const m_GLOB_NOCHECK = 16
const m_GLOB_NOESCAPE = 64
const m_GLOB_NOMATCH = 3
const m_GLOB_NOSORT = 4
const m_GLOB_NOSPACE = 1

type Tglob_t = struct {
	Fgl_pathc uint64
	Fgl_pathv uintptr
	Fgl_offs  uint64
	F__dummy1 int32
	F__dummy2 [5]uintptr
}

//#define LFS64_2(x, y) weak_alias(x, y)

type Tmatch = struct {
	Fnext        uintptr
	Fname        [1]int8
	F__ccgo_pad2 [7]byte
}

func _is_literal(tls *TLS, p uintptr, useesc int32) (r int32) {
	var bracket int32
	bracket = 0
	for ; *(*int8)(unsafe.Pointer(p)) != 0; p++ {
		switch int32(*(*int8)(unsafe.Pointer(p))) {
		case int32('\\'):
			if !(useesc != 0) {
				break
			}
			fallthrough
		case int32('?'):
			fallthrough
		case int32('*'):
			return 0
		case int32('['):
			bracket = int32(1)
		case int32(']'):
			if bracket != 0 {
				return 0
			}
			break
		}
	}
	return int32(1)
}

func _append(tls *TLS, tail uintptr, name uintptr, len1 uint64, mark int32) (r int32) {
	var new1 uintptr
	new1 = x_malloc(tls, uint64(16)+len1+uint64(1))
	if !(new1 != 0) {
		return -int32(1)
	}
	(*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(tail)))).Fnext = new1
	(*Tmatch)(unsafe.Pointer(new1)).Fnext = UintptrFromInt32(0)
	x_strcpy(tls, new1+8, name)
	if mark != 0 {
		x_strcat(tls, new1+8, ts+69)
	}
	*(*uintptr)(unsafe.Pointer(tail)) = new1
	return 0
}

func _match_in_dir(tls *TLS, d uintptr, p uintptr, flags int32, errfunc uintptr, tail uintptr) (r int32) {
	bp := tls.Alloc(576) /* tlsAllocs 576 maxVaListSize 0 */
	defer tls.Free(576)
	var dir, name, namebuf, p2, pat, v3, v4 uintptr
	var error1, fnm_flags, literal, mark, v2, v5, v6, v8 int32
	var l, v1, v7 uint64
	var _ /* de at bp+280 */ uintptr
	var _ /* de_buf at bp+0 */ [35]int64
	var _ /* st at bp+288 */ Tstat
	var _ /* st at bp+432 */ Tstat
	defer func() { x_realloc(tls, namebuf, 0); x_realloc(tls, pat, 0) }()
	v1 = x_strlen(tls, p) + uint64(1)
	pat = x_realloc(tls, pat, v1)
	l = x_strlen(tls, d)
	if flags&int32(m_GLOB_NOESCAPE) != 0 {
		v2 = int32(m_FNM_NOESCAPE)
	} else {
		v2 = 0
	}
	fnm_flags = v2 | int32(m_FNM_PERIOD)
	v3 = x_strchr(tls, p, int32('/'))
	p2 = v3
	if v3 != 0 {
		x_strcpy(tls, pat, p)
		*(*int8)(unsafe.Add(unsafe.Pointer(pat), int64(p2)-int64(p))) = 0
		for ; int32(*(*int8)(unsafe.Pointer(p2))) == int32('/'); p2++ {
		}
		p = pat
	}
	literal = _is_literal(tls, p, BoolInt32(!(flags&Int32FromInt32(m_GLOB_NOESCAPE) != 0)))
	if int32(*(*int8)(unsafe.Pointer(d))) == int32('/') && !(*(*int8)(unsafe.Pointer(d + UintptrFromInt32(1))) != 0) {
		l = uint64(0)
	}
	/* rely on opendir failing for nondirectory objects */
	if *(*int8)(unsafe.Pointer(d)) != 0 {
		v4 = d
	} else {
		v4 = ts + 154
	}
	dir = x_opendir(tls, v4)
	error1 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if !(dir != 0) {
		/* this is not an error -- we let opendir call stat for us */
		if error1 == int32(m_ENOTDIR) {
			return 0
		}
		if error1 == int32(m_EACCES) && !(*(*int8)(unsafe.Pointer(p)) != 0) {
			if !(x_stat(tls, d, bp+288) != 0) && (*(*Tstat)(unsafe.Pointer(bp + 288))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFDIR) {
				if _append(tls, tail, d, l, int32(l)) != 0 {
					return int32(m_GLOB_NOSPACE)
				}
				return 0
			}
		}
		if (*(*func(*TLS, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{errfunc})))(tls, d, error1) != 0 || flags&int32(m_GLOB_ERR) != 0 {
			return int32(m_GLOB_ABORTED)
		}
		return 0
	}
	if !(*(*int8)(unsafe.Pointer(p)) != 0) {
		if _append(tls, tail, d, l, int32(l)) != 0 {
			v5 = int32(m_GLOB_NOSPACE)
		} else {
			v5 = 0
		}
		error1 = v5
		x_closedir(tls, dir)
		return error1
	}
	for {
		v6 = x_readdir_r(tls, dir, bp, bp+280)
		error1 = v6
		if !(!(v6 != 0) && *(*uintptr)(unsafe.Pointer(bp + 280)) != 0) {
			break
		}
		v7 = l + uint64((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_reclen) + uint64(2)
		namebuf = x_realloc(tls, namebuf, v7)
		name = namebuf
		if !(literal != 0) && x_fnmatch(tls, p, *(*uintptr)(unsafe.Pointer(bp + 280))+19, fnm_flags) != 0 {
			continue
		}
		if literal != 0 && x_strcmp(tls, p, *(*uintptr)(unsafe.Pointer(bp + 280))+19) != 0 {
			continue
		}
		if p2 != 0 && (*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_type != 0 && !(int32((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_type)<<Int32FromInt32(12)&Int32FromInt32(m_S_IFMT) == Int32FromInt32(m_S_IFDIR)) && !(int32((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_type)<<Int32FromInt32(12)&Int32FromInt32(m_S_IFMT) == Int32FromInt32(m_S_IFLNK)) {
			continue
		}
		if *(*int8)(unsafe.Pointer(d)) != 0 {
			x_memcpy(tls, name, d, l)
			*(*int8)(unsafe.Pointer(name + uintptr(l))) = int8('/')
			x_strcpy(tls, name+uintptr(l)+uintptr(1), *(*uintptr)(unsafe.Pointer(bp + 280))+19)
		} else {
			name = *(*uintptr)(unsafe.Pointer(bp + 280)) + 19
		}
		if p2 != 0 {
			v8 = _match_in_dir(tls, name, p2, flags, errfunc, tail)
			error1 = v8
			if v8 != 0 {
				x_closedir(tls, dir)
				return error1
			}
		} else {
			mark = 0
			if flags&int32(m_GLOB_MARK) != 0 {
				if (*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_type != 0 {
					mark = BoolInt32(int32((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_type)<<int32(12)&int32(m_S_IFMT) == int32(m_S_IFDIR))
				} else {
					x_stat(tls, name, bp+432)
					mark = BoolInt32((*(*Tstat)(unsafe.Pointer(bp + 432))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFDIR))
				}
			}
			if _append(tls, tail, name, l+uint64((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).Fd_reclen)+uint64(1), mark) != 0 {
				x_closedir(tls, dir)
				return int32(m_GLOB_NOSPACE)
			}
		}
	}
	x_closedir(tls, dir)
	if error1 != 0 && ((*(*func(*TLS, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{errfunc})))(tls, d, error1) != 0 || flags&int32(m_GLOB_ERR) != 0) {
		return int32(m_GLOB_ABORTED)
	}
	return 0
}

func _ignore_err(tls *TLS, path uintptr, err int32) (r int32) {
	return 0
}

func _freelist(tls *TLS, head uintptr) {
	var match, next uintptr
	for match = (*Tmatch)(unsafe.Pointer(head)).Fnext; match != 0; match = next {
		next = (*Tmatch)(unsafe.Pointer(match)).Fnext
		x_free(tls, match)
	}
}

func _sort(tls *TLS, a uintptr, b uintptr) (r int32) {
	return x_strcmp(tls, *(*uintptr)(unsafe.Pointer(a)), *(*uintptr)(unsafe.Pointer(b)))
}

func x_glob(tls *TLS, pat uintptr, flags int32, errfunc uintptr, g uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var cnt, i, offs, v1 uint64
	var d, p, pathv uintptr
	var error1 int32
	var _ /* head at bp+0 */ Tmatch
	var _ /* tail at bp+16 */ uintptr
	p = pat
	*(*Tmatch)(unsafe.Pointer(bp)) = Tmatch{}
	*(*uintptr)(unsafe.Pointer(bp + 16)) = bp
	if flags&int32(m_GLOB_DOOFFS) != 0 {
		v1 = (*Tglob_t)(unsafe.Pointer(g)).Fgl_offs
	} else {
		v1 = uint64(0)
	}
	offs = v1
	error1 = 0
	if int32(*(*int8)(unsafe.Pointer(p))) == int32('/') {
		for ; int32(*(*int8)(unsafe.Pointer(p))) == int32('/'); p++ {
		}
		d = ts + 69
	} else {
		d = ts
	}
	if !(errfunc != 0) {
		errfunc = __ccgo_fp(_ignore_err)
	}
	if !(flags&Int32FromInt32(m_GLOB_APPEND) != 0) {
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_offs = offs
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc = uint64(0)
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = UintptrFromInt32(0)
	}
	if *(*int8)(unsafe.Pointer(p)) != 0 {
		error1 = _match_in_dir(tls, d, p, flags, errfunc, bp+16)
	}
	if error1 == int32(m_GLOB_NOSPACE) {
		_freelist(tls, bp)
		return error1
	}
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = (*(*Tmatch)(unsafe.Pointer(bp))).Fnext
	for *(*uintptr)(unsafe.Pointer(bp + 16)) != 0 {
		goto _2
	_2:
		*(*uintptr)(unsafe.Pointer(bp + 16)) = (*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fnext
		cnt++
	}
	if !(cnt != 0) {
		if flags&int32(m_GLOB_NOCHECK) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 16)) = bp
			if _append(tls, bp+16, pat, x_strlen(tls, pat), 0) != 0 {
				return int32(m_GLOB_NOSPACE)
			}
			cnt++
		} else {
			return int32(m_GLOB_NOMATCH)
		}
	}
	if flags&int32(m_GLOB_APPEND) != 0 {
		pathv = x_realloc(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv, (offs+(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc+cnt+uint64(1))*uint64(8))
		if !(pathv != 0) {
			_freelist(tls, bp)
			return int32(m_GLOB_NOSPACE)
		}
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = pathv
		offs += (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc
	} else {
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = x_malloc(tls, (offs+cnt+uint64(1))*uint64(8))
		if !((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv != 0) {
			_freelist(tls, bp)
			return int32(m_GLOB_NOSPACE)
		}
		for i = uint64(0); i < offs; i++ {
			*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(i)*8)) = UintptrFromInt32(0)
		}
	}
	i = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = (*(*Tmatch)(unsafe.Pointer(bp))).Fnext
	for i < cnt {
		*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(offs+i)*8)) = *(*uintptr)(unsafe.Pointer(bp + 16)) + 8
		goto _3
	_3:
		*(*uintptr)(unsafe.Pointer(bp + 16)) = (*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fnext
		i++
	}
	*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(offs+i)*8)) = UintptrFromInt32(0)
	*(*uint64)(unsafe.Pointer(g)) += cnt
	if !(flags&Int32FromInt32(m_GLOB_NOSORT) != 0) {
		x_qsort(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv+uintptr(offs)*8, cnt, uint64(8), __ccgo_fp(_sort))
	}
	return error1
}

func x_globfree(tls *TLS, g uintptr) {
	var i uint64
	for i = uint64(0); i < (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc; i++ {
		x_free(tls, *(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr((*Tglob_t)(unsafe.Pointer(g)).Fgl_offs+i)*8))-uintptr(uint64(int64(UintptrFromInt32(0)+8)-int64(UintptrFromInt32(0)))))
	}
	x_free(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv)
	(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc = uint64(0)
	(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = UintptrFromInt32(0)
}

const m_ASSERT_AT_BOL = 1
const m_ASSERT_AT_EOL = 2
const m_ASSERT_BACKREF = 256
const m_ASSERT_CHAR_CLASS = 4
const m_ASSERT_CHAR_CLASS_NEG = 8
const m_COPY_MAXIMIZE_FIRST_TAG = 2
const m_COPY_REMOVE_TAGS = 1
const m_MAX_NEG_CLASSES = 64
const m_REG_BADBR = 10
const m_REG_BADPAT = 2
const m_REG_EBRACE = 9
const m_REG_EBRACK = 7
const m_REG_ECOLLATE = 3
const m_REG_ECTYPE = 4
const m_REG_EESCAPE = 5
const m_REG_EPAREN = 8
const m_REG_ERANGE = 11
const m_REG_ESPACE = 12
const m_REG_EXTENDED = 1
const m_REG_ICASE = 2
const m_REG_NEWLINE = 4
const m_REG_NOSUB = 8
const m_REG_OK = 0
const m_tre_mem_alloc_impl = 0
const m_tre_mem_new_impl = 0

type Tregoff_t = int64

type Tregex_t = struct {
	Fre_nsub  uint64
	F__opaque uintptr
}

type Tregmatch_t = struct {
	Frm_so int64
	Frm_eo int64
}

type Treg_errcode_t = int32

type Ttre_char_t = int32

type Ttre_cint_t = int32

type Ttre_ctype_t = int32

type Ttre_tnfa_transition_t = struct {
	Fcode_min   int32
	Fcode_max   int32
	Fstate      uintptr
	Fstate_id   int32
	Ftags       uintptr
	Fassertions int32
	Fu          struct {
		Fbackref [0]int32
		Fclass   int32
	}
	Fneg_classes uintptr
}

type Ttnfa_transition = Ttre_tnfa_transition_t

type Ttre_tag_direction_t = int32

const _TRE_TAG_MINIMIZE = 0
const _TRE_TAG_MAXIMIZE = 1

type Ttre_submatch_data = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_submatch_data_t = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_tnfa_t = struct {
	Ftransitions     uintptr
	Fnum_transitions uint32
	Finitial         uintptr
	Ffinal           uintptr
	Fsubmatch_data   uintptr
	Fnum_submatches  uint32
	Ftag_directions  uintptr
	Fnum_tags        int32
	Fend_tag         int32
	Fnum_states      int32
	Fcflags          int32
	Fhave_backrefs   int32
}

type Ttnfa = Ttre_tnfa_t

type Ttre_list_t = struct {
	Fdata uintptr
	Fnext uintptr
}

type Ttre_list = Ttre_list_t

type Ttre_mem_t = uintptr

type Ttre_mem_struct = struct {
	Fblocks   uintptr
	Fcurrent  uintptr
	Fptr      uintptr
	Fn        uint64
	Ffailed   int32
	Fprovided uintptr
}

/***********************************************************************
 from tre-ast.c and tre-ast.h
***********************************************************************/

/* The different AST node types. */

type Ttre_ast_type_t = int32

const _LITERAL = 0
const _CATENATION = 1
const _ITERATION = 2
const _UNION = 3

/* Special subtypes of TRE_LITERAL. */

/* Taken from tre-compile.h */

type Ttre_pos_and_tags_t = struct {
	Fposition    int32
	Fcode_min    int32
	Fcode_max    int32
	Ftags        uintptr
	Fassertions  int32
	Fclass       int32
	Fneg_classes uintptr
	Fbackref     int32
	F__ccgo_pad8 [4]byte
}

/* A generic AST node.  All AST nodes consist of this node on the top
   level with `obj' pointing to the actual content. */

type Ttre_ast_node_t = struct {
	Ftype1          int32
	Fobj            uintptr
	Fnullable       int32
	Fsubmatch_id    int32
	Fnum_submatches int32
	Fnum_tags       int32
	Ffirstpos       uintptr
	Flastpos        uintptr
}

/* A "literal" node.  These are created for assertions, back references,
   tags, matching parameter settings, and all expressions that match one
   character. */

type Ttre_literal_t = struct {
	Fcode_min    int64
	Fcode_max    int64
	Fposition    int32
	Fclass       int32
	Fneg_classes uintptr
}

/* A "catenation" node.	 These are created when two regexps are concatenated.
   If there are more than one subexpressions in sequence, the `left' part
   holds all but the last, and `right' part holds the last subexpression
   (catenation is left associative). */

type Ttre_catenation_t = struct {
	Fleft  uintptr
	Fright uintptr
}

/* An "iteration" node.	 These are created for the "*", "+", "?", and "{m,n}"
   operators. */

type Ttre_iteration_t = struct {
	Farg uintptr
	Fmin int32
	Fmax int32
}

/* An "union" node.  These are created for the "|" operator. */

type Ttre_union_t = struct {
	Fleft  uintptr
	Fright uintptr
}

func _tre_ast_new_node(tls *TLS, mem uintptr, type1 int32, size uint64) (r uintptr) {
	var node uintptr
	node = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(48))
	if !(node != 0) {
		return UintptrFromInt32(0)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), size)
	if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj != 0) {
		return UintptrFromInt32(0)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = type1
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id = -int32(1)
	return node
}

func _tre_ast_new_literal(tls *TLS, mem uintptr, code_min int32, code_max int32, position int32) (r uintptr) {
	var lit, node uintptr
	node = _tre_ast_new_node(tls, mem, int32(_LITERAL), uint64(32))
	if !(node != 0) {
		return UintptrFromInt32(0)
	}
	lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(code_min)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(code_max)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = position
	return node
}

func _tre_ast_new_iter(tls *TLS, mem uintptr, arg uintptr, min int32, max int32) (r uintptr) {
	var iter, node uintptr
	node = _tre_ast_new_node(tls, mem, int32(_ITERATION), uint64(16))
	if !(node != 0) {
		return UintptrFromInt32(0)
	}
	iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg = arg
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin = min
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax = max
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(arg)).Fnum_submatches
	return node
}

func _tre_ast_new_union(tls *TLS, mem uintptr, left uintptr, right uintptr) (r uintptr) {
	var node uintptr
	node = _tre_ast_new_node(tls, mem, int32(_UNION), uint64(16))
	if node == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft = left
	(*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

func _tre_ast_new_catenation(tls *TLS, mem uintptr, left uintptr, right uintptr) (r uintptr) {
	var node uintptr
	node = _tre_ast_new_node(tls, mem, int32(_CATENATION), uint64(16))
	if node == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft = left
	(*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

/***********************************************************************
 from tre-stack.c and tre-stack.h
***********************************************************************/

/* Just to save some typing. */

type Ttre_stack_t = struct {
	Fsize      int32
	Fmax_size  int32
	Fincrement int32
	Fptr       int32
	Fstack     uintptr
}

type Ttre_stack_rec = Ttre_stack_t

func _tre_stack_new(tls *TLS, size int32, max_size int32, increment int32) (r uintptr) {
	var s uintptr
	s = x_malloc(tls, uint64(24))
	if s != UintptrFromInt32(0) {
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = x_malloc(tls, uint64(8)*uint64(size))
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack == UintptrFromInt32(0) {
			x_free(tls, s)
			return UintptrFromInt32(0)
		}
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size = max_size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement = increment
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr = 0
	}
	return s
}

func _tre_stack_destroy(tls *TLS, s uintptr) {
	x_free(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack)
	x_free(tls, s)
}

func _tre_stack_num_objects(tls *TLS, s uintptr) (r int32) {
	return (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr
}

func _tre_stack_push(tls *TLS, s uintptr, value uintptr) (r int32) {
	var new_buffer uintptr
	var new_size int32
	var v1 bool
	if (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr < (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize {
		*(*uintptr)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr((*Ttre_stack_t)(unsafe.Pointer(s)).Fptr)*8)) = value
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr++
	} else {
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize >= (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
			return int32(m_REG_ESPACE)
		} else {
			new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize + (*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement
			if new_size > (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
				new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size
			}
			new_buffer = x_realloc(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack, uint64(8)*uint64(new_size))
			if new_buffer == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			if v1 = new_size > (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize; !v1 {
				x___assert_fail(tls, ts+523, ts+542, int32(305), uintptr(unsafe.Pointer(&___func__)))
			}
			_ = v1 || Int32FromInt32(0) != 0
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = new_size
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = new_buffer
			_tre_stack_push(tls, s, value)
		}
	}
	return m_REG_OK
}

var ___func__ = [15]int8{'t', 'r', 'e', '_', 's', 't', 'a', 'c', 'k', '_', 'p', 'u', 's', 'h'}

func _tre_stack_pop(tls *TLS, s uintptr) (r uintptr) {
	var v1 int32
	var v2 uintptr
	v2 = s + 12
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	return *(*uintptr)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr(v1)*8))
}

/***********************************************************************
 from tre-parse.c and tre-parse.h
***********************************************************************/

/* Parse context. */

type Ttre_parse_ctx_t = struct {
	Fmem         uintptr
	Fstack       uintptr
	Fresult      uintptr
	Fre          uintptr
	Fre_start    uintptr
	Fre_end      uintptr
	Flen1        int32
	Fsubmatch_id int32
	Fposition    int32
	Fmax_backref int32
	Fcflags      int32
	Fnofirstsub  int32
}

func _tre_new_item(tls *TLS, mem uintptr, min int32, max int32, i uintptr, max_i uintptr, items uintptr) (r int32) {
	var array, new_items, v1 uintptr
	var status, v2 int32
	array = *(*uintptr)(unsafe.Pointer(items))
	/* Allocate more space if necessary. */
	if *(*int32)(unsafe.Pointer(i)) >= *(*int32)(unsafe.Pointer(max_i)) {
		/* If the array is already 1024 items large, give up -- there's
		probably an error in the regexp (e.g. not a '\0' terminated
		string and missing ']') */
		if *(*int32)(unsafe.Pointer(max_i)) > int32(1024) {
			return int32(m_REG_ESPACE)
		}
		*(*int32)(unsafe.Pointer(max_i)) *= int32(2)
		new_items = x_realloc(tls, array, uint64(8)*uint64(*(*int32)(unsafe.Pointer(max_i))))
		if new_items == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
		v1 = new_items
		array = v1
		*(*uintptr)(unsafe.Pointer(items)) = v1
	}
	*(*uintptr)(unsafe.Pointer(array + uintptr(*(*int32)(unsafe.Pointer(i)))*8)) = _tre_ast_new_literal(tls, mem, min, max, -int32(1))
	if *(*uintptr)(unsafe.Pointer(array + uintptr(*(*int32)(unsafe.Pointer(i)))*8)) == UintptrFromInt32(0) {
		v2 = int32(m_REG_ESPACE)
	} else {
		v2 = m_REG_OK
	}
	status = v2
	*(*int32)(unsafe.Pointer(i))++
	return status
}

// C documentation
//
//	/* Expands a character class to character ranges. */
func _tre_expand_ctype(tls *TLS, mem uintptr, class int32, items uintptr, i uintptr, max_i uintptr, cflags int32) (r int32) {
	var c, j, max, min, status int32
	var v1 bool
	status = m_REG_OK
	min = -int32(1)
	max = 0
	if v1 = uint64(+Int32FromInt32(4)) == uint64(1); !v1 {
		x___assert_fail(tls, ts+562, ts+542, int32(389), uintptr(unsafe.Pointer(&___func__1)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	for j = 0; j < int32(256) && status == m_REG_OK; j++ {
		c = j
		if x_iswctype(tls, c, class) != 0 || cflags&int32(m_REG_ICASE) != 0 && (x_iswctype(tls, x_towlower(tls, c), class) != 0 || x_iswctype(tls, x_towupper(tls, c), class) != 0) {
			if min < 0 {
				min = c
			}
			max = c
		} else if min >= 0 {
			status = _tre_new_item(tls, mem, min, max, i, max_i, items)
			min = -int32(1)
		}
	}
	if min >= 0 && status == m_REG_OK {
		status = _tre_new_item(tls, mem, min, max, i, max_i, items)
	}
	return status
}

var ___func__1 = [17]int8{'t', 'r', 'e', '_', 'e', 'x', 'p', 'a', 'n', 'd', '_', 'c', 't', 'y', 'p', 'e'}

func _tre_compare_items(tls *TLS, a uintptr, b uintptr) (r int32) {
	var a_min, b_min int32
	var l_a, l_b, node_a, node_b uintptr
	node_a = *(*uintptr)(unsafe.Pointer(a))
	node_b = *(*uintptr)(unsafe.Pointer(b))
	l_a = (*Ttre_ast_node_t)(unsafe.Pointer(node_a)).Fobj
	l_b = (*Ttre_ast_node_t)(unsafe.Pointer(node_b)).Fobj
	a_min = int32((*Ttre_literal_t)(unsafe.Pointer(l_a)).Fcode_min)
	b_min = int32((*Ttre_literal_t)(unsafe.Pointer(l_b)).Fcode_min)
	if a_min < b_min {
		return -int32(1)
	} else {
		if a_min > b_min {
			return int32(1)
		} else {
			return 0
		}
	}
	return r
}

func _tre_parse_bracket_items(tls *TLS, ctx uintptr, negate int32, neg_classes uintptr, num_neg_classes uintptr, items uintptr, num_items uintptr, items_size uintptr) (r int32) {
	bp := tls.Alloc(328) /* tlsAllocs 328 maxVaListSize 0 */
	defer tls.Free(328)
	var ccurr, class, cmin, len1, max, min, skip, status, v10, v11, v2, v4, v6, v7, v8, v9 int32
	var endptr, re, v3, v5 uintptr
	var v1 int64
	var _ /* i at bp+0 */ int32
	var _ /* max_i at bp+4 */ int32
	var _ /* tmp_str at bp+8 */ [64]int8
	var _ /* tmp_wcs at bp+72 */ [64]int32
	re = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre
	status = m_REG_OK
	class = Int32FromInt32(0)
	*(*int32)(unsafe.Pointer(bp)) = *(*int32)(unsafe.Pointer(num_items))
	*(*int32)(unsafe.Pointer(bp + 4)) = *(*int32)(unsafe.Pointer(items_size))
	/* Build an array of the items in the bracket expression. */
	for status == m_REG_OK {
		skip = 0
		if re == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			status = int32(m_REG_EBRACK)
		} else {
			if *(*int32)(unsafe.Pointer(re)) == int32(']') && re > (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre {
				re += 4
				break
			} else {
				min = 0
				max = 0
				class = Int32FromInt32(0)
				if re+uintptr(2)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(1)*4)) == int32('-') && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(2)*4)) != int32(']') {
					min = *(*int32)(unsafe.Pointer(re))
					max = *(*int32)(unsafe.Pointer(re + UintptrFromInt32(2)*4))
					re += uintptr(3) * 4
					/* XXX - Should use collation order instead of encoding values
					in character ranges. */
					if min > max {
						status = int32(m_REG_ERANGE)
					}
				} else {
					if re+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(re)) == int32('[') && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(1)*4)) == int32('.') {
						status = int32(m_REG_ECOLLATE)
					} else {
						if re+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(re)) == int32('[') && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(1)*4)) == int32('=') {
							status = int32(m_REG_ECOLLATE)
						} else {
							if re+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(re)) == int32('[') && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(1)*4)) == int32(':') {
								endptr = re + uintptr(2)*4
								for endptr < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(endptr)) != int32(':') {
									endptr += 4
								}
								if endptr != (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
									if (int64(endptr)-int64(re))/4-int64(2) <= int64(Int32FromInt32(63)) {
										v1 = (int64(endptr)-int64(re))/4 - int64(2)
									} else {
										v1 = int64(Int32FromInt32(63))
									}
									len1 = int32(v1)
									{
										x_wcsncpy(tls, bp+72, re+uintptr(2)*4, uint64(len1))
										(*(*[64]int32)(unsafe.Pointer(bp + 72)))[len1] = int32('\000')
										len1 = int32(x_wcstombs(tls, bp+8, bp+72, uint64(63)))
									}
									(*(*[64]int8)(unsafe.Pointer(bp + 8)))[len1] = int8('\000')
									class = x_wctype(tls, bp+8)
									if !(class != 0) {
										status = int32(m_REG_ECTYPE)
									}
									/* Optimize character classes for 8 bit character sets. */
									if status == m_REG_OK && uint64(+Int32FromInt32(4)) == uint64(1) {
										status = _tre_expand_ctype(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, class, items, bp, bp+4, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags)
										class = Int32FromInt32(0)
										skip = int32(1)
									}
									re = endptr + uintptr(2)*4
								} else {
									status = int32(m_REG_ECTYPE)
								}
								min = 0
								max = Int32FromInt32(0x7fffffff)
							} else {
								if *(*int32)(unsafe.Pointer(re)) == int32('-') && *(*int32)(unsafe.Pointer(re + UintptrFromInt32(1)*4)) != int32(']') && (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre != re {
									/* Two ranges are not allowed to share and endpoint. */
									status = int32(m_REG_ERANGE)
								}
								v3 = re
								re += 4
								v2 = *(*int32)(unsafe.Pointer(v3))
								max = v2
								min = v2
							}
						}
					}
				}
				if status != m_REG_OK {
					break
				}
				if class != 0 && negate != 0 {
					if *(*int32)(unsafe.Pointer(num_neg_classes)) >= int32(m_MAX_NEG_CLASSES) {
						status = int32(m_REG_ESPACE)
					} else {
						v5 = num_neg_classes
						v4 = *(*int32)(unsafe.Pointer(v5))
						*(*int32)(unsafe.Pointer(v5))++
						*(*int32)(unsafe.Pointer(neg_classes + uintptr(v4)*4)) = class
					}
				} else if !(skip != 0) {
					status = _tre_new_item(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, min, max, bp, bp+4, items)
					if status != m_REG_OK {
						break
					}
					(*Ttre_literal_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(items)) + uintptr(*(*int32)(unsafe.Pointer(bp))-int32(1))*8)))).Fobj)).Fclass = class
				}
				/* Add opposite-case counterpoints if REG_ICASE is present.
				   This is broken if there are more than two "same" characters. */
				if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_ICASE) != 0 && !(class != 0) && status == m_REG_OK && !(skip != 0) {
					for min <= max {
						if x_iswlower(tls, min) != 0 {
							v7 = min
							min++
							v6 = x_towupper(tls, v7)
							ccurr = v6
							cmin = v6
							for x_iswlower(tls, min) != 0 && x_towupper(tls, min) == ccurr+int32(1) && min <= max {
								v8 = min
								min++
								ccurr = x_towupper(tls, v8)
							}
							status = _tre_new_item(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, cmin, ccurr, bp, bp+4, items)
						} else {
							if x_iswupper(tls, min) != 0 {
								v10 = min
								min++
								v9 = x_towlower(tls, v10)
								ccurr = v9
								cmin = v9
								for x_iswupper(tls, min) != 0 && x_towlower(tls, min) == ccurr+int32(1) && min <= max {
									v11 = min
									min++
									ccurr = x_towlower(tls, v11)
								}
								status = _tre_new_item(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, cmin, ccurr, bp, bp+4, items)
							} else {
								min++
							}
						}
						if status != m_REG_OK {
							break
						}
					}
					if status != m_REG_OK {
						break
					}
				}
			}
		}
	}
	*(*int32)(unsafe.Pointer(num_items)) = *(*int32)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(items_size)) = *(*int32)(unsafe.Pointer(bp + 4))
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre = re
	return status
}

func _tre_parse_bracket(tls *TLS, ctx uintptr, result uintptr) (r int32) {
	bp := tls.Alloc(280) /* tlsAllocs 280 maxVaListSize 0 */
	defer tls.Free(280)
	var curr_max, curr_min, j, k, k1, max, min, negate, status, v1, v2, v3 int32
	var l, l1, n, node, u uintptr
	var _ /* i at bp+8 */ int32
	var _ /* items at bp+0 */ uintptr
	var _ /* max_i at bp+12 */ int32
	var _ /* neg_classes at bp+16 */ [64]int32
	var _ /* num_neg_classes at bp+272 */ int32
	node = UintptrFromInt32(0)
	negate = 0
	status = m_REG_OK
	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	*(*int32)(unsafe.Pointer(bp + 12)) = int32(32)
	*(*int32)(unsafe.Pointer(bp + 272)) = 0
	/* Start off with an array of `max_i' elements. */
	*(*uintptr)(unsafe.Pointer(bp)) = x_malloc(tls, uint64(8)*uint64(*(*int32)(unsafe.Pointer(bp + 12))))
	if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	if *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('^') {
		negate = int32(1)
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
	}
	status = _tre_parse_bracket_items(tls, ctx, negate, bp+16, bp+272, bp, bp+8, bp+12)
	if status != m_REG_OK {
		goto parse_bracket_done
	}
	/* Sort the array if we need to negate it. */
	if negate != 0 {
		x_qsort(tls, *(*uintptr)(unsafe.Pointer(bp)), uint64(*(*int32)(unsafe.Pointer(bp + 8))), uint64(8), __ccgo_fp(_tre_compare_items))
	}
	v1 = Int32FromInt32(0)
	curr_min = v1
	curr_max = v1
	/* Build a union of the items in the array, negated if necessary. */
	for j = 0; j < *(*int32)(unsafe.Pointer(bp + 8)) && status == m_REG_OK; j++ {
		l = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(j)*8)))).Fobj
		min = int32((*Ttre_literal_t)(unsafe.Pointer(l)).Fcode_min)
		max = int32((*Ttre_literal_t)(unsafe.Pointer(l)).Fcode_max)
		if negate != 0 {
			if min < curr_max {
				/* Overlap. */
				if max+int32(1) >= curr_max {
					v2 = max + int32(1)
				} else {
					v2 = curr_max
				}
				curr_max = v2
				l = UintptrFromInt32(0)
			} else {
				/* No overlap. */
				curr_max = min - int32(1)
				if curr_max >= curr_min {
					(*Ttre_literal_t)(unsafe.Pointer(l)).Fcode_min = int64(curr_min)
					(*Ttre_literal_t)(unsafe.Pointer(l)).Fcode_max = int64(curr_max)
				} else {
					l = UintptrFromInt32(0)
				}
				v3 = max + Int32FromInt32(1)
				curr_max = v3
				curr_min = v3
			}
		}
		if l != UintptrFromInt32(0) {
			(*Ttre_literal_t)(unsafe.Pointer(l)).Fposition = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition
			if *(*int32)(unsafe.Pointer(bp + 272)) > 0 {
				(*Ttre_literal_t)(unsafe.Pointer(l)).Fneg_classes = x___tre_mem_alloc_impl(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, UintptrFromInt32(0), 0, Uint64FromInt64(8)*uint64(*(*int32)(unsafe.Pointer(bp + 272))+Int32FromInt32(1)))
				if (*Ttre_literal_t)(unsafe.Pointer(l)).Fneg_classes == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				for k = 0; k < *(*int32)(unsafe.Pointer(bp + 272)); k++ {
					*(*int32)(unsafe.Pointer((*Ttre_literal_t)(unsafe.Pointer(l)).Fneg_classes + uintptr(k)*4)) = (*(*[64]int32)(unsafe.Pointer(bp + 16)))[k]
				}
				*(*int32)(unsafe.Pointer((*Ttre_literal_t)(unsafe.Pointer(l)).Fneg_classes + uintptr(k)*4)) = Int32FromInt32(0)
			} else {
				(*Ttre_literal_t)(unsafe.Pointer(l)).Fneg_classes = UintptrFromInt32(0)
			}
			if node == UintptrFromInt32(0) {
				node = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(j)*8))
			} else {
				u = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, node, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(j)*8)))
				if u == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
				}
				node = u
			}
		}
	}
	if status != m_REG_OK {
		goto parse_bracket_done
	}
	if negate != 0 {
		n = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, curr_min, int32(0x7fffffff), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
		if n == UintptrFromInt32(0) {
			status = int32(m_REG_ESPACE)
		} else {
			l1 = (*Ttre_ast_node_t)(unsafe.Pointer(n)).Fobj
			if *(*int32)(unsafe.Pointer(bp + 272)) > 0 {
				(*Ttre_literal_t)(unsafe.Pointer(l1)).Fneg_classes = x___tre_mem_alloc_impl(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, UintptrFromInt32(0), 0, Uint64FromInt64(8)*uint64(*(*int32)(unsafe.Pointer(bp + 272))+Int32FromInt32(1)))
				if (*Ttre_literal_t)(unsafe.Pointer(l1)).Fneg_classes == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					goto parse_bracket_done
				}
				for k1 = 0; k1 < *(*int32)(unsafe.Pointer(bp + 272)); k1++ {
					*(*int32)(unsafe.Pointer((*Ttre_literal_t)(unsafe.Pointer(l1)).Fneg_classes + uintptr(k1)*4)) = (*(*[64]int32)(unsafe.Pointer(bp + 16)))[k1]
				}
				*(*int32)(unsafe.Pointer((*Ttre_literal_t)(unsafe.Pointer(l1)).Fneg_classes + uintptr(k1)*4)) = Int32FromInt32(0)
			} else {
				(*Ttre_literal_t)(unsafe.Pointer(l1)).Fneg_classes = UintptrFromInt32(0)
			}
			if node == UintptrFromInt32(0) {
				node = n
			} else {
				u = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, node, n)
				if u == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
				}
				node = u
			}
		}
	}
	if status != m_REG_OK {
		goto parse_bracket_done
	}
parse_bracket_done:
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
	*(*uintptr)(unsafe.Pointer(result)) = node
	return status
}

// C documentation
//
//	/* Parses a positive decimal integer.  Returns -1 if the string does not
//	   contain a valid number. */
func _tre_parse_int(tls *TLS, regex uintptr, regex_end uintptr) (r1 int32) {
	var num int32
	var r uintptr
	num = -int32(1)
	r = *(*uintptr)(unsafe.Pointer(regex))
	for r < regex_end && *(*int32)(unsafe.Pointer(r)) >= int32('0') && *(*int32)(unsafe.Pointer(r)) <= int32('9') {
		if num < 0 {
			num = 0
		}
		num = num*int32(10) + *(*int32)(unsafe.Pointer(r)) - int32('0')
		r += 4
	}
	*(*uintptr)(unsafe.Pointer(regex)) = r
	return num
}

func _tre_parse_bound(tls *TLS, ctx uintptr, result uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var counts_set, done, max, min, v1 int32
	var start uintptr
	var _ /* r at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre
	counts_set = 0
	/* Parse number (minimum repetition count). */
	min = -int32(1)
	if *(*uintptr)(unsafe.Pointer(bp)) < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) >= int32('0') && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) <= int32('9') {
		min = _tre_parse_int(tls, bp, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end)
	}
	/* Parse comma and second number (maximum repetition count). */
	max = min
	if *(*uintptr)(unsafe.Pointer(bp)) < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) == int32(',') {
		*(*uintptr)(unsafe.Pointer(bp)) += 4
		max = _tre_parse_int(tls, bp, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end)
	}
	/* Check that the repeat counts are sane. */
	if max >= 0 && min > max || max > int32(m_RE_DUP_MAX) {
		return int32(m_REG_BADBR)
	}
	/*
	   '{'
	     optionally followed immediately by a number == minimum repcount
	     optionally followed by , then a number == maximum repcount
	*/
	for cond := true; cond; cond = start != *(*uintptr)(unsafe.Pointer(bp)) {
		start = *(*uintptr)(unsafe.Pointer(bp))
		/* Parse count limit settings */
		done = 0
		if !(counts_set != 0) {
			for *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && !(done != 0) {
				switch *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) {
				case int32(','):
					*(*uintptr)(unsafe.Pointer(bp)) += 4
				case int32(' '):
					*(*uintptr)(unsafe.Pointer(bp)) += 4
				case int32('}'):
					done = int32(1)
				default:
					done = int32(1)
					break
				}
			}
		}
	}
	/* Missing }. */
	if *(*uintptr)(unsafe.Pointer(bp)) >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
		return int32(m_REG_EBRACE)
	}
	/* Empty contents of {}. */
	if *(*uintptr)(unsafe.Pointer(bp)) == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre {
		return int32(m_REG_BADBR)
	}
	/* Parse the ending '}' or '\}'.*/
	if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 {
		if *(*uintptr)(unsafe.Pointer(bp)) >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end || *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != int32('}') {
			return int32(m_REG_BADBR)
		}
		*(*uintptr)(unsafe.Pointer(bp)) += 4
	} else {
		if *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4 >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end || *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != int32('\\') || *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + UintptrFromInt32(1)*4)) != int32('}') {
			return int32(m_REG_BADBR)
		}
		*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2) * 4
	}
	/* Create the AST node(s). */
	if min == 0 && max == 0 {
		*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
		if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
	} else {
		if min < 0 && max < 0 {
			/* Only approximate parameters set, no repetitions. */
			v1 = Int32FromInt32(1)
			max = v1
			min = v1
		}
		*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_iter(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, *(*uintptr)(unsafe.Pointer(result)), min, max)
		if !(*(*uintptr)(unsafe.Pointer(result)) != 0) {
			return int32(m_REG_ESPACE)
		}
	}
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre = *(*uintptr)(unsafe.Pointer(bp))
	return m_REG_OK
}

type Ttre_parse_re_stack_symbol_t = int32

const _PARSE_RE = 0
const _PARSE_ATOM = 1
const _PARSE_MARK_FOR_SUBMATCH = 2
const _PARSE_BRANCH = 3
const _PARSE_PIECE = 4
const _PARSE_CATENATION = 5
const _PARSE_POST_CATENATION = 6
const _PARSE_UNION = 7
const _PARSE_POST_UNION = 8
const _PARSE_POSTFIX = 9
const _PARSE_RESTORE_CFLAGS = 10

func _tre_parse(tls *TLS, ctx uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var bottom, c, depth, rep_max, rep_min, status, submatch_id, symbol, val, v34 int32
	var n, stack, tmp1, tmp11, tmp2, tmp21, tmp_node, tmp_node1, tmp_node2, tmp_node3, tree, tree1 uintptr
	var _ /* result at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = UintptrFromInt32(0)
	status = m_REG_OK
	stack = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstack
	bottom = _tre_stack_num_objects(tls, stack)
	depth = 0
	if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fnofirstsub != 0) {
		status = _tre_stack_push(tls, stack, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)
		status = _tre_stack_push(tls, stack, uintptr((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id))
		status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_MARK_FOR_SUBMATCH)))
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id++
	}
	status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_RE)))
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_start = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + uintptr((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Flen1)*4
	/* The following is basically just a recursive descent parser.  I use
	   an explicit stack instead of recursive functions mostly because of
	   two reasons: compatibility with systems which have an overflowable
	   call stack, and efficiency (both in lines of code and speed).  */
	for _tre_stack_num_objects(tls, stack) > bottom && status == m_REG_OK {
		if status != m_REG_OK {
			break
		}
		symbol = int32(_tre_stack_pop(tls, stack))
		switch symbol {
		case int32(_PARSE_RE):
			goto _1
		case int32(_PARSE_BRANCH):
			goto _2
		case int32(_PARSE_PIECE):
			goto _3
		case int32(_PARSE_CATENATION):
			goto _4
		case int32(_PARSE_POST_CATENATION):
			goto _5
		case int32(_PARSE_UNION):
			goto _6
		case int32(_PARSE_POST_UNION):
			goto _7
		case int32(_PARSE_POSTFIX):
			goto _8
		case int32(_PARSE_ATOM):
			goto _9
		case int32(_PARSE_MARK_FOR_SUBMATCH):
			goto _10
		case int32(_PARSE_RESTORE_CFLAGS):
			goto _11
		}
		goto _12
	_1:
		/* Parse a full regexp.  A regexp is one or more branches,
		   separated by the union operator `|'. */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 {
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_UNION)))
			if status != m_REG_OK {
				goto _12
			}
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_BRANCH)))
			if status != m_REG_OK {
				goto _12
			}
		}
		goto _12
	_2:
		status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_CATENATION)))
		if status != m_REG_OK {
			goto _12
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_PIECE)))
			if status != m_REG_OK {
				goto _12
			}
		}
		goto _12
	_3:
		status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_POSTFIX)))
		if status != m_REG_OK {
			goto _12
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_ATOM)))
			if status != m_REG_OK {
				goto _12
			}
		}
		goto _12
	_4:
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			goto _12
		}
		c = *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 && c == int32('|') {
			goto _12
		}
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 && c == int32(')') && depth > 0 || !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && (c == int32('\\') && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32(')')) {
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && depth == 0 {
				status = int32(m_REG_EPAREN)
			}
			depth--
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) {
				*(*uintptr)(unsafe.Pointer(ctx + 24)) += uintptr(2) * 4
			}
			goto _12
		}
		{
			/* Left associative concatenation. */
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_CATENATION)))
			if status != m_REG_OK {
				goto _12
			}
		}
		{
			status = _tre_stack_push(tls, stack, *(*uintptr)(unsafe.Pointer(bp)))
			if status != m_REG_OK {
				goto _12
			}
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_POST_CATENATION)))
			if status != m_REG_OK {
				goto _12
			}
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_PIECE)))
			if status != m_REG_OK {
				goto _12
			}
		}
		goto _12
	_5:
		tree = _tre_stack_pop(tls, stack)
		tmp_node = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tree, *(*uintptr)(unsafe.Pointer(bp)))
		if !(tmp_node != 0) {
			return int32(m_REG_ESPACE)
		}
		*(*uintptr)(unsafe.Pointer(bp)) = tmp_node
		goto _12
	_6:
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			goto _12
		}
		switch *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) {
		case int32('|'):
			goto _13
		case int32(')'):
			goto _14
		default:
			goto _15
		}
		goto _16
	_13:
	_18:
		if 0 != 0 {
			goto _18
		}
		goto _17
	_17:
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_UNION)))
			if status != m_REG_OK {
				goto _16
			}
		}
		{
			status = _tre_stack_push(tls, stack, *(*uintptr)(unsafe.Pointer(bp)))
			if status != m_REG_OK {
				goto _16
			}
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_POST_UNION)))
			if status != m_REG_OK {
				goto _16
			}
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_BRANCH)))
			if status != m_REG_OK {
				goto _16
			}
		}
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		goto _16
	_14:
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		goto _16
	_15:
		goto _16
	_16:
		goto _12
	_7:
		tree1 = _tre_stack_pop(tls, stack)
		tmp_node1 = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tree1, *(*uintptr)(unsafe.Pointer(bp)))
		if !(tmp_node1 != 0) {
			return int32(m_REG_ESPACE)
		}
		*(*uintptr)(unsafe.Pointer(bp)) = tmp_node1
		goto _12
	_8:
		/* Parse postfix operators. */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			goto _12
		}
		switch *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) {
		case int32('?'):
			goto _19
		case int32('+'):
			goto _20
		case int32('*'):
			goto _21
		case int32('\\'):
			goto _22
		case int32('{'):
			goto _23
		}
		goto _24
	_20:
	_19:
		if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) {
			goto _24
		}
	_21:
		rep_min = 0
		rep_max = -int32(1)
		if *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('+') {
			rep_min = int32(1)
		}
		if *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('?') {
			rep_max = int32(1)
		}
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		tmp_node2 = _tre_ast_new_iter(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, *(*uintptr)(unsafe.Pointer(bp)), rep_min, rep_max)
		if tmp_node2 == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
		*(*uintptr)(unsafe.Pointer(bp)) = tmp_node2
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_POSTFIX)))
			if status != m_REG_OK {
				goto _24
			}
		}
		goto _24
	_22:
		/* "\{" is special without REG_EXTENDED */
		if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32('{') {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
			goto parse_brace
		} else {
			goto _24
		}
	_23:
		/* "{" is literal without REG_EXTENDED */
		if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) {
			goto _24
		}
	parse_brace:
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		status = _tre_parse_bound(tls, ctx, bp)
		if status != m_REG_OK {
			return status
		}
		{
			status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_POSTFIX)))
			if status != m_REG_OK {
				goto _24
			}
		}
		goto _24
	_24:
		goto _12
	_9:
		/* Parse an atom.  An atom is a regular expression enclosed in `()',
		   an empty set of `()', a bracket expression, `.', `^', `$',
		   a `\' followed by a character, or a single character. */
		/* End of regexp? (empty string). */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			goto parse_literal
		}
		switch *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) {
		case int32('('):
			goto _25
		case int32(')'):
			goto _26
		case int32('['):
			goto _27
		case int32('\\'):
			goto _28
		case int32('.'):
			goto _29
		case int32('^'):
			goto _30
		case int32('$'):
			goto _31
		default:
			goto _32
		}
		goto _33
	_25: /* parenthesized subexpression */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre > (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_start && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre - UintptrFromInt32(1)*4)) == int32('\\') {
			depth++
			{
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
				{
					/* First parse a whole RE, then mark the resulting tree
					for submatching. */
					status = _tre_stack_push(tls, stack, uintptr((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id))
					if status != m_REG_OK {
						goto _33
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_MARK_FOR_SUBMATCH)))
					if status != m_REG_OK {
						goto _33
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_RE)))
					if status != m_REG_OK {
						goto _33
					}
				}
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id++
			}
		} else {
			goto parse_literal
		}
		goto _33
	_26: /* end of current subexpression */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 && depth > 0 || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre > (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_start && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre - UintptrFromInt32(1)*4)) == int32('\\') {
			/* We were expecting an atom, but instead the current
			   subexpression was closed.	POSIX leaves the meaning of
			   this to be implementation-defined.	 We interpret this as
			   an empty expression (which matches an empty string).  */
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) {
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre -= 4
			}
		} else {
			goto parse_literal
		}
		goto _33
	_27: /* bracket expression */
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		status = _tre_parse_bracket(tls, ctx, bp)
		if status != m_REG_OK {
			return status
		}
		goto _33
	_28:
		/* If this is "\(" or "\)" chew off the backslash and
		try again. */
		if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && (*(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32('(') || *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32(')')) {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_PARSE_ATOM)))
				if status != m_REG_OK {
					goto _33
				}
			}
			goto _33
		}
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(1)*4 >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			/* Trailing backslash. */
			return int32(m_REG_EESCAPE)
		}
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		switch *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) {
		default:
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && uint32(*(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))-Int32FromInt32('0')) < uint32(10) {
				/* Back reference. */
				val = *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) - int32('0')
				*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(4), val, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
				if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
					return int32(m_REG_ESPACE)
				}
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
				if val >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref {
					v34 = val
				} else {
					v34 = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref
				}
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref = v34
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
			} else {
				/* Escaped character. */
				*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)), *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
			}
			break
		}
		if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
		goto _33
	_29: /* the any-symbol */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_NEWLINE) != 0 {
			tmp1 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, Int32FromUint8('\n')-Int32FromInt32(1), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
			if !(tmp1 != 0) {
				return int32(m_REG_ESPACE)
			}
			tmp2 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, Int32FromUint8('\n')+Int32FromInt32(1), int32(0x7fffffff), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition+int32(1))
			if !(tmp2 != 0) {
				return int32(m_REG_ESPACE)
			}
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp1, tmp2)
			if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
				return int32(m_REG_ESPACE)
			}
			*(*int32)(unsafe.Pointer(ctx + 56)) += int32(2)
		} else {
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, int32(0x7fffffff), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
			if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
		}
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		goto _33
	_30: /* beginning of line assertion */
		/* '^' has a special meaning everywhere in EREs, and in the
		beginning of the RE and after \( is BREs. */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre-uintptr(2)*4 >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_start && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre - UintptrFromInt32(2)*4)) == int32('\\') && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre - UintptrFromInt32(1)*4)) == int32('(') || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_start {
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_BOL), -int32(1))
			if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		} else {
			goto parse_literal
		}
		goto _33
	_31: /* end of line assertion. */
		/* '$' is special everywhere in EREs, and in the end of the
		string and before \) is BREs. */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(2)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32('\\') && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(2)*4)) == int32(')') || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(1)*4 == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end {
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_EOL), -int32(1))
			if *(*uintptr)(unsafe.Pointer(bp)) == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		} else {
			goto parse_literal
		}
		goto _33
	_32:
	parse_literal:
		/* We are expecting an atom.  If the subexpression (or the whole
		regexp ends here, we interpret it as an empty expression
		(which matches an empty string).  */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end || *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('*') || (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_EXTENDED) != 0 && (*(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('|') || *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('{') || *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('+') || *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('?')) || !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&Int32FromInt32(m_REG_EXTENDED) != 0) && (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre+uintptr(1)*4 < (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre_end && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)) == int32('\\') && *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre + UintptrFromInt32(1)*4)) == int32('{') {
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
				return int32(m_REG_ESPACE)
			}
			goto _33
		}
		/* Note that we can't use an tre_isalpha() test here, since there
		may be characters which are alphabetic but neither upper or
		lower case. */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_ICASE) != 0 && (x_iswupper(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))) != 0 || x_iswlower(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))) != 0) {
			/* XXX - Can there be more than one opposite-case
			   counterpoints for some character in some locale?  Or
			   more than two characters which all should be regarded
			   the same character if case is ignored?  If yes, there
			   does not seem to be a portable way to detect it.  I guess
			   that at least for multi-character collating elements there
			   could be several opposite-case counterpoints, but they
			   cannot be supported portably anyway. */
			tmp11 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, x_towupper(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))), x_towupper(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
			if !(tmp11 != 0) {
				return int32(m_REG_ESPACE)
			}
			tmp21 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, x_towlower(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))), x_towlower(tls, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
			if !(tmp21 != 0) {
				return int32(m_REG_ESPACE)
			}
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp11, tmp21)
			if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
				return int32(m_REG_ESPACE)
			}
		} else {
			*(*uintptr)(unsafe.Pointer(bp)) = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)), *(*int32)(unsafe.Pointer((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre)), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
			if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
				return int32(m_REG_ESPACE)
			}
		}
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fre += 4
		goto _33
	_33:
		goto _12
	_10:
		submatch_id = int32(_tre_stack_pop(tls, stack))
		if (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fsubmatch_id >= 0 {
			n = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			if n == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			tmp_node3 = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, n, *(*uintptr)(unsafe.Pointer(bp)))
			if tmp_node3 == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(tmp_node3)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_submatches
			*(*uintptr)(unsafe.Pointer(bp)) = tmp_node3
		}
		(*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fsubmatch_id = submatch_id
		(*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_submatches++
		goto _12
	_11:
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags = int32(_tre_stack_pop(tls, stack))
		goto _12
	_12:
	}
	/* Check for missing closing parentheses. */
	if depth > 0 {
		return int32(m_REG_EPAREN)
	}
	if status == m_REG_OK {
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fresult = *(*uintptr)(unsafe.Pointer(bp))
	}
	return status
}

/***********************************************************************
 from tre-compile.c
***********************************************************************/

/*
  Algorithms to setup tags so that submatch addressing can be done.
*/

// C documentation
//
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the left child a new tag with number `tag_id' to `node' is added,
//	   and the right child is the old root. */
//	/*              OR                  */
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the right child a new tag with number `tag_id' to `node' is added,
//	   and the left child is the old root. */
func _tre_add_tag(tls *TLS, mem uintptr, node uintptr, tag_id int32, right int32) (r int32) {
	var c, child_old, child_tag, v1 uintptr
	c = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(16))
	if c == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	child_tag = _tre_ast_new_literal(tls, mem, -int32(3), tag_id, -int32(1))
	if child_tag == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	child_old = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(48))
	if child_old == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Fsubmatch_id = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Ffirstpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Flastpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer(child_old)).Fnum_tags = 0
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = c
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = int32(_CATENATION)
	v1 = child_old
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = v1
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = v1
	if right != 0 {
		(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = child_tag
	} else {
		(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = child_tag
	}
	return m_REG_OK
}

type Ttre_addtags_symbol_t = int32

const _ADDTAGS_RECURSE = 0
const _ADDTAGS_AFTER_ITERATION = 1
const _ADDTAGS_AFTER_UNION_LEFT = 2
const _ADDTAGS_AFTER_UNION_RIGHT = 3
const _ADDTAGS_AFTER_CAT_LEFT = 4
const _ADDTAGS_AFTER_CAT_RIGHT = 5
const _ADDTAGS_SET_SUBMATCH_END = 6

type Ttre_tag_states_t = struct {
	Ftag      int32
	Fnext_tag int32
}

// C documentation
//
//	/* Adds tags to appropriate locations in the parse tree in `tree', so that
//	   subexpressions marked for submatch addressing can be traced. */
func _tre_add_tags(tls *TLS, mem uintptr, stack uintptr, tree uintptr, tnfa uintptr) (r int32) {
	var added_tags, bottom, direction, enter_tag, first_pass, i1, i2, i3, i4, i5, i6, i7, id, id1, id2, id3, id4, id5, left_tag, new_tag, next_tag, num_tags, reserved_tag, right_tag, start, start1, start2, start3, status, symbol, tag, tag_left, tag_right, v14 int32
	var cat, iter, left, left1, left2, lit, node, orig_regset, p, parents, regset, right, right1, right2, saved_states, uni uintptr
	var i uint32
	var v10, v11, v15, v16 bool
	status = m_REG_OK
	node = tree /* Tree node we are currently looking at. */
	bottom = _tre_stack_num_objects(tls, stack)
	/* True for first pass (counting number of needed tags) */
	first_pass = BoolInt32(mem == UintptrFromInt32(0) || tnfa == UintptrFromInt32(0))
	num_tags = 0        /* Total number of tags. */
	tag = 0             /* The tag that is to be added next. */
	next_tag = int32(1) /* Next tag to use after this one. */
	/* Stack of submatches the current submatch is
	   contained in. */
	direction = int32(_TRE_TAG_MINIMIZE)
	if !(first_pass != 0) {
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = 0
	}
	regset = x_malloc(tls, uint64(4)*uint64(((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1))*Uint32FromInt32(2)))
	if regset == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(regset)) = -int32(1)
	orig_regset = regset
	parents = x_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if parents == UintptrFromInt32(0) {
		x_free(tls, regset)
		return int32(m_REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(parents)) = -int32(1)
	saved_states = x_malloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if saved_states == UintptrFromInt32(0) {
		x_free(tls, regset)
		x_free(tls, parents)
		return int32(m_REG_ESPACE)
	} else {
		for i = uint32(0); i <= (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches; i++ {
			(*(*Ttre_tag_states_t)(unsafe.Pointer(saved_states + uintptr(i)*8))).Ftag = -int32(1)
		}
	}
	status = _tre_stack_push(tls, stack, node)
	status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
	for _tre_stack_num_objects(tls, stack) > bottom {
		if status != m_REG_OK {
			break
		}
		symbol = int32(_tre_stack_pop(tls, stack))
		switch symbol {
		case int32(_ADDTAGS_SET_SUBMATCH_END):
			goto _1
		case int32(_ADDTAGS_RECURSE):
			goto _2
		case int32(_ADDTAGS_AFTER_ITERATION):
			goto _3
		case int32(_ADDTAGS_AFTER_CAT_LEFT):
			goto _4
		case int32(_ADDTAGS_AFTER_CAT_RIGHT):
			goto _5
		case int32(_ADDTAGS_AFTER_UNION_LEFT):
			goto _6
		case int32(_ADDTAGS_AFTER_UNION_RIGHT):
			goto _7
		default:
			goto _8
		}
		goto _9
	_1:
		id = int32(_tre_stack_pop(tls, stack))
		/* Add end of this submatch to regset. */
		for i1 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) >= 0; i1++ {
		}
		*(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) = id*int32(2) + int32(1)
		*(*int32)(unsafe.Pointer(regset + uintptr(i1+int32(1))*4)) = -int32(1)
		/* Pop this submatch from the parents stack. */
		for i1 = 0; *(*int32)(unsafe.Pointer(parents + uintptr(i1)*4)) >= 0; i1++ {
		}
		*(*int32)(unsafe.Pointer(parents + uintptr(i1-int32(1))*4)) = -int32(1)
		goto _9
	_2:
		node = _tre_stack_pop(tls, stack)
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= 0 {
			id1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			/* Add start of this submatch to regset. */
			for i2 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) >= 0; i2++ {
			}
			*(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) = id1 * int32(2)
			*(*int32)(unsafe.Pointer(regset + uintptr(i2+int32(1))*4)) = -int32(1)
			if !(first_pass != 0) {
				for i2 = 0; *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= 0; i2++ {
				}
				(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = UintptrFromInt32(0)
				if i2 > 0 {
					p = x_malloc(tls, uint64(4)*uint64(i2+Int32FromInt32(1)))
					if p == UintptrFromInt32(0) {
						status = int32(m_REG_ESPACE)
						goto _9
					}
					if v10 = (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents == UintptrFromInt32(0); !v10 {
						x___assert_fail(tls, ts+582, ts+542, int32(1593), uintptr(unsafe.Pointer(&___func__2)))
					}
					_ = v10 || Int32FromInt32(0) != 0
					(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = p
					for i2 = 0; *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= 0; i2++ {
						*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4))
					}
					*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = -int32(1)
				}
			}
			{
				/* Add end of this submatch to regset after processing this
				node. */
				status = _tre_stack_push(tls, stack, uintptr((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id))
				if status != m_REG_OK {
					goto _9
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_SET_SUBMATCH_END)))
				if status != m_REG_OK {
					goto _9
				}
			}
		}
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
				if *(*int32)(unsafe.Pointer(regset)) >= 0 {
					/* Regset is not empty, so add a tag before the
					   literal or backref. */
					if !(first_pass != 0) {
						status = _tre_add_tag(tls, mem, node, tag, 0)
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
						/* Go through the regset and set submatch data for
						   submatches that are using this tag. */
						for i3 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i3)*4)) >= 0; i3++ {
							id2 = *(*int32)(unsafe.Pointer(regset + uintptr(i3)*4)) >> int32(1)
							start = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i3)*4))&Int32FromInt32(1) != 0))
							if start != 0 {
								(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id2)*16))).Fso_tag = tag
							} else {
								(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id2)*16))).Feo_tag = tag
							}
						}
					} else {
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = int32(1)
					}
					*(*int32)(unsafe.Pointer(regset)) = -int32(1)
					tag = next_tag
					num_tags++
					next_tag++
				}
			} else {
				if v11 = !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-Int32FromInt32(3))); !v11 {
					x___assert_fail(tls, ts+622, ts+542, int32(1656), uintptr(unsafe.Pointer(&___func__2)))
				}
				_ = v11 || Int32FromInt32(0) != 0
			}
		case int32(_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft
			right = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright
			reserved_tag = -int32(1)
			{
				/* After processing right child. */
				status = _tre_stack_push(tls, stack, node)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_AFTER_CAT_RIGHT)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* Process right child. */
				status = _tre_stack_push(tls, stack, right)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* After processing left child. */
				status = _tre_stack_push(tls, stack, uintptr(next_tag+(*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags))
				if status != m_REG_OK {
					break
				}
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags > 0 && (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_tags > 0 {
				/* Reserve the next tag to the right child. */
				reserved_tag = next_tag
				next_tag++
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(reserved_tag))
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_AFTER_CAT_LEFT)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* Process left child. */
				status = _tre_stack_push(tls, stack, left)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
				if status != m_REG_OK {
					break
				}
			}
		case int32(_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if first_pass != 0 {
				{
					status = _tre_stack_push(tls, stack, BoolUintptr(*(*int32)(unsafe.Pointer(regset)) >= Int32FromInt32(0)))
					if status != m_REG_OK {
						break
					}
				}
			} else {
				{
					status = _tre_stack_push(tls, stack, uintptr(tag))
					if status != m_REG_OK {
						break
					}
				}
			}
			{
				status = _tre_stack_push(tls, stack, node)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_AFTER_ITERATION)))
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
				if status != m_REG_OK {
					break
				}
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset)) >= 0 {
				if !(first_pass != 0) {
					status = _tre_add_tag(tls, mem, node, tag, 0)
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					/* Go through the regset and set submatch data for
					   submatches that are using this tag. */
					for i4 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i4)*4)) >= 0; i4++ {
						id3 = *(*int32)(unsafe.Pointer(regset + uintptr(i4)*4)) >> int32(1)
						start1 = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i4)*4))&Int32FromInt32(1) != 0))
						if start1 != 0 {
							(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id3)*16))).Fso_tag = tag
						} else {
							(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id3)*16))).Feo_tag = tag
						}
					}
				}
				*(*int32)(unsafe.Pointer(regset)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			direction = int32(_TRE_TAG_MINIMIZE)
		case int32(_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft
			right1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fright
			if *(*int32)(unsafe.Pointer(regset)) >= 0 {
				left_tag = next_tag
				right_tag = next_tag + int32(1)
			} else {
				left_tag = tag
				right_tag = next_tag
			}
			{
				/* After processing right child. */
				status = _tre_stack_push(tls, stack, uintptr(right_tag))
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(left_tag))
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, regset)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, BoolUintptr(*(*int32)(unsafe.Pointer(regset)) >= Int32FromInt32(0)))
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, node)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, right1)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, left1)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_AFTER_UNION_RIGHT)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* Process right child. */
				status = _tre_stack_push(tls, stack, right1)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* After processing left child. */
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_AFTER_UNION_LEFT)))
				if status != m_REG_OK {
					break
				}
			}
			{
				/* Process left child. */
				status = _tre_stack_push(tls, stack, left1)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, uintptr(int32(_ADDTAGS_RECURSE)))
				if status != m_REG_OK {
					break
				}
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset)) >= 0 {
				if !(first_pass != 0) {
					status = _tre_add_tag(tls, mem, node, tag, 0)
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					/* Go through the regset and set submatch data for
					   submatches that are using this tag. */
					for i5 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i5)*4)) >= 0; i5++ {
						id4 = *(*int32)(unsafe.Pointer(regset + uintptr(i5)*4)) >> int32(1)
						start2 = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i5)*4))&Int32FromInt32(1) != 0))
						if start2 != 0 {
							(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id4)*16))).Fso_tag = tag
						} else {
							(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id4)*16))).Feo_tag = tag
						}
					}
				}
				*(*int32)(unsafe.Pointer(regset)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
				/* The next two tags are reserved for markers. */
				next_tag++
				tag = next_tag
				next_tag++
			}
			break
		}
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= 0 {
			/* Push this submatch on the parents stack. */
			for i6 = 0; *(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) >= 0; i6++ {
			}
			*(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			*(*int32)(unsafe.Pointer(parents + uintptr(i6+int32(1))*4)) = -int32(1)
		}
		goto _9 /* end case: ADDTAGS_RECURSE */
	_3:
		_ = enter_tag
		node = _tre_stack_pop(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)).Fnum_tags + int32(_tre_stack_pop(tls, stack))
		} else {
			enter_tag = int32(_tre_stack_pop(tls, stack))
		}
		direction = int32(_TRE_TAG_MAXIMIZE)
		goto _9
	_4:
		new_tag = int32(_tre_stack_pop(tls, stack))
		next_tag = int32(_tre_stack_pop(tls, stack))
		if new_tag >= 0 {
			tag = new_tag
		}
		goto _9
	_5:
	_13:
		if 0 != 0 {
			goto _13
		}
		goto _12
	_12:
		node = _tre_stack_pop(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags
		}
		goto _9
	_6:
		/* Lift the bottom of the `regset' array so that when processing
		   the right operand the items currently in the array are
		   invisible.	 The original bottom was saved at ADDTAGS_UNION and
		   will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
		for *(*int32)(unsafe.Pointer(regset)) >= 0 {
			regset += 4
		}
		goto _9
	_7:
		left2 = _tre_stack_pop(tls, stack)
		right2 = _tre_stack_pop(tls, stack)
		node = _tre_stack_pop(tls, stack)
		added_tags = int32(_tre_stack_pop(tls, stack))
		if first_pass != 0 {
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
				v14 = int32(2)
			} else {
				v14 = 0
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags + added_tags + v14
		}
		regset = _tre_stack_pop(tls, stack)
		tag_left = int32(_tre_stack_pop(tls, stack))
		tag_right = int32(_tre_stack_pop(tls, stack))
		/* Add tags after both children, the left child gets a smaller
		   tag than the right child.  This guarantees that we prefer
		   the left child over the right child. */
		/* XXX - This is not always necessary (if the children have
		   tags which must be seen for every match of that child). */
		/* XXX - Check if this is the only place where tre_add_tag_right
		   is used.	 If so, use tre_add_tag_left (putting the tag before
		   the child as opposed after the child) and throw away
		   tre_add_tag_right. */
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
			if !(first_pass != 0) {
				status = _tre_add_tag(tls, mem, left2, tag_left, int32(1))
				*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = int32(_TRE_TAG_MAXIMIZE)
				status = _tre_add_tag(tls, mem, right2, tag_right, int32(1))
				*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = int32(_TRE_TAG_MAXIMIZE)
			}
			num_tags += int32(2)
		}
		direction = int32(_TRE_TAG_MAXIMIZE)
		goto _9
	_8:
		if v15 = 0 != 0; !v15 {
			x___assert_fail(tls, ts+635, ts+542, int32(1937), uintptr(unsafe.Pointer(&___func__2)))
		}
		_ = v15 || Int32FromInt32(0) != 0
		goto _9
	_9: /* end switch(symbol) */
	} /* end while(tre_stack_num_objects(stack) > bottom) */
	if !(first_pass != 0) {
		/* Go through the regset and set submatch data for
		submatches that are using this tag. */
		for i7 = 0; *(*int32)(unsafe.Pointer(regset + uintptr(i7)*4)) >= 0; i7++ {
			id5 = *(*int32)(unsafe.Pointer(regset + uintptr(i7)*4)) >> int32(1)
			start3 = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i7)*4))&Int32FromInt32(1) != 0))
			if start3 != 0 {
				(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id5)*16))).Fso_tag = num_tags
			} else {
				(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id5)*16))).Feo_tag = num_tags
			}
		}
	}
	if v16 = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Fnum_tags == num_tags; !v16 {
		x___assert_fail(tls, ts+637, ts+542, int32(1965), uintptr(unsafe.Pointer(&___func__2)))
	}
	_ = v16 || Int32FromInt32(0) != 0
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = num_tags
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags = num_tags
	x_free(tls, orig_regset)
	x_free(tls, parents)
	x_free(tls, saved_states)
	return status
}

var ___func__2 = [13]int8{'t', 'r', 'e', '_', 'a', 'd', 'd', '_', 't', 'a', 'g', 's'}

/*
  AST to TNFA compilation routines.
*/

type Ttre_copyast_symbol_t = int32

const _COPY_RECURSE = 0
const _COPY_SET_RESULT_PTR = 1

func _tre_copy_ast(tls *TLS, mem uintptr, stack uintptr, ast uintptr, flags int32, pos_add uintptr, tag_directions uintptr, copy1 uintptr, max_pos uintptr) (r int32) {
	var bottom, first_tag, max, min, num_copied, pos, status, symbol, v1 int32
	var cat, copy11, copy2, iter, lit, node, result, uni uintptr
	var v2 bool
	status = m_REG_OK
	bottom = _tre_stack_num_objects(tls, stack)
	num_copied = 0
	first_tag = int32(1)
	result = copy1
	status = _tre_stack_push(tls, stack, ast)
	status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
	for status == m_REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		if status != m_REG_OK {
			break
		}
		symbol = int32(_tre_stack_pop(tls, stack))
		switch symbol {
		case int32(_COPY_SET_RESULT_PTR):
			result = _tre_stack_pop(tls, stack)
		case int32(_COPY_RECURSE):
			node = _tre_stack_pop(tls, stack)
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				pos = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
				min = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min)
				max = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* XXX - e.g. [ab] has only one position but two
					   nodes, so we are creating holes in the state space
					   here.  Not fatal, just wastes memory. */
					pos += *(*int32)(unsafe.Pointer(pos_add))
					num_copied++
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(m_COPY_REMOVE_TAGS) != 0 {
						/* Change this tag to empty. */
						min = -int32(1)
						v1 = -Int32FromInt32(1)
						pos = v1
						max = v1
					} else if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(m_COPY_MAXIMIZE_FIRST_TAG) != 0 && first_tag != 0 {
						/* Maximize the first tag. */
						*(*int32)(unsafe.Pointer(tag_directions + uintptr(max)*4)) = int32(_TRE_TAG_MAXIMIZE)
						first_tag = 0
					}
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_literal(tls, mem, min, max, pos)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
				}
				if pos > *(*int32)(unsafe.Pointer(max_pos)) {
					*(*int32)(unsafe.Pointer(max_pos)) = pos
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_union(tls, mem, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				copy11 = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = copy11
				{
					status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, copy11+8)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_SET_RESULT_PTR)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_catenation(tls, mem, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				copy2 = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				(*Ttre_catenation_t)(unsafe.Pointer(copy2)).Fleft = UintptrFromInt32(0)
				(*Ttre_catenation_t)(unsafe.Pointer(copy2)).Fright = UintptrFromInt32(0)
				result = copy2
				{
					status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, copy2+8)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_SET_RESULT_PTR)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_COPY_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_iter(tls, mem, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = iter
			default:
				if v2 = 0 != 0; !v2 {
					x___assert_fail(tls, ts+635, ts+542, int32(2114), uintptr(unsafe.Pointer(&___func__3)))
				}
				_ = v2 || Int32FromInt32(0) != 0
				break
			}
			break
		}
	}
	*(*int32)(unsafe.Pointer(pos_add)) += num_copied
	return status
}

var ___func__3 = [13]int8{'t', 'r', 'e', '_', 'c', 'o', 'p', 'y', '_', 'a', 's', 't'}

type Ttre_expand_ast_symbol_t = int32

const _EXPAND_RECURSE = 0
const _EXPAND_AFTER_ITER = 1

// C documentation
//
//	/* Expands each iteration node that has a finite nonzero minimum or maximum
//	   iteration count to a catenated sequence of copies of the node. */
func _tre_expand_ast(tls *TLS, mem uintptr, stack uintptr, ast uintptr, position uintptr, tag_directions uintptr, max_depth uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var bottom, flags, i, iter_depth, pos_add_last, pos_add_save, pos_add_total, status, status1, status2, symbol, v2 int32
	var cat, iter, iter1, lit, node, seq1, tmp, uni uintptr
	var v1, v3 bool
	var _ /* copy at bp+16 */ uintptr
	var _ /* copy at bp+24 */ uintptr
	var _ /* max_pos at bp+4 */ int32
	var _ /* pos_add at bp+0 */ int32
	var _ /* seq2 at bp+8 */ uintptr
	status = m_REG_OK
	bottom = _tre_stack_num_objects(tls, stack)
	*(*int32)(unsafe.Pointer(bp)) = 0
	pos_add_total = 0
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	/* Approximate parameter nesting level. */
	iter_depth = 0
	{
		status1 = _tre_stack_push(tls, stack, ast)
		if status1 != m_REG_OK {
			return status1
		}
	}
	{
		status2 = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
		if status2 != m_REG_OK {
			return status2
		}
	}
	for status == m_REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		if status != m_REG_OK {
			break
		}
		symbol = int32(_tre_stack_pop(tls, stack))
		node = _tre_stack_pop(tls, stack)
		switch symbol {
		case int32(_EXPAND_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					*(*int32)(unsafe.Pointer(lit + 16)) += *(*int32)(unsafe.Pointer(bp))
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition > *(*int32)(unsafe.Pointer(bp + 4)) {
						*(*int32)(unsafe.Pointer(bp + 4)) = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
					}
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push(tls, stack, uintptr(*(*int32)(unsafe.Pointer(bp))))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, node)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_AFTER_ITER)))
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
					if status != m_REG_OK {
						break
					}
				}
				{
					status = _tre_stack_push(tls, stack, uintptr(int32(_EXPAND_RECURSE)))
					if status != m_REG_OK {
						break
					}
				}
				/* If we are going to expand this node at EXPAND_AFTER_ITER
				   then don't increase the `pos' fields of the nodes now, it
				   will get done when expanding. */
				if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax > int32(1) {
					*(*int32)(unsafe.Pointer(bp)) = 0
				}
				iter_depth++
			default:
				if v1 = 0 != 0; !v1 {
					x___assert_fail(tls, ts+635, ts+542, int32(2210), uintptr(unsafe.Pointer(&___func__4)))
				}
				_ = v1 || Int32FromInt32(0) != 0
				break
			}
		case int32(_EXPAND_AFTER_ITER):
			iter1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			*(*int32)(unsafe.Pointer(bp)) = int32(_tre_stack_pop(tls, stack))
			pos_add_last = *(*int32)(unsafe.Pointer(bp))
			if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax > int32(1) {
				seq1 = UintptrFromInt32(0)
				*(*uintptr)(unsafe.Pointer(bp + 8)) = UintptrFromInt32(0)
				pos_add_save = *(*int32)(unsafe.Pointer(bp))
				/* Create a catenated sequence of copies of the node. */
				for i = 0; i < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin; i++ {
					/* Remove tags from all but the last copy. */
					if i+int32(1) < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin {
						v2 = int32(m_COPY_REMOVE_TAGS)
					} else {
						v2 = int32(m_COPY_MAXIMIZE_FIRST_TAG)
					}
					flags = v2
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, flags, bp, tag_directions, bp+16, bp+4)
					if status != m_REG_OK {
						return status
					}
					if seq1 != UintptrFromInt32(0) {
						seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 16)))
					} else {
						seq1 = *(*uintptr)(unsafe.Pointer(bp + 16))
					}
					if seq1 == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
				}
				if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax == -int32(1) {
					/* No upper limit. */
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, 0, bp, UintptrFromInt32(0), bp+8, bp+4)
					if status != m_REG_OK {
						return status
					}
					*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_iter(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 8)), 0, -int32(1))
					if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
				} else {
					for i = (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin; i < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax; i++ {
						pos_add_save = *(*int32)(unsafe.Pointer(bp))
						status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, 0, bp, UintptrFromInt32(0), bp+24, bp+4)
						if status != m_REG_OK {
							return status
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_catenation(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 24)), *(*uintptr)(unsafe.Pointer(bp + 8)))
						} else {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 24))
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
						tmp = _tre_ast_new_literal(tls, mem, -int32(1), -int32(1), -int32(1))
						if tmp == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
						*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_union(tls, mem, tmp, *(*uintptr)(unsafe.Pointer(bp + 8)))
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
					}
				}
				*(*int32)(unsafe.Pointer(bp)) = pos_add_save
				if seq1 == UintptrFromInt32(0) {
					seq1 = *(*uintptr)(unsafe.Pointer(bp + 8))
				} else if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
					seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 8)))
				}
				if seq1 == UintptrFromInt32(0) {
					return int32(m_REG_ESPACE)
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Fobj
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Ftype1
			}
			iter_depth--
			pos_add_total += *(*int32)(unsafe.Pointer(bp)) - pos_add_last
			if iter_depth == 0 {
				*(*int32)(unsafe.Pointer(bp)) = pos_add_total
			}
		default:
			if v3 = 0 != 0; !v3 {
				x___assert_fail(tls, ts+635, ts+542, int32(2305), uintptr(unsafe.Pointer(&___func__4)))
			}
			_ = v3 || Int32FromInt32(0) != 0
			break
		}
	}
	*(*int32)(unsafe.Pointer(position)) += pos_add_total
	/* `max_pos' should never be larger than `*position' if the above
	   code works, but just an extra safeguard let's make sure
	   `*position' is set large enough so enough memory will be
	   allocated for the transition table. */
	if *(*int32)(unsafe.Pointer(bp + 4)) > *(*int32)(unsafe.Pointer(position)) {
		*(*int32)(unsafe.Pointer(position)) = *(*int32)(unsafe.Pointer(bp + 4))
	}
	return status
}

var ___func__4 = [15]int8{'t', 'r', 'e', '_', 'e', 'x', 'p', 'a', 'n', 'd', '_', 'a', 's', 't'}

func _tre_set_empty(tls *TLS, mem uintptr) (r uintptr) {
	var new_set uintptr
	new_set = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(48))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_one(tls *TLS, mem uintptr, position int32, code_min int32, code_max int32, class int32, neg_classes uintptr, backref int32) (r uintptr) {
	var new_set uintptr
	new_set = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), Uint64FromInt64(48)*Uint64FromInt32(2))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fposition = position
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_min = code_min
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_max = code_max
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fclass = class
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fneg_classes = neg_classes
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fbackref = backref
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*48))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*48))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*48))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_union(tls *TLS, mem uintptr, set1 uintptr, set2 uintptr, tags uintptr, assertions int32) (r uintptr) {
	var i, j, num_tags, s1, s2 int32
	var new_set, new_tags uintptr
	for num_tags = 0; tags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer(tags + uintptr(num_tags)*4)) >= 0; num_tags++ {
	}
	for s1 = 0; (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fposition >= 0; s1++ {
	}
	for s2 = 0; (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fposition >= 0; s2++ {
	}
	new_set = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(48)*uint64(s1+s2+Int32FromInt32(1)))
	if !(new_set != 0) {
		return UintptrFromInt32(0)
	}
	for s1 = 0; (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fposition >= 0; s1++ {
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fcode_max
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fassertions | assertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Ftags == UintptrFromInt32(0) && tags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Ftags = UintptrFromInt32(0)
		} else {
			for i = 0; (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Ftags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Ftags + uintptr(i)*4)) >= 0; i++ {
			}
			new_tags = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, Uint64FromInt64(4)*uint64(i+num_tags+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			for j = 0; j < i; j++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*48))).Ftags + uintptr(j)*4))
			}
			for i = 0; i < num_tags; i++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i)*4))
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*48))).Ftags = new_tags
		}
	}
	for s2 = 0; (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fposition >= 0; s2++ {
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fcode_max
		/* XXX - why not | assertions here as well? */
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fassertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Ftags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Ftags = UintptrFromInt32(0)
		} else {
			for i = 0; *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Ftags + uintptr(i)*4)) >= 0; i++ {
			}
			new_tags = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(4)*uint64(i+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			for j = 0; j < i; j++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*48))).Ftags + uintptr(j)*4))
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Ftags = new_tags
		}
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*48))).Fposition = -int32(1)
	return new_set
}

// C documentation
//
//	/* Finds the empty path through `node' which is the one that should be
//	   taken according to POSIX.2 rules, and adds the tags on that path to
//	   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
//	   set to the number of tags seen on the path. */
func _tre_match_empty(tls *TLS, stack uintptr, node uintptr, tags uintptr, assertions uintptr, num_tags_seen uintptr) (r int32) {
	var bottom, i, status int32
	var cat, iter, lit, uni, p2 uintptr
	var v1, v3, v4, v5, v6, v7 bool
	bottom = _tre_stack_num_objects(tls, stack)
	status = m_REG_OK
	if num_tags_seen != 0 {
		*(*int32)(unsafe.Pointer(num_tags_seen)) = 0
	}
	status = _tre_stack_push(tls, stack, node)
	/* Walk through the tree recursively. */
	for status == m_REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		node = _tre_stack_pop(tls, stack)
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			switch (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min {
			case int64(-int32(3)):
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max >= 0 {
					if tags != UintptrFromInt32(0) {
						/* Add the tag to `tags'. */
						for i = 0; *(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) >= 0; i++ {
							if int64(*(*int32)(unsafe.Pointer(tags + uintptr(i)*4))) == (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max {
								break
							}
						}
						if *(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) < 0 {
							*(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
							*(*int32)(unsafe.Pointer(tags + uintptr(i+int32(1))*4)) = -int32(1)
						}
					}
					if num_tags_seen != 0 {
						*(*int32)(unsafe.Pointer(num_tags_seen))++
					}
				}
			case int64(-int32(2)):
				if v1 = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max >= int64(1) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max <= int64(256); !v1 {
					x___assert_fail(tls, ts+664, ts+542, int32(2489), uintptr(unsafe.Pointer(&___func__5)))
				}
				_ = v1 || Int32FromInt32(0) != 0
				if assertions != UintptrFromInt32(0) {
					p2 = assertions
					*(*int32)(unsafe.Pointer(p2)) = int32(int64(*(*int32)(unsafe.Pointer(p2))) | (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				}
			case int64(-int32(1)):
			default:
				if v3 = 0 != 0; !v3 {
					x___assert_fail(tls, ts+635, ts+542, int32(2497), uintptr(unsafe.Pointer(&___func__5)))
				}
				_ = v3 || Int32FromInt32(0) != 0
				break
			}
		case int32(_UNION):
			/* Subexpressions starting earlier take priority over ones
			   starting later, so we prefer the left subexpression over the
			   right subexpression. */
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 {
				status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
				if status != m_REG_OK {
					break
				}
			} else {
				if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0 {
					status = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != m_REG_OK {
						break
					}
				} else {
					if v4 = 0 != 0; !v4 {
						x___assert_fail(tls, ts+635, ts+542, int32(2512), uintptr(unsafe.Pointer(&___func__5)))
					}
					_ = v4 || Int32FromInt32(0) != 0
				}
			}
		case int32(_CATENATION):
			/* The path must go through both children. */
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if v5 = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0; !v5 {
				x___assert_fail(tls, ts+715, ts+542, int32(2518), uintptr(unsafe.Pointer(&___func__5)))
			}
			_ = v5 || Int32FromInt32(0) != 0
			if v6 = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0; !v6 {
				x___assert_fail(tls, ts+735, ts+542, int32(2519), uintptr(unsafe.Pointer(&___func__5)))
			}
			_ = v6 || Int32FromInt32(0) != 0
			{
				status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
				if status != m_REG_OK {
					break
				}
			}
			{
				status = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if status != m_REG_OK {
					break
				}
			}
		case int32(_ITERATION):
			/* A match with an empty string is preferred over no match at
			   all, so we go through the argument if possible. */
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				status = _tre_stack_push(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != m_REG_OK {
					break
				}
			}
		default:
			if v7 = 0 != 0; !v7 {
				x___assert_fail(tls, ts+635, ts+542, int32(2533), uintptr(unsafe.Pointer(&___func__5)))
			}
			_ = v7 || Int32FromInt32(0) != 0
			break
		}
	}
	return status
}

var ___func__5 = [16]int8{'t', 'r', 'e', '_', 'm', 'a', 't', 'c', 'h', '_', 'e', 'm', 'p', 't', 'y'}

type Ttre_nfl_stack_symbol_t = int32

const _NFL_RECURSE = 0
const _NFL_POST_UNION = 1
const _NFL_POST_CATENATION = 2
const _NFL_POST_ITERATION = 3

// C documentation
//
//	/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
//	   the nodes of the AST `tree'. */
func _tre_compute_nfl(tls *TLS, mem uintptr, stack uintptr, tree uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var bottom, status, status1, status10, status11, status12, status13, status14, status15, status16, status17, status18, status2, status3, status4, status5, status6, status7, status8, status9, symbol int32
	var cat, iter, lit, node, tags, uni uintptr
	var v1 bool
	var _ /* assertions at bp+4 */ int32
	var _ /* num_tags at bp+0 */ int32
	bottom = _tre_stack_num_objects(tls, stack)
	{
		status = _tre_stack_push(tls, stack, tree)
		if status != m_REG_OK {
			return status
		}
	}
	{
		status1 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
		if status1 != m_REG_OK {
			return status1
		}
	}
	for _tre_stack_num_objects(tls, stack) > bottom {
		symbol = int32(_tre_stack_pop(tls, stack))
		node = _tre_stack_pop(tls, stack)
		switch symbol {
		case int32(_NFL_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* Back references: nullable = false, firstpos = {i},
					   lastpos = {i}. */
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, 0, int32(0x7fffffff), 0, UintptrFromInt32(0), -int32(1))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
						return int32(m_REG_ESPACE)
					}
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, 0, int32(0x7fffffff), 0, UintptrFromInt32(0), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
						return int32(m_REG_ESPACE)
					}
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < 0 {
						/* Tags, empty strings and zero width assertions:
						   nullable = true, firstpos = {}, and lastpos = {}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(m_REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(m_REG_ESPACE)
						}
					} else {
						/* Literal at position i: nullable = false, firstpos = {i},
						   lastpos = {i}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), 0, UintptrFromInt32(0), -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(m_REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), (*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes, -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(m_REG_ESPACE)
						}
					}
				}
			case int32(_UNION):
				status2 = _tre_stack_push(tls, stack, node)
				if status2 != m_REG_OK {
					return status2
				}
				{
					status3 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_POST_UNION)))
					if status3 != m_REG_OK {
						return status3
					}
				}
				{
					status4 = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
					if status4 != m_REG_OK {
						return status4
					}
				}
				{
					status5 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
					if status5 != m_REG_OK {
						return status5
					}
				}
				{
					status6 = _tre_stack_push(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
					if status6 != m_REG_OK {
						return status6
					}
				}
				{
					status7 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
					if status7 != m_REG_OK {
						return status7
					}
				}
			case int32(_CATENATION):
				status8 = _tre_stack_push(tls, stack, node)
				if status8 != m_REG_OK {
					return status8
				}
				{
					status9 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_POST_CATENATION)))
					if status9 != m_REG_OK {
						return status9
					}
				}
				{
					status10 = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
					if status10 != m_REG_OK {
						return status10
					}
				}
				{
					status11 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
					if status11 != m_REG_OK {
						return status11
					}
				}
				{
					status12 = _tre_stack_push(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
					if status12 != m_REG_OK {
						return status12
					}
				}
				{
					status13 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
					if status13 != m_REG_OK {
						return status13
					}
				}
			case int32(_ITERATION):
				status14 = _tre_stack_push(tls, stack, node)
				if status14 != m_REG_OK {
					return status14
				}
				{
					status15 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_POST_ITERATION)))
					if status15 != m_REG_OK {
						return status15
					}
				}
				{
					status16 = _tre_stack_push(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)
					if status16 != m_REG_OK {
						return status16
					}
				}
				{
					status17 = _tre_stack_push(tls, stack, uintptr(int32(_NFL_RECURSE)))
					if status17 != m_REG_OK {
						return status17
					}
				}
				break
			}
		case int32(_NFL_POST_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0)
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Ffirstpos, UintptrFromInt32(0), 0)
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Flastpos, UintptrFromInt32(0), 0)
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
				return int32(m_REG_ESPACE)
			}
		case int32(_NFL_POST_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == 0 || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos
		case int32(_NFL_POST_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 && (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0)
			/* Compute firstpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 {
				/* The left side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags. */
				status18 = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status18 != m_REG_OK {
					return status18
				}
				/* Allocate arrays for the tags and parameters. */
				tags = x_malloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(m_REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = 0
				/* Second pass with tre_mach_empty() to get the list of
				   tags. */
				status18 = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, tags, bp+4, UintptrFromInt32(0))
				if status18 != m_REG_OK {
					x_free(tls, tags)
					return status18
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				x_free(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
					return int32(m_REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos
			}
			/* Compute lastpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0 {
				/* The right side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags. */
				status18 = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status18 != m_REG_OK {
					return status18
				}
				/* Allocate arrays for the tags and parameters. */
				tags = x_malloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(m_REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = 0
				/* Second pass with tre_mach_empty() to get the list of
				   tags. */
				status18 = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, tags, bp+4, UintptrFromInt32(0))
				if status18 != m_REG_OK {
					x_free(tls, tags)
					return status18
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				x_free(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
					return int32(m_REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos
			}
		default:
			if v1 = 0 != 0; !v1 {
				x___assert_fail(tls, ts+635, ts+542, int32(2765), uintptr(unsafe.Pointer(&___func__6)))
			}
			_ = v1 || Int32FromInt32(0) != 0
			break
		}
	}
	return m_REG_OK
}

var ___func__6 = [16]int8{'t', 'r', 'e', '_', 'c', 'o', 'm', 'p', 'u', 't', 'e', '_', 'n', 'f', 'l'}

// C documentation
//
//	/* Adds a transition from each position in `p1' to each position in `p2'. */
func _tre_make_trans(tls *TLS, p1 uintptr, p2 uintptr, transitions uintptr, counts uintptr, offs uintptr) (r int32) {
	var dup, i, j, k, l, prev_p2_pos, v1, v2, v5 int32
	var orig_p2, trans uintptr
	var v3, v4 bool
	orig_p2 = p2
	if transitions != UintptrFromInt32(0) {
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= 0 {
			p2 = orig_p2
			prev_p2_pos = -int32(1)
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= 0 {
				/* Optimization: if this position was already handled, skip it. */
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition == prev_p2_pos {
					p2 += 48
					continue
				}
				prev_p2_pos = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				/* Set `trans' to point to the next unused transition from
				   position `p1->position'. */
				trans = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4)))*48
				for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != UintptrFromInt32(0) {
					trans += 48
				}
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate == UintptrFromInt32(0) {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans + UintptrFromInt32(1)*48)).Fstate = UintptrFromInt32(0)
				}
				/* Use the character ranges, assertions, etc. from `p1' for
				   the transition from `p1' to `p2'. */
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_min = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_min
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_max = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_max
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition)*4)))*48
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass != 0 {
					v1 = int32(m_ASSERT_CHAR_CLASS)
				} else {
					v1 = 0
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					v2 = int32(m_ASSERT_CHAR_CLASS_NEG)
				} else {
					v2 = 0
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fassertions | (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fassertions | v1 | v2
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref >= 0 {
					if v3 = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fassertions&int32(4) == 0; !v3 {
						x___assert_fail(tls, ts+756, ts+542, int32(2837), uintptr(unsafe.Pointer(&___func__7)))
					}
					_ = v3 || Int32FromInt32(0) != 0
					if v4 = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fbackref < 0; !v4 {
						x___assert_fail(tls, ts+801, ts+542, int32(2838), uintptr(unsafe.Pointer(&___func__7)))
					}
					_ = v4 || Int32FromInt32(0) != 0
					*(*int32)(unsafe.Pointer(trans + 36)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref
					*(*int32)(unsafe.Pointer(trans + 32)) |= int32(m_ASSERT_BACKREF)
				} else {
					*(*int32)(unsafe.Pointer(trans + 36)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					for i = 0; *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*4)) != Int32FromInt32(0); i++ {
					}
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = x_malloc(tls, uint64(4)*uint64(i+Int32FromInt32(1)))
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
					for i = 0; *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*4)) != Int32FromInt32(0); i++ {
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*4))
					}
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*4)) = Int32FromInt32(0)
				} else {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = UintptrFromInt32(0)
				}
				/* Find out how many tags this transition has. */
				i = 0
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= 0 {
						i++
					}
				}
				j = 0
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= 0 {
						j++
					}
				}
				/* If we are overwriting a transition, free the old tag array. */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != UintptrFromInt32(0) {
					x_free(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = UintptrFromInt32(0)
				/* If there were any tags, allocate an array and fill it. */
				if i+j > 0 {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = x_malloc(tls, uint64(4)*uint64(i+j+Int32FromInt32(1)))
					if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0) {
						return int32(m_REG_ESPACE)
					}
					i = 0
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= 0 {
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4))
							i++
						}
					}
					l = i
					j = 0
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= 0 {
							/* Don't add duplicates. */
							dup = 0
							for k = 0; k < i; k++ {
								if *(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(k)*4)) == *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) {
									dup = int32(1)
									break
								}
							}
							if !(dup != 0) {
								v5 = l
								l++
								*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(v5)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4))
							}
							j++
						}
					}
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(l)*4)) = -int32(1)
				}
				p2 += 48
			}
			p1 += 48
		}
	} else {
		/* Compute a maximum limit for the number of transitions leaving
		   from each state. */
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= 0 {
			p2 = orig_p2
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= 0 {
				*(*int32)(unsafe.Pointer(counts + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4))++
				p2 += 48
			}
			p1 += 48
		}
	}
	return m_REG_OK
}

var ___func__7 = [15]int8{'t', 'r', 'e', '_', 'm', 'a', 'k', 'e', '_', 't', 'r', 'a', 'n', 's'}

// C documentation
//
//	/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
//	   labelled with one character range (there are no transitions on empty
//	   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
//	   the regexp. */
func _tre_ast_to_tnfa(tls *TLS, node uintptr, transitions uintptr, counts uintptr, offs uintptr) (r int32) {
	var cat, iter, uni uintptr
	var errcode int32
	var v1, v2 bool
	errcode = m_REG_OK
	/* XXX - recurse using a stack!. */
	switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
	case int32(_LITERAL):
	case int32(_UNION):
		uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, transitions, counts, offs)
		if errcode != m_REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright, transitions, counts, offs)
	case int32(_CATENATION):
		cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		/* Add a transition from each position in cat->left->lastpos
		to each position in cat->right->firstpos. */
		errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, transitions, counts, offs)
		if errcode != m_REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, transitions, counts, offs)
		if errcode != m_REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, transitions, counts, offs)
	case int32(_ITERATION):
		iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		if v1 = (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == -int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == int32(1); !v1 {
			x___assert_fail(tls, ts+817, ts+542, int32(3001), uintptr(unsafe.Pointer(&___func__8)))
		}
		_ = v1 || Int32FromInt32(0) != 0
		if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == -int32(1) {
			if v2 = (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == 0 || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == int32(1); !v2 {
				x___assert_fail(tls, ts+851, ts+542, int32(3005), uintptr(unsafe.Pointer(&___func__8)))
			}
			_ = v2 || Int32FromInt32(0) != 0
			/* Add a transition from each last position in the iterated
			   expression to each first position. */
			errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos, transitions, counts, offs)
			if errcode != m_REG_OK {
				return errcode
			}
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, transitions, counts, offs)
		break
	}
	return errcode
}

var ___func__8 = [16]int8{'t', 'r', 'e', '_', 'a', 's', 't', '_', 't', 'o', '_', 't', 'n', 'f', 'a'}

func _tre_free(tls *TLS, preg uintptr) {
	var i uint32
	var tnfa, trans uintptr
	tnfa = (*Tregex_t)(unsafe.Pointer(preg)).F__opaque
	if !(tnfa != 0) {
		return
	}
	for i = uint32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions; i++ {
		if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*48))).Fstate != 0 {
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*48))).Ftags != 0 {
				x_free(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*48))).Ftags)
			}
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*48))).Fneg_classes != 0 {
				x_free(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*48))).Fneg_classes)
			}
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial != 0 {
		for trans = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != 0; trans += 48 {
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0 {
				x_free(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
			}
		}
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data != 0 {
		for i = uint32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches; i++ {
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents != 0 {
				x_free(tls, (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents)
			}
		}
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions)
	}
	x_free(tls, tnfa)
}

func _tre_compile(tls *TLS, preg uintptr, regex uintptr, n uint64, cflags int32) (r int32) {
	bp := tls.Alloc(72) /* tlsAllocs 72 maxVaListSize 0 */
	defer tls.Free(72)
	var add, errcode, i, j, v1 int32
	var counts, initial, mem, offs, p, stack, submatch_data, tag_directions, tmp_ast_l, tmp_ast_r, tnfa, transitions, tree, v2 uintptr
	var _ /* parse_ctx at bp+0 */ Ttre_parse_ctx_t
	counts = UintptrFromInt32(0)
	offs = UintptrFromInt32(0)
	add = 0
	tnfa = UintptrFromInt32(0)
	tag_directions = UintptrFromInt32(0)
	/* Parse context. */
	/* Allocate a stack used throughout the compilation process for various
	   purposes. */
	stack = _tre_stack_new(tls, int32(512), int32(10240), int32(128))
	if !(stack != 0) {
		return int32(m_REG_ESPACE)
	}
	/* Allocate a fast memory allocator. */
	mem = x___tre_mem_new_impl(tls, 0, UintptrFromInt32(0))
	if !(mem != 0) {
		_tre_stack_destroy(tls, stack)
		return int32(m_REG_ESPACE)
	}
	/* Parse the regexp. */
	x_memset(tls, bp, 0, uint64(72))
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmem = mem
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fstack = stack
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fre = regex
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Flen1 = int32(n)
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fcflags = cflags
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref = -int32(1)
	errcode = _tre_parse(tls, bp)
	if errcode != m_REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub = uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id - int32(1))
	tree = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fresult
	/* Referring to nonexistent subexpressions is illegal. */
	if (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref > int32((*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub) {
		errcode = int32(6)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	/* Allocate the TNFA struct. */
	tnfa = x_calloc(tls, uint64(1), uint64(80))
	if tnfa == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs = BoolInt32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref >= 0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches = uint32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id)
	/* Set up tags for submatch addressing.  If REG_NOSUB is set and the
	   regexp does not have back references, this can be skipped. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 || !(cflags&Int32FromInt32(m_REG_NOSUB) != 0) {
		/* Figure out how many tags we will need. */
		errcode = _tre_add_tags(tls, UintptrFromInt32(0), stack, tree, tnfa)
		if errcode != m_REG_OK {
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > 0 {
			tag_directions = x_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
			if tag_directions == UintptrFromInt32(0) {
				errcode = int32(12)
				if int32(1) != 0 {
					goto error_exit
				}
			}
			(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions = tag_directions
			x_memset(tls, tag_directions, -int32(1), uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
		}
		submatch_data = x_calloc(tls, uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id), uint64(16))
		if submatch_data == UintptrFromInt32(0) {
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data = submatch_data
		errcode = _tre_add_tags(tls, mem, stack, tree, tnfa)
		if errcode != m_REG_OK {
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	/* Expand iteration nodes. */
	errcode = _tre_expand_ast(tls, mem, stack, tree, uintptr(unsafe.Pointer(&(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition)), tag_directions, UintptrFromInt32(0))
	if errcode != m_REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	/* Add a dummy node for the final state.
	     XXX - For certain patterns this dummy node can be optimized away,
		   for example "a*" or "ab*".	Figure out a simple way to detect
		   this possibility. */
	tmp_ast_l = tree
	v2 = uintptr(unsafe.Pointer(&(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	tmp_ast_r = _tre_ast_new_literal(tls, mem, 0, 0, v1)
	if tmp_ast_r == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	tree = _tre_ast_new_catenation(tls, mem, tmp_ast_l, tmp_ast_r)
	if tree == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	errcode = _tre_compute_nfl(tls, mem, stack, tree)
	if errcode != m_REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	counts = x_malloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if counts == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	offs = x_malloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if offs == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	for i = 0; i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition; i++ {
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = 0
	}
	_tre_ast_to_tnfa(tls, tree, UintptrFromInt32(0), counts, UintptrFromInt32(0))
	add = 0
	for i = 0; i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition; i++ {
		*(*int32)(unsafe.Pointer(offs + uintptr(i)*4)) = add
		add += *(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) + int32(1)
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = 0
	}
	transitions = x_calloc(tls, uint64(add+int32(1)), uint64(48))
	if transitions == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions = transitions
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	errcode = _tre_ast_to_tnfa(tls, tree, transitions, counts, offs)
	if errcode != m_REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos
	i = 0
	for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= 0 {
		i++
		p += 48
	}
	initial = x_calloc(tls, uint64(i+int32(1)), uint64(48))
	if initial == UintptrFromInt32(0) {
		errcode = int32(12)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial = initial
	i = 0
	for p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos; (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= 0; p += 48 {
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition)*4)))*48
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Ftags = UintptrFromInt32(0)
		/* Copy the arrays p->tags, they are allocated
		from a tre_mem object. */
		if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags != 0 {
			for j = 0; *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags + uintptr(j)*4)) >= 0; j++ {
			}
			(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Ftags = x_malloc(tls, uint64(4)*uint64(j+Int32FromInt32(1)))
			if !((*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Ftags != 0) {
				errcode = int32(12)
				if int32(1) != 0 {
					goto error_exit
				}
			}
			x_memcpy(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Ftags, (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags, uint64(4)*uint64(j+Int32FromInt32(1)))
		}
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fassertions
		i++
	}
	(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*48))).Fstate = UintptrFromInt32(0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*(*Ttre_pos_and_tags_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(tree)).Flastpos))).Fposition)*4)))*48
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags = cflags
	x___tre_mem_destroy(tls, mem)
	_tre_stack_destroy(tls, stack)
	x_free(tls, counts)
	x_free(tls, offs)
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	return m_REG_OK
error_exit:
	/* Free everything that was allocated and return the error code. */
	x___tre_mem_destroy(tls, mem)
	if stack != UintptrFromInt32(0) {
		_tre_stack_destroy(tls, stack)
	}
	if counts != UintptrFromInt32(0) {
		x_free(tls, counts)
	}
	if offs != UintptrFromInt32(0) {
		x_free(tls, offs)
	}
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	_tre_free(tls, preg)
	return errcode
}

func x_regcomp(tls *TLS, preg uintptr, regex uintptr, cflags int32) (r int32) {
	var n uint64
	var ret int32
	var wregex uintptr
	n = x_strlen(tls, regex)
	if n+uint64(1) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(4) {
		return int32(m_REG_ESPACE)
	}
	wregex = x_malloc(tls, uint64(4)*(n+uint64(1)))
	if wregex == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	n = x_mbstowcs(tls, wregex, regex, n+uint64(1))
	if n == uint64(-Int32FromInt32(1)) {
		x_free(tls, wregex)
		return int32(m_REG_BADPAT)
	}
	ret = _tre_compile(tls, preg, wregex, n, cflags)
	x_free(tls, wregex)
	return ret
}

func x_regfree(tls *TLS, preg uintptr) {
	_tre_free(tls, preg)
}

const m_REG_BADRPT = 13

/* Error message strings for error codes listed in `regex.h'.  This list
   needs to be in sync with the codes listed there, naturally. */

/* Converted to single string by Rich Felker to remove the need for
 * data relocations at runtime, 27 Feb 2006. */

var _tre_error_messages = [232]int8{'N', 'o', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'o', ' ', 'm', 'a', 't', 'c', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'g', 'e', 'x', 'p', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'o', 'l', 'l', 'a', 't', 'i', 'n', 'g', ' ', 'e', 'l', 'e', 'm', 'e', 'n', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'c', 'l', 'a', 's', 's', ' ', 'n', 'a', 'm', 'e', 0, 'T', 'r', 'a', 'i', 'l', 'i', 'n', 'g', ' ', 'b', 'a', 'c', 'k', 's', 'l', 'a', 's', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'b', 'a', 'c', 'k', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', ']', '\'', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', ')', '\'', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', '}', '\'', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'o', 'n', 't', 'e', 'n', 't', 's', ' ', 'o', 'f', ' ', '{', '}', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'r', 'a', 'n', 'g', 'e', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'X', 'X', 'X'}

func x_regerror(tls *TLS, errcode int32, preg uintptr, errbuf uintptr, errbuf_size uint64) (r uint64) {
	var err uintptr
	var err_len uint64
	if errcode >= 0 && errcode <= int32(m_REG_BADRPT) {
		for err = uintptr(unsafe.Pointer(&_tre_error_messages)); errcode != 0; {
			goto _1
		_1:
			errcode--
			err += uintptr(x_strlen(tls, err) + uint64(1))
		}
	} else {
		err = ts + 884
	}
	err_len = x_strlen(tls, err) + uint64(1)
	if errbuf_size > uint64(0) && errbuf != UintptrFromInt32(0) {
		if err_len > errbuf_size {
			x_memcpy(tls, errbuf, err, errbuf_size-uint64(1))
			*(*int8)(unsafe.Pointer(errbuf + uintptr(errbuf_size-uint64(1)))) = int8('\000')
		} else {
			x_strcpy(tls, errbuf, err)
		}
	}
	return err_len
}

const m_REG_NOMATCH = 1
const m_REG_NOTBOL = 1
const m_REG_NOTEOL = 2
const m_tre_bt_mem_destroy = 0

/***********************************************************************
 from tre-match-utils.h
***********************************************************************/

// C documentation
//
//	/* Returns 1 if `t1' wins `t2', 0 otherwise. */
func _tre_tag_order(tls *TLS, num_tags int32, tag_directions uintptr, t1 uintptr, t2 uintptr) (r int32) {
	var i int32
	for i = 0; i < num_tags; i++ {
		if *(*int32)(unsafe.Pointer(tag_directions + uintptr(i)*4)) == int32(_TRE_TAG_MINIMIZE) {
			if *(*int32)(unsafe.Pointer(t1 + uintptr(i)*4)) < *(*int32)(unsafe.Pointer(t2 + uintptr(i)*4)) {
				return int32(1)
			}
			if *(*int32)(unsafe.Pointer(t1 + uintptr(i)*4)) > *(*int32)(unsafe.Pointer(t2 + uintptr(i)*4)) {
				return 0
			}
		} else {
			if *(*int32)(unsafe.Pointer(t1 + uintptr(i)*4)) > *(*int32)(unsafe.Pointer(t2 + uintptr(i)*4)) {
				return int32(1)
			}
			if *(*int32)(unsafe.Pointer(t1 + uintptr(i)*4)) < *(*int32)(unsafe.Pointer(t2 + uintptr(i)*4)) {
				return 0
			}
		}
	}
	/*  assert(0);*/
	return 0
}

func _tre_neg_char_classes_match(tls *TLS, classes uintptr, wc int32, icase int32) (r int32) {
	for *(*int32)(unsafe.Pointer(classes)) != Int32FromInt32(0) {
		if !(icase != 0) && x_iswctype(tls, wc, *(*int32)(unsafe.Pointer(classes))) != 0 || icase != 0 && (x_iswctype(tls, x_towupper(tls, wc), *(*int32)(unsafe.Pointer(classes))) != 0 || x_iswctype(tls, x_towlower(tls, wc), *(*int32)(unsafe.Pointer(classes))) != 0) {
			return int32(1)
		} else {
			classes += 4
		}
	}
	return 0 /* No match. */
}

/***********************************************************************
 from tre-match-parallel.c
***********************************************************************/

/*
  This algorithm searches for matches basically by reading characters
  in the searched string one by one, starting at the beginning.	 All
  matching paths in the TNFA are traversed in parallel.	 When two or
  more paths reach the same state, exactly one is chosen according to
  tag ordering rules; if returning submatches is not required it does
  not matter which path is chosen.

  The worst case time required for finding the leftmost and longest
  match, or determining that there is no match, is always linearly
  dependent on the length of the text being searched.

  This algorithm cannot handle TNFAs with back referencing nodes.
  See `tre-match-backtrack.c'.
*/

type Ttre_tnfa_reach_t = struct {
	Fstate uintptr
	Ftags  uintptr
}

type Ttre_reach_pos_t = struct {
	Fpos  int32
	Ftags uintptr
}

func _tre_tnfa_run_parallel(tls *TLS, tnfa uintptr, string1 uintptr, len1 int32, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var buf, reach, reach_i, reach_next, reach_next_i, reach_pos, str_byte, tag_i, tmp_buf, tmp_iptr, tmp_tags, trans_i uintptr
	var i, match_eo, new_match, num_tags, pbytes, pos, pos_add_next, prev_c, rbytes, reg_newline, reg_notbol, reg_noteol, tbytes, total_bytes, xbytes, v5, v6, v8 int32
	var v1, v2, v3, v4 uint64
	var v7 bool
	var _ /* next_c at bp+0 */ int32
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = 0
	*(*int32)(unsafe.Pointer(bp)) = 0
	str_byte = string1
	pos = -int32(1)
	pos_add_next = int32(1)
	reg_notbol = eflags & int32(m_REG_NOTBOL)
	reg_noteol = eflags & int32(m_REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(m_REG_NEWLINE)
	match_eo = -int32(1) /* end offset of match (-1 if no match found yet) */
	new_match = 0
	_ = new_match
	tmp_tags = UintptrFromInt32(0)
	if !(match_tags != 0) {
		num_tags = 0
	} else {
		num_tags = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags
	}
	{
		/* Allocate memory for temporary data required for matching.	This needs to
		   be done for every matching operation to be thread safe.  This allocates
		   everything in a single large block from the stack frame using alloca()
		   or with malloc() if alloca is unavailable. */
		/* Compute the length of the block we need. */
		tbytes = int32(uint64(4) * uint64(num_tags))
		rbytes = int32(uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states+Int32FromInt32(1)))
		pbytes = int32(uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))
		xbytes = int32(uint64(4) * uint64(num_tags))
		total_bytes = int32((Uint64FromInt64(8)-Uint64FromInt32(1))*Uint64FromInt32(4) + uint64((rbytes+xbytes*(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states)*int32(2)) + uint64(tbytes) + uint64(pbytes))
		/* Allocate the memory. */
		buf = x_malloc(tls, uint64(total_bytes))
		if buf == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
		x_memset(tls, buf, 0, uint64(total_bytes))
		/* Get the various pointers within tmp_buf (properly aligned). */
		tmp_tags = buf
		tmp_buf = buf + uintptr(tbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v1 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v1 = uint64(0)
		}
		tmp_buf += uintptr(v1)
		reach_next = tmp_buf
		tmp_buf += uintptr(rbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v2 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v2 = uint64(0)
		}
		tmp_buf += uintptr(v2)
		reach = tmp_buf
		tmp_buf += uintptr(rbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v3 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v3 = uint64(0)
		}
		tmp_buf += uintptr(v3)
		reach_pos = tmp_buf
		tmp_buf += uintptr(pbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v4 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v4 = uint64(0)
		}
		tmp_buf += uintptr(v4)
		for i = 0; i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
			(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach + uintptr(i)*16))).Ftags = tmp_buf
			tmp_buf += uintptr(xbytes)
			(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next + uintptr(i)*16))).Ftags = tmp_buf
			tmp_buf += uintptr(xbytes)
		}
	}
	for i = 0; i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
		(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr(i)*16))).Fpos = -int32(1)
	}
	prev_c = *(*int32)(unsafe.Pointer(bp))
	pos += pos_add_next
	v5 = x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX))
	pos_add_next = v5
	if v5 <= 0 {
		if pos_add_next < 0 {
			return int32(m_REG_NOMATCH)
		} else {
			pos_add_next++
		}
	}
	str_byte += uintptr(pos_add_next)
	pos = 0
	reach_next_i = reach_next
	for int32(1) != 0 {
		/* If no match found yet, add the initial states to `reach_next'. */
		if match_eo < 0 {
			trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial
			for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != UintptrFromInt32(0) {
				if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*int32)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*int32)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0))) {
						trans_i += 48
						continue
					}
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
					for i = 0; i < num_tags; i++ {
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*4)) = -int32(1)
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != 0 {
						for *(*int32)(unsafe.Pointer(tag_i)) >= 0 {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*4)) = pos
							}
							tag_i += 4
						}
					}
					if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
						match_eo = pos
						new_match = int32(1)
						for i = 0; i < num_tags; i++ {
							*(*int32)(unsafe.Pointer(match_tags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*4))
						}
					}
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
					reach_next_i += 16
				}
				trans_i += 48
			}
			(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
		} else {
			if num_tags == 0 || reach_next_i == reach_next {
				/* We have found a match. */
				break
			}
		}
		/* Check for end of string. */
		if !(*(*int32)(unsafe.Pointer(bp)) != 0) {
			break
		}
		prev_c = *(*int32)(unsafe.Pointer(bp))
		pos += pos_add_next
		v6 = x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX))
		pos_add_next = v6
		if v6 <= 0 {
			if pos_add_next < 0 {
				return int32(m_REG_NOMATCH)
			} else {
				pos_add_next++
			}
		}
		str_byte += uintptr(pos_add_next)
		/* Swap `reach' and `reach_next'. */
		reach_i = reach
		reach = reach_next
		reach_next = reach_i
		/* For each state in `reach' see if there is a transition leaving with
		the current input symbol to a state not yet in `reach_next', and
		add the destination states to `reach_next'. */
		reach_next_i = reach_next
		for reach_i = reach; (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate != 0; reach_i += 16 {
			for trans_i = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0; trans_i += 48 {
				/* Does this transition match the input symbol? */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_min <= prev_c && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_max >= prev_c {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*int32)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*int32)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && !((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&Int32FromInt32(m_REG_ICASE) != 0) && !(x_iswctype(tls, prev_c, *(*int32)(unsafe.Pointer(trans_i + 36))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE) != 0 && (!(x_iswctype(tls, x_towlower(tls, prev_c), *(*int32)(unsafe.Pointer(trans_i + 36))) != 0) && !(x_iswctype(tls, x_towupper(tls, prev_c), *(*int32)(unsafe.Pointer(trans_i + 36))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fneg_classes, prev_c, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE)) != 0) {
						continue
					}
					/* Compute the tags after this transition. */
					for i = 0; i < num_tags; i++ {
						*(*int32)(unsafe.Pointer(tmp_tags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(i)*4))
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer(tag_i)) >= 0 {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*int32)(unsafe.Pointer(tmp_tags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*4)) = pos
							}
							tag_i += 4
						}
					}
					if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
						/* Found an unvisited node. */
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
						tmp_iptr = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags = tmp_tags
						tmp_tags = tmp_iptr
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
						if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal && (match_eo == -int32(1) || num_tags > 0 && *(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags)) <= *(*int32)(unsafe.Pointer(match_tags))) {
							match_eo = pos
							new_match = int32(1)
							for i = 0; i < num_tags; i++ {
								*(*int32)(unsafe.Pointer(match_tags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*4))
							}
						}
						reach_next_i += 16
					} else {
						if v7 = (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos == pos; !v7 {
							x___assert_fail(tls, ts+898, ts+938, int32(399), uintptr(unsafe.Pointer(&___func__9)))
						}
						_ = v7 || Int32FromInt32(0) != 0
						/* Another path has also reached this state.  We choose
						the winner by examining the tag values for both
						paths. */
						if _tre_tag_order(tls, num_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tmp_tags, *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))) != 0 {
							/* The new path wins. */
							tmp_iptr = *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))
							*(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags)) = tmp_tags
							if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
								match_eo = pos
								new_match = int32(1)
								for i = 0; i < num_tags; i++ {
									*(*int32)(unsafe.Pointer(match_tags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer(tmp_tags + uintptr(i)*4))
								}
							}
							tmp_tags = tmp_iptr
						}
					}
				}
			}
		}
		(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
	}
	if buf != 0 {
		x_free(tls, buf)
	}
	*(*int32)(unsafe.Pointer(match_end_ofs)) = match_eo
	if match_eo >= 0 {
		v8 = m_REG_OK
	} else {
		v8 = int32(m_REG_NOMATCH)
	}
	return v8
}

var ___func__9 = [22]int8{'t', 'r', 'e', '_', 't', 'n', 'f', 'a', '_', 'r', 'u', 'n', '_', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l'}

/***********************************************************************
 from tre-match-backtrack.c
***********************************************************************/

/*
  This matcher is for regexps that use back referencing.  Regexp matching
  with back referencing is an NP-complete problem on the number of back
  references.  The easiest way to match them is to use a backtracking
  routine which basically goes through all possible paths in the TNFA
  and chooses the one which results in the best (leftmost and longest)
  match.  This can be spectacularly expensive and may run out of stack
  space, but there really is no better known generic algorithm.	 Quoting
  Henry Spencer from comp.compilers:
  <URL: http://compilers.iecc.com/comparch/article/93-03-102>

    POSIX.2 REs require longest match, which is really exciting to
    implement since the obsolete ("basic") variant also includes
    \<digit>.  I haven't found a better way of tackling this than doing
    a preliminary match using a DFA (or simulation) on a modified RE
    that just replicates subREs for \<digit>, and then doing a
    backtracking match to determine whether the subRE matches were
    right.  This can be rather slow, but I console myself with the
    thought that people who use \<digit> deserve very slow execution.
    (Pun unintentional but very appropriate.)

*/

type Ttre_backtrack_item_t = struct {
	Fpos      int32
	Fstr_byte uintptr
	Fstate    uintptr
	Fstate_id int32
	Fnext_c   int32
	Ftags     uintptr
}

type Ttre_backtrack_t = uintptr

type Ttre_backtrack_struct = struct {
	Fitem Ttre_backtrack_item_t
	Fprev uintptr
	Fnext uintptr
}

func _tre_tnfa_run_backtrack(tls *TLS, tnfa uintptr, string1 uintptr, len1 int32, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var bt, bt_len, cflags, empty_br_match, eo, i, i1, i2, i3, i4, match_eo, next_c_start, pos, pos_add_next, pos_start, prev_c, reg_newline, reg_notbol, reg_noteol, result, ret, so, v1, v11, v5, v6 int32
	var mem, next_state, next_tags, pmatch, s, s1, stack, state, states_seen, str_byte, str_byte_start, tags, tmp, tmp1, trans_i, trans_i1, v2, v9 uintptr
	var v10 bool
	var _ /* next_c at bp+0 */ int32
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = 0
	*(*int32)(unsafe.Pointer(bp)) = 0
	str_byte = string1
	pos = 0
	pos_add_next = int32(1)
	reg_notbol = eflags & int32(m_REG_NOTBOL)
	reg_noteol = eflags & int32(m_REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(m_REG_NEWLINE)
	/* These are used to remember the necessary values of the above
	   variables to return to the position where the current search
	   started from. */
	pos_start = -int32(1)
	/* Compilation flags for this regexp. */
	cflags = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags
	/* End offset of best match so far, or -1 if no match found yet. */
	match_eo = -int32(1)
	/* Tag arrays. */
	tags = UintptrFromInt32(0)
	/* Current TNFA state. */
	states_seen = UintptrFromInt32(0)
	/* Memory allocator to for allocating the backtracking stack. */
	mem = x___tre_mem_new_impl(tls, 0, UintptrFromInt32(0))
	/* The backtracking stack. */
	pmatch = UintptrFromInt32(0)
	if !(mem != 0) {
		return int32(m_REG_ESPACE)
	}
	stack = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
	if !(stack != 0) {
		ret = int32(m_REG_ESPACE)
		goto error_exit
	}
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev = UintptrFromInt32(0)
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = UintptrFromInt32(0)
	tags = x_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
	if !(tags != 0) {
		ret = int32(m_REG_ESPACE)
		goto error_exit
	}
	pmatch = x_malloc(tls, uint64(16)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches))
	if !(pmatch != 0) {
		ret = int32(m_REG_ESPACE)
		goto error_exit
	}
	states_seen = x_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))
	if !(states_seen != 0) {
		ret = int32(m_REG_ESPACE)
		goto error_exit
	}
retry:
	{
		for i = 0; i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i++ {
			*(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) = -int32(1)
			if match_tags != 0 {
				*(*int32)(unsafe.Pointer(match_tags + uintptr(i)*4)) = -int32(1)
			}
		}
		for i = 0; i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
			*(*int32)(unsafe.Pointer(states_seen + uintptr(i)*4)) = 0
		}
	}
	state = UintptrFromInt32(0)
	pos = pos_start
	prev_c = *(*int32)(unsafe.Pointer(bp))
	pos += pos_add_next
	v1 = x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX))
	pos_add_next = v1
	if v1 <= 0 {
		if pos_add_next < 0 {
			return int32(m_REG_NOMATCH)
		} else {
			pos_add_next++
		}
	}
	str_byte += uintptr(pos_add_next)
	pos_start = pos
	next_c_start = *(*int32)(unsafe.Pointer(bp))
	str_byte_start = str_byte
	/* Handle initial states. */
	next_tags = UintptrFromInt32(0)
	for trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0; trans_i += 48 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*int32)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*int32)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0))) {
			continue
		}
		if state == UintptrFromInt32(0) {
			/* Start from this state. */
			state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
			next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
		} else {
			/* Backtrack to this state. */
			if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
				s = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
				if !(s != 0) {
					x___tre_mem_destroy(tls, mem)
					if tags != 0 {
						x_free(tls, tags)
					}
					if pmatch != 0 {
						x_free(tls, pmatch)
					}
					if states_seen != 0 {
						x_free(tls, states_seen)
					}
					return int32(m_REG_ESPACE)
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fprev = stack
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fnext = UintptrFromInt32(0)
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
				if !((*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags != 0) {
					x___tre_mem_destroy(tls, mem)
					if tags != 0 {
						x_free(tls, tags)
					}
					if pmatch != 0 {
						x_free(tls, pmatch)
					}
					if states_seen != 0 {
						x_free(tls, states_seen)
					}
					return int32(m_REG_ESPACE)
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s
				stack = s
			} else {
				stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
			}
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = *(*int32)(unsafe.Pointer(bp))
			for i1 = 0; i1 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i1++ {
				*(*int32)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i1)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i1)*4))
			}
			{
				tmp = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
				if tmp != 0 {
					for *(*int32)(unsafe.Pointer(tmp)) >= 0 {
						v2 = tmp
						tmp += 4
						*(*int32)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(v2)))*4)) = pos
					}
				}
			}
		}
	}
	if next_tags != 0 {
		for ; *(*int32)(unsafe.Pointer(next_tags)) >= 0; next_tags += 4 {
			*(*int32)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(next_tags)))*4)) = pos
		}
	}
	if state == UintptrFromInt32(0) {
		goto backtrack
	}
_4:
	if !(int32(1) != 0) {
		goto _3
	}
	if state == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
		if match_eo < pos || match_eo == pos && match_tags != 0 && _tre_tag_order(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tags, match_tags) != 0 {
			/* This match wins the previous match. */
			match_eo = pos
			if match_tags != 0 {
				for i2 = 0; i2 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i2++ {
					*(*int32)(unsafe.Pointer(match_tags + uintptr(i2)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i2)*4))
				}
			}
		}
		/* Our TNFAs never have transitions leaving from the final state,
		   so we jump right to backtracking. */
		goto backtrack
	}
	/* Go to the next character in the input string. */
	empty_br_match = 0
	trans_i1 = state
	if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate != 0 && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_BACKREF) != 0 {
		/* This is a back reference state.  All transitions leaving from
		   this state have the same back reference "assertion".  Instead
		   of reading the next character, we match the back reference. */
		bt = *(*int32)(unsafe.Pointer(trans_i1 + 36))
		/* Get the substring we need to match against.  Remember to
		   turn off REG_NOSUB temporarily. */
		_tre_fill_pmatch(tls, uint64(bt+int32(1)), pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&BoolInt32(!(Int32FromInt32(m_REG_NOSUB) != 0)), tnfa, tags, pos)
		so = int32((*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_so)
		eo = int32((*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_eo)
		bt_len = eo - so
		if len1 < 0 {
			result = x_strncmp(tls, string1+uintptr(so), str_byte-uintptr(1), uint64(bt_len))
		} else {
			if len1-pos < bt_len {
				result = int32(1)
			} else {
				result = x_memcmp(tls, string1+uintptr(so), str_byte-uintptr(1), uint64(bt_len))
			}
		}
		/* We can ignore multibyte characters here because the backref
		   string is already aligned at character boundaries. */
		if result == 0 {
			/* Back reference matched.  Check for infinite loop. */
			if bt_len == 0 {
				empty_br_match = int32(1)
			}
			if empty_br_match != 0 && *(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate_id)*4)) != 0 {
				goto backtrack
			}
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate_id)*4)) = empty_br_match
			/* Advance in input string and resync `prev_c', `next_c'
			and pos. */
			str_byte += uintptr(bt_len - int32(1))
			pos += bt_len - int32(1)
			prev_c = *(*int32)(unsafe.Pointer(bp))
			pos += pos_add_next
			v5 = x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX))
			pos_add_next = v5
			if v5 <= 0 {
				if pos_add_next < 0 {
					return int32(m_REG_NOMATCH)
				} else {
					pos_add_next++
				}
			}
			str_byte += uintptr(pos_add_next)
		} else {
			goto backtrack
		}
	} else {
		/* Check for end of string. */
		if len1 < 0 {
			if *(*int32)(unsafe.Pointer(bp)) == int32('\000') {
				goto backtrack
			}
		} else {
			if pos >= len1 {
				goto backtrack
			}
		}
		/* Read the next character. */
		prev_c = *(*int32)(unsafe.Pointer(bp))
		pos += pos_add_next
		v6 = x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX))
		pos_add_next = v6
		if v6 <= 0 {
			if pos_add_next < 0 {
				return int32(m_REG_NOMATCH)
			} else {
				pos_add_next++
			}
		}
		str_byte += uintptr(pos_add_next)
	}
	next_state = UintptrFromInt32(0)
	for trans_i1 = state; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate != 0; trans_i1 += 48 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fcode_min <= prev_c && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fcode_max >= prev_c {
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*int32)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*int32)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && !(cflags&Int32FromInt32(m_REG_ICASE) != 0) && !(x_iswctype(tls, prev_c, *(*int32)(unsafe.Pointer(trans_i1 + 36))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && cflags&int32(m_REG_ICASE) != 0 && (!(x_iswctype(tls, x_towlower(tls, prev_c), *(*int32)(unsafe.Pointer(trans_i1 + 36))) != 0) && !(x_iswctype(tls, x_towupper(tls, prev_c), *(*int32)(unsafe.Pointer(trans_i1 + 36))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fassertions&int32(m_ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fneg_classes, prev_c, cflags&int32(m_REG_ICASE)) != 0) {
				continue
			}
			if next_state == UintptrFromInt32(0) {
				/* First matching transition. */
				next_state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate
				next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Ftags
			} else {
				/* Second mathing transition.	 We may need to backtrack here
				   to take this transition instead of the first one, so we
				   push this transition in the backtracking stack so we can
				   jump back here if needed. */
				if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
					s1 = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
					if !(s1 != 0) {
						x___tre_mem_destroy(tls, mem)
						if tags != 0 {
							x_free(tls, tags)
						}
						if pmatch != 0 {
							x_free(tls, pmatch)
						}
						if states_seen != 0 {
							x_free(tls, states_seen)
						}
						return int32(m_REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fprev = stack
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fnext = UintptrFromInt32(0)
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags = x___tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
					if !((*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags != 0) {
						x___tre_mem_destroy(tls, mem)
						if tags != 0 {
							x_free(tls, tags)
						}
						if pmatch != 0 {
							x_free(tls, pmatch)
						}
						if states_seen != 0 {
							x_free(tls, states_seen)
						}
						return int32(m_REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s1
					stack = s1
				} else {
					stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Fstate_id
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = *(*int32)(unsafe.Pointer(bp))
				for i3 = 0; i3 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i3++ {
					*(*int32)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i3)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i3)*4))
				}
				{
					for tmp1 = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i1)).Ftags; tmp1 != 0 && *(*int32)(unsafe.Pointer(tmp1)) >= 0; tmp1 += 4 {
						*(*int32)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(tmp1)))*4)) = pos
					}
				}
			}
		}
	}
	if !(next_state != UintptrFromInt32(0)) {
		goto _7
	}
	/* Matching transitions were found.  Take the first one. */
	state = next_state
	/* Update the tag values. */
	if next_tags != 0 {
		for *(*int32)(unsafe.Pointer(next_tags)) >= 0 {
			v9 = next_tags
			next_tags += 4
			*(*int32)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(v9)))*4)) = pos
		}
	}
	goto _8
_7:
backtrack:
	/* A matching transition was not found.  Try to backtrack. */
	if (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev != 0 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate)).Fassertions != 0 && int32(m_ASSERT_BACKREF) != 0 {
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id)*4)) = 0
		}
		if v10 = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev != 0; !v10 {
			x___assert_fail(tls, ts+958, ts+938, int32(927), uintptr(unsafe.Pointer(&___func__10)))
		}
		_ = v10 || Int32FromInt32(0) != 0
		pos = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos
		str_byte = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte
		state = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate
		*(*int32)(unsafe.Pointer(bp)) = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c
		for i4 = 0; i4 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i4++ {
			*(*int32)(unsafe.Pointer(tags + uintptr(i4)*4)) = *(*int32)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i4)*4))
		}
		stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev
	} else {
		if match_eo < 0 {
			/* Try starting from a later position in the input string. */
			/* Check for end of string. */
			if len1 < 0 {
				if *(*int32)(unsafe.Pointer(bp)) == int32('\000') {
					goto _3
				}
			} else {
				if pos >= len1 {
					goto _3
				}
			}
			*(*int32)(unsafe.Pointer(bp)) = next_c_start
			str_byte = str_byte_start
			goto retry
		} else {
			goto _3
		}
	}
_8:
	goto _4
_3:
	if match_eo >= 0 {
		v11 = m_REG_OK
	} else {
		v11 = int32(m_REG_NOMATCH)
	}
	ret = v11
	*(*int32)(unsafe.Pointer(match_end_ofs)) = match_eo
error_exit:
	x___tre_mem_destroy(tls, mem)
	if tags != 0 {
		x_free(tls, tags)
	}
	if pmatch != 0 {
		x_free(tls, pmatch)
	}
	if states_seen != 0 {
		x_free(tls, states_seen)
	}
	return ret
}

var ___func__10 = [23]int8{'t', 'r', 'e', '_', 't', 'n', 'f', 'a', '_', 'r', 'u', 'n', '_', 'b', 'a', 'c', 'k', 't', 'r', 'a', 'c', 'k'}

/***********************************************************************
 from regexec.c
***********************************************************************/

// C documentation
//
//	/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
//	   endpoint values. */
func _tre_fill_pmatch(tls *TLS, nmatch uint64, pmatch uintptr, cflags int32, tnfa uintptr, tags uintptr, match_eo int32) {
	var i, j uint32
	var parents, submatch_data uintptr
	var v1, v4 int64
	var v2, v3 bool
	i = uint32(0)
	if match_eo >= 0 && !(cflags&Int32FromInt32(m_REG_NOSUB) != 0) {
		/* Construct submatch offsets from the tags. */
		submatch_data = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = int64(match_eo)
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = int64(*(*int32)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag)*4)))
			}
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = int64(match_eo)
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = int64(*(*int32)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag)*4)))
			}
			/* If either of the endpoints were not used, this submatch
			   was not part of the match. */
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so == int64(-int32(1)) || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
				v1 = int64(-Int32FromInt32(1))
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v1
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v1
			}
			i++
		}
		/* Reset all submatches that are not within all of their parent
		submatches. */
		i = uint32(0)
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
				if v2 = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so == int64(-int32(1)); !v2 {
					x___assert_fail(tls, ts+970, ts+938, int32(1031), uintptr(unsafe.Pointer(&___func__11)))
				}
				_ = v2 || Int32FromInt32(0) != 0
			}
			if v3 = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so <= (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo; !v3 {
				x___assert_fail(tls, ts+992, ts+938, int32(1032), uintptr(unsafe.Pointer(&___func__11)))
			}
			_ = v3 || Int32FromInt32(0) != 0
			parents = (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fparents
			if parents != UintptrFromInt32(0) {
				for j = uint32(0); *(*int32)(unsafe.Pointer(parents + uintptr(j)*4)) >= 0; j++ {
					if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so < (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_so || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo > (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_eo {
						v4 = int64(-Int32FromInt32(1))
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v4
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v4
					}
				}
			}
			i++
		}
	}
	for uint64(i) < nmatch {
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = int64(-int32(1))
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = int64(-int32(1))
		i++
	}
}

var ___func__11 = [16]int8{'t', 'r', 'e', '_', 'f', 'i', 'l', 'l', '_', 'p', 'm', 'a', 't', 'c', 'h'}

func _tre_match(tls *TLS, tnfa uintptr, string1 uintptr, len1 uint64, nmatch uint64, pmatch uintptr, eflags int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var status int32
	var tags uintptr
	var _ /* eo at bp+0 */ int32
	tags = UintptrFromInt32(0)
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > 0 && nmatch > uint64(0) {
		tags = x_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
		if tags == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
	}
	/* Dispatch to the appropriate matcher. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 {
		/* The regex has back references, use the backtracking matcher. */
		status = _tre_tnfa_run_backtrack(tls, tnfa, string1, int32(len1), tags, eflags, bp)
	} else {
		/* Exact matching, no back references, use the parallel matcher. */
		status = _tre_tnfa_run_parallel(tls, tnfa, string1, int32(len1), tags, eflags, bp)
	}
	if status == m_REG_OK {
		/* A match was found, so fill the submatch registers. */
		_tre_fill_pmatch(tls, nmatch, pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags, tnfa, tags, *(*int32)(unsafe.Pointer(bp)))
	}
	if tags != 0 {
		x_free(tls, tags)
	}
	return status
}

func x_regexec(tls *TLS, preg uintptr, str uintptr, nmatch uint64, pmatch uintptr, eflags int32) (r int32) {
	return _tre_match(tls, (*Tregex_t)(unsafe.Pointer(preg)).F__opaque, str, uint64(-Int32FromInt32(1)), nmatch, pmatch, eflags)
}

const m_TRE_MEM_BLOCK_SIZE = 1024

/* EOF */

// C documentation
//
//	/* Returns a new memory allocator or NULL if out of memory. */
func x___tre_mem_new_impl(tls *TLS, provided int32, provided_block uintptr) (r uintptr) {
	var mem uintptr
	if provided != 0 {
		mem = provided_block
		x_memset(tls, mem, 0, uint64(48))
	} else {
		mem = x_calloc(tls, uint64(1), uint64(48))
	}
	if mem == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	return mem
}

// C documentation
//
//	/* Frees the memory allocator and all memory allocated with it. */
func x___tre_mem_destroy(tls *TLS, mem uintptr) {
	var l, tmp uintptr
	l = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks
	for l != UintptrFromInt32(0) {
		x_free(tls, (*Ttre_list_t)(unsafe.Pointer(l)).Fdata)
		tmp = (*Ttre_list_t)(unsafe.Pointer(l)).Fnext
		x_free(tls, l)
		l = tmp
	}
	x_free(tls, mem)
}

// C documentation
//
//	/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
//	   allocated block or NULL if an underlying malloc() failed. */
func x___tre_mem_alloc_impl(tls *TLS, mem uintptr, provided int32, provided_block uintptr, zero int32, size uint64) (r uintptr) {
	var block_size int32
	var l, ptr uintptr
	var v1 uint64
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed != 0 {
		return UintptrFromInt32(0)
	}
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn < size {
		/* We need more memory than is available in the current block.
		Allocate a new block. */
		if provided != 0 {
			if provided_block == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = provided_block
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(m_TRE_MEM_BLOCK_SIZE)
		} else {
			if size*uint64(8) > uint64(m_TRE_MEM_BLOCK_SIZE) {
				block_size = int32(size * uint64(8))
			} else {
				block_size = int32(m_TRE_MEM_BLOCK_SIZE)
			}
			l = x_malloc(tls, uint64(16))
			if l == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fdata = x_malloc(tls, uint64(block_size))
			if (*Ttre_list_t)(unsafe.Pointer(l)).Fdata == UintptrFromInt32(0) {
				x_free(tls, l)
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fnext = UintptrFromInt32(0)
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent != UintptrFromInt32(0) {
				(*Ttre_list_t)(unsafe.Pointer((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent)).Fnext = l
			}
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks = l
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent = l
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = (*Ttre_list_t)(unsafe.Pointer(l)).Fdata
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(block_size)
		}
	}
	/* Make sure the next pointer will be aligned. */
	if (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8) != 0 {
		v1 = uint64(8) - (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8)
	} else {
		v1 = uint64(0)
	}
	size += v1
	/* Allocate from current block. */
	ptr = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr
	*(*uintptr)(unsafe.Pointer(mem + 16)) += uintptr(size)
	*(*uint64)(unsafe.Pointer(mem + 24)) -= size
	/* Set to zero if needed. */
	if zero != 0 {
		x_memset(tls, ptr, 0, size)
	}
	return ptr
}

const m___NR_poll = 7

type Tnfds_t = uint32

type Tpollfd = struct {
	Ffd      int32
	Fevents  int16
	Frevents int16
}

func x_poll(tls *TLS, fds uintptr, n uint32, timeout int32) (r1 int32) {
	var r int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall3(tls, int64(m___NR_poll), int64(fds), int64(n), int64(timeout)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_pselect6 = 270

func x_pselect(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, ts uintptr, mask uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var r int32
	var v2 int64
	var _ /* data at bp+0 */ [2]int64
	var _ /* ts_tmp at bp+16 */ Ttimespec
	*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
		0: int64(mask),
		1: int64(8)}
	if ts != 0 {
		*(*Ttimespec)(unsafe.Pointer(bp + 16)) = *(*Ttimespec)(unsafe.Pointer(ts))
	}
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	if ts != 0 {
		v2 = int64(bp + 16)
	} else {
		v2 = 0
	}
	r = int32(_syscall6(tls, int64(m___NR_pselect6), int64(n), int64(rfds), int64(wfds), int64(efds), v2, int64(bp)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_select = 23

func x_select(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, tv uintptr) (r1 int32) {
	var r int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall5(tls, int64(m___NR_select), int64(n), int64(rfds), int64(wfds), int64(efds), int64(tv)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_getitimer = 36

func x_getitimer(tls *TLS, which int32, old uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var ret, v1 int32
	var _ /* kold at bp+0 */ [4]int64
	v1 = int32(_syscall2(tls, int64(m___NR_getitimer), int64(which), int64(bp)))
	ret = v1
	if !(v1 != 0) {
		*(*Titimerval)(unsafe.Pointer(old)) = Titimerval{Fit_interval: Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[0], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)])}, Fit_value: Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)])}}
	}
	return ret
}

const m___NR_kill = 62

func x_kill(tls *TLS, pid int32, sig int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_kill), int64(pid), int64(sig)))
}

func x_killpg(tls *TLS, pgid int32, sig int32) (r int32) {
	if pgid < 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return x_kill(tls, -pgid, sig)
}

func x_raise(tls *TLS, sig int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_kill), _syscall0(tls, int64(39)), int64(sig)))
}

const m___NR_setitimer = 38

func x_setitimer(tls *TLS, which int32, new1 uintptr, old uintptr) (r int32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var ret, v1 int32
	var v2 int64
	var _ /* knew at bp+0 */ [4]int64
	var _ /* kold at bp+32 */ [4]int64
	*(*[4]int64)(unsafe.Pointer(bp)) = [4]int64{
		0: (*Titimerval)(unsafe.Pointer(new1)).Fit_interval.Ftv_sec,
		1: int64((*Titimerval)(unsafe.Pointer(new1)).Fit_interval.Ftv_usec),
		2: (*Titimerval)(unsafe.Pointer(new1)).Fit_value.Ftv_sec,
		3: int64((*Titimerval)(unsafe.Pointer(new1)).Fit_value.Ftv_usec)}
	if old != 0 {
		v2 = int64(bp + 32)
	} else {
		v2 = 0
	}
	v1 = int32(_syscall3(tls, int64(m___NR_setitimer), int64(which), int64(bp), v2))
	ret = v1
	if !(v1 != 0) && old != 0 {
		*(*Titimerval)(unsafe.Pointer(old)) = Titimerval{Fit_interval: Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp + 32)))[0], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(1)])}, Fit_value: Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(2)], Ftv_usec: int32((*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(3)])}}
	}
	return ret
}

const m_SA_RESTORER = 67108864
const m_SA_SIGINFO = 4
const m_SIGCANCEL = 32
const m_SIGSYSCALL = 33
const m___NR_rt_sigaction = 13

func x___libc_sigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r int32) {
	bp := tls.Alloc(304) /* tlsAllocs 304 maxVaListSize 0 */
	defer tls.Free(304)
	var pkold, pksa int64
	var v1 uintptr
	var _ /* kold at bp+152 */ struct {
		Fhandler  uintptr
		Fflags    uint64
		Frestorer uintptr
		Fmask     Tsigset_t
	}
	var _ /* ksa at bp+0 */ struct {
		Fhandler  uintptr
		Fflags    uint64
		Frestorer uintptr
		Fmask     Tsigset_t
	}
	pksa = 0
	pkold = 0
	if sa != 0 {
		(*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp))).Fhandler = *(*uintptr)(unsafe.Pointer(sa))
		(*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp))).Fflags = uint64((*Tsigaction)(unsafe.Pointer(sa)).Fsa_flags | int32(m_SA_RESTORER))
		if (*Tsigaction)(unsafe.Pointer(sa)).Fsa_flags&int32(m_SA_SIGINFO) != 0 {
			v1 = __ccgo_fp(___restore_rt)
		} else {
			v1 = __ccgo_fp(___restore)
		}
		(*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp))).Frestorer = v1
		(*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp))).Fmask = (*Tsigaction)(unsafe.Pointer(sa)).Fsa_mask
		pksa = int64(bp)
	}
	if old != 0 {
		pkold = int64(bp + 152)
	}
	if _syscall4(tls, int64(m___NR_rt_sigaction), int64(sig), pksa, pkold, int64(8)) != 0 {
		return -int32(1)
	}
	if old != 0 {
		*(*uintptr)(unsafe.Pointer(old)) = (*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp + 152))).Fhandler
		(*Tsigaction)(unsafe.Pointer(old)).Fsa_flags = int32((*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp + 152))).Fflags)
		(*Tsigaction)(unsafe.Pointer(old)).Fsa_mask = (*(*struct {
			Fhandler  uintptr
			Fflags    uint64
			Frestorer uintptr
			Fmask     Tsigset_t
		})(unsafe.Pointer(bp + 152))).Fmask
	}
	return 0
}

func x___sigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r int32) {
	if sig == int32(m_SIGCANCEL) || sig == int32(m_SIGSYSCALL) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return x___libc_sigaction(tls, sig, sa, old)
}

func x_sigaddset(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	s = uint32(sig - int32(1))
	if uint64(s) >= Uint64FromInt32(8)*Uint64FromInt64(128) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8)) |= uint64(1) << (uint64(s) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1)))
	return 0
}

const m___NR_sigaltstack = 131

func x_sigaltstack(tls *TLS, ss uintptr, old uintptr) (r int32) {
	/* depends on kernel struct matching */
	return int32(_syscall2(tls, int64(m___NR_sigaltstack), int64(ss), int64(old)))
}

func x_sigdelset(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	s = uint32(sig - int32(1))
	if uint64(s) >= Uint64FromInt32(8)*Uint64FromInt64(128) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8)) &= ^(Uint64FromUint64(1) << (uint64(s) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1))))
	return 0
}

func x_sigemptyset(tls *TLS, set uintptr) (r int32) {
	x_memset(tls, set, 0, uint64(128))
	return 0
}

func x_sigfillset(tls *TLS, set uintptr) (r int32) {
	x_memset(tls, set, -int32(1), uint64(128))
	return 0
}

func x_sighold(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	x_sigemptyset(tls, bp)
	if x_sigaddset(tls, bp, sig) < 0 {
		return -int32(1)
	}
	return x___sigprocmask(tls, m_SIG_BLOCK, bp, UintptrFromInt32(0))
}

func x_sigignore(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxVaListSize 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	x_sigemptyset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = UintptrFromInt32(1)
	(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags = 0
	return x___sigaction(tls, sig, bp, UintptrFromInt32(0))
}

const m_SA_RESTART = 268435456

func x_siginterrupt(tls *TLS, sig int32, flag int32) (r int32) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxVaListSize 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	x___sigaction(tls, sig, UintptrFromInt32(0), bp)
	if flag != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags)))) &= ^Int32FromInt32(m_SA_RESTART)
	} else {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags)))) |= int32(m_SA_RESTART)
	}
	return x___sigaction(tls, sig, bp, UintptrFromInt32(0))
}

func x_sigismember(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	s = uint32(sig - int32(1))
	if uint64(s) >= Uint64FromInt32(8)*Uint64FromInt64(128) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return BoolInt32(!!(*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8))&(Uint64FromUint64(1)<<(uint64(s)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))) != 0))
}

func x_siglongjmp(tls *TLS, buf uintptr, ret int32) {
	var flag, mask uintptr
	flag = buf + uintptr(Uint64FromInt64(72)/Uint64FromInt64(8))*8
	mask = flag + UintptrFromInt32(1)*8
	if *(*int64)(unsafe.Pointer(flag)) != 0 {
		x___sigprocmask(tls, int32(m_SIG_SETMASK), mask, UintptrFromInt32(0))
	}
	_longjmp(tls, buf, ret)
}

//#define LFS64_2(x, y) weak_alias(x, y)

func x_signal(tls *TLS, sig int32, func1 uintptr) (r uintptr) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxVaListSize 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	*(*uintptr)(unsafe.Pointer(bp)) = func1
	*(*int32)(unsafe.Pointer(bp + 136)) = int32(m_SA_RESTART)
	if x___sigaction(tls, sig, bp, bp) < 0 {
		return uintptr(-Int32FromInt32(1))
	}
	return *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler))))
}

func x_sigpause(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	if x___sigprocmask(tls, 0, UintptrFromInt32(0), bp) < 0 || x_sigdelset(tls, bp, sig) < 0 {
		return -int32(1)
	}
	return x_sigsuspend(tls, bp)
}

const m_SYSCALL_SIGSET_SIZE = 8
const m___NR_rt_sigpending = 127

func x_sigpending(tls *TLS, set uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_rt_sigpending), int64(set), int64(m_SYSCALL_SIGSET_SIZE)))
}

const m_SIG_UNBLOCK = 1
const m___NR_rt_sigprocmask = 14

func x___libc_sigprocmask(tls *TLS, how int32, set uintptr, old uintptr) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_rt_sigprocmask), int64(how), int64(set), int64(old), int64(8)))
}

func x___sigprocmask(tls *TLS, how int32, set uintptr, old uintptr) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* tmp at bp+0 */ Tsigset_t
	/* Quickly mask out bits 32 and 33 (thread control signals) */
	if 0 != 0 && how != int32(m_SIG_UNBLOCK) && *(*uint64)(unsafe.Pointer(set + uintptr(Uint64FromInt32(4)/Uint64FromInt64(8))*8))&(Uint64FromUint64(3)<<(Uint64FromInt32(32)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))) != 0 {
		*(*Tsigset_t)(unsafe.Pointer(bp)) = *(*Tsigset_t)(unsafe.Pointer(set))
		set = bp
		*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigset_t)(unsafe.Pointer(bp))).F__bits)) + uintptr(Uint64FromInt32(4)/Uint64FromInt64(8))*8)) &= ^(Uint64FromUint64(3) << (Uint64FromInt32(32) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1))))
	}
	return x___libc_sigprocmask(tls, how, set, old)
}

const m___NR_rt_sigqueueinfo = 129

func x_sigqueue(tls *TLS, pid int32, sig int32, value Tsigval) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* si at bp+0 */ Tsiginfo_t
	*(*int32)(unsafe.Pointer(bp)) = sig
	*(*int32)(unsafe.Pointer(bp + 8)) = -int32(1)
	*(*Tsigval)(unsafe.Pointer(bp + 24)) = value
	return int32(_syscall3(tls, int64(m___NR_rt_sigqueueinfo), int64(pid), int64(sig), int64(bp)))
}

func x_sigrelse(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	x_sigemptyset(tls, bp)
	if x_sigaddset(tls, bp, sig) < 0 {
		return -int32(1)
	}
	return x___sigprocmask(tls, int32(m_SIG_UNBLOCK), bp, UintptrFromInt32(0))
}

func x___libc_current_sigrtmax(tls *TLS) (r int32) {
	return int32(64)
}

func x___libc_current_sigrtmin(tls *TLS) (r int32) {
	return int32(34)
}

func x_sigset(tls *TLS, sig int32, handler uintptr) (r uintptr) {
	bp := tls.Alloc(432) /* tlsAllocs 432 maxVaListSize 0 */
	defer tls.Free(432)
	var v1 uintptr
	var _ /* mask at bp+304 */ Tsigset_t
	var _ /* sa at bp+0 */ Tsigaction
	var _ /* sa_old at bp+152 */ Tsigaction
	x_sigemptyset(tls, bp+304)
	if x_sigaddset(tls, bp+304, sig) < 0 {
		return uintptr(-Int32FromInt32(1))
	}
	if handler == UintptrFromInt32(2) {
		if x___sigaction(tls, sig, UintptrFromInt32(0), bp+152) < 0 {
			return uintptr(-Int32FromInt32(1))
		}
		if x___sigprocmask(tls, m_SIG_BLOCK, bp+304, bp+304) < 0 {
			return uintptr(-Int32FromInt32(1))
		}
	} else {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = handler
		(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags = 0
		x_sigemptyset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)))
		if x___sigaction(tls, sig, bp, bp+152) < 0 {
			return uintptr(-Int32FromInt32(1))
		}
		if x___sigprocmask(tls, int32(m_SIG_UNBLOCK), bp+304, bp+304) < 0 {
			return uintptr(-Int32FromInt32(1))
		}
	}
	if x_sigismember(tls, bp+304, sig) != 0 {
		v1 = UintptrFromInt32(2)
	} else {
		v1 = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 152))).F__sa_handler))))
	}
	return v1
}

const m___NR_rt_sigsuspend = 130

func x_sigsuspend(tls *TLS, mask uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_rt_sigsuspend), int64(mask), int64(128)))
}

const m___NR_rt_sigtimedwait = 128

func x_sigtimedwait(tls *TLS, mask uintptr, si uintptr, timeout uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1 int64
	var _ /* k_timeout at bp+0 */ [2]int64
	if timeout != 0 {
		(*(*[2]int64)(unsafe.Pointer(bp)))[0] = (*Ttimespec)(unsafe.Pointer(timeout)).Ftv_sec
		(*(*[2]int64)(unsafe.Pointer(bp)))[int32(1)] = int64((*Ttimespec)(unsafe.Pointer(timeout)).Ftv_nsec)
	}
	if timeout != 0 {
		v1 = int64(bp)
	} else {
		v1 = 0
	}
	return int32(_syscall4(tls, int64(m___NR_rt_sigtimedwait), int64(mask), int64(si), v1, int64(m_SYSCALL_SIGSET_SIZE)))
}

func x_sigwait(tls *TLS, mask uintptr, sig uintptr) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var _ /* si at bp+0 */ Tsiginfo_t
	if x_sigtimedwait(tls, mask, bp, UintptrFromInt32(0)) < 0 {
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(sig)) = (*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo
	return 0
}

func x_sigwaitinfo(tls *TLS, mask uintptr, si uintptr) (r int32) {
	return x_sigtimedwait(tls, mask, si, UintptrFromInt32(0))
}

const m___NR_chmod = 90

func x_chmod(tls *TLS, path uintptr, mode uint32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_chmod), int64(path), int64(mode)))
}

const m___NR_fchmod = 91

func x_fchmod(tls *TLS, fd int32, mode uint32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_fchmod), int64(fd), int64(mode)))
}

const m___NR_fchmodat = 268

func x_fchmodat(tls *TLS, fd int32, path uintptr, mode uint32, flag int32) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_fchmodat), int64(fd), int64(path), int64(mode), int64(flag)))
}

const m___NR_fstat = 5

func x_fstat(tls *TLS, fd int32, buf uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_fstat), int64(fd), int64(buf)))
}

const m___NR_newfstatat = 262

func x_fstatat(tls *TLS, fd int32, path uintptr, buf uintptr, flag int32) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_newfstatat), int64(fd), int64(path), int64(buf), int64(flag)))
}

const m___NR_fstatfs = 138

type Tstatvfs = struct {
	Ff_type     uint64
	Ff_bsize    uint64
	Ff_blocks   uint64
	Ff_bfree    uint64
	Ff_bavail   uint64
	Ff_files    uint64
	Ff_ffree    uint64
	Ff_fsid     uint64
	Ff_namemax  uint64
	Ff_frsize   uint64
	Ff_favail   uint64
	Ff_flag     uint64
	F__reserved [2]uint64
}

func x_fstatvfs(tls *TLS, fd int32, buf uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_fstatfs), int64(fd), int64(buf)))
}

const m___NR_lstat = 6

func x_lstat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_lstat), int64(path), int64(buf)))
}

const m___NR_mkdir = 83

func x_mkdir(tls *TLS, path uintptr, mode uint32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_mkdir), int64(path), int64(mode)))
}

const m___NR_mkdirat = 258

func x_mkdirat(tls *TLS, fd int32, path uintptr, mode uint32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_mkdirat), int64(fd), int64(path), int64(mode)))
}

const m_S_IFIFO = 4096

func x_mkfifo(tls *TLS, path uintptr, mode uint32) (r int32) {
	return x_mknod(tls, path, mode|uint32(m_S_IFIFO), uint64(0))
}

func x_mkfifoat(tls *TLS, fd int32, path uintptr, mode uint32) (r int32) {
	return x_mknodat(tls, fd, path, mode|uint32(m_S_IFIFO), uint64(0))
}

const m___NR_mknod = 133

func x_mknod(tls *TLS, path uintptr, mode uint32, dev uint64) (r int32) {
	/* since dev_t is system-specific anyway we defer to the idiotic
	 * legacy-compatible bitfield mapping of the type.. at least we've
	 * made it large enough to leave space for future expansion.. */
	return int32(_syscall3(tls, int64(m___NR_mknod), int64(path), int64(mode), int64(dev&uint64(0xffff))))
}

const m___NR_mknodat = 259

func x_mknodat(tls *TLS, fd int32, path uintptr, mode uint32, dev uint64) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_mknodat), int64(fd), int64(path), int64(mode), int64(dev&uint64(0xffff))))
}

const m___NR_stat = 4

func x_stat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_stat), int64(path), int64(buf)))
}

const m___NR_statfs = 137

func x_statvfs(tls *TLS, path uintptr, buf uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_statfs), int64(path), int64(buf)))
}

const m___NR_umask = 95

func x_umask(tls *TLS, mode uint32) (r uint32) {
	return uint32(_syscall1(tls, int64(m___NR_umask), int64(mode)))
}

func x___fclose_ca(tls *TLS, f uintptr) (r int32) {
	return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
}

const m_BUFSIZ = 1024
const m_F_NORD = 4
const m_F_NOWR = 8
const m_UNGET = 4

func x___fdopen(tls *TLS, fd int32, mode uintptr) (r uintptr) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var f, v1 uintptr
	var flags, plus, v2 int32
	var _ /* tio at bp+0 */ Ttermios
	plus = BoolInt32(!!(x_strchr(tls, mode, int32('+')) != 0))
	/* Check for valid initial mode character */
	if !(x_strchr(tls, ts+1027, int32(*(*int8)(unsafe.Pointer(mode)))) != 0) {
		return uintptr(0)
	}
	/* Allocate FILE+buffer or fail */
	v1 = x_malloc(tls, Uint64FromInt64(224)+Uint64FromInt32(m_UNGET)+Uint64FromInt32(m_BUFSIZ))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	/* Zero-fill only the struct, not the buffer */
	x_memset(tls, f, 0, uint64(224))
	/* Impose mode restrictions */
	if !(plus != 0) {
		if int32(*(*int8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(m_F_NOWR)
		} else {
			v2 = int32(m_F_NORD)
		}
		(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(v2)
	}
	/* Set append mode on fd if opened for append */
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('a') {
		flags = int32(_syscall3(tls, int64(m___NR_fcntl), int64(fd), int64(Int32FromInt32(3)), int64(Int32FromInt32(0))))
		_syscall3(tls, int64(m___NR_fcntl), int64(fd), int64(Int32FromInt32(4)), int64(flags|Int32FromInt32(02000)))
	}
	(*TFILE)(unsafe.Pointer(f)).Ffd = fd
	(*TFILE)(unsafe.Pointer(f)).Fbuf = f + uintptr(224) + uintptr(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(m_BUFSIZ)
	/* Activate line buffered mode for terminals */
	(*TFILE)(unsafe.Pointer(f)).Flbf = int8(-Int32FromInt32(1))
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_NOWR) != 0) && !(_syscall3(tls, int64(m___NR_ioctl), int64(fd), int64(Int32FromInt32(0x5401)), int64(bp)) != 0) {
		(*TFILE)(unsafe.Pointer(f)).Flbf = int8('\n')
	}
	/* Initialize op ptrs. No problem if some are unneeded. */
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(x___stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fwrite = __ccgo_fp(x___stdio_write)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(x___stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(x___stdio_close)
	/* Add new FILE to open file list */
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&x___ofl.Flock)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&x___ofl.Flock))
		_ = Int32FromInt32(1)
	}
	(*TFILE)(unsafe.Pointer(f)).Fnext = x___ofl.Fhead
	if x___ofl.Fhead != 0 {
		(*TFILE)(unsafe.Pointer(x___ofl.Fhead)).Fprev = f
	}
	x___ofl.Fhead = f
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___ofl.Flock)))) = 0
	return f
}

const m_F_PERM = 1

func x___fopen_rb_ca(tls *TLS, filename uintptr, f uintptr, buf uintptr, len1 uint64) (r uintptr) {
	x_memset(tls, f, 0, uint64(224))
	(*TFILE)(unsafe.Pointer(f)).Ffd = int32(_syscall3(tls, int64(m___NR_open), int64(filename), int64(Int32FromInt32(00)|Int32FromInt32(m_O_LARGEFILE)), int64(Int32FromInt32(0))))
	if (*TFILE)(unsafe.Pointer(f)).Ffd < 0 {
		return uintptr(0)
	}
	(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(Int32FromInt32(m_F_NOWR) | Int32FromInt32(m_F_PERM))
	(*TFILE)(unsafe.Pointer(f)).Fbuf = buf + uintptr(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = len1 - uint64(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(x___stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(x___stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(x___stdio_close)
	return f
}

func x___fpending(tls *TLS, f uintptr) (r uint64) {
	var v1 int64
	if (*TFILE)(unsafe.Pointer(f)).Fwend != 0 {
		v1 = int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase)
	} else {
		v1 = 0
	}
	return uint64(v1)
}

type Tofl = struct {
	Fhead        uintptr
	Flock        int32
	F__ccgo_pad2 [4]byte
}

const m_F_ERR = 32

func _overflow(tls *TLS, f uintptr, c int32) (r int32) {
	var v1, v2, v3, v4, v5, v6, v7, v8, v9 uintptr
	/* Initialize if we're not already writing */
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) {
		/* Fail if we're in error state or unwritable. */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(Int32FromInt32(m_F_ERR)|Int32FromInt32(m_F_NOWR)) != 0 {
			return -int32(1)
		}
		/* Set byte orientation -1,0=>-1; 1=>1 */
		*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
		/* Clear read buffer (easier than summoning nasal demons) */
		v2 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Frstop = v2
		v1 = v2
		(*TFILE)(unsafe.Pointer(f)).Frend = v1
		(*TFILE)(unsafe.Pointer(f)).Frpos = v1
		/* Activate write through the buffer */
		v3 = (*TFILE)(unsafe.Pointer(f)).Fbuf
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
		(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
		if int32((*TFILE)(unsafe.Pointer(f)).Flbf) < 0 {
			v4 = (*TFILE)(unsafe.Pointer(f)).Fwend - uintptr(1)
		} else {
			v4 = uintptr(0)
		}
		(*TFILE)(unsafe.Pointer(f)).Fwstop = v4
	}
	/* Buffer can always hold at least 1 byte... */
	if c != -int32(1) {
		v6 = f + 40
		v5 = *(*uintptr)(unsafe.Pointer(v6))
		*(*uintptr)(unsafe.Pointer(v6))++
		*(*uint8)(unsafe.Pointer(v5)) = uint8(c)
		if (*TFILE)(unsafe.Pointer(f)).Fwpos <= (*TFILE)(unsafe.Pointer(f)).Fwstop && c != int32((*TFILE)(unsafe.Pointer(f)).Flbf) {
			return c
		}
	}
	/* ...since if the next call fails, buffer is empty. */
	if (*(*func(*TLS, uintptr, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwbase, uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos)-int64((*TFILE)(unsafe.Pointer(f)).Fwbase))) < uint64(0) {
		*(*uint32)(unsafe.Pointer(f)) |= uint32(m_F_ERR)
		v9 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwstop = v9
		v8 = v9
		(*TFILE)(unsafe.Pointer(f)).Fwend = v8
		v7 = v8
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v7
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v7
		return -int32(1)
	}
	/* Buffer is empty so reset position to beginning */
	(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
	return c
}

func x___overflow(tls *TLS, f uintptr, c int32) (r int32) {
	return _overflow(tls, f, c&int32(0xff))
}

func x___oflow(tls *TLS, f uintptr) (r int32) {
	var v1 int32
	_overflow(tls, f, -int32(1))
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		v1 = -int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func init() {
	p := unsafe.Pointer(&x___fflush_on_exit)
	*(*uintptr)(unsafe.Add(p, 0)) = __ccgo_fp(x_fflush)
}

const m_LDBL_MAX_10_EXP = 308
const m_LDBL_MAX_EXP = 1024
const m_SIZE_L = 3
const m_SIZE_def = 0
const m_SIZE_l = 1
const m_SIZE_ll = 2

type Trctx_t = struct {
	Fread        uintptr
	Fopaque      uintptr
	Fwide        int32
	Fis_space    uintptr
	Fl           int32
	Fe           int32
	Fc           int32
	Fu           int32
	Fw           int32
	F__ccgo_pad9 [4]byte
}

type Trctx = Trctx_t

func _read(tls *TLS, r uintptr) (r1 int32) {
	var v1, v3 int32
	var v2 uintptr
	v2 = r + 48
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	if v1 < 0 {
		v3 = -Int32FromInt32(1)
		(*Trctx_t)(unsafe.Pointer(r)).Fw = v3
		return v3
	}
	if (*Trctx_t)(unsafe.Pointer(r)).Fu != 0 {
		(*Trctx_t)(unsafe.Pointer(r)).Fu = 0
	} else {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*Trctx_t)(unsafe.Pointer(r)).Fread})))(tls, r)
	}
	return (*Trctx_t)(unsafe.Pointer(r)).Fc
}

func _unread(tls *TLS, r uintptr) {
	//if (r->u || r->w < 0) return;
	if (*Trctx_t)(unsafe.Pointer(r)).Fw < 0 {
		return
	}
	(*Trctx_t)(unsafe.Pointer(r)).Fw++
	(*Trctx_t)(unsafe.Pointer(r)).Fu = int32(1)
}

func _store_int(tls *TLS, dest uintptr, size int32, neg int32, i uint64) {
	if !(dest != 0) {
		return
	}
	if neg != 0 {
		i = -i
	}
	switch size {
	case -int32(2):
		*(*int8)(unsafe.Pointer(dest)) = int8(i)
	case -int32(1):
		*(*int16)(unsafe.Pointer(dest)) = int16(i)
	case m_SIZE_def:
		*(*int32)(unsafe.Pointer(dest)) = int32(i)
	case int32(m_SIZE_l):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
	case int32(m_SIZE_ll):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	}
}

func _arg_n(tls *TLS, ap uintptr, n uint32) (r uintptr) {
	var ap2, p uintptr
	var i uint32
	ap2 = ap
	for i = n; i > uint32(1); i-- {
		_ = VaUintptr(&ap2)
	}
	p = VaUintptr(&ap2)
	_ = ap2
	return p
}

func x___scanf(tls *TLS, r uintptr, fmt uintptr, ap uintptr) (r1 int32) {
	bp := tls.Alloc(280) /* tlsAllocs 280 maxVaListSize 0 */
	defer tls.Free(280)
	var c, en, en1, ex, ex1, invert, l, m, matches, mode, neg, pos, size, t, wide, width, v14, v17, v18, v22, v24, v25, v31, v32, v33, v34, v35, v36, v48, v49, v50, v51, v52, v54, v55, v57, v58, v60, v61, v62, v63, v64, v66, v67, v69, v70, v71, v73, v77, v78 int32
	var dest, is_space, p, s, wcs, z, v13, v15, v16, v19, v20, v21, v23, v26, v27, v28, v4, v5, v6, v72, v74, v75, v76, v79, v80 uintptr
	var f, mag, mag1 float64
	var i uint64
	var v53 bool
	var v59, v68 float32
	var _ /* ch at bp+16 */ int8
	var _ /* ch at bp+274 */ int8
	var _ /* ch at bp+275 */ int8
	var _ /* dummy at bp+0 */ int64
	var _ /* scanset at bp+17 */ [257]uint8
	var _ /* st at bp+8 */ Tmbstate_t
	mode = 0
	wide = (*Trctx_t)(unsafe.Pointer(r)).Fwide
	dest = UintptrFromInt32(0)
	i = uint64(0)
	neg = 0
	matches = 0
	is_space = (*Trctx_t)(unsafe.Pointer(r)).Fis_space
	p = fmt
_3:
	if !(*(*int32)(unsafe.Pointer(p)) != 0) {
		goto _1
	}
	if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, *(*int32)(unsafe.Pointer(p))) != 0 {
		for cond := true; cond; cond = (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, *(*int32)(unsafe.Pointer(p))) != 0 {
			p += 4
		}
		for cond := true; cond; cond = (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, _read(tls, r)) != 0 {
			(*Trctx_t)(unsafe.Pointer(r)).Fw = int32(1)
		}
		_unread(tls, r)
		goto _2
	} else if *(*int32)(unsafe.Pointer(p)) != int32('%') || *(*int32)(unsafe.Pointer(p + 1*4)) == int32('%') {
		if *(*int32)(unsafe.Pointer(p)) == int32('%') {
			p += 4
		}
		(*Trctx_t)(unsafe.Pointer(r)).Fw = int32(1)
		v4 = p
		p += 4
		if *(*int32)(unsafe.Pointer(v4)) != _read(tls, r) {
			goto match_fail
		}
		goto _2
	}
	p += 4
	if mode != int32(1) {
		for z = p; uint32(*(*int32)(unsafe.Pointer(z))-Int32FromUint8('0')) < uint32(10); z += 4 {
		}
		if *(*int32)(unsafe.Pointer(z)) != int32('$') && *(*int32)(unsafe.Pointer(z)) != int32('*') {
			if mode == 0 {
				mode = int32(1)
			} else {
				goto fmt_fail
			}
		} else if *(*int32)(unsafe.Pointer(z)) != int32('*') {
			pos = 0
			mode = int32(2)
			for ; p < z; p += 4 {
				pos = int32(10)*pos + *(*int32)(unsafe.Pointer(p)) - int32('0')
			}
			p += 4
			if !(pos != 0) {
				goto fmt_fail
			}
			dest = _arg_n(tls, ap, uint32(pos))
		}
	}
	if *(*int32)(unsafe.Pointer(p)) == int32('*') {
		dest = UintptrFromInt32(0)
		p += 4
	} else if mode == int32(1) {
		dest = VaUintptr(&ap)
	}
	if !(*(*int32)(unsafe.Pointer(p)) != 0) {
		goto fmt_fail
	}
	width = 0
	for ; uint32(*(*int32)(unsafe.Pointer(p))-Int32FromUint8('0')) < uint32(10); p += 4 {
		width = int32(10)*width + *(*int32)(unsafe.Pointer(p)) - int32('0')
	}
	size = 0
	v5 = p
	p += 4
	switch *(*int32)(unsafe.Pointer(v5)) {
	case 0:
		goto fmt_fail
	case int32('h'):
		if *(*int32)(unsafe.Pointer(p)) == int32('h') {
			p += 4
			size = -Int32FromInt32(2)
		} else {
			size = -int32(1)
		}
	case int32('l'):
		if *(*int32)(unsafe.Pointer(p)) == int32('l') {
			p += 4
			size = Int32FromInt32(m_SIZE_ll)
		} else {
			size = int32(m_SIZE_l)
		}
	case int32('j'):
		size = int32(m_SIZE_ll)
	case int32('z'):
		fallthrough
	case int32('t'):
		size = int32(m_SIZE_l)
	case int32('L'):
		size = int32(m_SIZE_L)
	case int32('d'):
		fallthrough
	case int32('i'):
		fallthrough
	case int32('o'):
		fallthrough
	case int32('u'):
		fallthrough
	case int32('x'):
		fallthrough
	case int32('a'):
		fallthrough
	case int32('e'):
		fallthrough
	case int32('f'):
		fallthrough
	case int32('g'):
		fallthrough
	case int32('A'):
		fallthrough
	case int32('E'):
		fallthrough
	case int32('F'):
		fallthrough
	case int32('G'):
		fallthrough
	case int32('X'):
		fallthrough
	case int32('s'):
		fallthrough
	case int32('c'):
		fallthrough
	case int32('['):
		fallthrough
	case int32('S'):
		fallthrough
	case int32('C'):
		fallthrough
	case int32('p'):
		fallthrough
	case int32('n'):
		p -= 4
	default:
		goto fmt_fail
	}
	v6 = p
	p += 4
	t = *(*int32)(unsafe.Pointer(v6))
	switch t {
	case int32('C'):
		fallthrough
	case int32('c'):
		if width < int32(1) {
			width = int32(1)
		}
		fallthrough
	case int32('s'):
		if size == int32(m_SIZE_l) {
			t &= ^Int32FromInt32(0x20)
		}
		fallthrough
	case int32('d'):
		fallthrough
	case int32('i'):
		fallthrough
	case int32('o'):
		fallthrough
	case int32('u'):
		fallthrough
	case int32('x'):
		fallthrough
	case int32('a'):
		fallthrough
	case int32('e'):
		fallthrough
	case int32('f'):
		fallthrough
	case int32('g'):
		fallthrough
	case int32('A'):
		fallthrough
	case int32('E'):
		fallthrough
	case int32('F'):
		fallthrough
	case int32('G'):
		fallthrough
	case int32('X'):
		fallthrough
	case int32('['):
		fallthrough
	case int32('S'):
		fallthrough
	case int32('p'):
		fallthrough
	case int32('n'):
		if width < int32(1) {
			width = int32(m_INT_MAX)
		}
	default:
		goto fmt_fail
	}
	(*Trctx_t)(unsafe.Pointer(r)).Fw = width
	if t != int32('n') {
		if _read(tls, r) < 0 {
			goto input_fail
		}
		_unread(tls, r)
	}
	switch t {
	case int32('n'):
		goto _7
	case int32('C'):
		goto _8
	case int32('c'):
		goto _9
	case int32('['):
		goto _10
	default:
		goto _11
	}
	goto _12
_7:
	_store_int(tls, dest, size, 0, uint64((*Trctx_t)(unsafe.Pointer(r)).Fl-(*Trctx_t)(unsafe.Pointer(r)).Fu))
	/* do not increment match count, etc! */
	goto _2
_8:
	if dest != 0 {
		v13 = dest
	} else {
		v13 = bp
	}
	wcs = v13
	*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
	for {
		v14 = _read(tls, r)
		c = v14
		if !(v14 >= 0) {
			break
		}
		if wide != 0 {
			if dest != 0 {
				v15 = wcs
				wcs += 4
				*(*int32)(unsafe.Pointer(v15)) = c
			}
		} else {
			*(*int8)(unsafe.Pointer(bp + 16)) = int8(c)
			switch x_mbrtowc(tls, wcs, bp+16, uint64(1), bp+8) {
			case uint64(-Int32FromInt32(1)):
				goto enc_fail
			case uint64(-Int32FromInt32(2)):
			default:
				if dest != 0 {
					wcs += 4
				}
			}
		}
	}
	if (*Trctx_t)(unsafe.Pointer(r)).Fw > 0 {
		goto match_fail
	}
	goto _12
_9:
	if dest != 0 {
		v16 = dest
	} else {
		v16 = bp
	}
	s = v16
	for {
		v17 = _read(tls, r)
		c = v17
		if !(v17 >= 0) {
			break
		}
		if wide != 0 {
			v18 = x_wctomb(tls, s, c)
			l = v18
			if v18 < 0 {
				goto enc_fail
			}
			if dest != 0 {
				s += uintptr(l)
			}
		} else {
			if dest != 0 {
				v19 = s
				s++
				*(*int8)(unsafe.Pointer(v19)) = int8(c)
			}
		}
	}
	if (*Trctx_t)(unsafe.Pointer(r)).Fw > 0 {
		goto match_fail
	}
	goto _12
_10:
	if dest != 0 {
		v20 = dest
	} else {
		v20 = bp
	}
	wcs = v20
	if dest != 0 {
		v21 = dest
	} else {
		v21 = bp
	}
	s = v21
	if !(wide != 0) && size == int32(m_SIZE_l) {
		*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
	}
	if *(*int32)(unsafe.Pointer(p)) == int32('^') {
		p += 4
		invert = Int32FromInt32(1)
	} else {
		invert = 0
	}
	if wide != 0 {
		for m = 0; ; m = int32(1) {
			v22 = _read(tls, r)
			c = v22
			if !(v22 >= 0) {
				break
			}
			for z = p; *(*int32)(unsafe.Pointer(z)) != 0 && *(*int32)(unsafe.Pointer(z)) != c && (*(*int32)(unsafe.Pointer(z)) != int32(']') || z == p); z += 4 {
			}
			if !(*(*int32)(unsafe.Pointer(z)) != 0) {
				goto fmt_fail
			}
			if *(*int32)(unsafe.Pointer(z)) == c && (*(*int32)(unsafe.Pointer(z)) != int32(']') || z == p) {
				if invert != 0 {
					break
				}
			} else {
				if !(invert != 0) {
					break
				}
			}
			if size == int32(m_SIZE_l) {
				if dest != 0 {
					v23 = wcs
					wcs += 4
					*(*int32)(unsafe.Pointer(v23)) = c
				}
			} else {
				v24 = x_wctomb(tls, s, c)
				l = v24
				if v24 < 0 {
					goto enc_fail
				}
				if dest != 0 {
					s += uintptr(l)
				}
			}
		}
		for p += 4; *(*int32)(unsafe.Pointer(p)) != 0 && *(*int32)(unsafe.Pointer(p)) != int32(']'); p += 4 {
		}
		p += 4
	} else {
		x_memset(tls, bp+17, invert, uint64(257))
		(*(*[257]uint8)(unsafe.Pointer(bp + 17)))[0] = uint8(0)
		for z = p; *(*int32)(unsafe.Pointer(z)) != 0 && (*(*int32)(unsafe.Pointer(z)) != int32(']') || z == p); z += 4 {
			(*(*[257]uint8)(unsafe.Pointer(bp + 17)))[int32(1)+*(*int32)(unsafe.Pointer(z))] = uint8(int32(1) - invert)
		}
		if !(*(*int32)(unsafe.Pointer(z)) != 0) {
			goto fmt_fail
		}
		p = z + uintptr(1)*4
		c = 0
		for m = 0; ; m = int32(1) {
			v25 = _read(tls, r)
			c = v25
			if !((*(*[257]uint8)(unsafe.Pointer(bp + 17)))[v25+int32(1)] != 0) {
				break
			}
			if size == int32(m_SIZE_l) {
				*(*int8)(unsafe.Pointer(bp + 274)) = int8(c)
				switch x_mbrtowc(tls, wcs, bp+274, uint64(1), bp+8) {
				case uint64(-Int32FromInt32(1)):
					goto enc_fail
				case uint64(-Int32FromInt32(2)):
				default:
					if dest != 0 {
						wcs += 4
					}
				}
			} else {
				if dest != 0 {
					v26 = s
					s++
					*(*int8)(unsafe.Pointer(v26)) = int8(c)
				}
			}
		}
	}
	if !(m != 0) {
		goto match_fail
	}
	if dest != 0 {
		if size == int32(m_SIZE_l) {
			v27 = wcs
			wcs += 4
			*(*int32)(unsafe.Pointer(v27)) = 0
		} else {
			v28 = s
			s++
			*(*int8)(unsafe.Pointer(v28)) = 0
		}
	}
	goto _12
_11:
	/* read unlimited number of spaces, then reset width */
_30:
	(*Trctx_t)(unsafe.Pointer(r)).Fw = int32(1)
	v31 = _read(tls, r)
	c = v31
	if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, v31) != 0 {
		goto _30
	}
	goto _29
_29:
	if c < 0 {
		goto input_fail
	}
	_unread(tls, r)
	(*Trctx_t)(unsafe.Pointer(r)).Fw = width
_12:
	switch t {
	case int32('p'):
		fallthrough
	case int32('X'):
		t = int32('x')
		fallthrough
	case int32('d'):
		fallthrough
	case int32('i'):
		fallthrough
	case int32('o'):
		fallthrough
	case int32('u'):
		fallthrough
	case int32('x'):
		v33 = Int32FromInt32(0)
		neg = v33
		v32 = v33
		m = v32
		i = uint64(v32)
		v34 = _read(tls, r)
		c = v34
		if v34 == int32('-') {
			neg = int32(1)
		} else if c != int32('+') {
			_unread(tls, r)
		}
		switch t {
		case int32('i'):
			fallthrough
		case int32('x'):
			v35 = _read(tls, r)
			c = v35
			if v35 != int32('0') {
				if t == int32('i') {
					t = int32('d')
				}
				_unread(tls, r)
				break
			}
			v36 = _read(tls, r)
			c = v36
			if v36|int32(0x20) != int32('x') {
				if t == int32('i') {
					t = int32('o')
					/* lone 0 is valid octal */
					if uint32(c-Int32FromUint8('0')) >= uint32(8) {
						m = int32(1)
						goto int_finish
					}
				}
				_unread(tls, r)
				break
			}
			t = int32('x')
		}
	}
	switch t {
	case int32('u'):
		goto _37
	case int32('d'):
		goto _38
	case int32('o'):
		goto _39
	case int32('x'):
		goto _40
	case int32('g'):
		goto _41
	case int32('f'):
		goto _42
	case int32('e'):
		goto _43
	case int32('a'):
		goto _44
	case int32('S'):
		goto _45
	case int32('s'):
		goto _46
	}
	goto _47
_38:
_37:
	for m = 0; ; m = int32(1) {
		v48 = _read(tls, r)
		c = v48
		if !(uint32(v48-Int32FromUint8('0')) < uint32(10)) {
			break
		}
		i = uint64(10)*i + uint64(c) - uint64('0')
	}
	goto int_finish
_39:
	for m = 0; ; m = int32(1) {
		v49 = _read(tls, r)
		c = v49
		if !(uint32(v49)-uint32('0') < uint32(8)) {
			break
		}
		i = i<<int32(3) + uint64(c) - uint64('0')
	}
	goto int_finish
_40:
	for m = 0; ; m = int32(1) {
		v50 = _read(tls, r)
		c = v50
		if uint32(v50-Int32FromUint8('0')) < uint32(10) {
			i = i<<int32(4) + uint64(c) - uint64('0')
		} else {
			if uint32(c|Int32FromInt32(0x20))-uint32('a') < uint32(6) {
				i = i<<int32(4) + uint64(c|Int32FromInt32(0x20)) - uint64('a') + uint64(10)
			} else {
				break
			}
		}
	}
int_finish:
	if !(m != 0) {
		goto match_fail
	}
	_store_int(tls, dest, size, neg, i)
	goto _47
_44:
_43:
_42:
_41:
	f = Float64FromFloat64(0)
	v51 = Int32FromInt32(0)
	m = v51
	neg = v51
	v52 = _read(tls, r)
	c = v52
	if v52 == int32('-') {
		neg = int32(1)
	} else if c != int32('+') {
		_unread(tls, r)
	}
	/* FIXME: check for INF/NAN strings here */
	if v53 = _read(tls, r) == int32('0'); v53 {
		m = int32(1)
	}
	if v53 && _read(tls, r)|Int32FromInt32(0x20) == Int32FromUint8('x') {
		goto hexfloat
	} else {
		_unread(tls, r)
	}
	for ; ; m = int32(1) {
		v54 = _read(tls, r)
		c = v54
		if !(uint32(v54-Int32FromUint8('0')) < uint32(10)) {
			break
		}
		f = Float64FromFloat64(10)*f + float64(c-Int32FromUint8('0'))
	}
	if c == int32('.') {
		mag = float64(10)
		for {
			v55 = _read(tls, r)
			c = v55
			if !(uint32(v55-Int32FromUint8('0')) < uint32(10)) {
				break
			}
			f += float64(c-Int32FromUint8('0')) / mag
			goto _56
		_56:
			mag *= float64(10)
		}
	}
	if c|int32(0x20) == int32('e') {
		ex = 0
		en = 0
		m = 0
		v57 = _read(tls, r)
		c = v57
		if v57 == int32('-') {
			en = int32(1)
		} else if c != int32('+') {
			_unread(tls, r)
		}
		for ; ; m = int32(1) {
			v58 = _read(tls, r)
			c = v58
			if !(uint32(v58-Int32FromUint8('0')) < uint32(10)) {
				break
			}
			if ex < int32(m_LDBL_MAX_10_EXP) {
				ex = int32(10)*ex + (c - int32('0'))
			}
		}
		if ex > int32(m_LDBL_MAX_10_EXP) {
			if en != 0 {
				v59 = Float32FromInt32(0)
			} else {
				v60 = int32(0x7f800000)
				v59 = *(*float32)(unsafe.Pointer(&v60))
			}
			f = float64(v59)
		} else {
			if en != 0 {
				for {
					v61 = ex
					ex--
					if !(v61 != 0) {
						break
					}
					f /= Float64FromFloat64(10)
				}
			} else {
				for {
					v62 = ex
					ex--
					if !(v62 != 0) {
						break
					}
					f *= Float64FromFloat64(10)
				}
			}
		}
	}
	goto writefloat
hexfloat:
	m = 0
	for ; ; m = int32(1) {
		v63 = _read(tls, r)
		c = v63
		if !(x_isxdigit(tls, v63) != 0) {
			break
		}
		if uint32(c-Int32FromUint8('0')) < uint32(10) {
			f = Float64FromFloat64(16)*f + float64(c-Int32FromUint8('0'))
		} else {
			f = Float64FromFloat64(16)*f + float64(c|Int32FromInt32(32)-Int32FromUint8('a')+Int32FromInt32(10))
		}
	}
	if c == int32('.') {
		mag1 = Float64FromInt32(1) / Float64FromFloat64(16)
		for {
			v64 = _read(tls, r)
			c = v64
			if !(x_isxdigit(tls, v64) != 0) {
				break
			}
			if uint32(c-Int32FromUint8('0')) < uint32(10) {
				f += float64(c-Int32FromUint8('0')) * mag1
			} else {
				f += float64(c|Int32FromInt32(32)-Int32FromUint8('a')+Int32FromInt32(10)) * mag1
			}
			goto _65
		_65:
			mag1 *= Float64FromInt32(1) / Float64FromFloat64(16)
		}
	}
	if c|int32(0x20) == int32('p') {
		ex1 = 0
		en1 = 0
		m = 0
		v66 = _read(tls, r)
		c = v66
		if v66 == int32('-') {
			en1 = int32(1)
		} else if c != int32('+') {
			_unread(tls, r)
		}
		for ; ; m = int32(1) {
			v67 = _read(tls, r)
			c = v67
			if !(uint32(v67-Int32FromUint8('0')) < uint32(10)) {
				break
			}
			if ex1 < int32(m_LDBL_MAX_EXP) {
				ex1 = int32(10)*ex1 + (c - int32('0'))
			}
		}
		if ex1 > int32(m_LDBL_MAX_EXP) {
			if en1 != 0 {
				v68 = Float32FromInt32(0)
			} else {
				v69 = int32(0x7f800000)
				v68 = *(*float32)(unsafe.Pointer(&v69))
			}
			f = float64(v68)
		} else {
			if en1 != 0 {
				for {
					v70 = ex1
					ex1--
					if !(v70 != 0) {
						break
					}
					f *= Float64FromFloat64(0.5)
				}
			} else {
				for {
					v71 = ex1
					ex1--
					if !(v71 != 0) {
						break
					}
					f *= Float64FromFloat64(2)
				}
			}
		}
	}
writefloat:
	if !(m != 0) {
		goto match_fail
	}
	if neg != 0 {
		f *= -Float64FromFloat64(1)
	}
	if dest != 0 {
		switch size {
		case m_SIZE_def:
			*(*float32)(unsafe.Pointer(dest)) = float32(f)
		case int32(m_SIZE_l):
			*(*float64)(unsafe.Pointer(dest)) = f
		case int32(m_SIZE_L):
			*(*float64)(unsafe.Pointer(dest)) = f
			break
		}
	}
	goto _47
_45:
	if dest != 0 {
		v72 = dest
	} else {
		v72 = bp
	}
	wcs = v72
	*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
	for {
		v73 = _read(tls, r)
		c = v73
		if !(v73 >= 0) {
			break
		}
		if wide != 0 {
			if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, c) != 0 {
				break
			}
			if dest != 0 {
				v74 = wcs
				wcs += 4
				*(*int32)(unsafe.Pointer(v74)) = c
			}
		} else {
			*(*int8)(unsafe.Pointer(bp + 275)) = int8(c)
			if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, c) != 0 {
				break
			}
			switch x_mbrtowc(tls, wcs, bp+275, uint64(1), bp+8) {
			case uint64(-Int32FromInt32(1)):
				goto enc_fail
			case uint64(-Int32FromInt32(2)):
			default:
				if dest != 0 {
					wcs += 4
				}
			}
		}
	}
	if dest != 0 {
		v75 = wcs
		wcs += 4
		*(*int32)(unsafe.Pointer(v75)) = 0
	}
	goto _47
_46:
	if dest != 0 {
		v76 = dest
	} else {
		v76 = bp
	}
	s = v76
	for {
		v77 = _read(tls, r)
		c = v77
		if !(v77 >= 0) {
			break
		}
		if wide != 0 {
			if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, c) != 0 {
				break
			}
			v78 = x_wctomb(tls, s, c)
			l = v78
			if v78 < 0 {
				goto enc_fail
			}
			if dest != 0 {
				s += uintptr(l)
			}
		} else {
			if (*(*func(*TLS, int32) int32)(unsafe.Pointer(&struct{ uintptr }{is_space})))(tls, c) != 0 {
				break
			}
			if dest != 0 {
				v79 = s
				s++
				*(*int8)(unsafe.Pointer(v79)) = int8(c)
			}
		}
	}
	if dest != 0 {
		v80 = s
		s++
		*(*int8)(unsafe.Pointer(v80)) = 0
	}
	goto _47
_47:
	/* unread will do nothing if field width was exhausted */
	_unread(tls, r)
	if dest != 0 {
		matches++
	}
	goto _2
_2:
	goto _3
	goto _1
_1:
	return matches
enc_fail:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
fmt_fail:
input_fail:
	if !(matches != 0) {
		matches--
	}
match_fail:
	_unread(tls, r)
	return matches
}

const m___NR_close = 3

func x___stdio_close(tls *TLS, f uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_close), int64((*TFILE)(unsafe.Pointer(f)).Ffd)))
}

const m___NR_read = 0

func x___stdio_read(tls *TLS, f uintptr, buf uintptr, len1 uint64) (r uint64) {
	return uint64(_syscall3(tls, m___NR_read, int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(buf), int64(len1)))
}

const m___NR_lseek = 8

func _retneg1(tls *TLS, f uintptr, off int64, whence int32) (r int64) {
	return int64(-int32(1))
}

func x___stdio_seek(tls *TLS, f uintptr, off int64, whence int32) (r int64) {
	var ret int64
	ret = _syscall3(tls, int64(m___NR_lseek), int64((*TFILE)(unsafe.Pointer(f)).Ffd), off, int64(whence))
	/* Detect unseekable files and optimize future failures out */
	if ret < 0 && off == 0 && whence == int32(m_SEEK_CUR) {
		(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(_retneg1)
	}
	return ret
}

const m___NR_write = 1

func x___stdio_write(tls *TLS, f uintptr, buf uintptr, len1 uint64) (r uint64) {
	var cnt, v1 int64
	var stop uintptr
	var v2 bool
	stop = buf + uintptr(len1)
	cnt = int64(1)
	for {
		if v2 = buf < stop; v2 {
			v1 = _syscall3(tls, int64(m___NR_write), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(buf), int64(len1))
			cnt = v1
		}
		if !(v2 && v1 > 0) {
			break
		}
		goto _3
	_3:
		buf += uintptr(cnt)
	}
	return len1 - uint64(int64(stop)-int64(buf))
}

func x___uflow(tls *TLS, f uintptr) (r int32) {
	var v1, v2 uintptr
	if x___underflow(tls, f) < 0 {
		return -int32(1)
	} else {
		v2 = f + 8
		v1 = *(*uintptr)(unsafe.Pointer(v2))
		*(*uintptr)(unsafe.Pointer(v2))++
		return int32(*(*uint8)(unsafe.Pointer(v1)))
	}
	return r
}

const m_F_EOF = 16

func x___underflow(tls *TLS, f uintptr) (r int32) {
	var cnt, v1 int64
	var v3, v4, v5, p2 uintptr
	/* Read from buffer (Do we ever get called when this is true??) */
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Frstop {
		return int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos)))
	}
	/* Initialize if we're not already reading */
	if !((*TFILE)(unsafe.Pointer(f)).Frstop != 0) {
		/* Fail immediately if unreadable, eof, or error state. */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(Int32FromInt32(m_F_EOF)|Int32FromInt32(m_F_ERR)|Int32FromInt32(m_F_NORD)) != 0 {
			return -int32(1)
		}
		/* Set byte orientation -1,0=>-1; 1=>1 */
		*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
		/* Flush any unwritten output; fail on error. */
		if (*TFILE)(unsafe.Pointer(f)).Fwpos > (*TFILE)(unsafe.Pointer(f)).Fbuf && x___oflow(tls, f) != 0 {
			return -int32(1)
		}
		/* Disallow writes to buffer. */
		(*TFILE)(unsafe.Pointer(f)).Fwstop = uintptr(0)
	}
	/* Perform the underlying read operation */
	v1 = int64((*(*func(*TLS, uintptr, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, (*TFILE)(unsafe.Pointer(f)).Fbuf, (*TFILE)(unsafe.Pointer(f)).Fbuf_size))
	cnt = v1
	if v1+int64(1) <= int64(1) {
		/* Set flags and leave read mode */
		p2 = f
		*(*uint32)(unsafe.Pointer(p2)) = uint32(int64(*(*uint32)(unsafe.Pointer(p2))) | (Int64FromInt32(m_F_EOF) | cnt&Int64FromInt32(m_F_ERR)))
		v4 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Frstop = v4
		v3 = v4
		(*TFILE)(unsafe.Pointer(f)).Frend = v3
		(*TFILE)(unsafe.Pointer(f)).Frpos = v3
		return -int32(1)
	}
	/* Setup buffer pointers for reading from buffer */
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	v5 = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(cnt)
	(*TFILE)(unsafe.Pointer(f)).Frstop = v5
	(*TFILE)(unsafe.Pointer(f)).Frend = v5
	return int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos)))
}

func x_asprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vasprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func x_clearerr(tls *TLS, f uintptr) {
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^(Int32FromInt32(m_F_EOF) | Int32FromInt32(m_F_ERR)))
	*(*int32)(unsafe.Pointer(f + 140)) = 0
}

func x_dprintf(tls *TLS, fd int32, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vdprintf(tls, fd, fmt, ap)
	_ = ap
	return ret
}

func x_fclose(tls *TLS, f uintptr) (r1 int32) {
	var perm, r int32
	perm = int32((*TFILE)(unsafe.Pointer(f)).Fflags & uint32(m_F_PERM))
	if !(perm != 0) {
		if x___libc.Fthreads_minus_1 != 0 {
			x___lock(tls, uintptr(unsafe.Pointer(&x___ofl.Flock)))
			_ = Int32FromInt32(1)
		} else {
			_ = uintptr(unsafe.Pointer(&x___ofl.Flock))
			_ = Int32FromInt32(1)
		}
		if (*TFILE)(unsafe.Pointer(f)).Fprev != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fprev)).Fnext = (*TFILE)(unsafe.Pointer(f)).Fnext
		}
		if (*TFILE)(unsafe.Pointer(f)).Fnext != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext)).Fprev = (*TFILE)(unsafe.Pointer(f)).Fprev
		}
		if x___ofl.Fhead == f {
			x___ofl.Fhead = (*TFILE)(unsafe.Pointer(f)).Fnext
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___ofl.Flock)))) = 0
	}
	r = x_fflush(tls, f) | (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
	if !(perm != 0) {
		x_free(tls, f)
	}
	return r
}

func x_feof(tls *TLS, f uintptr) (r int32) {
	return BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0))
}

func x_ferror(tls *TLS, f uintptr) (r int32) {
	return BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_ERR) != 0))
}

func ___fflush_unlocked(tls *TLS, f uintptr) (r int32) {
	var v1 int32
	/* If writing, flush output. */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos > (*TFILE)(unsafe.Pointer(f)).Fbuf && x___oflow(tls, f) != 0 {
		return -int32(1)
	}
	/* If reading, sync position, per POSIX */
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Frend {
		(*(*func(*TLS, uintptr, int64, int32) int64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Frend), int32(m_SEEK_CUR))
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Frend
	/* Hook for special behavior on flush */
	if (*TFILE)(unsafe.Pointer(f)).Fflush != 0 {
		(*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fflush})))(tls, f)
	}
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		v1 = -int32(1)
	} else {
		v1 = 0
	}
	return v1
}

/* stdout.c will override this if linked */
var ___dummy = uintptr(0)

func x_fflush(tls *TLS, f uintptr) (r1 int32) {
	var next uintptr
	var r, v2 int32
	if f != 0 {
		if x___libc.Fthreads_minus_1 != 0 {
			x___lock(tls, f+140)
			_ = Int32FromInt32(1)
		} else {
			_ = f + 140
			_ = Int32FromInt32(1)
		}
		r = ___fflush_unlocked(tls, f)
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return r
	}
	if x___stdout_to_flush != 0 {
		v2 = x_fflush(tls, x___stdout_to_flush)
	} else {
		v2 = 0
	}
	r = v2
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&x___ofl.Flock)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&x___ofl.Flock))
		_ = Int32FromInt32(1)
	}
	for f = x___ofl.Fhead; f != 0; f = next {
		if x___libc.Fthreads_minus_1 != 0 {
			x___lock(tls, f+140)
			_ = Int32FromInt32(1)
		} else {
			_ = f + 140
			_ = Int32FromInt32(1)
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___ofl.Flock)))) = 0
		r |= ___fflush_unlocked(tls, f)
		if x___libc.Fthreads_minus_1 != 0 {
			x___lock(tls, uintptr(unsafe.Pointer(&x___ofl.Flock)))
			_ = Int32FromInt32(1)
		} else {
			_ = uintptr(unsafe.Pointer(&x___ofl.Flock))
			_ = Int32FromInt32(1)
		}
		next = (*TFILE)(unsafe.Pointer(f)).Fnext
		*(*int32)(unsafe.Pointer(f + 140)) = 0
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___ofl.Flock)))) = 0
	return r
}

func x_fgetc(tls *TLS, f uintptr) (r int32) {
	var c, v2 int32
	var v3, v4 uintptr
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Frstop {
		v4 = f + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
	} else {
		v2 = x___uflow(tls, f)
	}
	c = v2
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return c
}

func x_fgetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	var off int64
	off = x___ftello(tls, f)
	if off < 0 {
		return -int32(1)
	}
	*(*int64)(unsafe.Pointer(pos)) = off
	return 0
}

func x_fgets(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	var k, v4 uint64
	var p, z, v5 uintptr
	var v1 int32
	var v3 int64
	p = s
	v1 = n
	n--
	if !(v1 != 0) {
		return uintptr(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	for n != 0 && !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0) {
		z = x_memchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, int32('\n'), uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
		if z != 0 {
			v3 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
		} else {
			v3 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
		}
		k = uint64(v3)
		if k < uint64(n) {
			v4 = k
		} else {
			v4 = uint64(n)
		}
		k = v4
		x_memcpy(tls, p, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
		*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
		p += uintptr(k)
		n = int32(uint64(n) - k)
		if z != 0 {
			break
		}
		x___underflow(tls, f)
	}
	*(*int8)(unsafe.Pointer(p)) = 0
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		p = s
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	if p == s {
		v5 = uintptr(0)
	} else {
		v5 = s
	}
	return v5
}

func x___fgetwc_unlocked(tls *TLS, f uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var c, v1 int32
	var l uint64
	var _ /* b at bp+12 */ uint8
	var _ /* st at bp+0 */ Tmbstate_t
	var _ /* wc at bp+8 */ int32
	*(*Tmbstate_t)(unsafe.Pointer(bp)) = Tmbstate_t{}
	*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode + int32(1)
	/* Convert character from buffer if possible */
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Frend {
		l = x_mbrtowc(tls, bp+8, (*TFILE)(unsafe.Pointer(f)).Frpos, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)), bp)
		if l+uint64(2) >= uint64(2) {
			*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(l + BoolUint64(!(l != 0))) /* l==0 means 1 byte, null */
			return *(*int32)(unsafe.Pointer(bp + 8))
		}
		if l == uint64(-Int32FromInt32(1)) {
			(*TFILE)(unsafe.Pointer(f)).Frpos++
			return -Int32FromInt32(1)
		}
	} else {
		l = uint64(-Int32FromInt32(2))
	}
	/* Convert character byte-by-byte from __uflow */
	for l == uint64(-Int32FromInt32(2)) {
		v1 = x___uflow(tls, f)
		c = v1
		*(*uint8)(unsafe.Pointer(bp + 12)) = uint8(v1)
		if c < 0 {
			if !(x_mbsinit(tls, bp) != 0) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
			}
			return -Int32FromInt32(1)
		}
		l = x_mbrtowc(tls, bp+8, bp+12, uint64(1), bp)
		if l == uint64(-Int32FromInt32(1)) {
			return -Int32FromInt32(1)
		}
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return *(*int32)(unsafe.Pointer(bp + 8))
}

func x_fgetwc(tls *TLS, f uintptr) (r int32) {
	var c int32
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	c = x___fgetwc_unlocked(tls, f)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return c
}

func x_fgetws(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	var c, v1 int32
	var p, v3, v4 uintptr
	p = s
	v1 = n
	n--
	if !(v1 != 0) {
		return s
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	for ; n != 0; n-- {
		c = x___fgetwc_unlocked(tls, f)
		if c == -int32(1) {
			break
		}
		v3 = p
		p += 4
		*(*int32)(unsafe.Pointer(v3)) = c
		if c == int32('\n') {
			break
		}
	}
	*(*int32)(unsafe.Pointer(p)) = 0
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		p = s
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	if p == s {
		v4 = UintptrFromInt32(0)
	} else {
		v4 = s
	}
	return v4
}

func x_fileno(tls *TLS, f uintptr) (r int32) {
	return (*TFILE)(unsafe.Pointer(f)).Ffd
}

const m_O_APPEND = 1024

func x_fopen(tls *TLS, filename uintptr, mode uintptr) (r uintptr) {
	var f uintptr
	var fd, flags, plus int32
	plus = BoolInt32(!!(x_strchr(tls, mode, int32('+')) != 0))
	/* Check for valid initial mode character */
	if !(x_strchr(tls, ts+1027, int32(*(*int8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	/* Compute the flags to pass to open() */
	if plus != 0 {
		flags = int32(m_O_RDWR)
	} else {
		if int32(*(*int8)(unsafe.Pointer(mode))) == int32('r') {
			flags = m_O_RDONLY
		} else {
			flags = int32(m_O_WRONLY)
		}
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) != int32('r') {
		flags |= int32(m_O_CREAT)
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('w') {
		flags |= int32(m_O_TRUNC)
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('a') {
		flags |= int32(m_O_APPEND)
	}
	fd = int32(_syscall3(tls, int64(m___NR_open), int64(filename), int64(flags|int32(m_O_LARGEFILE)), int64(Int32FromInt32(0666))))
	if fd < 0 {
		return uintptr(0)
	}
	f = x___fdopen(tls, fd, mode)
	if f != 0 {
		return f
	}
	_syscall1(tls, int64(m___NR_close), int64(fd))
	return uintptr(0)
}

func x_fprintf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vfprintf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x_fputc(tls *TLS, c int32, f uintptr) (r int32) {
	var v2, v3 uintptr
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	if c != int32((*TFILE)(unsafe.Pointer(f)).Flbf) && (*TFILE)(unsafe.Pointer(f)).Fwpos+uintptr(1) < (*TFILE)(unsafe.Pointer(f)).Fwend {
		v3 = f + 40
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		*(*uint8)(unsafe.Pointer(v2)) = uint8(c)
	} else {
		c = x___overflow(tls, f, c)
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return c
}

func x_fputs(tls *TLS, s uintptr, f uintptr) (r int32) {
	var l uint64
	l = x_strlen(tls, s)
	if !(l != 0) {
		return 0
	}
	return int32(x_fwrite(tls, s, l, uint64(1), f)) - int32(1)
}

func x___fputwc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var l int32
	var v1, v2 uintptr
	var _ /* mbc at bp+0 */ [4]int8
	*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode + int32(1)
	if x_isascii(tls, c) != 0 {
		if c != int32((*TFILE)(unsafe.Pointer(f)).Flbf) && (*TFILE)(unsafe.Pointer(f)).Fwpos+uintptr(1) < (*TFILE)(unsafe.Pointer(f)).Fwend {
			v2 = f + 40
			v1 = *(*uintptr)(unsafe.Pointer(v2))
			*(*uintptr)(unsafe.Pointer(v2))++
			*(*uint8)(unsafe.Pointer(v1)) = uint8(c)
		} else {
			c = x___overflow(tls, f, c)
		}
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fwpos+uintptr(m_MB_LEN_MAX) < (*TFILE)(unsafe.Pointer(f)).Fwend {
			l = x_wctomb(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, c)
			if l < 0 {
				c = -Int32FromInt32(1)
			} else {
				*(*uintptr)(unsafe.Pointer(f + 40)) += uintptr(l)
			}
		} else {
			l = x_wctomb(tls, bp, c)
			if l < 0 || x___fwritex(tls, bp, uint64(l), f) < uint64(l) {
				c = -Int32FromInt32(1)
			}
		}
	}
	return c
}

func x_fputwc(tls *TLS, c int32, f uintptr) (r int32) {
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	c = x___fputwc_unlocked(tls, c, f)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return 0
}

func x_fputws(tls *TLS, _ws uintptr, f uintptr) (r int32) {
	bp := tls.Alloc(1032) /* tlsAllocs 1032 maxVaListSize 0 */
	defer tls.Free(1032)
	*(*uintptr)(unsafe.Pointer(bp)) = _ws
	var l, v2 uint64
	var v3 bool
	var _ /* buf at bp+8 */ [1024]uint8
	l = uint64(0)
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode + int32(1)
	for {
		if v3 = *(*uintptr)(unsafe.Pointer(bp)) != 0; v3 {
			v2 = x_wcsrtombs(tls, bp+8, bp, uint64(1024), uintptr(0))
			l = v2
		}
		if !(v3 && v2+uint64(1) > uint64(1)) {
			break
		}
		if x___fwritex(tls, bp+8, l, f) < l {
			*(*int32)(unsafe.Pointer(f + 140)) = 0
			return -int32(1)
		}
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return int32(l) /* 0 or -1 */
}

func x_fread(tls *TLS, destv uintptr, size uint64, nmemb uint64, f uintptr) (r uint64) {
	var dest, p4 uintptr
	var k, l, len1, v2 uint64
	dest = destv
	len1 = size * nmemb
	l = len1
	/* Never touch the file if length is zero.. */
	if !(l != 0) {
		return uint64(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	for {
		/* First exhaust the buffer. */
		if uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)) < l {
			v2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
		} else {
			v2 = l
		}
		k = v2
		x_memcpy(tls, dest, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
		*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
		dest += uintptr(k)
		l -= k
		/* Stop on EOF or errors */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(Int32FromInt32(m_F_EOF)|Int32FromInt32(m_F_ERR)|Int32FromInt32(m_F_NORD)) != 0 {
			goto eof
		}
		/* Done? Or going unbuffered? */
		if !(l != 0) || l > (*TFILE)(unsafe.Pointer(f)).Fbuf_size/uint64(2) {
			break
		}
		/* Otherwise, refill & read thru buffer. */
		x___underflow(tls, f)
	}
	/* Read the remainder directly */
	for l != 0 {
		k = (*(*func(*TLS, uintptr, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, dest, l)
		if k+uint64(1) <= uint64(1) {
			p4 = f
			*(*uint32)(unsafe.Pointer(p4)) = uint32(uint64(*(*uint32)(unsafe.Pointer(p4))) | (Uint64FromInt32(m_F_EOF) | Uint64FromInt32(m_F_ERR)&k))
			goto eof
		}
		goto _3
	_3:
		l -= k
		dest += uintptr(k)
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return nmemb
eof:
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return (len1 - l) / size
}

const m___NR_dup2 = 33

func x_freopen(tls *TLS, filename uintptr, mode uintptr, f uintptr) (r uintptr) {
	var f2 uintptr
	var fl int32
	x_fflush(tls, f)
	if !(filename != 0) {
		f2 = x_fopen(tls, ts+71, mode)
		if !(f2 != 0) {
			goto fail
		}
		fl = int32(_syscall3(tls, int64(m___NR_fcntl), int64((*TFILE)(unsafe.Pointer(f2)).Ffd), int64(Int32FromInt32(3)), int64(Int32FromInt32(0))))
		if fl < 0 || _syscall3(tls, int64(m___NR_fcntl), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(4)), int64(fl)) < 0 {
			goto fail2
		}
	} else {
		f2 = x_fopen(tls, filename, mode)
		if !(f2 != 0) {
			goto fail
		}
		if _syscall2(tls, int64(m___NR_dup2), int64((*TFILE)(unsafe.Pointer(f2)).Ffd), int64((*TFILE)(unsafe.Pointer(f)).Ffd)) < 0 {
			goto fail2
		}
	}
	(*TFILE)(unsafe.Pointer(f)).Fflags = (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_PERM) | (*TFILE)(unsafe.Pointer(f2)).Fflags
	(*TFILE)(unsafe.Pointer(f)).Fread = (*TFILE)(unsafe.Pointer(f2)).Fread
	(*TFILE)(unsafe.Pointer(f)).Fwrite = (*TFILE)(unsafe.Pointer(f2)).Fwrite
	(*TFILE)(unsafe.Pointer(f)).Fseek = (*TFILE)(unsafe.Pointer(f2)).Fseek
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = (*TFILE)(unsafe.Pointer(f2)).Fclose1
	(*TFILE)(unsafe.Pointer(f)).Fflush = (*TFILE)(unsafe.Pointer(f2)).Fflush
	x_fclose(tls, f2)
	return f
fail2:
	x_fclose(tls, f2)
fail:
	x_fclose(tls, f)
	return UintptrFromInt32(0)
}

func x_fscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vfscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x___fseeko_unlocked(tls *TLS, f uintptr, off int64, whence int32) (r int32) {
	var v1, v2 uintptr
	/* Adjust relative offset for unread data in buffer, if any. */
	if whence == int32(m_SEEK_CUR) {
		off -= int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	}
	/* If writing, flush output. */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos > (*TFILE)(unsafe.Pointer(f)).Fbuf && x___oflow(tls, f) != 0 {
		return -int32(1)
	}
	/* Perform the underlying seek operation. */
	if (*(*func(*TLS, uintptr, int64, int32) int64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, off, whence) < 0 {
		return -int32(1)
	}
	/* If seek succeeded, file is seekable and we discard read buffer. */
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frstop = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Frend = v1
	(*TFILE)(unsafe.Pointer(f)).Frpos = v1
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(m_F_EOF))
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return 0
}

func x___fseeko(tls *TLS, f uintptr, off int64, whence int32) (r int32) {
	var result int32
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	result = x___fseeko_unlocked(tls, f, off, whence)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return result
}

func x_fseek(tls *TLS, f uintptr, off int64, whence int32) (r int32) {
	return x___fseeko(tls, f, off, whence)
}

func x_fsetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	return x___fseeko(tls, f, *(*int64)(unsafe.Pointer(pos)), m_SEEK_SET)
}

const m_EOVERFLOW = 75
const m_LONG_MAX = 9223372036854775807

func x___ftello_unlocked(tls *TLS, f uintptr) (r int64) {
	var pos int64
	pos = (*(*func(*TLS, uintptr, int64, int32) int64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, 0, int32(m_SEEK_CUR))
	if pos < 0 {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return pos
	}
	/* Adjust for data in buffer. */
	return pos - (int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)) + (int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
}

func x___ftello(tls *TLS, f uintptr) (r int64) {
	var pos int64
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	pos = x___ftello_unlocked(tls, f)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return pos
}

func x_ftell(tls *TLS, f uintptr) (r int64) {
	var pos int64
	pos = x___ftello(tls, f)
	if pos > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return int64(-int32(1))
	}
	return pos
}

func x_fwide(tls *TLS, f uintptr, mode int32) (r int32) {
	if !((*TFILE)(unsafe.Pointer(f)).Fmode != 0) {
		(*TFILE)(unsafe.Pointer(f)).Fmode = mode>>(Uint64FromInt32(8)*Uint64FromInt64(4)-Uint64FromInt32(1)) | -(-mode >> (Uint64FromInt32(8)*Uint64FromInt64(4) - Uint64FromInt32(1)))
	}
	return (*TFILE)(unsafe.Pointer(f)).Fmode
}

func x___fwritex(tls *TLS, s uintptr, l uint64, f uintptr) (r uint64) {
	var i, k, v1 uint64
	i = uint64(0)
	k = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwend) - int64((*TFILE)(unsafe.Pointer(f)).Fwpos))
	/* Handle line-buffered mode by breaking into 2 parts */
	if int32((*TFILE)(unsafe.Pointer(f)).Flbf) >= 0 {
		/* Match /^(.*\n|)/ */
		for i = l; i != 0 && int32(*(*uint8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) != int32('\n'); i-- {
		}
		if i != 0 {
			(*TFILE)(unsafe.Pointer(f)).Flbf = int8(-Int32FromInt32(1))
			x___fwritex(tls, s, i, f)
			(*TFILE)(unsafe.Pointer(f)).Flbf = int8('\n')
			x___oflow(tls, f)
			if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
				v1 = uint64(0)
			} else {
				v1 = i + x___fwritex(tls, s+uintptr(i), l-i, f)
			}
			return v1
		}
	}
	/* Buffer initial segment */
	if k > l {
		k = l
	}
	x_memcpy(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, s, k)
	*(*uintptr)(unsafe.Pointer(f + 40)) += uintptr(k)
	if (*TFILE)(unsafe.Pointer(f)).Fwpos < (*TFILE)(unsafe.Pointer(f)).Fwend {
		return l
	}
	/* If there's work left to do, flush buffer */
	x___oflow(tls, f)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		return uint64(0)
	}
	/* If the remainder will not fit in buffer, write it directly */
	if l-k >= uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwend)-int64((*TFILE)(unsafe.Pointer(f)).Fwpos)) {
		return k + (*(*func(*TLS, uintptr, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, s+uintptr(k), l-k)
	}
	/* Otherwise, buffer the remainder */
	x_memcpy(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, s+uintptr(k), l-k)
	*(*uintptr)(unsafe.Pointer(f + 40)) += uintptr(l - k)
	return l
}

func x_fwrite(tls *TLS, src uintptr, size uint64, nmemb uint64, f uintptr) (r uint64) {
	var l uint64
	l = size * nmemb
	if !(l != 0) {
		return l
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	l = x___fwritex(tls, src, l, f)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return l / size
}

func x_fwscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vfwscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x_getc(tls *TLS, f uintptr) (r int32) {
	return x_fgetc(tls, f)
}

func x_getc_unlocked(tls *TLS, f uintptr) (r int32) {
	var v1 int32
	var v2, v3 uintptr
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Frstop {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___uflow(tls, f)
	}
	return v1
}

func x_getchar(tls *TLS) (r int32) {
	return x_fgetc(tls, Xstdin)
}

func x_getchar_unlocked(tls *TLS) (r int32) {
	var v1 int32
	var v2, v3 uintptr
	if (*TFILE)(unsafe.Pointer(Xstdin)).Frpos < (*TFILE)(unsafe.Pointer(Xstdin)).Frstop {
		v3 = Xstdin + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___uflow(tls, Xstdin)
	}
	return v1
}

func x_getdelim(tls *TLS, s uintptr, n uintptr, delim int32, f uintptr) (r int64) {
	var i, k uint64
	var tmp, z uintptr
	var v2 int64
	i = uint64(0)
	if !(n != 0) || !(s != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	}
	if !(*(*uintptr)(unsafe.Pointer(s)) != 0) {
		*(*uint64)(unsafe.Pointer(n)) = uint64(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	for !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0) {
		z = x_memchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, delim, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
		if z != 0 {
			v2 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
		} else {
			v2 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
		}
		k = uint64(v2)
		if i+k >= *(*uint64)(unsafe.Pointer(n)) {
			if k >= uint64(0xffffffffffffffff)-i {
				goto oom
			}
			*(*uint64)(unsafe.Pointer(n)) = i + k + uint64(1)
			if *(*uint64)(unsafe.Pointer(n)) < Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(2) {
				*(*uint64)(unsafe.Pointer(n)) *= uint64(2)
			}
			tmp = x_realloc(tls, *(*uintptr)(unsafe.Pointer(s)), *(*uint64)(unsafe.Pointer(n)))
			if !(tmp != 0) {
				*(*uint64)(unsafe.Pointer(n)) = i + k + uint64(1)
				tmp = x_realloc(tls, *(*uintptr)(unsafe.Pointer(s)), *(*uint64)(unsafe.Pointer(n)))
				if !(tmp != 0) {
					goto oom
				}
			}
			*(*uintptr)(unsafe.Pointer(s)) = tmp
		}
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(i), (*TFILE)(unsafe.Pointer(f)).Frpos, k)
		*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
		i += k
		if z != 0 {
			break
		}
		x___underflow(tls, f)
	}
	*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + uintptr(i))) = 0
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_EOF) != 0 || (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return int64(-int32(1))
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	if i > uint64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return int64(-int32(1))
	}
	return int64(i)
oom:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
	return int64(-int32(1))
}

func x_getline(tls *TLS, s uintptr, n uintptr, f uintptr) (r int64) {
	return x_getdelim(tls, s, n, int32('\n'), f)
}

func x_gets(tls *TLS, s uintptr) (r uintptr) {
	var ret uintptr
	ret = x_fgets(tls, s, int32(m_INT_MAX), Xstdin)
	if ret != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(x_strlen(tls, s)-uint64(1))))) == int32('\n') {
		*(*int8)(unsafe.Pointer(s + uintptr(x_strlen(tls, s)-uint64(1)))) = 0
	}
	return ret
}

func x_getw(tls *TLS, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var v1 int32
	var _ /* x at bp+0 */ int32
	if x_fread(tls, bp, uint64(4), uint64(1), f) != 0 {
		v1 = *(*int32)(unsafe.Pointer(bp))
	} else {
		v1 = -int32(1)
	}
	return v1
}

func x_getwc(tls *TLS, f uintptr) (r int32) {
	return x_fgetwc(tls, f)
}

func x_getwchar(tls *TLS) (r int32) {
	return x_fgetwc(tls, Xstdin)
}

func x_pclose(tls *TLS, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var _ /* status at bp+0 */ int32
	x_fclose(tls, f)
	for x_waitpid(tls, (*TFILE)(unsafe.Pointer(f)).Fpipe_pid, bp, 0) == -int32(1) {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EINTR) {
			return -int32(1)
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func x_perror(tls *TLS, msg uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 0 maxVaListSize 16 */
	defer tls.Free(24)
	if msg != 0 {
		x_fprintf(tls, Xstderr, ts+1031, VaList(bp+8, msg, x_strerror(tls, *(*int32)(unsafe.Pointer(x___errno_location(tls))))))
	} else {
		x_fprintf(tls, Xstderr, ts+1039, 0)
	}
}

func x_popen(tls *TLS, cmd uintptr, mode uintptr) (r uintptr) {
	bp := tls.Alloc(48) /* tlsAllocs 8 maxVaListSize 32 */
	defer tls.Free(48)
	var f, mi, modes uintptr
	var op, pid int32
	var _ /* p at bp+0 */ [2]int32
	modes = ts + 1043
	mi = x_strchr(tls, modes, int32(*(*int8)(unsafe.Pointer(mode))))
	if mi != 0 {
		op = int32(int64(mi) - int64(modes))
	} else {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	if x_pipe(tls, bp) != 0 {
		return UintptrFromInt32(0)
	}
	f = x___fdopen(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[op], mode)
	if !(f != 0) {
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[0])
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)])
		return UintptrFromInt32(0)
	}
	pid = x_fork(tls)
	switch pid {
	case -int32(1):
		x_fclose(tls, f)
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[0])
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)])
		return UintptrFromInt32(0)
	case 0:
		x_dup2(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)-op], int32(1)-op)
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[0])
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)])
		x_execl(tls, ts+1046, VaList(bp+16, ts+1054, ts+1057, cmd, UintptrFromInt32(0)))
		x__exit(tls, int32(127))
	}
	x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)-op])
	(*TFILE)(unsafe.Pointer(f)).Fpipe_pid = pid
	return f
}

func x_printf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vprintf(tls, fmt, ap)
	_ = ap
	return ret
}

func x_putc(tls *TLS, c int32, f uintptr) (r int32) {
	return x_fputc(tls, c, f)
}

func x_putc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	var v1 int32
	var v2 uint8
	var v3, v4 uintptr
	if (*TFILE)(unsafe.Pointer(f)).Fwpos < (*TFILE)(unsafe.Pointer(f)).Fwstop {
		v2 = uint8(c)
		v4 = f + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = x___overflow(tls, f, c)
	}
	return v1
}

func x_putchar(tls *TLS, c int32) (r int32) {
	return x_fputc(tls, c, Xstdout)
}

func x_putchar_unlocked(tls *TLS, c int32) (r int32) {
	var v1 int32
	var v2 uint8
	var v3, v4 uintptr
	if (*TFILE)(unsafe.Pointer(Xstdout)).Fwpos < (*TFILE)(unsafe.Pointer(Xstdout)).Fwstop {
		v2 = uint8(c)
		v4 = Xstdout + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = x___overflow(tls, Xstdout, c)
	}
	return v1
}

func x_puts(tls *TLS, s uintptr) (r int32) {
	return -BoolInt32(x_fputs(tls, s, Xstdout) < 0 || x_putchar(tls, int32('\n')) < 0)
}

func x_putw(tls *TLS, _x int32, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*int32)(unsafe.Pointer(bp)) = _x
	var v1 int32
	if x_fwrite(tls, bp, uint64(4), uint64(1), f) != 0 {
		v1 = *(*int32)(unsafe.Pointer(bp))
	} else {
		v1 = -int32(1)
	}
	return v1
}

func x_putwc(tls *TLS, c int32, f uintptr) (r int32) {
	return x_fputwc(tls, c, f)
}

func x_putwchar(tls *TLS, c int32) (r int32) {
	return x_fputwc(tls, c, Xstdout)
}

const m___NR_unlink = 87

func x_remove(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_unlink), int64(path)))
}

const m___NR_rename = 82

func x_rename(tls *TLS, old uintptr, new1 uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_rename), int64(old), int64(new1)))
}

func x_rewind(tls *TLS, f uintptr) {
	x_fseek(tls, f, 0, m_SEEK_SET)
}

func x_scanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vscanf(tls, fmt, ap)
	_ = ap
	return ret
}

const m__IOFBF = 0
const m__IONBF = 2

func x_setbuf(tls *TLS, f uintptr, buf uintptr) {
	var v1 int32
	if buf != 0 {
		v1 = m__IOFBF
	} else {
		v1 = int32(m__IONBF)
	}
	x_setvbuf(tls, f, buf, v1, uint64(m_BUFSIZ))
}

const m__IOLBF = 1

func x_setvbuf(tls *TLS, f uintptr, buf uintptr, type1 int32, size uint64) (r int32) {
	(*TFILE)(unsafe.Pointer(f)).Flbf = int8(-Int32FromInt32(1))
	if type1 == int32(m__IONBF) {
		(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(1)
	} else if type1 == int32(m__IOLBF) {
		(*TFILE)(unsafe.Pointer(f)).Flbf = int8('\n')
	}
	return 0
}

func x_snprintf(tls *TLS, s uintptr, n uint64, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vsnprintf(tls, s, n, fmt, ap)
	_ = ap
	return ret
}

func x_sprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vsprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func x_sscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vsscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

var _buf7 [5]uint8
var _f2 = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NORD)), Fbuf: uintptr(unsafe.Pointer(&_buf7)) + uintptr(m_UNGET), Fbuf_size: uint64(1), Ffd: int32(2), Fwrite: uintptr(0), Fseek: uintptr(0), Fclose1: uintptr(0)}

func init() {
	p := unsafe.Pointer(&_f2)
	*(*uintptr)(unsafe.Add(p, 192)) = __ccgo_fp(x___stdio_write)
	*(*uintptr)(unsafe.Add(p, 200)) = __ccgo_fp(x___stdio_seek)
	*(*uintptr)(unsafe.Add(p, 216)) = __ccgo_fp(x___stdio_close)
}

var _buf8 [1028]uint8
var _f3 = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NOWR)), Fbuf: uintptr(unsafe.Pointer(&_buf8)) + uintptr(m_UNGET), Fbuf_size: Uint64FromInt64(1028) - Uint64FromInt32(m_UNGET), Ffd: int32(0), Fread: uintptr(0), Fseek: uintptr(0), Fclose1: uintptr(0)}

func init() {
	p := unsafe.Pointer(&_f3)
	*(*uintptr)(unsafe.Add(p, 184)) = __ccgo_fp(x___stdio_read)
	*(*uintptr)(unsafe.Add(p, 200)) = __ccgo_fp(x___stdio_seek)
	*(*uintptr)(unsafe.Add(p, 216)) = __ccgo_fp(x___stdio_close)
}

var _buf9 [1028]uint8
var _f4 = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NORD)), Fbuf: uintptr(unsafe.Pointer(&_buf9)) + uintptr(m_UNGET), Fbuf_size: Uint64FromInt64(1028) - Uint64FromInt32(m_UNGET), Ffd: int32(1), Flbf: int8('\n'), Fwrite: uintptr(0), Fseek: uintptr(0), Fclose1: uintptr(0)}

func init() {
	p := unsafe.Pointer(&_f4)
	*(*uintptr)(unsafe.Add(p, 192)) = __ccgo_fp(x___stdio_write)
	*(*uintptr)(unsafe.Add(p, 200)) = __ccgo_fp(x___stdio_seek)
	*(*uintptr)(unsafe.Add(p, 216)) = __ccgo_fp(x___stdio_close)
}

func x_swscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vswscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

const m_F_OK = 0
const m_P_tmpdir = "/tmp"
const m_TMP_MAX = 10000
const m_W_OK = 2

func x_tempnam(tls *TLS, dir uintptr, pfx uintptr) (r uintptr) {
	bp := tls.Alloc(40) /* tlsAllocs 0 maxVaListSize 32 */
	defer tls.Free(40)
	var l, pid int32
	var s uintptr
	pid = x_getpid(tls)
	if !(dir != 0) {
		dir = ts + 1060
	}
	if !(pfx != 0) {
		pfx = ts + 1065
	}
	if x_access(tls, dir, Int32FromInt32(m_R_OK)|Int32FromInt32(m_W_OK)|Int32FromInt32(m_X_OK)) != 0 {
		return UintptrFromInt32(0)
	}
	l = int32(x_strlen(tls, dir) + uint64(1) + x_strlen(tls, pfx) + uint64(2) + Uint64FromInt64(4)*Uint64FromInt32(3)*Uint64FromInt32(2) + uint64(1))
	s = x_malloc(tls, uint64(l))
	if !(s != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return UintptrFromInt32(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock5)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock5))
		_ = Int32FromInt32(1)
	}
	for ; _index < int32(m_TMP_MAX); _index++ {
		x_snprintf(tls, s, uint64(l), ts+1070, VaList(bp+8, dir, pfx, pid, _index))
		if x_access(tls, s, m_F_OK) != 0 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock5)))) = 0
			return s
		}
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock5)))) = 0
	x_free(tls, s)
	return UintptrFromInt32(0)
}

var _lock5 int32

var _index int32

const m_L_tmpnam = 20

func x_tmpfile(tls *TLS) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxVaListSize 0 */
	defer tls.Free(24)
	var f, s uintptr
	var fd int32
	var _ /* buf at bp+0 */ [20]int8
	for {
		s = x_tmpnam(tls, bp)
		if !(s != 0) {
			return UintptrFromInt32(0)
		}
		fd = int32(_syscall3(tls, int64(m___NR_open), int64(s), int64(Int32FromInt32(02)|Int32FromInt32(0100)|Int32FromInt32(0200)|Int32FromInt32(m_O_LARGEFILE)), int64(Int32FromInt32(0600))))
		if fd >= 0 {
			f = x___fdopen(tls, fd, ts+1082)
			x_remove(tls, s)
			return f
		}
	}
	return r
}

func x_tmpnam(tls *TLS, s uintptr) (r uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 0 maxVaListSize 24 */
	defer tls.Free(32)
	var dir uintptr
	var pid int32
	pid = x_getpid(tls)
	dir = x_getenv(tls, ts+1085)
	if !(s != 0) {
		if !(_s2 != 0) {
			_s2 = x_malloc(tls, uint64(m_L_tmpnam))
		}
		s = _s2
	}
	/* this interface is insecure anyway but at least we can try.. */
	if !(dir != 0) || x_strlen(tls, dir) > uint64(Int32FromInt32(m_L_tmpnam)-Int32FromInt32(32)) {
		dir = ts + 1060
	}
	if x_access(tls, dir, Int32FromInt32(m_R_OK)|Int32FromInt32(m_W_OK)|Int32FromInt32(m_X_OK)) != 0 {
		return UintptrFromInt32(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock6)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock6))
		_ = Int32FromInt32(1)
	}
	for _index1++; _index1 < int32(m_TMP_MAX); _index1++ {
		x_snprintf(tls, s, uint64(m_L_tmpnam), ts+1092, VaList(bp+8, dir, pid, _index1))
		if x_access(tls, s, m_F_OK) != 0 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock6)))) = 0
			return s
		}
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock6)))) = 0
	return UintptrFromInt32(0)
}

var _lock6 int32

var _index1 int32

var _s2 uintptr

func x_ungetc(tls *TLS, c int32, f uintptr) (r int32) {
	var v2, v3, v4, v5, v6, v7 uintptr
	if c == -int32(1) {
		return c
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	/* Fail if unreadable or writing and unable to flush */
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(Int32FromInt32(m_F_ERR)|Int32FromInt32(m_F_NORD)) != 0 || (*TFILE)(unsafe.Pointer(f)).Fwpos != 0 && x___oflow(tls, f) != 0 {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return -int32(1)
	}
	/* Clear write mode */
	v4 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v4
	v3 = v4
	(*TFILE)(unsafe.Pointer(f)).Fwstop = v3
	v2 = v3
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
	/* Put the file in read mode */
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		v5 = (*TFILE)(unsafe.Pointer(f)).Fbuf
		(*TFILE)(unsafe.Pointer(f)).Frend = v5
		(*TFILE)(unsafe.Pointer(f)).Frpos = v5
	}
	/* If unget buffer is already full, fail. */
	if (*TFILE)(unsafe.Pointer(f)).Frpos <= (*TFILE)(unsafe.Pointer(f)).Fbuf-uintptr(m_UNGET) {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return -int32(1)
	}
	/* Put a byte back into the buffer */
	v7 = f + 8
	*(*uintptr)(unsafe.Pointer(v7))--
	v6 = *(*uintptr)(unsafe.Pointer(v7))
	*(*uint8)(unsafe.Pointer(v6)) = uint8(c)
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(m_F_EOF))
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return c
}

func x_ungetwc(tls *TLS, c int32, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var l, v1 int32
	var v2 bool
	var v4, v5, v6, v7, v8, p9 uintptr
	var _ /* mbc at bp+0 */ [4]uint8
	l = int32(1)
	if c == -int32(1) {
		return c
	}
	/* Try conversion early so we can fail without locking if invalid */
	if v2 = !(x_isascii(tls, c) != 0); v2 {
		v1 = x_wctomb(tls, bp, c)
		l = v1
	}
	if v2 && v1 < 0 {
		return -Int32FromInt32(1)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	*(*int32)(unsafe.Pointer(f + 208)) |= (*TFILE)(unsafe.Pointer(f)).Fmode + int32(1)
	/* Fail if unreadable or writing and unable to flush */
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(Int32FromInt32(m_F_ERR)|Int32FromInt32(m_F_NORD)) != 0 || (*TFILE)(unsafe.Pointer(f)).Fwpos != 0 && x___oflow(tls, f) != 0 {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return -Int32FromInt32(1)
	}
	/* Clear write mode */
	v5 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v5
	v4 = v5
	(*TFILE)(unsafe.Pointer(f)).Fwstop = v4
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v4
	/* Put the file in read mode */
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		v6 = (*TFILE)(unsafe.Pointer(f)).Fbuf
		(*TFILE)(unsafe.Pointer(f)).Frend = v6
		(*TFILE)(unsafe.Pointer(f)).Frpos = v6
	}
	/* If unget buffer is nonempty, fail. */
	if (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Fbuf {
		*(*int32)(unsafe.Pointer(f + 140)) = 0
		return -Int32FromInt32(1)
	}
	/* Put character back into the buffer */
	if x_isascii(tls, c) != 0 {
		v8 = f + 8
		*(*uintptr)(unsafe.Pointer(v8))--
		v7 = *(*uintptr)(unsafe.Pointer(v8))
		*(*uint8)(unsafe.Pointer(v7)) = uint8(c)
	} else {
		p9 = f + 8
		*(*uintptr)(unsafe.Pointer(p9)) -= uintptr(l)
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(p9)), bp, uint64(l))
	}
	/* Clear EOF */
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(m_F_EOF))
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return c
}

const m_GUESS = 240

func x_vasprintf(tls *TLS, s uintptr, fmt uintptr, ap uintptr) (r int32) {
	var a, ap2, b, v1, v2, v3 uintptr
	var l int32
	var v4 bool
	l = Int32FromUint32(240)
	v1 = x_malloc(tls, uint64(240))
	a = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	ap2 = ap
	l = x_vsnprintf(tls, a, uint64(240), fmt, ap2)
	_ = ap2
	if uint32(l) < uint32(240) {
		b = x_realloc(tls, a, uint64(uint32(l)+uint32(1)))
		if b != 0 {
			v2 = b
		} else {
			v2 = a
		}
		*(*uintptr)(unsafe.Pointer(s)) = v2
		return l
	}
	x_free(tls, a)
	if v4 = l < 0; !v4 {
		v3 = x_malloc(tls, uint64(uint32(l)+uint32(1)))
		*(*uintptr)(unsafe.Pointer(s)) = v3
	}
	if v4 || !(v3 != 0) {
		return -int32(1)
	}
	return x_vsnprintf(tls, *(*uintptr)(unsafe.Pointer(s)), uint64(uint32(l)+uint32(1)), fmt, ap)
}

func x_vdprintf(tls *TLS, fd int32, fmt uintptr, ap uintptr) (r1 int32) {
	bp := tls.Alloc(1248) /* tlsAllocs 1248 maxVaListSize 0 */
	defer tls.Free(1248)
	var r int32
	var _ /* buf at bp+0 */ [1024]int8
	var _ /* f at bp+1024 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp + 1024)) = TFILE{Fbuf: bp + uintptr(m_UNGET), Fbuf_size: Uint64FromInt64(1024) - Uint64FromInt32(m_UNGET), Ffd: fd, Flbf: int8(-Int32FromInt32(1)), Fwrite: __ccgo_fp(x___stdio_write)}
	r = x_vfprintf(tls, bp+1024, fmt, ap)
	x___oflow(tls, bp+1024)
	return r
}

const m_INTMAX_MAX = 9223372036854775807
const m_LDBL_MANT_DIG = 53
const m_LLONG = 12
const m_NL_ARGMAX = 9
const m_PDIFF = 13
const m_SIZET = 14
const m_UIPTR = 14
const m_ULONG_MAX = 18446744073709551615
const m_UMAX = 12

const _BARE = 0
const _LPRE = 1
const _LLPRE = 2
const _HPRE = 3
const _HHPRE = 4
const _BIGLPRE = 5
const _ZTPRE = 6
const _JPRE = 7
const _STOP = 8
const _PTR = 9
const _INT = 10
const _UINT = 11
const _ULLONG = 12
const _LONG = 13
const _ULONG = 14
const _SHORT = 15
const _USHORT = 16
const _CHAR = 17
const _UCHAR = 18
const _DBL = 19
const _LDBL = 20
const _NOARG = 21
const _MAXSTATE = 22

var _states = [8][58]uint8{
	0: {
		0:  uint8(_DBL),
		2:  uint8(_INT),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		11: uint8(_BIGLPRE),
		18: uint8(_PTR),
		23: uint8(_UINT),
		32: uint8(_DBL),
		34: uint8(_CHAR),
		35: uint8(_INT),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		39: uint8(_HPRE),
		40: uint8(_INT),
		41: uint8(_JPRE),
		43: uint8(_LPRE),
		44: uint8(_NOARG),
		45: uint8(_PTR),
		46: uint8(_UINT),
		47: uint8(_ULONG),
		50: uint8(_PTR),
		51: uint8(_ZTPRE),
		52: uint8(_UINT),
		55: uint8(_UINT),
		57: uint8(_ZTPRE)},
	1: {
		23: uint8(_ULONG),
		34: uint8(_INT),
		35: uint8(_LONG),
		40: uint8(_LONG),
		43: uint8(_LLPRE),
		45: uint8(_PTR),
		46: uint8(_ULONG),
		50: uint8(_PTR),
		52: uint8(_ULONG),
		55: uint8(_ULONG)},
	2: {
		23: uint8(_ULLONG),
		35: uint8(_ULLONG),
		40: uint8(_ULLONG),
		45: uint8(_PTR),
		46: uint8(_ULLONG),
		52: uint8(_ULLONG),
		55: uint8(_ULLONG)},
	3: {
		23: uint8(_USHORT),
		35: uint8(_SHORT),
		39: uint8(_HHPRE),
		40: uint8(_SHORT),
		45: uint8(_PTR),
		46: uint8(_USHORT),
		52: uint8(_USHORT),
		55: uint8(_USHORT)},
	4: {
		23: uint8(_UCHAR),
		35: uint8(_CHAR),
		40: uint8(_CHAR),
		45: uint8(_PTR),
		46: uint8(_UCHAR),
		52: uint8(_UCHAR),
		55: uint8(_UCHAR)},
	5: {
		0:  uint8(_LDBL),
		4:  uint8(_LDBL),
		5:  uint8(_LDBL),
		6:  uint8(_LDBL),
		32: uint8(_LDBL),
		36: uint8(_LDBL),
		37: uint8(_LDBL),
		38: uint8(_LDBL),
		45: uint8(_PTR)},
	6: {
		23: uint8(_ULONG),
		35: uint8(_LONG),
		40: uint8(_LONG),
		45: uint8(_PTR),
		46: uint8(_ULONG),
		52: uint8(_ULONG),
		55: uint8(_ULONG)},
	7: {
		23: uint8(_ULLONG),
		35: uint8(_ULLONG),
		40: uint8(_ULLONG),
		45: uint8(_PTR),
		46: uint8(_ULLONG),
		52: uint8(_ULLONG),
		55: uint8(_ULLONG)}}

type Targ = struct {
	Ff [0]float64
	Fp [0]uintptr
	Fi uint64
}

func _pop_arg(tls *TLS, arg uintptr, type1 int32, ap uintptr) {
	/* Give the compiler a hint for optimizing the switch. */
	if uint32(type1) > uint32(_MAXSTATE) {
		return
	}
	switch type1 {
	case int32(_PTR):
		*(*uintptr)(unsafe.Pointer(arg)) = VaUintptr(&*(*uintptr)(unsafe.Pointer(ap)))
	case int32(_INT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt32(&*(*uintptr)(unsafe.Pointer(ap))))
	case int32(_UINT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUint32(&*(*uintptr)(unsafe.Pointer(ap))))
	case int32(_LONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*uintptr)(unsafe.Pointer(ap))))
	case int32(_ULONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*uintptr)(unsafe.Pointer(ap)))
	case int32(_ULLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*uintptr)(unsafe.Pointer(ap)))
	case int32(_SHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int16(VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))))
	case int32(_USHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint16(VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))))
	case int32(_CHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int8(VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))))
	case int32(_UCHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint8(VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))))
	case int32(_DBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*uintptr)(unsafe.Pointer(ap)))
	case int32(_LDBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*uintptr)(unsafe.Pointer(ap)))
	}
}

func _out(tls *TLS, f uintptr, s uintptr, l uint64) {
	x___fwritex(tls, s, l, f)
}

func _pad(tls *TLS, f uintptr, c int8, w int32, l int32, fl int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxVaListSize 0 */
	defer tls.Free(256)
	var v1 uint64
	var _ /* pad at bp+0 */ [256]int8
	if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))) != 0 || l >= w {
		return
	}
	l = w - l
	if uint64(l) > uint64(256) {
		v1 = uint64(256)
	} else {
		v1 = uint64(l)
	}
	x_memset(tls, bp, int32(c), v1)
	for uint64(l) >= uint64(256) {
		_out(tls, f, bp, uint64(256))
		goto _2
	_2:
		l = int32(uint64(l) - Uint64FromInt64(256))
	}
	_out(tls, f, bp, uint64(l))
}

var _xdigits1 = [16]int8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}

func _fmt_x(tls *TLS, x uint64, s uintptr, lower int32) (r uintptr) {
	var v2 uintptr
	for x != 0 {
		s--
		v2 = s
		*(*int8)(unsafe.Pointer(v2)) = int8(int32(_xdigits1[x&uint64(15)]) | lower)
		goto _1
	_1:
		x >>= uint64(4)
	}
	return s
}

func _fmt_o(tls *TLS, x uint64, s uintptr) (r uintptr) {
	var v2 uintptr
	for x != 0 {
		s--
		v2 = s
		*(*int8)(unsafe.Pointer(v2)) = int8(uint64('0') + x&uint64(7))
		goto _1
	_1:
		x >>= uint64(3)
	}
	return s
}

func _fmt_u(tls *TLS, x uint64, s uintptr) (r uintptr) {
	var y uint64
	var v2, v4 uintptr
	for x > uint64(0xffffffffffffffff) {
		s--
		v2 = s
		*(*int8)(unsafe.Pointer(v2)) = int8(uint64('0') + x%uint64(10))
		goto _1
	_1:
		x /= uint64(10)
	}
	for y = x; y != 0; {
		s--
		v4 = s
		*(*int8)(unsafe.Pointer(v4)) = int8(uint64('0') + y%uint64(10))
		goto _3
	_3:
		y /= uint64(10)
	}
	return s
}

func _fmt_fp(tls *TLS, f uintptr, y float64, w int32, p int32, fl int32, t int32) (r1 int32) {
	bp := tls.Alloc(520) /* tlsAllocs 520 maxVaListSize 0 */
	defer tls.Free(520)
	var a, d, ebuf, estr, prefix, r, s, s1, s2, s3, s4, z, z2, v1, v10, v11, v12, v13, v15, v16, v17, v18, v19, v2, v21, v23, v24, v25, v28, v38, v39, v41, v42, v43, v45, v47, v48, v49, v6, v7, v9 uintptr
	var carry, carry1, rm, x2 uint32
	var e, i, j, l, pl, re, sh, sh1, x, v14, v20, v22, v3, v37, v4, v40, v46, v5, v51, v8 int32
	var round, round1, small float64
	var x1 uint64
	var v31, v32, v33, v34, v35, v36, v50 int64
	var _ /* big at bp+0 */ [120]uint32
	var _ /* buf at bp+484 */ [22]int8
	var _ /* e2 at bp+480 */ int32
	var _ /* ebuf0 at bp+506 */ [12]int8
	*(*int32)(unsafe.Pointer(bp + 480)) = 0
	prefix = ts + 1105
	ebuf = bp + 506 + uintptr(Uint64FromInt32(3)*Uint64FromInt64(4))
	pl = int32(1)
	if y < Float64FromInt32(0) || Float64FromInt32(1)/y < Float64FromInt32(0) {
		y = -y
	} else {
		if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0 {
			prefix++
		} else {
			if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0 {
				prefix += uintptr(2)
			} else {
				pl = 0
			}
		}
	}
	if !(x___fpclassify(tls, y) > Int32FromInt32(m_FP_INFINITE)) {
		if t&int32(32) != 0 {
			v1 = ts + 1109
		} else {
			v1 = ts + 1113
		}
		s1 = v1
		if y != y {
			if t&int32(32) != 0 {
				v2 = ts + 1117
			} else {
				v2 = ts + 1121
			}
			s1 = v2
			pl = Int32FromInt32(0)
		}
		_pad(tls, f, int8(' '), w, int32(3)+pl, int32(uint32(fl) & ^(Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' ')))))
		_out(tls, f, prefix, uint64(pl))
		_out(tls, f, s1, uint64(3))
		_pad(tls, f, int8(' '), w, int32(3)+pl, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > int32(3)+pl {
			v3 = w
		} else {
			v3 = int32(3) + pl
		}
		return v3
	}
	y = x_frexpl(tls, y, bp+480) * Float64FromInt32(2)
	if y != 0 {
		*(*int32)(unsafe.Pointer(bp + 480))--
	}
	if t|int32(32) == int32('a') {
		round = Float64FromFloat64(8)
		if p < 0 || p >= Int32FromInt32(m_LDBL_MANT_DIG)/Int32FromInt32(4)-Int32FromInt32(1) {
			re = 0
		} else {
			re = Int32FromInt32(m_LDBL_MANT_DIG)/Int32FromInt32(4) - Int32FromInt32(1) - p
		}
		if re != 0 {
			if pl != 0 && int32(*(*int8)(unsafe.Pointer(prefix))) == int32('-') {
				y = -y
			}
			for {
				v4 = re
				re--
				if !(v4 != 0) {
					break
				}
				round *= Float64FromInt32(16)
			}
			y += round
			y -= round
			if y < Float64FromInt32(0) {
				y = -y
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 480)) < 0 {
			v5 = -*(*int32)(unsafe.Pointer(bp + 480))
		} else {
			v5 = *(*int32)(unsafe.Pointer(bp + 480))
		}
		estr = _fmt_u(tls, uint64(v5), ebuf)
		if estr == ebuf {
			estr--
			v6 = estr
			*(*int8)(unsafe.Pointer(v6)) = int8('0')
		}
		estr--
		v7 = estr
		if *(*int32)(unsafe.Pointer(bp + 480)) < 0 {
			v8 = int32('-')
		} else {
			v8 = int32('+')
		}
		*(*int8)(unsafe.Pointer(v7)) = int8(v8)
		estr--
		v9 = estr
		*(*int8)(unsafe.Pointer(v9)) = int8(t + (Int32FromUint8('p') - Int32FromUint8('a')))
		s = bp + 484
		v10 = s
		s++
		*(*int8)(unsafe.Pointer(v10)) = int8('0')
		v11 = s
		s++
		*(*int8)(unsafe.Pointer(v11)) = int8(t + (Int32FromUint8('x') - Int32FromUint8('a')))
		for cond := true; cond; cond = y != 0 {
			x = int32(y)
			v12 = s
			s++
			*(*int8)(unsafe.Pointer(v12)) = int8(int32(_xdigits1[x]) | t&int32(32))
			y = Float64FromInt32(16) * (y - float64(x))
			if int64(s)-int64(bp+484) == int64(3) && (y != 0 || p > 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0) {
				v13 = s
				s++
				*(*int8)(unsafe.Pointer(v13)) = int8('.')
			}
		}
		if p < 0 {
			p = int32(int64(s) - int64(bp+484) - int64(4))
		}
		l = int32(int64(uintptr(int32(1)+p+BoolInt32(p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0))+ebuf) - int64(estr))
		_pad(tls, f, int8(' '), w, pl+l, fl)
		_out(tls, f, prefix, uint64(pl))
		_pad(tls, f, int8('0'), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
		_out(tls, f, bp+484, uint64(int64(s)-int64(bp+484)))
		_pad(tls, f, int8('0'), int32(int64(l)-(int64(ebuf)-int64(estr))-(int64(s)-int64(bp+484))), 0, 0)
		_out(tls, f, estr, uint64(int64(ebuf)-int64(estr)))
		_pad(tls, f, int8('0'), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > pl+l {
			v14 = w
		} else {
			v14 = pl + l
		}
		return v14
	}
	if p < 0 {
		p = int32(6)
	}
	y *= Float64FromFloat64(2.68435456e+08)
	*(*int32)(unsafe.Pointer(bp + 480)) -= int32(28)
	if *(*int32)(unsafe.Pointer(bp + 480)) < 0 {
		v16 = bp
		z = v16
		v15 = v16
		r = v15
		a = v15
	} else {
		v18 = bp + uintptr(Uint64FromInt64(480)/Uint64FromInt64(4))*4 - UintptrFromInt32(m_LDBL_MANT_DIG)*4 - UintptrFromInt32(1)*4
		z = v18
		v17 = v18
		r = v17
		a = v17
	}
	for cond := true; cond; cond = y != 0 {
		*(*uint32)(unsafe.Pointer(z)) = uint32(y)
		v19 = z
		z += 4
		y = Float64FromInt32(1000000000) * (y - float64(*(*uint32)(unsafe.Pointer(v19))))
	}
	for *(*int32)(unsafe.Pointer(bp + 480)) > 0 {
		carry = uint32(0)
		if int32(29) < *(*int32)(unsafe.Pointer(bp + 480)) {
			v20 = int32(29)
		} else {
			v20 = *(*int32)(unsafe.Pointer(bp + 480))
		}
		sh = v20
		for d = z - uintptr(1)*4; d >= a; d -= 4 {
			x1 = uint64(*(*uint32)(unsafe.Pointer(d)))<<sh + uint64(carry)
			*(*uint32)(unsafe.Pointer(d)) = uint32(x1 % uint64(1000000000))
			carry = uint32(x1 / uint64(1000000000))
		}
		if !(*(*uint32)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4)) != 0) && z > a {
			z -= 4
		}
		if carry != 0 {
			a -= 4
			v21 = a
			*(*uint32)(unsafe.Pointer(v21)) = carry
		}
		*(*int32)(unsafe.Pointer(bp + 480)) -= sh
	}
	for *(*int32)(unsafe.Pointer(bp + 480)) < 0 {
		carry1 = uint32(0)
		if int32(9) < -*(*int32)(unsafe.Pointer(bp + 480)) {
			v22 = int32(9)
		} else {
			v22 = -*(*int32)(unsafe.Pointer(bp + 480))
		}
		sh1 = v22
		for d = a; d < z; d += 4 {
			rm = *(*uint32)(unsafe.Pointer(d)) & uint32(int32(1)<<sh1-int32(1))
			*(*uint32)(unsafe.Pointer(d)) = *(*uint32)(unsafe.Pointer(d))>>sh1 + carry1
			carry1 = uint32(Int32FromInt32(1000000000)>>sh1) * rm
		}
		if !(*(*uint32)(unsafe.Pointer(a)) != 0) {
			a += 4
		}
		if carry1 != 0 {
			v23 = z
			z += 4
			*(*uint32)(unsafe.Pointer(v23)) = carry1
		}
		/* Avoid (slow!) computation past requested precision */
		if t|int32(32) == int32('f') {
			v24 = r
		} else {
			v24 = a
		}
		z2 = v24 + uintptr(2)*4 + uintptr(p/int32(9))*4
		if z < z2 {
			v25 = z
		} else {
			v25 = z2
		}
		z = v25
		*(*int32)(unsafe.Pointer(bp + 480)) += sh1
	}
	if a < z {
		i = int32(10)
		e = int32(Int64FromInt32(9) * ((int64(r) - int64(a)) / 4))
		for *(*uint32)(unsafe.Pointer(a)) >= uint32(i) {
			goto _26
		_26:
			i *= int32(10)
			e++
		}
	} else {
		e = 0
	}
	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - BoolInt32(t|int32(32) != int32('f'))*e - BoolInt32(t|int32(32) == int32('g'))
	if int64(j) < int64(9)*((int64(z)-int64(r))/4-int64(1)) {
		/* We avoid C's broken division of negative numbers */
		d = r + uintptr(1)*4 + uintptr((j+Int32FromInt32(9)*Int32FromInt32(m_LDBL_MAX_EXP))/int32(9))*4 - uintptr(m_LDBL_MAX_EXP)*4
		j += Int32FromInt32(9) * Int32FromInt32(m_LDBL_MAX_EXP)
		j %= int32(9)
		i = int32(10)
		j++
		for j < int32(9) {
			goto _27
		_27:
			i *= int32(10)
			j++
		}
		x2 = *(*uint32)(unsafe.Pointer(d)) % uint32(i)
		/* Are there any significant digits past j? */
		if x2 != 0 || d+uintptr(1)*4 != z {
			round1 = Float64FromFloat64(9.007199254740992e+15)
			if x2 < uint32(i/int32(2)) {
				small = Float64FromFloat64(0.5)
			} else {
				if i == i/int32(2) && d+uintptr(1)*4 == z {
					small = Float64FromFloat64(8)
				} else {
					small = Float64FromFloat64(8.5)
				}
			}
			if pl != 0 && int32(*(*int8)(unsafe.Pointer(prefix))) == int32('-') {
				round1 *= float64(-Int32FromInt32(1))
				small *= float64(-Int32FromInt32(1))
			}
			/* Decide whether to round by probing round+small */
			if round1+small != round1 {
				*(*uint32)(unsafe.Pointer(d)) = *(*uint32)(unsafe.Pointer(d)) - x2 + uint32(i)
				for *(*uint32)(unsafe.Pointer(d)) > uint32(999999999) {
					v28 = d
					d -= 4
					*(*uint32)(unsafe.Pointer(v28)) = uint32(0)
					*(*uint32)(unsafe.Pointer(d))++
				}
				if d < a {
					a = d
				}
				i = int32(10)
				e = int32(Int64FromInt32(9) * ((int64(r) - int64(a)) / 4))
				for *(*uint32)(unsafe.Pointer(a)) >= uint32(i) {
					goto _29
				_29:
					i *= int32(10)
					e++
				}
			}
		}
		for ; !(*(*uint32)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4)) != 0) && z > a; z -= 4 {
		}
	}
	if t|int32(32) == int32('g') {
		if !(p != 0) {
			p++
		}
		if p > e && e >= -int32(4) {
			t--
			p -= e + int32(1)
		} else {
			t -= int32(2)
			p--
		}
		if !(uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0) {
			/* Count trailing zeros in last place */
			if z > a {
				i = int32(10)
				j = Int32FromInt32(0)
				for *(*uint32)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4))%uint32(i) == uint32(0) {
					goto _30
				_30:
					i *= int32(10)
					j++
				}
			} else {
				j = int32(9)
			}
			if t|int32(32) == int32('f') {
				if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))-int64(j) {
					v32 = int64(Int32FromInt32(0))
				} else {
					v32 = int64(9)*((int64(z)-int64(r))/4-int64(1)) - int64(j)
				}
				if int64(p) < v32 {
					v31 = int64(p)
				} else {
					if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))-int64(j) {
						v33 = int64(Int32FromInt32(0))
					} else {
						v33 = int64(9)*((int64(z)-int64(r))/4-int64(1)) - int64(j)
					}
					v31 = v33
				}
				p = int32(v31)
			} else {
				if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))+int64(e)-int64(j) {
					v35 = int64(Int32FromInt32(0))
				} else {
					v35 = int64(9)*((int64(z)-int64(r))/4-int64(1)) + int64(e) - int64(j)
				}
				if int64(p) < v35 {
					v34 = int64(p)
				} else {
					if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))+int64(e)-int64(j) {
						v36 = int64(Int32FromInt32(0))
					} else {
						v36 = int64(9)*((int64(z)-int64(r))/4-int64(1)) + int64(e) - int64(j)
					}
					v34 = v36
				}
				p = int32(v34)
			}
		}
	}
	l = int32(1) + p + BoolInt32(p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0)
	if t|int32(32) == int32('f') {
		if e > 0 {
			l += e
		}
	} else {
		if e < 0 {
			v37 = -e
		} else {
			v37 = e
		}
		estr = _fmt_u(tls, uint64(v37), ebuf)
		for int64(ebuf)-int64(estr) < int64(2) {
			estr--
			v38 = estr
			*(*int8)(unsafe.Pointer(v38)) = int8('0')
		}
		estr--
		v39 = estr
		if e < 0 {
			v40 = int32('-')
		} else {
			v40 = int32('+')
		}
		*(*int8)(unsafe.Pointer(v39)) = int8(v40)
		estr--
		v41 = estr
		*(*int8)(unsafe.Pointer(v41)) = int8(t)
		l = int32(int64(l) + (int64(ebuf) - int64(estr)))
	}
	_pad(tls, f, int8(' '), w, pl+l, fl)
	_out(tls, f, prefix, uint64(pl))
	_pad(tls, f, int8('0'), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
	if t|int32(32) == int32('f') {
		if a > r {
			a = r
		}
		for d = a; d <= r; d += 4 {
			s2 = _fmt_u(tls, uint64(*(*uint32)(unsafe.Pointer(d))), bp+484+uintptr(9))
			if d != a {
				for s2 > bp+484 {
					s2--
					v42 = s2
					*(*int8)(unsafe.Pointer(v42)) = int8('0')
				}
			} else if s2 == bp+484+uintptr(9) {
				s2--
				v43 = s2
				*(*int8)(unsafe.Pointer(v43)) = int8('0')
			}
			_out(tls, f, s2, uint64(int64(bp+484+uintptr(9))-int64(s2)))
		}
		if p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
			_out(tls, f, ts+154, uint64(1))
		}
		for d < z && p > 0 {
			s3 = _fmt_u(tls, uint64(*(*uint32)(unsafe.Pointer(d))), bp+484+uintptr(9))
			for s3 > bp+484 {
				s3--
				v45 = s3
				*(*int8)(unsafe.Pointer(v45)) = int8('0')
			}
			if int32(9) < p {
				v46 = int32(9)
			} else {
				v46 = p
			}
			_out(tls, f, s3, uint64(v46))
			goto _44
		_44:
			d += 4
			p -= int32(9)
		}
		_pad(tls, f, int8('0'), p+int32(9), int32(9), 0)
	} else {
		if z <= a {
			z = a + uintptr(1)*4
		}
		for d = a; d < z && p >= 0; d += 4 {
			s4 = _fmt_u(tls, uint64(*(*uint32)(unsafe.Pointer(d))), bp+484+uintptr(9))
			if s4 == bp+484+uintptr(9) {
				s4--
				v47 = s4
				*(*int8)(unsafe.Pointer(v47)) = int8('0')
			}
			if d != a {
				for s4 > bp+484 {
					s4--
					v48 = s4
					*(*int8)(unsafe.Pointer(v48)) = int8('0')
				}
			} else {
				v49 = s4
				s4++
				_out(tls, f, v49, uint64(1))
				if p > 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
					_out(tls, f, ts+154, uint64(1))
				}
			}
			if int64(bp+484+UintptrFromInt32(9))-int64(s4) < int64(p) {
				v50 = int64(bp+484+UintptrFromInt32(9)) - int64(s4)
			} else {
				v50 = int64(p)
			}
			_out(tls, f, s4, uint64(v50))
			p = int32(int64(p) - (int64(bp+484+UintptrFromInt32(9)) - int64(s4)))
		}
		_pad(tls, f, int8('0'), p+int32(18), int32(18), 0)
		_out(tls, f, estr, uint64(int64(ebuf)-int64(estr)))
	}
	_pad(tls, f, int8(' '), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
	if w > pl+l {
		v51 = w
	} else {
		v51 = pl + l
	}
	return v51
}

func _getint(tls *TLS, s uintptr) (r int32) {
	var i int32
	for i = 0; uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(s))++ {
		i = int32(10)*i + (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) - int32('0'))
	}
	return i
}

func _printf_core(tls *TLS, f uintptr, fmt uintptr, ap uintptr, nl_arg uintptr, nl_type uintptr) (r int32) {
	bp := tls.Alloc(72) /* tlsAllocs 72 maxVaListSize 0 */
	defer tls.Free(72)
	var a, prefix, ws, z, v31, v36, v4, v40 uintptr
	var argpos, cnt, i, l, p, pl, t, w, v1, v2, v3, v32, v35, v39, v43 int32
	var fl, l10n, litpct, ps, st uint32
	var v27 uint64
	var v30 int64
	var v37, v41 bool
	var _ /* arg at bp+8 */ Targ
	var _ /* buf at bp+16 */ [40]int8
	var _ /* mb at bp+64 */ [4]int8
	var _ /* s at bp+0 */ uintptr
	var _ /* wc at bp+56 */ [2]int32
	*(*uintptr)(unsafe.Pointer(bp)) = fmt
	l10n = uint32(0)
	cnt = 0
	l = 0
	for {
		/* Update output count, end loop when fmt is exhausted */
		if cnt >= 0 {
			if l > int32(m_INT_MAX)-cnt {
				if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_ERR) != 0) {
					*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
				}
				cnt = -int32(1)
			} else {
				cnt += l
			}
		}
		if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) {
			break
		}
		/* Handle literal text and %% format specifiers */
		for a = *(*uintptr)(unsafe.Pointer(bp)); *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('%'); *(*uintptr)(unsafe.Pointer(bp))++ {
		}
		litpct = uint32(x_strspn(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+1125) / uint64(2)) /* Optimize %%%% runs */
		z = *(*uintptr)(unsafe.Pointer(bp)) + uintptr(litpct)
		*(*uintptr)(unsafe.Pointer(bp)) += uintptr(uint32(2) * litpct)
		l = int32(int64(z) - int64(a))
		if f != 0 {
			_out(tls, f, a, uint64(l))
		}
		if l != 0 {
			continue
		}
		if uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-Int32FromUint8('0')) < uint32(10) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == int32('$') {
			l10n = uint32(1)
			argpos = int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) - int32('0')
			*(*uintptr)(unsafe.Pointer(bp)) += uintptr(3)
		} else {
			argpos = -int32(1)
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		/* Read modifier flags */
		for fl = uint32(0); uint32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-uint32(' ') < uint32(32) && (Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('\'')-Int32FromUint8(' ')))&(uint32(1)<<(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-int32(' '))) != 0; *(*uintptr)(unsafe.Pointer(bp))++ {
			fl |= uint32(1) << (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) - int32(' '))
		}
		/* Read field width */
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('*') {
			if uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-Int32FromUint8('0')) < uint32(10) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == int32('$') {
				l10n = uint32(1)
				*(*int32)(unsafe.Pointer(nl_type + uintptr(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-int32('0'))*4)) = int32(_INT)
				w = int32(*(*uint64)(unsafe.Pointer(nl_arg + uintptr(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-int32('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp)) += uintptr(3)
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v1 = VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))
					} else {
						v1 = 0
					}
					w = v1
					*(*uintptr)(unsafe.Pointer(bp))++
				} else {
					return -int32(1)
				}
			}
			if w < 0 {
				fl |= Uint32FromUint32(1) << (Int32FromUint8('-') - Int32FromUint8(' '))
				w = -w
			}
		} else {
			v2 = _getint(tls, bp)
			w = v2
			if v2 < 0 {
				return -int32(1)
			}
		}
		/* Read precision */
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('.') && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == int32('*') {
			if uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-Int32FromUint8('0')) < uint32(10) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 3))) == int32('$') {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-int32('0'))*4)) = int32(_INT)
				p = int32(*(*uint64)(unsafe.Pointer(nl_arg + uintptr(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-int32('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp)) += uintptr(4)
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v3 = VaInt32(&*(*uintptr)(unsafe.Pointer(ap)))
					} else {
						v3 = 0
					}
					p = v3
					*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2)
				} else {
					return -int32(1)
				}
			}
		} else {
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('.') {
				*(*uintptr)(unsafe.Pointer(bp))++
				p = _getint(tls, bp)
			} else {
				p = -int32(1)
			}
		}
		/* Format specifier state machine */
		st = uint32(0)
		for cond := true; cond; cond = st-uint32(1) < uint32(_STOP) {
			if uint32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-uint32('A') > uint32(Int32FromUint8('z')-Int32FromUint8('A')) {
				return -int32(1)
			}
			ps = st
			v4 = *(*uintptr)(unsafe.Pointer(bp))
			*(*uintptr)(unsafe.Pointer(bp))++
			st = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_states)) + uintptr(st)*58 + uintptr(int32(*(*int8)(unsafe.Pointer(v4)))-int32('A')))))
		}
		if !(st != 0) {
			return -int32(1)
		}
		/* Check validity of argument type (nl/normal) */
		if st == uint32(_NOARG) {
			if argpos >= 0 {
				return -int32(1)
			} else if !(f != 0) {
				continue
			}
		} else {
			if argpos >= 0 {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(argpos)*4)) = int32(st)
				*(*Targ)(unsafe.Pointer(bp + 8)) = *(*Targ)(unsafe.Pointer(nl_arg + uintptr(argpos)*8))
			} else {
				if f != 0 {
					_pop_arg(tls, bp+8, int32(st), ap)
				} else {
					return 0
				}
			}
		}
		if !(f != 0) {
			continue
		}
		z = bp + 16 + uintptr(40)
		prefix = ts + 1127
		pl = 0
		t = int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(-Int32FromInt32(1)))))
		/* Transform ls,lc -> S,C */
		if ps != 0 && t&int32(15) == int32(3) {
			t &= ^Int32FromInt32(32)
		}
		/* - and 0 flags are mutually exclusive */
		if fl&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0 {
			fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		}
		switch t {
		case int32('n'):
			goto _5
		case int32('p'):
			goto _6
		case int32('X'):
			goto _7
		case int32('x'):
			goto _8
		case int32('o'):
			goto _9
		case int32('i'):
			goto _10
		case int32('d'):
			goto _11
		case int32('u'):
			goto _12
		case int32('c'):
			goto _13
		case int32('s'):
			goto _14
		case int32('m'):
			goto _15
		case int32('C'):
			goto _16
		case int32('S'):
			goto _17
		case int32('A'):
			goto _18
		case int32('G'):
			goto _19
		case int32('F'):
			goto _20
		case int32('E'):
			goto _21
		case int32('a'):
			goto _22
		case int32('g'):
			goto _23
		case int32('f'):
			goto _24
		case int32('e'):
			goto _25
		}
		goto _26
	_5:
		switch ps {
		case uint32(_BARE):
			*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = l
		case uint32(_LPRE):
			*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = int64(l)
		case uint32(_LLPRE):
			*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = int64(l)
		case uint32(_HPRE):
			*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint16(l)
		case uint32(_HHPRE):
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint8(l)
		case uint32(_ZTPRE):
			*(*uint64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint64(l)
		case uint32(_JPRE):
			*(*uint64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint64(l)
			break
		}
		continue
	_6:
		if uint64(p) > Uint64FromInt32(2)*Uint64FromInt64(8) {
			v27 = uint64(p)
		} else {
			v27 = Uint64FromInt32(2) * Uint64FromInt64(8)
		}
		p = int32(v27)
		t = int32('x')
		fl |= Uint32FromUint32(1) << (Int32FromUint8('#') - Int32FromUint8(' '))
	_8:
	_7:
		a = _fmt_x(tls, *(*uint64)(unsafe.Pointer(bp + 8)), z, t&int32(32))
		if fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
			prefix += uintptr(t >> Int32FromInt32(4))
			pl = Int32FromInt32(2)
		}
		if !(0 != 0) {
			goto _28
		}
	_9:
		a = _fmt_o(tls, *(*uint64)(unsafe.Pointer(bp + 8)), z)
		if fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 && *(*uint64)(unsafe.Pointer(bp + 8)) != 0 {
			prefix += uintptr(5)
			pl = Int32FromInt32(1)
		}
	_28:
		if !(0 != 0) {
			goto _29
		}
	_11:
	_10:
		pl = int32(1)
		if *(*uint64)(unsafe.Pointer(bp + 8)) > uint64(Int64FromInt64(0x7fffffffffffffff)) {
			*(*uint64)(unsafe.Pointer(bp + 8)) = -*(*uint64)(unsafe.Pointer(bp + 8))
		} else {
			if fl&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0 {
				prefix++
			} else {
				if fl&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0 {
					prefix += uintptr(2)
				} else {
					pl = 0
				}
			}
		}
	_12:
		a = _fmt_u(tls, *(*uint64)(unsafe.Pointer(bp + 8)), z)
	_29:
		if !(*(*uint64)(unsafe.Pointer(bp + 8)) != 0) && !(p != 0) {
			continue
		}
		if p >= 0 {
			fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		}
		if int64(p) > int64(z)-int64(a)+BoolInt64(!(*(*uint64)(unsafe.Pointer(bp + 8)) != 0)) {
			v30 = int64(p)
		} else {
			v30 = int64(z) - int64(a) + BoolInt64(!(*(*uint64)(unsafe.Pointer(bp + 8)) != 0))
		}
		p = int32(v30)
		goto _26
	_13:
		v32 = Int32FromInt32(1)
		p = v32
		v31 = z - uintptr(v32)
		a = v31
		*(*int8)(unsafe.Pointer(v31)) = int8(*(*uint64)(unsafe.Pointer(bp + 8)))
		fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		goto _26
	_15:
		if !(int32(1) != 0) {
			goto _33
		}
		a = x_strerror(tls, *(*int32)(unsafe.Pointer(x___errno_location(tls))))
		goto _34
	_33:
	_14:
		a = *(*uintptr)(unsafe.Pointer(bp + 8))
	_34:
		z = x_memchr(tls, a, 0, uint64(p))
		if !(z != 0) {
			z = a + uintptr(p)
		} else {
			p = int32(int64(z) - int64(a))
		}
		fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		goto _26
	_16:
		(*(*[2]int32)(unsafe.Pointer(bp + 56)))[0] = int32(*(*uint64)(unsafe.Pointer(bp + 8)))
		(*(*[2]int32)(unsafe.Pointer(bp + 56)))[int32(1)] = 0
		*(*uintptr)(unsafe.Pointer(bp + 8)) = bp + 56
		p = -int32(1)
	_17:
		ws = *(*uintptr)(unsafe.Pointer(bp + 8))
		for i = 0; ; {
			if v37 = *(*int32)(unsafe.Pointer(ws)) != 0; v37 {
				v36 = ws
				ws += 4
				v35 = x_wctomb(tls, bp+64, *(*int32)(unsafe.Pointer(v36)))
				l = v35
			}
			if !(v37 && v35 >= 0 && uint32(l) <= 0+uint32(p)-uint32(i)) {
				break
			}
			goto _38
		_38:
			i += l
		}
		if l < 0 {
			return -int32(1)
		}
		p = i
		_pad(tls, f, int8(' '), w, p, int32(fl))
		ws = *(*uintptr)(unsafe.Pointer(bp + 8))
		for i = 0; ; {
			if v41 = *(*int32)(unsafe.Pointer(ws)) != 0; v41 {
				v40 = ws
				ws += 4
				v39 = x_wctomb(tls, bp+64, *(*int32)(unsafe.Pointer(v40)))
				l = v39
			}
			if !(v41 && i+v39 <= p) {
				break
			}
			_out(tls, f, bp+64, uint64(l))
			goto _42
		_42:
			i += l
		}
		_pad(tls, f, int8(' '), w, p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > p {
			v43 = w
		} else {
			v43 = p
		}
		l = v43
		continue
	_25:
	_24:
	_23:
	_22:
	_21:
	_20:
	_19:
	_18:
		l = _fmt_fp(tls, f, *(*float64)(unsafe.Pointer(bp + 8)), w, p, int32(fl), t)
		continue
	_26:
		if int64(p) < int64(z)-int64(a) {
			p = int32(int64(z) - int64(a))
		}
		if w < pl+p {
			w = pl + p
		}
		_pad(tls, f, int8(' '), w, pl+p, int32(fl))
		_out(tls, f, prefix, uint64(pl))
		_pad(tls, f, int8('0'), w, pl+p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
		_pad(tls, f, int8('0'), p, int32(int64(z)-int64(a)), 0)
		_out(tls, f, a, uint64(int64(z)-int64(a)))
		_pad(tls, f, int8(' '), w, pl+p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		l = w
	}
	if f != 0 {
		return cnt
	}
	if !(l10n != 0) {
		return 0
	}
	for i = int32(1); i <= int32(m_NL_ARGMAX) && *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0; i++ {
		_pop_arg(tls, nl_arg+uintptr(i)*8, *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)), ap)
	}
	for ; i <= int32(m_NL_ARGMAX) && !(*(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0); i++ {
	}
	if i <= int32(m_NL_ARGMAX) {
		return -int32(1)
	}
	return int32(1)
}

func x_vfprintf(tls *TLS, f uintptr, fmt uintptr, ap uintptr) (r int32) {
	bp := tls.Alloc(120) /* tlsAllocs 120 maxVaListSize 0 */
	defer tls.Free(120)
	var ret int32
	var _ /* ap2 at bp+0 */ uintptr
	var _ /* nl_arg at bp+48 */ [9]Targ
	var _ /* nl_type at bp+8 */ [9]int32
	*(*[9]int32)(unsafe.Pointer(bp + 8)) = [9]int32{}
	*(*uintptr)(unsafe.Pointer(bp)) = ap
	if _printf_core(tls, uintptr(0), fmt, bp, bp+48, bp+8) < 0 {
		return -int32(1)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	ret = _printf_core(tls, f, fmt, bp, bp+48, bp+8)
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	_ = *(*uintptr)(unsafe.Pointer(bp))
	return ret
}

func _f_read(tls *TLS, r uintptr) {
	var f uintptr
	var v1 int32
	f = (*Trctx_t)(unsafe.Pointer(r)).Fopaque
	v1 = x___uflow(tls, f)
	(*Trctx_t)(unsafe.Pointer(r)).Fc = v1
	if v1 >= 0 {
		(*Trctx_t)(unsafe.Pointer(r)).Fl++
	}
}

func x_vfscanf(tls *TLS, f uintptr, fmt uintptr, ap uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var fmt2 uintptr
	var i, l, result, v1 uint64
	var _ /* r at bp+0 */ Trctx_t
	defer func() { x_realloc(tls, fmt2, 0) }()
	l = x_strlen(tls, fmt)
	*(*Trctx_t)(unsafe.Pointer(bp)) = Trctx_t{Fread: __ccgo_fp(_f_read), Fopaque: f, Fwide: 0, Fis_space: __ccgo_fp(x_isspace)}
	v1 = (l + uint64(1)) * 4
	fmt2 = x_realloc(tls, fmt2, v1)
	if l > uint64(0x100000) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return -int32(1)
	}
	for i = uint64(0); i <= l; i++ {
		*(*int32)(unsafe.Add(unsafe.Pointer(fmt2), i*4)) = int32(uint8(*(*int8)(unsafe.Pointer(fmt + uintptr(i)))))
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, f+140)
		_ = Int32FromInt32(1)
	} else {
		_ = f + 140
		_ = Int32FromInt32(1)
	}
	result = uint64(x___scanf(tls, bp, fmt2, ap))
	if (*(*Trctx_t)(unsafe.Pointer(bp))).Fu != 0 && (*(*Trctx_t)(unsafe.Pointer(bp))).Fc >= 0 {
		/* This code takes care of the case where the caller performs
		 * a nonmatching scanf to leave a character in the unscan
		 * buffer, followed by an unget, followed by a scanf that
		 * matches zero characters. In this case the final 'unread'
		 * character must be returned to the unget buffer rather than
		 * the unscan buffer. */
		(*TFILE)(unsafe.Pointer(f)).Frpos--
	}
	*(*int32)(unsafe.Pointer(f + 140)) = 0
	return int32(result)
}

func _f_read1(tls *TLS, r uintptr) {
	var f uintptr
	var v1 int32
	f = (*Trctx_t)(unsafe.Pointer(r)).Fopaque
	v1 = x_fgetwc(tls, f)
	(*Trctx_t)(unsafe.Pointer(r)).Fc = v1
	if v1 >= 0 {
		(*Trctx_t)(unsafe.Pointer(r)).Fl++
	}
}

func x_vfwscanf(tls *TLS, f uintptr, fmt uintptr, ap uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var result int32
	var _ /* r at bp+0 */ Trctx_t
	*(*Trctx_t)(unsafe.Pointer(bp)) = Trctx_t{Fread: __ccgo_fp(_f_read1), Fopaque: f, Fwide: int32(1), Fis_space: __ccgo_fp(x_iswspace)}
	result = x___scanf(tls, bp, fmt, ap)
	if (*(*Trctx_t)(unsafe.Pointer(bp))).Fu != 0 && (*(*Trctx_t)(unsafe.Pointer(bp))).Fc >= 0 {
		x_ungetwc(tls, (*(*Trctx_t)(unsafe.Pointer(bp))).Fc, f)
	}
	return result
}

func x_vprintf(tls *TLS, fmt uintptr, ap uintptr) (r int32) {
	return x_vfprintf(tls, Xstdout, fmt, ap)
}

func x_vscanf(tls *TLS, fmt uintptr, ap uintptr) (r int32) {
	return x_vfscanf(tls, Xstdin, fmt, ap)
}

func _sn_write(tls *TLS, f uintptr, s uintptr, l uint64) (r uint64) {
	/* pretend to succeed, but discard data */
	return l
}

func x_vsnprintf(tls *TLS, s uintptr, n uint64, fmt uintptr, ap uintptr) (r1 int32) {
	bp := tls.Alloc(232) /* tlsAllocs 232 maxVaListSize 0 */
	defer tls.Free(232)
	var r int32
	var v1 uintptr
	var _ /* buf at bp+224 */ [1]uint8
	var _ /* f at bp+0 */ TFILE
	x_memset(tls, bp, 0, uint64(224))
	(*(*TFILE)(unsafe.Pointer(bp))).Flbf = int8(-Int32FromInt32(1))
	(*(*TFILE)(unsafe.Pointer(bp))).Fwrite = __ccgo_fp(_sn_write)
	(*(*TFILE)(unsafe.Pointer(bp))).Fbuf_size = uint64(1)
	(*(*TFILE)(unsafe.Pointer(bp))).Fbuf = bp + 224
	if n > uint64(m_INT_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return -int32(1)
	} else if n > uint64(0) {
		if n > uint64(int64(UintptrFromInt32(0)+uintptr(Uint64FromUint64(0xffffffffffffffff)))-int64(s)) {
			n = uint64(int64(UintptrFromInt32(0)+uintptr(Uint64FromUint64(0xffffffffffffffff))) - int64(s))
		}
		(*(*TFILE)(unsafe.Pointer(bp))).Fwpos = s
		v1 = s + uintptr(n) - UintptrFromInt32(1)
		(*(*TFILE)(unsafe.Pointer(bp))).Fwend = v1
		(*(*TFILE)(unsafe.Pointer(bp))).Fwbase = v1
		(*(*TFILE)(unsafe.Pointer(bp))).Fwstop = (*(*TFILE)(unsafe.Pointer(bp))).Fwend - uintptr(1)
	}
	r = x_vfprintf(tls, bp, fmt, ap)
	/* wpos points just after last byte written, or to s+n-1 (wbase) */
	*(*uint8)(unsafe.Pointer((*(*TFILE)(unsafe.Pointer(bp))).Fwpos)) = uint8(0)
	return r
}

func x_vsprintf(tls *TLS, s uintptr, fmt uintptr, ap uintptr) (r int32) {
	return x_vsnprintf(tls, s, uint64(m_INT_MAX), fmt, ap)
}

func _s_read(tls *TLS, r uintptr) {
	var s, v2 uintptr
	var v1 int32
	s = (*Trctx_t)(unsafe.Pointer(r)).Fopaque
	if !(*(*uint8)(unsafe.Pointer(s + uintptr((*Trctx_t)(unsafe.Pointer(r)).Fl))) != 0) {
		(*Trctx_t)(unsafe.Pointer(r)).Fc = -int32(1)
	} else {
		v2 = r + 32
		v1 = *(*int32)(unsafe.Pointer(v2))
		*(*int32)(unsafe.Pointer(v2))++
		(*Trctx_t)(unsafe.Pointer(r)).Fc = int32(*(*uint8)(unsafe.Pointer(s + uintptr(v1))))
	}
}

func x_vsscanf(tls *TLS, s uintptr, fmt uintptr, ap uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var fmt2 uintptr
	var i, l, v1 uint64
	var _ /* r at bp+0 */ Trctx_t
	defer func() { x_realloc(tls, fmt2, 0) }()
	l = x_strlen(tls, fmt)
	v1 = (l + uint64(1)) * 4
	fmt2 = x_realloc(tls, fmt2, v1)
	*(*Trctx_t)(unsafe.Pointer(bp)) = Trctx_t{Fread: __ccgo_fp(_s_read), Fopaque: s, Fwide: 0, Fis_space: __ccgo_fp(x_isspace)}
	for i = uint64(0); i <= l; i++ {
		*(*int32)(unsafe.Add(unsafe.Pointer(fmt2), i*4)) = int32(uint8(*(*int8)(unsafe.Pointer(fmt + uintptr(i)))))
	}
	return x___scanf(tls, bp, fmt2, ap)
}

func _s_read1(tls *TLS, r uintptr) {
	var s, v2 uintptr
	var v1 int32
	s = (*Trctx_t)(unsafe.Pointer(r)).Fopaque
	if !(*(*int32)(unsafe.Pointer(s + uintptr((*Trctx_t)(unsafe.Pointer(r)).Fl)*4)) != 0) {
		(*Trctx_t)(unsafe.Pointer(r)).Fc = -int32(1)
	} else {
		v2 = r + 32
		v1 = *(*int32)(unsafe.Pointer(v2))
		*(*int32)(unsafe.Pointer(v2))++
		(*Trctx_t)(unsafe.Pointer(r)).Fc = *(*int32)(unsafe.Pointer(s + uintptr(v1)*4))
	}
}

func x_vswscanf(tls *TLS, s uintptr, fmt uintptr, ap uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var _ /* r at bp+0 */ Trctx_t
	*(*Trctx_t)(unsafe.Pointer(bp)) = Trctx_t{Fread: __ccgo_fp(_s_read1), Fopaque: s, Fwide: int32(1), Fis_space: __ccgo_fp(x_iswspace)}
	return x___scanf(tls, bp, fmt, ap)
}

func x_vwscanf(tls *TLS, fmt uintptr, ap uintptr) (r int32) {
	return x_vfwscanf(tls, Xstdin, fmt, ap)
}

func x_wscanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap uintptr
	var ret int32
	ap = va
	ret = x_vwscanf(tls, fmt, ap)
	_ = ap
	return ret
}

func x_abs(tls *TLS, a int32) (r int32) {
	var v1 int32
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_atof(tls *TLS, s uintptr) (r float64) {
	return x_strtod(tls, s, uintptr(0))
}

func x_atoi(tls *TLS, s uintptr) (r int32) {
	var n, neg, v2 int32
	var v1 uintptr
	n = 0
	neg = 0
	for x_isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	for uint32(int32(*(*int8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) {
		v1 = s
		s++
		n = int32(10)*n + int32(*(*int8)(unsafe.Pointer(v1))) - int32('0')
	}
	if neg != 0 {
		v2 = -n
	} else {
		v2 = n
	}
	return v2
}

func x_atol(tls *TLS, s uintptr) (r int64) {
	var n, v2 int64
	var neg int32
	var v1 uintptr
	n = 0
	neg = 0
	for x_isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	for uint32(int32(*(*int8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) {
		v1 = s
		s++
		n = int64(10)*n + int64(*(*int8)(unsafe.Pointer(v1))) - int64('0')
	}
	if neg != 0 {
		v2 = -n
	} else {
		v2 = n
	}
	return v2
}

func x_atoll(tls *TLS, s uintptr) (r int64) {
	var n, v2 int64
	var neg int32
	var v1 uintptr
	n = 0
	neg = 0
	for x_isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	for uint32(int32(*(*int8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) {
		v1 = s
		s++
		n = int64(10)*n + int64(*(*int8)(unsafe.Pointer(v1))) - int64('0')
	}
	if neg != 0 {
		v2 = -n
	} else {
		v2 = n
	}
	return v2
}

func x_bsearch(tls *TLS, key uintptr, base uintptr, nel uint64, width uint64, cmp uintptr) (r uintptr) {
	var sign int32
	var try uintptr
	for nel > uint64(0) {
		try = base + uintptr(width*(nel/uint64(2)))
		sign = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, try)
		if !(sign != 0) {
			return try
		} else {
			if nel == uint64(1) {
				break
			} else {
				if sign < 0 {
					nel /= uint64(2)
				} else {
					base = try
					nel -= nel / uint64(2)
				}
			}
		}
	}
	return UintptrFromInt32(0)
}

func x_div(tls *TLS, num int32, den int32) (r Tdiv_t) {
	return Tdiv_t{Fquot: num / den, Frem: num % den}
}

func x_frexp(tls *TLS, x float64, e uintptr) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ee int32
	var p1, p2 uintptr
	var _ /* y at bp+0 */ struct {
		Fi [0]uint64
		Fd float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	ee = int32(*(*uint64)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(ee != 0) {
		if x != 0 {
			x = x_frexp(tls, x*float64(1.8446744073709552e+19), e)
			*(*int32)(unsafe.Pointer(e)) -= int32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = 0
		}
		return x
	} else if ee == int32(0x7ff) {
		return x
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x3fe)
	p1 = bp
	*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & Uint64FromUint64(0x800fffffffffffff)
	p2 = bp
	*(*uint64)(unsafe.Pointer(p2)) = *(*uint64)(unsafe.Pointer(p2)) | Uint64FromUint64(0x3fe0000000000000)
	return *(*float64)(unsafe.Pointer(bp))
}

func x_frexpf(tls *TLS, x float32, e uintptr) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var ee int32
	var p1, p2 uintptr
	var _ /* y at bp+0 */ struct {
		Fi [0]uint32
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	ee = int32(*(*uint32)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(ee != 0) {
		if x != 0 {
			x = x_frexpf(tls, float32(float64(x)*float64(1.8446744073709552e+19)), e)
			*(*int32)(unsafe.Pointer(e)) -= int32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = 0
		}
		return x
	} else if ee == int32(0xff) {
		return x
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x7e)
	p1 = bp
	*(*uint32)(unsafe.Pointer(p1)) = uint32(uint64(*(*uint32)(unsafe.Pointer(p1))) & Uint64FromUint64(0x807fffff))
	p2 = bp
	*(*uint32)(unsafe.Pointer(p2)) = uint32(uint64(*(*uint32)(unsafe.Pointer(p2))) | Uint64FromUint64(0x3f000000))
	return *(*float32)(unsafe.Pointer(bp))
}

func x_frexpl(tls *TLS, x float64, e uintptr) (r float64) {
	return x_frexp(tls, x, e)
}

func x_imaxabs(tls *TLS, a int64) (r int64) {
	var v1 int64
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_imaxdiv(tls *TLS, num int64, den int64) (r Timaxdiv_t) {
	return Timaxdiv_t{Fquot: num / den, Frem: num % den}
}

func x_labs(tls *TLS, a int64) (r int64) {
	var v1 int64
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_ldiv(tls *TLS, num int64, den int64) (r Tldiv_t) {
	return Tldiv_t{Fquot: num / den, Frem: num % den}
}

func x_llabs(tls *TLS, a int64) (r int64) {
	var v1 int64
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_lldiv(tls *TLS, num int64, den int64) (r Tlldiv_t) {
	return Tlldiv_t{Fquot: num / den, Frem: num % den}
}

func _swap(tls *TLS, a uintptr, b uintptr, len1 uint64) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxVaListSize 0 */
	defer tls.Free(256)
	var l, v1 uint64
	var _ /* tmp at bp+0 */ [256]int8
	for len1 != 0 {
		if Uint64FromInt64(256) < len1 {
			v1 = Uint64FromInt64(256)
		} else {
			v1 = len1
		}
		l = v1
		x_memcpy(tls, bp, a, l)
		x_memcpy(tls, a, b, l)
		x_memcpy(tls, b, bp, l)
		a += uintptr(l)
		b += uintptr(l)
		len1 -= l
	}
}

func _sift(tls *TLS, base uintptr, root uint64, nel uint64, width uint64, cmp uintptr) {
	var max uint64
	for uint64(2)*root <= nel {
		max = uint64(2) * root
		if max < nel && (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, base+uintptr(max*width), base+uintptr((max+uint64(1))*width)) < 0 {
			max++
		}
		if max != 0 && (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, base+uintptr(root*width), base+uintptr(max*width)) < 0 {
			_swap(tls, base+uintptr(root*width), base+uintptr(max*width), width)
			root = max
		} else {
			break
		}
	}
}

func x_qsort(tls *TLS, _base uintptr, nel uint64, width uint64, cmp uintptr) {
	var base uintptr
	var i uint64
	base = _base
	if !(nel != 0) {
		return
	}
	for i = (nel + uint64(1)) / uint64(2); i != 0; i-- {
		_sift(tls, base, i-uint64(1), nel-uint64(1), width, cmp)
	}
	for i = nel - uint64(1); i != 0; i-- {
		_swap(tls, base, base+uintptr(i*width), width)
		_sift(tls, base, uint64(0), i-uint64(1), width, cmp)
	}
}

func x_strtod(tls *TLS, s uintptr, p uintptr) (r float64) {
	return x_strtold(tls, s, p)
}

func x_strtof(tls *TLS, s uintptr, p uintptr) (r float32) {
	return float32(x_strtold(tls, s, p))
}

const m_INTMAX_MIN = 1

func x_strtoimax(tls *TLS, s1 uintptr, p uintptr, base int32) (r int64) {
	var s, v1 uintptr
	var sign int32
	var x, v3 uint64
	var v2 int64
	s = s1
	sign = 0
	/* Initial whitespace */
	for ; x_isspace(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0; s++ {
	}
	/* Optional sign */
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') {
		v1 = s
		s++
		sign = int32(*(*uint8)(unsafe.Pointer(v1)))
	} else if int32(*(*uint8)(unsafe.Pointer(s))) == int32('+') {
		s++
	}
	x = x_strtoumax(tls, s, p, base)
	if x > uint64(Int64FromInt64(0x7fffffffffffffff)) {
		if !(sign != 0) || -x != uint64(int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff)) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		}
		if sign != 0 {
			v2 = int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
		} else {
			v2 = int64(0x7fffffffffffffff)
		}
		return v2
	}
	if sign != 0 {
		v3 = -x
	} else {
		v3 = x
	}
	return int64(v3)
}

func x_strtol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	var x int64
	x = x_strtoimax(tls, s, p, base)
	if x > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(0x7fffffffffffffff)
	} else if x < int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
	}
	return x
}

func x_strtold(tls *TLS, _s1 uintptr, p uintptr) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _s1
	var e int64
	var frac, x, v2, v6, v8 float64
	var nonzero, radix, sign, v4, v5 int32
	var v1, v3, v7 uintptr
	var _ /* s at bp+8 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp))
	x = Float64FromInt32(0)
	sign = 0
	nonzero = 0
	radix = int32('.')
	if !(p != 0) {
		p = bp
	}
	/* Initial whitespace */
	for ; x_isspace(tls, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))) != 0; *(*uintptr)(unsafe.Pointer(bp + 8))++ {
	}
	/* Optional sign */
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == int32('-') {
		v1 = *(*uintptr)(unsafe.Pointer(bp + 8))
		*(*uintptr)(unsafe.Pointer(bp + 8))++
		sign = int32(*(*uint8)(unsafe.Pointer(v1)))
	} else if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == int32('+') {
		*(*uintptr)(unsafe.Pointer(bp + 8))++
	}
	/* Handle infinities and NaNs. */
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))|int32(32) == int32('i') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))|int32(32) == int32('n') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))|int32(32) == int32('f') {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(3)
		if sign != 0 {
			v2 = -Float64FromFloat64(1) / float64(0)
		} else {
			v2 = Float64FromFloat64(1) / Float64FromFloat64(0)
		}
		return v2
	} else if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))|int32(32) == int32('n') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))|int32(32) == int32('a') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))|int32(32) == int32('n') {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(3)
		return Float64FromFloat64(0) / Float64FromFloat64(0)
	}
	/* Possible hex float */
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == int32('0') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))|int32(32) == int32('x') {
		/* Mantissa must be non-degenerate */
		if !(x_isxdigit(tls, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))) != 0) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2))) != radix || !(x_isxdigit(tls, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))) != 0)) {
			/* Decimal float 0, 'x' extraneous */
			*(*uintptr)(unsafe.Pointer(bp + 8))++
			v3 = *(*uintptr)(unsafe.Pointer(bp + 8))
			*(*uintptr)(unsafe.Pointer(p)) = v3
			return Float64FromInt32(0)
		}
		/* We have a real hex float */
		*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(2)
		for ; x_isxdigit(tls, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))) != 0; *(*uintptr)(unsafe.Pointer(bp + 8))++ {
			if uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) < uint32(10) {
				v4 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) - int32('0')
			} else {
				v4 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) | int32(32) - int32('a')
			}
			x = Float64FromInt32(16)*x + float64(v4)
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != int32('0') {
				nonzero = int32(1)
			}
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == radix {
			frac = Float64FromFloat64(1) / Float64FromFloat64(16)
			for *(*uintptr)(unsafe.Pointer(bp + 8))++; x_isxdigit(tls, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))) != 0; *(*uintptr)(unsafe.Pointer(bp + 8))++ {
				if uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) < uint32(10) {
					v5 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) - int32('0')
				} else {
					v5 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) | int32(32) - int32('a')
				}
				x += frac * float64(v5)
				frac *= Float64FromFloat64(1) / Float64FromFloat64(16)
				if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != int32('0') {
					nonzero = int32(1)
				}
			}
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))|int32(32) == int32('p') {
			e = x_strtol(tls, *(*uintptr)(unsafe.Pointer(bp + 8))+uintptr(1), bp+8, int32(10))
			for ; e > 0; e-- {
				x *= Float64FromFloat64(2)
			}
			for ; e < 0; e++ {
				x *= Float64FromFloat64(0.5)
			}
		}
		if nonzero != 0 && !(x != 0) || !(Float64FromFloat64(1)/x != 0) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		}
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp + 8))
		if sign != 0 {
			v6 = -x
		} else {
			v6 = x
		}
		return v6
	}
	/* Mantissa must be non-degenerate */
	if !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) < Uint32FromInt32(10)) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != radix || !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))-Int32FromUint8('0')) < Uint32FromInt32(10))) {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp))
		return Float64FromInt32(0)
	}
	for ; uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(bp + 8))++ {
		x = Float64FromInt32(10)*x + float64(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) - Float64FromUint8('0')
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != int32('0') {
			nonzero = int32(1)
		}
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == radix {
		frac = Float64FromFloat64(10)
		for *(*uintptr)(unsafe.Pointer(bp + 8))++; uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(bp + 8))++ {
			x += float64(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-Int32FromUint8('0')) / frac
			frac *= Float64FromFloat64(10)
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != int32('0') {
				nonzero = int32(1)
			}
		}
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))|int32(32) == int32('e') {
		*(*uintptr)(unsafe.Pointer(bp + 8))++
		v7 = *(*uintptr)(unsafe.Pointer(bp + 8))
		e = x_strtol(tls, v7, bp+8, int32(10))
		for ; e > 0; e-- {
			x *= Float64FromFloat64(10)
		}
		for ; e < 0; e++ {
			x /= Float64FromFloat64(10)
		}
	}
	if nonzero != 0 && !(x != 0) || !(Float64FromFloat64(1)/x != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
	}
	*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	if sign != 0 {
		v8 = -x
	} else {
		v8 = x
	}
	return v8
}

const m_LLONG_MAX = 9223372036854775807

func x_strtoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	var x int64
	x = x_strtoimax(tls, s, p, base)
	if x > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(0x7fffffffffffffff)
	} else if x < int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
	}
	return x
}

func x_strtoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	var x uint64
	x = x_strtoumax(tls, s, p, base)
	if x > uint64(0xffffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return uint64(0xffffffffffffffff)
	}
	return x
}

const m_ULLONG_MAX = 18446744073709551615

func x_strtoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	var x uint64
	x = x_strtoumax(tls, s, p, base)
	if x > uint64(0xffffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return uint64(0xffffffffffffffff)
	}
	return x
}

const m_UINTMAX_MAX = 18446744073709551615

/* Lookup table for digit values. -1==255>=36 -> invalid */
var _digits = [256]uint8{
	0:   uint8(-Int32FromInt32(1)),
	1:   uint8(-Int32FromInt32(1)),
	2:   uint8(-Int32FromInt32(1)),
	3:   uint8(-Int32FromInt32(1)),
	4:   uint8(-Int32FromInt32(1)),
	5:   uint8(-Int32FromInt32(1)),
	6:   uint8(-Int32FromInt32(1)),
	7:   uint8(-Int32FromInt32(1)),
	8:   uint8(-Int32FromInt32(1)),
	9:   uint8(-Int32FromInt32(1)),
	10:  uint8(-Int32FromInt32(1)),
	11:  uint8(-Int32FromInt32(1)),
	12:  uint8(-Int32FromInt32(1)),
	13:  uint8(-Int32FromInt32(1)),
	14:  uint8(-Int32FromInt32(1)),
	15:  uint8(-Int32FromInt32(1)),
	16:  uint8(-Int32FromInt32(1)),
	17:  uint8(-Int32FromInt32(1)),
	18:  uint8(-Int32FromInt32(1)),
	19:  uint8(-Int32FromInt32(1)),
	20:  uint8(-Int32FromInt32(1)),
	21:  uint8(-Int32FromInt32(1)),
	22:  uint8(-Int32FromInt32(1)),
	23:  uint8(-Int32FromInt32(1)),
	24:  uint8(-Int32FromInt32(1)),
	25:  uint8(-Int32FromInt32(1)),
	26:  uint8(-Int32FromInt32(1)),
	27:  uint8(-Int32FromInt32(1)),
	28:  uint8(-Int32FromInt32(1)),
	29:  uint8(-Int32FromInt32(1)),
	30:  uint8(-Int32FromInt32(1)),
	31:  uint8(-Int32FromInt32(1)),
	32:  uint8(-Int32FromInt32(1)),
	33:  uint8(-Int32FromInt32(1)),
	34:  uint8(-Int32FromInt32(1)),
	35:  uint8(-Int32FromInt32(1)),
	36:  uint8(-Int32FromInt32(1)),
	37:  uint8(-Int32FromInt32(1)),
	38:  uint8(-Int32FromInt32(1)),
	39:  uint8(-Int32FromInt32(1)),
	40:  uint8(-Int32FromInt32(1)),
	41:  uint8(-Int32FromInt32(1)),
	42:  uint8(-Int32FromInt32(1)),
	43:  uint8(-Int32FromInt32(1)),
	44:  uint8(-Int32FromInt32(1)),
	45:  uint8(-Int32FromInt32(1)),
	46:  uint8(-Int32FromInt32(1)),
	47:  uint8(-Int32FromInt32(1)),
	48:  uint8(0),
	49:  uint8(1),
	50:  uint8(2),
	51:  uint8(3),
	52:  uint8(4),
	53:  uint8(5),
	54:  uint8(6),
	55:  uint8(7),
	56:  uint8(8),
	57:  uint8(9),
	58:  uint8(-Int32FromInt32(1)),
	59:  uint8(-Int32FromInt32(1)),
	60:  uint8(-Int32FromInt32(1)),
	61:  uint8(-Int32FromInt32(1)),
	62:  uint8(-Int32FromInt32(1)),
	63:  uint8(-Int32FromInt32(1)),
	64:  uint8(-Int32FromInt32(1)),
	65:  uint8(10),
	66:  uint8(11),
	67:  uint8(12),
	68:  uint8(13),
	69:  uint8(14),
	70:  uint8(15),
	71:  uint8(16),
	72:  uint8(17),
	73:  uint8(18),
	74:  uint8(19),
	75:  uint8(20),
	76:  uint8(21),
	77:  uint8(22),
	78:  uint8(23),
	79:  uint8(24),
	80:  uint8(25),
	81:  uint8(26),
	82:  uint8(27),
	83:  uint8(28),
	84:  uint8(29),
	85:  uint8(30),
	86:  uint8(31),
	87:  uint8(32),
	88:  uint8(33),
	89:  uint8(34),
	90:  uint8(35),
	91:  uint8(-Int32FromInt32(1)),
	92:  uint8(-Int32FromInt32(1)),
	93:  uint8(-Int32FromInt32(1)),
	94:  uint8(-Int32FromInt32(1)),
	95:  uint8(-Int32FromInt32(1)),
	96:  uint8(-Int32FromInt32(1)),
	97:  uint8(10),
	98:  uint8(11),
	99:  uint8(12),
	100: uint8(13),
	101: uint8(14),
	102: uint8(15),
	103: uint8(16),
	104: uint8(17),
	105: uint8(18),
	106: uint8(19),
	107: uint8(20),
	108: uint8(21),
	109: uint8(22),
	110: uint8(23),
	111: uint8(24),
	112: uint8(25),
	113: uint8(26),
	114: uint8(27),
	115: uint8(28),
	116: uint8(29),
	117: uint8(30),
	118: uint8(31),
	119: uint8(32),
	120: uint8(33),
	121: uint8(34),
	122: uint8(35),
	123: uint8(-Int32FromInt32(1)),
	124: uint8(-Int32FromInt32(1)),
	125: uint8(-Int32FromInt32(1)),
	126: uint8(-Int32FromInt32(1)),
	127: uint8(-Int32FromInt32(1)),
	128: uint8(-Int32FromInt32(1)),
	129: uint8(-Int32FromInt32(1)),
	130: uint8(-Int32FromInt32(1)),
	131: uint8(-Int32FromInt32(1)),
	132: uint8(-Int32FromInt32(1)),
	133: uint8(-Int32FromInt32(1)),
	134: uint8(-Int32FromInt32(1)),
	135: uint8(-Int32FromInt32(1)),
	136: uint8(-Int32FromInt32(1)),
	137: uint8(-Int32FromInt32(1)),
	138: uint8(-Int32FromInt32(1)),
	139: uint8(-Int32FromInt32(1)),
	140: uint8(-Int32FromInt32(1)),
	141: uint8(-Int32FromInt32(1)),
	142: uint8(-Int32FromInt32(1)),
	143: uint8(-Int32FromInt32(1)),
	144: uint8(-Int32FromInt32(1)),
	145: uint8(-Int32FromInt32(1)),
	146: uint8(-Int32FromInt32(1)),
	147: uint8(-Int32FromInt32(1)),
	148: uint8(-Int32FromInt32(1)),
	149: uint8(-Int32FromInt32(1)),
	150: uint8(-Int32FromInt32(1)),
	151: uint8(-Int32FromInt32(1)),
	152: uint8(-Int32FromInt32(1)),
	153: uint8(-Int32FromInt32(1)),
	154: uint8(-Int32FromInt32(1)),
	155: uint8(-Int32FromInt32(1)),
	156: uint8(-Int32FromInt32(1)),
	157: uint8(-Int32FromInt32(1)),
	158: uint8(-Int32FromInt32(1)),
	159: uint8(-Int32FromInt32(1)),
	160: uint8(-Int32FromInt32(1)),
	161: uint8(-Int32FromInt32(1)),
	162: uint8(-Int32FromInt32(1)),
	163: uint8(-Int32FromInt32(1)),
	164: uint8(-Int32FromInt32(1)),
	165: uint8(-Int32FromInt32(1)),
	166: uint8(-Int32FromInt32(1)),
	167: uint8(-Int32FromInt32(1)),
	168: uint8(-Int32FromInt32(1)),
	169: uint8(-Int32FromInt32(1)),
	170: uint8(-Int32FromInt32(1)),
	171: uint8(-Int32FromInt32(1)),
	172: uint8(-Int32FromInt32(1)),
	173: uint8(-Int32FromInt32(1)),
	174: uint8(-Int32FromInt32(1)),
	175: uint8(-Int32FromInt32(1)),
	176: uint8(-Int32FromInt32(1)),
	177: uint8(-Int32FromInt32(1)),
	178: uint8(-Int32FromInt32(1)),
	179: uint8(-Int32FromInt32(1)),
	180: uint8(-Int32FromInt32(1)),
	181: uint8(-Int32FromInt32(1)),
	182: uint8(-Int32FromInt32(1)),
	183: uint8(-Int32FromInt32(1)),
	184: uint8(-Int32FromInt32(1)),
	185: uint8(-Int32FromInt32(1)),
	186: uint8(-Int32FromInt32(1)),
	187: uint8(-Int32FromInt32(1)),
	188: uint8(-Int32FromInt32(1)),
	189: uint8(-Int32FromInt32(1)),
	190: uint8(-Int32FromInt32(1)),
	191: uint8(-Int32FromInt32(1)),
	192: uint8(-Int32FromInt32(1)),
	193: uint8(-Int32FromInt32(1)),
	194: uint8(-Int32FromInt32(1)),
	195: uint8(-Int32FromInt32(1)),
	196: uint8(-Int32FromInt32(1)),
	197: uint8(-Int32FromInt32(1)),
	198: uint8(-Int32FromInt32(1)),
	199: uint8(-Int32FromInt32(1)),
	200: uint8(-Int32FromInt32(1)),
	201: uint8(-Int32FromInt32(1)),
	202: uint8(-Int32FromInt32(1)),
	203: uint8(-Int32FromInt32(1)),
	204: uint8(-Int32FromInt32(1)),
	205: uint8(-Int32FromInt32(1)),
	206: uint8(-Int32FromInt32(1)),
	207: uint8(-Int32FromInt32(1)),
	208: uint8(-Int32FromInt32(1)),
	209: uint8(-Int32FromInt32(1)),
	210: uint8(-Int32FromInt32(1)),
	211: uint8(-Int32FromInt32(1)),
	212: uint8(-Int32FromInt32(1)),
	213: uint8(-Int32FromInt32(1)),
	214: uint8(-Int32FromInt32(1)),
	215: uint8(-Int32FromInt32(1)),
	216: uint8(-Int32FromInt32(1)),
	217: uint8(-Int32FromInt32(1)),
	218: uint8(-Int32FromInt32(1)),
	219: uint8(-Int32FromInt32(1)),
	220: uint8(-Int32FromInt32(1)),
	221: uint8(-Int32FromInt32(1)),
	222: uint8(-Int32FromInt32(1)),
	223: uint8(-Int32FromInt32(1)),
	224: uint8(-Int32FromInt32(1)),
	225: uint8(-Int32FromInt32(1)),
	226: uint8(-Int32FromInt32(1)),
	227: uint8(-Int32FromInt32(1)),
	228: uint8(-Int32FromInt32(1)),
	229: uint8(-Int32FromInt32(1)),
	230: uint8(-Int32FromInt32(1)),
	231: uint8(-Int32FromInt32(1)),
	232: uint8(-Int32FromInt32(1)),
	233: uint8(-Int32FromInt32(1)),
	234: uint8(-Int32FromInt32(1)),
	235: uint8(-Int32FromInt32(1)),
	236: uint8(-Int32FromInt32(1)),
	237: uint8(-Int32FromInt32(1)),
	238: uint8(-Int32FromInt32(1)),
	239: uint8(-Int32FromInt32(1)),
	240: uint8(-Int32FromInt32(1)),
	241: uint8(-Int32FromInt32(1)),
	242: uint8(-Int32FromInt32(1)),
	243: uint8(-Int32FromInt32(1)),
	244: uint8(-Int32FromInt32(1)),
	245: uint8(-Int32FromInt32(1)),
	246: uint8(-Int32FromInt32(1)),
	247: uint8(-Int32FromInt32(1)),
	248: uint8(-Int32FromInt32(1)),
	249: uint8(-Int32FromInt32(1)),
	250: uint8(-Int32FromInt32(1)),
	251: uint8(-Int32FromInt32(1)),
	252: uint8(-Int32FromInt32(1)),
	253: uint8(-Int32FromInt32(1)),
	254: uint8(-Int32FromInt32(1)),
	255: uint8(-Int32FromInt32(1))}

func x_strtoumax(tls *TLS, _s1 uintptr, p uintptr, base int32) (r uint64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _s1
	var s, v1 uintptr
	var shift, sign int32
	var x, x1, z, z1, v2 uint64
	s = *(*uintptr)(unsafe.Pointer(bp))
	z = uint64(0)
	sign = 0
	if !(p != 0) {
		p = bp
	}
	/* Initial whitespace */
	for ; x_isspace(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0; s++ {
	}
	/* Optional sign */
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') {
		v1 = s
		s++
		sign = int32(*(*uint8)(unsafe.Pointer(v1)))
	} else if int32(*(*uint8)(unsafe.Pointer(s))) == int32('+') {
		s++
	}
	/* Default base 8, 10, or 16 depending on prefix */
	if base == 0 {
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('0') {
			if int32(*(*uint8)(unsafe.Pointer(s + 1)))|int32(32) == int32('x') {
				base = int32(16)
			} else {
				base = int32(8)
			}
		} else {
			base = int32(10)
		}
	}
	if uint32(base)-uint32(2) > uint32(Int32FromInt32(36)-Int32FromInt32(2)) || int32(_digits[*(*uint8)(unsafe.Pointer(s))]) >= base {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp))
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uint64(0)
	}
	/* Main loops. Only use big types if we have to. */
	if base == int32(10) {
		for x1 = uint64(0); uint32(int32(*(*uint8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) && x1 <= Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(10)-Uint64FromInt32(10); s++ {
			x1 = uint64(10)*x1 + uint64(*(*uint8)(unsafe.Pointer(s))) - uint64('0')
		}
		for x = x1; uint32(int32(*(*uint8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) && x <= Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(10)-Uint64FromInt32(10); s++ {
			x = uint64(10)*x + uint64(*(*uint8)(unsafe.Pointer(s))) - uint64('0')
		}
		if uint32(int32(*(*uint8)(unsafe.Pointer(s)))-Int32FromUint8('0')) < uint32(10) {
			if uint32(int32(*(*uint8)(unsafe.Pointer(s + 1)))-Int32FromUint8('0')) < uint32(10) || uint64(10)*x > uint64(0xffffffffffffffff)-uint64(int32(*(*uint8)(unsafe.Pointer(s)))-Int32FromUint8('0')) {
				goto overflow
			}
			x = uint64(10)*x + uint64(*(*uint8)(unsafe.Pointer(s))) - uint64('0')
		}
	} else {
		if !(base&(base/Int32FromInt32(2)) != 0) {
			if base == int32(16) {
				if int32(*(*uint8)(unsafe.Pointer(s))) == int32('0') && int32(*(*uint8)(unsafe.Pointer(s + 1)))|int32(32) == int32('x') && int32(_digits[*(*uint8)(unsafe.Pointer(s + 2))]) < int32(16) {
					s += uintptr(2)
				}
				shift = int32(4)
				z1 = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(16)
				z = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(16)
			} else {
				if base == int32(8) {
					shift = int32(3)
					z1 = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(8)
					z = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(8)
				} else {
					if base == int32(2) {
						shift = int32(1)
						z1 = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(2)
						z = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(2)
					} else {
						if base == int32(4) {
							shift = int32(2)
							z1 = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(4)
							z = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(4)
						} else {
							shift = int32(5)
							z1 = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(32)
							z = Uint64FromUint64(0xffffffffffffffff) / Uint64FromInt32(32)
						}
					}
				}
			}
			for x1 = uint64(0); int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base && x1 <= z1; s++ {
				x1 = x1<<shift + uint64(_digits[*(*uint8)(unsafe.Pointer(s))])
			}
			for x = x1; int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base && x <= z; s++ {
				x = x<<shift + uint64(_digits[*(*uint8)(unsafe.Pointer(s))])
			}
			if int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base {
				goto overflow
			}
		} else {
			z1 = uint64(0xffffffffffffffff)/uint64(base) - uint64(base)
			for x1 = uint64(0); int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base && x1 <= z1; s++ {
				x1 = x1*uint64(base) + uint64(_digits[*(*uint8)(unsafe.Pointer(s))])
			}
			if int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base {
				z = uint64(0xffffffffffffffff)/uint64(base) - uint64(base)
			}
			for x = x1; int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base && x <= z; s++ {
				x = x*uint64(base) + uint64(_digits[*(*uint8)(unsafe.Pointer(s))])
			}
			if int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base {
				if int32(_digits[*(*uint8)(unsafe.Pointer(s + 1))]) < base || x*uint64(base) > uint64(0xffffffffffffffff)-uint64(_digits[*(*uint8)(unsafe.Pointer(s))]) {
					goto overflow
				}
				x = x*uint64(base) + uint64(_digits[*(*uint8)(unsafe.Pointer(s))])
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(p)) = s
	if sign != 0 {
		v2 = -x
	} else {
		v2 = x
	}
	return v2
overflow:
	for ; int32(_digits[*(*uint8)(unsafe.Pointer(s))]) < base; s++ {
	}
	*(*uintptr)(unsafe.Pointer(p)) = s
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
	return Uint64FromUint64(0xffffffffffffffff)
}

func x_wcstoimax(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	var sign int32
	var x, v3 uint64
	var v1 uintptr
	var v2 int64
	sign = 0
	/* Initial whitespace */
	for ; x_iswspace(tls, *(*int32)(unsafe.Pointer(s))) != 0; s += 4 {
	}
	/* Optional sign */
	if *(*int32)(unsafe.Pointer(s)) == int32('-') {
		v1 = s
		s += 4
		sign = *(*int32)(unsafe.Pointer(v1))
	} else if *(*int32)(unsafe.Pointer(s)) == int32('+') {
		s += 4
	}
	x = x_wcstoumax(tls, s, p, base)
	if x > uint64(Int64FromInt64(0x7fffffffffffffff)) {
		if !(sign != 0) || -x != uint64(int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff)) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		}
		if sign != 0 {
			v2 = int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
		} else {
			v2 = int64(0x7fffffffffffffff)
		}
		return v2
	}
	if sign != 0 {
		v3 = -x
	} else {
		v3 = x
	}
	return int64(v3)
}

func x_wcstol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	var x int64
	x = x_wcstoimax(tls, s, p, base)
	if x > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(0x7fffffffffffffff)
	} else if x < int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
	}
	return x
}

func x_wcstoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	var x int64
	x = x_wcstoimax(tls, s, p, base)
	if x > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(0x7fffffffffffffff)
	} else if x < int64(-Int32FromInt32(1))-Int64FromInt64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return int64(-Int32FromInt32(1)) - Int64FromInt64(0x7fffffffffffffff)
	}
	return x
}

func x_wcstoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	var x uint64
	x = x_wcstoumax(tls, s, p, base)
	if x > uint64(0xffffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return uint64(0xffffffffffffffff)
	}
	return x
}

func x_wcstoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	var x uint64
	x = x_wcstoumax(tls, s, p, base)
	if x > uint64(0xffffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return uint64(0xffffffffffffffff)
	}
	return x
}

func x_wcstoumax(tls *TLS, _s uintptr, p uintptr, base int32) (r uint64) {
	bp := tls.Alloc(80) /* tlsAllocs 80 maxVaListSize 0 */
	defer tls.Free(80)
	*(*uintptr)(unsafe.Pointer(bp)) = _s
	var sign, skipped int32
	var v1 uintptr
	var _ /* buf at bp+8 */ [66]int8
	/* Large enough for largest value in binary */
	sign = 0
	skipped = 0
	if !(p != 0) {
		p = bp
	}
	if base != 0 && uint32(base)-uint32(2) > uint32(Int32FromInt32(36)-Int32FromInt32(2)) {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp))
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uint64(0)
	}
	/* Initial whitespace */
	for ; x_iswspace(tls, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0; *(*uintptr)(unsafe.Pointer(bp)) += 4 {
	}
	/* Optional sign */
	if *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) == int32('-') {
		v1 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp)) += 4
		sign = *(*int32)(unsafe.Pointer(v1))
	} else if *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) == int32('+') {
		*(*uintptr)(unsafe.Pointer(bp)) += 4
	}
	/* Skip leading zeros but don't allow leading zeros before "0x". */
	for ; *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) == int32('0') && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)) == int32('0'); *(*uintptr)(unsafe.Pointer(bp)) += 4 {
		skipped = int32(1)
	}
	if skipped != 0 && (base == 0 || base == int32(16)) && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))|int32(32) == int32('x') {
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp)) + UintptrFromInt32(1)*4
		return uint64(0)
	}
	/* Convert to normal char string so we can use strtoumax */
	(*(*[66]int8)(unsafe.Pointer(bp + 8)))[0] = int8(sign)
	if x_wcstombs(tls, bp+8+BoolUintptr(!!(sign != 0)), *(*uintptr)(unsafe.Pointer(bp)), Uint64FromInt64(66)-Uint64FromInt32(1)) < uint64(0) {
		return uint64(0)
	}
	(*(*[66]int8)(unsafe.Pointer(bp + 8)))[Uint64FromInt64(66)-Uint64FromInt32(1)] = 0
	/* Compute final position */
	if p != 0 {
		if (base == 0 || base == int32(16)) && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) == int32('0') && *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))|int32(32) == int32('x') && x_iswxdigit(tls, *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4))) != 0 {
			*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2) * 4
		}
		for ; *(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 && (uint32(*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-uint32('0') < uint32(base) || uint32(*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))|uint32(32)-uint32('a') < uint32(base-int32(10))); *(*uintptr)(unsafe.Pointer(bp)) += 4 {
		}
		*(*uintptr)(unsafe.Pointer(p)) = *(*uintptr)(unsafe.Pointer(bp))
	}
	return x_strtoumax(tls, bp+8, uintptr(0), base)
}

func x_bcmp(tls *TLS, s1 uintptr, s2 uintptr, n uint64) (r int32) {
	return x_memcmp(tls, s1, s2, n)
}

func x_bcopy(tls *TLS, s1 uintptr, s2 uintptr, n uint64) {
	x_memmove(tls, s2, s1, n)
}

func x_bzero(tls *TLS, s uintptr, n uint64) {
	x_memset(tls, s, 0, n)
}

func x_index(tls *TLS, s uintptr, c int32) (r uintptr) {
	return x_strchr(tls, s, c)
}

const m_UCHAR_MAX = 255

func x_memchr(tls *TLS, src uintptr, c int32, n uint64) (r uintptr) {
	var k uint64
	var s, w, v4 uintptr
	s = src
	c = int32(uint8(c))
	for uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		goto _1
	_1:
		s++
		n--
	}
	if n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
		for w = s; n >= Uint64FromInt64(8) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); {
			goto _2
		_2:
			w += 8
			n -= Uint64FromInt64(8)
		}
		for s = w; n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c; {
			goto _3
		_3:
			s++
			n--
		}
	}
	if n != 0 {
		v4 = s
	} else {
		v4 = uintptr(0)
	}
	return v4
}

func x_memcmp(tls *TLS, vl uintptr, vr uintptr, n uint64) (r1 int32) {
	var l, r uintptr
	var v2 int32
	l = vl
	r = vr
	for n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) {
		goto _1
	_1:
		n--
		l++
		r++
	}
	if n != 0 {
		v2 = int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
	} else {
		v2 = 0
	}
	return v2
}

func x_memcpy(tls *TLS, dest uintptr, src uintptr, n uint64) (r uintptr) {
	var d, s, wd, ws, v1, v2, v5, v6, v7, v8 uintptr
	d = dest
	s = src
	if uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		goto misaligned
	}
	for ; uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; n-- {
		v1 = d
		d++
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v1)) = *(*uint8)(unsafe.Pointer(v2))
	}
	if !(n != 0) {
		goto _3
	}
	wd = d
	ws = s
	for n >= Uint64FromInt64(8) {
		v5 = wd
		wd += 8
		v6 = ws
		ws += 8
		*(*uint64)(unsafe.Pointer(v5)) = *(*uint64)(unsafe.Pointer(v6))
		goto _4
	_4:
		n -= Uint64FromInt64(8)
	}
	d = wd
	s = ws
misaligned:
	for ; n != 0; n-- {
		v7 = d
		d++
		v8 = s
		s++
		*(*uint8)(unsafe.Pointer(v7)) = *(*uint8)(unsafe.Pointer(v8))
	}
_3:
	return dest
}

func x_memmove(tls *TLS, dest uintptr, src uintptr, n uint64) (r uintptr) {
	var d, s uintptr
	var v1 uint64
	d = dest
	s = src
	if d == s {
		return d
	}
	if uint64(int64(d)-int64(s)) < n {
		for {
			v1 = n
			n--
			if !(v1 != 0) {
				break
			}
			*(*int8)(unsafe.Pointer(d + uintptr(n))) = *(*int8)(unsafe.Pointer(s + uintptr(n)))
		}
		return dest
	}
	/* Assumes memcpy is overlap-safe when dest < src */
	return x_memcpy(tls, d, s, n)
}

func x_mempcpy(tls *TLS, dest uintptr, src uintptr, n uint64) (r uintptr) {
	x_memcpy(tls, dest, src, n)
	return dest + uintptr(n)
}

func x_memset(tls *TLS, dest uintptr, c int32, n uint64) (r uintptr) {
	var k uint64
	var s, w, v1 uintptr
	s = dest
	c = int32(uint8(c))
	for ; uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; n-- {
		v1 = s
		s++
		*(*uint8)(unsafe.Pointer(v1)) = uint8(c)
	}
	if n != 0 {
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
		for w = s; n >= Uint64FromInt64(8); {
			*(*uint64)(unsafe.Pointer(w)) = k
			goto _2
		_2:
			n -= Uint64FromInt64(8)
			w += 8
		}
		for s = w; n != 0; {
			*(*uint8)(unsafe.Pointer(s)) = uint8(c)
			goto _3
		_3:
			n--
			s++
		}
	}
	return dest
}

func x_rindex(tls *TLS, s uintptr, c int32) (r uintptr) {
	return x_strrchr(tls, s, c)
}

func x___stpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	var wd, ws, v3, v4 uintptr
	var v1, v6 int8
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			v1 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v1
			if !(v1 != 0 && uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0) {
				break
			}
			goto _2
		_2:
			s++
			d++
		}
		if !(*(*int8)(unsafe.Pointer(s)) != 0) {
			return d
		}
		wd = d
		ws = s
		for !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			goto _5
		_5:
			v3 = wd
			wd += 8
			v4 = ws
			ws += 8
			*(*uint64)(unsafe.Pointer(v3)) = *(*uint64)(unsafe.Pointer(v4))
		}
		d = wd
		s = ws
	}
	for {
		v6 = *(*int8)(unsafe.Pointer(s))
		*(*int8)(unsafe.Pointer(d)) = v6
		if !(v6 != 0) {
			break
		}
		goto _7
	_7:
		s++
		d++
	}
	return d
}

func x___stpncpy(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var wd, ws, v4 uintptr
	var v1, v6 int8
	var v2, v7 bool
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v2 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v2 {
				v1 = *(*int8)(unsafe.Pointer(s))
				*(*int8)(unsafe.Pointer(d)) = v1
			}
			if !(v2 && v1 != 0) {
				break
			}
			goto _3
		_3:
			n--
			s++
			d++
		}
		if !(n != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) {
			goto tail
		}
		wd = d
		ws = s
		for n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
			goto _5
		_5:
			n -= uint64(8)
			ws += 8
			v4 = wd
			wd += 8
			_ = *(*uint64)(unsafe.Pointer(v4))
		}
		d = wd
		s = ws
	}
	for {
		if v7 = n != 0; v7 {
			v6 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v6
		}
		if !(v7 && v6 != 0) {
			break
		}
		goto _8
	_8:
		n--
		s++
		d++
	}
tail:
	x_memset(tls, d, 0, n)
	return d
}

func x_strcasecmp(tls *TLS, _l uintptr, _r uintptr) (r1 int32) {
	var l, r uintptr
	l = _l
	r = _r
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))) {
		goto _1
	_1:
		l++
		r++
	}
	return x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func x_strcasestr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	//FIXME!
	return x_strstr(tls, h, n)
}

func x_strcat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x_strcpy(tls, dest+uintptr(x_strlen(tls, dest)), src)
	return dest
}

func x_strchr(tls *TLS, s uintptr, c int32) (r uintptr) {
	var k uint64
	var w, v1 uintptr
	c = int32(int8(c))
	if !(c != 0) {
		return s + uintptr(x_strlen(tls, s))
	}
	for ; uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && *(*int8)(unsafe.Pointer(s)) != 0 && int32(*(*int8)(unsafe.Pointer(s))) != c; s++ {
	}
	if *(*int8)(unsafe.Pointer(s)) != 0 && int32(*(*int8)(unsafe.Pointer(s))) != c {
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
		for w = s; !((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); w += 8 {
		}
		for s = w; *(*int8)(unsafe.Pointer(s)) != 0 && int32(*(*int8)(unsafe.Pointer(s))) != c; s++ {
		}
	}
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_strchrnul(tls *TLS, s uintptr, c int32) (r uintptr) {
	var p, v1 uintptr
	p = x_strchr(tls, s, c)
	if p != 0 {
		v1 = p
	} else {
		v1 = s + uintptr(x_strlen(tls, s))
	}
	return v1
}

func x_strcmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	for int32(*(*int8)(unsafe.Pointer(l))) == int32(*(*int8)(unsafe.Pointer(r))) && *(*int8)(unsafe.Pointer(l)) != 0 && *(*int8)(unsafe.Pointer(r)) != 0 {
		goto _1
	_1:
		l++
		r++
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func x_strcpy(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x___stpcpy(tls, dest, src)
	return dest
}

func x_strcspn(tls *TLS, _s uintptr, _c uintptr) (r uint64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var a, c, s, v2, p3 uintptr
	var v1 uint64
	var v4 bool
	var _ /* byteset at bp+0 */ [4]uint64
	s = _s
	c = _c
	a = s
	if !(*(*uint8)(unsafe.Pointer(c)) != 0) {
		return x_strlen(tls, s)
	}
	if !(*(*uint8)(unsafe.Pointer(c + 1)) != 0) {
		v2 = x_strchr(tls, s, int32(*(*uint8)(unsafe.Pointer(c))))
		s = v2
		if v2 != 0 {
			v1 = uint64(int64(s) - int64(a))
		} else {
			v1 = x_strlen(tls, a)
		}
		return v1
	}
	x_memset(tls, bp, 0, uint64(32))
	for ; ; c++ {
		if v4 = *(*uint8)(unsafe.Pointer(c)) != 0; v4 {
			p3 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*uint64)(unsafe.Pointer(p3)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(c))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		}
		if !(v4 && *(*uint64)(unsafe.Pointer(p3)) != 0) {
			break
		}
	}
	for ; *(*uint8)(unsafe.Pointer(s)) != 0 && !((*(*[4]uint64)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0); s++ {
	}
	return uint64(int64(s) - int64(a))
}

func x___strdup(tls *TLS, s uintptr) (r uintptr) {
	var d uintptr
	var l uint64
	l = x_strlen(tls, s)
	d = x_malloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	return x_memcpy(tls, d, s, l+uint64(1))
}

func x_strerror_r(tls *TLS, err int32, buf uintptr, buflen uint64) (r int32) {
	var msg uintptr
	msg = x_strerror(tls, err)
	if x_strlen(tls, msg) >= buflen {
		return int32(m_ERANGE)
	}
	x_strcpy(tls, buf, msg)
	return 0
}

func x_strlcat(tls *TLS, d uintptr, s uintptr, n uint64) (r uint64) {
	var l uint64
	l = x_strnlen(tls, d, n)
	if l == n {
		return l + x_strlen(tls, s)
	}
	return l + x_strlcpy(tls, d+uintptr(l), s, n-l)
}

func x_strlcpy(tls *TLS, d uintptr, s uintptr, n uint64) (r uint64) {
	var d0, wd, ws, v5 uintptr
	var v1 uint64
	var v2, v7 int8
	var v3, v8 bool
	d0 = d
	v1 = n
	n--
	if !(v1 != 0) {
		goto finish
	}
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v3 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v3 {
				v2 = *(*int8)(unsafe.Pointer(s))
				*(*int8)(unsafe.Pointer(d)) = v2
			}
			if !(v3 && v2 != 0) {
				break
			}
			goto _4
		_4:
			n--
			s++
			d++
		}
		if n != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
			wd = d
			ws = s
			for n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
				*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
				goto _6
			_6:
				n -= uint64(8)
				ws += 8
				v5 = wd
				wd += 8
				_ = *(*uint64)(unsafe.Pointer(v5))
			}
			d = wd
			s = ws
		}
	}
	for {
		if v8 = n != 0; v8 {
			v7 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v7
		}
		if !(v8 && v7 != 0) {
			break
		}
		goto _9
	_9:
		n--
		s++
		d++
	}
	*(*int8)(unsafe.Pointer(d)) = 0
finish:
	return uint64(int64(d)-int64(d0)) + x_strlen(tls, s)
	return r
}

func x_strlen(tls *TLS, s uintptr) (r uint64) {
	var a, w uintptr
	a = s
	for ; uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && *(*int8)(unsafe.Pointer(s)) != 0; s++ {
	}
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		for w = s; !((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); w += 8 {
		}
		for s = w; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
	}
	return uint64(int64(s) - int64(a))
}

func x_strncasecmp(tls *TLS, _l uintptr, _r uintptr, n uint64) (r1 int32) {
	var l, r uintptr
	var v1 uint64
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return 0
	}
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))) {
		goto _2
	_2:
		l++
		r++
		n--
	}
	return x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func x_strncat(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var a, v2, v3, v5 uintptr
	var v1 int8
	var v4 bool
	a = d
	d += uintptr(x_strlen(tls, d))
	for {
		if v4 = n != 0; v4 {
			v2 = s
			s++
			v1 = *(*int8)(unsafe.Pointer(v2))
			v3 = d
			d++
			*(*int8)(unsafe.Pointer(v3)) = v1
		}
		if !(v4 && v1 != 0) {
			break
		}
		n--
	}
	v5 = d
	d++
	*(*int8)(unsafe.Pointer(v5)) = 0
	return a
}

func x_strncmp(tls *TLS, _l uintptr, _r uintptr, n uint64) (r1 int32) {
	var l, r uintptr
	var v1 uint64
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return 0
	}
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) {
		goto _2
	_2:
		l++
		r++
		n--
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func x_strncpy(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	x___stpncpy(tls, d, s, n)
	return d
}

func x_strndup(tls *TLS, s uintptr, n uint64) (r uintptr) {
	var d uintptr
	var l uint64
	l = x_strnlen(tls, s, n)
	d = x_malloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	x_memcpy(tls, d, s, l)
	*(*int8)(unsafe.Pointer(d + uintptr(l))) = 0
	return d
}

func x_strnlen(tls *TLS, s uintptr, n uint64) (r uint64) {
	var p uintptr
	var v1 uint64
	p = x_memchr(tls, s, 0, n)
	if p != 0 {
		v1 = uint64(int64(p) - int64(s))
	} else {
		v1 = n
	}
	return v1
}

func x_strpbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	var v1 uintptr
	s += uintptr(x_strcspn(tls, s, b))
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_strrchr(tls *TLS, s uintptr, c int32) (r uintptr) {
	var p, v1 uintptr
	c = int32(int8(c))
	for p = s + uintptr(x_strlen(tls, s)); p >= s && int32(*(*int8)(unsafe.Pointer(p))) != c; p-- {
	}
	if p >= s {
		v1 = p
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_strsep(tls *TLS, str uintptr, sep uintptr) (r uintptr) {
	var end, s, v1 uintptr
	s = *(*uintptr)(unsafe.Pointer(str))
	if !(s != 0) {
		return UintptrFromInt32(0)
	}
	end = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(end)) != 0 {
		v1 = end
		end++
		*(*int8)(unsafe.Pointer(v1)) = 0
	} else {
		end = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(str)) = end
	return s
}

var _strings = [502]int8{'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 'i', 'g', 'n', 'a', 'l', 0, 'H', 'a', 'n', 'g', 'u', 'p', 0, 'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 0, 'Q', 'u', 'i', 't', 0, 'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'i', 'n', 's', 't', 'r', 'u', 'c', 't', 'i', 'o', 'n', 0, 'T', 'r', 'a', 'c', 'e', '/', 'b', 'r', 'e', 'a', 'k', 'p', 'o', 'i', 'n', 't', ' ', 't', 'r', 'a', 'p', 0, 'A', 'b', 'o', 'r', 't', 'e', 'd', 0, 'B', 'u', 's', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'F', 'l', 'o', 'a', 't', 'i', 'n', 'g', ' ', 'p', 'o', 'i', 'n', 't', ' ', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 0, 'K', 'i', 'l', 'l', 'e', 'd', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '1', 0, 'S', 'e', 'g', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'u', 'l', 't', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '2', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e', 0, 'A', 'l', 'a', 'r', 'm', ' ', 'c', 'l', 'o', 'c', 'k', 0, 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', 0, 'S', 't', 'a', 'c', 'k', ' ', 'f', 'a', 'u', 'l', 't', 0, 'C', 'h', 'i', 'l', 'd', ' ', 'e', 'x', 'i', 't', 'e', 'd', 0, 'C', 'o', 'n', 't', 'i', 'n', 'u', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 's', 'i', 'g', 'n', 'a', 'l', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'i', 'n', 'p', 'u', 't', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'o', 'u', 't', 'p', 'u', 't', ')', 0, 'U', 'r', 'g', 'e', 'n', 't', ' ', 'I', '/', 'O', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 0, 'C', 'P', 'U', ' ', 't', 'i', 'm', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'F', 'i', 'l', 'e', ' ', 's', 'i', 'z', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'V', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'P', 'r', 'o', 'f', 'i', 'l', 'i', 'n', 'g', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'W', 'i', 'n', 'd', 'o', 'w', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', 0, 'I', '/', 'O', ' ', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e', 0, 'P', 'o', 'w', 'e', 'r', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', 0, 'B', 'a', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l'}

func x_strsignal(tls *TLS, signum int32) (r uintptr) {
	var s uintptr
	var v1 int32
	s = uintptr(unsafe.Pointer(&_strings))
	signum = signum
	if uint32(signum)-uint32(1) > uint32(31) {
		signum = 0
	}
	for ; ; s++ {
		v1 = signum
		signum--
		if !(v1 != 0) {
			break
		}
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
	}
	return s
}

func x_strspn(tls *TLS, _s uintptr, _c uintptr) (r uint64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var a, c, s, p1 uintptr
	var v2 bool
	var _ /* byteset at bp+0 */ [4]uint64
	s = _s
	c = _c
	a = s
	*(*[4]uint64)(unsafe.Pointer(bp)) = [4]uint64{}
	if !(*(*uint8)(unsafe.Pointer(c)) != 0) {
		return uint64(0)
	}
	if !(*(*uint8)(unsafe.Pointer(c + 1)) != 0) {
		for ; int32(*(*uint8)(unsafe.Pointer(s))) == int32(*(*uint8)(unsafe.Pointer(c))); s++ {
		}
		return uint64(int64(s) - int64(a))
	}
	for ; ; c++ {
		if v2 = *(*uint8)(unsafe.Pointer(c)) != 0; v2 {
			p1 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*uint64)(unsafe.Pointer(p1)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(c))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		}
		if !(v2 && *(*uint64)(unsafe.Pointer(p1)) != 0) {
			break
		}
	}
	for ; *(*uint8)(unsafe.Pointer(s)) != 0 && (*(*[4]uint64)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0; s++ {
	}
	return uint64(int64(s) - int64(a))
}

func _twobyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw uint16
	var v1, v3 uintptr
	nw = uint16(int32(*(*uint8)(unsafe.Pointer(n)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + 1))))
	hw = uint16(int32(*(*uint8)(unsafe.Pointer(h)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + 1))))
	for h++; *(*uint8)(unsafe.Pointer(h)) != 0 && int32(hw) != int32(nw); {
		goto _2
	_2:
		h++
		v1 = h
		hw = uint16(int32(hw)<<int32(8) | int32(*(*uint8)(unsafe.Pointer(v1))))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(1)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _threebyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw uint32
	var v1, v3 uintptr
	nw = uint32(int32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8))
	hw = uint32(int32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8))
	h += uintptr(2)
	for *(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw {
		goto _2
	_2:
		h++
		v1 = h
		hw = (hw | uint32(*(*uint8)(unsafe.Pointer(v1)))) << int32(8)
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(2)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _fourbyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw uint32
	var v1, v3 uintptr
	nw = uint32(int32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + 3))))
	hw = uint32(int32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16) | int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + 3))))
	h += uintptr(3)
	for *(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw {
		goto _2
	_2:
		h++
		v1 = h
		hw = hw<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(v1)))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(3)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _twoway_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var grow, ip, jp, k, l, mem, mem0, ms, p, p0, v1, v2, v3, v4, v5, v6, v7, v8 uint64
	var shift [256]uint64
	var z, z2 uintptr
	var _ /* byteset at bp+0 */ [4]uint64
	*(*[4]uint64)(unsafe.Pointer(bp)) = [4]uint64{}
	/* Computing length of needle and fill shift table */
	for l = uint64(0); *(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 && *(*uint8)(unsafe.Pointer(h + uintptr(l))) != 0; l++ {
		*(*uint64)(unsafe.Pointer(bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l))))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l)))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		shift[*(*uint8)(unsafe.Pointer(n + uintptr(l)))] = l + Uint64FromInt32(1)
	}
	if *(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v1 = Uint64FromInt32(1)
	p = v1
	k = v1
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) > int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v2 = jp
				jp++
				ip = v2
				v3 = Uint64FromInt32(1)
				p = v3
				k = v3
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v4 = Uint64FromInt32(1)
	p = v4
	k = v4
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) < int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v5 = jp
				jp++
				ip = v5
				v6 = Uint64FromInt32(1)
				p = v6
				k = v6
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if x_memcmp(tls, n, n+uintptr(p), ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v7 = ms
		} else {
			v7 = l - ms - uint64(1)
		}
		p = v7 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64(int64(z)-int64(h)) < l {
			/* Fast estimate for MIN(l,63) */
			grow = l | uint64(63)
			z2 = x_memchr(tls, z, 0, grow)
			if z2 != 0 {
				z = z2
				if uint64(int64(z)-int64(h)) < l {
					return uintptr(0)
				}
			} else {
				z += uintptr(grow)
			}
		}
		/* Check last byte first; advance by shift on mismatch */
		if (*(*[4]uint64)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
			k = l - shift[*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1))))]
			//printf("adv by %zu (on %c) at [%s] (%zu;l=%zu)\n", k, h[l-1], h, shift[h[l-1]], l);
			if k != 0 {
				if mem0 != 0 && mem != 0 && k < p {
					k = l - p
				}
				h += uintptr(k)
				mem = uint64(0)
				continue
			}
		} else {
			h += uintptr(l)
			mem = uint64(0)
			continue
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v8 = ms + uint64(1)
		} else {
			v8 = mem
		}
		k = v8
		for ; *(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k)))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k)))); k++ {
		}
		if *(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 {
			h += uintptr(k - ms)
			mem = uint64(0)
			continue
		}
		/* Compare left half */
		for k = ms + uint64(1); k > mem && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k-uint64(1))))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k-uint64(1))))); k-- {
		}
		if k == mem {
			return h
		}
		h += uintptr(p)
		mem = mem0
	}
	return r
}

func x_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	/* Return immediately on empty needle */
	if !(*(*int8)(unsafe.Pointer(n)) != 0) {
		return h
	}
	/* Use faster algorithms for short needles */
	h = x_strchr(tls, h, int32(*(*int8)(unsafe.Pointer(n))))
	if !(h != 0) || !(*(*int8)(unsafe.Pointer(n + 1)) != 0) {
		return h
	}
	if !(*(*int8)(unsafe.Pointer(h + 1)) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + 2)) != 0) {
		return _twobyte_strstr(tls, h, n)
	}
	if !(*(*int8)(unsafe.Pointer(h + 2)) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + 3)) != 0) {
		return _threebyte_strstr(tls, h, n)
	}
	if !(*(*int8)(unsafe.Pointer(h + 3)) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + 4)) != 0) {
		return _fourbyte_strstr(tls, h, n)
	}
	return _twoway_strstr(tls, h, n)
}

func x_strtok(tls *TLS, s uintptr, sep uintptr) (r uintptr) {
	var v1, v3, v4 uintptr
	var v2 bool
	if v2 = !(s != 0); v2 {
		v1 = _p3
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s += uintptr(x_strspn(tls, s, sep))
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		_p3 = v3
		return v3
	}
	_p3 = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(_p3)) != 0 {
		v4 = _p3
		_p3++
		*(*int8)(unsafe.Pointer(v4)) = 0
	} else {
		_p3 = uintptr(0)
	}
	return s
}

var _p3 uintptr

func x_strtok_r(tls *TLS, s uintptr, sep uintptr, p uintptr) (r uintptr) {
	var v1, v3, v4, v5 uintptr
	var v2 bool
	if v2 = !(s != 0); v2 {
		v1 = *(*uintptr)(unsafe.Pointer(p))
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s += uintptr(x_strspn(tls, s, sep))
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		*(*uintptr)(unsafe.Pointer(p)) = v3
		return v3
	}
	*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))) != 0 {
		v5 = p
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5))++
		*(*int8)(unsafe.Pointer(v4)) = 0
	} else {
		*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
	}
	return s
}

func x_swab(tls *TLS, _src uintptr, _dest uintptr, n int64) {
	var dest, src uintptr
	src = _src
	dest = _dest
	for n > 0 {
		*(*int8)(unsafe.Pointer(dest)) = *(*int8)(unsafe.Pointer(src + 1))
		*(*int8)(unsafe.Pointer(dest + 1)) = *(*int8)(unsafe.Pointer(src))
		dest += uintptr(2)
		src += uintptr(2)
		goto _1
	_1:
		n -= int64(2)
	}
}

func x_wcscat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x_wcscpy(tls, dest+uintptr(x_wcslen(tls, dest))*4, src)
	return dest
}

func x_wcschr(tls *TLS, s uintptr, c int32) (r uintptr) {
	var v1 uintptr
	if !(c != 0) {
		return s + uintptr(x_wcslen(tls, s))*4
	}
	for ; *(*int32)(unsafe.Pointer(s)) != 0 && *(*int32)(unsafe.Pointer(s)) != c; s += 4 {
	}
	if *(*int32)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_wcscmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	for *(*int32)(unsafe.Pointer(l)) == *(*int32)(unsafe.Pointer(r)) && *(*int32)(unsafe.Pointer(l)) != 0 && *(*int32)(unsafe.Pointer(r)) != 0 {
		goto _1
	_1:
		l += 4
		r += 4
	}
	return *(*int32)(unsafe.Pointer(l)) - *(*int32)(unsafe.Pointer(r))
}

func x_wcscpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	var a, v2, v3 uintptr
	var v1 int32
	a = d
	for {
		v2 = s
		s += 4
		v1 = *(*int32)(unsafe.Pointer(v2))
		v3 = d
		d += 4
		*(*int32)(unsafe.Pointer(v3)) = v1
		if !(v1 != 0) {
			break
		}
	}
	return a
}

func x_wcscspn(tls *TLS, s uintptr, c uintptr) (r uint64) {
	var a, v2, v3 uintptr
	var v1 uint64
	if !(*(*int32)(unsafe.Pointer(c)) != 0) {
		return x_wcslen(tls, s)
	}
	if !(*(*int32)(unsafe.Pointer(c + 1*4)) != 0) {
		v3 = s
		a = v3
		v2 = x_wcschr(tls, v3, *(*int32)(unsafe.Pointer(c)))
		s = v2
		if v2 != 0 {
			v1 = uint64((int64(s) - int64(a)) / 4)
		} else {
			v1 = x_wcslen(tls, a)
		}
		return v1
	}
	for a = s; *(*int32)(unsafe.Pointer(s)) != 0 && !(x_wcschr(tls, c, *(*int32)(unsafe.Pointer(s))) != 0); s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func x_wcslen(tls *TLS, s uintptr) (r uint64) {
	var a uintptr
	for a = s; *(*int32)(unsafe.Pointer(s)) != 0; s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func x_wcsncat(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var a, v2, v3, v5 uintptr
	var v1 int32
	var v4 bool
	a = d
	d += uintptr(x_wcslen(tls, d)) * 4
	for {
		if v4 = n != 0; v4 {
			v2 = s
			s += 4
			v1 = *(*int32)(unsafe.Pointer(v2))
			v3 = d
			d += 4
			*(*int32)(unsafe.Pointer(v3)) = v1
		}
		if !(v4 && v1 != 0) {
			break
		}
		n--
	}
	v5 = d
	d += 4
	*(*int32)(unsafe.Pointer(v5)) = 0
	return a
}

func x_wcsncmp(tls *TLS, l uintptr, r uintptr, n uint64) (r1 int32) {
	var v2 int32
	for n != 0 && *(*int32)(unsafe.Pointer(l)) == *(*int32)(unsafe.Pointer(r)) && *(*int32)(unsafe.Pointer(l)) != 0 && *(*int32)(unsafe.Pointer(r)) != 0 {
		goto _1
	_1:
		l += 4
		r += 4
	}
	if n != 0 {
		v2 = *(*int32)(unsafe.Pointer(l)) - *(*int32)(unsafe.Pointer(r))
	} else {
		v2 = 0
	}
	return v2
}

func x_wcsncpy(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var a, v2, v3 uintptr
	var v1 int32
	var v4 bool
	a = d
	for {
		if v4 = n != 0; v4 {
			v2 = s
			s += 4
			v1 = *(*int32)(unsafe.Pointer(v2))
			v3 = d
			d += 4
			*(*int32)(unsafe.Pointer(v3)) = v1
		}
		if !(v4 && v1 != 0) {
			break
		}
		n--
	}
	x_wmemset(tls, d, 0, n)
	return a
}

func x_wcspbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	var v1 uintptr
	s += uintptr(x_wcscspn(tls, s, b)) * 4
	if *(*int32)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = UintptrFromInt32(0)
	}
	return v1
}

func x_wcsrchr(tls *TLS, s uintptr, c int32) (r uintptr) {
	var p, v1 uintptr
	for p = s + uintptr(x_wcslen(tls, s))*4; p >= s && *(*int32)(unsafe.Pointer(p)) != c; p -= 4 {
	}
	if p >= s {
		v1 = p
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_wcsspn(tls *TLS, s uintptr, c uintptr) (r uint64) {
	var a uintptr
	for a = s; *(*int32)(unsafe.Pointer(s)) != 0 && x_wcschr(tls, c, *(*int32)(unsafe.Pointer(s))) != 0; s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func _naive_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var i uint64
	var v2 uintptr
	for i = uint64(0); *(*int32)(unsafe.Pointer(n + uintptr(i)*4)) != 0 && *(*int32)(unsafe.Pointer(h + uintptr(i)*4)) != 0; i++ {
		for *(*int32)(unsafe.Pointer(n + uintptr(i)*4)) != *(*int32)(unsafe.Pointer(h + uintptr(i)*4)) {
			goto _1
		_1:
			h += 4
			i = Uint64FromInt32(0)
		}
	}
	if *(*int32)(unsafe.Pointer(n + uintptr(i)*4)) != 0 {
		v2 = uintptr(0)
	} else {
		v2 = h
	}
	return v2
}

func _twoway_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var grow, ip, jp, k, l, mem, mem0, ms, p, p0, v1, v2, v3, v4, v5, v6, v7, v8 uint64
	var z, z2 uintptr
	/* Computing length of needle */
	for l = uint64(0); *(*int32)(unsafe.Pointer(n + uintptr(l)*4)) != 0 && *(*int32)(unsafe.Pointer(h + uintptr(l)*4)) != 0; l++ {
	}
	if *(*int32)(unsafe.Pointer(n + uintptr(l)*4)) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v1 = Uint64FromInt32(1)
	p = v1
	k = v1
	for jp+k < l {
		if *(*int32)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*int32)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*int32)(unsafe.Pointer(n + uintptr(ip+k)*4)) > *(*int32)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v2 = jp
				jp++
				ip = v2
				v3 = Uint64FromInt32(1)
				p = v3
				k = v3
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v4 = Uint64FromInt32(1)
	p = v4
	k = v4
	for jp+k < l {
		if *(*int32)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*int32)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*int32)(unsafe.Pointer(n + uintptr(ip+k)*4)) < *(*int32)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v5 = jp
				jp++
				ip = v5
				v6 = Uint64FromInt32(1)
				p = v6
				k = v6
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if x_wmemcmp(tls, n, n+uintptr(p)*4, ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v7 = ms
		} else {
			v7 = l - ms - uint64(1)
		}
		p = v7 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64((int64(z)-int64(h))/4) < l {
			/* Fast estimate for MIN(l,63) */
			grow = l | uint64(63)
			z2 = x_wmemchr(tls, z, 0, grow)
			if z2 != 0 {
				z = z2
				if uint64((int64(z)-int64(h))/4) < l {
					return uintptr(0)
				}
			} else {
				z += uintptr(grow) * 4
			}
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v8 = ms + uint64(1)
		} else {
			v8 = mem
		}
		k = v8
		for ; *(*int32)(unsafe.Pointer(n + uintptr(k)*4)) != 0 && *(*int32)(unsafe.Pointer(n + uintptr(k)*4)) == *(*int32)(unsafe.Pointer(h + uintptr(k)*4)); k++ {
		}
		if *(*int32)(unsafe.Pointer(n + uintptr(k)*4)) != 0 {
			h += uintptr(k-ms) * 4
			mem = uint64(0)
			continue
		}
		/* Compare left half */
		for k = ms + uint64(1); k > mem && *(*int32)(unsafe.Pointer(n + uintptr(k-uint64(1))*4)) == *(*int32)(unsafe.Pointer(h + uintptr(k-uint64(1))*4)); k-- {
		}
		if k == mem {
			return h
		}
		h += uintptr(p) * 4
		mem = mem0
	}
	return r
}

func x_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	/* Return immediately on empty needle or haystack */
	if !(*(*int32)(unsafe.Pointer(n)) != 0) {
		return h
	}
	if !(*(*int32)(unsafe.Pointer(h)) != 0) {
		return uintptr(0)
	}
	/* Use faster algorithms for short needles */
	h = x_wcschr(tls, h, *(*int32)(unsafe.Pointer(n)))
	if !(h != 0) || !(*(*int32)(unsafe.Pointer(n + 1*4)) != 0) {
		return h
	}
	if !(*(*int32)(unsafe.Pointer(h + 1*4)) != 0) {
		return uintptr(0)
	}
	if !(*(*int32)(unsafe.Pointer(n + 2*4)) != 0) || !(*(*int32)(unsafe.Pointer(n + 3*4)) != 0) || !(*(*int32)(unsafe.Pointer(n + 4*4)) != 0) {
		return _naive_wcsstr(tls, h, n)
	}
	return _twoway_wcsstr(tls, h, n)
}

func x_wcswcs(tls *TLS, haystack uintptr, needle uintptr) (r uintptr) {
	return x_wcsstr(tls, haystack, needle)
}

func x_wmemchr(tls *TLS, s uintptr, c int32, n uint64) (r uintptr) {
	var v1 uintptr
	for ; n != 0 && *(*int32)(unsafe.Pointer(s)) != c; s += 4 {
	}
	if n != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_wmemcmp(tls *TLS, l uintptr, r uintptr, n uint64) (r1 int32) {
	var v2 int32
	for n != 0 && *(*int32)(unsafe.Pointer(l)) == *(*int32)(unsafe.Pointer(r)) {
		goto _1
	_1:
		n--
		l += 4
		r += 4
	}
	if n != 0 {
		v2 = *(*int32)(unsafe.Pointer(l)) - *(*int32)(unsafe.Pointer(r))
	} else {
		v2 = 0
	}
	return v2
}

func x_wmemcpy(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var a, v2, v3 uintptr
	var v1 uint64
	a = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		v3 = s
		s += 4
		*(*int32)(unsafe.Pointer(v2)) = *(*int32)(unsafe.Pointer(v3))
	}
	return a
}

func x_wmemmove(tls *TLS, d uintptr, s uintptr, n uint64) (r uintptr) {
	var v1 uint64
	if uint64((int64(d)-int64(s))/4) < n {
		for {
			v1 = n
			n--
			if !(v1 != 0) {
				break
			}
			*(*int32)(unsafe.Pointer(d + uintptr(n)*4)) = *(*int32)(unsafe.Pointer(s + uintptr(n)*4))
		}
		return d
	}
	return x_wmemcpy(tls, d, s, n)
}

func x_wmemset(tls *TLS, d uintptr, c int32, n uint64) (r uintptr) {
	var ret, v2 uintptr
	var v1 uint64
	ret = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		*(*int32)(unsafe.Pointer(v2)) = c
	}
	return ret
}

type Tutmpx = struct {
	Fut_type   int16
	Fut_pid    int32
	Fut_line   [32]int8
	Fut_id     [4]int8
	Fut_user   [32]int8
	Fut_host   [256]int8
	F__ut_exit struct {
		F__e_termination int16
		F__e_exit        int16
	}
	Fut_session   int64
	Fut_tv        Ttimeval
	Fut_addr_v6   [4]uint32
	F__unused     [20]int8
	F__ccgo_pad11 [4]byte
}

func x_endutxent(tls *TLS) {
}

func x_setutxent(tls *TLS) {
}

func x_getutxent(tls *TLS) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_getutxid(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_getutxline(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_pututxline(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

const m_EEXIST = 17

//#define LFS64_2(x, y) weak_alias(x, y)

func x_mkdtemp(tls *TLS, template uintptr) (r uintptr) {
	for {
		if !(x___mktemp(tls, template) != 0) {
			return uintptr(0)
		}
		if !(x_mkdir(tls, template, uint32(0700)) != 0) {
			return template
		}
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EEXIST) {
			return uintptr(0)
		}
		/* this is safe because mktemp verified
		 * that we have a valid template string */
		x_strcpy(tls, template+uintptr(x_strlen(tls, template))-uintptr(6), ts+1137)
	}
	return r
}

const m_O_EXCL = 128

//#define LFS64_2(x, y) weak_alias(x, y)

func x_mkstemp(tls *TLS, template uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	var fd int32
retry:
	if !(x___mktemp(tls, template) != 0) {
		return -int32(1)
	}
	fd = x_open(tls, template, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_EXCL), VaList(bp+8, int32(0600)))
	if fd >= 0 {
		return fd
	}
	if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EEXIST) {
		/* this is safe because mktemp verified
		 * that we have a valid template string */
		x_strcpy(tls, template+uintptr(x_strlen(tls, template))-uintptr(6), ts+1137)
		goto retry
	}
	return -int32(1)
}

func x___mktemp(tls *TLS, template uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	var l int32
	l = int32(x_strlen(tls, template))
	if l < int32(6) || x_strcmp(tls, template+uintptr(l)-uintptr(6), ts+1137) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return UintptrFromInt32(0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock7)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock7))
		_ = Int32FromInt32(1)
	}
	for ; _index2 < int32(1000000); _index2++ {
		x_snprintf(tls, template+uintptr(l)-uintptr(6), uint64(6), ts+1144, VaList(bp+8, _index2))
		if x_access(tls, template, m_F_OK) != 0 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock7)))) = 0
			return template
		}
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock7)))) = 0
	return UintptrFromInt32(0)
}

var _lock7 int32

var _index2 int32

const m_CBAUD = 4111

func x_cfgetospeed(tls *TLS, tio uintptr) (r uint32) {
	return (*Ttermios)(unsafe.Pointer(tio)).Fc_cflag & uint32(m_CBAUD)
}

func x_cfgetispeed(tls *TLS, tio uintptr) (r uint32) {
	return x_cfgetospeed(tls, tio)
}

func x_cfsetospeed(tls *TLS, tio uintptr, speed uint32) (r int32) {
	if speed&uint32(^Int32FromInt32(m_CBAUD)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	*(*uint32)(unsafe.Pointer(tio + 8)) &= uint32(^Int32FromInt32(m_CBAUD))
	*(*uint32)(unsafe.Pointer(tio + 8)) |= speed
	return 0
}

func x_cfsetispeed(tls *TLS, tio uintptr, speed uint32) (r int32) {
	var v1 int32
	if speed != 0 {
		v1 = x_cfsetospeed(tls, tio, speed)
	} else {
		v1 = 0
	}
	return v1
}

const m_TCSBRK = 21513

func x_tcdrain(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	return x_ioctl(tls, fd, int32(m_TCSBRK), VaList(bp+8, int32(1)))
}

const m_TCXONC = 21514

func x_tcflow(tls *TLS, fd int32, action int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	return x_ioctl(tls, fd, int32(m_TCXONC), VaList(bp+8, action))
}

const m_TCFLSH = 21515

func x_tcflush(tls *TLS, fd int32, queue int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	return x_ioctl(tls, fd, int32(m_TCFLSH), VaList(bp+8, queue))
}

const m_TCGETS = 21505

func x_tcgetattr(tls *TLS, fd int32, tio uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	if x_ioctl(tls, fd, int32(m_TCGETS), VaList(bp+8, tio)) != 0 {
		return -int32(1)
	}
	return 0
}

const m_TIOCGSID = 21545

func x_tcgetsid(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var _ /* sid at bp+0 */ int32
	if x_ioctl(tls, fd, int32(m_TIOCGSID), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func x_tcsendbreak(tls *TLS, fd int32, dur int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	/* nonzero duration is implementation-defined, so ignore it */
	return x_ioctl(tls, fd, int32(m_TCSBRK), VaList(bp+8, 0))
}

const m_TCSETS = 21506

func x_tcsetattr(tls *TLS, fd int32, act int32, tio uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxVaListSize 8 */
	defer tls.Free(16)
	if act < 0 || act > int32(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return x_ioctl(tls, fd, int32(m_TCSETS)+act, VaList(bp+8, tio))
}

const m___NR_futex = 202

func x___futex(tls *TLS, addr uintptr, op int32, val int32, ts uintptr) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_futex), int64(addr), int64(op), int64(val), int64(ts)))
}

func x___lock(tls *TLS, l uintptr) {
	var spins int32
	spins = int32(100000)
	/* Do not use futexes because we insist that unlocking is a simple
	 * assignment to optimize non-pathological code with no contention. */
	for _a_swap(tls, l, int32(1)) != 0 {
		if spins != 0 {
			spins--
			_a_spin(tls)
		} else {
			_syscall0(tls, int64(m___NR_sched_yield))
		}
	}
}

const m_ETIMEDOUT = 110
const m_FUTEX_WAIT = 0

func x___timedwait(tls *TLS, addr uintptr, val int32, clk int32, at uintptr, priv int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1 uint64
	var v2 int64
	var _ /* to at bp+0 */ Ttimespec
	if at != 0 {
		x_clock_gettime(tls, clk, bp)
		(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec = (*Ttimespec)(unsafe.Pointer(at)).Ftv_sec - (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
		v1 = (*Ttimespec)(unsafe.Pointer(at)).Ftv_nsec - (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec
		(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec = v1
		if v1 < uint64(0) {
			(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec--
			*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec)))) += uint64(1000000000)
		}
		if (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec < 0 {
			return int32(m_ETIMEDOUT)
		}
	}
	if priv != 0 {
		priv = int32(128)
	}
	priv = 0
	if at != 0 {
		v2 = int64(bp)
	} else {
		v2 = 0
	}
	return int32(_syscall4(tls, int64(m___NR_futex), int64(addr), int64(m_FUTEX_WAIT|priv), int64(val), v2))
}

func x___wait(tls *TLS, addr uintptr, waiters uintptr, val int32, priv int32) {
	var spins, v1 int32
	spins = int32(50000)
	if priv != 0 {
		priv = int32(128)
	}
	priv = 0
	for {
		v1 = spins
		spins--
		if !(v1 != 0) {
			break
		}
		if *(*int32)(unsafe.Pointer(addr)) == val {
			_a_spin(tls)
		} else {
			return
		}
	}
	if waiters != 0 {
		_a_inc(tls, waiters)
	}
	for *(*int32)(unsafe.Pointer(addr)) == val {
		_syscall4(tls, int64(m___NR_futex), int64(addr), int64(m_FUTEX_WAIT|priv), int64(val), 0)
	}
	if waiters != 0 {
		_a_dec(tls, waiters)
	}
}

const m_FUTEX_WAKE = 1

func x___wake(tls *TLS, addr uintptr, cnt int32, priv int32) {
	if priv != 0 {
		priv = int32(128)
	}
	priv = 0
	if cnt < 0 {
		cnt = int32(m_INT_MAX)
	}
	_syscall3(tls, int64(m___NR_futex), int64(addr), int64(int32(m_FUTEX_WAKE)|priv), int64(cnt))
}

func x___pthread_register_cancel(tls *TLS, cb uintptr) {
	var self uintptr
	self = x_pthread_self(tls)
	(*T__ptcb)(unsafe.Pointer(cb)).F__next = (*T__pthread)(unsafe.Pointer(self)).Fcancelbuf
	(*T__pthread)(unsafe.Pointer(self)).Fcancelbuf = cb
}

func x___pthread_unregister_cancel(tls *TLS, cb uintptr) {
	var self uintptr
	self = ___pthread_self(tls)
	(*T__pthread)(unsafe.Pointer(self)).Fcancelbuf = (*T__ptcb)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Fcancelbuf)).F__next
}

func x_pthread_attr_destroy(tls *TLS, a uintptr) (r int32) {
	return 0
}

func x_pthread_attr_getdetachstate(tls *TLS, a uintptr, state uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(state)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(2)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4))
	return 0
}

func x_pthread_attr_getguardsize(tls *TLS, a uintptr, size uintptr) (r int32) {
	*(*uint64)(unsafe.Pointer(size)) = *(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + 1*8)) + uint64(m_PAGESIZE)
	return 0
}

func x_pthread_attr_getscope(tls *TLS, a uintptr, scope uintptr) (r int32) {
	return 0
}

func x_pthread_attr_getstacksize(tls *TLS, a uintptr, size uintptr) (r int32) {
	*(*uint64)(unsafe.Pointer(size)) = *(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)))) + uint64(Int32FromInt32(16384)-Int32FromInt32(m_PAGESIZE))
	return 0
}

func x_pthread_attr_init(tls *TLS, a uintptr) (r int32) {
	x_memset(tls, a, 0, uint64(56))
	return 0
}

func x_pthread_attr_setdetachstate(tls *TLS, a uintptr, state int32) (r int32) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(2)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4)) = state
	return 0
}

func x_pthread_attr_setguardsize(tls *TLS, a uintptr, size uint64) (r int32) {
	if size > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(8) {
		return int32(m_EINVAL)
	}
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + 1*8)) = size - uint64(m_PAGESIZE)
	return 0
}

func x_pthread_attr_setscope(tls *TLS, a uintptr, scope int32) (r int32) {
	return 0
}

func x_pthread_attr_setstacksize(tls *TLS, a uintptr, size uint64) (r int32) {
	if size-uint64(m_PAGESIZE) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(4) {
		return int32(m_EINVAL)
	}
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)))) = size - uint64(Int32FromInt32(16384)-Int32FromInt32(m_PAGESIZE))
	return 0
}

func x_pthread_barrier_destroy(tls *TLS, b uintptr) (r int32) {
	return 0
}

func x_pthread_barrier_init(tls *TLS, b uintptr, a uintptr, count uint32) (r int32) {
	if !(count != 0) {
		return int32(m_EINVAL)
	}
	*(*Tpthread_barrier_t)(unsafe.Pointer(b)) = Tpthread_barrier_t{F__u: *(*struct {
		F__p [0][1]uintptr
		F__i [8]int32
	})(unsafe.Pointer(&struct {
		_ [4]byte
		f int32
		_ [24]byte
	}{f: int32(count - Uint32FromInt32(1))}))}
	return 0
}

func x_pthread_barrier_wait(tls *TLS, b uintptr) (r int32) {
	var cur, v1, v2 int32
	/* Trivial case: count was set at 1 */
	if !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 1*4)) != 0) {
		return -int32(1)
	}
	/* Wait for anyone still suspended at previous use of barrier */
	for {
		v1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 2*4))
		cur = v1
		if !(v1 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i))+2*4, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i))+3*4, cur, 0)
	}
	/* If we are the last to reach barrier, reset it and wake others */
	if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)), int32(1)) == *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 1*4)) {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 2*4)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 1*4))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)))) = 0
		x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)), -int32(1), 0)
		return -int32(1)
	}
	/* Wait for our peers to reach the barrier */
	for {
		v2 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i))))
		cur = v2
		if !(v2 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)), uintptr(0), cur, 0)
	}
	/* If we're the last to wake up and barrier is awaiting reuse */
	if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i))+2*4, -int32(1)) == int32(1) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + 3*4)) != 0 {
		x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i))+2*4, -int32(1), 0)
	}
	return 0
}

const m___NR_tgkill = 234

func x_pthread_cancel(tls *TLS, t uintptr) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_tgkill), int64((*T__pthread)(unsafe.Pointer(t)).Fpid), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(m_SIGCANCEL)))
}

func x_pthread_cond_broadcast(tls *TLS, c uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)))) = 0
	x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)), -int32(1), 0)
	return 0
}

func x_pthread_cond_destroy(tls *TLS, c uintptr) (r int32) {
	return 0
}

func x_pthread_cond_init(tls *TLS, c uintptr, a uintptr) (r int32) {
	x_memset(tls, c, 0, uint64(48))
	return 0
}

func x_pthread_cond_signal(tls *TLS, c uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)))) = 0
	x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)), int32(1), 0)
	return 0
}

const m_CLOCK_REALTIME = 0
const m_libc1 = 0

func _relock(tls *TLS, m uintptr) {
	x_pthread_mutex_lock(tls, m)
}

func x_pthread_cond_timedwait(tls *TLS, c uintptr, m uintptr, ts uintptr) (r1 int32) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxVaListSize 0 */
	defer tls.Free(96)
	var __f, __x uintptr
	var e, r, v2, v5 int32
	var _ /* __cb at bp+0 */ T__ptcb
	e = 0
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	__f = __ccgo_fp(_relock)
	__x = m
	if ___setjmp(tls, uintptr(unsafe.Pointer(&(*(*T__ptcb)(unsafe.Pointer(bp))).F__jb))) != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{__f})))(tls, __x)
		x___pthread_unwind_next(tls, bp)
	}
	x___pthread_register_cancel(tls, bp)
	{
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)))) = int32(1)
		v2 = x_pthread_mutex_unlock(tls, m)
		r = v2
		if v2 != 0 {
			return r
		}
		if x___libc.Fcancelpt != 0 {
			(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
			_ = 0
		}
		_ = Int32FromInt32(0)
		e = x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)), int32(1), m_CLOCK_REALTIME, ts, 0)
		if x___libc.Fcancelpt != 0 {
			(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
			_ = 0
		}
		_ = Int32FromInt32(0)
	}
	x___pthread_unregister_cancel(tls, bp)
	if 0 != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{__f})))(tls, __x)
	}
	v5 = x_pthread_mutex_lock(tls, m)
	r = v5
	if v5 != 0 {
		return r
	}
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return e
}

func x_pthread_cond_wait(tls *TLS, c uintptr, m uintptr) (r int32) {
	return x_pthread_cond_timedwait(tls, c, m, uintptr(0))
}

const m_EAGAIN = 11
const m_PROT_EXEC = 4
const m_PROT_NONE = 0
const m_PTHREAD_DESTRUCTOR_ITERATIONS = 4
const m_PTHREAD_KEYS_MAX = 1024
const m_libc2 = 1

func x___pthread_unwind_next(tls *TLS, cb uintptr) {
	var i, j, not_finished int32
	var self, tmp uintptr
	if (*T__ptcb)(unsafe.Pointer(cb)).F__next != 0 {
		_longjmp(tls, (*T__ptcb)(unsafe.Pointer(cb)).F__next, int32(1))
	}
	self = x_pthread_self(tls)
	if (*T__pthread)(unsafe.Pointer(self)).Fcancel != 0 {
		(*T__pthread)(unsafe.Pointer(self)).Fresult = uintptr(-Int32FromInt32(1))
	}
	if !(_a_fetch_add(tls, uintptr(unsafe.Pointer(&x___libc.Fthreads_minus_1)), -int32(1)) != 0) {
		x_exit(tls, 0)
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, self+196)
		_ = Int32FromInt32(1)
	} else {
		_ = self + 196
		_ = Int32FromInt32(1)
	}
	not_finished = (*T__pthread)(unsafe.Pointer(self)).Ftsd_used
	for j = 0; not_finished != 0 && j < int32(m_PTHREAD_DESTRUCTOR_ITERATIONS); j++ {
		not_finished = 0
		for i = 0; i < int32(m_PTHREAD_KEYS_MAX); i++ {
			if *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(i)*8)) != 0 && *(*uintptr)(unsafe.Pointer(x___libc.Ftsd_keys + uintptr(i)*8)) != 0 {
				tmp = *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(i)*8))
				*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(i)*8)) = uintptr(0)
				(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(x___libc.Ftsd_keys + uintptr(i)*8))})))(tls, tmp)
				not_finished = int32(1)
			}
		}
	}
	if (*T__pthread)(unsafe.Pointer(self)).Fdetached != 0 && (*T__pthread)(unsafe.Pointer(self)).Fmap_base != 0 {
		___unmapself(tls, (*T__pthread)(unsafe.Pointer(self)).Fmap_base, (*T__pthread)(unsafe.Pointer(self)).Fmap_size)
	}
	_syscall1(tls, int64(m___NR_exit), 0)
}

func _docancel(tls *TLS, self uintptr) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxVaListSize 0 */
	defer tls.Free(96)
	var _ /* cb at bp+0 */ T__ptcb
	*(*T__ptcb)(unsafe.Pointer(bp)) = T__ptcb{F__next: (*T__pthread)(unsafe.Pointer(self)).Fcancelbuf}
	x___pthread_unwind_next(tls, bp)
}

func _cancel_handler(tls *TLS, sig int32, si uintptr, ctx uintptr) {
	var self uintptr
	self = ___pthread_self(tls)
	(*T__pthread)(unsafe.Pointer(self)).Fcancel = int32(1)
	if (*T__pthread)(unsafe.Pointer(self)).Fcanceldisable != 0 || !((*T__pthread)(unsafe.Pointer(self)).Fcancelasync != 0) && !((*T__pthread)(unsafe.Pointer(self)).Fcancelpoint != 0) {
		return
	}
	_docancel(tls, self)
}

func _cancelpt(tls *TLS, x int32) {
	var self uintptr
	self = ___pthread_self(tls)
	if (*T__pthread)(unsafe.Pointer(self)).Fcanceldisable != 0 {
		return
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcancelpoint = x
	if (*T__pthread)(unsafe.Pointer(self)).Fcancel != 0 {
		_docancel(tls, self)
	}
}

/* "rsyscall" is a mechanism by which a thread can synchronously force all
 * other threads to perform an arbitrary syscall. It is necessary to work
 * around the non-conformant implementation of setuid() et al on Linux,
 * which affect only the calling thread and not the whole process. This
 * implementation performs some tricks with signal delivery to work around
 * the fact that it does not keep any list of threads in userspace. */

var _rs struct {
	Flock   int32
	Fhold   int32
	Fblocks int32
	Fcnt    int32
	Farg    [6]uint64
	Fnr     int32
	Ferr    int32
}

func _rsyscall_handler(tls *TLS, sig int32, si uintptr, ctx uintptr) {
	if _rs.Fcnt == x___libc.Fthreads_minus_1 {
		return
	}
	if _syscall6(tls, int64(_rs.Fnr), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg))))), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 1*8))), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 2*8))), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 3*8))), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 4*8))), int64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 5*8)))) < 0 && !(_rs.Ferr != 0) {
		_rs.Ferr = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	_a_inc(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)))
	x___wake(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)), int32(1), int32(1))
	for _rs.Fhold != 0 {
		x___wait(tls, uintptr(unsafe.Pointer(&_rs.Fhold)), uintptr(0), int32(1), int32(1))
	}
	_a_dec(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)))
	if !(_rs.Fcnt != 0) {
		x___wake(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)), int32(1), int32(1))
	}
}

func _rsyscall(tls *TLS, nr int32, a int64, b int64, c int64, d int64, e int64, f int64) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxVaListSize 0 */
	defer tls.Free(128)
	var i, ret, v2, v3, v4 int32
	var self uintptr
	var _ /* set at bp+0 */ Tsigset_t
	*(*Tsigset_t)(unsafe.Pointer(bp)) = Tsigset_t{}
	self = ___pthread_self(tls)
	x_sigaddset(tls, bp, int32(m_SIGSYSCALL))
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_rs.Flock)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_rs.Flock))
		_ = Int32FromInt32(1)
	}
	for {
		v2 = _rs.Fblocks
		i = v2
		if !(v2 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&_rs.Fblocks)), uintptr(0), i, int32(1))
	}
	x___libc_sigprocmask(tls, m_SIG_BLOCK, bp, uintptr(0))
	_rs.Fnr = nr
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)))) = uint64(a)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 1*8)) = uint64(b)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 2*8)) = uint64(c)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 3*8)) = uint64(d)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 4*8)) = uint64(d)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Farg)) + 5*8)) = uint64(f)
	_rs.Fhold = int32(1)
	_rs.Ferr = 0
	_rs.Fcnt = 0
	/* Dispatch signals until all threads respond */
	for i = x___libc.Fthreads_minus_1; i != 0; i-- {
		x_sigqueue(tls, (*T__pthread)(unsafe.Pointer(self)).Fpid, int32(m_SIGSYSCALL), Tsigval{})
	}
	for {
		v3 = _rs.Fcnt
		i = v3
		if !(v3 < x___libc.Fthreads_minus_1) {
			break
		}
		x_sigqueue(tls, (*T__pthread)(unsafe.Pointer(self)).Fpid, int32(m_SIGSYSCALL), Tsigval{})
		x___wait(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)), uintptr(0), i, int32(1))
	}
	/* Handle any lingering signals with no-op */
	x___libc_sigprocmask(tls, int32(m_SIG_UNBLOCK), bp, uintptr(0))
	/* Resume other threads' signal handlers and wait for them */
	_rs.Fhold = 0
	x___wake(tls, uintptr(unsafe.Pointer(&_rs.Fhold)), -int32(1), 0)
	for {
		v4 = _rs.Fcnt
		i = v4
		if !(v4 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&_rs.Fcnt)), uintptr(0), i, int32(1))
	}
	if _rs.Ferr != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = _rs.Ferr
		ret = -Int32FromInt32(1)
	} else {
		ret = int32(_syscall6(tls, int64(nr), a, b, c, d, e, f))
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_rs.Flock)))) = 0
	return ret
}

func _init_threads(tls *TLS) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxVaListSize 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	*(*int32)(unsafe.Pointer(bp + 136)) = Int32FromInt32(m_SA_SIGINFO) | Int32FromInt32(m_SA_RESTART)
	x___libc.Flock = __ccgo_fp(x___lock)
	x___libc.Fcancelpt = __ccgo_fp(_cancelpt)
	x___libc.Frsyscall = __ccgo_fp(_rsyscall)
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = __ccgo_fp(_cancel_handler)
	x___libc_sigaction(tls, int32(m_SIGCANCEL), bp, uintptr(0))
	x_sigaddset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)), int32(m_SIGSYSCALL))
	x_sigaddset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)), int32(m_SIGCANCEL))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = __ccgo_fp(_rsyscall_handler)
	x___libc_sigaction(tls, int32(m_SIGSYSCALL), bp, uintptr(0))
	x___sigprocmask(tls, int32(m_SIG_UNBLOCK), uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)), uintptr(0))
}

func _start(tls *TLS, p uintptr) (r int32) {
	var self uintptr
	self = p
	x_pthread_exit(tls, (*(*func(*TLS, uintptr) uintptr)(unsafe.Pointer(&struct{ uintptr }{(*T__pthread)(unsafe.Pointer(self)).Fstart})))(tls, (*T__pthread)(unsafe.Pointer(self)).Fstart_arg))
	return 0
}

/* pthread_key_create.c overrides this */
var _dummy1 = uint64(0)

func x_pthread_create(tls *TLS, res uintptr, attr uintptr, entry uintptr, arg uintptr) (r int32) {
	var guard, size uint64
	var map1, new1, self, stack, tsd uintptr
	var ret, v1, v2 int32
	var v3 bool
	self = x_pthread_self(tls)
	if !(self != 0) {
		v1 = Int32FromInt32(m_ENOSYS)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v1
		return v1
	}
	if v3 = !(_init1 != 0); v3 {
		_init1++
		v2 = _init1
	}
	if v3 && v2 != 0 {
		_init_threads(tls)
	}
	if !(attr != 0) {
		attr = uintptr(unsafe.Pointer(&_default_attr))
	}
	guard = (*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(attr)).F__u)) + 1*8)) + Uint64FromInt32(4096) + Uint64FromInt32(m_PAGESIZE) - Uint64FromInt32(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
	size = guard + (*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(attr)).F__u))))+uint64(Int32FromInt32(16384)-Int32FromInt32(4096))+uint64(m_PAGESIZE)-uint64(1))&uint64(-Int32FromInt32(m_PAGESIZE))
	size += x___pthread_tsd_size
	map1 = x___mmap(tls, uintptr(0), size, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE)|Int32FromInt32(m_PROT_EXEC), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), 0)
	if !(map1 != 0) {
		return int32(m_EAGAIN)
	}
	x_mprotect(tls, map1, guard, m_PROT_NONE)
	tsd = map1 + uintptr(size) - uintptr(x___pthread_tsd_size)
	new1 = tsd - UintptrFromInt64(272) - uintptr(Uint64FromInt32(m_PAGESIZE)%Uint64FromInt64(272))
	(*T__pthread)(unsafe.Pointer(new1)).Fmap_base = map1
	(*T__pthread)(unsafe.Pointer(new1)).Fmap_size = size
	(*T__pthread)(unsafe.Pointer(new1)).Fpid = (*T__pthread)(unsafe.Pointer(self)).Fpid
	(*T__pthread)(unsafe.Pointer(new1)).Ferrno_ptr = new1 + 52
	(*T__pthread)(unsafe.Pointer(new1)).Fstart = entry
	(*T__pthread)(unsafe.Pointer(new1)).Fstart_arg = arg
	(*T__pthread)(unsafe.Pointer(new1)).Fself = new1
	(*T__pthread)(unsafe.Pointer(new1)).Ftsd = tsd
	(*T__pthread)(unsafe.Pointer(new1)).Fdetached = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(attr)).F__u.F__i)) + uintptr(Uint64FromInt32(2)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4))
	(*T__pthread)(unsafe.Pointer(new1)).Fattr = *(*Tpthread_attr_t)(unsafe.Pointer(attr))
	x_memcpy(tls, new1+8, self+8, uint64(32))
	*(*uint64)(unsafe.Pointer(new1 + 8 + 1*8)) = uint64(new1)
	stack = uintptr((uint64(new1) - Uint64FromInt32(1)) & ^Uint64FromInt32(15))
	/* We must synchronize new thread creation with rsyscall
	 * delivery. This looks to be the least expensive way: */
	_a_inc(tls, uintptr(unsafe.Pointer(&_rs.Fblocks)))
	for _rs.Flock != 0 {
		x___wait(tls, uintptr(unsafe.Pointer(&_rs.Flock)), uintptr(0), int32(1), int32(1))
	}
	_a_inc(tls, uintptr(unsafe.Pointer(&x___libc.Fthreads_minus_1)))
	ret = ___uniclone(tls, stack, __ccgo_fp(_start), new1)
	_a_dec(tls, uintptr(unsafe.Pointer(&_rs.Fblocks)))
	if _rs.Flock != 0 {
		x___wake(tls, uintptr(unsafe.Pointer(&_rs.Fblocks)), int32(1), int32(1))
	}
	if ret < 0 {
		_a_dec(tls, uintptr(unsafe.Pointer(&x___libc.Fthreads_minus_1)))
		x___munmap(tls, map1, size)
		return int32(m_EAGAIN)
	}
	*(*uintptr)(unsafe.Pointer(res)) = new1
	return 0
}

var _init1 int32

var _default_attr Tpthread_attr_t

func x_pthread_exit(tls *TLS, result uintptr) {
	var self uintptr
	self = x_pthread_self(tls)
	(*T__pthread)(unsafe.Pointer(self)).Fresult = result
	_docancel(tls, self)
}

func x_pthread_detach(tls *TLS, t uintptr) (r int32) {
	/* Cannot detach a thread that's already exiting */
	if _a_swap(tls, t+196, int32(1)) != 0 {
		return x_pthread_join(tls, t, uintptr(0))
	}
	(*T__pthread)(unsafe.Pointer(t)).Fdetached = int32(1)
	(*T__pthread)(unsafe.Pointer(t)).Fexitlock = 0
	return 0
}

func x_pthread_equal(tls *TLS, a uintptr, b uintptr) (r int32) {
	return BoolInt32(a == b)
}

func x_pthread_getspecific(tls *TLS, k int32) (r uintptr) {
	var self uintptr
	self = x_pthread_self(tls)
	if !((*T__pthread)(unsafe.Pointer(self)).Ftsd != 0) {
		return uintptr(0)
	}
	return *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8))
}

func x_pthread_join(tls *TLS, t uintptr, res uintptr) (r int32) {
	var tmp int32
	tmp = (*T__pthread)(unsafe.Pointer(t)).Ftid
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	if tmp != 0 {
		x___wait(tls, t+40, uintptr(0), tmp, int32(1))
	}
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	if res != 0 {
		*(*uintptr)(unsafe.Pointer(res)) = (*T__pthread)(unsafe.Pointer(t)).Fresult
	}
	if (*T__pthread)(unsafe.Pointer(t)).Fmap_base != 0 {
		x___munmap(tls, (*T__pthread)(unsafe.Pointer(t)).Fmap_base, (*T__pthread)(unsafe.Pointer(t)).Fmap_size)
	}
	return 0
}

func _nodtor(tls *TLS, dummy uintptr) {
}

func x_pthread_key_create(tls *TLS, _k uintptr, dtor uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _k
	var i, j, v1 int32
	var v2 bool
	i = int32(uint64(bp) / uint64(16) % uint64(m_PTHREAD_KEYS_MAX))
	j = i
	x___libc.Ftsd_keys = uintptr(unsafe.Pointer(&_keys))
	if !(dtor != 0) {
		dtor = __ccgo_fp(_nodtor)
	}
	/* Cheap trick - &k cannot match any destructor pointer */
	for {
		if v2 = _a_cas_p(tls, uintptr(unsafe.Pointer(&_keys))+uintptr(j)*8, uintptr(0), bp) != 0; v2 {
			v1 = (j + Int32FromInt32(1)) % Int32FromInt32(m_PTHREAD_KEYS_MAX)
			j = v1
		}
		if !(v2 && v1 != i) {
			break
		}
	}
	if _keys[j] != bp {
		return int32(m_EAGAIN)
	}
	_keys[j] = dtor
	*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) = j
	return 0
}

var _keys [1024]uintptr

func x_pthread_key_delete(tls *TLS, k int32) (r int32) {
	if x___libc.Ftsd_keys != 0 {
		*(*uintptr)(unsafe.Pointer(x___libc.Ftsd_keys + uintptr(k)*8)) = uintptr(0)
	}
	return 0
}

func x_pthread_kill(tls *TLS, t uintptr, sig int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_tgkill), int64((*T__pthread)(unsafe.Pointer(t)).Fpid), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(sig)))
}

func x_pthread_mutex_destroy(tls *TLS, mutex uintptr) (r int32) {
	return 0
}

func x_pthread_mutex_init(tls *TLS, m uintptr, a uintptr) (r int32) {
	x_memset(tls, m, 0, uint64(40))
	if a != 0 {
	}
	return 0
}

const m_EBUSY = 16

func x_pthread_mutex_lock(tls *TLS, m uintptr) (r1 int32) {
	var r, v1 int32
	for {
		v1 = x_pthread_mutex_trylock(tls, m)
		r = v1
		if !(v1 == int32(m_EBUSY)) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+2*4, int32(1), 0)
	}
	return r
}

func x_pthread_mutex_timedlock(tls *TLS, m uintptr, at uintptr) (r1 int32) {
	var r, w, v1 int32
	w = 0
	for {
		v1 = x_pthread_mutex_trylock(tls, m)
		r = v1
		if !(v1 == int32(m_EBUSY)) {
			break
		}
		if !(w != 0) {
			_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+2*4)
			w++
		}
		if x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1), m_CLOCK_REALTIME, at, 0) == int32(m_ETIMEDOUT) {
			if w != 0 {
				_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+2*4)
			}
			return int32(m_ETIMEDOUT)
		}
	}
	if w != 0 {
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+2*4)
	}
	return r
}

const m_EDEADLK = 35
const m_PTHREAD_MUTEX_ERRORCHECK = 2
const m_PTHREAD_MUTEX_RECURSIVE = 1

func x_pthread_mutex_trylock(tls *TLS, m uintptr) (r int32) {
	var self uintptr
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)))) == int32(m_PTHREAD_MUTEX_RECURSIVE) {
		self = x_pthread_self(tls)
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) == (*T__pthread)(unsafe.Pointer(self)).Ftid {
			if uint32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 1*4))) >= uint32(m_INT_MAX) {
				return int32(m_EAGAIN)
			}
			_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4)
			return 0
		}
		if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1)) != 0 {
			if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, -int32(1)) == int32(1) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 2*4)) != 0 {
				x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1), 0)
			}
			return int32(m_EBUSY)
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) = (*T__pthread)(unsafe.Pointer(self)).Ftid
		return 0
	}
	if _a_swap(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1)) != 0 {
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)))) == int32(m_PTHREAD_MUTEX_ERRORCHECK) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) == (*T__pthread)(unsafe.Pointer(x_pthread_self(tls))).Ftid {
			return int32(m_EDEADLK)
		} else {
			return int32(m_EBUSY)
		}
	}
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)))) == int32(m_PTHREAD_MUTEX_ERRORCHECK) {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) = (*T__pthread)(unsafe.Pointer(x_pthread_self(tls))).Ftid
	}
	return 0
}

const m_EPERM = 1

func x_pthread_mutex_unlock(tls *TLS, m uintptr) (r int32) {
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)))) == int32(m_PTHREAD_MUTEX_RECURSIVE) {
		if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, -int32(1)) == int32(1) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 2*4)) != 0 {
			x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1), 0)
		}
		return 0
	}
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)))) == int32(m_PTHREAD_MUTEX_ERRORCHECK) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) != (*T__pthread)(unsafe.Pointer(x_pthread_self(tls))).Ftid {
		return int32(m_EPERM)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 3*4)) = 0
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 1*4)) = 0
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + 2*4)) != 0 {
		x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i))+1*4, int32(1), 0)
	}
	return 0
}

func x_pthread_mutexattr_destroy(tls *TLS, a uintptr) (r int32) {
	return 0
}

func x_pthread_mutexattr_gettype(tls *TLS, a uintptr, type1 uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(type1)) = int32(*(*uint32)(unsafe.Pointer(a)) & uint32(3))
	return 0
}

func x_pthread_mutexattr_init(tls *TLS, a uintptr) (r int32) {
	x_memset(tls, a, 0, uint64(4))
	return 0
}

func x_pthread_mutexattr_settype(tls *TLS, a uintptr, type1 int32) (r int32) {
	if uint32(type1) > uint32(2) {
		return int32(m_EINVAL)
	}
	*(*uint32)(unsafe.Pointer(a)) = *(*uint32)(unsafe.Pointer(a))&uint32(^Int32FromInt32(3)) | uint32(type1)
	return 0
}

func _undo(tls *TLS, control uintptr) {
	_a_store(tls, control, 0)
	x___wake(tls, control, int32(1), 0)
}

func x_pthread_once(tls *TLS, control uintptr, init1 uintptr) (r int32) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxVaListSize 0 */
	defer tls.Free(96)
	var __f, __x uintptr
	var _ /* __cb at bp+0 */ T__ptcb
	/* Return immediately if init finished before */
	if *(*int32)(unsafe.Pointer(control)) == int32(2) {
		return 0
	}
	/* Try to enter initializing state. Three possibilities:
	 *  0 - we're the first or the other cancelled; run init
	 *  1 - another thread is running init; wait
	 *  2 - another thread finished running init; just return */
	for {
		switch _a_swap(tls, control, int32(1)) {
		case 0:
		case int32(1):
			x___wait(tls, control, uintptr(unsafe.Pointer(&_waiters1)), int32(1), 0)
			continue
		case int32(2):
			_a_store(tls, control, int32(2))
			return 0
		}
	}
	__f = __ccgo_fp(_undo)
	__x = control
	if ___setjmp(tls, uintptr(unsafe.Pointer(&(*(*T__ptcb)(unsafe.Pointer(bp))).F__jb))) != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{__f})))(tls, __x)
		x___pthread_unwind_next(tls, bp)
	}
	x___pthread_register_cancel(tls, bp)
	{
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{init1})))(tls)
	}
	x___pthread_unregister_cancel(tls, bp)
	if 0 != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{__f})))(tls, __x)
	}
	if _waiters1 != 0 {
		x___wake(tls, control, -int32(1), 0)
	}
	return 0
}

var _waiters1 int32

func x_pthread_rwlock_destroy(tls *TLS, rw uintptr) (r int32) {
	return 0
}

func x_pthread_rwlock_init(tls *TLS, rw uintptr, a uintptr) (r int32) {
	x_memset(tls, rw, 0, uint64(56))
	if a != 0 {
	}
	return 0
}

func x_pthread_rwlock_rdlock(tls *TLS, rw uintptr) (r int32) {
	for x_pthread_rwlock_tryrdlock(tls, rw) != 0 {
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4, int32(1), 0)
	}
	return 0
}

func x_pthread_rwlock_timedrdlock(tls *TLS, rw uintptr, at uintptr) (r int32) {
	var w int32
	w = 0
	for x_pthread_rwlock_tryrdlock(tls, rw) != 0 {
		if !(w != 0) {
			_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
			w++
		}
		if x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), int32(1), m_CLOCK_REALTIME, at, 0) == int32(m_ETIMEDOUT) {
			if w != 0 {
				_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
			}
			return int32(m_ETIMEDOUT)
		}
	}
	if w != 0 {
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
	}
	return 0
}

func x_pthread_rwlock_timedwrlock(tls *TLS, rw uintptr, at uintptr) (r int32) {
	var nr, w, v1 int32
	var p uintptr
	w = 0
	for x_pthread_rwlock_trywrlock(tls, rw) == int32(m_EAGAIN) {
		if !(w != 0) {
			_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
			w++
		}
		v1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4))
		nr = v1
		if v1 != 0 {
			p = uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4
		} else {
			nr = int32(1)
			p = uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))
		}
		if x___timedwait(tls, p, nr, m_CLOCK_REALTIME, at, 0) == int32(m_ETIMEDOUT) {
			if w != 0 {
				_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
			}
			return int32(m_ETIMEDOUT)
		}
	}
	if w != 0 {
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4)
	}
	return 0
}

func x_pthread_rwlock_tryrdlock(tls *TLS, rw uintptr) (r int32) {
	_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4)
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)))) != 0 {
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4)
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 2*4)) != 0 && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4)) != 0) {
			x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4, int32(1), 0)
		}
		return int32(m_EAGAIN)
	}
	return 0
}

func x_pthread_rwlock_trywrlock(tls *TLS, rw uintptr) (r int32) {
	if _a_swap(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), int32(1)) != 0 {
		return int32(m_EAGAIN)
	}
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4)) != 0 {
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), 0)
		return int32(m_EAGAIN)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 3*4)) = (*T__pthread)(unsafe.Pointer(x_pthread_self(tls))).Ftid
	return 0
}

func x_pthread_rwlock_unlock(tls *TLS, rw uintptr) (r int32) {
	var self uintptr
	self = x_pthread_self(tls)
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 3*4)) == (*T__pthread)(unsafe.Pointer(self)).Ftid {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 3*4)) = 0
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), 0)
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 2*4)) != 0 {
			x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), -int32(1), 0)
		}
		return 0
	}
	_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4)
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 2*4)) != 0 && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4)) != 0) {
		x___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4, int32(1), 0)
	}
	return 0
}

func x_pthread_rwlock_wrlock(tls *TLS, rw uintptr) (r int32) {
	var nr, v1 int32
	for x_pthread_rwlock_trywrlock(tls, rw) == int32(m_EAGAIN) {
		v1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + 1*4))
		nr = v1
		if v1 != 0 {
			x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+1*4, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4, nr, 0)
		} else {
			x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)), uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i))+2*4, int32(1), 0)
		}
	}
	return 0
}

const m___NR_set_tid_address = 218

var _main_thread T__pthread

func _errno_location(tls *TLS) (r uintptr) {
	return (*T__pthread)(unsafe.Pointer(___pthread_self(tls))).Ferrno_ptr
}

func _init_main_thread(tls *TLS) (r int32) {
	var v1 int32
	_main_thread.Fself = uintptr(unsafe.Pointer(&_main_thread))
	if ___set_thread_area(tls, uintptr(unsafe.Pointer(&_main_thread))) < 0 {
		return -int32(1)
	}
	_syscall1(tls, int64(m___NR_set_tid_address), int64(uintptr(unsafe.Pointer(&_main_thread.Ftid))))
	_main_thread.Ferrno_ptr = x___errno_location(tls)
	x___libc.Ferrno_location = __ccgo_fp(_errno_location)
	v1 = x_getpid(tls)
	_main_thread.Fpid = v1
	_main_thread.Ftid = v1
	return 0
}

func x_pthread_self(tls *TLS) (r uintptr) {
	if !(_init2 != 0) {
		if _failed != 0 {
			return uintptr(0)
		}
		if _init_main_thread(tls) < 0 {
			_failed = int32(1)
		}
		if _failed != 0 {
			return uintptr(0)
		}
		_init2 = int32(1)
	}
	return ___pthread_self(tls)
}

var _init2 int32

var _failed int32

func x_pthread_setcancelstate(tls *TLS, new1 int32, old uintptr) (r int32) {
	var self uintptr
	self = x_pthread_self(tls)
	if old != 0 {
		*(*int32)(unsafe.Pointer(old)) = (*T__pthread)(unsafe.Pointer(self)).Fcanceldisable
	}
	if uint32(new1) > uint32(1) {
		return int32(m_EINVAL)
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcanceldisable = new1
	return 0
}

func x_pthread_setcanceltype(tls *TLS, new1 int32, old uintptr) (r int32) {
	var self uintptr
	self = x_pthread_self(tls)
	if old != 0 {
		*(*int32)(unsafe.Pointer(old)) = (*T__pthread)(unsafe.Pointer(self)).Fcancelasync
	}
	if uint32(new1) > uint32(1) {
		return int32(m_EINVAL)
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcancelasync = new1
	return 0
}

func x_pthread_setspecific(tls *TLS, k int32, x uintptr) (r int32) {
	var self, v1 uintptr
	self = x_pthread_self(tls)
	/* Handle the case of the main thread */
	if !((*T__pthread)(unsafe.Pointer(self)).Ftsd != 0) {
		if !(x != 0) {
			return 0
		}
		v1 = x_calloc(tls, uint64(8), uint64(m_PTHREAD_KEYS_MAX))
		(*T__pthread)(unsafe.Pointer(self)).Ftsd = v1
		if !(v1 != 0) {
			return int32(m_ENOMEM)
		}
	}
	/* Avoid unnecessary COW */
	if *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) != x {
		*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) = x
		(*T__pthread)(unsafe.Pointer(self)).Ftsd_used = int32(1)
	}
	return 0
}

func x_pthread_spin_destroy(tls *TLS, s uintptr) (r int32) {
	return 0
}

func x_pthread_spin_init(tls *TLS, s uintptr, shared int32) (r int32) {
	var v1 int32
	v1 = Int32FromInt32(0)
	*(*int32)(unsafe.Pointer(s)) = v1
	return v1
}

func x_pthread_spin_lock(tls *TLS, s uintptr) (r int32) {
	for _a_swap(tls, s, int32(1)) != 0 {
	}
	return 0
}

func x_pthread_spin_trylock(tls *TLS, s uintptr) (r int32) {
	return -_a_swap(tls, s, int32(1)) & int32(m_EBUSY)
}

func x_pthread_spin_unlock(tls *TLS, s uintptr) (r int32) {
	var v1 int32
	v1 = Int32FromInt32(0)
	*(*int32)(unsafe.Pointer(s)) = v1
	return v1
}

func x_pthread_testcancel(tls *TLS) {
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
}

const m_ABDAY_1 = 131072
const m_ABMON_1 = 131086

func x___asctime(tls *TLS, tm uintptr, buf uintptr) (r uintptr) {
	bp := tls.Alloc(64) /* tlsAllocs 0 maxVaListSize 56 */
	defer tls.Free(64)
	/* FIXME: change __langinfo to __C_langinfo once we have locales */
	if x_snprintf(tls, buf, uint64(26), ts+1149, VaList(bp+8, x___langinfo(tls, int32(m_ABDAY_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_wday), x___langinfo(tls, int32(m_ABMON_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_mon), (*Ttm)(unsafe.Pointer(tm)).Ftm_mday, (*Ttm)(unsafe.Pointer(tm)).Ftm_hour, (*Ttm)(unsafe.Pointer(tm)).Ftm_min, (*Ttm)(unsafe.Pointer(tm)).Ftm_sec, int32(1900)+(*Ttm)(unsafe.Pointer(tm)).Ftm_year)) >= int32(26) {
		/* ISO C requires us to use the above format string,
		 * even if it will not fit in the buffer. Thus asctime_r
		 * is _supposed_ to crash if the fields in tm are too large.
		 * We follow this behavior and crash "gracefully" to warn
		 * application developers that they may not be so lucky
		 * on other implementations (e.g. stack smashing..).
		 */
		*(*int32)(unsafe.Pointer(UintptrFromInt32(0))) = 0
	}
	return buf
}

/* C defines the rounding for division in a nonsensical way */

// C documentation
//
//	/* FIXME: use lldiv once it's fixed to compute quot,rem together */
func x___time_to_tm(tls *TLS, t int64, tm uintptr) (r uintptr) {
	var bigday, v1, v2 int64
	var day, year100, year4 uint32
	var hour, leap, mday, min, month, sec, wday, yday, year, year400 int32
	/* start from 2000-03-01 (multiple of 400 years) */
	t += int64(-Int32FromInt32(946684800) - Int32FromInt32(86400)*(Int32FromInt32(31)+Int32FromInt32(29)))
	if t > 0 {
		v1 = t / int64(Int32FromInt32(86400))
	} else {
		v1 = -((int64(Int32FromInt32(86400)) - t - int64(1)) / int64(Int32FromInt32(86400)))
	}
	bigday = v1
	sec = int32(t - bigday*int64(86400))
	hour = sec / int32(3600)
	sec -= hour * int32(3600)
	min = sec / int32(60)
	sec -= min * int32(60)
	/* 2000-03-01 was a wednesday */
	wday = int32((int64(3) + bigday) % int64(7))
	if wday < 0 {
		wday += int32(7)
	}
	t = -Int64FromInt64(946684800) - int64(Int32FromInt32(86400)*(Int32FromInt32(31)+Int32FromInt32(29))) + Int64FromInt32(9000000)
	if bigday > 0 {
		v2 = bigday / int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97))
	} else {
		v2 = -((int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)) - bigday - int64(1)) / int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)))
	}
	year400 = int32(v2)
	day = uint32(bigday - int64(year400*(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97))))
	year100 = day / uint32(Int32FromInt32(365)*Int32FromInt32(100)+Int32FromInt32(24))
	if year100 == uint32(4) {
		year100--
	}
	day -= year100 * uint32(Int32FromInt32(365)*Int32FromInt32(100)+Int32FromInt32(24))
	year4 = day / uint32(Int32FromInt32(365)*Int32FromInt32(4)+Int32FromInt32(1))
	if year4 == uint32(25) {
		year4--
	}
	day -= year4 * uint32(Int32FromInt32(365)*Int32FromInt32(4)+Int32FromInt32(1))
	year = int32(day / uint32(365))
	if year == int32(4) {
		year--
	}
	day -= uint32(year * int32(365))
	leap = BoolInt32(!(year != 0) && (year4 != 0 || !(year100 != 0)))
	yday = int32(day + uint32(31) + uint32(28) + uint32(leap))
	if yday >= int32(365)+leap {
		yday -= int32(365) + leap
	}
	year = int32(uint32(year) + (Uint32FromInt32(4)*year4 + Uint32FromInt32(100)*year100 + uint32(Int32FromInt32(400)*year400) + Uint32FromInt32(2000) - Uint32FromInt32(1900)))
	for month = 0; uint32(_days_thru_month[month]) <= day; month++ {
	}
	if month != 0 {
		day -= uint32(_days_thru_month[month-int32(1)])
	}
	month += int32(2)
	if month >= int32(12) {
		month -= int32(12)
		year++
	}
	mday = int32(day + uint32(1))
	(*Ttm)(unsafe.Pointer(tm)).Ftm_sec = sec
	(*Ttm)(unsafe.Pointer(tm)).Ftm_min = min
	(*Ttm)(unsafe.Pointer(tm)).Ftm_hour = hour
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mday = mday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mon = month
	(*Ttm)(unsafe.Pointer(tm)).Ftm_year = year
	(*Ttm)(unsafe.Pointer(tm)).Ftm_wday = wday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_yday = yday
	return tm
}

/* months are march-based */
var _days_thru_month = [12]int32{
	0:  int32(31),
	1:  int32(61),
	2:  int32(92),
	3:  int32(122),
	4:  int32(153),
	5:  int32(184),
	6:  int32(214),
	7:  int32(245),
	8:  int32(275),
	9:  int32(306),
	10: int32(337),
	11: int32(366)}

func x___tm_to_time(tls *TLS, tm uintptr) (r int64) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxVaListSize 0 */
	defer tls.Free(48)
	var day, month, z100, z4, z400, v2, v3 int32
	var year, v1 int64
	year = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year + -int32(100))
	month = (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
	day = (*Ttm)(unsafe.Pointer(tm)).Ftm_mday
	/* normalize month */
	if month >= int32(12) {
		year += int64(month / int32(12))
		month %= int32(12)
	} else if month < 0 {
		year += int64(month / int32(12))
		month %= int32(12)
		if month != 0 {
			month += int32(12)
			year--
		}
	}
	if year-BoolInt64(month < Int32FromInt32(2)) > 0 {
		v1 = (year - BoolInt64(month < Int32FromInt32(2))) / int64(Int32FromInt32(4))
	} else {
		v1 = -((int64(Int32FromInt32(4)) - (year - BoolInt64(month < Int32FromInt32(2))) - int64(1)) / int64(Int32FromInt32(4)))
	}
	z4 = int32(v1)
	if z4 > 0 {
		v2 = z4 / int32(25)
	} else {
		v2 = -((int32(25) - z4 - int32(1)) / int32(25))
	}
	z100 = v2
	if z100 > 0 {
		v3 = z100 / int32(4)
	} else {
		v3 = -((int32(4) - z100 - int32(1)) / int32(4))
	}
	z400 = v3
	*(*[12]int32)(unsafe.Pointer(bp)) = [12]int32{
		0:  0,
		1:  int32(31),
		2:  int32(59),
		3:  int32(90),
		4:  int32(120),
		5:  int32(151),
		6:  int32(181),
		7:  int32(212),
		8:  int32(243),
		9:  int32(273),
		10: int32(304),
		11: int32(335)}
	day = int32(int64(day) + (year*Int64FromInt32(365) + int64(z4) - int64(z100) + int64(z400) + int64(*(*int32)(unsafe.Pointer(bp + uintptr(month)*4)))))
	return int64(day)*int64(86400) + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour*int32(3600)) + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_min*int32(60)) + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_sec) - int64(-int32(946684800)) /* the dawn of time :) */
}

func x_asctime(tls *TLS, tm uintptr) (r uintptr) {
	return x___asctime(tls, tm, uintptr(unsafe.Pointer(&_buf10)))
}

var _buf10 [26]int8

func x_asctime_r(tls *TLS, tm uintptr, buf uintptr) (r uintptr) {
	return x___asctime(tls, tm, buf)
}

type Ttms = struct {
	Ftms_utime  int64
	Ftms_stime  int64
	Ftms_cutime int64
	Ftms_cstime int64
}

// C documentation
//
//	/* this function assumes 100 hz linux and corrects for it */
func x_clock(tls *TLS) (r int64) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxVaListSize 0 */
	defer tls.Free(32)
	var _ /* tms at bp+0 */ Ttms
	return int64(uint64(x_times(tls, bp)) * uint64(10000))
}

const m___NR_clock_gettime = 228

func x_clock_gettime(tls *TLS, clk int32, ts uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_clock_gettime), int64(clk), int64(ts)))
}

func x_ctime(tls *TLS, t uintptr) (r uintptr) {
	return x_asctime(tls, x_localtime(tls, t))
}

func x_ctime_r(tls *TLS, t uintptr, buf uintptr) (r uintptr) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxVaListSize 0 */
	defer tls.Free(56)
	var _ /* tm at bp+0 */ Ttm
	x_localtime_r(tls, t, bp)
	return x_asctime_r(tls, bp, buf)
}

func x_difftime(tls *TLS, t1 int64, t0 int64) (r float64) {
	return float64(t1 - t0)
}

const m___NR_gettimeofday = 96

func x_gettimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	_syscall2(tls, int64(m___NR_gettimeofday), int64(tv), 0)
	return 0
}

func x_gmtime(tls *TLS, t uintptr) (r uintptr) {
	x___time_to_tm(tls, *(*int64)(unsafe.Pointer(t)), uintptr(unsafe.Pointer(&_tm)))
	_tm.Ftm_isdst = 0
	return uintptr(unsafe.Pointer(&_tm))
}

var _tm Ttm

func x_gmtime_r(tls *TLS, t uintptr, result uintptr) (r uintptr) {
	x___time_to_tm(tls, *(*int64)(unsafe.Pointer(t)), result)
	(*Ttm)(unsafe.Pointer(result)).Ftm_isdst = 0
	return result
}

func x_localtime(tls *TLS, t uintptr) (r uintptr) {
	x___tzset(tls)
	x___time_to_tm(tls, *(*int64)(unsafe.Pointer(t))-x___timezone, uintptr(unsafe.Pointer(&_tm1)))
	_tm1.Ftm_isdst = -int32(1)
	return x___dst_adjust(tls, uintptr(unsafe.Pointer(&_tm1)))
}

var _tm1 Ttm

func x_localtime_r(tls *TLS, t uintptr, result uintptr) (r uintptr) {
	x___tzset(tls)
	x___time_to_tm(tls, *(*int64)(unsafe.Pointer(t))-x___timezone, result)
	(*Ttm)(unsafe.Pointer(result)).Ftm_isdst = -int32(1)
	return x___dst_adjust(tls, result)
}

func x_mktime(tls *TLS, tm uintptr) (r int64) {
	var isdst int32
	var lt, t int64
	var p1 uintptr
	isdst = (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst
	x___tzset(tls)
	p1 = tm
	*(*int32)(unsafe.Pointer(p1)) = int32(int64(*(*int32)(unsafe.Pointer(p1))) + x___timezone)
	if isdst > 0 {
		*(*int32)(unsafe.Pointer(tm)) += x___dst_offset
	}
	t = x___tm_to_time(tls, tm)
	lt = t - x___timezone
	if isdst > 0 {
		lt -= int64(x___dst_offset)
	}
	x___time_to_tm(tls, lt, tm)
	x___dst_adjust(tls, tm)
	return t
}

const m___NR_nanosleep = 35

func x_nanosleep(tls *TLS, req uintptr, rem uintptr) (r int32) {
	var ret int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	ret = int32(_syscall2(tls, int64(m___NR_nanosleep), int64(req), int64(rem)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return ret
}

const m_AM_STR = 131110
const m_DAY_1 = 131079
const m_D_FMT = 131113
const m_D_T_FMT = 131112
const m_MON_1 = 131098
const m_PM_STR = 131111
const m_T_FMT = 131114
const m_T_FMT_AMPM = 131115

// FIXME: integer overflows

func x_strftime(tls *TLS, s uintptr, n uint64, f uintptr, tm uintptr) (r uint64) {
	bp := tls.Alloc(24) /* tlsAllocs 0 maxVaListSize 16 */
	defer tls.Free(24)
	var fmt, v1 uintptr
	var item, val, v3, v5, v6 int32
	var l, v2, v4, v7 uint64
	for l = uint64(0); *(*int8)(unsafe.Pointer(f)) != 0 && l < n; f++ {
		if int32(*(*int8)(unsafe.Pointer(f))) == int32('%') {
		do_fmt:
			f++
			v1 = f
			switch int32(*(*int8)(unsafe.Pointer(v1))) {
			case int32('%'):
				goto literal
			case int32('E'):
				fallthrough
			case int32('O'):
				goto do_fmt
			case int32('a'):
				item = int32(m_ABDAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
				goto nl_strcat
			case int32('A'):
				item = int32(m_DAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
				goto nl_strcat
			case int32('h'):
				fallthrough
			case int32('b'):
				item = int32(m_ABMON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
				goto nl_strcat
			case int32('B'):
				item = int32(m_MON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
				goto nl_strcat
			case int32('c'):
				item = int32(m_D_T_FMT)
				goto nl_strftime
			case int32('C'):
				val = (int32(1900) + (*Ttm)(unsafe.Pointer(tm)).Ftm_year) / int32(100)
				fmt = ts + 1181
				goto number
			case int32('d'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_mday
				fmt = ts + 1181
				goto number
			case int32('D'):
				fmt = ts + 1186
				goto recu_strftime
			case int32('e'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_mday
				fmt = ts + 1195
				goto number
			case int32('F'):
				fmt = ts + 1199
				goto recu_strftime
			case int32('g'):
				// FIXME
				val = 0 //week_based_year(tm)%100;
				fmt = ts + 1181
				goto number
			case int32('G'):
				// FIXME
				val = 0 //week_based_year(tm);
				fmt = ts + 1208
				goto number
			case int32('H'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_hour
				fmt = ts + 1181
				goto number
			case int32('I'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_hour
				if !(val != 0) {
					val = int32(12)
				} else if val > int32(12) {
					val -= int32(12)
				}
				fmt = ts + 1181
				goto number
			case int32('j'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_yday + int32(1)
				fmt = ts + 1213
				goto number
			case int32('m'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_mon + int32(1)
				fmt = ts + 1181
				goto number
			case int32('M'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_min
				fmt = ts + 1181
				goto number
			case int32('n'):
				v2 = l
				l++
				*(*int8)(unsafe.Pointer(s + uintptr(v2))) = int8('\n')
				continue
			case int32('p'):
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_hour >= int32(12) {
					v3 = int32(m_PM_STR)
				} else {
					v3 = int32(m_AM_STR)
				}
				item = v3
				goto nl_strcat
			case int32('r'):
				item = int32(m_T_FMT_AMPM)
				goto nl_strftime
			case int32('R'):
				fmt = ts + 1218
				goto recu_strftime
			case int32('S'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_sec
				fmt = ts + 1181
				goto number
			case int32('t'):
				v4 = l
				l++
				*(*int8)(unsafe.Pointer(s + uintptr(v4))) = int8('\t')
				continue
			case int32('T'):
				fmt = ts + 1224
				goto recu_strftime
			case int32('u'):
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_wday != 0 {
					v5 = (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
				} else {
					v5 = int32(7)
				}
				val = v5
				fmt = ts + 350
				goto number
			case int32('U'):
				fallthrough
			case int32('V'):
				fallthrough
			case int32('W'):
				// FIXME: week number mess..
				continue
			case int32('w'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
				fmt = ts + 350
				goto number
			case int32('x'):
				item = int32(m_D_FMT)
				goto nl_strftime
			case int32('X'):
				item = int32(m_T_FMT)
				goto nl_strftime
			case int32('y'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_year % int32(100)
				fmt = ts + 1181
				goto number
			case int32('Y'):
				val = (*Ttm)(unsafe.Pointer(tm)).Ftm_year + int32(1900)
				fmt = ts + 1208
				goto number
			case int32('z'):
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < 0 {
					continue
				}
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst != 0 {
					v6 = x___dst_offset
				} else {
					v6 = 0
				}
				val = int32(-x___timezone - int64(v6))
				l += uint64(x_snprintf(tls, s+uintptr(l), n-l, ts+1233, VaList(bp+8, val/int32(3600), x_abs(tls, val%int32(3600))/int32(60))))
				continue
			case int32('Z'):
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < 0 || !(x___tzname[0] != 0) || !(*(*int8)(unsafe.Pointer(x___tzname[0])) != 0) {
					continue
				}
				l += uint64(x_snprintf(tls, s+uintptr(l), n-l, ts+15, VaList(bp+8, x___tzname[BoolInt32(!!((*Ttm)(unsafe.Pointer(tm)).Ftm_isdst != 0))])))
				continue
			default:
				return uint64(0)
			}
		}
	literal:
		v7 = l
		l++
		*(*int8)(unsafe.Pointer(s + uintptr(v7))) = *(*int8)(unsafe.Pointer(f))
		continue
	number:
		l += uint64(x_snprintf(tls, s+uintptr(l), n-l, fmt, VaList(bp+8, val)))
		continue
	nl_strcat:
		l += uint64(x_snprintf(tls, s+uintptr(l), n-l, ts+15, VaList(bp+8, x___langinfo(tls, item))))
		continue
	nl_strftime:
		fmt = x___langinfo(tls, item)
	recu_strftime:
		l += x_strftime(tls, s+uintptr(l), n-l, fmt, tm)
	}
	if l >= n {
		return uint64(0)
	}
	*(*int8)(unsafe.Pointer(s + uintptr(l))) = 0
	return l
}

func x_strptime(tls *TLS, s uintptr, f uintptr, tm uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_time(tls *TLS, t uintptr) (r int64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimeval
	_syscall2(tls, int64(m___NR_gettimeofday), int64(bp), 0)
	if t != 0 {
		*(*int64)(unsafe.Pointer(t)) = (*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_sec
	}
	return (*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_sec
}

const m___NR_times = 100

func x_times(tls *TLS, _tms uintptr) (r int64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _tms
	return _syscall1(tls, int64(m___NR_times), int64(bp))
}

var _std_name [7]int8
var _dst_name [7]int8

/* all elements are zero-based */

type Trule = struct {
	Fmonth int8
	Fweek  int8
	Fday   int16
	Ftime  int32
}

var ___dst_start Trule
var ___dst_end Trule

func _zname(tls *TLS, d uintptr, s uintptr) {
	var i int32
	var v1 int8
	var v2 bool
	for i = 0; ; {
		if v2 = i < int32(m_TZNAME_MAX); v2 {
			v1 = *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))
			*(*int8)(unsafe.Pointer(d + uintptr(i))) = v1
		}
		if !(v2 && uint32(int32(v1)|Int32FromInt32(32)-Int32FromUint8('a')) < uint32(26)) {
			break
		}
		goto _3
	_3:
		i++
		*(*uintptr)(unsafe.Pointer(s))++
	}
	*(*int8)(unsafe.Pointer(d + uintptr(i))) = 0
}

func _hhmmss(tls *TLS, s uintptr) (r int32) {
	var ofs int32
	ofs = int32(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s)), s, int32(10)) * int64(3600))
	if ofs >= 0 {
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32(':') {
			ofs = int32(int64(ofs) + x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10))*Int64FromInt32(60))
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32(':') {
			ofs = int32(int64(ofs) + x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)))
		}
	} else {
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32(':') {
			ofs = int32(int64(ofs) - x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10))*Int64FromInt32(60))
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32(':') {
			ofs = int32(int64(ofs) - x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)))
		}
	}
	return ofs
}

func _dstrule(tls *TLS, rule uintptr, s uintptr) (r int32) {
	var v1, v2 uintptr
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) != int32(',') {
		return -int32(1)
	}
	v2 = s
	*(*uintptr)(unsafe.Pointer(v2))++
	v1 = *(*uintptr)(unsafe.Pointer(v2))
	switch int32(*(*int8)(unsafe.Pointer(v1))) {
	case int32('J'):
		(*Trule)(unsafe.Pointer(rule)).Fmonth = int8('J')
		(*Trule)(unsafe.Pointer(rule)).Fday = int16(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)) - int64(1))
	case int32('M'):
		(*Trule)(unsafe.Pointer(rule)).Fmonth = int8(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)) - int64(1))
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) != int32('.') || int32((*Trule)(unsafe.Pointer(rule)).Fmonth) < 0 || int32((*Trule)(unsafe.Pointer(rule)).Fmonth) > int32(11) {
			return -int32(1)
		}
		(*Trule)(unsafe.Pointer(rule)).Fweek = int8(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)) - int64(1))
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) != int32('.') || int32((*Trule)(unsafe.Pointer(rule)).Fweek) < 0 || int32((*Trule)(unsafe.Pointer(rule)).Fweek) > int32(4) {
			return -int32(1)
		}
		(*Trule)(unsafe.Pointer(rule)).Fday = int16(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)))
		if int32((*Trule)(unsafe.Pointer(rule)).Fday) < 0 || int32((*Trule)(unsafe.Pointer(rule)).Fday) > int32(6) {
			return -int32(1)
		}
	default:
		(*Trule)(unsafe.Pointer(rule)).Fmonth = int8('L')
		(*Trule)(unsafe.Pointer(rule)).Fday = int16(x_strtol(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(1), s, int32(10)))
		break
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32('/') {
		*(*uintptr)(unsafe.Pointer(s))++
		(*Trule)(unsafe.Pointer(rule)).Ftime = _hhmmss(tls, s)
	} else {
		(*Trule)(unsafe.Pointer(rule)).Ftime = int32(7200)
	}
	return 0
}

func x_tzset(tls *TLS) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxVaListSize 0 */
	defer tls.Free(8)
	var a, v1 uintptr
	var _ /* z at bp+0 */ uintptr
	x_strcpy(tls, uintptr(unsafe.Pointer(&_std_name)), ts+1243)
	x_strcpy(tls, uintptr(unsafe.Pointer(&_dst_name)), ts+1243)
	x___tzname[0] = uintptr(unsafe.Pointer(&_std_name))
	x___tzname[int32(1)] = uintptr(unsafe.Pointer(&_dst_name))
	x___timezone = 0
	x___daylight = 0
	v1 = x_getenv(tls, ts+1247)
	*(*uintptr)(unsafe.Pointer(bp)) = v1
	if !(v1 != 0) || !(uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))|Int32FromInt32(32)-Int32FromUint8('a')) < Uint32FromInt32(26)) {
		return
	}
	_zname(tls, uintptr(unsafe.Pointer(&_std_name)), bp)
	x___timezone = int64(_hhmmss(tls, bp))
	_zname(tls, uintptr(unsafe.Pointer(&_dst_name)), bp)
	if _dst_name[0] != 0 {
		x___daylight = int32(1)
	}
	a = *(*uintptr)(unsafe.Pointer(bp))
	x___dst_offset = int32(int64(_hhmmss(tls, bp)) - x___timezone)
	if *(*uintptr)(unsafe.Pointer(bp)) == a {
		x___dst_offset = -int32(3600)
	}
	if _dstrule(tls, uintptr(unsafe.Pointer(&___dst_start)), bp) != 0 || _dstrule(tls, uintptr(unsafe.Pointer(&___dst_end)), bp) != 0 {
		x___daylight = 0
	}
}

func x___tzset(tls *TLS) {
	if _init3 != 0 {
		return
	}
	if x___libc.Fthreads_minus_1 != 0 {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock8)))
		_ = Int32FromInt32(1)
	} else {
		_ = uintptr(unsafe.Pointer(&_lock8))
		_ = Int32FromInt32(1)
	}
	if !(_init3 != 0) {
		x_tzset(tls)
	}
	_init3 = int32(1)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_lock8)))) = 0
}

var _lock8 int32

var _init3 int32

func _is_leap(tls *TLS, year int32) (r int32) {
	year -= int32(100)
	return BoolInt32(!(year&Int32FromInt32(3) != 0) && (year%int32(100) != 0 || !(year%Int32FromInt32(400) != 0)))
}

func _cutoff_yday(tls *TLS, tm uintptr, rule uintptr) (r int32) {
	var leap, mday, yday int32
	switch int32((*Trule)(unsafe.Pointer(rule)).Fmonth) {
	case int32('J'):
		return int32((*Trule)(unsafe.Pointer(rule)).Fday) + BoolInt32((*Ttm)(unsafe.Pointer(tm)).Ftm_mon > int32(1) && _is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year) != 0)
	case int32('L'):
		return int32((*Trule)(unsafe.Pointer(rule)).Fday)
	default:
		yday = _first_day[(*Trule)(unsafe.Pointer(rule)).Fmonth]
		leap = _is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year)
		if int32((*Trule)(unsafe.Pointer(rule)).Fmonth) > int32(1) && leap != 0 {
			yday++
		}
		mday = (int32((*Trule)(unsafe.Pointer(rule)).Fday)-(yday+(*Ttm)(unsafe.Pointer(tm)).Ftm_wday-(*Ttm)(unsafe.Pointer(tm)).Ftm_yday)+int32(1400))%int32(7) + int32(7)*int32((*Trule)(unsafe.Pointer(rule)).Fweek)
		if mday >= int32(_days_in_month[(*Trule)(unsafe.Pointer(rule)).Fmonth])+BoolInt32(leap != 0 && int32((*Trule)(unsafe.Pointer(rule)).Fmonth) == int32(1)) {
			mday -= int32(7)
		}
		return mday + yday
	}
	return r
}

var _days_in_month = [12]int8{
	0:  int8(31),
	1:  int8(28),
	2:  int8(31),
	3:  int8(30),
	4:  int8(31),
	5:  int8(30),
	6:  int8(31),
	7:  int8(31),
	8:  int8(30),
	9:  int8(31),
	10: int8(30),
	11: int8(31)}

var _first_day = [12]int32{
	0:  0,
	1:  int32(31),
	2:  int32(59),
	3:  int32(90),
	4:  int32(120),
	5:  int32(151),
	6:  int32(181),
	7:  int32(212),
	8:  int32(243),
	9:  int32(273),
	10: int32(304),
	11: int32(335)}

func x___dst_adjust(tls *TLS, tm uintptr) (r uintptr) {
	var after_start, before_end, end, secs, start int32
	var t int64
	if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst >= 0 {
		return tm
	}
	if !(x___daylight != 0) {
		(*Ttm)(unsafe.Pointer(tm)).Ftm_isdst = 0
		return tm
	}
	secs = (*Ttm)(unsafe.Pointer(tm)).Ftm_hour*int32(3600) + (*Ttm)(unsafe.Pointer(tm)).Ftm_min*int32(60) + (*Ttm)(unsafe.Pointer(tm)).Ftm_sec
	start = _cutoff_yday(tls, tm, uintptr(unsafe.Pointer(&___dst_start)))
	end = _cutoff_yday(tls, tm, uintptr(unsafe.Pointer(&___dst_end)))
	after_start = BoolInt32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday > start || (*Ttm)(unsafe.Pointer(tm)).Ftm_yday == start && secs >= ___dst_start.Ftime)
	before_end = BoolInt32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday < end || (*Ttm)(unsafe.Pointer(tm)).Ftm_yday == end && secs < ___dst_end.Ftime)
	if after_start != 0 && before_end != 0 || end < start && (after_start != 0 || before_end != 0) {
		*(*int32)(unsafe.Pointer(tm)) -= x___dst_offset
		(*Ttm)(unsafe.Pointer(tm)).Ftm_isdst = int32(1)
		t = x___tm_to_time(tls, tm)
		return x___time_to_tm(tls, t, tm)
	} else {
		(*Ttm)(unsafe.Pointer(tm)).Ftm_isdst = 0
	}
	return tm
}

type Tutimbuf = struct {
	Factime  int64
	Fmodtime int64
}

func x_utime(tls *TLS, path uintptr, times uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var v1 int64
	var _ /* ktimes at bp+0 */ [2]int64
	if times != 0 {
		(*(*[2]int64)(unsafe.Pointer(bp)))[0] = (*Tutimbuf)(unsafe.Pointer(times)).Factime
		(*(*[2]int64)(unsafe.Pointer(bp)))[int32(1)] = (*Tutimbuf)(unsafe.Pointer(times)).Fmodtime
	}
	if times != 0 {
		v1 = int64(bp)
	} else {
		v1 = 0
	}
	return int32(_syscall2(tls, int64(m___NR_utime), int64(path), v1))
}

func x__exit(tls *TLS, status int32) {
	x__Exit(tls, status)
}

const m___NR_access = 21

func x_access(tls *TLS, filename uintptr, amode int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_access), int64(filename), int64(amode)))
}

const m___NR_alarm = 37

func x_alarm(tls *TLS, seconds uint32) (r uint32) {
	return uint32(_syscall1(tls, int64(m___NR_alarm), int64(seconds)))
}

const m___NR_chdir = 80

func x_chdir(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_chdir), int64(path)))
}

const m___NR_chown = 92

func x_chown(tls *TLS, path uintptr, uid uint32, gid uint32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_chown), int64(path), int64(uid), int64(gid)))
}

func x_close(tls *TLS, fd int32) (r int32) {
	var ret int32
	ret = int32(_syscall1(tls, int64(m___NR_close), int64(fd)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return ret
}

const m_L_ctermid = 20

func x_ctermid(tls *TLS, s uintptr) (r uintptr) {
	var fd int32
	if !(s != 0) {
		if !(_s21 != 0) {
			_s21 = x_malloc(tls, uint64(m_L_ctermid))
		}
		s = _s21
	}
	fd = x_open(tls, ts+81, Int32FromInt32(m_O_WRONLY)|Int32FromInt32(m_O_NOCTTY), 0)
	if fd < 0 {
		return x_strcpy(tls, s, ts)
	}
	if x_ttyname_r(tls, fd, s, uint64(m_L_ctermid)) != 0 {
		x_strcpy(tls, s, ts)
	}
	x_close(tls, fd)
	return s
}

var _s21 uintptr

const m___NR_dup = 32

func x_dup(tls *TLS, fd int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_dup), int64(fd)))
}

func x_dup2(tls *TLS, old int32, new1 int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_dup2), int64(old), int64(new1)))
}

const m___NR_faccessat = 269

func x_faccessat(tls *TLS, fd int32, filename uintptr, amode int32, flag int32) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_faccessat), int64(fd), int64(filename), int64(amode), int64(flag)))
}

const m___NR_fchdir = 81

func x_fchdir(tls *TLS, fd int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_fchdir), int64(fd)))
}

const m___NR_fchown = 93

func x_fchown(tls *TLS, fd int32, uid uint32, gid uint32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_fchown), int64(fd), int64(uid), int64(gid)))
}

const m___NR_fchownat = 260

func x_fchownat(tls *TLS, fd int32, path uintptr, uid uint32, gid uint32, flag int32) (r int32) {
	return int32(_syscall5(tls, int64(m___NR_fchownat), int64(fd), int64(path), int64(uid), int64(gid), int64(flag)))
}

func x_fdatasync(tls *TLS, fd int32) (r int32) {
	return 0
}

func x_fsync(tls *TLS, fd int32) (r int32) {
	//return syscall1(__NR_fsync, fd);
	return 0
}

const m___NR_ftruncate = 77

func x_ftruncate(tls *TLS, fd int32, length int64) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_ftruncate), int64(fd), length, 0))
}

const m___NR_getcwd = 79

func x_getcwd(tls *TLS, buf uintptr, size uint64) (r uintptr) {
	var v1 uintptr
	if _syscall2(tls, int64(m___NR_getcwd), int64(buf), int64(size)) < 0 {
		v1 = UintptrFromInt32(0)
	} else {
		v1 = buf
	}
	return v1
}

const m___NR_getegid = 108

func x_getegid(tls *TLS) (r uint32) {
	return uint32(_syscall0(tls, int64(m___NR_getegid)))
}

const m___NR_geteuid = 107

func x_geteuid(tls *TLS) (r uint32) {
	return uint32(_syscall0(tls, int64(m___NR_geteuid)))
}

const m___NR_getgid = 104

func x_getgid(tls *TLS) (r uint32) {
	return uint32(_syscall0(tls, int64(m___NR_getgid)))
}

const m___NR_getgroups = 115

func x_getgroups(tls *TLS, count int32, list uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_getgroups), int64(count), int64(list)))
}

func x_gethostname(tls *TLS, name uintptr, len1 uint64) (r int32) {
	bp := tls.Alloc(392) /* tlsAllocs 392 maxVaListSize 0 */
	defer tls.Free(392)
	var i uint64
	var v1 int8
	var v2 bool
	var _ /* uts at bp+0 */ Tutsname
	if x_uname(tls, bp) != 0 {
		return -int32(1)
	}
	if len1 > uint64(65) {
		len1 = uint64(65)
	}
	for i = uint64(0); ; i++ {
		if v2 = i < len1; v2 {
			v1 = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tutsname)(unsafe.Pointer(bp))).Fnodename)) + uintptr(i)))
			*(*int8)(unsafe.Pointer(name + uintptr(i))) = v1
		}
		if !(v2 && v1 != 0) {
			break
		}
	}
	if i == len1 {
		*(*int8)(unsafe.Pointer(name + uintptr(i-uint64(1)))) = 0
	}
	return 0
}

func x_getlogin(tls *TLS) (r uintptr) {
	return x_getenv(tls, ts+1250)
}

const m_ENXIO = 6

func x_getlogin_r(tls *TLS, name uintptr, size uint64) (r int32) {
	var logname uintptr
	logname = x_getlogin(tls)
	if !(logname != 0) {
		return int32(m_ENXIO)
	} /* or...? */
	if x_strlen(tls, name) >= size {
		return int32(m_ERANGE)
	}
	x_strcpy(tls, name, logname)
	return 0
}

const m___NR_getpgid = 121

func x_getpgid(tls *TLS, pid int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_getpgid), int64(pid)))
}

const m___NR_getpgrp = 111

func x_getpgrp(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_getpgrp)))
}

const m___NR_getpid = 39

func x_getpid(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_getpid)))
}

const m___NR_getppid = 110

func x_getppid(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_getppid)))
}

const m___NR_getsid = 124

func x_getsid(tls *TLS, pid int32) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_getsid), int64(pid)))
}

const m___NR_getuid = 102

func x_getuid(tls *TLS) (r uint32) {
	return uint32(_syscall0(tls, int64(m___NR_getuid)))
}

func x_isatty(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxVaListSize 0 */
	defer tls.Free(64)
	var _ /* t at bp+0 */ Ttermios
	return BoolInt32(x_tcgetattr(tls, fd, bp) == 0)
}

const m___NR_lchown = 94

func x_lchown(tls *TLS, path uintptr, uid uint32, gid uint32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_lchown), int64(path), int64(uid), int64(gid)))
}

const m___NR_link = 86

func x_link(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_link), int64(existing), int64(new1)))
}

const m___NR_linkat = 265

func x_linkat(tls *TLS, fd1 int32, existing uintptr, fd2 int32, new1 uintptr, flag int32) (r int32) {
	return int32(_syscall5(tls, int64(m___NR_linkat), int64(fd1), int64(existing), int64(fd2), int64(new1), int64(flag)))
}

func x_lseek(tls *TLS, fd int32, offset int64, whence int32) (r int64) {
	return _syscall3(tls, int64(m___NR_lseek), int64(fd), offset, int64(whence))
}

const m_PRIO_PROCESS = 0

func x_nice(tls *TLS, inc int32) (r int32) {
	return x_setpriority(tls, m_PRIO_PROCESS, 0, x_getpriority(tls, m_PRIO_PROCESS, 0)+inc)
}

const m___NR_pause = 34

func x_pause(tls *TLS) (r1 int32) {
	var r int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall0(tls, int64(m___NR_pause)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_pipe = 22

func x_pipe(tls *TLS, fd uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_pipe), int64(fd)))
}

const m___NR_pread64 = 17

func x_pread(tls *TLS, fd int32, buf uintptr, size uint64, ofs int64) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall5(tls, int64(m___NR_pread64), int64(fd), int64(buf), int64(size), ofs, 0)
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_pwrite64 = 18

func x_pwrite(tls *TLS, fd int32, buf uintptr, size uint64, ofs int64) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall5(tls, int64(m___NR_pwrite64), int64(fd), int64(buf), int64(size), ofs, 0)
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

func x_read(tls *TLS, fd int32, buf uintptr, count uint64) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall3(tls, m___NR_read, int64(fd), int64(buf), int64(count))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_readlink = 89

func x_readlink(tls *TLS, path uintptr, buf uintptr, bufsize uint64) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_readlink), int64(path), int64(buf), int64(bufsize)))
}

const m___NR_readlinkat = 267

func x_readlinkat(tls *TLS, fd int32, path uintptr, buf uintptr, bufsize uint64) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_readlinkat), int64(fd), int64(path), int64(buf), int64(bufsize)))
}

const m___NR_readv = 19

func x_readv(tls *TLS, fd int32, iov uintptr, count int32) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall3(tls, int64(m___NR_readv), int64(fd), int64(iov), int64(count))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

const m___NR_renameat = 264

func x_renameat(tls *TLS, oldfd int32, old uintptr, newfd int32, new1 uintptr) (r int32) {
	return int32(_syscall4(tls, int64(m___NR_renameat), int64(oldfd), int64(old), int64(newfd), int64(new1)))
}

const m___NR_rmdir = 84

func x_rmdir(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_rmdir), int64(path)))
}

func x_setegid(tls *TLS, egid uint32) (r int32) {
	return x_setregid(tls, uint32(-Int32FromInt32(1)), egid)
}

func x_seteuid(tls *TLS, euid uint32) (r int32) {
	return x_setreuid(tls, uint32(-Int32FromInt32(1)), euid)
}

const m___NR_setgid = 106

func x_setgid(tls *TLS, gid uint32) (r int32) {
	if x___libc.Frsyscall != 0 {
		return (*(*func(*TLS, int32, int64, int64, int64, int64, int64, int64) int32)(unsafe.Pointer(&struct{ uintptr }{x___libc.Frsyscall})))(tls, int32(m___NR_setgid), int64(gid), 0, 0, 0, 0, 0)
	}
	return int32(_syscall1(tls, int64(m___NR_setgid), int64(gid)))
}

const m___NR_setpgid = 109

func x_setpgid(tls *TLS, pid int32, pgid int32) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_setpgid), int64(pid), int64(pgid)))
}

func x_setpgrp(tls *TLS) (r int32) {
	return x_setpgid(tls, 0, 0)
}

const m___NR_setregid = 114

func x_setregid(tls *TLS, rgid uint32, egid uint32) (r int32) {
	if x___libc.Frsyscall != 0 {
		return (*(*func(*TLS, int32, int64, int64, int64, int64, int64, int64) int32)(unsafe.Pointer(&struct{ uintptr }{x___libc.Frsyscall})))(tls, int32(m___NR_setregid), int64(rgid), int64(egid), 0, 0, 0, 0)
	}
	return int32(_syscall2(tls, int64(m___NR_setregid), int64(rgid), int64(egid)))
}

const m___NR_setreuid = 113

func x_setreuid(tls *TLS, ruid uint32, euid uint32) (r int32) {
	if x___libc.Frsyscall != 0 {
		return (*(*func(*TLS, int32, int64, int64, int64, int64, int64, int64) int32)(unsafe.Pointer(&struct{ uintptr }{x___libc.Frsyscall})))(tls, int32(m___NR_setreuid), int64(ruid), int64(euid), 0, 0, 0, 0)
	}
	return int32(_syscall2(tls, int64(m___NR_setreuid), int64(ruid), int64(euid)))
}

const m___NR_setsid = 112

func x_setsid(tls *TLS) (r int32) {
	return int32(_syscall0(tls, int64(m___NR_setsid)))
}

const m___NR_setuid = 105

func x_setuid(tls *TLS, uid uint32) (r int32) {
	if x___libc.Frsyscall != 0 {
		return (*(*func(*TLS, int32, int64, int64, int64, int64, int64, int64) int32)(unsafe.Pointer(&struct{ uintptr }{x___libc.Frsyscall})))(tls, int32(m___NR_setuid), int64(uid), 0, 0, 0, 0, 0)
	}
	return int32(_syscall1(tls, int64(m___NR_setuid), int64(uid)))
}

func x_sleep(tls *TLS, seconds uint32) (r uint32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{Ftv_sec: int64(seconds), Ftv_nsec: uint64(0)}
	if x_nanosleep(tls, bp, bp) != 0 {
		return uint32((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec)
	}
	return uint32(0)
}

const m___NR_symlink = 88

func x_symlink(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	return int32(_syscall2(tls, int64(m___NR_symlink), int64(existing), int64(new1)))
}

const m___NR_symlinkat = 266

func x_symlinkat(tls *TLS, existing uintptr, fd int32, new1 uintptr) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_symlinkat), int64(existing), int64(fd), int64(new1)))
}

const m___NR_sync = 162

func x_sync(tls *TLS) {
	_syscall0(tls, int64(m___NR_sync))
}

const m_TIOCGPGRP = 21519

func x_tcgetpgrp(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var _ /* pgrp at bp+0 */ int32
	if x_ioctl(tls, fd, int32(m_TIOCGPGRP), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

const m_TIOCSPGRP = 21520

func x_tcsetpgrp(tls *TLS, fd int32, pgrp int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxVaListSize 8 */
	defer tls.Free(24)
	var _ /* pgrp_int at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = pgrp
	return x_ioctl(tls, fd, int32(m_TIOCSPGRP), VaList(bp+16, bp))
}

const m___NR_truncate = 76

func x_truncate(tls *TLS, path uintptr, length int64) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_truncate), int64(path), length, 0))
}

func x_ttyname(tls *TLS, fd int32) (r uintptr) {
	var result, v1 int32
	v1 = x_ttyname_r(tls, fd, uintptr(unsafe.Pointer(&_buf11)), uint64(20))
	result = v1
	if v1 != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = result
		return UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&_buf11))
}

var _buf11 [20]int8

const m_ENOTTY = 25

func x_ttyname_r(tls *TLS, fd int32, name uintptr, size uint64) (r int32) {
	bp := tls.Alloc(48) /* tlsAllocs 32 maxVaListSize 8 */
	defer tls.Free(48)
	var l int64
	var _ /* procname at bp+0 */ [29]int8
	if !(x_isatty(tls, fd) != 0) {
		return int32(m_ENOTTY)
	}
	x_snprintf(tls, bp, uint64(29), ts+1258, VaList(bp+40, fd))
	l = int64(x_readlink(tls, bp, name, size))
	if l < 0 {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	} else {
		if uint64(l) == size {
			return int32(m_ERANGE)
		} else {
			return 0
		}
	}
	return r
}

/* the following are needed for iso c functions to use */

// C documentation
//
//	/* FIXME: ?? */
func x_ualarm(tls *TLS, useconds int64, interval int64) (r int64) {
	return int64(-int32(1))
}

func x_unlink(tls *TLS, path uintptr) (r int32) {
	return int32(_syscall1(tls, int64(m___NR_unlink), int64(path)))
}

const m___NR_unlinkat = 263

func x_unlinkat(tls *TLS, fd int32, path uintptr, flag int32) (r int32) {
	return int32(_syscall3(tls, int64(m___NR_unlinkat), int64(fd), int64(path), int64(flag)))
}

func x_usleep(tls *TLS, useconds int64) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxVaListSize 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{Ftv_sec: useconds / int64(1000000), Ftv_nsec: uint64(useconds % int64(1000000) * int64(1000))}
	return x_nanosleep(tls, bp, bp)
}

func x_write(tls *TLS, fd int32, buf uintptr, count uint64) (r1 int64) {
	var r int32
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = int32(_syscall3(tls, int64(m___NR_write), int64(fd), int64(buf), int64(count)))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return int64(r)
}

const m___NR_writev = 20

func x_writev(tls *TLS, fd int32, iov uintptr, count int32) (r1 int64) {
	var r int64
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, int32(1))
		_ = 0
	}
	_ = Int32FromInt32(0)
	r = _syscall3(tls, int64(m___NR_writev), int64(fd), int64(iov), int64(count))
	if x___libc.Fcancelpt != 0 {
		(*(*func(*TLS, int32))(unsafe.Pointer(&struct{ uintptr }{x___libc.Fcancelpt})))(tls, 0)
		_ = 0
	}
	_ = Int32FromInt32(0)
	return r
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

//#define LFS64_2(x, y) weak_alias(x, y)

var x____environ uintptr

var x___daylight int32

var x___dst_offset int32

//#define LFS64_2(x, y) weak_alias(x, y)

/* Any use of __environ/environ will override this symbol. */
var x___dummy_environ = uintptr(-Int32FromInt32(1))

var x___env_map uintptr

/* Link flush-on-exit code iff any stdio write functions are linked. */
var x___fflush_on_exit = uintptr(0)

/* Upper 6 state bits are a negative integer offset to bound-check next byte */
/*    equivalent to: ( (b-0x80) | (b+offset) ) & ~0x3f      */

/* Interval [a,b). Either a must be 80 or b must be c0, lower 3 bits clear. */

var x___fsmu8 = [51]uint32{
	0:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x2),
	1:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x3),
	2:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x4),
	3:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x5),
	4:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x6),
	5:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x7),
	6:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x8),
	7:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0x9),
	8:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xa),
	9:  uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xb),
	10: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xc),
	11: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xd),
	12: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xe),
	13: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | Uint32FromInt32(0xf),
	14: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x0)+Int32FromInt32(16)),
	15: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x1)+Int32FromInt32(16)),
	16: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x2)+Int32FromInt32(16)),
	17: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x3)+Int32FromInt32(16)),
	18: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x4)+Int32FromInt32(16)),
	19: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x5)+Int32FromInt32(16)),
	20: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x6)+Int32FromInt32(16)),
	21: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x7)+Int32FromInt32(16)),
	22: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x8)+Int32FromInt32(16)),
	23: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0x9)+Int32FromInt32(16)),
	24: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xa)+Int32FromInt32(16)),
	25: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xb)+Int32FromInt32(16)),
	26: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xc)+Int32FromInt32(16)),
	27: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xd)+Int32FromInt32(16)),
	28: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xe)+Int32FromInt32(16)),
	29: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32(Int32FromInt32(0xf)+Int32FromInt32(16)),
	30: uint32(-Int32FromInt32(0xa0)<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x0),
	31: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x1),
	32: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x2),
	33: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x3),
	34: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x4),
	35: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x5),
	36: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x6),
	37: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x7),
	38: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x8),
	39: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0x9),
	40: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xa),
	41: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xb),
	42: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xc),
	43: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xa0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xd),
	44: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xe),
	45: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | Uint32FromInt32(0xf),
	46: uint32(-Int32FromInt32(0x90)<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(12) | Uint32FromInt32(0x0),
	47: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(12) | Uint32FromInt32(0x1),
	48: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(12) | Uint32FromInt32(0x2),
	49: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(12) | Uint32FromInt32(0x3),
	50: uint32((Int32FromInt32(0x40)-Int32FromInt32(0xa0))<<Int32FromInt32(23)) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(6) | uint32((Int32FromInt32(0x40)-Int32FromInt32(0xc0))<<Int32FromInt32(23))>>Int32FromInt32(12) | Uint32FromInt32(0x4)}

var x___funcs_on_exit = uintptr(0)

var x___libc T__libc

var x___ofl Tofl

var x___pthread_tsd_size = Uint64FromInt64(8) * Uint64FromInt32(m_PTHREAD_KEYS_MAX)

var x___seed48 = [7]uint16{
	0: uint16(0),
	1: uint16(0),
	2: uint16(0),
	3: uint16(0xe66d),
	4: uint16(0xdeec),
	5: uint16(0x5),
	6: uint16(0xb)}

/* overrides symbol in fflush.c, used for flushing NULL */
var x___stdout_to_flush = uintptr(unsafe.Pointer(&_f4))

var x___timezone int64

var x___tzname = [2]uintptr{}

//#define LFS64_2(x, y) weak_alias(x, y)

var x_errno int32

var x_h_errno int32

var x_in6addr_any = Tin6_addr{}

var x_in6addr_loopback = Tin6_addr{F__in6_union: *(*struct {
	F__s6_addr32 [0][4]uint32
	F__s6_addr   [16]uint8
})(unsafe.Pointer(&[16]uint8{
	0:  uint8(0),
	1:  uint8(0),
	2:  uint8(0),
	3:  uint8(0),
	4:  uint8(0),
	5:  uint8(0),
	6:  uint8(0),
	7:  uint8(0),
	8:  uint8(0),
	9:  uint8(0),
	10: uint8(0),
	11: uint8(0),
	12: uint8(0),
	13: uint8(0),
	14: uint8(0),
	15: uint8(1)}))}

var x_optarg uintptr

var x_opterr = int32(1)

var x_optind = int32(1)

var x_optopt int32

var Xstderr = uintptr(unsafe.Pointer(&_f2))

var Xstdin = uintptr(unsafe.Pointer(&_f3))

var Xstdout = uintptr(unsafe.Pointer(&_f4))

var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data

var ts1 = "\x00/bin:/usr/bin\x00%s\x00toupper\x00tolower\x00Assertion failed: %s (%s: %s: %d)\n\x00/\x00/dev/null\x00/dev/tty\x00 %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d\x00%s\t%s\t%s\t%s\t%d\t%d\n\x00UTF-8\x00.\x00\xff\x00C\x00POSIX\x00C.UTF-8\x00: illegal option: \x00\n\x00: option requires an argument: \x00/dev/ptmx\x00/dev/pts/%d\x00wb\x00%b %e %T\x00<%d>%s \x00[%d]\x00: \x00/etc/resolv.conf\x00nameserver\x00%d.%d.%d.%d.in-addr.arpa\x00ip6.arpa\x00/etc/hosts\x00%d\x00tcp\x00udp\x00%d.%d.%d.%d\x00%.0x%x:%.0x%x:%.0x%x:%.0x%x:%.0x%x:%.0x%x:%.0x%x:%.0x%x\x00:0\x00/etc/group\x00rb\x00/etc/passwd\x00/etc/tcb/%s/shadow\x00/etc/shadow\x00PATH\x00/usr/local/bin:/bin:/usr/bin\x00new_size > s->size\x00src/regex/regcomp.c\x00TRE_MB_CUR_MAX == 1\x00tnfa->submatch_data[id].parents == NULL\x00!IS_TAG(lit)\x000\x00tree->num_tags == num_tags\x00lit->code_max >= 1 || lit->code_max <= ASSERT_LAST\x00cat->left->nullable\x00cat->right->nullable\x00(trans->assertions & ASSERT_CHAR_CLASS) == 0\x00p2->backref < 0\x00iter->max == -1 || iter->max == 1\x00iter->min == 0 || iter->min == 1\x00Unknown error\x00reach_pos[trans_i->state_id].pos == pos\x00src/regex/regexec.c\x00stack->prev\x00pmatch[i].rm_so == -1\x00pmatch[i].rm_so <= pmatch[i].rm_eo\x00rwa\x00%s: %m\n\x00%m\n\x00rw\x00/bin/sh\x00sh\x00-c\x00/tmp\x00temp\x00%s/%s-%d-%d\x00w+\x00TMPDIR\x00%s/temp%d-%d\x00-+ \x00inf\x00INF\x00nan\x00NAN\x00%\x00-+   0X0x\x00XXXXXX\x00%06d\x00%.3s %.3s%3d %.2d:%.2d:%.2d %d\n\x00%02d\x00%m/%d/%y\x00%2d\x00%Y-%m-%d\x00%04d\x00%03d\x00%H:%M\x00%H:%M:%S\x00%+.2d%.2d\x00GMT\x00TZ\x00LOGNAME\x00/proc/self/fd/%d\x00"
