// Code generated for linux/amd64 by 'gcc --package-name=libc --prefix-enumerator=_ --prefix-external=x_ --prefix-field=F --prefix-static-internal=_ --prefix-static-none=_ --prefix-tagged-enum=_ --prefix-tagged-struct=T --prefix-tagged-union=T --prefix-typename=T --prefix-macro=m_ --prefix-undefined=_ -exec-cc gcc -extended-errors -hide=__assert_fail -ignore-asm-errors -ignore-header-functions -ignore-unsupported-alignment -std=c99 -nostdinc -ffreestanding -D_XOPEN_SOURCE=700 -I./arch/x86_64 -I./arch/generic -Iobj/src/internal -I./src/include -I./src/internal -Iobj/include -I./include -mlong-double-64 -nostdlib -shared -o lib/libc.so.go obj/src/aio/aio.lo.go obj/src/aio/aio_suspend.lo.go obj/src/aio/lio_listio.lo.go obj/src/complex/__cexp.lo.go obj/src/complex/__cexpf.lo.go obj/src/complex/cabs.lo.go obj/src/complex/cabsf.lo.go obj/src/complex/cabsl.lo.go obj/src/complex/cacos.lo.go obj/src/complex/cacosf.lo.go obj/src/complex/cacosh.lo.go obj/src/complex/cacoshf.lo.go obj/src/complex/cacoshl.lo.go obj/src/complex/cacosl.lo.go obj/src/complex/carg.lo.go obj/src/complex/cargf.lo.go obj/src/complex/cargl.lo.go obj/src/complex/casin.lo.go obj/src/complex/casinf.lo.go obj/src/complex/casinh.lo.go obj/src/complex/casinhf.lo.go obj/src/complex/casinhl.lo.go obj/src/complex/casinl.lo.go obj/src/complex/catan.lo.go obj/src/complex/catanf.lo.go obj/src/complex/catanh.lo.go obj/src/complex/catanhf.lo.go obj/src/complex/catanhl.lo.go obj/src/complex/catanl.lo.go obj/src/complex/ccos.lo.go obj/src/complex/ccosf.lo.go obj/src/complex/ccosh.lo.go obj/src/complex/ccoshf.lo.go obj/src/complex/ccoshl.lo.go obj/src/complex/ccosl.lo.go obj/src/complex/cexp.lo.go obj/src/complex/cexpf.lo.go obj/src/complex/cexpl.lo.go obj/src/complex/cimag.lo.go obj/src/complex/cimagf.lo.go obj/src/complex/cimagl.lo.go obj/src/complex/clog.lo.go obj/src/complex/clogf.lo.go obj/src/complex/clogl.lo.go obj/src/complex/conj.lo.go obj/src/complex/conjf.lo.go obj/src/complex/conjl.lo.go obj/src/complex/cpow.lo.go obj/src/complex/cpowf.lo.go obj/src/complex/cpowl.lo.go obj/src/complex/cproj.lo.go obj/src/complex/cprojf.lo.go obj/src/complex/cprojl.lo.go obj/src/complex/creal.lo.go obj/src/complex/crealf.lo.go obj/src/complex/creall.lo.go obj/src/complex/csin.lo.go obj/src/complex/csinf.lo.go obj/src/complex/csinh.lo.go obj/src/complex/csinhf.lo.go obj/src/complex/csinhl.lo.go obj/src/complex/csinl.lo.go obj/src/complex/csqrt.lo.go obj/src/complex/csqrtf.lo.go obj/src/complex/csqrtl.lo.go obj/src/complex/ctan.lo.go obj/src/complex/ctanf.lo.go obj/src/complex/ctanh.lo.go obj/src/complex/ctanhf.lo.go obj/src/complex/ctanhl.lo.go obj/src/complex/ctanl.lo.go obj/src/conf/confstr.lo.go obj/src/conf/fpathconf.lo.go obj/src/conf/legacy.lo.go obj/src/conf/pathconf.lo.go obj/src/conf/sysconf.lo.go obj/src/crypt/crypt.lo.go obj/src/crypt/crypt_blowfish.lo.go obj/src/crypt/crypt_des.lo.go obj/src/crypt/crypt_md5.lo.go obj/src/crypt/crypt_r.lo.go obj/src/crypt/crypt_sha256.lo.go obj/src/crypt/crypt_sha512.lo.go obj/src/crypt/encrypt.lo.go obj/src/ctype/__ctype_b_loc.lo.go obj/src/ctype/__ctype_get_mb_cur_max.lo.go obj/src/ctype/__ctype_tolower_loc.lo.go obj/src/ctype/__ctype_toupper_loc.lo.go obj/src/ctype/isalnum.lo.go obj/src/ctype/isalpha.lo.go obj/src/ctype/isascii.lo.go obj/src/ctype/isblank.lo.go obj/src/ctype/iscntrl.lo.go obj/src/ctype/isdigit.lo.go obj/src/ctype/isgraph.lo.go obj/src/ctype/islower.lo.go obj/src/ctype/isprint.lo.go obj/src/ctype/ispunct.lo.go obj/src/ctype/isspace.lo.go obj/src/ctype/isupper.lo.go obj/src/ctype/iswalnum.lo.go obj/src/ctype/iswalpha.lo.go obj/src/ctype/iswblank.lo.go obj/src/ctype/iswcntrl.lo.go obj/src/ctype/iswctype.lo.go obj/src/ctype/iswdigit.lo.go obj/src/ctype/iswgraph.lo.go obj/src/ctype/iswlower.lo.go obj/src/ctype/iswprint.lo.go obj/src/ctype/iswpunct.lo.go obj/src/ctype/iswspace.lo.go obj/src/ctype/iswupper.lo.go obj/src/ctype/iswxdigit.lo.go obj/src/ctype/isxdigit.lo.go obj/src/ctype/toascii.lo.go obj/src/ctype/tolower.lo.go obj/src/ctype/toupper.lo.go obj/src/ctype/towctrans.lo.go obj/src/ctype/wcswidth.lo.go obj/src/ctype/wctrans.lo.go obj/src/ctype/wcwidth.lo.go obj/src/dirent/alphasort.lo.go obj/src/dirent/closedir.lo.go obj/src/dirent/dirfd.lo.go obj/src/dirent/fdopendir.lo.go obj/src/dirent/opendir.lo.go obj/src/dirent/readdir.lo.go obj/src/dirent/readdir_r.lo.go obj/src/dirent/rewinddir.lo.go obj/src/dirent/scandir.lo.go obj/src/dirent/seekdir.lo.go obj/src/dirent/telldir.lo.go obj/src/dirent/versionsort.lo.go obj/src/env/__environ.lo.go obj/src/env/__init_tls.lo.go obj/src/env/__libc_start_main.lo.go obj/src/env/__reset_tls.lo.go obj/src/env/__stack_chk_fail.lo.go obj/src/env/clearenv.lo.go obj/src/env/getenv.lo.go obj/src/env/putenv.lo.go obj/src/env/secure_getenv.lo.go obj/src/env/setenv.lo.go obj/src/env/unsetenv.lo.go obj/src/errno/__errno_location.lo.go obj/src/errno/strerror.lo.go obj/src/exit/_Exit.lo.go obj/src/exit/abort.lo.go obj/src/exit/abort_lock.lo.go obj/src/exit/assert.lo.go obj/src/exit/at_quick_exit.lo.go obj/src/exit/atexit.lo.go obj/src/exit/exit.lo.go obj/src/exit/quick_exit.lo.go obj/src/fcntl/creat.lo.go obj/src/fcntl/fcntl.lo.go obj/src/fcntl/open.lo.go obj/src/fcntl/openat.lo.go obj/src/fcntl/posix_fadvise.lo.go obj/src/fcntl/posix_fallocate.lo.go obj/src/fenv/__flt_rounds.lo.go obj/src/fenv/fegetexceptflag.lo.go obj/src/fenv/feholdexcept.lo.go obj/src/fenv/fesetexceptflag.lo.go obj/src/fenv/fesetround.lo.go obj/src/fenv/feupdateenv.lo.go obj/src/internal/defsysinfo.lo.go obj/src/internal/floatscan.lo.go obj/src/internal/intscan.lo.go obj/src/internal/libc.lo.go obj/src/internal/procfdname.lo.go obj/src/internal/shgetc.lo.go obj/src/internal/syscall_ret.lo.go obj/src/internal/vdso.lo.go obj/src/internal/version.lo.go obj/src/ipc/ftok.lo.go obj/src/ipc/msgctl.lo.go obj/src/ipc/msgget.lo.go obj/src/ipc/msgrcv.lo.go obj/src/ipc/msgsnd.lo.go obj/src/ipc/semctl.lo.go obj/src/ipc/semget.lo.go obj/src/ipc/semop.lo.go obj/src/ipc/semtimedop.lo.go obj/src/ipc/shmat.lo.go obj/src/ipc/shmctl.lo.go obj/src/ipc/shmdt.lo.go obj/src/ipc/shmget.lo.go obj/src/ldso/__dlsym.lo.go obj/src/ldso/dl_iterate_phdr.lo.go obj/src/ldso/dladdr.lo.go obj/src/ldso/dlclose.lo.go obj/src/ldso/dlerror.lo.go obj/src/ldso/dlinfo.lo.go obj/src/ldso/dlopen.lo.go obj/src/legacy/cuserid.lo.go obj/src/legacy/daemon.lo.go obj/src/legacy/err.lo.go obj/src/legacy/euidaccess.lo.go obj/src/legacy/ftw.lo.go obj/src/legacy/futimes.lo.go obj/src/legacy/getdtablesize.lo.go obj/src/legacy/getloadavg.lo.go obj/src/legacy/getpagesize.lo.go obj/src/legacy/getpass.lo.go obj/src/legacy/getusershell.lo.go obj/src/legacy/isastream.lo.go obj/src/legacy/lutimes.lo.go obj/src/legacy/ulimit.lo.go obj/src/legacy/utmpx.lo.go obj/src/legacy/valloc.lo.go obj/src/linux/adjtime.lo.go obj/src/linux/adjtimex.lo.go obj/src/linux/arch_prctl.lo.go obj/src/linux/brk.lo.go obj/src/linux/cache.lo.go obj/src/linux/cap.lo.go obj/src/linux/chroot.lo.go obj/src/linux/clock_adjtime.lo.go obj/src/linux/clone.lo.go obj/src/linux/copy_file_range.lo.go obj/src/linux/epoll.lo.go obj/src/linux/eventfd.lo.go obj/src/linux/fallocate.lo.go obj/src/linux/fanotify.lo.go obj/src/linux/flock.lo.go obj/src/linux/getdents.lo.go obj/src/linux/getrandom.lo.go obj/src/linux/gettid.lo.go obj/src/linux/inotify.lo.go obj/src/linux/ioperm.lo.go obj/src/linux/iopl.lo.go obj/src/linux/klogctl.lo.go obj/src/linux/membarrier.lo.go obj/src/linux/memfd_create.lo.go obj/src/linux/mlock2.lo.go obj/src/linux/module.lo.go obj/src/linux/mount.lo.go obj/src/linux/name_to_handle_at.lo.go obj/src/linux/open_by_handle_at.lo.go obj/src/linux/personality.lo.go obj/src/linux/pivot_root.lo.go obj/src/linux/ppoll.lo.go obj/src/linux/prctl.lo.go obj/src/linux/prlimit.lo.go obj/src/linux/process_vm.lo.go obj/src/linux/ptrace.lo.go obj/src/linux/quotactl.lo.go obj/src/linux/readahead.lo.go obj/src/linux/reboot.lo.go obj/src/linux/remap_file_pages.lo.go obj/src/linux/sbrk.lo.go obj/src/linux/sendfile.lo.go obj/src/linux/setfsgid.lo.go obj/src/linux/setfsuid.lo.go obj/src/linux/setgroups.lo.go obj/src/linux/sethostname.lo.go obj/src/linux/setns.lo.go obj/src/linux/settimeofday.lo.go obj/src/linux/signalfd.lo.go obj/src/linux/splice.lo.go obj/src/linux/stime.lo.go obj/src/linux/swap.lo.go obj/src/linux/sync_file_range.lo.go obj/src/linux/syncfs.lo.go obj/src/linux/sysinfo.lo.go obj/src/linux/tee.lo.go obj/src/linux/timerfd.lo.go obj/src/linux/unshare.lo.go obj/src/linux/utimes.lo.go obj/src/linux/vhangup.lo.go obj/src/linux/vmsplice.lo.go obj/src/linux/wait3.lo.go obj/src/linux/wait4.lo.go obj/src/linux/xattr.lo.go obj/src/locale/__lctrans.lo.go obj/src/locale/__mo_lookup.lo.go obj/src/locale/bind_textdomain_codeset.lo.go obj/src/locale/c_locale.lo.go obj/src/locale/catclose.lo.go obj/src/locale/catgets.lo.go obj/src/locale/catopen.lo.go obj/src/locale/dcngettext.lo.go obj/src/locale/duplocale.lo.go obj/src/locale/freelocale.lo.go obj/src/locale/iconv.lo.go obj/src/locale/iconv_close.lo.go obj/src/locale/langinfo.lo.go obj/src/locale/locale_map.lo.go obj/src/locale/localeconv.lo.go obj/src/locale/newlocale.lo.go obj/src/locale/pleval.lo.go obj/src/locale/setlocale.lo.go obj/src/locale/strcoll.lo.go obj/src/locale/strfmon.lo.go obj/src/locale/strtod_l.lo.go obj/src/locale/strxfrm.lo.go obj/src/locale/textdomain.lo.go obj/src/locale/uselocale.lo.go obj/src/locale/wcscoll.lo.go obj/src/locale/wcsxfrm.lo.go obj/src/malloc/calloc.lo.go obj/src/malloc/free.lo.go obj/src/malloc/libc_calloc.lo.go obj/src/malloc/lite_malloc.lo.go obj/src/malloc/mallocng/aligned_alloc.lo.go obj/src/malloc/mallocng/donate.lo.go obj/src/malloc/mallocng/free.lo.go obj/src/malloc/mallocng/malloc.lo.go obj/src/malloc/mallocng/malloc_usable_size.lo.go obj/src/malloc/mallocng/realloc.lo.go obj/src/malloc/memalign.lo.go obj/src/malloc/posix_memalign.lo.go obj/src/malloc/realloc.lo.go obj/src/malloc/reallocarray.lo.go obj/src/malloc/replaced.lo.go obj/src/math/__cos.lo.go obj/src/math/__cosdf.lo.go obj/src/math/__cosl.lo.go obj/src/math/__expo2.lo.go obj/src/math/__expo2f.lo.go obj/src/math/__fpclassify.lo.go obj/src/math/__fpclassifyf.lo.go obj/src/math/__fpclassifyl.lo.go obj/src/math/__math_divzero.lo.go obj/src/math/__math_divzerof.lo.go obj/src/math/__math_invalid.lo.go obj/src/math/__math_invalidf.lo.go obj/src/math/__math_invalidl.lo.go obj/src/math/__math_oflow.lo.go obj/src/math/__math_oflowf.lo.go obj/src/math/__math_uflow.lo.go obj/src/math/__math_uflowf.lo.go obj/src/math/__math_xflow.lo.go obj/src/math/__math_xflowf.lo.go obj/src/math/__polevll.lo.go obj/src/math/__rem_pio2.lo.go obj/src/math/__rem_pio2_large.lo.go obj/src/math/__rem_pio2f.lo.go obj/src/math/__rem_pio2l.lo.go obj/src/math/__signbit.lo.go obj/src/math/__signbitf.lo.go obj/src/math/__signbitl.lo.go obj/src/math/__sin.lo.go obj/src/math/__sindf.lo.go obj/src/math/__sinl.lo.go obj/src/math/__tan.lo.go obj/src/math/__tandf.lo.go obj/src/math/__tanl.lo.go obj/src/math/acos.lo.go obj/src/math/acosf.lo.go obj/src/math/acosh.lo.go obj/src/math/acoshf.lo.go obj/src/math/acoshl.lo.go obj/src/math/asin.lo.go obj/src/math/asinf.lo.go obj/src/math/asinh.lo.go obj/src/math/asinhf.lo.go obj/src/math/asinhl.lo.go obj/src/math/atan.lo.go obj/src/math/atan2.lo.go obj/src/math/atan2f.lo.go obj/src/math/atanf.lo.go obj/src/math/atanh.lo.go obj/src/math/atanhf.lo.go obj/src/math/atanhl.lo.go obj/src/math/cbrt.lo.go obj/src/math/cbrtf.lo.go obj/src/math/cbrtl.lo.go obj/src/math/ceil.lo.go obj/src/math/ceilf.lo.go obj/src/math/copysign.lo.go obj/src/math/copysignf.lo.go obj/src/math/copysignl.lo.go obj/src/math/cos.lo.go obj/src/math/cosf.lo.go obj/src/math/cosh.lo.go obj/src/math/coshf.lo.go obj/src/math/coshl.lo.go obj/src/math/cosl.lo.go obj/src/math/erf.lo.go obj/src/math/erff.lo.go obj/src/math/erfl.lo.go obj/src/math/exp.lo.go obj/src/math/exp10.lo.go obj/src/math/exp10f.lo.go obj/src/math/exp10l.lo.go obj/src/math/exp2.lo.go obj/src/math/exp2f.lo.go obj/src/math/exp2f_data.lo.go obj/src/math/exp_data.lo.go obj/src/math/expf.lo.go obj/src/math/expm1.lo.go obj/src/math/expm1f.lo.go obj/src/math/fabs.lo.go obj/src/math/fabsf.lo.go obj/src/math/fdim.lo.go obj/src/math/fdimf.lo.go obj/src/math/fdiml.lo.go obj/src/math/finite.lo.go obj/src/math/finitef.lo.go obj/src/math/floor.lo.go obj/src/math/floorf.lo.go obj/src/math/fmal.lo.go obj/src/math/fmax.lo.go obj/src/math/fmaxf.lo.go obj/src/math/fmaxl.lo.go obj/src/math/fmin.lo.go obj/src/math/fminf.lo.go obj/src/math/fminl.lo.go obj/src/math/fmod.lo.go obj/src/math/fmodf.lo.go obj/src/math/frexp.lo.go obj/src/math/frexpf.lo.go obj/src/math/frexpl.lo.go obj/src/math/hypot.lo.go obj/src/math/hypotf.lo.go obj/src/math/hypotl.lo.go obj/src/math/ilogb.lo.go obj/src/math/ilogbf.lo.go obj/src/math/ilogbl.lo.go obj/src/math/j0.lo.go obj/src/math/j0f.lo.go obj/src/math/j1.lo.go obj/src/math/j1f.lo.go obj/src/math/jn.lo.go obj/src/math/jnf.lo.go obj/src/math/ldexp.lo.go obj/src/math/ldexpf.lo.go obj/src/math/ldexpl.lo.go obj/src/math/lgamma.lo.go obj/src/math/lgamma_r.lo.go obj/src/math/lgammaf.lo.go obj/src/math/lgammaf_r.lo.go obj/src/math/lgammal.lo.go obj/src/math/llround.lo.go obj/src/math/llroundf.lo.go obj/src/math/llroundl.lo.go obj/src/math/log.lo.go obj/src/math/log10.lo.go obj/src/math/log10f.lo.go obj/src/math/log1p.lo.go obj/src/math/log1pf.lo.go obj/src/math/log2.lo.go obj/src/math/log2_data.lo.go obj/src/math/log2f.lo.go obj/src/math/log2f_data.lo.go obj/src/math/log_data.lo.go obj/src/math/logb.lo.go obj/src/math/logbf.lo.go obj/src/math/logbl.lo.go obj/src/math/logf.lo.go obj/src/math/logf_data.lo.go obj/src/math/lround.lo.go obj/src/math/lroundf.lo.go obj/src/math/lroundl.lo.go obj/src/math/modf.lo.go obj/src/math/modff.lo.go obj/src/math/modfl.lo.go obj/src/math/nan.lo.go obj/src/math/nanf.lo.go obj/src/math/nanl.lo.go obj/src/math/nearbyint.lo.go obj/src/math/nearbyintf.lo.go obj/src/math/nearbyintl.lo.go obj/src/math/nextafter.lo.go obj/src/math/nextafterf.lo.go obj/src/math/nextafterl.lo.go obj/src/math/nexttoward.lo.go obj/src/math/nexttowardf.lo.go obj/src/math/nexttowardl.lo.go obj/src/math/pow.lo.go obj/src/math/pow_data.lo.go obj/src/math/powf.lo.go obj/src/math/powf_data.lo.go obj/src/math/powl.lo.go obj/src/math/remainder.lo.go obj/src/math/remainderf.lo.go obj/src/math/remquo.lo.go obj/src/math/remquof.lo.go obj/src/math/rint.lo.go obj/src/math/rintf.lo.go obj/src/math/round.lo.go obj/src/math/roundf.lo.go obj/src/math/roundl.lo.go obj/src/math/scalb.lo.go obj/src/math/scalbf.lo.go obj/src/math/scalbln.lo.go obj/src/math/scalblnf.lo.go obj/src/math/scalblnl.lo.go obj/src/math/scalbn.lo.go obj/src/math/scalbnf.lo.go obj/src/math/scalbnl.lo.go obj/src/math/signgam.lo.go obj/src/math/significand.lo.go obj/src/math/significandf.lo.go obj/src/math/sin.lo.go obj/src/math/sincos.lo.go obj/src/math/sincosf.lo.go obj/src/math/sincosl.lo.go obj/src/math/sinf.lo.go obj/src/math/sinh.lo.go obj/src/math/sinhf.lo.go obj/src/math/sinhl.lo.go obj/src/math/sinl.lo.go obj/src/math/sqrt_data.lo.go obj/src/math/tan.lo.go obj/src/math/tanf.lo.go obj/src/math/tanh.lo.go obj/src/math/tanhf.lo.go obj/src/math/tanhl.lo.go obj/src/math/tanl.lo.go obj/src/math/tgamma.lo.go obj/src/math/tgammaf.lo.go obj/src/math/tgammal.lo.go obj/src/math/trunc.lo.go obj/src/math/truncf.lo.go obj/src/math/x86_64/fabsl.lo.go obj/src/math/x86_64/fma.lo.go obj/src/math/x86_64/fmaf.lo.go obj/src/math/x86_64/fmodl.lo.go obj/src/math/x86_64/llrint.lo.go obj/src/math/x86_64/llrintf.lo.go obj/src/math/x86_64/llrintl.lo.go obj/src/math/x86_64/lrint.lo.go obj/src/math/x86_64/lrintf.lo.go obj/src/math/x86_64/lrintl.lo.go obj/src/math/x86_64/remainderl.lo.go obj/src/math/x86_64/remquol.lo.go obj/src/math/x86_64/rintl.lo.go obj/src/math/x86_64/sqrt.lo.go obj/src/math/x86_64/sqrtf.lo.go obj/src/math/x86_64/sqrtl.lo.go obj/src/misc/a64l.lo.go obj/src/misc/basename.lo.go obj/src/misc/dirname.lo.go obj/src/misc/ffs.lo.go obj/src/misc/ffsl.lo.go obj/src/misc/ffsll.lo.go obj/src/misc/fmtmsg.lo.go obj/src/misc/forkpty.lo.go obj/src/misc/get_current_dir_name.lo.go obj/src/misc/getauxval.lo.go obj/src/misc/getdomainname.lo.go obj/src/misc/getentropy.lo.go obj/src/misc/gethostid.lo.go obj/src/misc/getopt.lo.go obj/src/misc/getopt_long.lo.go obj/src/misc/getpriority.lo.go obj/src/misc/getresgid.lo.go obj/src/misc/getresuid.lo.go obj/src/misc/getrlimit.lo.go obj/src/misc/getrusage.lo.go obj/src/misc/getsubopt.lo.go obj/src/misc/initgroups.lo.go obj/src/misc/ioctl.lo.go obj/src/misc/issetugid.lo.go obj/src/misc/lockf.lo.go obj/src/misc/login_tty.lo.go obj/src/misc/mntent.lo.go obj/src/misc/nftw.lo.go obj/src/misc/openpty.lo.go obj/src/misc/ptsname.lo.go obj/src/misc/pty.lo.go obj/src/misc/realpath.lo.go obj/src/misc/setdomainname.lo.go obj/src/misc/setpriority.lo.go obj/src/misc/setrlimit.lo.go obj/src/misc/syscall.lo.go obj/src/misc/syslog.lo.go obj/src/misc/uname.lo.go obj/src/misc/wordexp.lo.go obj/src/mman/madvise.lo.go obj/src/mman/mincore.lo.go obj/src/mman/mlock.lo.go obj/src/mman/mlockall.lo.go obj/src/mman/mmap.lo.go obj/src/mman/mprotect.lo.go obj/src/mman/mremap.lo.go obj/src/mman/msync.lo.go obj/src/mman/munlock.lo.go obj/src/mman/munlockall.lo.go obj/src/mman/munmap.lo.go obj/src/mman/posix_madvise.lo.go obj/src/mman/shm_open.lo.go obj/src/mq/mq_close.lo.go obj/src/mq/mq_getattr.lo.go obj/src/mq/mq_notify.lo.go obj/src/mq/mq_open.lo.go obj/src/mq/mq_receive.lo.go obj/src/mq/mq_send.lo.go obj/src/mq/mq_setattr.lo.go obj/src/mq/mq_timedreceive.lo.go obj/src/mq/mq_timedsend.lo.go obj/src/mq/mq_unlink.lo.go obj/src/multibyte/btowc.lo.go obj/src/multibyte/c16rtomb.lo.go obj/src/multibyte/c32rtomb.lo.go obj/src/multibyte/internal.lo.go obj/src/multibyte/mblen.lo.go obj/src/multibyte/mbrlen.lo.go obj/src/multibyte/mbrtoc16.lo.go obj/src/multibyte/mbrtoc32.lo.go obj/src/multibyte/mbrtowc.lo.go obj/src/multibyte/mbsinit.lo.go obj/src/multibyte/mbsnrtowcs.lo.go obj/src/multibyte/mbsrtowcs.lo.go obj/src/multibyte/mbstowcs.lo.go obj/src/multibyte/mbtowc.lo.go obj/src/multibyte/wcrtomb.lo.go obj/src/multibyte/wcsnrtombs.lo.go obj/src/multibyte/wcsrtombs.lo.go obj/src/multibyte/wcstombs.lo.go obj/src/multibyte/wctob.lo.go obj/src/multibyte/wctomb.lo.go obj/src/network/accept.lo.go obj/src/network/accept4.lo.go obj/src/network/bind.lo.go obj/src/network/connect.lo.go obj/src/network/dn_comp.lo.go obj/src/network/dn_expand.lo.go obj/src/network/dn_skipname.lo.go obj/src/network/dns_parse.lo.go obj/src/network/ent.lo.go obj/src/network/ether.lo.go obj/src/network/freeaddrinfo.lo.go obj/src/network/gai_strerror.lo.go obj/src/network/getaddrinfo.lo.go obj/src/network/gethostbyaddr.lo.go obj/src/network/gethostbyaddr_r.lo.go obj/src/network/gethostbyname.lo.go obj/src/network/gethostbyname2.lo.go obj/src/network/gethostbyname2_r.lo.go obj/src/network/gethostbyname_r.lo.go obj/src/network/getifaddrs.lo.go obj/src/network/getnameinfo.lo.go obj/src/network/getpeername.lo.go obj/src/network/getservbyname.lo.go obj/src/network/getservbyname_r.lo.go obj/src/network/getservbyport.lo.go obj/src/network/getservbyport_r.lo.go obj/src/network/getsockname.lo.go obj/src/network/getsockopt.lo.go obj/src/network/h_errno.lo.go obj/src/network/herror.lo.go obj/src/network/hstrerror.lo.go obj/src/network/htonl.lo.go obj/src/network/htons.lo.go obj/src/network/if_freenameindex.lo.go obj/src/network/if_indextoname.lo.go obj/src/network/if_nameindex.lo.go obj/src/network/if_nametoindex.lo.go obj/src/network/in6addr_any.lo.go obj/src/network/in6addr_loopback.lo.go obj/src/network/inet_addr.lo.go obj/src/network/inet_aton.lo.go obj/src/network/inet_legacy.lo.go obj/src/network/inet_ntoa.lo.go obj/src/network/inet_ntop.lo.go obj/src/network/inet_pton.lo.go obj/src/network/listen.lo.go obj/src/network/lookup_ipliteral.lo.go obj/src/network/lookup_name.lo.go obj/src/network/lookup_serv.lo.go obj/src/network/netlink.lo.go obj/src/network/netname.lo.go obj/src/network/ns_parse.lo.go obj/src/network/ntohl.lo.go obj/src/network/ntohs.lo.go obj/src/network/proto.lo.go obj/src/network/recv.lo.go obj/src/network/recvfrom.lo.go obj/src/network/recvmmsg.lo.go obj/src/network/recvmsg.lo.go obj/src/network/res_init.lo.go obj/src/network/res_mkquery.lo.go obj/src/network/res_msend.lo.go obj/src/network/res_query.lo.go obj/src/network/res_querydomain.lo.go obj/src/network/res_send.lo.go obj/src/network/res_state.lo.go obj/src/network/resolvconf.lo.go obj/src/network/send.lo.go obj/src/network/sendmmsg.lo.go obj/src/network/sendmsg.lo.go obj/src/network/sendto.lo.go obj/src/network/serv.lo.go obj/src/network/setsockopt.lo.go obj/src/network/shutdown.lo.go obj/src/network/sockatmark.lo.go obj/src/network/socket.lo.go obj/src/network/socketpair.lo.go obj/src/passwd/fgetgrent.lo.go obj/src/passwd/fgetpwent.lo.go obj/src/passwd/fgetspent.lo.go obj/src/passwd/getgr_a.lo.go obj/src/passwd/getgr_r.lo.go obj/src/passwd/getgrent.lo.go obj/src/passwd/getgrent_a.lo.go obj/src/passwd/getgrouplist.lo.go obj/src/passwd/getpw_a.lo.go obj/src/passwd/getpw_r.lo.go obj/src/passwd/getpwent.lo.go obj/src/passwd/getpwent_a.lo.go obj/src/passwd/getspent.lo.go obj/src/passwd/getspnam.lo.go obj/src/passwd/getspnam_r.lo.go obj/src/passwd/lckpwdf.lo.go obj/src/passwd/nscd_query.lo.go obj/src/passwd/putgrent.lo.go obj/src/passwd/putpwent.lo.go obj/src/passwd/putspent.lo.go obj/src/prng/__rand48_step.lo.go obj/src/prng/__seed48.lo.go obj/src/prng/drand48.lo.go obj/src/prng/lcong48.lo.go obj/src/prng/lrand48.lo.go obj/src/prng/mrand48.lo.go obj/src/prng/rand.lo.go obj/src/prng/rand_r.lo.go obj/src/prng/random.lo.go obj/src/prng/seed48.lo.go obj/src/prng/srand48.lo.go obj/src/process/_Fork.lo.go obj/src/process/execl.lo.go obj/src/process/execle.lo.go obj/src/process/execlp.lo.go obj/src/process/execv.lo.go obj/src/process/execve.lo.go obj/src/process/execvp.lo.go obj/src/process/fexecve.lo.go obj/src/process/fork.lo.go obj/src/process/posix_spawn.lo.go obj/src/process/posix_spawn_file_actions_addchdir.lo.go obj/src/process/posix_spawn_file_actions_addclose.lo.go obj/src/process/posix_spawn_file_actions_adddup2.lo.go obj/src/process/posix_spawn_file_actions_addfchdir.lo.go obj/src/process/posix_spawn_file_actions_addopen.lo.go obj/src/process/posix_spawn_file_actions_destroy.lo.go obj/src/process/posix_spawn_file_actions_init.lo.go obj/src/process/posix_spawnattr_destroy.lo.go obj/src/process/posix_spawnattr_getflags.lo.go obj/src/process/posix_spawnattr_getpgroup.lo.go obj/src/process/posix_spawnattr_getsigdefault.lo.go obj/src/process/posix_spawnattr_getsigmask.lo.go obj/src/process/posix_spawnattr_init.lo.go obj/src/process/posix_spawnattr_sched.lo.go obj/src/process/posix_spawnattr_setflags.lo.go obj/src/process/posix_spawnattr_setpgroup.lo.go obj/src/process/posix_spawnattr_setsigdefault.lo.go obj/src/process/posix_spawnattr_setsigmask.lo.go obj/src/process/posix_spawnp.lo.go obj/src/process/system.lo.go obj/src/process/wait.lo.go obj/src/process/waitid.lo.go obj/src/process/waitpid.lo.go obj/src/regex/fnmatch.lo.go obj/src/regex/glob.lo.go obj/src/regex/regcomp.lo.go obj/src/regex/regerror.lo.go obj/src/regex/regexec.lo.go obj/src/regex/tre-mem.lo.go obj/src/sched/affinity.lo.go obj/src/sched/sched_cpucount.lo.go obj/src/sched/sched_get_priority_max.lo.go obj/src/sched/sched_getcpu.lo.go obj/src/sched/sched_getparam.lo.go obj/src/sched/sched_getscheduler.lo.go obj/src/sched/sched_rr_get_interval.lo.go obj/src/sched/sched_setparam.lo.go obj/src/sched/sched_setscheduler.lo.go obj/src/sched/sched_yield.lo.go obj/src/search/hsearch.lo.go obj/src/search/insque.lo.go obj/src/search/lsearch.lo.go obj/src/search/tdelete.lo.go obj/src/search/tdestroy.lo.go obj/src/search/tfind.lo.go obj/src/search/tsearch.lo.go obj/src/search/twalk.lo.go obj/src/select/poll.lo.go obj/src/select/pselect.lo.go obj/src/select/select.lo.go obj/src/signal/block.lo.go obj/src/signal/getitimer.lo.go obj/src/signal/kill.lo.go obj/src/signal/killpg.lo.go obj/src/signal/psiginfo.lo.go obj/src/signal/psignal.lo.go obj/src/signal/raise.lo.go obj/src/signal/setitimer.lo.go obj/src/signal/sigaction.lo.go obj/src/signal/sigaddset.lo.go obj/src/signal/sigaltstack.lo.go obj/src/signal/sigandset.lo.go obj/src/signal/sigdelset.lo.go obj/src/signal/sigemptyset.lo.go obj/src/signal/sigfillset.lo.go obj/src/signal/sighold.lo.go obj/src/signal/sigignore.lo.go obj/src/signal/siginterrupt.lo.go obj/src/signal/sigisemptyset.lo.go obj/src/signal/sigismember.lo.go obj/src/signal/siglongjmp.lo.go obj/src/signal/signal.lo.go obj/src/signal/sigorset.lo.go obj/src/signal/sigpause.lo.go obj/src/signal/sigpending.lo.go obj/src/signal/sigprocmask.lo.go obj/src/signal/sigqueue.lo.go obj/src/signal/sigrelse.lo.go obj/src/signal/sigrtmax.lo.go obj/src/signal/sigrtmin.lo.go obj/src/signal/sigset.lo.go obj/src/signal/sigsetjmp_tail.lo.go obj/src/signal/sigsuspend.lo.go obj/src/signal/sigtimedwait.lo.go obj/src/signal/sigwait.lo.go obj/src/signal/sigwaitinfo.lo.go obj/src/stat/__xstat.lo.go obj/src/stat/chmod.lo.go obj/src/stat/fchmod.lo.go obj/src/stat/fchmodat.lo.go obj/src/stat/fstat.lo.go obj/src/stat/fstatat.lo.go obj/src/stat/futimens.lo.go obj/src/stat/futimesat.lo.go obj/src/stat/lchmod.lo.go obj/src/stat/lstat.lo.go obj/src/stat/mkdir.lo.go obj/src/stat/mkdirat.lo.go obj/src/stat/mkfifo.lo.go obj/src/stat/mkfifoat.lo.go obj/src/stat/mknod.lo.go obj/src/stat/mknodat.lo.go obj/src/stat/stat.lo.go obj/src/stat/statvfs.lo.go obj/src/stat/umask.lo.go obj/src/stat/utimensat.lo.go obj/src/stdio/__fclose_ca.lo.go obj/src/stdio/__fdopen.lo.go obj/src/stdio/__fmodeflags.lo.go obj/src/stdio/__fopen_rb_ca.lo.go obj/src/stdio/__lockfile.lo.go obj/src/stdio/__overflow.lo.go obj/src/stdio/__stdio_close.lo.go obj/src/stdio/__stdio_exit.lo.go obj/src/stdio/__stdio_read.lo.go obj/src/stdio/__stdio_seek.lo.go obj/src/stdio/__stdio_write.lo.go obj/src/stdio/__stdout_write.lo.go obj/src/stdio/__toread.lo.go obj/src/stdio/__towrite.lo.go obj/src/stdio/__uflow.lo.go obj/src/stdio/asprintf.lo.go obj/src/stdio/clearerr.lo.go obj/src/stdio/dprintf.lo.go obj/src/stdio/ext.lo.go obj/src/stdio/ext2.lo.go obj/src/stdio/fclose.lo.go obj/src/stdio/feof.lo.go obj/src/stdio/ferror.lo.go obj/src/stdio/fflush.lo.go obj/src/stdio/fgetc.lo.go obj/src/stdio/fgetln.lo.go obj/src/stdio/fgetpos.lo.go obj/src/stdio/fgets.lo.go obj/src/stdio/fgetwc.lo.go obj/src/stdio/fgetws.lo.go obj/src/stdio/fileno.lo.go obj/src/stdio/flockfile.lo.go obj/src/stdio/fmemopen.lo.go obj/src/stdio/fopen.lo.go obj/src/stdio/fopencookie.lo.go obj/src/stdio/fprintf.lo.go obj/src/stdio/fputc.lo.go obj/src/stdio/fputs.lo.go obj/src/stdio/fputwc.lo.go obj/src/stdio/fputws.lo.go obj/src/stdio/fread.lo.go obj/src/stdio/freopen.lo.go obj/src/stdio/fscanf.lo.go obj/src/stdio/fseek.lo.go obj/src/stdio/fsetpos.lo.go obj/src/stdio/ftell.lo.go obj/src/stdio/ftrylockfile.lo.go obj/src/stdio/funlockfile.lo.go obj/src/stdio/fwide.lo.go obj/src/stdio/fwprintf.lo.go obj/src/stdio/fwrite.lo.go obj/src/stdio/fwscanf.lo.go obj/src/stdio/getc.lo.go obj/src/stdio/getc_unlocked.lo.go obj/src/stdio/getchar.lo.go obj/src/stdio/getchar_unlocked.lo.go obj/src/stdio/getdelim.lo.go obj/src/stdio/getline.lo.go obj/src/stdio/gets.lo.go obj/src/stdio/getw.lo.go obj/src/stdio/getwc.lo.go obj/src/stdio/getwchar.lo.go obj/src/stdio/ofl.lo.go obj/src/stdio/ofl_add.lo.go obj/src/stdio/open_memstream.lo.go obj/src/stdio/open_wmemstream.lo.go obj/src/stdio/pclose.lo.go obj/src/stdio/perror.lo.go obj/src/stdio/popen.lo.go obj/src/stdio/printf.lo.go obj/src/stdio/putc.lo.go obj/src/stdio/putc_unlocked.lo.go obj/src/stdio/putchar.lo.go obj/src/stdio/putchar_unlocked.lo.go obj/src/stdio/puts.lo.go obj/src/stdio/putw.lo.go obj/src/stdio/putwc.lo.go obj/src/stdio/putwchar.lo.go obj/src/stdio/remove.lo.go obj/src/stdio/rename.lo.go obj/src/stdio/rewind.lo.go obj/src/stdio/scanf.lo.go obj/src/stdio/setbuf.lo.go obj/src/stdio/setbuffer.lo.go obj/src/stdio/setlinebuf.lo.go obj/src/stdio/setvbuf.lo.go obj/src/stdio/snprintf.lo.go obj/src/stdio/sprintf.lo.go obj/src/stdio/sscanf.lo.go obj/src/stdio/stderr.lo.go obj/src/stdio/stdin.lo.go obj/src/stdio/stdout.lo.go obj/src/stdio/swprintf.lo.go obj/src/stdio/swscanf.lo.go obj/src/stdio/tempnam.lo.go obj/src/stdio/tmpfile.lo.go obj/src/stdio/tmpnam.lo.go obj/src/stdio/ungetc.lo.go obj/src/stdio/ungetwc.lo.go obj/src/stdio/vasprintf.lo.go obj/src/stdio/vdprintf.lo.go obj/src/stdio/vfprintf.lo.go obj/src/stdio/vfscanf.lo.go obj/src/stdio/vfwprintf.lo.go obj/src/stdio/vfwscanf.lo.go obj/src/stdio/vprintf.lo.go obj/src/stdio/vscanf.lo.go obj/src/stdio/vsnprintf.lo.go obj/src/stdio/vsprintf.lo.go obj/src/stdio/vsscanf.lo.go obj/src/stdio/vswprintf.lo.go obj/src/stdio/vswscanf.lo.go obj/src/stdio/vwprintf.lo.go obj/src/stdio/vwscanf.lo.go obj/src/stdio/wprintf.lo.go obj/src/stdio/wscanf.lo.go obj/src/stdlib/abs.lo.go obj/src/stdlib/atof.lo.go obj/src/stdlib/atoi.lo.go obj/src/stdlib/atol.lo.go obj/src/stdlib/atoll.lo.go obj/src/stdlib/bsearch.lo.go obj/src/stdlib/div.lo.go obj/src/stdlib/ecvt.lo.go obj/src/stdlib/fcvt.lo.go obj/src/stdlib/gcvt.lo.go obj/src/stdlib/imaxabs.lo.go obj/src/stdlib/imaxdiv.lo.go obj/src/stdlib/labs.lo.go obj/src/stdlib/ldiv.lo.go obj/src/stdlib/llabs.lo.go obj/src/stdlib/lldiv.lo.go obj/src/stdlib/qsort.lo.go obj/src/stdlib/qsort_nr.lo.go obj/src/stdlib/strtod.lo.go obj/src/stdlib/strtol.lo.go obj/src/stdlib/wcstod.lo.go obj/src/stdlib/wcstol.lo.go obj/src/string/bcmp.lo.go obj/src/string/bcopy.lo.go obj/src/string/bzero.lo.go obj/src/string/explicit_bzero.lo.go obj/src/string/index.lo.go obj/src/string/memccpy.lo.go obj/src/string/memchr.lo.go obj/src/string/memcmp.lo.go obj/src/string/memcpy.lo.go obj/src/string/memmem.lo.go obj/src/string/memmove.lo.go obj/src/string/mempcpy.lo.go obj/src/string/memrchr.lo.go obj/src/string/memset.lo.go obj/src/string/rindex.lo.go obj/src/string/stpcpy.lo.go obj/src/string/stpncpy.lo.go obj/src/string/strcasecmp.lo.go obj/src/string/strcasestr.lo.go obj/src/string/strcat.lo.go obj/src/string/strchr.lo.go obj/src/string/strchrnul.lo.go obj/src/string/strcmp.lo.go obj/src/string/strcpy.lo.go obj/src/string/strcspn.lo.go obj/src/string/strdup.lo.go obj/src/string/strerror_r.lo.go obj/src/string/strlcat.lo.go obj/src/string/strlcpy.lo.go obj/src/string/strlen.lo.go obj/src/string/strncasecmp.lo.go obj/src/string/strncat.lo.go obj/src/string/strncmp.lo.go obj/src/string/strncpy.lo.go obj/src/string/strndup.lo.go obj/src/string/strnlen.lo.go obj/src/string/strpbrk.lo.go obj/src/string/strrchr.lo.go obj/src/string/strsep.lo.go obj/src/string/strsignal.lo.go obj/src/string/strspn.lo.go obj/src/string/strstr.lo.go obj/src/string/strtok.lo.go obj/src/string/strtok_r.lo.go obj/src/string/strverscmp.lo.go obj/src/string/swab.lo.go obj/src/string/wcpcpy.lo.go obj/src/string/wcpncpy.lo.go obj/src/string/wcscasecmp.lo.go obj/src/string/wcscasecmp_l.lo.go obj/src/string/wcscat.lo.go obj/src/string/wcschr.lo.go obj/src/string/wcscmp.lo.go obj/src/string/wcscpy.lo.go obj/src/string/wcscspn.lo.go obj/src/string/wcsdup.lo.go obj/src/string/wcslen.lo.go obj/src/string/wcsncasecmp.lo.go obj/src/string/wcsncasecmp_l.lo.go obj/src/string/wcsncat.lo.go obj/src/string/wcsncmp.lo.go obj/src/string/wcsncpy.lo.go obj/src/string/wcsnlen.lo.go obj/src/string/wcspbrk.lo.go obj/src/string/wcsrchr.lo.go obj/src/string/wcsspn.lo.go obj/src/string/wcsstr.lo.go obj/src/string/wcstok.lo.go obj/src/string/wcswcs.lo.go obj/src/string/wmemchr.lo.go obj/src/string/wmemcmp.lo.go obj/src/string/wmemcpy.lo.go obj/src/string/wmemmove.lo.go obj/src/string/wmemset.lo.go obj/src/temp/__randname.lo.go obj/src/temp/mkdtemp.lo.go obj/src/temp/mkostemp.lo.go obj/src/temp/mkostemps.lo.go obj/src/temp/mkstemp.lo.go obj/src/temp/mkstemps.lo.go obj/src/temp/mktemp.lo.go obj/src/termios/cfgetospeed.lo.go obj/src/termios/cfmakeraw.lo.go obj/src/termios/cfsetospeed.lo.go obj/src/termios/tcdrain.lo.go obj/src/termios/tcflow.lo.go obj/src/termios/tcflush.lo.go obj/src/termios/tcgetattr.lo.go obj/src/termios/tcgetsid.lo.go obj/src/termios/tcgetwinsize.lo.go obj/src/termios/tcsendbreak.lo.go obj/src/termios/tcsetattr.lo.go obj/src/termios/tcsetwinsize.lo.go obj/src/thread/__lock.lo.go obj/src/thread/__syscall_cp.lo.go obj/src/thread/__timedwait.lo.go obj/src/thread/__tls_get_addr.lo.go obj/src/thread/__wait.lo.go obj/src/thread/call_once.lo.go obj/src/thread/cnd_broadcast.lo.go obj/src/thread/cnd_destroy.lo.go obj/src/thread/cnd_init.lo.go obj/src/thread/cnd_signal.lo.go obj/src/thread/cnd_timedwait.lo.go obj/src/thread/cnd_wait.lo.go obj/src/thread/default_attr.lo.go obj/src/thread/lock_ptc.lo.go obj/src/thread/mtx_destroy.lo.go obj/src/thread/mtx_init.lo.go obj/src/thread/mtx_lock.lo.go obj/src/thread/mtx_timedlock.lo.go obj/src/thread/mtx_trylock.lo.go obj/src/thread/mtx_unlock.lo.go obj/src/thread/pthread_atfork.lo.go obj/src/thread/pthread_attr_destroy.lo.go obj/src/thread/pthread_attr_get.lo.go obj/src/thread/pthread_attr_init.lo.go obj/src/thread/pthread_attr_setdetachstate.lo.go obj/src/thread/pthread_attr_setguardsize.lo.go obj/src/thread/pthread_attr_setinheritsched.lo.go obj/src/thread/pthread_attr_setschedparam.lo.go obj/src/thread/pthread_attr_setschedpolicy.lo.go obj/src/thread/pthread_attr_setscope.lo.go obj/src/thread/pthread_attr_setstack.lo.go obj/src/thread/pthread_attr_setstacksize.lo.go obj/src/thread/pthread_barrier_destroy.lo.go obj/src/thread/pthread_barrier_init.lo.go obj/src/thread/pthread_barrier_wait.lo.go obj/src/thread/pthread_barrierattr_destroy.lo.go obj/src/thread/pthread_barrierattr_init.lo.go obj/src/thread/pthread_barrierattr_setpshared.lo.go obj/src/thread/pthread_cancel.lo.go obj/src/thread/pthread_cleanup_push.lo.go obj/src/thread/pthread_cond_broadcast.lo.go obj/src/thread/pthread_cond_destroy.lo.go obj/src/thread/pthread_cond_init.lo.go obj/src/thread/pthread_cond_signal.lo.go obj/src/thread/pthread_cond_timedwait.lo.go obj/src/thread/pthread_cond_wait.lo.go obj/src/thread/pthread_condattr_destroy.lo.go obj/src/thread/pthread_condattr_init.lo.go obj/src/thread/pthread_condattr_setclock.lo.go obj/src/thread/pthread_condattr_setpshared.lo.go obj/src/thread/pthread_create.lo.go obj/src/thread/pthread_detach.lo.go obj/src/thread/pthread_equal.lo.go obj/src/thread/pthread_getattr_np.lo.go obj/src/thread/pthread_getconcurrency.lo.go obj/src/thread/pthread_getcpuclockid.lo.go obj/src/thread/pthread_getname_np.lo.go obj/src/thread/pthread_getschedparam.lo.go obj/src/thread/pthread_getspecific.lo.go obj/src/thread/pthread_join.lo.go obj/src/thread/pthread_key_create.lo.go obj/src/thread/pthread_kill.lo.go obj/src/thread/pthread_mutex_consistent.lo.go obj/src/thread/pthread_mutex_destroy.lo.go obj/src/thread/pthread_mutex_getprioceiling.lo.go obj/src/thread/pthread_mutex_init.lo.go obj/src/thread/pthread_mutex_lock.lo.go obj/src/thread/pthread_mutex_setprioceiling.lo.go obj/src/thread/pthread_mutex_timedlock.lo.go obj/src/thread/pthread_mutex_trylock.lo.go obj/src/thread/pthread_mutex_unlock.lo.go obj/src/thread/pthread_mutexattr_destroy.lo.go obj/src/thread/pthread_mutexattr_init.lo.go obj/src/thread/pthread_mutexattr_setprotocol.lo.go obj/src/thread/pthread_mutexattr_setpshared.lo.go obj/src/thread/pthread_mutexattr_setrobust.lo.go obj/src/thread/pthread_mutexattr_settype.lo.go obj/src/thread/pthread_once.lo.go obj/src/thread/pthread_rwlock_destroy.lo.go obj/src/thread/pthread_rwlock_init.lo.go obj/src/thread/pthread_rwlock_rdlock.lo.go obj/src/thread/pthread_rwlock_timedrdlock.lo.go obj/src/thread/pthread_rwlock_timedwrlock.lo.go obj/src/thread/pthread_rwlock_tryrdlock.lo.go obj/src/thread/pthread_rwlock_trywrlock.lo.go obj/src/thread/pthread_rwlock_unlock.lo.go obj/src/thread/pthread_rwlock_wrlock.lo.go obj/src/thread/pthread_rwlockattr_destroy.lo.go obj/src/thread/pthread_rwlockattr_init.lo.go obj/src/thread/pthread_rwlockattr_setpshared.lo.go obj/src/thread/pthread_self.lo.go obj/src/thread/pthread_setattr_default_np.lo.go obj/src/thread/pthread_setcancelstate.lo.go obj/src/thread/pthread_setcanceltype.lo.go obj/src/thread/pthread_setconcurrency.lo.go obj/src/thread/pthread_setname_np.lo.go obj/src/thread/pthread_setschedparam.lo.go obj/src/thread/pthread_setschedprio.lo.go obj/src/thread/pthread_setspecific.lo.go obj/src/thread/pthread_sigmask.lo.go obj/src/thread/pthread_spin_destroy.lo.go obj/src/thread/pthread_spin_init.lo.go obj/src/thread/pthread_spin_lock.lo.go obj/src/thread/pthread_spin_trylock.lo.go obj/src/thread/pthread_spin_unlock.lo.go obj/src/thread/pthread_testcancel.lo.go obj/src/thread/sem_destroy.lo.go obj/src/thread/sem_getvalue.lo.go obj/src/thread/sem_init.lo.go obj/src/thread/sem_open.lo.go obj/src/thread/sem_post.lo.go obj/src/thread/sem_timedwait.lo.go obj/src/thread/sem_trywait.lo.go obj/src/thread/sem_unlink.lo.go obj/src/thread/sem_wait.lo.go obj/src/thread/synccall.lo.go obj/src/thread/thrd_create.lo.go obj/src/thread/thrd_exit.lo.go obj/src/thread/thrd_join.lo.go obj/src/thread/thrd_sleep.lo.go obj/src/thread/thrd_yield.lo.go obj/src/thread/tls.lo.go obj/src/thread/tss_create.lo.go obj/src/thread/tss_delete.lo.go obj/src/thread/tss_set.lo.go obj/src/thread/vmlock.lo.go obj/src/time/__map_file.lo.go obj/src/time/__month_to_secs.lo.go obj/src/time/__secs_to_tm.lo.go obj/src/time/__tm_to_secs.lo.go obj/src/time/__tz.lo.go obj/src/time/__year_to_secs.lo.go obj/src/time/asctime.lo.go obj/src/time/asctime_r.lo.go obj/src/time/clock.lo.go obj/src/time/clock_getcpuclockid.lo.go obj/src/time/clock_getres.lo.go obj/src/time/clock_gettime.lo.go obj/src/time/clock_nanosleep.lo.go obj/src/time/clock_settime.lo.go obj/src/time/ctime.lo.go obj/src/time/ctime_r.lo.go obj/src/time/difftime.lo.go obj/src/time/ftime.lo.go obj/src/time/getdate.lo.go obj/src/time/gettimeofday.lo.go obj/src/time/gmtime.lo.go obj/src/time/gmtime_r.lo.go obj/src/time/localtime.lo.go obj/src/time/localtime_r.lo.go obj/src/time/mktime.lo.go obj/src/time/nanosleep.lo.go obj/src/time/strftime.lo.go obj/src/time/strptime.lo.go obj/src/time/time.lo.go obj/src/time/timegm.lo.go obj/src/time/timer_create.lo.go obj/src/time/timer_delete.lo.go obj/src/time/timer_getoverrun.lo.go obj/src/time/timer_gettime.lo.go obj/src/time/timer_settime.lo.go obj/src/time/times.lo.go obj/src/time/timespec_get.lo.go obj/src/time/utime.lo.go obj/src/time/wcsftime.lo.go obj/src/unistd/_exit.lo.go obj/src/unistd/access.lo.go obj/src/unistd/acct.lo.go obj/src/unistd/alarm.lo.go obj/src/unistd/chdir.lo.go obj/src/unistd/chown.lo.go obj/src/unistd/close.lo.go obj/src/unistd/ctermid.lo.go obj/src/unistd/dup.lo.go obj/src/unistd/dup2.lo.go obj/src/unistd/dup3.lo.go obj/src/unistd/faccessat.lo.go obj/src/unistd/fchdir.lo.go obj/src/unistd/fchown.lo.go obj/src/unistd/fchownat.lo.go obj/src/unistd/fdatasync.lo.go obj/src/unistd/fsync.lo.go obj/src/unistd/ftruncate.lo.go obj/src/unistd/getcwd.lo.go obj/src/unistd/getegid.lo.go obj/src/unistd/geteuid.lo.go obj/src/unistd/getgid.lo.go obj/src/unistd/getgroups.lo.go obj/src/unistd/gethostname.lo.go obj/src/unistd/getlogin.lo.go obj/src/unistd/getlogin_r.lo.go obj/src/unistd/getpgid.lo.go obj/src/unistd/getpgrp.lo.go obj/src/unistd/getpid.lo.go obj/src/unistd/getppid.lo.go obj/src/unistd/getsid.lo.go obj/src/unistd/getuid.lo.go obj/src/unistd/isatty.lo.go obj/src/unistd/lchown.lo.go obj/src/unistd/link.lo.go obj/src/unistd/linkat.lo.go obj/src/unistd/lseek.lo.go obj/src/unistd/nice.lo.go obj/src/unistd/pause.lo.go obj/src/unistd/pipe.lo.go obj/src/unistd/pipe2.lo.go obj/src/unistd/posix_close.lo.go obj/src/unistd/pread.lo.go obj/src/unistd/preadv.lo.go obj/src/unistd/pwrite.lo.go obj/src/unistd/pwritev.lo.go obj/src/unistd/read.lo.go obj/src/unistd/readlink.lo.go obj/src/unistd/readlinkat.lo.go obj/src/unistd/readv.lo.go obj/src/unistd/renameat.lo.go obj/src/unistd/rmdir.lo.go obj/src/unistd/setegid.lo.go obj/src/unistd/seteuid.lo.go obj/src/unistd/setgid.lo.go obj/src/unistd/setpgid.lo.go obj/src/unistd/setpgrp.lo.go obj/src/unistd/setregid.lo.go obj/src/unistd/setresgid.lo.go obj/src/unistd/setresuid.lo.go obj/src/unistd/setreuid.lo.go obj/src/unistd/setsid.lo.go obj/src/unistd/setuid.lo.go obj/src/unistd/setxid.lo.go obj/src/unistd/sleep.lo.go obj/src/unistd/symlink.lo.go obj/src/unistd/symlinkat.lo.go obj/src/unistd/sync.lo.go obj/src/unistd/tcgetpgrp.lo.go obj/src/unistd/tcsetpgrp.lo.go obj/src/unistd/truncate.lo.go obj/src/unistd/ttyname.lo.go obj/src/unistd/ttyname_r.lo.go obj/src/unistd/ualarm.lo.go obj/src/unistd/unlink.lo.go obj/src/unistd/unlinkat.lo.go obj/src/unistd/usleep.lo.go obj/src/unistd/write.lo.go obj/src/unistd/writev.lo.go obj/ldso/dlstart.lo.go obj/ldso/dynlink.lo.go', DO NOT EDIT..

//go:build linux && amd64
// +build linux,amd64

package libc

import (
	"reflect"
	"unsafe"

	. "modernc.org/libc/v2/rtl"
)

var (
	_ reflect.Type
	_ unsafe.Pointer
)

const m_AIO_ALLDONE = 2
const m_AIO_CANCELED = 0
const m_AT_MINSIGSTKSZ = 51
const m_EAGAIN = 11
const m_EBADF = 9
const m_ECANCELED = 125
const m_EINPROGRESS = 115
const m_EINVAL = 22
const m_ENOENT = 2
const m_ENOSYS = 38
const m_FUTEX_PRIVATE = 128
const m_F_GETFD = 1
const m_F_GETFL = 3
const m_INT_MAX = 2147483647
const m_LIO_READ = 0
const m_LIO_WRITE = 1
const m_O_APPEND = 1024
const m_O_DSYNC = 4096
const m_O_SYNC = 1052672
const m_PTHREAD_CREATE_DETACHED = 1
const m_SEEK_CUR = 1
const m_SIGEV_SIGNAL = 0
const m_SIGEV_THREAD = 2
const m_SIG_BLOCK = 0
const m_SIG_SETMASK = 2

type T__builtin_va_list = uintptr

type T__predefined_size_t = uint64

type T__predefined_wchar_t = int32

type T__predefined_ptrdiff_t = int64

type Tsize_t = uint64

type Ttime_t = int64

type Tclock_t = int64

type Ttimespec = struct {
	Ftv_sec  Ttime_t
	Ftv_nsec int64
}

type Tpid_t = int32

type Tuid_t = uint32

type Tpthread_t = uintptr

type T__pthread = struct {
	Fself          uintptr
	Fdtv           uintptr
	Fprev          uintptr
	Fnext          uintptr
	Fsysinfo       Tuintptr_t
	Fcanary        Tuintptr_t
	Ftid           int32
	Ferrno_val     int32
	Fdetach_state  int32
	Fcancel        int32
	Fcanceldisable uint8
	Fcancelasync   uint8
	F__ccgo66      uint8
	Fmap_base      uintptr
	Fmap_size      Tsize_t
	Fstack         uintptr
	Fstack_size    Tsize_t
	Fguard_size    Tsize_t
	Fresult        uintptr
	Fcancelbuf     uintptr
	Ftsd           uintptr
	Frobust_list   struct {
		Fhead    uintptr
		Foff     int64
		Fpending uintptr
	}
	Fh_errno_val int32
	Ftimer_id    int32
	Flocale      Tlocale_t
	Fkilllock    [1]int32
	Fdlerror_buf uintptr
	Fstdio_locks uintptr
}

type Tsigset_t = struct {
	F__bits [16]uint64
}

type T__sigset_t = Tsigset_t

type Tpthread_attr_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__s  [0][7]uint64
		F__i  [14]int32
	}
}

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  Tsize_t
}

type Tsigaltstack = Tstack_t

type Tmcontext_t = struct {
	F__space [32]uint64
}

type Tucontext_t = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

type T__ucontext = Tucontext_t

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
}

type Tsiginfo_t = struct {
	Fsi_signo    int32
	Fsi_errno    int32
	Fsi_code     int32
	F__si_fields struct {
		F__si_common [0]struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		}
		F__sigfault [0]struct {
			Fsi_addr     uintptr
			Fsi_addr_lsb int16
			F__first     struct {
				Fsi_pkey    [0]uint32
				F__addr_bnd struct {
					Fsi_lower uintptr
					Fsi_upper uintptr
				}
			}
		}
		F__sigpoll [0]struct {
			Fsi_band     int64
			Fsi_fd       int32
			F__ccgo_pad2 [4]byte
		}
		F__sigsys [0]struct {
			Fsi_call_addr uintptr
			Fsi_syscall   int32
			Fsi_arch      uint32
		}
		F__pad [112]int8
	}
}

type Tsigaction = struct {
	F__sa_handler struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	}
	Fsa_mask     Tsigset_t
	Fsa_flags    int32
	Fsa_restorer uintptr
}

type Tsigevent = struct {
	Fsigev_value  Tsigval
	Fsigev_signo  int32
	Fsigev_notify int32
	F__sev_fields struct {
		Fsigev_notify_thread_id [0]Tpid_t
		F__sev_thread           [0]struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		}
		F__pad [48]int8
	}
}

type Tsig_atomic_t = int32

type Ttimer_t = uintptr

type Tclockid_t = int32

type Tlocale_t = uintptr

type T__locale_struct = struct {
	Fcat [6]uintptr
}

type Ttm = struct {
	Ftm_sec      int32
	Ftm_min      int32
	Ftm_hour     int32
	Ftm_mday     int32
	Ftm_mon      int32
	Ftm_year     int32
	Ftm_wday     int32
	Ftm_yday     int32
	Ftm_isdst    int32
	F__tm_gmtoff int64
	F__tm_zone   uintptr
}

type Titimerspec = struct {
	Fit_interval Ttimespec
	Fit_value    Ttimespec
}

type Tssize_t = int64

type Toff_t = int64

type Taiocb = struct {
	Faio_fildes     int32
	Faio_lio_opcode int32
	Faio_reqprio    int32
	Faio_buf        uintptr
	Faio_nbytes     Tsize_t
	Faio_sigevent   Tsigevent
	F__td           uintptr
	F__lock         [2]int32
	F__err          int32
	F__ret          Tssize_t
	Faio_offset     Toff_t
	F__next         uintptr
	F__prev         uintptr
	F__dummy4       [16]int8
}

type Tpthread_once_t = int32

type Tpthread_key_t = uint32

type Tpthread_spinlock_t = int32

type Tpthread_mutexattr_t = struct {
	F__attr uint32
}

type Tpthread_condattr_t = struct {
	F__attr uint32
}

type Tpthread_barrierattr_t = struct {
	F__attr uint32
}

type Tpthread_rwlockattr_t = struct {
	F__attr [2]uint32
}

type Tpthread_mutex_t = struct {
	F__u struct {
		F__vi [0][10]int32
		F__p  [0][5]uintptr
		F__i  [10]int32
	}
}

type Tpthread_cond_t = struct {
	F__u struct {
		F__vi [0][12]int32
		F__p  [0][6]uintptr
		F__i  [12]int32
	}
}

type Tpthread_rwlock_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__p  [0][7]uintptr
		F__i  [14]int32
	}
}

type Tpthread_barrier_t = struct {
	F__u struct {
		F__vi [0][8]int32
		F__p  [0][4]uintptr
		F__i  [8]int32
	}
}

type Tsched_param = struct {
	Fsched_priority int32
	F__reserved1    int32
	F__reserved2    [2]struct {
		F__reserved1 Ttime_t
		F__reserved2 int64
	}
	F__reserved3 int32
	F__ccgo_pad4 [4]byte
}

type T__ptcb = struct {
	F__f    uintptr
	F__x    uintptr
	F__next uintptr
}

type Tmode_t = uint32

type Tflock = struct {
	Fl_type      int16
	Fl_whence    int16
	Fl_start     Toff_t
	Fl_len       Toff_t
	Fl_pid       Tpid_t
	F__ccgo_pad5 [4]byte
}

type Tsem_t = struct {
	F__val [8]int32
}

type Tintptr_t = int64

type Tgid_t = uint32

type Tuseconds_t = uint32

type Twchar_t = int32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tuintptr_t = uint64

type Tint8_t = int8

type Tint16_t = int16

type Tint32_t = int32

type Tint64_t = int64

type Tintmax_t = int64

type Tuint8_t = uint8

type Tuint16_t = uint16

type Tuint32_t = uint32

type Tuint64_t = uint64

type Tuintmax_t = uint64

type Tint_fast8_t = int8

type Tint_fast64_t = int64

type Tint_least8_t = int8

type Tint_least16_t = int16

type Tint_least32_t = int32

type Tint_least64_t = int64

type Tuint_fast8_t = uint8

type Tuint_fast64_t = uint64

type Tuint_least8_t = uint8

type Tuint_least16_t = uint16

type Tuint_least32_t = uint32

type Tuint_least64_t = uint64

type Tint_fast16_t = int32

type Tint_fast32_t = int32

type Tuint_fast16_t = uint32

type Tuint_fast32_t = uint32

type TElf32_Half = uint16

type TElf64_Half = uint16

type TElf32_Word = uint32

type TElf32_Sword = int32

type TElf64_Word = uint32

type TElf64_Sword = int32

type TElf32_Xword = uint64

type TElf32_Sxword = int64

type TElf64_Xword = uint64

type TElf64_Sxword = int64

type TElf32_Addr = uint32

type TElf64_Addr = uint64

type TElf32_Off = uint32

type TElf64_Off = uint64

type TElf32_Section = uint16

type TElf64_Section = uint16

type TElf32_Versym = uint16

type TElf64_Versym = uint16

type TElf32_Ehdr = struct {
	Fe_ident     [16]uint8
	Fe_type      TElf32_Half
	Fe_machine   TElf32_Half
	Fe_version   TElf32_Word
	Fe_entry     TElf32_Addr
	Fe_phoff     TElf32_Off
	Fe_shoff     TElf32_Off
	Fe_flags     TElf32_Word
	Fe_ehsize    TElf32_Half
	Fe_phentsize TElf32_Half
	Fe_phnum     TElf32_Half
	Fe_shentsize TElf32_Half
	Fe_shnum     TElf32_Half
	Fe_shstrndx  TElf32_Half
}

type TElf64_Ehdr = struct {
	Fe_ident     [16]uint8
	Fe_type      TElf64_Half
	Fe_machine   TElf64_Half
	Fe_version   TElf64_Word
	Fe_entry     TElf64_Addr
	Fe_phoff     TElf64_Off
	Fe_shoff     TElf64_Off
	Fe_flags     TElf64_Word
	Fe_ehsize    TElf64_Half
	Fe_phentsize TElf64_Half
	Fe_phnum     TElf64_Half
	Fe_shentsize TElf64_Half
	Fe_shnum     TElf64_Half
	Fe_shstrndx  TElf64_Half
}

type TElf32_Shdr = struct {
	Fsh_name      TElf32_Word
	Fsh_type      TElf32_Word
	Fsh_flags     TElf32_Word
	Fsh_addr      TElf32_Addr
	Fsh_offset    TElf32_Off
	Fsh_size      TElf32_Word
	Fsh_link      TElf32_Word
	Fsh_info      TElf32_Word
	Fsh_addralign TElf32_Word
	Fsh_entsize   TElf32_Word
}

type TElf64_Shdr = struct {
	Fsh_name      TElf64_Word
	Fsh_type      TElf64_Word
	Fsh_flags     TElf64_Xword
	Fsh_addr      TElf64_Addr
	Fsh_offset    TElf64_Off
	Fsh_size      TElf64_Xword
	Fsh_link      TElf64_Word
	Fsh_info      TElf64_Word
	Fsh_addralign TElf64_Xword
	Fsh_entsize   TElf64_Xword
}

type TElf32_Chdr = struct {
	Fch_type      TElf32_Word
	Fch_size      TElf32_Word
	Fch_addralign TElf32_Word
}

type TElf64_Chdr = struct {
	Fch_type      TElf64_Word
	Fch_reserved  TElf64_Word
	Fch_size      TElf64_Xword
	Fch_addralign TElf64_Xword
}

type TElf32_Sym = struct {
	Fst_name  TElf32_Word
	Fst_value TElf32_Addr
	Fst_size  TElf32_Word
	Fst_info  uint8
	Fst_other uint8
	Fst_shndx TElf32_Section
}

type TElf64_Sym = struct {
	Fst_name  TElf64_Word
	Fst_info  uint8
	Fst_other uint8
	Fst_shndx TElf64_Section
	Fst_value TElf64_Addr
	Fst_size  TElf64_Xword
}

type TElf32_Syminfo = struct {
	Fsi_boundto TElf32_Half
	Fsi_flags   TElf32_Half
}

type TElf64_Syminfo = struct {
	Fsi_boundto TElf64_Half
	Fsi_flags   TElf64_Half
}

type TElf32_Rel = struct {
	Fr_offset TElf32_Addr
	Fr_info   TElf32_Word
}

type TElf64_Rel = struct {
	Fr_offset TElf64_Addr
	Fr_info   TElf64_Xword
}

type TElf32_Rela = struct {
	Fr_offset TElf32_Addr
	Fr_info   TElf32_Word
	Fr_addend TElf32_Sword
}

type TElf64_Rela = struct {
	Fr_offset TElf64_Addr
	Fr_info   TElf64_Xword
	Fr_addend TElf64_Sxword
}

type TElf32_Phdr = struct {
	Fp_type   TElf32_Word
	Fp_offset TElf32_Off
	Fp_vaddr  TElf32_Addr
	Fp_paddr  TElf32_Addr
	Fp_filesz TElf32_Word
	Fp_memsz  TElf32_Word
	Fp_flags  TElf32_Word
	Fp_align  TElf32_Word
}

type TElf64_Phdr = struct {
	Fp_type   TElf64_Word
	Fp_flags  TElf64_Word
	Fp_offset TElf64_Off
	Fp_vaddr  TElf64_Addr
	Fp_paddr  TElf64_Addr
	Fp_filesz TElf64_Xword
	Fp_memsz  TElf64_Xword
	Fp_align  TElf64_Xword
}

type TElf32_Dyn = struct {
	Fd_tag TElf32_Sword
	Fd_un  struct {
		Fd_ptr [0]TElf32_Addr
		Fd_val TElf32_Word
	}
}

type TElf64_Dyn = struct {
	Fd_tag TElf64_Sxword
	Fd_un  struct {
		Fd_ptr [0]TElf64_Addr
		Fd_val TElf64_Xword
	}
}

type TElf32_Verdef = struct {
	Fvd_version TElf32_Half
	Fvd_flags   TElf32_Half
	Fvd_ndx     TElf32_Half
	Fvd_cnt     TElf32_Half
	Fvd_hash    TElf32_Word
	Fvd_aux     TElf32_Word
	Fvd_next    TElf32_Word
}

type TElf64_Verdef = struct {
	Fvd_version TElf64_Half
	Fvd_flags   TElf64_Half
	Fvd_ndx     TElf64_Half
	Fvd_cnt     TElf64_Half
	Fvd_hash    TElf64_Word
	Fvd_aux     TElf64_Word
	Fvd_next    TElf64_Word
}

type TElf32_Verdaux = struct {
	Fvda_name TElf32_Word
	Fvda_next TElf32_Word
}

type TElf64_Verdaux = struct {
	Fvda_name TElf64_Word
	Fvda_next TElf64_Word
}

type TElf32_Verneed = struct {
	Fvn_version TElf32_Half
	Fvn_cnt     TElf32_Half
	Fvn_file    TElf32_Word
	Fvn_aux     TElf32_Word
	Fvn_next    TElf32_Word
}

type TElf64_Verneed = struct {
	Fvn_version TElf64_Half
	Fvn_cnt     TElf64_Half
	Fvn_file    TElf64_Word
	Fvn_aux     TElf64_Word
	Fvn_next    TElf64_Word
}

type TElf32_Vernaux = struct {
	Fvna_hash  TElf32_Word
	Fvna_flags TElf32_Half
	Fvna_other TElf32_Half
	Fvna_name  TElf32_Word
	Fvna_next  TElf32_Word
}

type TElf64_Vernaux = struct {
	Fvna_hash  TElf64_Word
	Fvna_flags TElf64_Half
	Fvna_other TElf64_Half
	Fvna_name  TElf64_Word
	Fvna_next  TElf64_Word
}

type TElf32_auxv_t = struct {
	Fa_type Tuint32_t
	Fa_un   struct {
		Fa_val Tuint32_t
	}
}

type TElf64_auxv_t = struct {
	Fa_type Tuint64_t
	Fa_un   struct {
		Fa_val Tuint64_t
	}
}

type TElf32_Nhdr = struct {
	Fn_namesz TElf32_Word
	Fn_descsz TElf32_Word
	Fn_type   TElf32_Word
}

type TElf64_Nhdr = struct {
	Fn_namesz TElf64_Word
	Fn_descsz TElf64_Word
	Fn_type   TElf64_Word
}

type TElf32_Move = struct {
	Fm_value     TElf32_Xword
	Fm_info      TElf32_Word
	Fm_poffset   TElf32_Word
	Fm_repeat    TElf32_Half
	Fm_stride    TElf32_Half
	F__ccgo_pad5 [4]byte
}

type TElf64_Move = struct {
	Fm_value     TElf64_Xword
	Fm_info      TElf64_Xword
	Fm_poffset   TElf64_Xword
	Fm_repeat    TElf64_Half
	Fm_stride    TElf64_Half
	F__ccgo_pad5 [4]byte
}

type TElf32_gptab = struct {
	Fgt_entry [0]struct {
		Fgt_g_value TElf32_Word
		Fgt_bytes   TElf32_Word
	}
	Fgt_header struct {
		Fgt_current_g_value TElf32_Word
		Fgt_unused          TElf32_Word
	}
}

type TElf32_RegInfo = struct {
	Fri_gprmask  TElf32_Word
	Fri_cprmask  [4]TElf32_Word
	Fri_gp_value TElf32_Sword
}

type TElf_Options = struct {
	Fkind    uint8
	Fsize    uint8
	Fsection TElf32_Section
	Finfo    TElf32_Word
}

type TElf_Options_Hw = struct {
	Fhwp_flags1 TElf32_Word
	Fhwp_flags2 TElf32_Word
}

type TElf32_Lib = struct {
	Fl_name       TElf32_Word
	Fl_time_stamp TElf32_Word
	Fl_checksum   TElf32_Word
	Fl_version    TElf32_Word
	Fl_flags      TElf32_Word
}

type TElf64_Lib = struct {
	Fl_name       TElf64_Word
	Fl_time_stamp TElf64_Word
	Fl_checksum   TElf64_Word
	Fl_version    TElf64_Word
	Fl_flags      TElf64_Word
}

type TElf32_Conflict = uint32

type TElf_MIPS_ABIFlags_v0 = struct {
	Fversion   TElf32_Half
	Fisa_level uint8
	Fisa_rev   uint8
	Fgpr_size  uint8
	Fcpr1_size uint8
	Fcpr2_size uint8
	Ffp_abi    uint8
	Fisa_ext   TElf32_Word
	Fases      TElf32_Word
	Fflags1    TElf32_Word
	Fflags2    TElf32_Word
}

const _Val_GNU_MIPS_ABI_FP_ANY = 0
const _Val_GNU_MIPS_ABI_FP_DOUBLE = 1
const _Val_GNU_MIPS_ABI_FP_SINGLE = 2
const _Val_GNU_MIPS_ABI_FP_SOFT = 3
const _Val_GNU_MIPS_ABI_FP_OLD_64 = 4
const _Val_GNU_MIPS_ABI_FP_XX = 5
const _Val_GNU_MIPS_ABI_FP_64 = 6
const _Val_GNU_MIPS_ABI_FP_64A = 7
const _Val_GNU_MIPS_ABI_FP_MAX = 7

type Tsyscall_arg_t = int64

type Tva_list = uintptr

type T__isoc_va_list = uintptr

type Tfpos_t = struct {
	F__lldata [0]int64
	F__align  [0]float64
	F__opaque [16]int8
}

type T_G_fpos64_t = Tfpos_t

type Ttls_module = struct {
	Fnext   uintptr
	Fimage  uintptr
	Flen1   Tsize_t
	Fsize   Tsize_t
	Falign  Tsize_t
	Foffset Tsize_t
}

type T__libc = struct {
	Fcan_do_threads  int8
	Fthreaded        int8
	Fsecure          int8
	Fneed_locks      int8
	Fthreads_minus_1 int32
	Fauxv            uintptr
	Ftls_head        uintptr
	Ftls_size        Tsize_t
	Ftls_align       Tsize_t
	Ftls_cnt         Tsize_t
	Fpage_size       Tsize_t
	Fglobal_locale   T__locale_struct
}

const _DT_EXITED = 0
const _DT_EXITING = 1
const _DT_JOINABLE = 2
const _DT_DETACHED = 3

/* The following is a threads-based implementation of AIO with minimal
 * dependence on implementation details. Most synchronization is
 * performed with pthread primitives, but atomics and futex operations
 * are used for notification in a couple places where the pthread
 * primitives would be inefficient or impractical.
 *
 * For each fd with outstanding aio operations, an aio_queue structure
 * is maintained. These are reference-counted and destroyed by the last
 * aio worker thread to exit. Accessing any member of the aio_queue
 * structure requires a lock on the aio_queue. Adding and removing aio
 * queues themselves requires a write lock on the global map object,
 * a 4-level table mapping file descriptor numbers to aio queues. A
 * read lock on the map is used to obtain locks on existing queues by
 * excluding destruction of the queue by a different thread while it is
 * being locked.
 *
 * Each aio queue has a list of active threads/operations. Presently there
 * is a one to one relationship between threads and operations. The only
 * members of the aio_thread structure which are accessed by other threads
 * are the linked list pointers, op (which is immutable), running (which
 * is updated atomically), and err (which is synchronized via running),
 * so no locking is necessary. Most of the other other members are used
 * for sharing data between the main flow of execution and cancellation
 * cleanup handler.
 *
 * Taking any aio locks requires having all signals blocked. This is
 * necessary because aio_cancel is needed by close, and close is required
 * to be async-signal safe. All aio worker threads run with all signals
 * blocked permanently.
 */

type Taio_thread = struct {
	Ftd      Tpthread_t
	Fcb      uintptr
	Fnext    uintptr
	Fprev    uintptr
	Fq       uintptr
	Frunning int32
	Ferr     int32
	Fop      int32
	Fret     Tssize_t
}

type Taio_queue = struct {
	Ffd       int32
	Fseekable int32
	Fappend1  int32
	Fref      int32
	Finit1    int32
	Flock     Tpthread_mutex_t
	Fcond     Tpthread_cond_t
	Fhead     uintptr
}

type Taio_args = struct {
	Fcb          uintptr
	Fq           uintptr
	Fop          int32
	Fsem         Tsem_t
	F__ccgo_pad4 [4]byte
}

var _maplock = Tpthread_rwlock_t{}
var _map uintptr
var _aio_fd_cnt int32

var _io_thread_stack_size Tsize_t

func ___aio_get_queue(tls *TLS, fd int32, need int32) (r uintptr) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var a int32
	var b uint8
	var c uint8
	var d uint8
	var masked int32
	var q uintptr
	var val uint64
	var _ /* allmask at bp+0 */ Tsigset_t
	var _ /* origmask at bp+128 */ Tsigset_t
	var v1 uintptr
	var v2 bool
	var v3 uint64
	var v4 uintptr
	var v5 uintptr
	masked = int32(0)
	if fd < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EBADF)
		return uintptr(0)
	}
	a = fd >> int32(24)
	b = uint8(fd >> int32(16))
	c = uint8(fd >> int32(8))
	d = uint8(fd)
	q = uintptr(0)
	x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_maplock)))
	if v2 = !(_map != 0) || !(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) != 0) || !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) != 0) || !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) != 0); !v2 {
		v1 = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) + uintptr(d)*8))
		q = v1
	}
	if (v2 || !(v1 != 0)) && need != 0 {
		x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_maplock)))
		if x_fcntl(tls, fd, int32(m_F_GETFD), 0) < int32(0) {
			return uintptr(0)
		}
		x_sigfillset(tls, bp)
		masked = int32(1)
		x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp, bp+128)
		x___pthread_rwlock_wrlock(tls, uintptr(unsafe.Pointer(&_maplock)))
		if !(_io_thread_stack_size != 0) {
			val = x___getauxval(tls, uint64(m_AT_MINSIGSTKSZ))
			if uint64(Int32FromInt32(2048)+Int32FromInt32(2048)) > val+uint64(512) {
				v3 = uint64(Int32FromInt32(2048) + Int32FromInt32(2048))
			} else {
				v3 = val + uint64(512)
			}
			_io_thread_stack_size = v3
		}
		if !(_map != 0) {
			_map = x___libc_calloc(tls, uint64(8), uint64((-Uint32FromUint32(1)/Uint32FromInt32(2)+Uint32FromInt32(1))>>Int32FromInt32(24)))
		}
		if !(_map != 0) {
			goto out
		}
		if !(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) != 0) {
			*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) = x___libc_calloc(tls, uint64(8), uint64(256))
		}
		if !(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) != 0) {
			goto out
		}
		if !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) != 0) {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) = x___libc_calloc(tls, uint64(8), uint64(256))
		}
		if !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) != 0) {
			goto out
		}
		if !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) != 0) {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) = x___libc_calloc(tls, uint64(8), uint64(256))
		}
		if !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) != 0) {
			goto out
		}
		v4 = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) + uintptr(d)*8))
		q = v4
		if !(v4 != 0) {
			v5 = x___libc_calloc(tls, uint64(120), uint64(1))
			q = v5
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) + uintptr(d)*8)) = v5
			if q != 0 {
				(*Taio_queue)(unsafe.Pointer(q)).Ffd = fd
				x_pthread_mutex_init(tls, q+24, uintptr(0))
				x_pthread_cond_init(tls, q+64, uintptr(0))
				_a_inc(tls, uintptr(unsafe.Pointer(&_aio_fd_cnt)))
			}
		}
	}
	if q != 0 {
		x___pthread_mutex_lock(tls, q+24)
	}
out:
	x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_maplock)))
	if masked != 0 {
		x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+128, uintptr(0))
	}
	return q
}

func ___aio_unref_queue(tls *TLS, q uintptr) {
	var a int32
	var b uint8
	var c uint8
	var d uint8
	var fd int32
	if (*Taio_queue)(unsafe.Pointer(q)).Fref > int32(1) {
		(*Taio_queue)(unsafe.Pointer(q)).Fref--
		x___pthread_mutex_unlock(tls, q+24)
		return
	}
	/* This is potentially the last reference, but a new reference
	 * may arrive since we cannot free the queue object without first
	 * taking the maplock, which requires releasing the queue lock. */
	x___pthread_mutex_unlock(tls, q+24)
	x___pthread_rwlock_wrlock(tls, uintptr(unsafe.Pointer(&_maplock)))
	x___pthread_mutex_lock(tls, q+24)
	if (*Taio_queue)(unsafe.Pointer(q)).Fref == int32(1) {
		fd = (*Taio_queue)(unsafe.Pointer(q)).Ffd
		a = fd >> int32(24)
		b = uint8(fd >> int32(16))
		c = uint8(fd >> int32(8))
		d = uint8(fd)
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) + uintptr(d)*8)) = uintptr(0)
		_a_dec(tls, uintptr(unsafe.Pointer(&_aio_fd_cnt)))
		x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_maplock)))
		x___pthread_mutex_unlock(tls, q+24)
		x___libc_free(tls, q)
	} else {
		(*Taio_queue)(unsafe.Pointer(q)).Fref--
		x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_maplock)))
		x___pthread_mutex_unlock(tls, q+24)
	}
}

func _cleanup(tls *TLS, ctx uintptr) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var at uintptr
	var cb uintptr
	var q uintptr
	var sev Tsigevent
	var _ /* si at bp+0 */ Tsiginfo_t
	at = ctx
	q = (*Taio_thread)(unsafe.Pointer(at)).Fq
	cb = (*Taio_thread)(unsafe.Pointer(at)).Fcb
	sev = (*Taiocb)(unsafe.Pointer(cb)).Faio_sigevent
	/* There are four potential types of waiters we could need to wake:
	 *   1. Callers of aio_cancel/close.
	 *   2. Callers of aio_suspend with a single aiocb.
	 *   3. Callers of aio_suspend with a list.
	 *   4. AIO worker threads waiting for sequenced operations.
	 * Types 1-3 are notified via atomics/futexes, mainly for AS-safety
	 * considerations. Type 4 is notified later via a cond var. */
	(*Taiocb)(unsafe.Pointer(cb)).F__ret = (*Taio_thread)(unsafe.Pointer(at)).Fret
	if _a_swap(tls, at+40, int32(0)) < int32(0) {
		___wake(tls, at+40, -int32(1), int32(1))
	}
	if _a_swap(tls, cb+112, (*Taio_thread)(unsafe.Pointer(at)).Ferr) != int32(m_EINPROGRESS) {
		___wake(tls, cb+112, -int32(1), int32(1))
	}
	if _a_swap(tls, uintptr(unsafe.Pointer(&x___aio_fut)), int32(0)) != 0 {
		___wake(tls, uintptr(unsafe.Pointer(&x___aio_fut)), -int32(1), int32(1))
	}
	x___pthread_mutex_lock(tls, q+24)
	if (*Taio_thread)(unsafe.Pointer(at)).Fnext != 0 {
		(*Taio_thread)(unsafe.Pointer((*Taio_thread)(unsafe.Pointer(at)).Fnext)).Fprev = (*Taio_thread)(unsafe.Pointer(at)).Fprev
	}
	if (*Taio_thread)(unsafe.Pointer(at)).Fprev != 0 {
		(*Taio_thread)(unsafe.Pointer((*Taio_thread)(unsafe.Pointer(at)).Fprev)).Fnext = (*Taio_thread)(unsafe.Pointer(at)).Fnext
	} else {
		(*Taio_queue)(unsafe.Pointer(q)).Fhead = (*Taio_thread)(unsafe.Pointer(at)).Fnext
	}
	/* Signal aio worker threads waiting for sequenced operations. */
	x_pthread_cond_broadcast(tls, q+64)
	___aio_unref_queue(tls, q)
	if sev.Fsigev_notify == int32(m_SIGEV_SIGNAL) {
		*(*Tsiginfo_t)(unsafe.Pointer(bp)) = Tsiginfo_t{Fsi_signo: sev.Fsigev_signo, Fsi_code: -int32(4), F__si_fields: *(*struct {
			F__si_common [0]struct {
				F__first struct {
					F__timer [0]struct {
						Fsi_timerid int32
						Fsi_overrun int32
					}
					F__piduid struct {
						Fsi_pid Tpid_t
						Fsi_uid Tuid_t
					}
				}
				F__second struct {
					F__sigchld [0]struct {
						Fsi_status int32
						Fsi_utime  Tclock_t
						Fsi_stime  Tclock_t
					}
					Fsi_value    Tsigval
					F__ccgo_pad2 [16]byte
				}
			}
			F__sigfault [0]struct {
				Fsi_addr     uintptr
				Fsi_addr_lsb int16
				F__first     struct {
					Fsi_pkey    [0]uint32
					F__addr_bnd struct {
						Fsi_lower uintptr
						Fsi_upper uintptr
					}
				}
			}
			F__sigpoll [0]struct {
				Fsi_band     int64
				Fsi_fd       int32
				F__ccgo_pad2 [4]byte
			}
			F__sigsys [0]struct {
				Fsi_call_addr uintptr
				Fsi_syscall   int32
				Fsi_arch      uint32
			}
			F__pad [112]int8
		})(unsafe.Pointer(&struct {
			f struct {
				F__first struct {
					F__timer [0]struct {
						Fsi_timerid int32
						Fsi_overrun int32
					}
					F__piduid struct {
						Fsi_pid Tpid_t
						Fsi_uid Tuid_t
					}
				}
				F__second struct {
					F__sigchld [0]struct {
						Fsi_status int32
						Fsi_utime  Tclock_t
						Fsi_stime  Tclock_t
					}
					Fsi_value    Tsigval
					F__ccgo_pad2 [16]byte
				}
			}
			_ [80]byte
		}{f: struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		}{F__first: *(*struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		})(unsafe.Pointer(&struct {
			Fsi_pid Tpid_t
			Fsi_uid Tuid_t
		}{Fsi_pid: x_getpid(tls), Fsi_uid: x_getuid(tls)})), F__second: struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}{Fsi_value: sev.Fsigev_value}}}))}
		___syscall3(tls, int64(129), int64((*(*struct {
			Fsi_pid Tpid_t
			Fsi_uid Tuid_t
		})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		})(unsafe.Pointer(&(*(*Tsiginfo_t)(unsafe.Pointer(bp))).F__si_fields))).F__first))))).Fsi_pid), int64((*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo), int64(bp))
	}
	if sev.Fsigev_notify == int32(m_SIGEV_THREAD) {
		_a_store(tls, ___get_tp(tls)+60, int32(0))
		(*(*func(*TLS, Tsigval))(unsafe.Pointer(&struct{ uintptr }{(*(*struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		})(unsafe.Pointer(&sev.F__sev_fields))).Fsigev_notify_function})))(tls, sev.Fsigev_value)
	}
}

func _io_thread_func(tls *TLS, ctx uintptr) (r uintptr) {
	bp := tls.Alloc(88) /* tlsAllocs 88 maxValist 0 */
	defer tls.Free(88)
	var args uintptr
	var buf uintptr
	var cb uintptr
	var fd int32
	var len1 Tsize_t
	var off Toff_t
	var op int32
	var p uintptr
	var q uintptr
	var ret Tssize_t
	var seekable int32
	var _ /* __cb at bp+64 */ T__ptcb
	var _ /* at at bp+0 */ Taio_thread
	var v1 uintptr
	var v2 int64
	var v3 int64
	var v4 int32
	args = ctx
	cb = (*Taio_args)(unsafe.Pointer(args)).Fcb
	fd = (*Taiocb)(unsafe.Pointer(cb)).Faio_fildes
	op = (*Taio_args)(unsafe.Pointer(args)).Fop
	buf = (*Taiocb)(unsafe.Pointer(cb)).Faio_buf
	len1 = (*Taiocb)(unsafe.Pointer(cb)).Faio_nbytes
	off = (*Taiocb)(unsafe.Pointer(cb)).Faio_offset
	q = (*Taio_args)(unsafe.Pointer(args)).Fq
	x___pthread_mutex_lock(tls, q+24)
	x_sem_post(tls, args+20)
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fop = op
	(*(*Taio_thread)(unsafe.Pointer(bp))).Frunning = int32(1)
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fret = int64(-int32(1))
	(*(*Taio_thread)(unsafe.Pointer(bp))).Ferr = int32(m_ECANCELED)
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fq = q
	(*(*Taio_thread)(unsafe.Pointer(bp))).Ftd = ___get_tp(tls)
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fcb = cb
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fprev = uintptr(0)
	v1 = (*Taio_queue)(unsafe.Pointer(q)).Fhead
	(*(*Taio_thread)(unsafe.Pointer(bp))).Fnext = v1
	if v1 != 0 {
		(*Taio_thread)(unsafe.Pointer((*(*Taio_thread)(unsafe.Pointer(bp))).Fnext)).Fprev = bp
	}
	(*Taio_queue)(unsafe.Pointer(q)).Fhead = bp
	if !((*Taio_queue)(unsafe.Pointer(q)).Finit1 != 0) {
		seekable = BoolInt32(x___lseek(tls, fd, int64(0), int32(m_SEEK_CUR)) >= int64(0))
		(*Taio_queue)(unsafe.Pointer(q)).Fseekable = seekable
		(*Taio_queue)(unsafe.Pointer(q)).Fappend1 = BoolInt32(!(seekable != 0) || x_fcntl(tls, fd, int32(m_F_GETFL), 0)&int32(m_O_APPEND) != 0)
		(*Taio_queue)(unsafe.Pointer(q)).Finit1 = int32(1)
	}
	{
		x__pthread_cleanup_push(tls, bp+64, __ccgo_fp(_cleanup), bp)
		/* Wait for sequenced operations. */
		if op != int32(m_LIO_READ) && (op != int32(m_LIO_WRITE) || (*Taio_queue)(unsafe.Pointer(q)).Fappend1 != 0) {
			for {
				for p = (*(*Taio_thread)(unsafe.Pointer(bp))).Fnext; p != 0 && (*Taio_thread)(unsafe.Pointer(p)).Fop != int32(m_LIO_WRITE); p = (*Taio_thread)(unsafe.Pointer(p)).Fnext {
				}
				if !(p != 0) {
					break
				}
				x_pthread_cond_wait(tls, q+64, q+24)
			}
		}
		x___pthread_mutex_unlock(tls, q+24)
		switch op {
		case int32(m_LIO_WRITE):
			if (*Taio_queue)(unsafe.Pointer(q)).Fappend1 != 0 {
				v2 = x_write(tls, fd, buf, len1)
			} else {
				v2 = x_pwrite(tls, fd, buf, len1, off)
			}
			ret = v2
		case int32(m_LIO_READ):
			if !((*Taio_queue)(unsafe.Pointer(q)).Fseekable != 0) {
				v3 = x_read(tls, fd, buf, len1)
			} else {
				v3 = x_pread(tls, fd, buf, len1, off)
			}
			ret = v3
		case int32(m_O_SYNC):
			ret = int64(x_fsync(tls, fd))
		case int32(m_O_DSYNC):
			ret = int64(x_fdatasync(tls, fd))
			break
		}
		(*(*Taio_thread)(unsafe.Pointer(bp))).Fret = ret
		if ret < int64(0) {
			v4 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		} else {
			v4 = int32(0)
		}
		(*(*Taio_thread)(unsafe.Pointer(bp))).Ferr = v4
		x__pthread_cleanup_pop(tls, bp+64, int32(1))
	}
	return uintptr(0)
}

func _submit(tls *TLS, cb uintptr, op int32) (r int32) {
	bp := tls.Alloc(376) /* tlsAllocs 376 maxValist 0 */
	defer tls.Free(376)
	var q uintptr
	var ret int32
	var _ /* a at bp+0 */ Tpthread_attr_t
	var _ /* allmask at bp+56 */ Tsigset_t
	var _ /* args at bp+320 */ Taio_args
	var _ /* origmask at bp+184 */ Tsigset_t
	var _ /* td at bp+312 */ Tpthread_t
	var v1 int32
	var v2 int32
	ret = int32(0)
	q = ___aio_get_queue(tls, (*Taiocb)(unsafe.Pointer(cb)).Faio_fildes, int32(1))
	*(*Taio_args)(unsafe.Pointer(bp + 320)) = Taio_args{Fcb: cb, Fq: q, Fop: op}
	x_sem_init(tls, uintptr(unsafe.Pointer(&(*(*Taio_args)(unsafe.Pointer(bp + 320))).Fsem)), int32(0), uint32(0))
	if !(q != 0) {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EBADF) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
		}
		(*Taiocb)(unsafe.Pointer(cb)).F__ret = int64(-int32(1))
		(*Taiocb)(unsafe.Pointer(cb)).F__err = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		return -int32(1)
	}
	(*Taio_queue)(unsafe.Pointer(q)).Fref++
	x___pthread_mutex_unlock(tls, q+24)
	if (*Taiocb)(unsafe.Pointer(cb)).Faio_sigevent.Fsigev_notify == int32(m_SIGEV_THREAD) {
		if (*(*struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		})(unsafe.Pointer(&(*Taiocb)(unsafe.Pointer(cb)).Faio_sigevent.F__sev_fields))).Fsigev_notify_attributes != 0 {
			*(*Tpthread_attr_t)(unsafe.Pointer(bp)) = *(*Tpthread_attr_t)(unsafe.Pointer((*(*struct {
				Fsigev_notify_function   uintptr
				Fsigev_notify_attributes uintptr
			})(unsafe.Pointer(&(*Taiocb)(unsafe.Pointer(cb)).Faio_sigevent.F__sev_fields))).Fsigev_notify_attributes))
		} else {
			x_pthread_attr_init(tls, bp)
		}
	} else {
		x_pthread_attr_init(tls, bp)
		x_pthread_attr_setstacksize(tls, bp, _io_thread_stack_size)
		x_pthread_attr_setguardsize(tls, bp, uint64(0))
	}
	x_pthread_attr_setdetachstate(tls, bp, int32(m_PTHREAD_CREATE_DETACHED))
	x_sigfillset(tls, bp+56)
	x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp+56, bp+184)
	(*Taiocb)(unsafe.Pointer(cb)).F__err = int32(m_EINPROGRESS)
	if x___pthread_create(tls, bp+312, bp, __ccgo_fp(_io_thread_func), bp+320) != 0 {
		x___pthread_mutex_lock(tls, q+24)
		___aio_unref_queue(tls, q)
		v1 = Int32FromInt32(m_EAGAIN)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v1
		(*Taiocb)(unsafe.Pointer(cb)).F__err = v1
		v2 = -Int32FromInt32(1)
		ret = v2
		(*Taiocb)(unsafe.Pointer(cb)).F__ret = int64(v2)
	}
	x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+184, uintptr(0))
	if !(ret != 0) {
		for x_sem_wait(tls, uintptr(unsafe.Pointer(&(*(*Taio_args)(unsafe.Pointer(bp + 320))).Fsem))) != 0 {
		}
	}
	return ret
}

func x_aio_read(tls *TLS, cb uintptr) (r int32) {
	return _submit(tls, cb, int32(m_LIO_READ))
}

func x_aio_write(tls *TLS, cb uintptr) (r int32) {
	return _submit(tls, cb, int32(m_LIO_WRITE))
}

func x_aio_fsync(tls *TLS, op int32, cb uintptr) (r int32) {
	if op != int32(m_O_SYNC) && op != int32(m_O_DSYNC) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return _submit(tls, cb, op)
}

func x_aio_return(tls *TLS, cb uintptr) (r Tssize_t) {
	return (*Taiocb)(unsafe.Pointer(cb)).F__ret
}

func x_aio_error(tls *TLS, cb uintptr) (r int32) {
	_a_barrier(tls)
	return (*Taiocb)(unsafe.Pointer(cb)).F__err & int32(0x7fffffff)
}

func x_aio_cancel(tls *TLS, fd int32, cb uintptr) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var p uintptr
	var q uintptr
	var ret int32
	var _ /* allmask at bp+0 */ Tsigset_t
	var _ /* origmask at bp+128 */ Tsigset_t
	var v1 uintptr
	ret = int32(m_AIO_ALLDONE)
	/* Unspecified behavior case. Report an error. */
	if cb != 0 && fd != (*Taiocb)(unsafe.Pointer(cb)).Faio_fildes {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	x_sigfillset(tls, bp)
	x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp, bp+128)
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
	v1 = ___aio_get_queue(tls, fd, int32(0))
	q = v1
	if !(v1 != 0) {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EBADF) {
			ret = -int32(1)
		}
		goto done
	}
	for p = (*Taio_queue)(unsafe.Pointer(q)).Fhead; p != 0; p = (*Taio_thread)(unsafe.Pointer(p)).Fnext {
		if cb != 0 && cb != (*Taio_thread)(unsafe.Pointer(p)).Fcb {
			continue
		}
		/* Transition target from running to running-with-waiters */
		if _a_cas(tls, p+40, int32(1), -int32(1)) != 0 {
			x_pthread_cancel(tls, (*Taio_thread)(unsafe.Pointer(p)).Ftd)
			x___wait(tls, p+40, uintptr(0), -int32(1), int32(1))
			if (*Taio_thread)(unsafe.Pointer(p)).Ferr == int32(m_ECANCELED) {
				ret = int32(m_AIO_CANCELED)
			}
		}
	}
	x___pthread_mutex_unlock(tls, q+24)
done:
	x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+128, uintptr(0))
	return ret
}

func x___aio_close(tls *TLS, fd int32) (r int32) {
	_a_barrier(tls)
	if _aio_fd_cnt != 0 {
		x_aio_cancel(tls, fd, uintptr(0))
	}
	return fd
}

func x___aio_atfork(tls *TLS, who int32) {
	var a int32
	var b int32
	var c int32
	var d int32
	if who < int32(0) {
		x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_maplock)))
		return
	} else {
		if !(who != 0) {
			x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_maplock)))
			return
		}
	}
	_aio_fd_cnt = int32(0)
	if x___pthread_rwlock_tryrdlock(tls, uintptr(unsafe.Pointer(&_maplock))) != 0 {
		/* Obtaining lock may fail if _Fork was called nor via
		 * fork. In this case, no further aio is possible from
		 * child and we can just null out map so __aio_close
		 * does not attempt to do anything. */
		_map = uintptr(0)
		return
	}
	if _map != 0 {
		a = int32(0)
		for ; uint32(a) < (-Uint32FromUint32(1)/Uint32FromInt32(2)+Uint32FromInt32(1))>>Int32FromInt32(24); a++ {
			if *(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) != 0 {
				b = int32(0)
				for ; b < int32(256); b++ {
					if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) != 0 {
						c = int32(0)
						for ; c < int32(256); c++ {
							if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) != 0 {
								d = int32(0)
								for ; d < int32(256); d++ {
									*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_map + uintptr(a)*8)) + uintptr(b)*8)) + uintptr(c)*8)) + uintptr(d)*8)) = uintptr(0)
								}
							}
						}
					}
				}
			}
		}
	}
	/* Re-initialize the rwlock rather than unlocking since there
	 * may have been more than one reference on it in the parent.
	 * We are not a lock holder anyway; the thread in the parent was. */
	x_pthread_rwlock_init(tls, uintptr(unsafe.Pointer(&_maplock)), uintptr(0))
}

const m_CLOCK_MONOTONIC = 1
const m_EINTR = 4
const m_ETIMEDOUT = 110

func x_aio_suspend(tls *TLS, cbs uintptr, cnt int32, ts uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var cb uintptr
	var expect int32
	var i int32
	var nzcnt int32
	var pfut uintptr
	var ret int32
	var tid int32
	var _ /* at at bp+0 */ Ttimespec
	var _ /* dummy_fut at bp+16 */ int32
	var v4 uintptr
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	tid = int32(0)
	expect = int32(0)
	*(*int32)(unsafe.Pointer(bp + 16)) = int32(0)
	nzcnt = int32(0)
	cb = uintptr(0)
	x___pthread_testcancel(tls)
	if cnt < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	for i = int32(0); i < cnt; i++ {
		if *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) != 0 {
			if x_aio_error(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8))) != int32(m_EINPROGRESS) {
				return int32(0)
			}
			nzcnt++
			cb = *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8))
		}
	}
	if ts != 0 {
		x___clock_gettime(tls, int32(m_CLOCK_MONOTONIC), bp)
		p1 = uintptr(unsafe.Pointer(&(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec))
		*(*Ttime_t)(unsafe.Pointer(p1)) = *(*Ttime_t)(unsafe.Pointer(p1)) + (*Ttimespec)(unsafe.Pointer(ts)).Ftv_sec
		p2 = uintptr(unsafe.Pointer(&(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec))
		*(*int64)(unsafe.Pointer(p2)) = *(*int64)(unsafe.Pointer(p2)) + (*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec
		if *(*int64)(unsafe.Pointer(p2)) >= int64(1000000000) {
			p3 = uintptr(unsafe.Pointer(&(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec))
			*(*int64)(unsafe.Pointer(p3)) = *(*int64)(unsafe.Pointer(p3)) - Int64FromInt32(1000000000)
			(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec++
		}
	}
	for {
		for i = int32(0); i < cnt; i++ {
			if *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) != 0 && x_aio_error(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8))) != int32(m_EINPROGRESS) {
				return int32(0)
			}
		}
		switch nzcnt {
		case int32(0):
			pfut = bp + 16
		case int32(1):
			pfut = cb + 112
			expect = int32(Uint32FromInt32(m_EINPROGRESS) | Uint32FromUint32(0x80000000))
			_a_cas(tls, pfut, int32(m_EINPROGRESS), expect)
		default:
			pfut = uintptr(unsafe.Pointer(&x___aio_fut))
			if !(tid != 0) {
				tid = (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid
			}
			expect = _a_cas(tls, pfut, int32(0), tid)
			if !(expect != 0) {
				expect = tid
			}
			/* Need to recheck the predicate before waiting. */
			for i = int32(0); i < cnt; i++ {
				if *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) != 0 && x_aio_error(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8))) != int32(m_EINPROGRESS) {
					return int32(0)
				}
			}
			break
		}
		if ts != 0 {
			v4 = bp
		} else {
			v4 = uintptr(0)
		}
		ret = x___timedwait_cp(tls, pfut, expect, int32(m_CLOCK_MONOTONIC), v4, int32(1))
		switch ret {
		case int32(m_ETIMEDOUT):
			ret = int32(m_EAGAIN)
			fallthrough
		case int32(m_ECANCELED):
			fallthrough
		case int32(m_EINTR):
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = ret
			return -int32(1)
		}
	}
	return r
}

const m_EIO = 5
const m_LIO_WAIT = 0
const m_PAGESIZE = 4096
const m_SIGEV_NONE = 1

type Tlio_state = struct {
	Fsev uintptr
	Fcnt int32
}

func _lio_wait(tls *TLS, st uintptr) (r int32) {
	var cbs uintptr
	var cnt int32
	var err int32
	var got_err int32
	var i int32
	got_err = int32(0)
	cnt = (*Tlio_state)(unsafe.Pointer(st)).Fcnt
	cbs = st + 16
	for {
		for i = int32(0); i < cnt; i++ {
			if !(*(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) != 0) {
				continue
			}
			err = x_aio_error(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)))
			if err == int32(m_EINPROGRESS) {
				break
			}
			if err != 0 {
				got_err = int32(1)
			}
			*(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) = uintptr(0)
		}
		if i == cnt {
			if got_err != 0 {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EIO)
				return -int32(1)
			}
			return int32(0)
		}
		if x_aio_suspend(tls, cbs, cnt, uintptr(0)) != 0 {
			return -int32(1)
		}
	}
	return r
}

func _notify_signal(tls *TLS, sev uintptr) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var _ /* si at bp+0 */ Tsiginfo_t
	*(*Tsiginfo_t)(unsafe.Pointer(bp)) = Tsiginfo_t{Fsi_signo: (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_signo, Fsi_code: -int32(4), F__si_fields: *(*struct {
		F__si_common [0]struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		}
		F__sigfault [0]struct {
			Fsi_addr     uintptr
			Fsi_addr_lsb int16
			F__first     struct {
				Fsi_pkey    [0]uint32
				F__addr_bnd struct {
					Fsi_lower uintptr
					Fsi_upper uintptr
				}
			}
		}
		F__sigpoll [0]struct {
			Fsi_band     int64
			Fsi_fd       int32
			F__ccgo_pad2 [4]byte
		}
		F__sigsys [0]struct {
			Fsi_call_addr uintptr
			Fsi_syscall   int32
			Fsi_arch      uint32
		}
		F__pad [112]int8
	})(unsafe.Pointer(&struct {
		f struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		}
		_ [80]byte
	}{f: struct {
		F__first struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		}
		F__second struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}
	}{F__first: *(*struct {
		F__timer [0]struct {
			Fsi_timerid int32
			Fsi_overrun int32
		}
		F__piduid struct {
			Fsi_pid Tpid_t
			Fsi_uid Tuid_t
		}
	})(unsafe.Pointer(&struct {
		Fsi_pid Tpid_t
		Fsi_uid Tuid_t
	}{Fsi_pid: x_getpid(tls), Fsi_uid: x_getuid(tls)})), F__second: struct {
		F__sigchld [0]struct {
			Fsi_status int32
			Fsi_utime  Tclock_t
			Fsi_stime  Tclock_t
		}
		Fsi_value    Tsigval
		F__ccgo_pad2 [16]byte
	}{Fsi_value: (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_value}}}))}
	___syscall3(tls, int64(129), int64((*(*struct {
		Fsi_pid Tpid_t
		Fsi_uid Tuid_t
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		F__first struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		}
		F__second struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}
	})(unsafe.Pointer(&(*(*Tsiginfo_t)(unsafe.Pointer(bp))).F__si_fields))).F__first))))).Fsi_pid), int64((*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo), int64(bp))
}

func _wait_thread(tls *TLS, p uintptr) (r uintptr) {
	var sev uintptr
	var st uintptr
	st = p
	sev = (*Tlio_state)(unsafe.Pointer(st)).Fsev
	_lio_wait(tls, st)
	x_free(tls, st)
	switch (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_notify {
	case int32(m_SIGEV_SIGNAL):
		_notify_signal(tls, sev)
	case int32(m_SIGEV_THREAD):
		(*(*func(*TLS, Tsigval))(unsafe.Pointer(&struct{ uintptr }{(*(*struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer(sev)).F__sev_fields))).Fsigev_notify_function})))(tls, (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_value)
		break
	}
	return uintptr(0)
}

func x_lio_listio(tls *TLS, mode int32, cbs uintptr, cnt int32, sev uintptr) (r int32) {
	bp := tls.Alloc(320) /* tlsAllocs 320 maxValist 0 */
	defer tls.Free(320)
	var i int32
	var ret int32
	var st uintptr
	var _ /* a at bp+0 */ Tpthread_attr_t
	var _ /* set at bp+56 */ Tsigset_t
	var _ /* set_old at bp+184 */ Tsigset_t
	var _ /* td at bp+312 */ Tpthread_t
	var v1 uintptr
	st = uintptr(0)
	if cnt < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	if mode == int32(m_LIO_WAIT) || sev != 0 && (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_notify != int32(m_SIGEV_NONE) {
		v1 = _default_malloc(tls, uint64(16)+uint64(cnt)*uint64(8))
		st = v1
		if !(v1 != 0) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
			return -int32(1)
		}
		(*Tlio_state)(unsafe.Pointer(st)).Fcnt = cnt
		(*Tlio_state)(unsafe.Pointer(st)).Fsev = sev
		x_memcpy(tls, st+16, cbs, uint64(cnt)*uint64(8))
	}
	for i = int32(0); i < cnt; i++ {
		if !(*(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)) != 0) {
			continue
		}
		switch (*Taiocb)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)))).Faio_lio_opcode {
		case int32(m_LIO_READ):
			ret = x_aio_read(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)))
		case int32(m_LIO_WRITE):
			ret = x_aio_write(tls, *(*uintptr)(unsafe.Pointer(cbs + uintptr(i)*8)))
		default:
			continue
		}
		if ret != 0 {
			x_free(tls, st)
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
			return -int32(1)
		}
	}
	if mode == int32(m_LIO_WAIT) {
		ret = _lio_wait(tls, st)
		x_free(tls, st)
		return ret
	}
	if st != 0 {
		if (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_notify == int32(m_SIGEV_THREAD) {
			if (*(*struct {
				Fsigev_notify_function   uintptr
				Fsigev_notify_attributes uintptr
			})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer(sev)).F__sev_fields))).Fsigev_notify_attributes != 0 {
				*(*Tpthread_attr_t)(unsafe.Pointer(bp)) = *(*Tpthread_attr_t)(unsafe.Pointer((*(*struct {
					Fsigev_notify_function   uintptr
					Fsigev_notify_attributes uintptr
				})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer(sev)).F__sev_fields))).Fsigev_notify_attributes))
			} else {
				x_pthread_attr_init(tls, bp)
			}
		} else {
			x_pthread_attr_init(tls, bp)
			x_pthread_attr_setstacksize(tls, bp, uint64(m_PAGESIZE))
			x_pthread_attr_setguardsize(tls, bp, uint64(0))
		}
		x_pthread_attr_setdetachstate(tls, bp, int32(m_PTHREAD_CREATE_DETACHED))
		x_sigfillset(tls, bp+56)
		x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp+56, bp+184)
		if x___pthread_create(tls, bp+312, bp, __ccgo_fp(_wait_thread), st) != 0 {
			x_free(tls, st)
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
			return -int32(1)
		}
		x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+184, uintptr(0))
	}
	return int32(0)
}

const m_FP_NAN = 0

type Tfloat_t = float32

type Tdouble_t = float64

var _k = uint32(1799)                   /* constant for reduction */
var _kln2 = float64(1246.9717778273416) /* k * ln2 */

// C documentation
//
//	/*
//	 * Compute exp(x), scaled to avoid spurious overflow.  An exponent is
//	 * returned separately in 'expt'.
//	 *
//	 * Input:  ln(DBL_MAX) <= x < ln(2 * DBL_MAX / DBL_MIN_DENORM) ~= 1454.91
//	 * Output: 2**1023 <= y < 2**1024
//	 */
func ___frexp_exp(tls *TLS, x float64, expt uintptr) (r float64) {
	var exp_x float64
	var hx Tuint32_t
	/*
	 * We use exp(x) = exp(x - kln2) * 2**k, carefully chosen to
	 * minimize |exp(kln2) - 2**k|.  We also scale the exponent of
	 * exp_x to MAX_EXP so that the result can be multiplied by
	 * a tiny number without losing accuracy due to denormalization.
	 */
	exp_x = x_exp(tls, x-_kln2)
	{
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: exp_x})))) >> int32(32))
	}
	*(*int32)(unsafe.Pointer(expt)) = int32(hx>>Int32FromInt32(20) - uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1023)) + _k)
	{
		exp_x = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: uint64(hx&Uint32FromInt32(0xfffff)|uint32((Int32FromInt32(0x3ff)+Int32FromInt32(1023))<<Int32FromInt32(20)))<<Int32FromInt32(32) | uint64(uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: exp_x}))))))}))))
	}
	return exp_x
}

// C documentation
//
//	/*
//	 * __ldexp_cexp(x, expt) compute exp(x) * 2**expt.
//	 * It is intended for large arguments (real part >= ln(DBL_MAX))
//	 * where care is needed to avoid overflow.
//	 *
//	 * The present implementation is narrowly tailored for our hyperbolic and
//	 * exponential functions.  We assume expt is small (0 or -1), and the caller
//	 * has filtered out very large x, for which overflow would be inevitable.
//	 */
func x___ldexp_cexp(tls *TLS, z complex128, expt int32) (r complex128) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var exp_x float64
	var half_expt int32
	var scale1 float64
	var scale2 float64
	var x float64
	var y float64
	var _ /* ex_expt at bp+0 */ int32
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	exp_x = ___frexp_exp(tls, x, bp)
	expt = expt + *(*int32)(unsafe.Pointer(bp))
	/*
	 * Arrange so that scale1 * scale2 == 2**expt.  We use this to
	 * compensate for scalbn being horrendously slow.
	 */
	half_expt = expt / int32(2)
	{
		scale1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: uint64((Int32FromInt32(0x3ff)+half_expt)<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	half_expt = expt - half_expt
	{
		scale2 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: uint64((Int32FromInt32(0x3ff)+half_expt)<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: x_cos(tls, y) * exp_x * scale1 * scale2,
		1: x_sin(tls, y) * exp_x * scale1 * scale2}))))))
}

var _k1 = uint32(235)                        /* constant for reduction */
var _kln21 = Float32FromFloat32(162.8895874) /* k * ln2 */

// C documentation
//
//	/*
//	 * See __cexp.c for details.
//	 *
//	 * Input:  ln(FLT_MAX) <= x < ln(2 * FLT_MAX / FLT_MIN_DENORM) ~= 192.7
//	 * Output: 2**127 <= y < 2**128
//	 */
func ___frexp_expf(tls *TLS, x float32, expt uintptr) (r float32) {
	var exp_x float32
	var hx Tuint32_t
	exp_x = x_expf(tls, x-_kln21)
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: exp_x}))))
	}
	*(*int32)(unsafe.Pointer(expt)) = int32(hx>>Int32FromInt32(23) - uint32(Int32FromInt32(0x7f)+Int32FromInt32(127)) + _k1)
	{
		exp_x = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: hx&uint32(0x7fffff) | uint32((Int32FromInt32(0x7f)+Int32FromInt32(127))<<Int32FromInt32(23))}))))
	}
	return exp_x
}

func x___ldexp_cexpf(tls *TLS, z complex64, expt int32) (r complex64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var exp_x float32
	var half_expt int32
	var scale1 float32
	var scale2 float32
	var x float32
	var y float32
	var _ /* ex_expt at bp+0 */ int32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	exp_x = ___frexp_expf(tls, x, bp)
	expt = expt + *(*int32)(unsafe.Pointer(bp))
	half_expt = expt / int32(2)
	{
		scale1 = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: uint32((int32(0x7f) + half_expt) << int32(23))}))))
	}
	half_expt = expt - half_expt
	{
		scale2 = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: uint32((int32(0x7f) + half_expt) << int32(23))}))))
	}
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: x_cosf(tls, y) * exp_x * scale1 * scale2,
		1: x_sinf(tls, y) * exp_x * scale1 * scale2}))))))
}

func x_cabs(tls *TLS, z complex128) (r float64) {
	return x_hypot(tls, Float64FromComplex128(z), +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8)))
}

func x_cabsf(tls *TLS, z complex64) (r float32) {
	return x_hypotf(tls, Float32FromComplex64(z), +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4)))
}

func x_cabsl(tls *TLS, z complex128) (r float64) {
	return x_cabs(tls, z)
}

func x_cacos(tls *TLS, z complex128) (r complex128) {
	z = x_casin(tls, z)
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: float64(1.5707963267948966) - Float64FromComplex128(z),
		1: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8))}))))))
}

// FIXME

var _float_pi_2 = float32(1.5707963267948966)

func x_cacosf(tls *TLS, z complex64) (r complex64) {
	z = x_casinf(tls, z)
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: _float_pi_2 - Float32FromComplex64(z),
		1: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4))}))))))
}

func x_cacosh(tls *TLS, z complex128) (r complex128) {
	var zineg int32
	zineg = int32(___DOUBLE_BITS(tls, +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))) >> Int32FromInt32(63))
	z = x_cacos(tls, z)
	if zineg != 0 {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float64
				F__z  complex128
			}{F__z: z})) + UintptrFromInt32(1)*8)),
			1: -Float64FromComplex128(z)}))))))
	} else {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float64
				F__z  complex128
			}{F__z: z})) + UintptrFromInt32(1)*8)),
			1: Float64FromComplex128(z)}))))))
	}
	return r
}

func x_cacoshf(tls *TLS, z complex64) (r complex64) {
	var zineg int32
	zineg = int32(___FLOAT_BITS(tls, +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))) >> Int32FromInt32(31))
	z = x_cacosf(tls, z)
	if zineg != 0 {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float32
				F__z  complex64
			}{F__z: z})) + UintptrFromInt32(1)*4)),
			1: -Float32FromComplex64(z)}))))))
	} else {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float32
				F__z  complex64
			}{F__z: z})) + UintptrFromInt32(1)*4)),
			1: Float32FromComplex64(z)}))))))
	}
	return r
}

func x_cacoshl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_cacosh(tls, z))
}

func x_cacosl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_cacos(tls, z))
}

func x_carg(tls *TLS, z complex128) (r float64) {
	return x_atan2(tls, +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8)), Float64FromComplex128(z))
}

func x_cargf(tls *TLS, z complex64) (r float32) {
	return x_atan2f(tls, +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4)), Float32FromComplex64(z))
}

func x_cargl(tls *TLS, z complex128) (r float64) {
	return x_carg(tls, z)
}

func x_casin(tls *TLS, z complex128) (r1 complex128) {
	var r complex128
	var w complex128
	var x float64
	var y float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	w = *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: float64(1) - (x-y)*(x+y),
		1: -Float64FromFloat64(2) * x * y}))))))
	r = x_clog(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -y,
		1: x}))))))+x_csqrt(tls, w))
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: r})) + UintptrFromInt32(1)*8)),
		1: -Float64FromComplex128(r)}))))))
}

func x_casinf(tls *TLS, z complex64) (r1 complex64) {
	var r complex64
	var w complex64
	var x float32
	var y float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	w = *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: float32(Float64FromFloat64(1) - float64((x-y)*(x+y))),
		1: float32(-Float64FromFloat64(2) * float64(x) * float64(y))}))))))
	r = x_clogf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -y,
		1: x}))))))+x_csqrtf(tls, w))
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: r})) + UintptrFromInt32(1)*4)),
		1: -Float32FromComplex64(r)}))))))
}

func x_casinh(tls *TLS, z complex128) (r complex128) {
	z = x_casin(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: Float64FromComplex128(z)})))))))
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: -Float64FromComplex128(z)}))))))
}

func x_casinhf(tls *TLS, z complex64) (r complex64) {
	z = x_casinf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: Float32FromComplex64(z)})))))))
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: -Float32FromComplex64(z)}))))))
}

func x_casinhl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_casinh(tls, z))
}

func x_casinl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_casin(tls, z))
}

var _DP1 = float64(3.141592651605606)
var _DP2 = float64(1.9841871479187034e-09)
var _DP3 = float64(1.1442377452219664e-17)

func __redupi(tls *TLS, x float64) (r float64) {
	var i int64
	var t float64
	t = x / float64(3.141592653589793)
	if t >= float64(0) {
		t = t + Float64FromFloat64(0.5)
	} else {
		t = t - Float64FromFloat64(0.5)
	}
	i = int64(t) /* the multiple */
	t = float64(i)
	t = x - t*_DP1 - t*_DP2 - t*_DP3
	return t
}

func x_catan(tls *TLS, z complex128) (r complex128) {
	var a float64
	var t float64
	var w complex128
	var x float64
	var x2 float64
	var y float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	x2 = x * x
	a = float64(1) - x2 - y*y
	t = float64(0.5) * x_atan2(tls, float64(2)*x, a)
	w = Complex128FromFloat64(__redupi(tls, t))
	t = y - float64(1)
	a = x2 + t*t
	t = y + float64(1)
	a = (x2 + t*t) / a
	w = *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: Float64FromComplex128(w),
		1: float64(0.25) * x_log(tls, a)}))))))
	return w
}

var _DP11 = float64(3.140625)
var _DP21 = float64(0.0009675025939941406)
var _DP31 = float64(1.5099579909783765e-07)

var _float_pi = float32(3.141592653589793)

func __redupif(tls *TLS, xx float32) (r float32) {
	var i int64
	var t float32
	var x float32
	x = xx
	t = x / _float_pi
	if t >= Float32FromFloat32(0) {
		t = t + Float32FromFloat32(0.5)
	} else {
		t = t - Float32FromFloat32(0.5)
	}
	i = int64(t) /* the multiple */
	t = float32(i)
	t = float32(float64(x) - float64(t)*_DP11 - float64(t)*_DP21 - float64(t)*_DP31)
	return t
}

func x_catanf(tls *TLS, z complex64) (r complex64) {
	var a float32
	var t float32
	var w complex64
	var x float32
	var x2 float32
	var y float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	x2 = x * x
	a = Float32FromFloat32(1) - x2 - y*y
	t = Float32FromFloat32(0.5) * x_atan2f(tls, Float32FromFloat32(2)*x, a)
	w = Complex64FromFloat32(__redupif(tls, t))
	t = y - Float32FromFloat32(1)
	a = x2 + t*t
	t = y + Float32FromFloat32(1)
	a = (x2 + t*t) / a
	w = *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: Float32FromComplex64(w),
		1: Float32FromFloat32(0.25) * x_logf(tls, a)}))))))
	return w
}

func x_catanh(tls *TLS, z complex128) (r complex128) {
	z = x_catan(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: Float64FromComplex128(z)})))))))
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: -Float64FromComplex128(z)}))))))
}

func x_catanhf(tls *TLS, z complex64) (r complex64) {
	z = x_catanf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: Float32FromComplex64(z)})))))))
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: -Float32FromComplex64(z)}))))))
}

func x_catanhl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_catanh(tls, z))
}

func x_catanl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_catan(tls, z))
}

func x_ccos(tls *TLS, z complex128) (r complex128) {
	return x_ccosh(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: Float64FromComplex128(z)})))))))
}

func x_ccosf(tls *TLS, z complex64) (r complex64) {
	return x_ccoshf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: Float32FromComplex64(z)})))))))
}

var _huge = float64(8.98846567431158e+307)

func x_ccosh(tls *TLS, z complex128) (r complex128) {
	var __u Tuint64_t
	var __u1 Tuint64_t
	var h float64
	var hx Tint32_t
	var hy Tint32_t
	var ix Tint32_t
	var iy Tint32_t
	var lx Tint32_t
	var ly Tint32_t
	var x float64
	var y float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		hx = int32(__u >> int32(32))
		lx = int32(uint32(__u))
	}
	{
		__u1 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: y}))))
		hy = int32(__u1 >> int32(32))
		ly = int32(uint32(__u1))
	}
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	/* Handle the nearly-non-exceptional cases where x and y are finite. */
	if ix < int32(0x7ff00000) && iy < int32(0x7ff00000) {
		if iy|ly == int32(0) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_cosh(tls, x),
				1: x * y}))))))
		}
		if ix < int32(0x40360000) { /* small x: normal case */
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_cosh(tls, x) * x_cos(tls, y),
				1: x_sinh(tls, x) * x_sin(tls, y)}))))))
		}
		/* |x| >= 22, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x40862e42) {
			/* x < 710: exp(|x|) won't overflow */
			h = x_exp(tls, x_fabs(tls, x)) * float64(0.5)
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: h * x_cos(tls, y),
				1: x_copysign(tls, h, x) * x_sin(tls, y)}))))))
		} else {
			if ix < int32(0x4096bbaa) {
				/* x < 1455: scale to avoid overflow */
				z = x___ldexp_cexp(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: x_fabs(tls, x),
					1: y})))))), -int32(1))
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: Float64FromComplex128(z),
					1: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
						F__xy [0][2]float64
						F__z  complex128
					}{F__z: z})) + UintptrFromInt32(1)*8)) * x_copysign(tls, Float64FromInt32(1), x)}))))))
			} else {
				/* x >= 1455: the result always overflows */
				h = _huge * x
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: h * h * x_cos(tls, y),
					1: h * x_sin(tls, y)}))))))
			}
		}
	}
	/*
	 * cosh(+-0 +- I Inf) = dNaN + I sign(d(+-0, dNaN))0.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as dNaN.  Raise the invalid floating-point exception.
	 *
	 * cosh(+-0 +- I NaN) = d(NaN) + I sign(d(+-0, NaN))0.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 */
	if ix|lx == int32(0) && iy >= int32(0x7ff00000) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: y - y,
			1: x_copysign(tls, Float64FromInt32(0), x*(y-y))}))))))
	}
	/*
	 * cosh(+-Inf +- I 0) = +Inf + I (+-)(+-)0.
	 *
	 * cosh(NaN +- I 0)   = d(NaN) + I sign(d(NaN, +-0))0.
	 * The sign of 0 in the result is unspecified.
	 */
	if iy|ly == int32(0) && ix >= int32(0x7ff00000) {
		if hx&int32(0xfffff)|lx == int32(0) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x * x,
				1: x_copysign(tls, Float64FromInt32(0), x) * y}))))))
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x * x,
			1: x_copysign(tls, Float64FromInt32(0), (x+x)*y)}))))))
	}
	/*
	 * cosh(x +- I Inf) = dNaN + I dNaN.
	 * Raise the invalid floating-point exception for finite nonzero x.
	 *
	 * cosh(x + I NaN) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero x.  Choice = don't raise (except for signaling NaNs).
	 */
	if ix < int32(0x7ff00000) && iy >= int32(0x7ff00000) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: y - y,
			1: x * (y - y)}))))))
	}
	/*
	 * cosh(+-Inf + I NaN)  = +Inf + I d(NaN).
	 *
	 * cosh(+-Inf +- I Inf) = +Inf + I dNaN.
	 * The sign of Inf in the result is unspecified.  Choice = always +.
	 * Raise the invalid floating-point exception.
	 *
	 * cosh(+-Inf + I y)   = +Inf cos(y) +- I Inf sin(y)
	 */
	if ix >= int32(0x7ff00000) && hx&int32(0xfffff)|lx == int32(0) {
		if iy >= int32(0x7ff00000) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x * x,
				1: x * (y - y)}))))))
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x * x * x_cos(tls, y),
			1: x * x_sin(tls, y)}))))))
	}
	/*
	 * cosh(NaN + I NaN)  = d(NaN) + I d(NaN).
	 *
	 * cosh(NaN +- I Inf) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception.
	 * Choice = raise.
	 *
	 * cosh(NaN + I y)    = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero y.  Choice = don't raise (except for signaling NaNs).
	 */
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: x * x * (y - y),
		1: (x + x) * (y - y)}))))))
}

var _huge1 = float32(1.7014118346046923e+38)

func x_ccoshf(tls *TLS, z complex64) (r complex64) {
	var h float32
	var hx Tint32_t
	var hy Tint32_t
	var ix Tint32_t
	var iy Tint32_t
	var x float32
	var y float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	{
		hx = int32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x})))))
	}
	{
		hy = int32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: y})))))
	}
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	if ix < int32(0x7f800000) && iy < int32(0x7f800000) {
		if iy == int32(0) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_coshf(tls, x),
				1: x * y}))))))
		}
		if ix < int32(0x41100000) { /* small x: normal case */
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_coshf(tls, x) * x_cosf(tls, y),
				1: x_sinhf(tls, x) * x_sinf(tls, y)}))))))
		}
		/* |x| >= 9, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x42b17218) {
			/* x < 88.7: expf(|x|) won't overflow */
			h = x_expf(tls, x_fabsf(tls, x)) * Float32FromFloat32(0.5)
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: h * x_cosf(tls, y),
				1: x_copysignf(tls, h, x) * x_sinf(tls, y)}))))))
		} else {
			if ix < int32(0x4340b1e7) {
				/* x < 192.7: scale to avoid overflow */
				z = x___ldexp_cexpf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: x_fabsf(tls, x),
					1: y})))))), -int32(1))
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: Float32FromComplex64(z),
					1: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
						F__xy [0][2]float32
						F__z  complex64
					}{F__z: z})) + UintptrFromInt32(1)*4)) * x_copysignf(tls, Float32FromInt32(1), x)}))))))
			} else {
				/* x >= 192.7: the result always overflows */
				h = _huge1 * x
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: h * h * x_cosf(tls, y),
					1: h * x_sinf(tls, y)}))))))
			}
		}
	}
	if ix == int32(0) && iy >= int32(0x7f800000) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: y - y,
			1: x_copysignf(tls, Float32FromInt32(0), x*(y-y))}))))))
	}
	if iy == int32(0) && ix >= int32(0x7f800000) {
		if hx&int32(0x7fffff) == int32(0) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x * x,
				1: x_copysignf(tls, Float32FromInt32(0), x) * y}))))))
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x * x,
			1: x_copysignf(tls, Float32FromInt32(0), (x+x)*y)}))))))
	}
	if ix < int32(0x7f800000) && iy >= int32(0x7f800000) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: y - y,
			1: x * (y - y)}))))))
	}
	if ix >= int32(0x7f800000) && hx&int32(0x7fffff) == int32(0) {
		if iy >= int32(0x7f800000) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x * x,
				1: x * (y - y)}))))))
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x * x * x_cosf(tls, y),
			1: x * x_sinf(tls, y)}))))))
	}
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: x * x * (y - y),
		1: (x + x) * (y - y)}))))))
}

// C documentation
//
//	//FIXME
func x_ccoshl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_ccosh(tls, z))
}

func x_ccosl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_ccos(tls, z))
}

var _exp_ovfl = uint32(0x40862e42) /* high bits of MAX_EXP * ln2 ~= 710 */
var _cexp_ovfl = uint32(0x4096b8e4)

func x_cexp(tls *TLS, z complex128) (r complex128) {
	var __u Tuint64_t
	var __u1 Tuint64_t
	var exp_x float64
	var hx Tuint32_t
	var hy Tuint32_t
	var lx Tuint32_t
	var ly Tuint32_t
	var x float64
	var y float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: y}))))
		hy = uint32(__u >> int32(32))
		ly = uint32(__u)
	}
	hy = hy & Uint32FromInt32(0x7fffffff)
	/* cexp(x + I 0) = exp(x) + I 0 */
	if hy|ly == uint32(0) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x_exp(tls, x),
			1: y}))))))
	}
	{
		__u1 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		hx = uint32(__u1 >> int32(32))
		lx = uint32(__u1)
	}
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if hx&uint32(0x7fffffff)|lx == uint32(0) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x_cos(tls, y),
			1: x_sin(tls, y)}))))))
	}
	if hy >= uint32(0x7ff00000) {
		if lx != uint32(0) || hx&uint32(0x7fffffff) != uint32(0x7ff00000) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: y - y,
				1: y - y}))))))
		} else {
			if hx&uint32(0x80000000) != 0 {
				/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
					F__xy [0][2]float64
					F__z  complex128
				}{}))))
			} else {
				/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: x,
					1: y - y}))))))
			}
		}
	}
	if hx >= _exp_ovfl && hx <= _cexp_ovfl {
		/*
		 * x is between 709.7 and 1454.3, so we must scale to avoid
		 * overflow in exp(x).
		 */
		return x___ldexp_cexp(tls, z, int32(0))
	} else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		exp_x = x_exp(tls, x)
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: exp_x * x_cos(tls, y),
			1: exp_x * x_sin(tls, y)}))))))
	}
	return r
}

var _exp_ovfl1 = uint32(0x42b17218) /* MAX_EXP * ln2 ~= 88.722839355 */
var _cexp_ovfl1 = uint32(0x43400074)

func x_cexpf(tls *TLS, z complex64) (r complex64) {
	var exp_x float32
	var hx Tuint32_t
	var hy Tuint32_t
	var x float32
	var y float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	{
		hy = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: y}))))
	}
	hy = hy & Uint32FromInt32(0x7fffffff)
	/* cexp(x + I 0) = exp(x) + I 0 */
	if hy == uint32(0) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x_expf(tls, x),
			1: y}))))))
	}
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if hx&uint32(0x7fffffff) == uint32(0) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x_cosf(tls, y),
			1: x_sinf(tls, y)}))))))
	}
	if hy >= uint32(0x7f800000) {
		if hx&uint32(0x7fffffff) != uint32(0x7f800000) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: y - y,
				1: y - y}))))))
		} else {
			if hx&uint32(0x80000000) != 0 {
				/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
					F__xy [0][2]float32
					F__z  complex64
				}{}))))
			} else {
				/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: x,
					1: y - y}))))))
			}
		}
	}
	if hx >= _exp_ovfl1 && hx <= _cexp_ovfl1 {
		/*
		 * x is between 88.7 and 192, so we must scale to avoid
		 * overflow in expf(x).
		 */
		return x___ldexp_cexpf(tls, z, int32(0))
	} else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		exp_x = x_expf(tls, x)
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: exp_x * x_cosf(tls, y),
			1: exp_x * x_sinf(tls, y)}))))))
	}
	return r
}

// C documentation
//
//	//FIXME
func x_cexpl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_cexp(tls, z))
}

func x_cimag(tls *TLS, z complex128) (r float64) {
	return +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
}

func x_cimagf(tls *TLS, z complex64) (r float32) {
	return +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
}

func x_cimagl(tls *TLS, z complex128) (r float64) {
	return +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
}

func x_clog(tls *TLS, z complex128) (r1 complex128) {
	var phi float64
	var r float64
	r = x_cabs(tls, z)
	phi = x_carg(tls, z)
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: x_log(tls, r),
		1: phi}))))))
}

func x_clogf(tls *TLS, z complex64) (r1 complex64) {
	var phi float32
	var r float32
	r = x_cabsf(tls, z)
	phi = x_cargf(tls, z)
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: x_logf(tls, r),
		1: phi}))))))
}

func x_clogl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_clog(tls, z))
}

func x_conj(tls *TLS, z complex128) (r complex128) {
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: Float64FromComplex128(z),
		1: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8))}))))))
}

func x_conjf(tls *TLS, z complex64) (r complex64) {
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: Float32FromComplex64(z),
		1: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4))}))))))
}

func x_conjl(tls *TLS, z complex128) (r complex128) {
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: Float64FromComplex128(z),
		1: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8))}))))))
}

func x_cpow(tls *TLS, z complex128, c complex128) (r complex128) {
	return x_cexp(tls, c*x_clog(tls, z))
}

func x_cpowf(tls *TLS, z complex64, c complex64) (r complex64) {
	return x_cexpf(tls, c*x_clogf(tls, z))
}

func x_cpowl(tls *TLS, z complex128, c complex128) (r complex128) {
	return Complex128FromComplex128(x_cpow(tls, z, c))
}

const m_FP_INFINITE = 1

func x_cproj(tls *TLS, z complex128) (r complex128) {
	if BoolInt32(___DOUBLE_BITS(tls, Float64FromComplex128(z))&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || BoolInt32(___DOUBLE_BITS(tls, +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8)))&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: float64(___builtin_inff(tls)),
			1: x_copysign(tls, float64(0), +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float64
				F__z  complex128
			}{F__z: z})) + UintptrFromInt32(1)*8)))}))))))
	}
	return z
}

func x_cprojf(tls *TLS, z complex64) (r complex64) {
	if BoolInt32(___FLOAT_BITS(tls, Float32FromComplex64(z))&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 || BoolInt32(___FLOAT_BITS(tls, +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4)))&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: ___builtin_inff(tls),
			1: x_copysignf(tls, float32(0), +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F__xy [0][2]float32
				F__z  complex64
			}{F__z: z})) + UintptrFromInt32(1)*4)))}))))))
	}
	return z
}

func x_cprojl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_cproj(tls, z))
}

func x_creal(tls *TLS, z complex128) (r float64) {
	return Float64FromComplex128(z)
}

func x_crealf(tls *TLS, z complex64) (r float32) {
	return Float32FromComplex64(z)
}

func x_creall(tls *TLS, z complex128) (r float64) {
	return Float64FromComplex128(z)
}

func x_csin(tls *TLS, z complex128) (r complex128) {
	z = x_csinh(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: Float64FromComplex128(z)})))))))
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: -Float64FromComplex128(z)}))))))
}

func x_csinf(tls *TLS, z complex64) (r complex64) {
	z = x_csinhf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: Float32FromComplex64(z)})))))))
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: -Float32FromComplex64(z)}))))))
}

var _huge2 = float64(8.98846567431158e+307)

func x_csinh(tls *TLS, z complex128) (r complex128) {
	var __u Tuint64_t
	var __u1 Tuint64_t
	var h float64
	var hx Tint32_t
	var hy Tint32_t
	var ix Tint32_t
	var iy Tint32_t
	var lx Tint32_t
	var ly Tint32_t
	var x float64
	var y float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		hx = int32(__u >> int32(32))
		lx = int32(uint32(__u))
	}
	{
		__u1 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: y}))))
		hy = int32(__u1 >> int32(32))
		ly = int32(uint32(__u1))
	}
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	/* Handle the nearly-non-exceptional cases where x and y are finite. */
	if ix < int32(0x7ff00000) && iy < int32(0x7ff00000) {
		if iy|ly == int32(0) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_sinh(tls, x),
				1: y}))))))
		}
		if ix < int32(0x40360000) { /* small x: normal case */
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_sinh(tls, x) * x_cos(tls, y),
				1: x_cosh(tls, x) * x_sin(tls, y)}))))))
		}
		/* |x| >= 22, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x40862e42) {
			/* x < 710: exp(|x|) won't overflow */
			h = x_exp(tls, x_fabs(tls, x)) * float64(0.5)
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_copysign(tls, h, x) * x_cos(tls, y),
				1: h * x_sin(tls, y)}))))))
		} else {
			if ix < int32(0x4096bbaa) {
				/* x < 1455: scale to avoid overflow */
				z = x___ldexp_cexp(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: x_fabs(tls, x),
					1: y})))))), -int32(1))
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: Float64FromComplex128(z) * x_copysign(tls, Float64FromInt32(1), x),
					1: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
						F__xy [0][2]float64
						F__z  complex128
					}{F__z: z})) + UintptrFromInt32(1)*8))}))))))
			} else {
				/* x >= 1455: the result always overflows */
				h = _huge2 * x
				return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float64
					F__z  complex128
				})(unsafe.Pointer(&[2]float64{
					0: h * x_cos(tls, y),
					1: h * h * x_sin(tls, y)}))))))
			}
		}
	}
	/*
	 * sinh(+-0 +- I Inf) = sign(d(+-0, dNaN))0 + I dNaN.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as dNaN.  Raise the invalid floating-point exception.
	 *
	 * sinh(+-0 +- I NaN) = sign(d(+-0, NaN))0 + I d(NaN).
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 */
	if ix|lx == int32(0) && iy >= int32(0x7ff00000) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x_copysign(tls, Float64FromInt32(0), x*(y-y)),
			1: y - y}))))))
	}
	/*
	 * sinh(+-Inf +- I 0) = +-Inf + I +-0.
	 *
	 * sinh(NaN +- I 0)   = d(NaN) + I +-0.
	 */
	if iy|ly == int32(0) && ix >= int32(0x7ff00000) {
		if hx&int32(0xfffff)|lx == int32(0) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x,
				1: y}))))))
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x,
			1: x_copysign(tls, Float64FromInt32(0), y)}))))))
	}
	/*
	 * sinh(x +- I Inf) = dNaN + I dNaN.
	 * Raise the invalid floating-point exception for finite nonzero x.
	 *
	 * sinh(x + I NaN) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero x.  Choice = don't raise (except for signaling NaNs).
	 */
	if ix < int32(0x7ff00000) && iy >= int32(0x7ff00000) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: y - y,
			1: x * (y - y)}))))))
	}
	/*
	 * sinh(+-Inf + I NaN)  = +-Inf + I d(NaN).
	 * The sign of Inf in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 *
	 * sinh(+-Inf +- I Inf) = +Inf + I dNaN.
	 * The sign of Inf in the result is unspecified.  Choice = always +.
	 * Raise the invalid floating-point exception.
	 *
	 * sinh(+-Inf + I y)   = +-Inf cos(y) + I Inf sin(y)
	 */
	if ix >= int32(0x7ff00000) && hx&int32(0xfffff)|lx == int32(0) {
		if iy >= int32(0x7ff00000) {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x * x,
				1: x * (y - y)}))))))
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x * x_cos(tls, y),
			1: float64(___builtin_inff(tls)) * x_sin(tls, y)}))))))
	}
	/*
	 * sinh(NaN + I NaN)  = d(NaN) + I d(NaN).
	 *
	 * sinh(NaN +- I Inf) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception.
	 * Choice = raise.
	 *
	 * sinh(NaN + I y)    = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero y.  Choice = don't raise (except for signaling NaNs).
	 */
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: x * x * (y - y),
		1: (x + x) * (y - y)}))))))
}

var _huge3 = float32(1.7014118346046923e+38)

func x_csinhf(tls *TLS, z complex64) (r complex64) {
	var h float32
	var hx Tint32_t
	var hy Tint32_t
	var ix Tint32_t
	var iy Tint32_t
	var x float32
	var y float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	{
		hx = int32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x})))))
	}
	{
		hy = int32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: y})))))
	}
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	if ix < int32(0x7f800000) && iy < int32(0x7f800000) {
		if iy == int32(0) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_sinhf(tls, x),
				1: y}))))))
		}
		if ix < int32(0x41100000) { /* small x: normal case */
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_sinhf(tls, x) * x_cosf(tls, y),
				1: x_coshf(tls, x) * x_sinf(tls, y)}))))))
		}
		/* |x| >= 9, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x42b17218) {
			/* x < 88.7: expf(|x|) won't overflow */
			h = x_expf(tls, x_fabsf(tls, x)) * Float32FromFloat32(0.5)
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_copysignf(tls, h, x) * x_cosf(tls, y),
				1: h * x_sinf(tls, y)}))))))
		} else {
			if ix < int32(0x4340b1e7) {
				/* x < 192.7: scale to avoid overflow */
				z = x___ldexp_cexpf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: x_fabsf(tls, x),
					1: y})))))), -int32(1))
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: Float32FromComplex64(z) * x_copysignf(tls, Float32FromInt32(1), x),
					1: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
						F__xy [0][2]float32
						F__z  complex64
					}{F__z: z})) + UintptrFromInt32(1)*4))}))))))
			} else {
				/* x >= 192.7: the result always overflows */
				h = _huge3 * x
				return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
					F__xy [0][2]float32
					F__z  complex64
				})(unsafe.Pointer(&[2]float32{
					0: h * x_cosf(tls, y),
					1: h * h * x_sinf(tls, y)}))))))
			}
		}
	}
	if ix == int32(0) && iy >= int32(0x7f800000) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x_copysignf(tls, Float32FromInt32(0), x*(y-y)),
			1: y - y}))))))
	}
	if iy == int32(0) && ix >= int32(0x7f800000) {
		if hx&int32(0x7fffff) == int32(0) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x,
				1: y}))))))
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x,
			1: x_copysignf(tls, Float32FromInt32(0), y)}))))))
	}
	if ix < int32(0x7f800000) && iy >= int32(0x7f800000) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: y - y,
			1: x * (y - y)}))))))
	}
	if ix >= int32(0x7f800000) && hx&int32(0x7fffff) == int32(0) {
		if iy >= int32(0x7f800000) {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x * x,
				1: x * (y - y)}))))))
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x * x_cosf(tls, y),
			1: ___builtin_inff(tls) * x_sinf(tls, y)}))))))
	}
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: x * x * (y - y),
		1: (x + x) * (y - y)}))))))
}

// C documentation
//
//	//FIXME
func x_csinhl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_csinh(tls, z))
}

func x_csinl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_csin(tls, z))
}

func x_csqrt(tls *TLS, z complex128) (r complex128) {
	var a float64
	var b float64
	var result complex128
	var scale int32
	var t float64
	a = Float64FromComplex128(z)
	b = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	/* Handle special cases. */
	if z == Complex128FromInt32(0) {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: float64(Int32FromInt32(0)),
			1: b}))))))
	}
	if BoolInt32(___DOUBLE_BITS(tls, b)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: float64(___builtin_inff(tls)),
			1: b}))))))
	}
	if BoolInt32(___DOUBLE_BITS(tls, a)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		t = (b - b) / (b - b) /* raise invalid if b is not a NaN */
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: a,
			1: t})))))) /* return NaN + NaN i */
	}
	if BoolInt32(___DOUBLE_BITS(tls, a)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		/*
		 * csqrt(inf + NaN i)  = inf +  NaN i
		 * csqrt(inf + y i)    = inf +  0 i
		 * csqrt(-inf + NaN i) = NaN +- inf i
		 * csqrt(-inf + y i)   = 0   +  inf i
		 */
		if int32(___DOUBLE_BITS(tls, a)>>Int32FromInt32(63)) != 0 {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x_fabs(tls, b-b),
				1: x_copysign(tls, a, b)}))))))
		} else {
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: a,
				1: x_copysign(tls, b-b, b)}))))))
		}
	}
	/*
	 * The remaining special case (b is NaN) is handled just fine by
	 * the normal code path below.
	 */
	/* Scale to avoid overflow. */
	if x_fabs(tls, a) >= float64(7.446288774449766e+307) || x_fabs(tls, b) >= float64(7.446288774449766e+307) {
		a = a * Float64FromFloat64(0.25)
		b = b * Float64FromFloat64(0.25)
		scale = int32(1)
	} else {
		scale = int32(0)
	}
	/* Algorithm 312, CACM vol 10, Oct 1967. */
	if a >= Float64FromInt32(0) {
		t = x_sqrt(tls, (a+x_hypot(tls, a, b))*float64(0.5))
		result = *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: t,
			1: b / (Float64FromInt32(2) * t)}))))))
	} else {
		t = x_sqrt(tls, (-a+x_hypot(tls, a, b))*float64(0.5))
		result = *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x_fabs(tls, b) / (Float64FromInt32(2) * t),
			1: x_copysign(tls, t, b)}))))))
	}
	/* Rescale. */
	if scale != 0 {
		result = result * Complex128FromInt32(2)
	}
	return result
}

func x_csqrtf(tls *TLS, z complex64) (r complex64) {
	var a float32
	var b float32
	var t float64
	a = Float32FromComplex64(z)
	b = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	/* Handle special cases. */
	if z == Complex64FromInt32(0) {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: float32(Int32FromInt32(0)),
			1: b}))))))
	}
	if BoolInt32(___FLOAT_BITS(tls, b)&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: ___builtin_inff(tls),
			1: b}))))))
	}
	if BoolInt32(___FLOAT_BITS(tls, a)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		t = float64((b - b) / (b - b)) /* raise invalid if b is not a NaN */
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: a,
			1: float32(t)})))))) /* return NaN + NaN i */
	}
	if BoolInt32(___FLOAT_BITS(tls, a)&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		/*
		 * csqrtf(inf + NaN i)  = inf +  NaN i
		 * csqrtf(inf + y i)    = inf +  0 i
		 * csqrtf(-inf + NaN i) = NaN +- inf i
		 * csqrtf(-inf + y i)   = 0   +  inf i
		 */
		if int32(___FLOAT_BITS(tls, a)>>Int32FromInt32(31)) != 0 {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x_fabsf(tls, b-b),
				1: x_copysignf(tls, a, b)}))))))
		} else {
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: a,
				1: x_copysignf(tls, b-b, b)}))))))
		}
	}
	/*
	 * The remaining special case (b is NaN) is handled just fine by
	 * the normal code path below.
	 */
	/*
	 * We compute t in double precision to avoid overflow and to
	 * provide correct rounding in nearly all cases.
	 * This is Algorithm 312, CACM vol 10, Oct 1967.
	 */
	if a >= Float32FromInt32(0) {
		t = x_sqrt(tls, (float64(a)+x_hypot(tls, float64(a), float64(b)))*float64(0.5))
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: float32(t),
			1: float32(float64(b) / (Float64FromFloat64(2) * t))}))))))
	} else {
		t = x_sqrt(tls, (float64(-a)+x_hypot(tls, float64(a), float64(b)))*float64(0.5))
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: float32(float64(x_fabsf(tls, b)) / (Float64FromFloat64(2) * t)),
			1: x_copysignf(tls, float32(t), b)}))))))
	}
	return r
}

// C documentation
//
//	//FIXME
func x_csqrtl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_csqrt(tls, z))
}

func x_ctan(tls *TLS, z complex128) (r complex128) {
	z = x_ctanh(tls, *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: -+*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: Float64FromComplex128(z)})))))))
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float64
			F__z  complex128
		}{F__z: z})) + UintptrFromInt32(1)*8)),
		1: -Float64FromComplex128(z)}))))))
}

func x_ctanf(tls *TLS, z complex64) (r complex64) {
	z = x_ctanhf(tls, *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: -+*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: Float32FromComplex64(z)})))))))
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F__xy [0][2]float32
			F__z  complex64
		}{F__z: z})) + UintptrFromInt32(1)*4)),
		1: -Float32FromComplex64(z)}))))))
}

func x_ctanh(tls *TLS, z complex128) (r complex128) {
	var __u Tuint64_t
	var beta float64
	var denom float64
	var exp_mx float64
	var hx Tuint32_t
	var ix Tuint32_t
	var lx Tuint32_t
	var rho float64
	var s float64
	var t float64
	var x float64
	var y float64
	var v1 float64
	var v2 float64
	var v3 float64
	x = Float64FromComplex128(z)
	y = +*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float64
		F__z  complex128
	}{F__z: z})) + UintptrFromInt32(1)*8))
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		hx = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	ix = hx & uint32(0x7fffffff)
	/*
	 * ctanh(NaN + i 0) = NaN + i 0
	 *
	 * ctanh(NaN + i y) = NaN + i NaN               for y != 0
	 *
	 * The imaginary part has the sign of x*sin(2*y), but there's no
	 * special effort to get this right.
	 *
	 * ctanh(+-Inf +- i Inf) = +-1 +- 0
	 *
	 * ctanh(+-Inf + i y) = +-1 + 0 sin(2y)         for y finite
	 *
	 * The imaginary part of the sign is unspecified.  This special
	 * case is only needed to avoid a spurious invalid exception when
	 * y is infinite.
	 */
	if ix >= uint32(0x7ff00000) {
		if ix&uint32(0xfffff)|lx != 0 { /* x is NaN */
			if y == Float64FromInt32(0) {
				v1 = y
			} else {
				v1 = x * y
			}
			return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float64
				F__z  complex128
			})(unsafe.Pointer(&[2]float64{
				0: x,
				1: v1}))))))
		}
		{
			x = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_f [0]float64
				F_i Tuint64_t
			}{F_i: uint64(hx-Uint32FromInt32(0x40000000))<<Int32FromInt32(32) | uint64(uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x}))))))}))))
		} /* x = copysign(1, x) */
		if BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			v2 = y
		} else {
			v2 = x_sin(tls, y) * x_cos(tls, y)
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x,
			1: x_copysign(tls, Float64FromInt32(0), v2)}))))))
	}
	/*
	 * ctanh(+-0 + i NAN) = +-0 + i NaN
	 * ctanh(+-0 +- i Inf) = +-0 + i NaN
	 * ctanh(x + i NAN) = NaN + i NaN
	 * ctanh(x +- i Inf) = NaN + i NaN
	 */
	if !(BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		if x != 0 {
			v3 = y - y
		} else {
			v3 = x
		}
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: v3,
			1: y - y}))))))
	}
	/*
	 * ctanh(+-huge + i +-y) ~= +-1 +- i 2sin(2y)/exp(2x), using the
	 * approximation sinh^2(huge) ~= exp(2*huge) / 4.
	 * We use a modified formula to avoid spurious overflow.
	 */
	if ix >= uint32(0x40360000) {
		/* x >= 22 */
		exp_mx = x_exp(tls, -x_fabs(tls, x))
		return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float64
			F__z  complex128
		})(unsafe.Pointer(&[2]float64{
			0: x_copysign(tls, Float64FromInt32(1), x),
			1: Float64FromInt32(4) * x_sin(tls, y) * x_cos(tls, y) * exp_mx * exp_mx}))))))
	}
	/* Kahan's algorithm */
	t = x_tan(tls, y)
	beta = float64(1) + t*t /* = 1 / cos^2(y) */
	s = x_sinh(tls, x)
	rho = x_sqrt(tls, Float64FromInt32(1)+s*s) /* = cosh(x) */
	denom = Float64FromInt32(1) + beta*s*s
	return *(*complex128)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float64
		F__z  complex128
	})(unsafe.Pointer(&[2]float64{
		0: beta * rho * s / denom,
		1: t / denom}))))))
}

func x_ctanhf(tls *TLS, z complex64) (r complex64) {
	var beta float32
	var denom float32
	var exp_mx float32
	var hx Tuint32_t
	var ix Tuint32_t
	var rho float32
	var s float32
	var t float32
	var x float32
	var y float32
	var v1 float32
	var v2 float32
	var v3 float32
	x = Float32FromComplex64(z)
	y = +*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F__xy [0][2]float32
		F__z  complex64
	}{F__z: z})) + UintptrFromInt32(1)*4))
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = hx & uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		if ix&uint32(0x7fffff) != 0 {
			if y == Float32FromInt32(0) {
				v1 = y
			} else {
				v1 = x * y
			}
			return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
				F__xy [0][2]float32
				F__z  complex64
			})(unsafe.Pointer(&[2]float32{
				0: x,
				1: v1}))))))
		}
		{
			x = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_f [0]float32
				F_i Tuint32_t
			}{F_i: hx - uint32(0x40000000)}))))
		}
		if BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
			v2 = y
		} else {
			v2 = x_sinf(tls, y) * x_cosf(tls, y)
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x,
			1: x_copysignf(tls, Float32FromInt32(0), v2)}))))))
	}
	if !(BoolInt32(___FLOAT_BITS(tls, y)&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		if ix != 0 {
			v3 = y - y
		} else {
			v3 = x
		}
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: v3,
			1: y - y}))))))
	}
	if ix >= uint32(0x41300000) {
		/* x >= 11 */
		exp_mx = x_expf(tls, -x_fabsf(tls, x))
		return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
			F__xy [0][2]float32
			F__z  complex64
		})(unsafe.Pointer(&[2]float32{
			0: x_copysignf(tls, Float32FromInt32(1), x),
			1: Float32FromInt32(4) * x_sinf(tls, y) * x_cosf(tls, y) * exp_mx * exp_mx}))))))
	}
	t = x_tanf(tls, y)
	beta = float32(float64(1) + float64(t*t))
	s = x_sinhf(tls, x)
	rho = x_sqrtf(tls, Float32FromInt32(1)+s*s)
	denom = Float32FromInt32(1) + beta*s*s
	return *(*complex64)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*struct {
		F__xy [0][2]float32
		F__z  complex64
	})(unsafe.Pointer(&[2]float32{
		0: beta * rho * s / denom,
		1: t / denom}))))))
}

// C documentation
//
//	//FIXME
func x_ctanhl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_ctanh(tls, z))
}

func x_ctanl(tls *TLS, z complex128) (r complex128) {
	return Complex128FromComplex128(x_ctan(tls, z))
}

const m__CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116

func x_confstr(tls *TLS, name int32, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	var s uintptr
	s = ts
	if !(name != 0) {
		s = ts + 1
	} else {
		if uint32(name) & ^Uint32FromUint32(4) != uint32(1) && uint32(name-int32(m__CS_POSIX_V6_ILP32_OFF32_CFLAGS)) > uint32(35) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
			return uint64(0)
		}
	}
	// snprintf is overkill but avoid wasting code size to implement
	// this completely useless function and its truncation semantics
	return uint64(x_snprintf(tls, buf, len1, ts+15, VaList(bp+8, s)) + int32(1))
}

const m_FILESIZEBITS = 64
const m_NAME_MAX = 255
const m_PATH_MAX = 4096
const m_PIPE_BUF = 4096
const m__PC_2_SYMLINKS = 20
const m__PC_ALLOC_SIZE_MIN = 18
const m__PC_ASYNC_IO = 10
const m__PC_CHOWN_RESTRICTED = 6
const m__PC_FILESIZEBITS = 13
const m__PC_LINK_MAX = 0
const m__PC_MAX_CANON = 1
const m__PC_MAX_INPUT = 2
const m__PC_NAME_MAX = 3
const m__PC_NO_TRUNC = 7
const m__PC_PATH_MAX = 4
const m__PC_PIPE_BUF = 5
const m__PC_PRIO_IO = 11
const m__PC_REC_INCR_XFER_SIZE = 14
const m__PC_REC_MAX_XFER_SIZE = 15
const m__PC_REC_MIN_XFER_SIZE = 16
const m__PC_REC_XFER_ALIGN = 17
const m__PC_SOCK_MAXBUF = 12
const m__PC_SYMLINK_MAX = 19
const m__PC_SYNC_IO = 9
const m__PC_VDISABLE = 8
const m__POSIX_LINK_MAX = 8
const m__POSIX_MAX_CANON = 255
const m__POSIX_MAX_INPUT = 255

func x_fpathconf(tls *TLS, fd int32, name int32) (r int64) {
	if uint64(name) >= Uint64FromInt64(42)/Uint64FromInt64(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	}
	return int64(_values[name])
}

var _values = [21]int16{
	0:  int16(m__POSIX_LINK_MAX),
	1:  int16(m__POSIX_MAX_CANON),
	2:  int16(m__POSIX_MAX_INPUT),
	3:  int16(m_NAME_MAX),
	4:  int16(m_PATH_MAX),
	5:  int16(m_PIPE_BUF),
	6:  int16(1),
	7:  int16(1),
	8:  int16(0),
	9:  int16(1),
	10: int16(-int32(1)),
	11: int16(-int32(1)),
	12: int16(-int32(1)),
	13: int16(m_FILESIZEBITS),
	14: int16(4096),
	15: int16(4096),
	16: int16(4096),
	17: int16(4096),
	18: int16(4096),
	19: int16(-int32(1)),
	20: int16(1)}

const m__SC_AVPHYS_PAGES = 86
const m__SC_NPROCESSORS_CONF = 83
const m__SC_NPROCESSORS_ONLN = 84
const m__SC_PHYS_PAGES = 85

type Tsysinfo = struct {
	Fuptime       uint64
	Floads        [3]uint64
	Ftotalram     uint64
	Ffreeram      uint64
	Fsharedram    uint64
	Fbufferram    uint64
	Ftotalswap    uint64
	Ffreeswap     uint64
	Fprocs        uint16
	Fpad          uint16
	Ftotalhigh    uint64
	Ffreehigh     uint64
	Fmem_unit     uint32
	F__reserved   [256]int8
	F__ccgo_pad14 [4]byte
}

func x_get_nprocs_conf(tls *TLS) (r int32) {
	return int32(x_sysconf(tls, int32(m__SC_NPROCESSORS_CONF)))
}

func x_get_nprocs(tls *TLS) (r int32) {
	return int32(x_sysconf(tls, int32(m__SC_NPROCESSORS_ONLN)))
}

func x_get_phys_pages(tls *TLS) (r int64) {
	return x_sysconf(tls, int32(m__SC_PHYS_PAGES))
}

func x_get_avphys_pages(tls *TLS) (r int64) {
	return x_sysconf(tls, int32(m__SC_AVPHYS_PAGES))
}

func x_pathconf(tls *TLS, path uintptr, name int32) (r int64) {
	return x_fpathconf(tls, -int32(1), name)
}

const m_ARG_MAX = 131072
const m_COLL_WEIGHTS_MAX = 2
const m_DELAYTIMER_MAX = 2147483647
const m_FD_SETSIZE = 1024
const m_HOST_NAME_MAX = 255
const m_IOV_MAX = 1024
const m_MINSIGSTKSZ = 2048
const m_MQ_PRIO_MAX = 32768
const m_NZERO = 20
const m_PTHREAD_DESTRUCTOR_ITERATIONS = 4
const m_PTHREAD_KEYS_MAX = 128
const m_PTHREAD_STACK_MIN = 2048
const m_RE_DUP_MAX = 255
const m_RLIMIT_NOFILE = 7
const m_RLIMIT_NPROC = 6
const m_SEM_NSEMS_MAX = 256
const m_SEM_VALUE_MAX = 2147483647
const m_SIGSTKSZ = 8192
const m_SYMLOOP_MAX = 40
const m_TTY_NAME_MAX = 32
const m_TZNAME_MAX = 6
const m__NSIG = 65
const m__POSIX2_BC_BASE_MAX = 99
const m__POSIX2_BC_DIM_MAX = 2048
const m__POSIX2_BC_SCALE_MAX = 99
const m__POSIX2_BC_STRING_MAX = 1000
const m__POSIX_VERSION = 200809
const m__SC_2_CHAR_TERM = 95
const m__SC_2_C_BIND = 47
const m__SC_2_C_DEV = 48
const m__SC_2_FORT_DEV = 49
const m__SC_2_FORT_RUN = 50
const m__SC_2_LOCALEDEF = 52
const m__SC_2_PBS = 168
const m__SC_2_PBS_ACCOUNTING = 169
const m__SC_2_PBS_CHECKPOINT = 175
const m__SC_2_PBS_LOCATE = 170
const m__SC_2_PBS_MESSAGE = 171
const m__SC_2_PBS_TRACK = 172
const m__SC_2_SW_DEV = 51
const m__SC_2_UPE = 97
const m__SC_2_VERSION = 46
const m__SC_ADVISORY_INFO = 132
const m__SC_AIO_LISTIO_MAX = 23
const m__SC_AIO_MAX = 24
const m__SC_AIO_PRIO_DELTA_MAX = 25
const m__SC_ARG_MAX = 0
const m__SC_ASYNCHRONOUS_IO = 12
const m__SC_ATEXIT_MAX = 87
const m__SC_BARRIERS = 133
const m__SC_BC_BASE_MAX = 36
const m__SC_BC_DIM_MAX = 37
const m__SC_BC_SCALE_MAX = 38
const m__SC_BC_STRING_MAX = 39
const m__SC_CHILD_MAX = 1
const m__SC_CLK_TCK = 2
const m__SC_CLOCK_SELECTION = 137
const m__SC_COLL_WEIGHTS_MAX = 40
const m__SC_CPUTIME = 138
const m__SC_DELAYTIMER_MAX = 26
const m__SC_EXPR_NEST_MAX = 42
const m__SC_FSYNC = 15
const m__SC_GETGR_R_SIZE_MAX = 69
const m__SC_GETPW_R_SIZE_MAX = 70
const m__SC_HOST_NAME_MAX = 180
const m__SC_IOV_MAX = 60
const m__SC_IPV6 = 235
const m__SC_JOB_CONTROL = 7
const m__SC_LINE_MAX = 43
const m__SC_LOGIN_NAME_MAX = 71
const m__SC_MAPPED_FILES = 16
const m__SC_MEMLOCK = 17
const m__SC_MEMLOCK_RANGE = 18
const m__SC_MEMORY_PROTECTION = 19
const m__SC_MESSAGE_PASSING = 20
const m__SC_MINSIGSTKSZ = 249
const m__SC_MONOTONIC_CLOCK = 149
const m__SC_MQ_OPEN_MAX = 27
const m__SC_MQ_PRIO_MAX = 28
const m__SC_NGROUPS_MAX = 3
const m__SC_NZERO = 109
const m__SC_OPEN_MAX = 4
const m__SC_PAGE_SIZE = 30
const m__SC_PASS_MAX = 88
const m__SC_PRIORITIZED_IO = 13
const m__SC_PRIORITY_SCHEDULING = 10
const m__SC_RAW_SOCKETS = 236
const m__SC_READER_WRITER_LOCKS = 153
const m__SC_REALTIME_SIGNALS = 9
const m__SC_REGEXP = 155
const m__SC_RE_DUP_MAX = 44
const m__SC_RTSIG_MAX = 31
const m__SC_SAVED_IDS = 8
const m__SC_SEMAPHORES = 21
const m__SC_SEM_NSEMS_MAX = 32
const m__SC_SEM_VALUE_MAX = 33
const m__SC_SHARED_MEMORY_OBJECTS = 22
const m__SC_SHELL = 157
const m__SC_SIGQUEUE_MAX = 34
const m__SC_SIGSTKSZ = 250
const m__SC_SPAWN = 159
const m__SC_SPIN_LOCKS = 154
const m__SC_SPORADIC_SERVER = 160
const m__SC_SS_REPL_MAX = 241
const m__SC_STREAMS = 174
const m__SC_STREAM_MAX = 5
const m__SC_SYMLOOP_MAX = 173
const m__SC_SYNCHRONIZED_IO = 14
const m__SC_THREADS = 67
const m__SC_THREAD_ATTR_STACKADDR = 77
const m__SC_THREAD_ATTR_STACKSIZE = 78
const m__SC_THREAD_CPUTIME = 139
const m__SC_THREAD_DESTRUCTOR_ITERATIONS = 73
const m__SC_THREAD_KEYS_MAX = 74
const m__SC_THREAD_PRIORITY_SCHEDULING = 79
const m__SC_THREAD_PRIO_INHERIT = 80
const m__SC_THREAD_PRIO_PROTECT = 81
const m__SC_THREAD_PROCESS_SHARED = 82
const m__SC_THREAD_ROBUST_PRIO_INHERIT = 247
const m__SC_THREAD_ROBUST_PRIO_PROTECT = 248
const m__SC_THREAD_SAFE_FUNCTIONS = 68
const m__SC_THREAD_SPORADIC_SERVER = 161
const m__SC_THREAD_STACK_MIN = 75
const m__SC_THREAD_THREADS_MAX = 76
const m__SC_TIMEOUTS = 164
const m__SC_TIMERS = 11
const m__SC_TIMER_MAX = 35
const m__SC_TRACE = 181
const m__SC_TRACE_EVENT_FILTER = 182
const m__SC_TRACE_EVENT_NAME_MAX = 242
const m__SC_TRACE_INHERIT = 183
const m__SC_TRACE_LOG = 184
const m__SC_TRACE_NAME_MAX = 243
const m__SC_TRACE_SYS_MAX = 244
const m__SC_TRACE_USER_EVENT_MAX = 245
const m__SC_TTY_NAME_MAX = 72
const m__SC_TYPED_MEMORY_OBJECTS = 165
const m__SC_TZNAME_MAX = 6
const m__SC_V6_ILP32_OFF32 = 176
const m__SC_V6_ILP32_OFFBIG = 177
const m__SC_V6_LP64_OFF64 = 178
const m__SC_V6_LPBIG_OFFBIG = 179
const m__SC_V7_ILP32_OFF32 = 237
const m__SC_V7_ILP32_OFFBIG = 238
const m__SC_V7_LP64_OFF64 = 239
const m__SC_V7_LPBIG_OFFBIG = 240
const m__SC_VERSION = 29
const m__SC_XBS5_ILP32_OFF32 = 125
const m__SC_XBS5_ILP32_OFFBIG = 126
const m__SC_XBS5_LP64_OFF64 = 127
const m__SC_XBS5_LPBIG_OFFBIG = 128
const m__SC_XOPEN_CRYPT = 92
const m__SC_XOPEN_ENH_I18N = 93
const m__SC_XOPEN_LEGACY = 129
const m__SC_XOPEN_REALTIME = 130
const m__SC_XOPEN_REALTIME_THREADS = 131
const m__SC_XOPEN_SHM = 94
const m__SC_XOPEN_STREAMS = 246
const m__SC_XOPEN_UNIX = 91
const m__SC_XOPEN_VERSION = 89
const m__SC_XOPEN_XCU_VERSION = 90
const m__SC_XOPEN_XPG2 = 98
const m__SC_XOPEN_XPG3 = 99
const m__SC_XOPEN_XPG4 = 100
const m__XOPEN_VERSION = 700
const m___LONG_MAX = 9223372036854775807

type Tsuseconds_t = int64

type Ttimeval = struct {
	Ftv_sec  Ttime_t
	Ftv_usec Tsuseconds_t
}

type Tfd_mask = uint64

type Tfd_set = struct {
	Ffds_bits [16]uint64
}

type Titimerval = struct {
	Fit_interval Ttimeval
	Fit_value    Ttimeval
}

type Tid_t = uint32

type Trlim_t = uint64

type Trlimit = struct {
	Frlim_cur Trlim_t
	Frlim_max Trlim_t
}

type Trusage = struct {
	Fru_utime    Ttimeval
	Fru_stime    Ttimeval
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
	F__reserved  [16]int64
}

func x_sysconf(tls *TLS, name int32) (r int64) {
	bp := tls.Alloc(512) /* tlsAllocs 512 maxValist 0 */
	defer tls.Free(512)
	var cnt int32
	var i int32
	var mem uint64
	var val int64
	var _ /* lim at bp+0 */ Trlimit
	var _ /* set at bp+16 */ [128]uint8
	var _ /* si at bp+144 */ Tsysinfo
	var v1 uint64
	var v2 int32
	var v5 uint64
	var p3 uintptr
	if uint64(name) >= Uint64FromInt64(502)/Uint64FromInt64(2) || !(_values1[name] != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	} else {
		if int32(_values1[name]) >= -int32(1) {
			return int64(_values1[name])
		} else {
			if int32(_values1[name]) < -int32(256) {
				x_getrlimit(tls, int32(_values1[name])&int32(16383), bp)
				if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur == ^Uint64FromUint64(0) {
					return int64(-int32(1))
				}
				if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur > uint64(0x7fffffffffffffff) {
					v1 = uint64(0x7fffffffffffffff)
				} else {
					v1 = (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur
				}
				return int64(v1)
			}
		}
	}
	switch int32(uint8(_values1[name])) {
	case (-Int32FromInt32(256) | Int32FromInt32(1)) & Int32FromInt32(255):
		return int64(200809)
	case (-Int32FromInt32(256) | Int32FromInt32(2)) & Int32FromInt32(255):
		return int64(m_ARG_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(3)) & Int32FromInt32(255):
		return int64(m_MQ_PRIO_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(4)) & Int32FromInt32(255):
		return int64(m_PAGESIZE)
	case (-Int32FromInt32(256) | Int32FromInt32(5)) & Int32FromInt32(255):
		return int64(m_SEM_VALUE_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(11)) & Int32FromInt32(255):
		return int64(m_DELAYTIMER_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(6)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(7)) & Int32FromInt32(255):
		*(*[128]uint8)(unsafe.Pointer(bp + 16)) = [128]uint8{
			0: uint8(1)}
		___syscall3(tls, int64(204), int64(Int32FromInt32(0)), int64(Uint64FromInt64(128)), int64(bp+16))
		v2 = Int32FromInt32(0)
		cnt = v2
		i = v2
		for ; uint64(i) < uint64(128); i++ {
			for (*(*[128]uint8)(unsafe.Pointer(bp + 16)))[i] != 0 {
				goto _4
			_4:
				p3 = bp + 16 + uintptr(i)
				*(*uint8)(unsafe.Pointer(p3)) = uint8(int32(*(*uint8)(unsafe.Pointer(p3))) & (int32((*(*[128]uint8)(unsafe.Pointer(bp + 16)))[i]) - Int32FromInt32(1)))
				cnt++
			}
		}
		return int64(cnt)
	case (-Int32FromInt32(256) | Int32FromInt32(8)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(9)) & Int32FromInt32(255):
		x___lsysinfo(tls, bp+144)
		if !((*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit != 0) {
			(*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit = uint32(1)
		}
		if name == int32(m__SC_PHYS_PAGES) {
			mem = (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Ftotalram
		} else {
			mem = (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Ffreeram + (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fbufferram
		}
		mem = mem * uint64((*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit)
		mem = mem / Uint64FromInt32(m_PAGESIZE)
		if mem > uint64(0x7fffffffffffffff) {
			v5 = uint64(0x7fffffffffffffff)
		} else {
			v5 = mem
		}
		return int64(v5)
	case (-Int32FromInt32(256) | Int32FromInt32(12)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(13)) & Int32FromInt32(255):
		val = int64(x___getauxval(tls, uint64(m_AT_MINSIGSTKSZ)))
		if val < int64(m_MINSIGSTKSZ) {
			val = int64(m_MINSIGSTKSZ)
		}
		if int32(_values1[name]) == -Int32FromInt32(256)|Int32FromInt32(13) {
			val = val + int64(Int32FromInt32(m_SIGSTKSZ)-Int32FromInt32(m_MINSIGSTKSZ))
		}
		return val
	case (-Int32FromInt32(256) | Int32FromInt32(10)) & Int32FromInt32(255):
		return int64(0)
	}
	return int64(_values1[name])
}

var _values1 = [251]int16{
	0:   int16(-Int32FromInt32(256) | Int32FromInt32(2)),
	1:   int16(-Int32FromInt32(32768) | Int32FromInt32(m_RLIMIT_NPROC)),
	2:   int16(100),
	3:   int16(32),
	4:   int16(-Int32FromInt32(32768) | Int32FromInt32(m_RLIMIT_NOFILE)),
	5:   int16(-int32(1)),
	6:   int16(m_TZNAME_MAX),
	7:   int16(1),
	8:   int16(1),
	9:   int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	10:  int16(-int32(1)),
	11:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	12:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	13:  int16(-int32(1)),
	14:  int16(-int32(1)),
	15:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	16:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	17:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	18:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	19:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	20:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	21:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	22:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	23:  int16(-int32(1)),
	24:  int16(-int32(1)),
	25:  int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	26:  int16(-Int32FromInt32(256) | Int32FromInt32(11)),
	27:  int16(-int32(1)),
	28:  int16(-Int32FromInt32(256) | Int32FromInt32(3)),
	29:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	30:  int16(-Int32FromInt32(256) | Int32FromInt32(4)),
	31:  int16(Int32FromInt32(m__NSIG) - Int32FromInt32(1) - Int32FromInt32(31) - Int32FromInt32(3)),
	32:  int16(m_SEM_NSEMS_MAX),
	33:  int16(-Int32FromInt32(256) | Int32FromInt32(5)),
	34:  int16(-int32(1)),
	35:  int16(-int32(1)),
	36:  int16(m__POSIX2_BC_BASE_MAX),
	37:  int16(m__POSIX2_BC_DIM_MAX),
	38:  int16(m__POSIX2_BC_SCALE_MAX),
	39:  int16(m__POSIX2_BC_STRING_MAX),
	40:  int16(m_COLL_WEIGHTS_MAX),
	42:  int16(-int32(1)),
	43:  int16(-int32(1)),
	44:  int16(m_RE_DUP_MAX),
	46:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	47:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	48:  int16(-int32(1)),
	49:  int16(-int32(1)),
	50:  int16(-int32(1)),
	51:  int16(-int32(1)),
	52:  int16(-int32(1)),
	60:  int16(m_IOV_MAX),
	67:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	68:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	69:  int16(-int32(1)),
	70:  int16(-int32(1)),
	71:  int16(256),
	72:  int16(m_TTY_NAME_MAX),
	73:  int16(m_PTHREAD_DESTRUCTOR_ITERATIONS),
	74:  int16(m_PTHREAD_KEYS_MAX),
	75:  int16(m_PTHREAD_STACK_MIN),
	76:  int16(-int32(1)),
	77:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	78:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	79:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	80:  int16(-int32(1)),
	81:  int16(-int32(1)),
	82:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	83:  int16(-Int32FromInt32(256) | Int32FromInt32(6)),
	84:  int16(-Int32FromInt32(256) | Int32FromInt32(7)),
	85:  int16(-Int32FromInt32(256) | Int32FromInt32(8)),
	86:  int16(-Int32FromInt32(256) | Int32FromInt32(9)),
	87:  int16(-int32(1)),
	88:  int16(-int32(1)),
	89:  int16(m__XOPEN_VERSION),
	90:  int16(m__XOPEN_VERSION),
	91:  int16(1),
	92:  int16(-int32(1)),
	93:  int16(1),
	94:  int16(1),
	95:  int16(-int32(1)),
	97:  int16(-int32(1)),
	98:  int16(-int32(1)),
	99:  int16(-int32(1)),
	100: int16(-int32(1)),
	109: int16(m_NZERO),
	125: int16(-int32(1)),
	126: int16(-int32(1)),
	127: int16(1),
	128: int16(-int32(1)),
	129: int16(-int32(1)),
	130: int16(-int32(1)),
	131: int16(-int32(1)),
	132: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	133: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	137: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	138: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	139: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	149: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	153: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	154: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	155: int16(1),
	157: int16(1),
	159: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	160: int16(-int32(1)),
	161: int16(-int32(1)),
	164: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	165: int16(-int32(1)),
	168: int16(-int32(1)),
	169: int16(-int32(1)),
	170: int16(-int32(1)),
	171: int16(-int32(1)),
	172: int16(-int32(1)),
	173: int16(m_SYMLOOP_MAX),
	174: int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	175: int16(-int32(1)),
	176: int16(-int32(1)),
	177: int16(-int32(1)),
	178: int16(1),
	179: int16(-int32(1)),
	180: int16(m_HOST_NAME_MAX),
	181: int16(-int32(1)),
	182: int16(-int32(1)),
	183: int16(-int32(1)),
	184: int16(-int32(1)),
	235: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	236: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	237: int16(-int32(1)),
	238: int16(-int32(1)),
	239: int16(1),
	240: int16(-int32(1)),
	241: int16(-int32(1)),
	242: int16(-int32(1)),
	243: int16(-int32(1)),
	244: int16(-int32(1)),
	245: int16(-int32(1)),
	246: int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	247: int16(-int32(1)),
	248: int16(-int32(1)),
	249: int16(-Int32FromInt32(256) | Int32FromInt32(12)),
	250: int16(-Int32FromInt32(256) | Int32FromInt32(13))}

type Tcrypt_data = struct {
	Finitialized int32
	F__buf       [256]int8
}

func x_crypt(tls *TLS, key uintptr, salt uintptr) (r uintptr) {
	return x___crypt_r(tls, key, salt, uintptr(unsafe.Pointer(&_buf)))
}

/* This buffer is sufficiently large for all
 * currently-supported hash types. It needs to be updated if
 * longer hashes are added. The cast to struct crypt_data * is
 * purely to meet the public API requirements of the crypt_r
 * function; the implementation of crypt_r uses the object
 * purely as a char buffer. */
var _buf [128]int8

const m_BF_N = 16

type TBF_word = uint32

type TBF_word_signed = int32

/* Number of Blowfish rounds, this is also hardcoded into a few places */

type TBF_key = [18]TBF_word

type TBF_ctx = struct {
	FPS [0][1042]TBF_word
	Fs  struct {
		FP TBF_key
		FS [4][256]TBF_word
	}
}

/*
 * Magic IV for 64 Blowfish encryptions that we do at the end.
 * The string is "OrpheanBeholderScryDoubt" on big-endian.
 */
var _BF_magic_w = [6]TBF_word{
	0: uint32(0x4F727068),
	1: uint32(0x65616E42),
	2: uint32(0x65686F6C),
	3: uint32(0x64657253),
	4: uint32(0x63727944),
	5: uint32(0x6F756274)}

/*
 * P-box and S-box tables initialized with digits of Pi.
 */
var _BF_init_state = *(*TBF_ctx)(unsafe.Pointer(&struct {
	FP TBF_key
	FS [4][256]TBF_word
}{FP: TBF_key{
	0:  uint32(0x243f6a88),
	1:  uint32(0x85a308d3),
	2:  uint32(0x13198a2e),
	3:  uint32(0x03707344),
	4:  uint32(0xa4093822),
	5:  uint32(0x299f31d0),
	6:  uint32(0x082efa98),
	7:  uint32(0xec4e6c89),
	8:  uint32(0x452821e6),
	9:  uint32(0x38d01377),
	10: uint32(0xbe5466cf),
	11: uint32(0x34e90c6c),
	12: uint32(0xc0ac29b7),
	13: uint32(0xc97c50dd),
	14: uint32(0x3f84d5b5),
	15: uint32(0xb5470917),
	16: uint32(0x9216d5d9),
	17: uint32(0x8979fb1b)}, FS: [4][256]TBF_word{
	0: {
		0:   uint32(0xd1310ba6),
		1:   uint32(0x98dfb5ac),
		2:   uint32(0x2ffd72db),
		3:   uint32(0xd01adfb7),
		4:   uint32(0xb8e1afed),
		5:   uint32(0x6a267e96),
		6:   uint32(0xba7c9045),
		7:   uint32(0xf12c7f99),
		8:   uint32(0x24a19947),
		9:   uint32(0xb3916cf7),
		10:  uint32(0x0801f2e2),
		11:  uint32(0x858efc16),
		12:  uint32(0x636920d8),
		13:  uint32(0x71574e69),
		14:  uint32(0xa458fea3),
		15:  uint32(0xf4933d7e),
		16:  uint32(0x0d95748f),
		17:  uint32(0x728eb658),
		18:  uint32(0x718bcd58),
		19:  uint32(0x82154aee),
		20:  uint32(0x7b54a41d),
		21:  uint32(0xc25a59b5),
		22:  uint32(0x9c30d539),
		23:  uint32(0x2af26013),
		24:  uint32(0xc5d1b023),
		25:  uint32(0x286085f0),
		26:  uint32(0xca417918),
		27:  uint32(0xb8db38ef),
		28:  uint32(0x8e79dcb0),
		29:  uint32(0x603a180e),
		30:  uint32(0x6c9e0e8b),
		31:  uint32(0xb01e8a3e),
		32:  uint32(0xd71577c1),
		33:  uint32(0xbd314b27),
		34:  uint32(0x78af2fda),
		35:  uint32(0x55605c60),
		36:  uint32(0xe65525f3),
		37:  uint32(0xaa55ab94),
		38:  uint32(0x57489862),
		39:  uint32(0x63e81440),
		40:  uint32(0x55ca396a),
		41:  uint32(0x2aab10b6),
		42:  uint32(0xb4cc5c34),
		43:  uint32(0x1141e8ce),
		44:  uint32(0xa15486af),
		45:  uint32(0x7c72e993),
		46:  uint32(0xb3ee1411),
		47:  uint32(0x636fbc2a),
		48:  uint32(0x2ba9c55d),
		49:  uint32(0x741831f6),
		50:  uint32(0xce5c3e16),
		51:  uint32(0x9b87931e),
		52:  uint32(0xafd6ba33),
		53:  uint32(0x6c24cf5c),
		54:  uint32(0x7a325381),
		55:  uint32(0x28958677),
		56:  uint32(0x3b8f4898),
		57:  uint32(0x6b4bb9af),
		58:  uint32(0xc4bfe81b),
		59:  uint32(0x66282193),
		60:  uint32(0x61d809cc),
		61:  uint32(0xfb21a991),
		62:  uint32(0x487cac60),
		63:  uint32(0x5dec8032),
		64:  uint32(0xef845d5d),
		65:  uint32(0xe98575b1),
		66:  uint32(0xdc262302),
		67:  uint32(0xeb651b88),
		68:  uint32(0x23893e81),
		69:  uint32(0xd396acc5),
		70:  uint32(0x0f6d6ff3),
		71:  uint32(0x83f44239),
		72:  uint32(0x2e0b4482),
		73:  uint32(0xa4842004),
		74:  uint32(0x69c8f04a),
		75:  uint32(0x9e1f9b5e),
		76:  uint32(0x21c66842),
		77:  uint32(0xf6e96c9a),
		78:  uint32(0x670c9c61),
		79:  uint32(0xabd388f0),
		80:  uint32(0x6a51a0d2),
		81:  uint32(0xd8542f68),
		82:  uint32(0x960fa728),
		83:  uint32(0xab5133a3),
		84:  uint32(0x6eef0b6c),
		85:  uint32(0x137a3be4),
		86:  uint32(0xba3bf050),
		87:  uint32(0x7efb2a98),
		88:  uint32(0xa1f1651d),
		89:  uint32(0x39af0176),
		90:  uint32(0x66ca593e),
		91:  uint32(0x82430e88),
		92:  uint32(0x8cee8619),
		93:  uint32(0x456f9fb4),
		94:  uint32(0x7d84a5c3),
		95:  uint32(0x3b8b5ebe),
		96:  uint32(0xe06f75d8),
		97:  uint32(0x85c12073),
		98:  uint32(0x401a449f),
		99:  uint32(0x56c16aa6),
		100: uint32(0x4ed3aa62),
		101: uint32(0x363f7706),
		102: uint32(0x1bfedf72),
		103: uint32(0x429b023d),
		104: uint32(0x37d0d724),
		105: uint32(0xd00a1248),
		106: uint32(0xdb0fead3),
		107: uint32(0x49f1c09b),
		108: uint32(0x075372c9),
		109: uint32(0x80991b7b),
		110: uint32(0x25d479d8),
		111: uint32(0xf6e8def7),
		112: uint32(0xe3fe501a),
		113: uint32(0xb6794c3b),
		114: uint32(0x976ce0bd),
		115: uint32(0x04c006ba),
		116: uint32(0xc1a94fb6),
		117: uint32(0x409f60c4),
		118: uint32(0x5e5c9ec2),
		119: uint32(0x196a2463),
		120: uint32(0x68fb6faf),
		121: uint32(0x3e6c53b5),
		122: uint32(0x1339b2eb),
		123: uint32(0x3b52ec6f),
		124: uint32(0x6dfc511f),
		125: uint32(0x9b30952c),
		126: uint32(0xcc814544),
		127: uint32(0xaf5ebd09),
		128: uint32(0xbee3d004),
		129: uint32(0xde334afd),
		130: uint32(0x660f2807),
		131: uint32(0x192e4bb3),
		132: uint32(0xc0cba857),
		133: uint32(0x45c8740f),
		134: uint32(0xd20b5f39),
		135: uint32(0xb9d3fbdb),
		136: uint32(0x5579c0bd),
		137: uint32(0x1a60320a),
		138: uint32(0xd6a100c6),
		139: uint32(0x402c7279),
		140: uint32(0x679f25fe),
		141: uint32(0xfb1fa3cc),
		142: uint32(0x8ea5e9f8),
		143: uint32(0xdb3222f8),
		144: uint32(0x3c7516df),
		145: uint32(0xfd616b15),
		146: uint32(0x2f501ec8),
		147: uint32(0xad0552ab),
		148: uint32(0x323db5fa),
		149: uint32(0xfd238760),
		150: uint32(0x53317b48),
		151: uint32(0x3e00df82),
		152: uint32(0x9e5c57bb),
		153: uint32(0xca6f8ca0),
		154: uint32(0x1a87562e),
		155: uint32(0xdf1769db),
		156: uint32(0xd542a8f6),
		157: uint32(0x287effc3),
		158: uint32(0xac6732c6),
		159: uint32(0x8c4f5573),
		160: uint32(0x695b27b0),
		161: uint32(0xbbca58c8),
		162: uint32(0xe1ffa35d),
		163: uint32(0xb8f011a0),
		164: uint32(0x10fa3d98),
		165: uint32(0xfd2183b8),
		166: uint32(0x4afcb56c),
		167: uint32(0x2dd1d35b),
		168: uint32(0x9a53e479),
		169: uint32(0xb6f84565),
		170: uint32(0xd28e49bc),
		171: uint32(0x4bfb9790),
		172: uint32(0xe1ddf2da),
		173: uint32(0xa4cb7e33),
		174: uint32(0x62fb1341),
		175: uint32(0xcee4c6e8),
		176: uint32(0xef20cada),
		177: uint32(0x36774c01),
		178: uint32(0xd07e9efe),
		179: uint32(0x2bf11fb4),
		180: uint32(0x95dbda4d),
		181: uint32(0xae909198),
		182: uint32(0xeaad8e71),
		183: uint32(0x6b93d5a0),
		184: uint32(0xd08ed1d0),
		185: uint32(0xafc725e0),
		186: uint32(0x8e3c5b2f),
		187: uint32(0x8e7594b7),
		188: uint32(0x8ff6e2fb),
		189: uint32(0xf2122b64),
		190: uint32(0x8888b812),
		191: uint32(0x900df01c),
		192: uint32(0x4fad5ea0),
		193: uint32(0x688fc31c),
		194: uint32(0xd1cff191),
		195: uint32(0xb3a8c1ad),
		196: uint32(0x2f2f2218),
		197: uint32(0xbe0e1777),
		198: uint32(0xea752dfe),
		199: uint32(0x8b021fa1),
		200: uint32(0xe5a0cc0f),
		201: uint32(0xb56f74e8),
		202: uint32(0x18acf3d6),
		203: uint32(0xce89e299),
		204: uint32(0xb4a84fe0),
		205: uint32(0xfd13e0b7),
		206: uint32(0x7cc43b81),
		207: uint32(0xd2ada8d9),
		208: uint32(0x165fa266),
		209: uint32(0x80957705),
		210: uint32(0x93cc7314),
		211: uint32(0x211a1477),
		212: uint32(0xe6ad2065),
		213: uint32(0x77b5fa86),
		214: uint32(0xc75442f5),
		215: uint32(0xfb9d35cf),
		216: uint32(0xebcdaf0c),
		217: uint32(0x7b3e89a0),
		218: uint32(0xd6411bd3),
		219: uint32(0xae1e7e49),
		220: uint32(0x00250e2d),
		221: uint32(0x2071b35e),
		222: uint32(0x226800bb),
		223: uint32(0x57b8e0af),
		224: uint32(0x2464369b),
		225: uint32(0xf009b91e),
		226: uint32(0x5563911d),
		227: uint32(0x59dfa6aa),
		228: uint32(0x78c14389),
		229: uint32(0xd95a537f),
		230: uint32(0x207d5ba2),
		231: uint32(0x02e5b9c5),
		232: uint32(0x83260376),
		233: uint32(0x6295cfa9),
		234: uint32(0x11c81968),
		235: uint32(0x4e734a41),
		236: uint32(0xb3472dca),
		237: uint32(0x7b14a94a),
		238: uint32(0x1b510052),
		239: uint32(0x9a532915),
		240: uint32(0xd60f573f),
		241: uint32(0xbc9bc6e4),
		242: uint32(0x2b60a476),
		243: uint32(0x81e67400),
		244: uint32(0x08ba6fb5),
		245: uint32(0x571be91f),
		246: uint32(0xf296ec6b),
		247: uint32(0x2a0dd915),
		248: uint32(0xb6636521),
		249: uint32(0xe7b9f9b6),
		250: uint32(0xff34052e),
		251: uint32(0xc5855664),
		252: uint32(0x53b02d5d),
		253: uint32(0xa99f8fa1),
		254: uint32(0x08ba4799),
		255: uint32(0x6e85076a)},
	1: {
		0:   uint32(0x4b7a70e9),
		1:   uint32(0xb5b32944),
		2:   uint32(0xdb75092e),
		3:   uint32(0xc4192623),
		4:   uint32(0xad6ea6b0),
		5:   uint32(0x49a7df7d),
		6:   uint32(0x9cee60b8),
		7:   uint32(0x8fedb266),
		8:   uint32(0xecaa8c71),
		9:   uint32(0x699a17ff),
		10:  uint32(0x5664526c),
		11:  uint32(0xc2b19ee1),
		12:  uint32(0x193602a5),
		13:  uint32(0x75094c29),
		14:  uint32(0xa0591340),
		15:  uint32(0xe4183a3e),
		16:  uint32(0x3f54989a),
		17:  uint32(0x5b429d65),
		18:  uint32(0x6b8fe4d6),
		19:  uint32(0x99f73fd6),
		20:  uint32(0xa1d29c07),
		21:  uint32(0xefe830f5),
		22:  uint32(0x4d2d38e6),
		23:  uint32(0xf0255dc1),
		24:  uint32(0x4cdd2086),
		25:  uint32(0x8470eb26),
		26:  uint32(0x6382e9c6),
		27:  uint32(0x021ecc5e),
		28:  uint32(0x09686b3f),
		29:  uint32(0x3ebaefc9),
		30:  uint32(0x3c971814),
		31:  uint32(0x6b6a70a1),
		32:  uint32(0x687f3584),
		33:  uint32(0x52a0e286),
		34:  uint32(0xb79c5305),
		35:  uint32(0xaa500737),
		36:  uint32(0x3e07841c),
		37:  uint32(0x7fdeae5c),
		38:  uint32(0x8e7d44ec),
		39:  uint32(0x5716f2b8),
		40:  uint32(0xb03ada37),
		41:  uint32(0xf0500c0d),
		42:  uint32(0xf01c1f04),
		43:  uint32(0x0200b3ff),
		44:  uint32(0xae0cf51a),
		45:  uint32(0x3cb574b2),
		46:  uint32(0x25837a58),
		47:  uint32(0xdc0921bd),
		48:  uint32(0xd19113f9),
		49:  uint32(0x7ca92ff6),
		50:  uint32(0x94324773),
		51:  uint32(0x22f54701),
		52:  uint32(0x3ae5e581),
		53:  uint32(0x37c2dadc),
		54:  uint32(0xc8b57634),
		55:  uint32(0x9af3dda7),
		56:  uint32(0xa9446146),
		57:  uint32(0x0fd0030e),
		58:  uint32(0xecc8c73e),
		59:  uint32(0xa4751e41),
		60:  uint32(0xe238cd99),
		61:  uint32(0x3bea0e2f),
		62:  uint32(0x3280bba1),
		63:  uint32(0x183eb331),
		64:  uint32(0x4e548b38),
		65:  uint32(0x4f6db908),
		66:  uint32(0x6f420d03),
		67:  uint32(0xf60a04bf),
		68:  uint32(0x2cb81290),
		69:  uint32(0x24977c79),
		70:  uint32(0x5679b072),
		71:  uint32(0xbcaf89af),
		72:  uint32(0xde9a771f),
		73:  uint32(0xd9930810),
		74:  uint32(0xb38bae12),
		75:  uint32(0xdccf3f2e),
		76:  uint32(0x5512721f),
		77:  uint32(0x2e6b7124),
		78:  uint32(0x501adde6),
		79:  uint32(0x9f84cd87),
		80:  uint32(0x7a584718),
		81:  uint32(0x7408da17),
		82:  uint32(0xbc9f9abc),
		83:  uint32(0xe94b7d8c),
		84:  uint32(0xec7aec3a),
		85:  uint32(0xdb851dfa),
		86:  uint32(0x63094366),
		87:  uint32(0xc464c3d2),
		88:  uint32(0xef1c1847),
		89:  uint32(0x3215d908),
		90:  uint32(0xdd433b37),
		91:  uint32(0x24c2ba16),
		92:  uint32(0x12a14d43),
		93:  uint32(0x2a65c451),
		94:  uint32(0x50940002),
		95:  uint32(0x133ae4dd),
		96:  uint32(0x71dff89e),
		97:  uint32(0x10314e55),
		98:  uint32(0x81ac77d6),
		99:  uint32(0x5f11199b),
		100: uint32(0x043556f1),
		101: uint32(0xd7a3c76b),
		102: uint32(0x3c11183b),
		103: uint32(0x5924a509),
		104: uint32(0xf28fe6ed),
		105: uint32(0x97f1fbfa),
		106: uint32(0x9ebabf2c),
		107: uint32(0x1e153c6e),
		108: uint32(0x86e34570),
		109: uint32(0xeae96fb1),
		110: uint32(0x860e5e0a),
		111: uint32(0x5a3e2ab3),
		112: uint32(0x771fe71c),
		113: uint32(0x4e3d06fa),
		114: uint32(0x2965dcb9),
		115: uint32(0x99e71d0f),
		116: uint32(0x803e89d6),
		117: uint32(0x5266c825),
		118: uint32(0x2e4cc978),
		119: uint32(0x9c10b36a),
		120: uint32(0xc6150eba),
		121: uint32(0x94e2ea78),
		122: uint32(0xa5fc3c53),
		123: uint32(0x1e0a2df4),
		124: uint32(0xf2f74ea7),
		125: uint32(0x361d2b3d),
		126: uint32(0x1939260f),
		127: uint32(0x19c27960),
		128: uint32(0x5223a708),
		129: uint32(0xf71312b6),
		130: uint32(0xebadfe6e),
		131: uint32(0xeac31f66),
		132: uint32(0xe3bc4595),
		133: uint32(0xa67bc883),
		134: uint32(0xb17f37d1),
		135: uint32(0x018cff28),
		136: uint32(0xc332ddef),
		137: uint32(0xbe6c5aa5),
		138: uint32(0x65582185),
		139: uint32(0x68ab9802),
		140: uint32(0xeecea50f),
		141: uint32(0xdb2f953b),
		142: uint32(0x2aef7dad),
		143: uint32(0x5b6e2f84),
		144: uint32(0x1521b628),
		145: uint32(0x29076170),
		146: uint32(0xecdd4775),
		147: uint32(0x619f1510),
		148: uint32(0x13cca830),
		149: uint32(0xeb61bd96),
		150: uint32(0x0334fe1e),
		151: uint32(0xaa0363cf),
		152: uint32(0xb5735c90),
		153: uint32(0x4c70a239),
		154: uint32(0xd59e9e0b),
		155: uint32(0xcbaade14),
		156: uint32(0xeecc86bc),
		157: uint32(0x60622ca7),
		158: uint32(0x9cab5cab),
		159: uint32(0xb2f3846e),
		160: uint32(0x648b1eaf),
		161: uint32(0x19bdf0ca),
		162: uint32(0xa02369b9),
		163: uint32(0x655abb50),
		164: uint32(0x40685a32),
		165: uint32(0x3c2ab4b3),
		166: uint32(0x319ee9d5),
		167: uint32(0xc021b8f7),
		168: uint32(0x9b540b19),
		169: uint32(0x875fa099),
		170: uint32(0x95f7997e),
		171: uint32(0x623d7da8),
		172: uint32(0xf837889a),
		173: uint32(0x97e32d77),
		174: uint32(0x11ed935f),
		175: uint32(0x16681281),
		176: uint32(0x0e358829),
		177: uint32(0xc7e61fd6),
		178: uint32(0x96dedfa1),
		179: uint32(0x7858ba99),
		180: uint32(0x57f584a5),
		181: uint32(0x1b227263),
		182: uint32(0x9b83c3ff),
		183: uint32(0x1ac24696),
		184: uint32(0xcdb30aeb),
		185: uint32(0x532e3054),
		186: uint32(0x8fd948e4),
		187: uint32(0x6dbc3128),
		188: uint32(0x58ebf2ef),
		189: uint32(0x34c6ffea),
		190: uint32(0xfe28ed61),
		191: uint32(0xee7c3c73),
		192: uint32(0x5d4a14d9),
		193: uint32(0xe864b7e3),
		194: uint32(0x42105d14),
		195: uint32(0x203e13e0),
		196: uint32(0x45eee2b6),
		197: uint32(0xa3aaabea),
		198: uint32(0xdb6c4f15),
		199: uint32(0xfacb4fd0),
		200: uint32(0xc742f442),
		201: uint32(0xef6abbb5),
		202: uint32(0x654f3b1d),
		203: uint32(0x41cd2105),
		204: uint32(0xd81e799e),
		205: uint32(0x86854dc7),
		206: uint32(0xe44b476a),
		207: uint32(0x3d816250),
		208: uint32(0xcf62a1f2),
		209: uint32(0x5b8d2646),
		210: uint32(0xfc8883a0),
		211: uint32(0xc1c7b6a3),
		212: uint32(0x7f1524c3),
		213: uint32(0x69cb7492),
		214: uint32(0x47848a0b),
		215: uint32(0x5692b285),
		216: uint32(0x095bbf00),
		217: uint32(0xad19489d),
		218: uint32(0x1462b174),
		219: uint32(0x23820e00),
		220: uint32(0x58428d2a),
		221: uint32(0x0c55f5ea),
		222: uint32(0x1dadf43e),
		223: uint32(0x233f7061),
		224: uint32(0x3372f092),
		225: uint32(0x8d937e41),
		226: uint32(0xd65fecf1),
		227: uint32(0x6c223bdb),
		228: uint32(0x7cde3759),
		229: uint32(0xcbee7460),
		230: uint32(0x4085f2a7),
		231: uint32(0xce77326e),
		232: uint32(0xa6078084),
		233: uint32(0x19f8509e),
		234: uint32(0xe8efd855),
		235: uint32(0x61d99735),
		236: uint32(0xa969a7aa),
		237: uint32(0xc50c06c2),
		238: uint32(0x5a04abfc),
		239: uint32(0x800bcadc),
		240: uint32(0x9e447a2e),
		241: uint32(0xc3453484),
		242: uint32(0xfdd56705),
		243: uint32(0x0e1e9ec9),
		244: uint32(0xdb73dbd3),
		245: uint32(0x105588cd),
		246: uint32(0x675fda79),
		247: uint32(0xe3674340),
		248: uint32(0xc5c43465),
		249: uint32(0x713e38d8),
		250: uint32(0x3d28f89e),
		251: uint32(0xf16dff20),
		252: uint32(0x153e21e7),
		253: uint32(0x8fb03d4a),
		254: uint32(0xe6e39f2b),
		255: uint32(0xdb83adf7)},
	2: {
		0:   uint32(0xe93d5a68),
		1:   uint32(0x948140f7),
		2:   uint32(0xf64c261c),
		3:   uint32(0x94692934),
		4:   uint32(0x411520f7),
		5:   uint32(0x7602d4f7),
		6:   uint32(0xbcf46b2e),
		7:   uint32(0xd4a20068),
		8:   uint32(0xd4082471),
		9:   uint32(0x3320f46a),
		10:  uint32(0x43b7d4b7),
		11:  uint32(0x500061af),
		12:  uint32(0x1e39f62e),
		13:  uint32(0x97244546),
		14:  uint32(0x14214f74),
		15:  uint32(0xbf8b8840),
		16:  uint32(0x4d95fc1d),
		17:  uint32(0x96b591af),
		18:  uint32(0x70f4ddd3),
		19:  uint32(0x66a02f45),
		20:  uint32(0xbfbc09ec),
		21:  uint32(0x03bd9785),
		22:  uint32(0x7fac6dd0),
		23:  uint32(0x31cb8504),
		24:  uint32(0x96eb27b3),
		25:  uint32(0x55fd3941),
		26:  uint32(0xda2547e6),
		27:  uint32(0xabca0a9a),
		28:  uint32(0x28507825),
		29:  uint32(0x530429f4),
		30:  uint32(0x0a2c86da),
		31:  uint32(0xe9b66dfb),
		32:  uint32(0x68dc1462),
		33:  uint32(0xd7486900),
		34:  uint32(0x680ec0a4),
		35:  uint32(0x27a18dee),
		36:  uint32(0x4f3ffea2),
		37:  uint32(0xe887ad8c),
		38:  uint32(0xb58ce006),
		39:  uint32(0x7af4d6b6),
		40:  uint32(0xaace1e7c),
		41:  uint32(0xd3375fec),
		42:  uint32(0xce78a399),
		43:  uint32(0x406b2a42),
		44:  uint32(0x20fe9e35),
		45:  uint32(0xd9f385b9),
		46:  uint32(0xee39d7ab),
		47:  uint32(0x3b124e8b),
		48:  uint32(0x1dc9faf7),
		49:  uint32(0x4b6d1856),
		50:  uint32(0x26a36631),
		51:  uint32(0xeae397b2),
		52:  uint32(0x3a6efa74),
		53:  uint32(0xdd5b4332),
		54:  uint32(0x6841e7f7),
		55:  uint32(0xca7820fb),
		56:  uint32(0xfb0af54e),
		57:  uint32(0xd8feb397),
		58:  uint32(0x454056ac),
		59:  uint32(0xba489527),
		60:  uint32(0x55533a3a),
		61:  uint32(0x20838d87),
		62:  uint32(0xfe6ba9b7),
		63:  uint32(0xd096954b),
		64:  uint32(0x55a867bc),
		65:  uint32(0xa1159a58),
		66:  uint32(0xcca92963),
		67:  uint32(0x99e1db33),
		68:  uint32(0xa62a4a56),
		69:  uint32(0x3f3125f9),
		70:  uint32(0x5ef47e1c),
		71:  uint32(0x9029317c),
		72:  uint32(0xfdf8e802),
		73:  uint32(0x04272f70),
		74:  uint32(0x80bb155c),
		75:  uint32(0x05282ce3),
		76:  uint32(0x95c11548),
		77:  uint32(0xe4c66d22),
		78:  uint32(0x48c1133f),
		79:  uint32(0xc70f86dc),
		80:  uint32(0x07f9c9ee),
		81:  uint32(0x41041f0f),
		82:  uint32(0x404779a4),
		83:  uint32(0x5d886e17),
		84:  uint32(0x325f51eb),
		85:  uint32(0xd59bc0d1),
		86:  uint32(0xf2bcc18f),
		87:  uint32(0x41113564),
		88:  uint32(0x257b7834),
		89:  uint32(0x602a9c60),
		90:  uint32(0xdff8e8a3),
		91:  uint32(0x1f636c1b),
		92:  uint32(0x0e12b4c2),
		93:  uint32(0x02e1329e),
		94:  uint32(0xaf664fd1),
		95:  uint32(0xcad18115),
		96:  uint32(0x6b2395e0),
		97:  uint32(0x333e92e1),
		98:  uint32(0x3b240b62),
		99:  uint32(0xeebeb922),
		100: uint32(0x85b2a20e),
		101: uint32(0xe6ba0d99),
		102: uint32(0xde720c8c),
		103: uint32(0x2da2f728),
		104: uint32(0xd0127845),
		105: uint32(0x95b794fd),
		106: uint32(0x647d0862),
		107: uint32(0xe7ccf5f0),
		108: uint32(0x5449a36f),
		109: uint32(0x877d48fa),
		110: uint32(0xc39dfd27),
		111: uint32(0xf33e8d1e),
		112: uint32(0x0a476341),
		113: uint32(0x992eff74),
		114: uint32(0x3a6f6eab),
		115: uint32(0xf4f8fd37),
		116: uint32(0xa812dc60),
		117: uint32(0xa1ebddf8),
		118: uint32(0x991be14c),
		119: uint32(0xdb6e6b0d),
		120: uint32(0xc67b5510),
		121: uint32(0x6d672c37),
		122: uint32(0x2765d43b),
		123: uint32(0xdcd0e804),
		124: uint32(0xf1290dc7),
		125: uint32(0xcc00ffa3),
		126: uint32(0xb5390f92),
		127: uint32(0x690fed0b),
		128: uint32(0x667b9ffb),
		129: uint32(0xcedb7d9c),
		130: uint32(0xa091cf0b),
		131: uint32(0xd9155ea3),
		132: uint32(0xbb132f88),
		133: uint32(0x515bad24),
		134: uint32(0x7b9479bf),
		135: uint32(0x763bd6eb),
		136: uint32(0x37392eb3),
		137: uint32(0xcc115979),
		138: uint32(0x8026e297),
		139: uint32(0xf42e312d),
		140: uint32(0x6842ada7),
		141: uint32(0xc66a2b3b),
		142: uint32(0x12754ccc),
		143: uint32(0x782ef11c),
		144: uint32(0x6a124237),
		145: uint32(0xb79251e7),
		146: uint32(0x06a1bbe6),
		147: uint32(0x4bfb6350),
		148: uint32(0x1a6b1018),
		149: uint32(0x11caedfa),
		150: uint32(0x3d25bdd8),
		151: uint32(0xe2e1c3c9),
		152: uint32(0x44421659),
		153: uint32(0x0a121386),
		154: uint32(0xd90cec6e),
		155: uint32(0xd5abea2a),
		156: uint32(0x64af674e),
		157: uint32(0xda86a85f),
		158: uint32(0xbebfe988),
		159: uint32(0x64e4c3fe),
		160: uint32(0x9dbc8057),
		161: uint32(0xf0f7c086),
		162: uint32(0x60787bf8),
		163: uint32(0x6003604d),
		164: uint32(0xd1fd8346),
		165: uint32(0xf6381fb0),
		166: uint32(0x7745ae04),
		167: uint32(0xd736fccc),
		168: uint32(0x83426b33),
		169: uint32(0xf01eab71),
		170: uint32(0xb0804187),
		171: uint32(0x3c005e5f),
		172: uint32(0x77a057be),
		173: uint32(0xbde8ae24),
		174: uint32(0x55464299),
		175: uint32(0xbf582e61),
		176: uint32(0x4e58f48f),
		177: uint32(0xf2ddfda2),
		178: uint32(0xf474ef38),
		179: uint32(0x8789bdc2),
		180: uint32(0x5366f9c3),
		181: uint32(0xc8b38e74),
		182: uint32(0xb475f255),
		183: uint32(0x46fcd9b9),
		184: uint32(0x7aeb2661),
		185: uint32(0x8b1ddf84),
		186: uint32(0x846a0e79),
		187: uint32(0x915f95e2),
		188: uint32(0x466e598e),
		189: uint32(0x20b45770),
		190: uint32(0x8cd55591),
		191: uint32(0xc902de4c),
		192: uint32(0xb90bace1),
		193: uint32(0xbb8205d0),
		194: uint32(0x11a86248),
		195: uint32(0x7574a99e),
		196: uint32(0xb77f19b6),
		197: uint32(0xe0a9dc09),
		198: uint32(0x662d09a1),
		199: uint32(0xc4324633),
		200: uint32(0xe85a1f02),
		201: uint32(0x09f0be8c),
		202: uint32(0x4a99a025),
		203: uint32(0x1d6efe10),
		204: uint32(0x1ab93d1d),
		205: uint32(0x0ba5a4df),
		206: uint32(0xa186f20f),
		207: uint32(0x2868f169),
		208: uint32(0xdcb7da83),
		209: uint32(0x573906fe),
		210: uint32(0xa1e2ce9b),
		211: uint32(0x4fcd7f52),
		212: uint32(0x50115e01),
		213: uint32(0xa70683fa),
		214: uint32(0xa002b5c4),
		215: uint32(0x0de6d027),
		216: uint32(0x9af88c27),
		217: uint32(0x773f8641),
		218: uint32(0xc3604c06),
		219: uint32(0x61a806b5),
		220: uint32(0xf0177a28),
		221: uint32(0xc0f586e0),
		222: uint32(0x006058aa),
		223: uint32(0x30dc7d62),
		224: uint32(0x11e69ed7),
		225: uint32(0x2338ea63),
		226: uint32(0x53c2dd94),
		227: uint32(0xc2c21634),
		228: uint32(0xbbcbee56),
		229: uint32(0x90bcb6de),
		230: uint32(0xebfc7da1),
		231: uint32(0xce591d76),
		232: uint32(0x6f05e409),
		233: uint32(0x4b7c0188),
		234: uint32(0x39720a3d),
		235: uint32(0x7c927c24),
		236: uint32(0x86e3725f),
		237: uint32(0x724d9db9),
		238: uint32(0x1ac15bb4),
		239: uint32(0xd39eb8fc),
		240: uint32(0xed545578),
		241: uint32(0x08fca5b5),
		242: uint32(0xd83d7cd3),
		243: uint32(0x4dad0fc4),
		244: uint32(0x1e50ef5e),
		245: uint32(0xb161e6f8),
		246: uint32(0xa28514d9),
		247: uint32(0x6c51133c),
		248: uint32(0x6fd5c7e7),
		249: uint32(0x56e14ec4),
		250: uint32(0x362abfce),
		251: uint32(0xddc6c837),
		252: uint32(0xd79a3234),
		253: uint32(0x92638212),
		254: uint32(0x670efa8e),
		255: uint32(0x406000e0)},
	3: {
		0:   uint32(0x3a39ce37),
		1:   uint32(0xd3faf5cf),
		2:   uint32(0xabc27737),
		3:   uint32(0x5ac52d1b),
		4:   uint32(0x5cb0679e),
		5:   uint32(0x4fa33742),
		6:   uint32(0xd3822740),
		7:   uint32(0x99bc9bbe),
		8:   uint32(0xd5118e9d),
		9:   uint32(0xbf0f7315),
		10:  uint32(0xd62d1c7e),
		11:  uint32(0xc700c47b),
		12:  uint32(0xb78c1b6b),
		13:  uint32(0x21a19045),
		14:  uint32(0xb26eb1be),
		15:  uint32(0x6a366eb4),
		16:  uint32(0x5748ab2f),
		17:  uint32(0xbc946e79),
		18:  uint32(0xc6a376d2),
		19:  uint32(0x6549c2c8),
		20:  uint32(0x530ff8ee),
		21:  uint32(0x468dde7d),
		22:  uint32(0xd5730a1d),
		23:  uint32(0x4cd04dc6),
		24:  uint32(0x2939bbdb),
		25:  uint32(0xa9ba4650),
		26:  uint32(0xac9526e8),
		27:  uint32(0xbe5ee304),
		28:  uint32(0xa1fad5f0),
		29:  uint32(0x6a2d519a),
		30:  uint32(0x63ef8ce2),
		31:  uint32(0x9a86ee22),
		32:  uint32(0xc089c2b8),
		33:  uint32(0x43242ef6),
		34:  uint32(0xa51e03aa),
		35:  uint32(0x9cf2d0a4),
		36:  uint32(0x83c061ba),
		37:  uint32(0x9be96a4d),
		38:  uint32(0x8fe51550),
		39:  uint32(0xba645bd6),
		40:  uint32(0x2826a2f9),
		41:  uint32(0xa73a3ae1),
		42:  uint32(0x4ba99586),
		43:  uint32(0xef5562e9),
		44:  uint32(0xc72fefd3),
		45:  uint32(0xf752f7da),
		46:  uint32(0x3f046f69),
		47:  uint32(0x77fa0a59),
		48:  uint32(0x80e4a915),
		49:  uint32(0x87b08601),
		50:  uint32(0x9b09e6ad),
		51:  uint32(0x3b3ee593),
		52:  uint32(0xe990fd5a),
		53:  uint32(0x9e34d797),
		54:  uint32(0x2cf0b7d9),
		55:  uint32(0x022b8b51),
		56:  uint32(0x96d5ac3a),
		57:  uint32(0x017da67d),
		58:  uint32(0xd1cf3ed6),
		59:  uint32(0x7c7d2d28),
		60:  uint32(0x1f9f25cf),
		61:  uint32(0xadf2b89b),
		62:  uint32(0x5ad6b472),
		63:  uint32(0x5a88f54c),
		64:  uint32(0xe029ac71),
		65:  uint32(0xe019a5e6),
		66:  uint32(0x47b0acfd),
		67:  uint32(0xed93fa9b),
		68:  uint32(0xe8d3c48d),
		69:  uint32(0x283b57cc),
		70:  uint32(0xf8d56629),
		71:  uint32(0x79132e28),
		72:  uint32(0x785f0191),
		73:  uint32(0xed756055),
		74:  uint32(0xf7960e44),
		75:  uint32(0xe3d35e8c),
		76:  uint32(0x15056dd4),
		77:  uint32(0x88f46dba),
		78:  uint32(0x03a16125),
		79:  uint32(0x0564f0bd),
		80:  uint32(0xc3eb9e15),
		81:  uint32(0x3c9057a2),
		82:  uint32(0x97271aec),
		83:  uint32(0xa93a072a),
		84:  uint32(0x1b3f6d9b),
		85:  uint32(0x1e6321f5),
		86:  uint32(0xf59c66fb),
		87:  uint32(0x26dcf319),
		88:  uint32(0x7533d928),
		89:  uint32(0xb155fdf5),
		90:  uint32(0x03563482),
		91:  uint32(0x8aba3cbb),
		92:  uint32(0x28517711),
		93:  uint32(0xc20ad9f8),
		94:  uint32(0xabcc5167),
		95:  uint32(0xccad925f),
		96:  uint32(0x4de81751),
		97:  uint32(0x3830dc8e),
		98:  uint32(0x379d5862),
		99:  uint32(0x9320f991),
		100: uint32(0xea7a90c2),
		101: uint32(0xfb3e7bce),
		102: uint32(0x5121ce64),
		103: uint32(0x774fbe32),
		104: uint32(0xa8b6e37e),
		105: uint32(0xc3293d46),
		106: uint32(0x48de5369),
		107: uint32(0x6413e680),
		108: uint32(0xa2ae0810),
		109: uint32(0xdd6db224),
		110: uint32(0x69852dfd),
		111: uint32(0x09072166),
		112: uint32(0xb39a460a),
		113: uint32(0x6445c0dd),
		114: uint32(0x586cdecf),
		115: uint32(0x1c20c8ae),
		116: uint32(0x5bbef7dd),
		117: uint32(0x1b588d40),
		118: uint32(0xccd2017f),
		119: uint32(0x6bb4e3bb),
		120: uint32(0xdda26a7e),
		121: uint32(0x3a59ff45),
		122: uint32(0x3e350a44),
		123: uint32(0xbcb4cdd5),
		124: uint32(0x72eacea8),
		125: uint32(0xfa6484bb),
		126: uint32(0x8d6612ae),
		127: uint32(0xbf3c6f47),
		128: uint32(0xd29be463),
		129: uint32(0x542f5d9e),
		130: uint32(0xaec2771b),
		131: uint32(0xf64e6370),
		132: uint32(0x740e0d8d),
		133: uint32(0xe75b1357),
		134: uint32(0xf8721671),
		135: uint32(0xaf537d5d),
		136: uint32(0x4040cb08),
		137: uint32(0x4eb4e2cc),
		138: uint32(0x34d2466a),
		139: uint32(0x0115af84),
		140: uint32(0xe1b00428),
		141: uint32(0x95983a1d),
		142: uint32(0x06b89fb4),
		143: uint32(0xce6ea048),
		144: uint32(0x6f3f3b82),
		145: uint32(0x3520ab82),
		146: uint32(0x011a1d4b),
		147: uint32(0x277227f8),
		148: uint32(0x611560b1),
		149: uint32(0xe7933fdc),
		150: uint32(0xbb3a792b),
		151: uint32(0x344525bd),
		152: uint32(0xa08839e1),
		153: uint32(0x51ce794b),
		154: uint32(0x2f32c9b7),
		155: uint32(0xa01fbac9),
		156: uint32(0xe01cc87e),
		157: uint32(0xbcc7d1f6),
		158: uint32(0xcf0111c3),
		159: uint32(0xa1e8aac7),
		160: uint32(0x1a908749),
		161: uint32(0xd44fbd9a),
		162: uint32(0xd0dadecb),
		163: uint32(0xd50ada38),
		164: uint32(0x0339c32a),
		165: uint32(0xc6913667),
		166: uint32(0x8df9317c),
		167: uint32(0xe0b12b4f),
		168: uint32(0xf79e59b7),
		169: uint32(0x43f5bb3a),
		170: uint32(0xf2d519ff),
		171: uint32(0x27d9459c),
		172: uint32(0xbf97222c),
		173: uint32(0x15e6fc2a),
		174: uint32(0x0f91fc71),
		175: uint32(0x9b941525),
		176: uint32(0xfae59361),
		177: uint32(0xceb69ceb),
		178: uint32(0xc2a86459),
		179: uint32(0x12baa8d1),
		180: uint32(0xb6c1075e),
		181: uint32(0xe3056a0c),
		182: uint32(0x10d25065),
		183: uint32(0xcb03a442),
		184: uint32(0xe0ec6e0e),
		185: uint32(0x1698db3b),
		186: uint32(0x4c98a0be),
		187: uint32(0x3278e964),
		188: uint32(0x9f1f9532),
		189: uint32(0xe0d392df),
		190: uint32(0xd3a0342b),
		191: uint32(0x8971f21e),
		192: uint32(0x1b0a7441),
		193: uint32(0x4ba3348c),
		194: uint32(0xc5be7120),
		195: uint32(0xc37632d8),
		196: uint32(0xdf359f8d),
		197: uint32(0x9b992f2e),
		198: uint32(0xe60b6f47),
		199: uint32(0x0fe3f11d),
		200: uint32(0xe54cda54),
		201: uint32(0x1edad891),
		202: uint32(0xce6279cf),
		203: uint32(0xcd3e7e6f),
		204: uint32(0x1618b166),
		205: uint32(0xfd2c1d05),
		206: uint32(0x848fd2c5),
		207: uint32(0xf6fb2299),
		208: uint32(0xf523f357),
		209: uint32(0xa6327623),
		210: uint32(0x93a83531),
		211: uint32(0x56cccd02),
		212: uint32(0xacf08162),
		213: uint32(0x5a75ebb5),
		214: uint32(0x6e163697),
		215: uint32(0x88d273cc),
		216: uint32(0xde966292),
		217: uint32(0x81b949d0),
		218: uint32(0x4c50901b),
		219: uint32(0x71c65614),
		220: uint32(0xe6c6c7bd),
		221: uint32(0x327a140a),
		222: uint32(0x45e1d006),
		223: uint32(0xc3f27b9a),
		224: uint32(0xc9aa53fd),
		225: uint32(0x62a80f00),
		226: uint32(0xbb25bfe2),
		227: uint32(0x35bdd2f6),
		228: uint32(0x71126905),
		229: uint32(0xb2040222),
		230: uint32(0xb6cbcf7c),
		231: uint32(0xcd769c2b),
		232: uint32(0x53113ec0),
		233: uint32(0x1640e3d3),
		234: uint32(0x38abbd60),
		235: uint32(0x2547adf0),
		236: uint32(0xba38209c),
		237: uint32(0xf746ce76),
		238: uint32(0x77afa1c5),
		239: uint32(0x20756060),
		240: uint32(0x85cbfe4e),
		241: uint32(0x8ae88dd8),
		242: uint32(0x7aaaf9b0),
		243: uint32(0x4cf9aa7e),
		244: uint32(0x1948c25c),
		245: uint32(0x02fb8a8c),
		246: uint32(0x01c36ae4),
		247: uint32(0xd6ebe1f9),
		248: uint32(0x90d4f869),
		249: uint32(0xa65cdea0),
		250: uint32(0x3f09252d),
		251: uint32(0xc208e69f),
		252: uint32(0xb74e6132),
		253: uint32(0xce77e25b),
		254: uint32(0x578fdfe3),
		255: uint32(0x3ac372e6)}}}))

var _BF_itoa64 = [65]uint8{'.', '/', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}

var _BF_atoi64 = [96]uint8{
	0:  uint8(64),
	1:  uint8(64),
	2:  uint8(64),
	3:  uint8(64),
	4:  uint8(64),
	5:  uint8(64),
	6:  uint8(64),
	7:  uint8(64),
	8:  uint8(64),
	9:  uint8(64),
	10: uint8(64),
	11: uint8(64),
	12: uint8(64),
	13: uint8(64),
	14: uint8(0),
	15: uint8(1),
	16: uint8(54),
	17: uint8(55),
	18: uint8(56),
	19: uint8(57),
	20: uint8(58),
	21: uint8(59),
	22: uint8(60),
	23: uint8(61),
	24: uint8(62),
	25: uint8(63),
	26: uint8(64),
	27: uint8(64),
	28: uint8(64),
	29: uint8(64),
	30: uint8(64),
	31: uint8(64),
	32: uint8(64),
	33: uint8(2),
	34: uint8(3),
	35: uint8(4),
	36: uint8(5),
	37: uint8(6),
	38: uint8(7),
	39: uint8(8),
	40: uint8(9),
	41: uint8(10),
	42: uint8(11),
	43: uint8(12),
	44: uint8(13),
	45: uint8(14),
	46: uint8(15),
	47: uint8(16),
	48: uint8(17),
	49: uint8(18),
	50: uint8(19),
	51: uint8(20),
	52: uint8(21),
	53: uint8(22),
	54: uint8(23),
	55: uint8(24),
	56: uint8(25),
	57: uint8(26),
	58: uint8(27),
	59: uint8(64),
	60: uint8(64),
	61: uint8(64),
	62: uint8(64),
	63: uint8(64),
	64: uint8(64),
	65: uint8(28),
	66: uint8(29),
	67: uint8(30),
	68: uint8(31),
	69: uint8(32),
	70: uint8(33),
	71: uint8(34),
	72: uint8(35),
	73: uint8(36),
	74: uint8(37),
	75: uint8(38),
	76: uint8(39),
	77: uint8(40),
	78: uint8(41),
	79: uint8(42),
	80: uint8(43),
	81: uint8(44),
	82: uint8(45),
	83: uint8(46),
	84: uint8(47),
	85: uint8(48),
	86: uint8(49),
	87: uint8(50),
	88: uint8(51),
	89: uint8(52),
	90: uint8(53),
	91: uint8(64),
	92: uint8(64),
	93: uint8(64),
	94: uint8(64),
	95: uint8(64)}

func _BF_decode(tls *TLS, dst uintptr, src uintptr, size int32) (r int32) {
	var c1 uint32
	var c2 uint32
	var c3 uint32
	var c4 uint32
	var dptr uintptr
	var end uintptr
	var sptr uintptr
	var tmp uint32
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	dptr = dst
	end = dptr + uintptr(size)
	sptr = src
	for cond := true; cond; cond = dptr < end {
		{
			v1 = sptr
			sptr++
			tmp = uint32(*(*uint8)(unsafe.Pointer(v1)))
			tmp = tmp - Uint32FromInt32(0x20)
			if tmp >= uint32(0x60) {
				return -int32(1)
			}
			tmp = uint32(_BF_atoi64[tmp])
			if tmp > uint32(63) {
				return -int32(1)
			}
			c1 = tmp
		}
		{
			v2 = sptr
			sptr++
			tmp = uint32(*(*uint8)(unsafe.Pointer(v2)))
			tmp = tmp - Uint32FromInt32(0x20)
			if tmp >= uint32(0x60) {
				return -int32(1)
			}
			tmp = uint32(_BF_atoi64[tmp])
			if tmp > uint32(63) {
				return -int32(1)
			}
			c2 = tmp
		}
		v3 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v3)) = uint8(c1<<int32(2) | c2&uint32(0x30)>>int32(4))
		if dptr >= end {
			break
		}
		{
			v4 = sptr
			sptr++
			tmp = uint32(*(*uint8)(unsafe.Pointer(v4)))
			tmp = tmp - Uint32FromInt32(0x20)
			if tmp >= uint32(0x60) {
				return -int32(1)
			}
			tmp = uint32(_BF_atoi64[tmp])
			if tmp > uint32(63) {
				return -int32(1)
			}
			c3 = tmp
		}
		v5 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v5)) = uint8(c2&uint32(0x0F)<<int32(4) | c3&uint32(0x3C)>>int32(2))
		if dptr >= end {
			break
		}
		{
			v6 = sptr
			sptr++
			tmp = uint32(*(*uint8)(unsafe.Pointer(v6)))
			tmp = tmp - Uint32FromInt32(0x20)
			if tmp >= uint32(0x60) {
				return -int32(1)
			}
			tmp = uint32(_BF_atoi64[tmp])
			if tmp > uint32(63) {
				return -int32(1)
			}
			c4 = tmp
		}
		v7 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v7)) = uint8(c3&uint32(0x03)<<int32(6) | c4)
	}
	return int32(0)
}

func _BF_encode(tls *TLS, dst uintptr, src uintptr, size int32) {
	var c1 uint32
	var c2 uint32
	var dptr uintptr
	var end uintptr
	var sptr uintptr
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	var v8 uintptr
	var v9 uintptr
	sptr = src
	end = sptr + uintptr(size)
	dptr = dst
	for cond := true; cond; cond = sptr < end {
		v1 = sptr
		sptr++
		c1 = uint32(*(*uint8)(unsafe.Pointer(v1)))
		v2 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v2)) = _BF_itoa64[c1>>int32(2)]
		c1 = c1 & uint32(0x03) << int32(4)
		if sptr >= end {
			v3 = dptr
			dptr++
			*(*uint8)(unsafe.Pointer(v3)) = _BF_itoa64[c1]
			break
		}
		v4 = sptr
		sptr++
		c2 = uint32(*(*uint8)(unsafe.Pointer(v4)))
		c1 = c1 | c2>>Int32FromInt32(4)
		v5 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v5)) = _BF_itoa64[c1]
		c1 = c2 & uint32(0x0f) << int32(2)
		if sptr >= end {
			v6 = dptr
			dptr++
			*(*uint8)(unsafe.Pointer(v6)) = _BF_itoa64[c1]
			break
		}
		v7 = sptr
		sptr++
		c2 = uint32(*(*uint8)(unsafe.Pointer(v7)))
		c1 = c1 | c2>>Int32FromInt32(6)
		v8 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v8)) = _BF_itoa64[c1]
		v9 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v9)) = _BF_itoa64[c2&uint32(0x3f)]
	}
}

func _BF_swap(tls *TLS, x uintptr, count int32) {
	var tmp TBF_word
	var v1 int32
	var v2 uintptr
	if *(*int8)(unsafe.Pointer(&struct {
		Fc [0]int8
		Fi int32
	}{Fi: int32(1)})) != 0 {
		for first := true; ; first = false {
			if !first {
				count--
				v1 = count
				if !(v1 != 0) {
					break
				}
			}
			tmp = *(*TBF_word)(unsafe.Pointer(x))
			tmp = tmp<<Int32FromInt32(16) | tmp>>Int32FromInt32(16)
			v2 = x
			x += 4
			*(*TBF_word)(unsafe.Pointer(v2)) = tmp&uint32(0x00FF00FF)<<int32(8) | tmp>>Int32FromInt32(8)&uint32(0x00FF00FF)
		}
	}
}

func _BF_encrypt(tls *TLS, ctx uintptr, L TBF_word, R TBF_word, start uintptr, end uintptr) (r TBF_word) {
	var i int32
	var ptr uintptr
	var tmp1 TBF_word
	var tmp2 TBF_word
	var tmp3 TBF_word
	var tmp4 TBF_word
	var v2 uintptr
	var v3 uintptr
	ptr = start
	for cond := true; cond; cond = ptr < end {
		L = L ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FP)) + UintptrFromInt32(0)*4))
		i = int32(0)
		for i < int32(16) {
			tmp1 = L & uint32(0xFF)
			tmp2 = L >> int32(8)
			tmp2 = tmp2 & Uint32FromInt32(0xFF)
			tmp3 = L >> int32(16)
			tmp3 = tmp3 & Uint32FromInt32(0xFF)
			tmp4 = L >> int32(24)
			tmp1 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(3)*1024 + uintptr(tmp1)*4))
			tmp2 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(2)*1024 + uintptr(tmp2)*4))
			tmp3 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(1)*1024 + uintptr(tmp3)*4))
			tmp3 = tmp3 + *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(0)*1024 + uintptr(tmp4)*4))
			tmp3 = tmp3 ^ tmp2
			R = R ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FP)) + uintptr(i+Int32FromInt32(1))*4))
			tmp3 = tmp3 + tmp1
			R = R ^ tmp3
			tmp1 = R & uint32(0xFF)
			tmp2 = R >> int32(8)
			tmp2 = tmp2 & Uint32FromInt32(0xFF)
			tmp3 = R >> int32(16)
			tmp3 = tmp3 & Uint32FromInt32(0xFF)
			tmp4 = R >> int32(24)
			tmp1 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(3)*1024 + uintptr(tmp1)*4))
			tmp2 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(2)*1024 + uintptr(tmp2)*4))
			tmp3 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(1)*1024 + uintptr(tmp3)*4))
			tmp3 = tmp3 + *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FS)) + UintptrFromInt32(0)*1024 + uintptr(tmp4)*4))
			tmp3 = tmp3 ^ tmp2
			L = L ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FP)) + uintptr(i+Int32FromInt32(1)+Int32FromInt32(1))*4))
			tmp3 = tmp3 + tmp1
			L = L ^ tmp3
			goto _1
		_1:
			i = i + Int32FromInt32(2)
		}
		tmp4 = R
		R = L
		L = tmp4 ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*TBF_ctx)(unsafe.Pointer(ctx)).Fs.FP)) + uintptr(Int32FromInt32(m_BF_N)+Int32FromInt32(1))*4))
		v2 = ptr
		ptr += 4
		*(*TBF_word)(unsafe.Pointer(v2)) = L
		v3 = ptr
		ptr += 4
		*(*TBF_word)(unsafe.Pointer(v3)) = R
	}
	return L
}

func _BF_set_key(tls *TLS, key uintptr, expanded uintptr, initial uintptr, flags uint8) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var bug uint32
	var diff TBF_word
	var i uint32
	var j uint32
	var ptr uintptr
	var safety TBF_word
	var sign TBF_word
	var _ /* tmp at bp+0 */ [2]TBF_word
	var v1 TBF_word
	var v2 TBF_word
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	ptr = key
	/*
	 * There was a sign extension bug in older revisions of this function.  While
	 * we would have liked to simply fix the bug and move on, we have to provide
	 * a backwards compatibility feature (essentially the bug) for some systems and
	 * a safety measure for some others.  The latter is needed because for certain
	 * multiple inputs to the buggy algorithm there exist easily found inputs to
	 * the correct algorithm that produce the same hash.  Thus, we optionally
	 * deviate from the correct algorithm just enough to avoid such collisions.
	 * While the bug itself affected the majority of passwords containing
	 * characters with the 8th bit set (although only a percentage of those in a
	 * collision-producing way), the anti-collision safety measure affects
	 * only a subset of passwords containing the '\xff' character (not even all of
	 * those passwords, just some of them).  This character is not found in valid
	 * UTF-8 sequences and is rarely used in popular 8-bit character encodings.
	 * Thus, the safety measure is unlikely to cause much annoyance, and is a
	 * reasonable tradeoff to use when authenticating against existing hashes that
	 * are not reliably known to have been computed with the correct algorithm.
	 *
	 * We use an approach that tries to minimize side-channel leaks of password
	 * information - that is, we mostly use fixed-cost bitwise operations instead
	 * of branches or table lookups.  (One conditional branch based on password
	 * length remains.  It is not part of the bug aftermath, though, and is
	 * difficult and possibly unreasonable to avoid given the use of C strings by
	 * the caller, which results in similar timing leaks anyway.)
	 *
	 * For actual implementation, we set an array index in the variable "bug"
	 * (0 means no bug, 1 means sign extension bug emulation) and a flag in the
	 * variable "safety" (bit 16 is set when the safety measure is requested).
	 * Valid combinations of settings are:
	 *
	 * Prefix "$2a$": bug = 0, safety = 0x10000
	 * Prefix "$2b$": bug = 0, safety = 0
	 * Prefix "$2x$": bug = 1, safety = 0
	 * Prefix "$2y$": bug = 0, safety = 0
	 */
	bug = uint32(int32(flags) & int32(1))
	safety = uint32(flags) & uint32(2) << int32(15)
	v1 = Uint32FromInt32(0)
	diff = v1
	sign = v1
	for i = uint32(0); i < uint32(Int32FromInt32(m_BF_N)+Int32FromInt32(2)); i++ {
		v2 = Uint32FromInt32(0)
		(*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)] = v2
		(*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(0)] = v2
		for j = uint32(0); j < uint32(4); j++ {
			p3 = bp + UintptrFromInt32(0)*4
			*(*TBF_word)(unsafe.Pointer(p3)) = *(*TBF_word)(unsafe.Pointer(p3)) << Uint32FromInt32(8)
			p4 = bp + UintptrFromInt32(0)*4
			*(*TBF_word)(unsafe.Pointer(p4)) = *(*TBF_word)(unsafe.Pointer(p4)) | uint32(uint8(*(*int8)(unsafe.Pointer(ptr)))) /* correct */
			p5 = bp + UintptrFromInt32(1)*4
			*(*TBF_word)(unsafe.Pointer(p5)) = *(*TBF_word)(unsafe.Pointer(p5)) << Uint32FromInt32(8)
			p6 = bp + UintptrFromInt32(1)*4
			*(*TBF_word)(unsafe.Pointer(p6)) = *(*TBF_word)(unsafe.Pointer(p6)) | uint32(*(*int8)(unsafe.Pointer(ptr))) /* bug */
			/*
			 * Sign extension in the first char has no effect - nothing to overwrite yet,
			 * and those extra 24 bits will be fully shifted out of the 32-bit word.  For
			 * chars 2, 3, 4 in each four-char block, we set bit 7 of "sign" if sign
			 * extension in tmp[1] occurs.  Once this flag is set, it remains set.
			 */
			if j != 0 {
				sign = sign | (*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)]&Uint32FromInt32(0x80)
			}
			if !(*(*int8)(unsafe.Pointer(ptr)) != 0) {
				ptr = key
			} else {
				ptr++
			}
		}
		diff = diff | ((*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(0)] ^ (*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)]) /* Non-zero on any differences */
		*(*TBF_word)(unsafe.Pointer(expanded + uintptr(i)*4)) = (*(*[2]TBF_word)(unsafe.Pointer(bp)))[bug]
		*(*TBF_word)(unsafe.Pointer(initial + uintptr(i)*4)) = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
			FP TBF_key
			FS [4][256]TBF_word
		})(unsafe.Pointer(uintptr(unsafe.Pointer(&_BF_init_state))))).FP)) + uintptr(i)*4)) ^ (*(*[2]TBF_word)(unsafe.Pointer(bp)))[bug]
	}
	/*
	 * At this point, "diff" is zero iff the correct and buggy algorithms produced
	 * exactly the same result.  If so and if "sign" is non-zero, which indicates
	 * that there was a non-benign sign extension, this means that we have a
	 * collision between the correctly computed hash for this password and a set of
	 * passwords that could be supplied to the buggy algorithm.  Our safety measure
	 * is meant to protect from such many-buggy to one-correct collisions, by
	 * deviating from the correct algorithm in such cases.  Let's check for this.
	 */
	diff = diff | diff>>Int32FromInt32(16) /* still zero iff exact match */
	diff = diff & Uint32FromInt32(0xffff)  /* ditto */
	diff = diff + Uint32FromInt32(0xffff)  /* bit 16 set iff "diff" was non-zero (on non-match) */
	sign = sign << Uint32FromInt32(9)      /* move the non-benign sign extension flag to bit 16 */
	sign = sign & (^diff & safety)         /* action needed? */
	/*
	 * If we have determined that we need to deviate from the correct algorithm,
	 * flip bit 16 in initial expanded key.  (The choice of 16 is arbitrary, but
	 * let's stick to it now.  It came out of the approach we used above, and it's
	 * not any worse than any other choice we could make.)
	 *
	 * It is crucial that we don't do the same to the expanded key used in the main
	 * Eksblowfish loop.  By doing it to only one of these two, we deviate from a
	 * state that could be directly specified by a password to the buggy algorithm
	 * (and to the fully correct one as well, but that's a side-effect).
	 */
	p7 = initial + UintptrFromInt32(0)*4
	*(*TBF_word)(unsafe.Pointer(p7)) = *(*TBF_word)(unsafe.Pointer(p7)) ^ sign
}

var _flags_by_subtype = [26]uint8{
	0:  uint8(2),
	1:  uint8(4),
	2:  uint8(0),
	3:  uint8(0),
	4:  uint8(0),
	5:  uint8(0),
	6:  uint8(0),
	7:  uint8(0),
	8:  uint8(0),
	9:  uint8(0),
	10: uint8(0),
	11: uint8(0),
	12: uint8(0),
	13: uint8(0),
	14: uint8(0),
	15: uint8(0),
	16: uint8(0),
	17: uint8(0),
	18: uint8(0),
	19: uint8(0),
	20: uint8(0),
	21: uint8(0),
	22: uint8(0),
	23: uint8(1),
	24: uint8(4),
	25: uint8(0)}

func _BF_crypt(tls *TLS, key uintptr, setting uintptr, output uintptr, min TBF_word) (r uintptr) {
	bp := tls.Alloc(4272) /* tlsAllocs 4272 maxValist 0 */
	defer tls.Free(4272)
	var L TBF_word
	var L1 TBF_word
	var R TBF_word
	var count TBF_word
	var done int32
	var i int32
	var ptr uintptr
	var tmp1 TBF_word
	var tmp2 TBF_word
	var tmp3 TBF_word
	var tmp4 TBF_word
	var _ /* LR at bp+4264 */ [2]TBF_word
	var _ /* data at bp+0 */ struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	}
	var v1 TBF_word
	var v13 TBF_word
	var p10 uintptr
	var p11 uintptr
	var p3 uintptr
	var p4 uintptr
	var p6 uintptr
	var p7 uintptr
	var p8 uintptr
	var p9 uintptr
	if int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(0)))) != int32('$') || int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(1)))) != int32('2') || uint32(int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(2))))-int32('a')) > uint32(25) || !(_flags_by_subtype[int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(2))))-int32('a')] != 0) || int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(3)))) != int32('$') || uint32(int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(4))))-int32('0')) > uint32(1) || uint32(int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(5))))-int32('0')) > uint32(9) || int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(6)))) != int32('$') {
		return UintptrFromInt32(0)
	}
	count = Uint32FromInt32(1) << ((int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(4))))-int32('0'))*int32(10) + (int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(5)))) - int32('0')))
	if count < min || _BF_decode(tls, uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fbinary.Fsalt)), setting+UintptrFromInt32(7), int32(16)) != 0 {
		return UintptrFromInt32(0)
	}
	_BF_swap(tls, uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fbinary.Fsalt)), int32(4))
	_BF_set_key(tls, key, uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fexpanded_key)), uintptr(unsafe.Pointer(&(*(*struct {
		FP TBF_key
		FS [4][256]TBF_word
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fctx))))).FP)), _flags_by_subtype[int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(2))))-int32('a')])
	x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*struct {
		FP TBF_key
		FS [4][256]TBF_word
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fctx))))).FS)), uintptr(unsafe.Pointer(&(*(*struct {
		FP TBF_key
		FS [4][256]TBF_word
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&_BF_init_state))))).FS)), uint64(4096))
	{
		L = uint32(0)
		R = uint32(0)
		ptr = uintptr(unsafe.Pointer(&(*(*struct {
			Fctx          TBF_ctx
			Fexpanded_key TBF_key
			Fbinary       struct {
				Foutput      [0][6]TBF_word
				Fsalt        [4]TBF_word
				F__ccgo_pad2 [8]byte
			}
		})(unsafe.Pointer(bp))).Fctx)) + UintptrFromInt32(0)*4
		for cond := true; cond; cond = int32(1) != 0 {
			L = _BF_encrypt(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx)), L^*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(0)*4)), R^*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(1)*4)), ptr, ptr)
			R = *(*TBF_word)(unsafe.Pointer(ptr + UintptrFromInt32(1)*4))
			ptr = ptr + UintptrFromInt32(2)*4
			if ptr >= uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx))+uintptr(Int32FromInt32(m_BF_N)+Int32FromInt32(2)+Int32FromInt32(4)*Int32FromInt32(0x100))*4 {
				break
			}
			L = _BF_encrypt(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx)), L^*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(2)*4)), R^*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(3)*4)), ptr, ptr)
			R = *(*TBF_word)(unsafe.Pointer(ptr + UintptrFromInt32(1)*4))
			ptr = ptr + UintptrFromInt32(2)*4
		}
	}
	for first := true; ; first = false {
		if !first {
			count--
			v1 = count
			if !(v1 != 0) {
				break
			}
		}
		for i = int32(0); i < Int32FromInt32(m_BF_N)+Int32FromInt32(2); {
			p3 = uintptr(unsafe.Pointer(&(*(*struct {
				FP TBF_key
				FS [4][256]TBF_word
			})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i)*4
			*(*TBF_word)(unsafe.Pointer(p3)) = *(*TBF_word)(unsafe.Pointer(p3)) ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fexpanded_key)) + uintptr(i)*4))
			p4 = uintptr(unsafe.Pointer(&(*(*struct {
				FP TBF_key
				FS [4][256]TBF_word
			})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i+Int32FromInt32(1))*4
			*(*TBF_word)(unsafe.Pointer(p4)) = *(*TBF_word)(unsafe.Pointer(p4)) ^ *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fexpanded_key)) + uintptr(i+Int32FromInt32(1))*4))
			goto _2
		_2:
			i = i + Int32FromInt32(2)
		}
		done = int32(0)
		for cond := true; cond; cond = int32(1) != 0 {
			_BF_encrypt(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx)), uint32(0), uint32(0), uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx))+UintptrFromInt32(0)*4, uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx))+uintptr(Int32FromInt32(m_BF_N)+Int32FromInt32(2)+Int32FromInt32(4)*Int32FromInt32(0x100))*4)
			if done != 0 {
				break
			}
			done = int32(1)
			{
				tmp1 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(0)*4))
				tmp2 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(1)*4))
				tmp3 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(2)*4))
				tmp4 = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fbinary.Fsalt)) + UintptrFromInt32(3)*4))
				for i = int32(0); i < int32(m_BF_N); {
					p6 = uintptr(unsafe.Pointer(&(*(*struct {
						FP TBF_key
						FS [4][256]TBF_word
					})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
						Fctx          TBF_ctx
						Fexpanded_key TBF_key
						Fbinary       struct {
							Foutput      [0][6]TBF_word
							Fsalt        [4]TBF_word
							F__ccgo_pad2 [8]byte
						}
					})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i)*4
					*(*TBF_word)(unsafe.Pointer(p6)) = *(*TBF_word)(unsafe.Pointer(p6)) ^ tmp1
					p7 = uintptr(unsafe.Pointer(&(*(*struct {
						FP TBF_key
						FS [4][256]TBF_word
					})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
						Fctx          TBF_ctx
						Fexpanded_key TBF_key
						Fbinary       struct {
							Foutput      [0][6]TBF_word
							Fsalt        [4]TBF_word
							F__ccgo_pad2 [8]byte
						}
					})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i+Int32FromInt32(1))*4
					*(*TBF_word)(unsafe.Pointer(p7)) = *(*TBF_word)(unsafe.Pointer(p7)) ^ tmp2
					p8 = uintptr(unsafe.Pointer(&(*(*struct {
						FP TBF_key
						FS [4][256]TBF_word
					})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
						Fctx          TBF_ctx
						Fexpanded_key TBF_key
						Fbinary       struct {
							Foutput      [0][6]TBF_word
							Fsalt        [4]TBF_word
							F__ccgo_pad2 [8]byte
						}
					})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i+Int32FromInt32(2))*4
					*(*TBF_word)(unsafe.Pointer(p8)) = *(*TBF_word)(unsafe.Pointer(p8)) ^ tmp3
					p9 = uintptr(unsafe.Pointer(&(*(*struct {
						FP TBF_key
						FS [4][256]TBF_word
					})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
						Fctx          TBF_ctx
						Fexpanded_key TBF_key
						Fbinary       struct {
							Foutput      [0][6]TBF_word
							Fsalt        [4]TBF_word
							F__ccgo_pad2 [8]byte
						}
					})(unsafe.Pointer(bp))).Fctx))))).FP)) + uintptr(i+Int32FromInt32(3))*4
					*(*TBF_word)(unsafe.Pointer(p9)) = *(*TBF_word)(unsafe.Pointer(p9)) ^ tmp4
					goto _5
				_5:
					i = i + Int32FromInt32(4)
				}
				p10 = uintptr(unsafe.Pointer(&(*(*struct {
					FP TBF_key
					FS [4][256]TBF_word
				})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fctx))))).FP)) + UintptrFromInt32(16)*4
				*(*TBF_word)(unsafe.Pointer(p10)) = *(*TBF_word)(unsafe.Pointer(p10)) ^ tmp1
				p11 = uintptr(unsafe.Pointer(&(*(*struct {
					FP TBF_key
					FS [4][256]TBF_word
				})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
					Fctx          TBF_ctx
					Fexpanded_key TBF_key
					Fbinary       struct {
						Foutput      [0][6]TBF_word
						Fsalt        [4]TBF_word
						F__ccgo_pad2 [8]byte
					}
				})(unsafe.Pointer(bp))).Fctx))))).FP)) + UintptrFromInt32(17)*4
				*(*TBF_word)(unsafe.Pointer(p11)) = *(*TBF_word)(unsafe.Pointer(p11)) ^ tmp2
			}
		}
	}
	for i = int32(0); i < int32(6); {
		L1 = _BF_magic_w[i]
		(*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)] = _BF_magic_w[i+int32(1)]
		count = uint32(64)
		for first := true; ; first = false {
			if !first {
				count--
				v13 = count
				if !(v13 != 0) {
					break
				}
			}
			L1 = _BF_encrypt(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fctx          TBF_ctx
				Fexpanded_key TBF_key
				Fbinary       struct {
					Foutput      [0][6]TBF_word
					Fsalt        [4]TBF_word
					F__ccgo_pad2 [8]byte
				}
			})(unsafe.Pointer(bp))).Fctx)), L1, (*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)], bp+4264+UintptrFromInt32(0)*4, bp+4264+UintptrFromInt32(0)*4)
		}
		*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
			Fctx          TBF_ctx
			Fexpanded_key TBF_key
			Fbinary       struct {
				Foutput      [0][6]TBF_word
				Fsalt        [4]TBF_word
				F__ccgo_pad2 [8]byte
			}
		})(unsafe.Pointer(bp))).Fbinary)) + uintptr(i)*4)) = L1
		*(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
			Fctx          TBF_ctx
			Fexpanded_key TBF_key
			Fbinary       struct {
				Foutput      [0][6]TBF_word
				Fsalt        [4]TBF_word
				F__ccgo_pad2 [8]byte
			}
		})(unsafe.Pointer(bp))).Fbinary)) + uintptr(i+Int32FromInt32(1))*4)) = (*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)]
		goto _12
	_12:
		i = i + Int32FromInt32(2)
	}
	x_memcpy(tls, output, setting, uint64(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))
	*(*int8)(unsafe.Pointer(output + uintptr(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))) = int8(_BF_itoa64[int32(_BF_atoi64[int32(*(*int8)(unsafe.Pointer(setting + uintptr(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))))-int32(0x20)])&int32(0x30)])
	/* This has to be bug-compatible with the original implementation, so
	 * only encode 23 of the 24 bytes. :-) */
	_BF_swap(tls, uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fbinary)), int32(6))
	_BF_encode(tls, output+uintptr(Int32FromInt32(7)+Int32FromInt32(22)), uintptr(unsafe.Pointer(&(*(*struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	})(unsafe.Pointer(bp))).Fbinary)), int32(23))
	*(*int8)(unsafe.Pointer(output + uintptr(Int32FromInt32(7)+Int32FromInt32(22)+Int32FromInt32(31)))) = int8('\000')
	return output
}

// C documentation
//
//	/*
//	 * Please preserve the runtime self-test.  It serves two purposes at once:
//	 *
//	 * 1. We really can't afford the risk of producing incompatible hashes e.g.
//	 * when there's something like gcc bug 26587 again, whereas an application or
//	 * library integrating this code might not also integrate our external tests or
//	 * it might not run them after every build.  Even if it does, the miscompile
//	 * might only occur on the production build, but not on a testing build (such
//	 * as because of different optimization settings).  It is painful to recover
//	 * from incorrectly-computed hashes - merely fixing whatever broke is not
//	 * enough.  Thus, a proactive measure like this self-test is needed.
//	 *
//	 * 2. We don't want to leave sensitive data from our actual password hash
//	 * computation on the stack or in registers.  Previous revisions of the code
//	 * would do explicit cleanups, but simply running the self-test after hash
//	 * computation is more reliable.
//	 *
//	 * The performance cost of this quick self-test is around 0.6% at the "$2a$08"
//	 * setting.
//	 */
func x___crypt_blowfish(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(384) /* tlsAllocs 384 maxValist 0 */
	defer tls.Free(384)
	var flags uint32
	var k uintptr
	var ok int32
	var p uintptr
	var retval uintptr
	var test_hash uintptr
	var test_key uintptr
	var test_setting uintptr
	var _ /* ae at bp+96 */ TBF_key
	var _ /* ai at bp+168 */ TBF_key
	var _ /* buf at bp+0 */ struct {
		Fs [30]int8
		Fo [63]int8
	}
	var _ /* ye at bp+240 */ TBF_key
	var _ /* yi at bp+312 */ TBF_key
	var p1 uintptr
	test_key = ts + 18
	test_setting = ts + 28
	test_hash = uintptr(unsafe.Pointer(&_test_hashes)) + UintptrFromInt32(0)*34
	/* Hash the supplied password */
	retval = _BF_crypt(tls, key, setting, output, uint32(16))
	/*
	 * Do a quick self-test.  It is important that we make both calls to BF_crypt()
	 * from the same scope such that they likely use the same stack locations,
	 * which makes the second call overwrite the first call's sensitive data on the
	 * stack and makes it more likely that any alignment related issues would be
	 * detected by the self-test.
	 */
	x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fs)), test_setting, uint64(30))
	if retval != 0 {
		flags = uint32(_flags_by_subtype[int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(2))))-int32('a')])
		test_hash = uintptr(unsafe.Pointer(&_test_hashes)) + uintptr(flags&Uint32FromInt32(1))*34
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
			Fs [30]int8
			Fo [63]int8
		})(unsafe.Pointer(bp))).Fs)) + UintptrFromInt32(2))) = *(*int8)(unsafe.Pointer(setting + UintptrFromInt32(2)))
	}
	x_memset(tls, uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fo)), int32(0x55), uint64(63))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fo)) + uintptr(Uint64FromInt64(63)-Uint64FromInt32(1)))) = int8(0)
	p = _BF_crypt(tls, test_key, uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fs)), uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fo)), uint32(1))
	ok = BoolInt32(p == uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fo)) && !(x_memcmp(tls, p, uintptr(unsafe.Pointer(&(*(*struct {
		Fs [30]int8
		Fo [63]int8
	})(unsafe.Pointer(bp))).Fs)), uint64(Int32FromInt32(7)+Int32FromInt32(22))) != 0) && !(x_memcmp(tls, p+uintptr(Int32FromInt32(7)+Int32FromInt32(22)), test_hash, uint64(Int32FromInt32(31)+Int32FromInt32(1)+Int32FromInt32(1)+Int32FromInt32(1))) != 0))
	{
		k = ts + 58
		_BF_set_key(tls, k, bp+96, bp+168, uint8(2))  /* $2a$ */
		_BF_set_key(tls, k, bp+240, bp+312, uint8(4)) /* $2y$ */
		p1 = bp + 168 + UintptrFromInt32(0)*4
		*(*TBF_word)(unsafe.Pointer(p1)) = *(*TBF_word)(unsafe.Pointer(p1)) ^ Uint32FromInt32(0x10000) /* undo the safety (for comparison) */
		ok = BoolInt32(ok != 0 && (*(*TBF_key)(unsafe.Pointer(bp + 168)))[int32(0)] == uint32(0xdb9c59bc) && (*(*TBF_key)(unsafe.Pointer(bp + 240)))[int32(17)] == uint32(0x33343500) && !(x_memcmp(tls, bp+96, bp+240, uint64(72)) != 0) && !(x_memcmp(tls, bp+168, bp+312, uint64(72)) != 0))
	}
	if ok != 0 && retval != 0 {
		return retval
	}
	return ts + 65
}

var _test_hashes = [2][34]int8{
	0: {'i', '1', 'D', '7', '0', '9', 'v', 'f', 'a', 'm', 'u', 'l', 'i', 'm', 'l', 'G', 'c', 'q', '0', 'q', 'q', '3', 'U', 'v', 'u', 'U', 'a', 's', 'v', 'E', 'a', 0, 'U'},
	1: {'V', 'U', 'r', 'P', 'm', 'X', 'D', '6', 'q', '/', 'n', 'V', 'S', 'S', 'p', '7', 'p', 'N', 'D', 'h', 'C', 'R', '9', '0', '7', '1', 'I', 'f', 'I', 'R', 'e', 0, 'U'}}

const m__PASSWORD_EFMT1 = 95

type Texpanded_key = struct {
	Fl [16]Tuint32_t
	Fr [16]Tuint32_t
}

var _key_shifts = [16]uint8{
	0:  uint8(1),
	1:  uint8(1),
	2:  uint8(2),
	3:  uint8(2),
	4:  uint8(2),
	5:  uint8(2),
	6:  uint8(2),
	7:  uint8(2),
	8:  uint8(1),
	9:  uint8(2),
	10: uint8(2),
	11: uint8(2),
	12: uint8(2),
	13: uint8(2),
	14: uint8(2),
	15: uint8(1)}

var _psbox = [8][64]Tuint32_t{
	0: {
		0:  uint32(0x00808200),
		1:  uint32(0x00000000),
		2:  uint32(0x00008000),
		3:  uint32(0x00808202),
		4:  uint32(0x00808002),
		5:  uint32(0x00008202),
		6:  uint32(0x00000002),
		7:  uint32(0x00008000),
		8:  uint32(0x00000200),
		9:  uint32(0x00808200),
		10: uint32(0x00808202),
		11: uint32(0x00000200),
		12: uint32(0x00800202),
		13: uint32(0x00808002),
		14: uint32(0x00800000),
		15: uint32(0x00000002),
		16: uint32(0x00000202),
		17: uint32(0x00800200),
		18: uint32(0x00800200),
		19: uint32(0x00008200),
		20: uint32(0x00008200),
		21: uint32(0x00808000),
		22: uint32(0x00808000),
		23: uint32(0x00800202),
		24: uint32(0x00008002),
		25: uint32(0x00800002),
		26: uint32(0x00800002),
		27: uint32(0x00008002),
		28: uint32(0x00000000),
		29: uint32(0x00000202),
		30: uint32(0x00008202),
		31: uint32(0x00800000),
		32: uint32(0x00008000),
		33: uint32(0x00808202),
		34: uint32(0x00000002),
		35: uint32(0x00808000),
		36: uint32(0x00808200),
		37: uint32(0x00800000),
		38: uint32(0x00800000),
		39: uint32(0x00000200),
		40: uint32(0x00808002),
		41: uint32(0x00008000),
		42: uint32(0x00008200),
		43: uint32(0x00800002),
		44: uint32(0x00000200),
		45: uint32(0x00000002),
		46: uint32(0x00800202),
		47: uint32(0x00008202),
		48: uint32(0x00808202),
		49: uint32(0x00008002),
		50: uint32(0x00808000),
		51: uint32(0x00800202),
		52: uint32(0x00800002),
		53: uint32(0x00000202),
		54: uint32(0x00008202),
		55: uint32(0x00808200),
		56: uint32(0x00000202),
		57: uint32(0x00800200),
		58: uint32(0x00800200),
		59: uint32(0x00000000),
		60: uint32(0x00008002),
		61: uint32(0x00008200),
		62: uint32(0x00000000),
		63: uint32(0x00808002)},
	1: {
		0:  uint32(0x40084010),
		1:  uint32(0x40004000),
		2:  uint32(0x00004000),
		3:  uint32(0x00084010),
		4:  uint32(0x00080000),
		5:  uint32(0x00000010),
		6:  uint32(0x40080010),
		7:  uint32(0x40004010),
		8:  uint32(0x40000010),
		9:  uint32(0x40084010),
		10: uint32(0x40084000),
		11: uint32(0x40000000),
		12: uint32(0x40004000),
		13: uint32(0x00080000),
		14: uint32(0x00000010),
		15: uint32(0x40080010),
		16: uint32(0x00084000),
		17: uint32(0x00080010),
		18: uint32(0x40004010),
		19: uint32(0x00000000),
		20: uint32(0x40000000),
		21: uint32(0x00004000),
		22: uint32(0x00084010),
		23: uint32(0x40080000),
		24: uint32(0x00080010),
		25: uint32(0x40000010),
		26: uint32(0x00000000),
		27: uint32(0x00084000),
		28: uint32(0x00004010),
		29: uint32(0x40084000),
		30: uint32(0x40080000),
		31: uint32(0x00004010),
		32: uint32(0x00000000),
		33: uint32(0x00084010),
		34: uint32(0x40080010),
		35: uint32(0x00080000),
		36: uint32(0x40004010),
		37: uint32(0x40080000),
		38: uint32(0x40084000),
		39: uint32(0x00004000),
		40: uint32(0x40080000),
		41: uint32(0x40004000),
		42: uint32(0x00000010),
		43: uint32(0x40084010),
		44: uint32(0x00084010),
		45: uint32(0x00000010),
		46: uint32(0x00004000),
		47: uint32(0x40000000),
		48: uint32(0x00004010),
		49: uint32(0x40084000),
		50: uint32(0x00080000),
		51: uint32(0x40000010),
		52: uint32(0x00080010),
		53: uint32(0x40004010),
		54: uint32(0x40000010),
		55: uint32(0x00080010),
		56: uint32(0x00084000),
		57: uint32(0x00000000),
		58: uint32(0x40004000),
		59: uint32(0x00004010),
		60: uint32(0x40000000),
		61: uint32(0x40080010),
		62: uint32(0x40084010),
		63: uint32(0x00084000)},
	2: {
		0:  uint32(0x00000104),
		1:  uint32(0x04010100),
		2:  uint32(0x00000000),
		3:  uint32(0x04010004),
		4:  uint32(0x04000100),
		5:  uint32(0x00000000),
		6:  uint32(0x00010104),
		7:  uint32(0x04000100),
		8:  uint32(0x00010004),
		9:  uint32(0x04000004),
		10: uint32(0x04000004),
		11: uint32(0x00010000),
		12: uint32(0x04010104),
		13: uint32(0x00010004),
		14: uint32(0x04010000),
		15: uint32(0x00000104),
		16: uint32(0x04000000),
		17: uint32(0x00000004),
		18: uint32(0x04010100),
		19: uint32(0x00000100),
		20: uint32(0x00010100),
		21: uint32(0x04010000),
		22: uint32(0x04010004),
		23: uint32(0x00010104),
		24: uint32(0x04000104),
		25: uint32(0x00010100),
		26: uint32(0x00010000),
		27: uint32(0x04000104),
		28: uint32(0x00000004),
		29: uint32(0x04010104),
		30: uint32(0x00000100),
		31: uint32(0x04000000),
		32: uint32(0x04010100),
		33: uint32(0x04000000),
		34: uint32(0x00010004),
		35: uint32(0x00000104),
		36: uint32(0x00010000),
		37: uint32(0x04010100),
		38: uint32(0x04000100),
		39: uint32(0x00000000),
		40: uint32(0x00000100),
		41: uint32(0x00010004),
		42: uint32(0x04010104),
		43: uint32(0x04000100),
		44: uint32(0x04000004),
		45: uint32(0x00000100),
		46: uint32(0x00000000),
		47: uint32(0x04010004),
		48: uint32(0x04000104),
		49: uint32(0x00010000),
		50: uint32(0x04000000),
		51: uint32(0x04010104),
		52: uint32(0x00000004),
		53: uint32(0x00010104),
		54: uint32(0x00010100),
		55: uint32(0x04000004),
		56: uint32(0x04010000),
		57: uint32(0x04000104),
		58: uint32(0x00000104),
		59: uint32(0x04010000),
		60: uint32(0x00010104),
		61: uint32(0x00000004),
		62: uint32(0x04010004),
		63: uint32(0x00010100)},
	3: {
		0:  uint32(0x80401000),
		1:  uint32(0x80001040),
		2:  uint32(0x80001040),
		3:  uint32(0x00000040),
		4:  uint32(0x00401040),
		5:  uint32(0x80400040),
		6:  uint32(0x80400000),
		7:  uint32(0x80001000),
		8:  uint32(0x00000000),
		9:  uint32(0x00401000),
		10: uint32(0x00401000),
		11: uint32(0x80401040),
		12: uint32(0x80000040),
		13: uint32(0x00000000),
		14: uint32(0x00400040),
		15: uint32(0x80400000),
		16: uint32(0x80000000),
		17: uint32(0x00001000),
		18: uint32(0x00400000),
		19: uint32(0x80401000),
		20: uint32(0x00000040),
		21: uint32(0x00400000),
		22: uint32(0x80001000),
		23: uint32(0x00001040),
		24: uint32(0x80400040),
		25: uint32(0x80000000),
		26: uint32(0x00001040),
		27: uint32(0x00400040),
		28: uint32(0x00001000),
		29: uint32(0x00401040),
		30: uint32(0x80401040),
		31: uint32(0x80000040),
		32: uint32(0x00400040),
		33: uint32(0x80400000),
		34: uint32(0x00401000),
		35: uint32(0x80401040),
		36: uint32(0x80000040),
		37: uint32(0x00000000),
		38: uint32(0x00000000),
		39: uint32(0x00401000),
		40: uint32(0x00001040),
		41: uint32(0x00400040),
		42: uint32(0x80400040),
		43: uint32(0x80000000),
		44: uint32(0x80401000),
		45: uint32(0x80001040),
		46: uint32(0x80001040),
		47: uint32(0x00000040),
		48: uint32(0x80401040),
		49: uint32(0x80000040),
		50: uint32(0x80000000),
		51: uint32(0x00001000),
		52: uint32(0x80400000),
		53: uint32(0x80001000),
		54: uint32(0x00401040),
		55: uint32(0x80400040),
		56: uint32(0x80001000),
		57: uint32(0x00001040),
		58: uint32(0x00400000),
		59: uint32(0x80401000),
		60: uint32(0x00000040),
		61: uint32(0x00400000),
		62: uint32(0x00001000),
		63: uint32(0x00401040)},
	4: {
		0:  uint32(0x00000080),
		1:  uint32(0x01040080),
		2:  uint32(0x01040000),
		3:  uint32(0x21000080),
		4:  uint32(0x00040000),
		5:  uint32(0x00000080),
		6:  uint32(0x20000000),
		7:  uint32(0x01040000),
		8:  uint32(0x20040080),
		9:  uint32(0x00040000),
		10: uint32(0x01000080),
		11: uint32(0x20040080),
		12: uint32(0x21000080),
		13: uint32(0x21040000),
		14: uint32(0x00040080),
		15: uint32(0x20000000),
		16: uint32(0x01000000),
		17: uint32(0x20040000),
		18: uint32(0x20040000),
		19: uint32(0x00000000),
		20: uint32(0x20000080),
		21: uint32(0x21040080),
		22: uint32(0x21040080),
		23: uint32(0x01000080),
		24: uint32(0x21040000),
		25: uint32(0x20000080),
		26: uint32(0x00000000),
		27: uint32(0x21000000),
		28: uint32(0x01040080),
		29: uint32(0x01000000),
		30: uint32(0x21000000),
		31: uint32(0x00040080),
		32: uint32(0x00040000),
		33: uint32(0x21000080),
		34: uint32(0x00000080),
		35: uint32(0x01000000),
		36: uint32(0x20000000),
		37: uint32(0x01040000),
		38: uint32(0x21000080),
		39: uint32(0x20040080),
		40: uint32(0x01000080),
		41: uint32(0x20000000),
		42: uint32(0x21040000),
		43: uint32(0x01040080),
		44: uint32(0x20040080),
		45: uint32(0x00000080),
		46: uint32(0x01000000),
		47: uint32(0x21040000),
		48: uint32(0x21040080),
		49: uint32(0x00040080),
		50: uint32(0x21000000),
		51: uint32(0x21040080),
		52: uint32(0x01040000),
		53: uint32(0x00000000),
		54: uint32(0x20040000),
		55: uint32(0x21000000),
		56: uint32(0x00040080),
		57: uint32(0x01000080),
		58: uint32(0x20000080),
		59: uint32(0x00040000),
		60: uint32(0x00000000),
		61: uint32(0x20040000),
		62: uint32(0x01040080),
		63: uint32(0x20000080)},
	5: {
		0:  uint32(0x10000008),
		1:  uint32(0x10200000),
		2:  uint32(0x00002000),
		3:  uint32(0x10202008),
		4:  uint32(0x10200000),
		5:  uint32(0x00000008),
		6:  uint32(0x10202008),
		7:  uint32(0x00200000),
		8:  uint32(0x10002000),
		9:  uint32(0x00202008),
		10: uint32(0x00200000),
		11: uint32(0x10000008),
		12: uint32(0x00200008),
		13: uint32(0x10002000),
		14: uint32(0x10000000),
		15: uint32(0x00002008),
		16: uint32(0x00000000),
		17: uint32(0x00200008),
		18: uint32(0x10002008),
		19: uint32(0x00002000),
		20: uint32(0x00202000),
		21: uint32(0x10002008),
		22: uint32(0x00000008),
		23: uint32(0x10200008),
		24: uint32(0x10200008),
		25: uint32(0x00000000),
		26: uint32(0x00202008),
		27: uint32(0x10202000),
		28: uint32(0x00002008),
		29: uint32(0x00202000),
		30: uint32(0x10202000),
		31: uint32(0x10000000),
		32: uint32(0x10002000),
		33: uint32(0x00000008),
		34: uint32(0x10200008),
		35: uint32(0x00202000),
		36: uint32(0x10202008),
		37: uint32(0x00200000),
		38: uint32(0x00002008),
		39: uint32(0x10000008),
		40: uint32(0x00200000),
		41: uint32(0x10002000),
		42: uint32(0x10000000),
		43: uint32(0x00002008),
		44: uint32(0x10000008),
		45: uint32(0x10202008),
		46: uint32(0x00202000),
		47: uint32(0x10200000),
		48: uint32(0x00202008),
		49: uint32(0x10202000),
		50: uint32(0x00000000),
		51: uint32(0x10200008),
		52: uint32(0x00000008),
		53: uint32(0x00002000),
		54: uint32(0x10200000),
		55: uint32(0x00202008),
		56: uint32(0x00002000),
		57: uint32(0x00200008),
		58: uint32(0x10002008),
		59: uint32(0x00000000),
		60: uint32(0x10202000),
		61: uint32(0x10000000),
		62: uint32(0x00200008),
		63: uint32(0x10002008)},
	6: {
		0:  uint32(0x00100000),
		1:  uint32(0x02100001),
		2:  uint32(0x02000401),
		3:  uint32(0x00000000),
		4:  uint32(0x00000400),
		5:  uint32(0x02000401),
		6:  uint32(0x00100401),
		7:  uint32(0x02100400),
		8:  uint32(0x02100401),
		9:  uint32(0x00100000),
		10: uint32(0x00000000),
		11: uint32(0x02000001),
		12: uint32(0x00000001),
		13: uint32(0x02000000),
		14: uint32(0x02100001),
		15: uint32(0x00000401),
		16: uint32(0x02000400),
		17: uint32(0x00100401),
		18: uint32(0x00100001),
		19: uint32(0x02000400),
		20: uint32(0x02000001),
		21: uint32(0x02100000),
		22: uint32(0x02100400),
		23: uint32(0x00100001),
		24: uint32(0x02100000),
		25: uint32(0x00000400),
		26: uint32(0x00000401),
		27: uint32(0x02100401),
		28: uint32(0x00100400),
		29: uint32(0x00000001),
		30: uint32(0x02000000),
		31: uint32(0x00100400),
		32: uint32(0x02000000),
		33: uint32(0x00100400),
		34: uint32(0x00100000),
		35: uint32(0x02000401),
		36: uint32(0x02000401),
		37: uint32(0x02100001),
		38: uint32(0x02100001),
		39: uint32(0x00000001),
		40: uint32(0x00100001),
		41: uint32(0x02000000),
		42: uint32(0x02000400),
		43: uint32(0x00100000),
		44: uint32(0x02100400),
		45: uint32(0x00000401),
		46: uint32(0x00100401),
		47: uint32(0x02100400),
		48: uint32(0x00000401),
		49: uint32(0x02000001),
		50: uint32(0x02100401),
		51: uint32(0x02100000),
		52: uint32(0x00100400),
		53: uint32(0x00000000),
		54: uint32(0x00000001),
		55: uint32(0x02100401),
		56: uint32(0x00000000),
		57: uint32(0x00100401),
		58: uint32(0x02100000),
		59: uint32(0x00000400),
		60: uint32(0x02000001),
		61: uint32(0x02000400),
		62: uint32(0x00000400),
		63: uint32(0x00100001)},
	7: {
		0:  uint32(0x08000820),
		1:  uint32(0x00000800),
		2:  uint32(0x00020000),
		3:  uint32(0x08020820),
		4:  uint32(0x08000000),
		5:  uint32(0x08000820),
		6:  uint32(0x00000020),
		7:  uint32(0x08000000),
		8:  uint32(0x00020020),
		9:  uint32(0x08020000),
		10: uint32(0x08020820),
		11: uint32(0x00020800),
		12: uint32(0x08020800),
		13: uint32(0x00020820),
		14: uint32(0x00000800),
		15: uint32(0x00000020),
		16: uint32(0x08020000),
		17: uint32(0x08000020),
		18: uint32(0x08000800),
		19: uint32(0x00000820),
		20: uint32(0x00020800),
		21: uint32(0x00020020),
		22: uint32(0x08020020),
		23: uint32(0x08020800),
		24: uint32(0x00000820),
		25: uint32(0x00000000),
		26: uint32(0x00000000),
		27: uint32(0x08020020),
		28: uint32(0x08000020),
		29: uint32(0x08000800),
		30: uint32(0x00020820),
		31: uint32(0x00020000),
		32: uint32(0x00020820),
		33: uint32(0x00020000),
		34: uint32(0x08020800),
		35: uint32(0x00000800),
		36: uint32(0x00000020),
		37: uint32(0x08020020),
		38: uint32(0x00000800),
		39: uint32(0x00020820),
		40: uint32(0x08000800),
		41: uint32(0x00000020),
		42: uint32(0x08000020),
		43: uint32(0x08020000),
		44: uint32(0x08020020),
		45: uint32(0x08000000),
		46: uint32(0x00020000),
		47: uint32(0x08000820),
		48: uint32(0x00000000),
		49: uint32(0x08020820),
		50: uint32(0x00020020),
		51: uint32(0x08000020),
		52: uint32(0x08020000),
		53: uint32(0x08000800),
		54: uint32(0x08000820),
		55: uint32(0x00000000),
		56: uint32(0x08020820),
		57: uint32(0x00020800),
		58: uint32(0x00020800),
		59: uint32(0x00000820),
		60: uint32(0x00000820),
		61: uint32(0x00020020),
		62: uint32(0x08000000),
		63: uint32(0x08020800)}}
var _ip_maskl = [16][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00010000),
		2:  uint32(0x00000000),
		3:  uint32(0x00010000),
		4:  uint32(0x01000000),
		5:  uint32(0x01010000),
		6:  uint32(0x01000000),
		7:  uint32(0x01010000),
		8:  uint32(0x00000000),
		9:  uint32(0x00010000),
		10: uint32(0x00000000),
		11: uint32(0x00010000),
		12: uint32(0x01000000),
		13: uint32(0x01010000),
		14: uint32(0x01000000),
		15: uint32(0x01010000)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000001),
		2:  uint32(0x00000000),
		3:  uint32(0x00000001),
		4:  uint32(0x00000100),
		5:  uint32(0x00000101),
		6:  uint32(0x00000100),
		7:  uint32(0x00000101),
		8:  uint32(0x00000000),
		9:  uint32(0x00000001),
		10: uint32(0x00000000),
		11: uint32(0x00000001),
		12: uint32(0x00000100),
		13: uint32(0x00000101),
		14: uint32(0x00000100),
		15: uint32(0x00000101)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00020000),
		2:  uint32(0x00000000),
		3:  uint32(0x00020000),
		4:  uint32(0x02000000),
		5:  uint32(0x02020000),
		6:  uint32(0x02000000),
		7:  uint32(0x02020000),
		8:  uint32(0x00000000),
		9:  uint32(0x00020000),
		10: uint32(0x00000000),
		11: uint32(0x00020000),
		12: uint32(0x02000000),
		13: uint32(0x02020000),
		14: uint32(0x02000000),
		15: uint32(0x02020000)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000002),
		2:  uint32(0x00000000),
		3:  uint32(0x00000002),
		4:  uint32(0x00000200),
		5:  uint32(0x00000202),
		6:  uint32(0x00000200),
		7:  uint32(0x00000202),
		8:  uint32(0x00000000),
		9:  uint32(0x00000002),
		10: uint32(0x00000000),
		11: uint32(0x00000002),
		12: uint32(0x00000200),
		13: uint32(0x00000202),
		14: uint32(0x00000200),
		15: uint32(0x00000202)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x00040000),
		2:  uint32(0x00000000),
		3:  uint32(0x00040000),
		4:  uint32(0x04000000),
		5:  uint32(0x04040000),
		6:  uint32(0x04000000),
		7:  uint32(0x04040000),
		8:  uint32(0x00000000),
		9:  uint32(0x00040000),
		10: uint32(0x00000000),
		11: uint32(0x00040000),
		12: uint32(0x04000000),
		13: uint32(0x04040000),
		14: uint32(0x04000000),
		15: uint32(0x04040000)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000004),
		2:  uint32(0x00000000),
		3:  uint32(0x00000004),
		4:  uint32(0x00000400),
		5:  uint32(0x00000404),
		6:  uint32(0x00000400),
		7:  uint32(0x00000404),
		8:  uint32(0x00000000),
		9:  uint32(0x00000004),
		10: uint32(0x00000000),
		11: uint32(0x00000004),
		12: uint32(0x00000400),
		13: uint32(0x00000404),
		14: uint32(0x00000400),
		15: uint32(0x00000404)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x00080000),
		2:  uint32(0x00000000),
		3:  uint32(0x00080000),
		4:  uint32(0x08000000),
		5:  uint32(0x08080000),
		6:  uint32(0x08000000),
		7:  uint32(0x08080000),
		8:  uint32(0x00000000),
		9:  uint32(0x00080000),
		10: uint32(0x00000000),
		11: uint32(0x00080000),
		12: uint32(0x08000000),
		13: uint32(0x08080000),
		14: uint32(0x08000000),
		15: uint32(0x08080000)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000008),
		2:  uint32(0x00000000),
		3:  uint32(0x00000008),
		4:  uint32(0x00000800),
		5:  uint32(0x00000808),
		6:  uint32(0x00000800),
		7:  uint32(0x00000808),
		8:  uint32(0x00000000),
		9:  uint32(0x00000008),
		10: uint32(0x00000000),
		11: uint32(0x00000008),
		12: uint32(0x00000800),
		13: uint32(0x00000808),
		14: uint32(0x00000800),
		15: uint32(0x00000808)},
	8: {
		0:  uint32(0x00000000),
		1:  uint32(0x00100000),
		2:  uint32(0x00000000),
		3:  uint32(0x00100000),
		4:  uint32(0x10000000),
		5:  uint32(0x10100000),
		6:  uint32(0x10000000),
		7:  uint32(0x10100000),
		8:  uint32(0x00000000),
		9:  uint32(0x00100000),
		10: uint32(0x00000000),
		11: uint32(0x00100000),
		12: uint32(0x10000000),
		13: uint32(0x10100000),
		14: uint32(0x10000000),
		15: uint32(0x10100000)},
	9: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000010),
		2:  uint32(0x00000000),
		3:  uint32(0x00000010),
		4:  uint32(0x00001000),
		5:  uint32(0x00001010),
		6:  uint32(0x00001000),
		7:  uint32(0x00001010),
		8:  uint32(0x00000000),
		9:  uint32(0x00000010),
		10: uint32(0x00000000),
		11: uint32(0x00000010),
		12: uint32(0x00001000),
		13: uint32(0x00001010),
		14: uint32(0x00001000),
		15: uint32(0x00001010)},
	10: {
		0:  uint32(0x00000000),
		1:  uint32(0x00200000),
		2:  uint32(0x00000000),
		3:  uint32(0x00200000),
		4:  uint32(0x20000000),
		5:  uint32(0x20200000),
		6:  uint32(0x20000000),
		7:  uint32(0x20200000),
		8:  uint32(0x00000000),
		9:  uint32(0x00200000),
		10: uint32(0x00000000),
		11: uint32(0x00200000),
		12: uint32(0x20000000),
		13: uint32(0x20200000),
		14: uint32(0x20000000),
		15: uint32(0x20200000)},
	11: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000020),
		2:  uint32(0x00000000),
		3:  uint32(0x00000020),
		4:  uint32(0x00002000),
		5:  uint32(0x00002020),
		6:  uint32(0x00002000),
		7:  uint32(0x00002020),
		8:  uint32(0x00000000),
		9:  uint32(0x00000020),
		10: uint32(0x00000000),
		11: uint32(0x00000020),
		12: uint32(0x00002000),
		13: uint32(0x00002020),
		14: uint32(0x00002000),
		15: uint32(0x00002020)},
	12: {
		0:  uint32(0x00000000),
		1:  uint32(0x00400000),
		2:  uint32(0x00000000),
		3:  uint32(0x00400000),
		4:  uint32(0x40000000),
		5:  uint32(0x40400000),
		6:  uint32(0x40000000),
		7:  uint32(0x40400000),
		8:  uint32(0x00000000),
		9:  uint32(0x00400000),
		10: uint32(0x00000000),
		11: uint32(0x00400000),
		12: uint32(0x40000000),
		13: uint32(0x40400000),
		14: uint32(0x40000000),
		15: uint32(0x40400000)},
	13: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000040),
		2:  uint32(0x00000000),
		3:  uint32(0x00000040),
		4:  uint32(0x00004000),
		5:  uint32(0x00004040),
		6:  uint32(0x00004000),
		7:  uint32(0x00004040),
		8:  uint32(0x00000000),
		9:  uint32(0x00000040),
		10: uint32(0x00000000),
		11: uint32(0x00000040),
		12: uint32(0x00004000),
		13: uint32(0x00004040),
		14: uint32(0x00004000),
		15: uint32(0x00004040)},
	14: {
		0:  uint32(0x00000000),
		1:  uint32(0x00800000),
		2:  uint32(0x00000000),
		3:  uint32(0x00800000),
		4:  uint32(0x80000000),
		5:  uint32(0x80800000),
		6:  uint32(0x80000000),
		7:  uint32(0x80800000),
		8:  uint32(0x00000000),
		9:  uint32(0x00800000),
		10: uint32(0x00000000),
		11: uint32(0x00800000),
		12: uint32(0x80000000),
		13: uint32(0x80800000),
		14: uint32(0x80000000),
		15: uint32(0x80800000)},
	15: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000080),
		2:  uint32(0x00000000),
		3:  uint32(0x00000080),
		4:  uint32(0x00008000),
		5:  uint32(0x00008080),
		6:  uint32(0x00008000),
		7:  uint32(0x00008080),
		8:  uint32(0x00000000),
		9:  uint32(0x00000080),
		10: uint32(0x00000000),
		11: uint32(0x00000080),
		12: uint32(0x00008000),
		13: uint32(0x00008080),
		14: uint32(0x00008000),
		15: uint32(0x00008080)}}
var _ip_maskr = [16][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00010000),
		3:  uint32(0x00010000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00010000),
		7:  uint32(0x00010000),
		8:  uint32(0x01000000),
		9:  uint32(0x01000000),
		10: uint32(0x01010000),
		11: uint32(0x01010000),
		12: uint32(0x01000000),
		13: uint32(0x01000000),
		14: uint32(0x01010000),
		15: uint32(0x01010000)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000001),
		3:  uint32(0x00000001),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000001),
		7:  uint32(0x00000001),
		8:  uint32(0x00000100),
		9:  uint32(0x00000100),
		10: uint32(0x00000101),
		11: uint32(0x00000101),
		12: uint32(0x00000100),
		13: uint32(0x00000100),
		14: uint32(0x00000101),
		15: uint32(0x00000101)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00020000),
		3:  uint32(0x00020000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00020000),
		7:  uint32(0x00020000),
		8:  uint32(0x02000000),
		9:  uint32(0x02000000),
		10: uint32(0x02020000),
		11: uint32(0x02020000),
		12: uint32(0x02000000),
		13: uint32(0x02000000),
		14: uint32(0x02020000),
		15: uint32(0x02020000)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000002),
		3:  uint32(0x00000002),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000002),
		7:  uint32(0x00000002),
		8:  uint32(0x00000200),
		9:  uint32(0x00000200),
		10: uint32(0x00000202),
		11: uint32(0x00000202),
		12: uint32(0x00000200),
		13: uint32(0x00000200),
		14: uint32(0x00000202),
		15: uint32(0x00000202)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00040000),
		3:  uint32(0x00040000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00040000),
		7:  uint32(0x00040000),
		8:  uint32(0x04000000),
		9:  uint32(0x04000000),
		10: uint32(0x04040000),
		11: uint32(0x04040000),
		12: uint32(0x04000000),
		13: uint32(0x04000000),
		14: uint32(0x04040000),
		15: uint32(0x04040000)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000004),
		3:  uint32(0x00000004),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000004),
		7:  uint32(0x00000004),
		8:  uint32(0x00000400),
		9:  uint32(0x00000400),
		10: uint32(0x00000404),
		11: uint32(0x00000404),
		12: uint32(0x00000400),
		13: uint32(0x00000400),
		14: uint32(0x00000404),
		15: uint32(0x00000404)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00080000),
		3:  uint32(0x00080000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00080000),
		7:  uint32(0x00080000),
		8:  uint32(0x08000000),
		9:  uint32(0x08000000),
		10: uint32(0x08080000),
		11: uint32(0x08080000),
		12: uint32(0x08000000),
		13: uint32(0x08000000),
		14: uint32(0x08080000),
		15: uint32(0x08080000)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000008),
		3:  uint32(0x00000008),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000008),
		7:  uint32(0x00000008),
		8:  uint32(0x00000800),
		9:  uint32(0x00000800),
		10: uint32(0x00000808),
		11: uint32(0x00000808),
		12: uint32(0x00000800),
		13: uint32(0x00000800),
		14: uint32(0x00000808),
		15: uint32(0x00000808)},
	8: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00100000),
		3:  uint32(0x00100000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00100000),
		7:  uint32(0x00100000),
		8:  uint32(0x10000000),
		9:  uint32(0x10000000),
		10: uint32(0x10100000),
		11: uint32(0x10100000),
		12: uint32(0x10000000),
		13: uint32(0x10000000),
		14: uint32(0x10100000),
		15: uint32(0x10100000)},
	9: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000010),
		3:  uint32(0x00000010),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000010),
		7:  uint32(0x00000010),
		8:  uint32(0x00001000),
		9:  uint32(0x00001000),
		10: uint32(0x00001010),
		11: uint32(0x00001010),
		12: uint32(0x00001000),
		13: uint32(0x00001000),
		14: uint32(0x00001010),
		15: uint32(0x00001010)},
	10: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00200000),
		3:  uint32(0x00200000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00200000),
		7:  uint32(0x00200000),
		8:  uint32(0x20000000),
		9:  uint32(0x20000000),
		10: uint32(0x20200000),
		11: uint32(0x20200000),
		12: uint32(0x20000000),
		13: uint32(0x20000000),
		14: uint32(0x20200000),
		15: uint32(0x20200000)},
	11: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000020),
		3:  uint32(0x00000020),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000020),
		7:  uint32(0x00000020),
		8:  uint32(0x00002000),
		9:  uint32(0x00002000),
		10: uint32(0x00002020),
		11: uint32(0x00002020),
		12: uint32(0x00002000),
		13: uint32(0x00002000),
		14: uint32(0x00002020),
		15: uint32(0x00002020)},
	12: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00400000),
		3:  uint32(0x00400000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00400000),
		7:  uint32(0x00400000),
		8:  uint32(0x40000000),
		9:  uint32(0x40000000),
		10: uint32(0x40400000),
		11: uint32(0x40400000),
		12: uint32(0x40000000),
		13: uint32(0x40000000),
		14: uint32(0x40400000),
		15: uint32(0x40400000)},
	13: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000040),
		3:  uint32(0x00000040),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000040),
		7:  uint32(0x00000040),
		8:  uint32(0x00004000),
		9:  uint32(0x00004000),
		10: uint32(0x00004040),
		11: uint32(0x00004040),
		12: uint32(0x00004000),
		13: uint32(0x00004000),
		14: uint32(0x00004040),
		15: uint32(0x00004040)},
	14: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00800000),
		3:  uint32(0x00800000),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00800000),
		7:  uint32(0x00800000),
		8:  uint32(0x80000000),
		9:  uint32(0x80000000),
		10: uint32(0x80800000),
		11: uint32(0x80800000),
		12: uint32(0x80000000),
		13: uint32(0x80000000),
		14: uint32(0x80800000),
		15: uint32(0x80800000)},
	15: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00000000),
		5:  uint32(0x00000000),
		6:  uint32(0x00000080),
		7:  uint32(0x00000080),
		8:  uint32(0x00008000),
		9:  uint32(0x00008000),
		10: uint32(0x00008080),
		11: uint32(0x00008080),
		12: uint32(0x00008000),
		13: uint32(0x00008000),
		14: uint32(0x00008080),
		15: uint32(0x00008080)}}
var _fp_maskl = [8][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x40000000),
		2:  uint32(0x00400000),
		3:  uint32(0x40400000),
		4:  uint32(0x00004000),
		5:  uint32(0x40004000),
		6:  uint32(0x00404000),
		7:  uint32(0x40404000),
		8:  uint32(0x00000040),
		9:  uint32(0x40000040),
		10: uint32(0x00400040),
		11: uint32(0x40400040),
		12: uint32(0x00004040),
		13: uint32(0x40004040),
		14: uint32(0x00404040),
		15: uint32(0x40404040)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x10000000),
		2:  uint32(0x00100000),
		3:  uint32(0x10100000),
		4:  uint32(0x00001000),
		5:  uint32(0x10001000),
		6:  uint32(0x00101000),
		7:  uint32(0x10101000),
		8:  uint32(0x00000010),
		9:  uint32(0x10000010),
		10: uint32(0x00100010),
		11: uint32(0x10100010),
		12: uint32(0x00001010),
		13: uint32(0x10001010),
		14: uint32(0x00101010),
		15: uint32(0x10101010)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x04000000),
		2:  uint32(0x00040000),
		3:  uint32(0x04040000),
		4:  uint32(0x00000400),
		5:  uint32(0x04000400),
		6:  uint32(0x00040400),
		7:  uint32(0x04040400),
		8:  uint32(0x00000004),
		9:  uint32(0x04000004),
		10: uint32(0x00040004),
		11: uint32(0x04040004),
		12: uint32(0x00000404),
		13: uint32(0x04000404),
		14: uint32(0x00040404),
		15: uint32(0x04040404)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x01000000),
		2:  uint32(0x00010000),
		3:  uint32(0x01010000),
		4:  uint32(0x00000100),
		5:  uint32(0x01000100),
		6:  uint32(0x00010100),
		7:  uint32(0x01010100),
		8:  uint32(0x00000001),
		9:  uint32(0x01000001),
		10: uint32(0x00010001),
		11: uint32(0x01010001),
		12: uint32(0x00000101),
		13: uint32(0x01000101),
		14: uint32(0x00010101),
		15: uint32(0x01010101)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x80000000),
		2:  uint32(0x00800000),
		3:  uint32(0x80800000),
		4:  uint32(0x00008000),
		5:  uint32(0x80008000),
		6:  uint32(0x00808000),
		7:  uint32(0x80808000),
		8:  uint32(0x00000080),
		9:  uint32(0x80000080),
		10: uint32(0x00800080),
		11: uint32(0x80800080),
		12: uint32(0x00008080),
		13: uint32(0x80008080),
		14: uint32(0x00808080),
		15: uint32(0x80808080)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x20000000),
		2:  uint32(0x00200000),
		3:  uint32(0x20200000),
		4:  uint32(0x00002000),
		5:  uint32(0x20002000),
		6:  uint32(0x00202000),
		7:  uint32(0x20202000),
		8:  uint32(0x00000020),
		9:  uint32(0x20000020),
		10: uint32(0x00200020),
		11: uint32(0x20200020),
		12: uint32(0x00002020),
		13: uint32(0x20002020),
		14: uint32(0x00202020),
		15: uint32(0x20202020)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x08000000),
		2:  uint32(0x00080000),
		3:  uint32(0x08080000),
		4:  uint32(0x00000800),
		5:  uint32(0x08000800),
		6:  uint32(0x00080800),
		7:  uint32(0x08080800),
		8:  uint32(0x00000008),
		9:  uint32(0x08000008),
		10: uint32(0x00080008),
		11: uint32(0x08080008),
		12: uint32(0x00000808),
		13: uint32(0x08000808),
		14: uint32(0x00080808),
		15: uint32(0x08080808)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x02000000),
		2:  uint32(0x00020000),
		3:  uint32(0x02020000),
		4:  uint32(0x00000200),
		5:  uint32(0x02000200),
		6:  uint32(0x00020200),
		7:  uint32(0x02020200),
		8:  uint32(0x00000002),
		9:  uint32(0x02000002),
		10: uint32(0x00020002),
		11: uint32(0x02020002),
		12: uint32(0x00000202),
		13: uint32(0x02000202),
		14: uint32(0x00020202),
		15: uint32(0x02020202)}}
var _fp_maskr = [8][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x40000000),
		2:  uint32(0x00400000),
		3:  uint32(0x40400000),
		4:  uint32(0x00004000),
		5:  uint32(0x40004000),
		6:  uint32(0x00404000),
		7:  uint32(0x40404000),
		8:  uint32(0x00000040),
		9:  uint32(0x40000040),
		10: uint32(0x00400040),
		11: uint32(0x40400040),
		12: uint32(0x00004040),
		13: uint32(0x40004040),
		14: uint32(0x00404040),
		15: uint32(0x40404040)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x10000000),
		2:  uint32(0x00100000),
		3:  uint32(0x10100000),
		4:  uint32(0x00001000),
		5:  uint32(0x10001000),
		6:  uint32(0x00101000),
		7:  uint32(0x10101000),
		8:  uint32(0x00000010),
		9:  uint32(0x10000010),
		10: uint32(0x00100010),
		11: uint32(0x10100010),
		12: uint32(0x00001010),
		13: uint32(0x10001010),
		14: uint32(0x00101010),
		15: uint32(0x10101010)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x04000000),
		2:  uint32(0x00040000),
		3:  uint32(0x04040000),
		4:  uint32(0x00000400),
		5:  uint32(0x04000400),
		6:  uint32(0x00040400),
		7:  uint32(0x04040400),
		8:  uint32(0x00000004),
		9:  uint32(0x04000004),
		10: uint32(0x00040004),
		11: uint32(0x04040004),
		12: uint32(0x00000404),
		13: uint32(0x04000404),
		14: uint32(0x00040404),
		15: uint32(0x04040404)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x01000000),
		2:  uint32(0x00010000),
		3:  uint32(0x01010000),
		4:  uint32(0x00000100),
		5:  uint32(0x01000100),
		6:  uint32(0x00010100),
		7:  uint32(0x01010100),
		8:  uint32(0x00000001),
		9:  uint32(0x01000001),
		10: uint32(0x00010001),
		11: uint32(0x01010001),
		12: uint32(0x00000101),
		13: uint32(0x01000101),
		14: uint32(0x00010101),
		15: uint32(0x01010101)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x80000000),
		2:  uint32(0x00800000),
		3:  uint32(0x80800000),
		4:  uint32(0x00008000),
		5:  uint32(0x80008000),
		6:  uint32(0x00808000),
		7:  uint32(0x80808000),
		8:  uint32(0x00000080),
		9:  uint32(0x80000080),
		10: uint32(0x00800080),
		11: uint32(0x80800080),
		12: uint32(0x00008080),
		13: uint32(0x80008080),
		14: uint32(0x00808080),
		15: uint32(0x80808080)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x20000000),
		2:  uint32(0x00200000),
		3:  uint32(0x20200000),
		4:  uint32(0x00002000),
		5:  uint32(0x20002000),
		6:  uint32(0x00202000),
		7:  uint32(0x20202000),
		8:  uint32(0x00000020),
		9:  uint32(0x20000020),
		10: uint32(0x00200020),
		11: uint32(0x20200020),
		12: uint32(0x00002020),
		13: uint32(0x20002020),
		14: uint32(0x00202020),
		15: uint32(0x20202020)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x08000000),
		2:  uint32(0x00080000),
		3:  uint32(0x08080000),
		4:  uint32(0x00000800),
		5:  uint32(0x08000800),
		6:  uint32(0x00080800),
		7:  uint32(0x08080800),
		8:  uint32(0x00000008),
		9:  uint32(0x08000008),
		10: uint32(0x00080008),
		11: uint32(0x08080008),
		12: uint32(0x00000808),
		13: uint32(0x08000808),
		14: uint32(0x00080808),
		15: uint32(0x08080808)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x02000000),
		2:  uint32(0x00020000),
		3:  uint32(0x02020000),
		4:  uint32(0x00000200),
		5:  uint32(0x02000200),
		6:  uint32(0x00020200),
		7:  uint32(0x02020200),
		8:  uint32(0x00000002),
		9:  uint32(0x02000002),
		10: uint32(0x00020002),
		11: uint32(0x02020002),
		12: uint32(0x00000202),
		13: uint32(0x02000202),
		14: uint32(0x00020202),
		15: uint32(0x02020202)}}
var _key_perm_maskl = [8][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000010),
		3:  uint32(0x00000010),
		4:  uint32(0x00001000),
		5:  uint32(0x00001000),
		6:  uint32(0x00001010),
		7:  uint32(0x00001010),
		8:  uint32(0x00100000),
		9:  uint32(0x00100000),
		10: uint32(0x00100010),
		11: uint32(0x00100010),
		12: uint32(0x00101000),
		13: uint32(0x00101000),
		14: uint32(0x00101010),
		15: uint32(0x00101010)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000020),
		3:  uint32(0x00000020),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00002020),
		7:  uint32(0x00002020),
		8:  uint32(0x00200000),
		9:  uint32(0x00200000),
		10: uint32(0x00200020),
		11: uint32(0x00200020),
		12: uint32(0x00202000),
		13: uint32(0x00202000),
		14: uint32(0x00202020),
		15: uint32(0x00202020)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000040),
		3:  uint32(0x00000040),
		4:  uint32(0x00004000),
		5:  uint32(0x00004000),
		6:  uint32(0x00004040),
		7:  uint32(0x00004040),
		8:  uint32(0x00400000),
		9:  uint32(0x00400000),
		10: uint32(0x00400040),
		11: uint32(0x00400040),
		12: uint32(0x00404000),
		13: uint32(0x00404000),
		14: uint32(0x00404040),
		15: uint32(0x00404040)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00008000),
		5:  uint32(0x00008000),
		6:  uint32(0x00008080),
		7:  uint32(0x00008080),
		8:  uint32(0x00800000),
		9:  uint32(0x00800000),
		10: uint32(0x00800080),
		11: uint32(0x00800080),
		12: uint32(0x00808000),
		13: uint32(0x00808000),
		14: uint32(0x00808080),
		15: uint32(0x00808080)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000001),
		2:  uint32(0x00000100),
		3:  uint32(0x00000101),
		4:  uint32(0x00010000),
		5:  uint32(0x00010001),
		6:  uint32(0x00010100),
		7:  uint32(0x00010101),
		8:  uint32(0x01000000),
		9:  uint32(0x01000001),
		10: uint32(0x01000100),
		11: uint32(0x01000101),
		12: uint32(0x01010000),
		13: uint32(0x01010001),
		14: uint32(0x01010100),
		15: uint32(0x01010101)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000002),
		2:  uint32(0x00000200),
		3:  uint32(0x00000202),
		4:  uint32(0x00020000),
		5:  uint32(0x00020002),
		6:  uint32(0x00020200),
		7:  uint32(0x00020202),
		8:  uint32(0x02000000),
		9:  uint32(0x02000002),
		10: uint32(0x02000200),
		11: uint32(0x02000202),
		12: uint32(0x02020000),
		13: uint32(0x02020002),
		14: uint32(0x02020200),
		15: uint32(0x02020202)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000004),
		2:  uint32(0x00000400),
		3:  uint32(0x00000404),
		4:  uint32(0x00040000),
		5:  uint32(0x00040004),
		6:  uint32(0x00040400),
		7:  uint32(0x00040404),
		8:  uint32(0x04000000),
		9:  uint32(0x04000004),
		10: uint32(0x04000400),
		11: uint32(0x04000404),
		12: uint32(0x04040000),
		13: uint32(0x04040004),
		14: uint32(0x04040400),
		15: uint32(0x04040404)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000008),
		2:  uint32(0x00000800),
		3:  uint32(0x00000808),
		4:  uint32(0x00080000),
		5:  uint32(0x00080008),
		6:  uint32(0x00080800),
		7:  uint32(0x00080808),
		8:  uint32(0x08000000),
		9:  uint32(0x08000008),
		10: uint32(0x08000800),
		11: uint32(0x08000808),
		12: uint32(0x08080000),
		13: uint32(0x08080008),
		14: uint32(0x08080800),
		15: uint32(0x08080808)}}
var _key_perm_maskr = [12][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000001),
		2:  uint32(0x00000000),
		3:  uint32(0x00000001),
		4:  uint32(0x00000000),
		5:  uint32(0x00000001),
		6:  uint32(0x00000000),
		7:  uint32(0x00000001),
		8:  uint32(0x00000000),
		9:  uint32(0x00000001),
		10: uint32(0x00000000),
		11: uint32(0x00000001),
		12: uint32(0x00000000),
		13: uint32(0x00000001),
		14: uint32(0x00000000),
		15: uint32(0x00000001)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00100000),
		3:  uint32(0x00100000),
		4:  uint32(0x00001000),
		5:  uint32(0x00001000),
		6:  uint32(0x00101000),
		7:  uint32(0x00101000),
		8:  uint32(0x00000010),
		9:  uint32(0x00000010),
		10: uint32(0x00100010),
		11: uint32(0x00100010),
		12: uint32(0x00001010),
		13: uint32(0x00001010),
		14: uint32(0x00101010),
		15: uint32(0x00101010)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000002),
		2:  uint32(0x00000000),
		3:  uint32(0x00000002),
		4:  uint32(0x00000000),
		5:  uint32(0x00000002),
		6:  uint32(0x00000000),
		7:  uint32(0x00000002),
		8:  uint32(0x00000000),
		9:  uint32(0x00000002),
		10: uint32(0x00000000),
		11: uint32(0x00000002),
		12: uint32(0x00000000),
		13: uint32(0x00000002),
		14: uint32(0x00000000),
		15: uint32(0x00000002)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00200000),
		3:  uint32(0x00200000),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00202000),
		7:  uint32(0x00202000),
		8:  uint32(0x00000020),
		9:  uint32(0x00000020),
		10: uint32(0x00200020),
		11: uint32(0x00200020),
		12: uint32(0x00002020),
		13: uint32(0x00002020),
		14: uint32(0x00202020),
		15: uint32(0x00202020)},
	4: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000004),
		2:  uint32(0x00000000),
		3:  uint32(0x00000004),
		4:  uint32(0x00000000),
		5:  uint32(0x00000004),
		6:  uint32(0x00000000),
		7:  uint32(0x00000004),
		8:  uint32(0x00000000),
		9:  uint32(0x00000004),
		10: uint32(0x00000000),
		11: uint32(0x00000004),
		12: uint32(0x00000000),
		13: uint32(0x00000004),
		14: uint32(0x00000000),
		15: uint32(0x00000004)},
	5: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00400000),
		3:  uint32(0x00400000),
		4:  uint32(0x00004000),
		5:  uint32(0x00004000),
		6:  uint32(0x00404000),
		7:  uint32(0x00404000),
		8:  uint32(0x00000040),
		9:  uint32(0x00000040),
		10: uint32(0x00400040),
		11: uint32(0x00400040),
		12: uint32(0x00004040),
		13: uint32(0x00004040),
		14: uint32(0x00404040),
		15: uint32(0x00404040)},
	6: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000008),
		2:  uint32(0x00000000),
		3:  uint32(0x00000008),
		4:  uint32(0x00000000),
		5:  uint32(0x00000008),
		6:  uint32(0x00000000),
		7:  uint32(0x00000008),
		8:  uint32(0x00000000),
		9:  uint32(0x00000008),
		10: uint32(0x00000000),
		11: uint32(0x00000008),
		12: uint32(0x00000000),
		13: uint32(0x00000008),
		14: uint32(0x00000000),
		15: uint32(0x00000008)},
	7: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00800000),
		3:  uint32(0x00800000),
		4:  uint32(0x00008000),
		5:  uint32(0x00008000),
		6:  uint32(0x00808000),
		7:  uint32(0x00808000),
		8:  uint32(0x00000080),
		9:  uint32(0x00000080),
		10: uint32(0x00800080),
		11: uint32(0x00800080),
		12: uint32(0x00008080),
		13: uint32(0x00008080),
		14: uint32(0x00808080),
		15: uint32(0x00808080)},
	8: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x01000000),
		3:  uint32(0x01000000),
		4:  uint32(0x00010000),
		5:  uint32(0x00010000),
		6:  uint32(0x01010000),
		7:  uint32(0x01010000),
		8:  uint32(0x00000100),
		9:  uint32(0x00000100),
		10: uint32(0x01000100),
		11: uint32(0x01000100),
		12: uint32(0x00010100),
		13: uint32(0x00010100),
		14: uint32(0x01010100),
		15: uint32(0x01010100)},
	9: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x02000000),
		3:  uint32(0x02000000),
		4:  uint32(0x00020000),
		5:  uint32(0x00020000),
		6:  uint32(0x02020000),
		7:  uint32(0x02020000),
		8:  uint32(0x00000200),
		9:  uint32(0x00000200),
		10: uint32(0x02000200),
		11: uint32(0x02000200),
		12: uint32(0x00020200),
		13: uint32(0x00020200),
		14: uint32(0x02020200),
		15: uint32(0x02020200)},
	10: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x04000000),
		3:  uint32(0x04000000),
		4:  uint32(0x00040000),
		5:  uint32(0x00040000),
		6:  uint32(0x04040000),
		7:  uint32(0x04040000),
		8:  uint32(0x00000400),
		9:  uint32(0x00000400),
		10: uint32(0x04000400),
		11: uint32(0x04000400),
		12: uint32(0x00040400),
		13: uint32(0x00040400),
		14: uint32(0x04040400),
		15: uint32(0x04040400)},
	11: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x08000000),
		3:  uint32(0x08000000),
		4:  uint32(0x00080000),
		5:  uint32(0x00080000),
		6:  uint32(0x08080000),
		7:  uint32(0x08080000),
		8:  uint32(0x00000800),
		9:  uint32(0x00000800),
		10: uint32(0x08000800),
		11: uint32(0x08000800),
		12: uint32(0x00080800),
		13: uint32(0x00080800),
		14: uint32(0x08080800),
		15: uint32(0x08080800)}}
var _comp_maskl0 = [4][8]Tuint32_t{
	0: {
		0: uint32(0x00000000),
		1: uint32(0x00020000),
		2: uint32(0x00000001),
		3: uint32(0x00020001),
		4: uint32(0x00080000),
		5: uint32(0x000a0000),
		6: uint32(0x00080001),
		7: uint32(0x000a0001)},
	1: {
		0: uint32(0x00000000),
		1: uint32(0x00001000),
		2: uint32(0x00000000),
		3: uint32(0x00001000),
		4: uint32(0x00000040),
		5: uint32(0x00001040),
		6: uint32(0x00000040),
		7: uint32(0x00001040)},
	2: {
		0: uint32(0x00000000),
		1: uint32(0x00400000),
		2: uint32(0x00000020),
		3: uint32(0x00400020),
		4: uint32(0x00008000),
		5: uint32(0x00408000),
		6: uint32(0x00008020),
		7: uint32(0x00408020)},
	3: {
		0: uint32(0x00000000),
		1: uint32(0x00100000),
		2: uint32(0x00000800),
		3: uint32(0x00100800),
		4: uint32(0x00000000),
		5: uint32(0x00100000),
		6: uint32(0x00000800),
		7: uint32(0x00100800)}}
var _comp_maskr0 = [4][8]Tuint32_t{
	0: {
		0: uint32(0x00000000),
		1: uint32(0x00200000),
		2: uint32(0x00020000),
		3: uint32(0x00220000),
		4: uint32(0x00000002),
		5: uint32(0x00200002),
		6: uint32(0x00020002),
		7: uint32(0x00220002)},
	1: {
		0: uint32(0x00000000),
		1: uint32(0x00000000),
		2: uint32(0x00100000),
		3: uint32(0x00100000),
		4: uint32(0x00000004),
		5: uint32(0x00000004),
		6: uint32(0x00100004),
		7: uint32(0x00100004)},
	2: {
		0: uint32(0x00000000),
		1: uint32(0x00004000),
		2: uint32(0x00000800),
		3: uint32(0x00004800),
		4: uint32(0x00000000),
		5: uint32(0x00004000),
		6: uint32(0x00000800),
		7: uint32(0x00004800)},
	3: {
		0: uint32(0x00000000),
		1: uint32(0x00400000),
		2: uint32(0x00008000),
		3: uint32(0x00408000),
		4: uint32(0x00000008),
		5: uint32(0x00400008),
		6: uint32(0x00008008),
		7: uint32(0x00408008)}}
var _comp_maskl1 = [4][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000010),
		2:  uint32(0x00004000),
		3:  uint32(0x00004010),
		4:  uint32(0x00040000),
		5:  uint32(0x00040010),
		6:  uint32(0x00044000),
		7:  uint32(0x00044010),
		8:  uint32(0x00000100),
		9:  uint32(0x00000110),
		10: uint32(0x00004100),
		11: uint32(0x00004110),
		12: uint32(0x00040100),
		13: uint32(0x00040110),
		14: uint32(0x00044100),
		15: uint32(0x00044110)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00800000),
		2:  uint32(0x00000002),
		3:  uint32(0x00800002),
		4:  uint32(0x00000200),
		5:  uint32(0x00800200),
		6:  uint32(0x00000202),
		7:  uint32(0x00800202),
		8:  uint32(0x00200000),
		9:  uint32(0x00a00000),
		10: uint32(0x00200002),
		11: uint32(0x00a00002),
		12: uint32(0x00200200),
		13: uint32(0x00a00200),
		14: uint32(0x00200202),
		15: uint32(0x00a00202)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00002000),
		2:  uint32(0x00000004),
		3:  uint32(0x00002004),
		4:  uint32(0x00000400),
		5:  uint32(0x00002400),
		6:  uint32(0x00000404),
		7:  uint32(0x00002404),
		8:  uint32(0x00000000),
		9:  uint32(0x00002000),
		10: uint32(0x00000004),
		11: uint32(0x00002004),
		12: uint32(0x00000400),
		13: uint32(0x00002400),
		14: uint32(0x00000404),
		15: uint32(0x00002404)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00010000),
		2:  uint32(0x00000008),
		3:  uint32(0x00010008),
		4:  uint32(0x00000080),
		5:  uint32(0x00010080),
		6:  uint32(0x00000088),
		7:  uint32(0x00010088),
		8:  uint32(0x00000000),
		9:  uint32(0x00010000),
		10: uint32(0x00000008),
		11: uint32(0x00010008),
		12: uint32(0x00000080),
		13: uint32(0x00010080),
		14: uint32(0x00000088),
		15: uint32(0x00010088)}}
var _comp_maskr1 = [4][16]Tuint32_t{
	0: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000000),
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00002080),
		7:  uint32(0x00002080),
		8:  uint32(0x00000001),
		9:  uint32(0x00000001),
		10: uint32(0x00000081),
		11: uint32(0x00000081),
		12: uint32(0x00002001),
		13: uint32(0x00002001),
		14: uint32(0x00002081),
		15: uint32(0x00002081)},
	1: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000010),
		2:  uint32(0x00800000),
		3:  uint32(0x00800010),
		4:  uint32(0x00010000),
		5:  uint32(0x00010010),
		6:  uint32(0x00810000),
		7:  uint32(0x00810010),
		8:  uint32(0x00000200),
		9:  uint32(0x00000210),
		10: uint32(0x00800200),
		11: uint32(0x00800210),
		12: uint32(0x00010200),
		13: uint32(0x00010210),
		14: uint32(0x00810200),
		15: uint32(0x00810210)},
	2: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000400),
		2:  uint32(0x00001000),
		3:  uint32(0x00001400),
		4:  uint32(0x00080000),
		5:  uint32(0x00080400),
		6:  uint32(0x00081000),
		7:  uint32(0x00081400),
		8:  uint32(0x00000020),
		9:  uint32(0x00000420),
		10: uint32(0x00001020),
		11: uint32(0x00001420),
		12: uint32(0x00080020),
		13: uint32(0x00080420),
		14: uint32(0x00081020),
		15: uint32(0x00081420)},
	3: {
		0:  uint32(0x00000000),
		1:  uint32(0x00000100),
		2:  uint32(0x00040000),
		3:  uint32(0x00040100),
		4:  uint32(0x00000000),
		5:  uint32(0x00000100),
		6:  uint32(0x00040000),
		7:  uint32(0x00040100),
		8:  uint32(0x00000040),
		9:  uint32(0x00000140),
		10: uint32(0x00040040),
		11: uint32(0x00040140),
		12: uint32(0x00000040),
		13: uint32(0x00000140),
		14: uint32(0x00040040),
		15: uint32(0x00040140)}}

var _ascii64 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

/*   0000000000111111111122222222223333333333444444444455555555556666 */
/*   0123456789012345678901234567890123456789012345678901234567890123 */

// C documentation
//
//	/*
//	 * We match the behavior of UFC-crypt on systems where "char" is signed by
//	 * default (the majority), regardless of char's signedness on our system.
//	 */
func _ascii_to_bin(tls *TLS, ch int32) (r Tuint32_t) {
	var retval int32
	var sch int32
	var v1 int32
	if ch < int32(0x80) {
		v1 = ch
	} else {
		v1 = -(int32(0x100) - ch)
	}
	sch = v1
	retval = sch - int32('.')
	if sch >= int32('A') {
		retval = sch - (Int32FromUint8('A') - Int32FromInt32(12))
		if sch >= int32('a') {
			retval = sch - (Int32FromUint8('a') - Int32FromInt32(38))
		}
	}
	retval = retval & Int32FromInt32(0x3f)
	return uint32(retval)
}

// C documentation
//
//	/*
//	 * When we choose to "support" invalid salts, nevertheless disallow those
//	 * containing characters that would violate the passwd file format.
//	 */
func _ascii_is_unsafe(tls *TLS, ch uint8) (r int32) {
	return BoolInt32(!(ch != 0) || int32(ch) == int32('\n') || int32(ch) == int32(':'))
}

func _setup_salt(tls *TLS, salt Tuint32_t) (r Tuint32_t) {
	var i uint32
	var obit Tuint32_t
	var saltbit Tuint32_t
	var saltbits Tuint32_t
	saltbits = uint32(0)
	saltbit = uint32(1)
	obit = uint32(0x800000)
	for i = uint32(0); i < uint32(24); i++ {
		if salt&saltbit != 0 {
			saltbits = saltbits | obit
		}
		saltbit = saltbit << Uint32FromInt32(1)
		obit = obit >> Uint32FromInt32(1)
	}
	return saltbits
}

func x___des_setkey(tls *TLS, key uintptr, ekey uintptr) {
	var i uint32
	var ibit uint32
	var j uint32
	var k0 Tuint32_t
	var k1 Tuint32_t
	var kl Tuint32_t
	var kr Tuint32_t
	var rawkey0 Tuint32_t
	var rawkey1 Tuint32_t
	var round uint32
	var shifts uint32
	var t0 Tuint32_t
	var t1 Tuint32_t
	var v1 Tuint32_t
	var v3 Tuint32_t
	rawkey0 = uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(3)))) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(2))))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(1))))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(0))))<<Int32FromInt32(24)
	rawkey1 = uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(7)))) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(6))))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(5))))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(key + UintptrFromInt32(4))))<<Int32FromInt32(24)
	/*
	 * Do key permutation and split into two 28-bit subkeys.
	 */
	v1 = Uint32FromInt32(0)
	k1 = v1
	k0 = v1
	i = uint32(0)
	ibit = Uint32FromInt32(28)
	for i < uint32(4) {
		j = i << int32(1)
		k0 = k0 | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskl)) + uintptr(i)*64 + uintptr(rawkey0>>ibit&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskl)) + uintptr(i+Uint32FromInt32(4))*64 + uintptr(rawkey1>>ibit&Uint32FromInt32(0xf))*4)))
		k1 = k1 | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(j)*64 + uintptr(rawkey0>>ibit&Uint32FromInt32(0xf))*4))
		ibit = ibit - Uint32FromInt32(4)
		k1 = k1 | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(j+Uint32FromInt32(1))*64 + uintptr(rawkey0>>ibit&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(i+Uint32FromInt32(8))*64 + uintptr(rawkey1>>ibit&Uint32FromInt32(0xf))*4)))
		goto _2
	_2:
		i++
		ibit = ibit - Uint32FromInt32(4)
	}
	/*
	 * Rotate subkeys and do compression permutation.
	 */
	shifts = uint32(0)
	for round = uint32(0); round < uint32(16); round++ {
		shifts = shifts + uint32(_key_shifts[round])
		t0 = k0<<shifts | k0>>(Uint32FromInt32(28)-shifts)
		t1 = k1<<shifts | k1>>(Uint32FromInt32(28)-shifts)
		v3 = Uint32FromInt32(0)
		kr = v3
		kl = v3
		ibit = uint32(25)
		for i = uint32(0); i < uint32(4); i++ {
			kl = kl | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskl0)) + uintptr(i)*32 + uintptr(t0>>ibit&Uint32FromInt32(7))*4))
			kr = kr | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskr0)) + uintptr(i)*32 + uintptr(t1>>ibit&Uint32FromInt32(7))*4))
			ibit = ibit - Uint32FromInt32(4)
			kl = kl | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskl1)) + uintptr(i)*64 + uintptr(t0>>ibit&Uint32FromInt32(0xf))*4))
			kr = kr | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskr1)) + uintptr(i)*64 + uintptr(t1>>ibit&Uint32FromInt32(0xf))*4))
			ibit = ibit - Uint32FromInt32(3)
		}
		*(*Tuint32_t)(unsafe.Pointer(ekey + uintptr(round)*4)) = kl
		*(*Tuint32_t)(unsafe.Pointer(ekey + 64 + uintptr(round)*4)) = kr
	}
}

// C documentation
//
//	/*
//	 * l_in, r_in, l_out, and r_out are in pseudo-"big-endian" format.
//	 */
func x___do_des(tls *TLS, l_in Tuint32_t, r_in Tuint32_t, l_out uintptr, r_out uintptr, count Tuint32_t, saltbits Tuint32_t, ekey uintptr) {
	var f Tuint32_t
	var i uint32
	var i1 uint32
	var ibit uint32
	var ibit1 uint32
	var kl uintptr
	var kr uintptr
	var l Tuint32_t
	var lo Tuint32_t
	var r Tuint32_t
	var r48l Tuint32_t
	var r48r Tuint32_t
	var ro Tuint32_t
	var round uint32
	var v1 Tuint32_t
	var v3 Tuint32_t
	var v4 uint32
	var v5 uintptr
	var v6 uintptr
	var v7 Tuint32_t
	/*
	 * Do initial permutation (IP).
	 */
	v1 = Uint32FromInt32(0)
	r = v1
	l = v1
	if l_in|r_in != 0 {
		i = uint32(0)
		ibit = Uint32FromInt32(28)
		for i < uint32(8) {
			l = l | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskl)) + uintptr(i)*64 + uintptr(l_in>>ibit&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskl)) + uintptr(i+Uint32FromInt32(8))*64 + uintptr(r_in>>ibit&Uint32FromInt32(0xf))*4)))
			r = r | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskr)) + uintptr(i)*64 + uintptr(l_in>>ibit&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskr)) + uintptr(i+Uint32FromInt32(8))*64 + uintptr(r_in>>ibit&Uint32FromInt32(0xf))*4)))
			goto _2
		_2:
			i++
			ibit = ibit - Uint32FromInt32(4)
		}
	}
	for {
		v3 = count
		count--
		if !(v3 != 0) {
			break
		}
		/*
		 * Do each round.
		 */
		round = uint32(16)
		kl = ekey
		kr = ekey + 64
		for {
			v4 = round
			round--
			if !(v4 != 0) {
				break
			}
			/*
			 * Expand R to 48 bits (simulate the E-box).
			 */
			r48l = r&uint32(0x00000001)<<int32(23) | r&uint32(0xf8000000)>>int32(9) | r&uint32(0x1f800000)>>int32(11) | r&uint32(0x01f80000)>>int32(13) | r&uint32(0x001f8000)>>int32(15)
			r48r = r&uint32(0x0001f800)<<int32(7) | r&uint32(0x00001f80)<<int32(5) | r&uint32(0x000001f8)<<int32(3) | r&uint32(0x0000001f)<<int32(1) | r&uint32(0x80000000)>>int32(31)
			/*
			 * Do salting for crypt() and friends, and
			 * XOR with the permuted key.
			 */
			f = (r48l ^ r48r) & saltbits
			v5 = kl
			kl += 4
			r48l = r48l ^ (f ^ *(*Tuint32_t)(unsafe.Pointer(v5)))
			v6 = kr
			kr += 4
			r48r = r48r ^ (f ^ *(*Tuint32_t)(unsafe.Pointer(v6)))
			/*
			 * Do S-box lookups (which shrink it back to 32 bits)
			 * and do the P-box permutation at the same time.
			 */
			f = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(0)*256 + uintptr(r48l>>Int32FromInt32(18))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(1)*256 + uintptr(r48l>>Int32FromInt32(12)&Uint32FromInt32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(2)*256 + uintptr(r48l>>Int32FromInt32(6)&Uint32FromInt32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(3)*256 + uintptr(r48l&Uint32FromInt32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(4)*256 + uintptr(r48r>>Int32FromInt32(18))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(5)*256 + uintptr(r48r>>Int32FromInt32(12)&Uint32FromInt32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(6)*256 + uintptr(r48r>>Int32FromInt32(6)&Uint32FromInt32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + UintptrFromInt32(7)*256 + uintptr(r48r&Uint32FromInt32(0x3f))*4))
			/*
			 * Now that we've permuted things, complete f().
			 */
			f = f ^ l
			l = r
			r = f
		}
		r = l
		l = f
	}
	{
		/*
		 * Do final permutation (inverse of IP).
		 */
		v7 = Uint32FromInt32(0)
		ro = v7
		lo = v7
		i1 = uint32(0)
		ibit1 = Uint32FromInt32(28)
		for i1 < uint32(4) {
			ro = ro | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskr)) + uintptr(i1)*64 + uintptr(l>>ibit1&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskr)) + uintptr(i1+Uint32FromInt32(4))*64 + uintptr(r>>ibit1&Uint32FromInt32(0xf))*4)))
			ibit1 = ibit1 - Uint32FromInt32(4)
			lo = lo | (*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskl)) + uintptr(i1)*64 + uintptr(l>>ibit1&Uint32FromInt32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskl)) + uintptr(i1+Uint32FromInt32(4))*64 + uintptr(r>>ibit1&Uint32FromInt32(0xf))*4)))
			goto _8
		_8:
			i1++
			ibit1 = ibit1 - Uint32FromInt32(4)
		}
		*(*Tuint32_t)(unsafe.Pointer(l_out)) = lo
		*(*Tuint32_t)(unsafe.Pointer(r_out)) = ro
	}
}

func _des_cipher(tls *TLS, in uintptr, out uintptr, count Tuint32_t, saltbits Tuint32_t, ekey uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var rawl Tuint32_t
	var rawr Tuint32_t
	var _ /* l_out at bp+0 */ Tuint32_t
	var _ /* r_out at bp+4 */ Tuint32_t
	rawl = uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(3)))) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(2))))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(1))))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(0))))<<Int32FromInt32(24)
	rawr = uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(7)))) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(6))))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(5))))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(in + UintptrFromInt32(4))))<<Int32FromInt32(24)
	x___do_des(tls, rawl, rawr, bp, bp+4, count, saltbits, ekey)
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(0))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(24))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(1))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(16))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(2))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(8))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(3))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(4))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(24))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(5))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(16))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(6))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(8))
	*(*uint8)(unsafe.Pointer(out + UintptrFromInt32(7))) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)))
}

func __crypt_extended_r_uut(tls *TLS, _key uintptr, _setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(144) /* tlsAllocs 144 maxValist 0 */
	defer tls.Free(144)
	var count Tuint32_t
	var i uint32
	var key uintptr
	var l Tuint32_t
	var p uintptr
	var q uintptr
	var salt Tuint32_t
	var setting uintptr
	var value Tuint32_t
	var value1 Tuint32_t
	var _ /* ekey at bp+0 */ Texpanded_key
	var _ /* keybuf at bp+128 */ [8]uint8
	var _ /* r0 at bp+136 */ Tuint32_t
	var _ /* r1 at bp+140 */ Tuint32_t
	var v1 uintptr
	var v10 uintptr
	var v11 uintptr
	var v12 uintptr
	var v13 uintptr
	var v14 uintptr
	var v15 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	var v8 uintptr
	var v9 uintptr
	var p2 uintptr
	key = _key
	setting = _setting
	/*
	 * Copy the key, shifting each character left by one bit and padding
	 * with zeroes.
	 */
	q = bp + 128
	for q <= bp+128+uintptr(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		v1 = q
		q++
		*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(key))) << int32(1))
		if *(*uint8)(unsafe.Pointer(key)) != 0 {
			key++
		}
	}
	x___des_setkey(tls, bp+128, bp)
	if int32(*(*uint8)(unsafe.Pointer(setting))) == int32('_') {
		/*
		 * "new"-style:
		 *	setting - underscore, 4 chars of count, 4 chars of salt
		 *	key - unlimited characters
		 */
		i = uint32(1)
		count = Uint32FromInt32(0)
		for ; i < uint32(5); i++ {
			value = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))))
			if int32(_ascii64[value]) != int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))) {
				return UintptrFromInt32(0)
			}
			count = count | value<<((i-Uint32FromInt32(1))*Uint32FromInt32(6))
		}
		if !(count != 0) {
			return UintptrFromInt32(0)
		}
		i = uint32(5)
		salt = Uint32FromInt32(0)
		for ; i < uint32(9); i++ {
			value1 = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))))
			if int32(_ascii64[value1]) != int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))) {
				return UintptrFromInt32(0)
			}
			salt = salt | value1<<((i-Uint32FromInt32(5))*Uint32FromInt32(6))
		}
		for *(*uint8)(unsafe.Pointer(key)) != 0 {
			/*
			 * Encrypt the key with itself.
			 */
			_des_cipher(tls, bp+128, bp+128, uint32(1), uint32(0), bp)
			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = bp + 128
			for q <= bp+128+uintptr(Uint64FromInt64(8)-Uint64FromInt32(1)) && *(*uint8)(unsafe.Pointer(key)) != 0 {
				v3 = q
				q++
				p2 = v3
				v4 = key
				key++
				*(*uint8)(unsafe.Pointer(p2)) = uint8(int32(*(*uint8)(unsafe.Pointer(p2))) ^ int32(*(*uint8)(unsafe.Pointer(v4)))<<Int32FromInt32(1))
			}
			x___des_setkey(tls, bp+128, bp)
		}
		x_memcpy(tls, output, setting, uint64(9))
		*(*int8)(unsafe.Pointer(output + UintptrFromInt32(9))) = int8('\000')
		p = output + uintptr(9)
	} else {
		/*
		 * "old"-style:
		 *	setting - 2 chars of salt
		 *	key - up to 8 characters
		 */
		count = uint32(25)
		if _ascii_is_unsafe(tls, *(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(0)))) != 0 || _ascii_is_unsafe(tls, *(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(1)))) != 0 {
			return UintptrFromInt32(0)
		}
		salt = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(1)))))<<Int32FromInt32(6) | _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(0)))))
		*(*int8)(unsafe.Pointer(output + UintptrFromInt32(0))) = int8(*(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(0))))
		*(*int8)(unsafe.Pointer(output + UintptrFromInt32(1))) = int8(*(*uint8)(unsafe.Pointer(setting + UintptrFromInt32(1))))
		p = output + uintptr(2)
	}
	/*
	 * Do it.
	 */
	x___do_des(tls, uint32(0), uint32(0), bp+136, bp+140, count, _setup_salt(tls, salt), bp)
	/*
	 * Now encode the result...
	 */
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 136)) >> int32(8)
	v5 = p
	p++
	*(*uint8)(unsafe.Pointer(v5)) = _ascii64[l>>Int32FromInt32(18)&uint32(0x3f)]
	v6 = p
	p++
	*(*uint8)(unsafe.Pointer(v6)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v7 = p
	p++
	*(*uint8)(unsafe.Pointer(v7)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v8 = p
	p++
	*(*uint8)(unsafe.Pointer(v8)) = _ascii64[l&uint32(0x3f)]
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 136))<<Int32FromInt32(16) | *(*Tuint32_t)(unsafe.Pointer(bp + 140))>>Int32FromInt32(16)&uint32(0xffff)
	v9 = p
	p++
	*(*uint8)(unsafe.Pointer(v9)) = _ascii64[l>>Int32FromInt32(18)&uint32(0x3f)]
	v10 = p
	p++
	*(*uint8)(unsafe.Pointer(v10)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v11 = p
	p++
	*(*uint8)(unsafe.Pointer(v11)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v12 = p
	p++
	*(*uint8)(unsafe.Pointer(v12)) = _ascii64[l&uint32(0x3f)]
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 140)) << int32(2)
	v13 = p
	p++
	*(*uint8)(unsafe.Pointer(v13)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v14 = p
	p++
	*(*uint8)(unsafe.Pointer(v14)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v15 = p
	p++
	*(*uint8)(unsafe.Pointer(v15)) = _ascii64[l&uint32(0x3f)]
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return output
}

func x___crypt_des(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var p uintptr
	var retval uintptr
	var test_hash uintptr
	var test_key uintptr
	var test_setting uintptr
	var _ /* test_buf at bp+0 */ [21]int8
	var v1 uintptr
	test_key = ts + 67
	test_setting = ts + 88
	test_hash = ts + 98
	if int32(*(*int8)(unsafe.Pointer(setting))) != int32('_') {
		test_setting = ts + 119
		test_hash = ts + 122
	}
	/*
	 * Hash the supplied password.
	 */
	retval = __crypt_extended_r_uut(tls, key, setting, output)
	/*
	 * Perform a quick self-test.  It is important that we make both calls
	 * to _crypt_extended_r_uut() from the same scope such that they likely
	 * use the same stack locations, which makes the second call overwrite
	 * the first call's sensitive data on the stack and makes it more
	 * likely that any alignment related issues would be detected.
	 */
	p = __crypt_extended_r_uut(tls, test_key, test_setting, bp)
	if p != 0 && !(x_strcmp(tls, p, test_hash) != 0) && retval != 0 {
		return retval
	}
	if int32(*(*int8)(unsafe.Pointer(setting + UintptrFromInt32(0)))) == int32('*') {
		v1 = ts + 136
	} else {
		v1 = ts + 65
	}
	return v1
}

const m_KEY_MAX = 30000
const m_SALT_MAX = 8

/* public domain md5 implementation based on rfc1321 and libtomcrypt */

type Tmd5 = struct {
	Flen1 Tuint64_t
	Fh    [4]Tuint32_t
	Fbuf  [64]Tuint8_t
}

func _rol(tls *TLS, n Tuint32_t, k int32) (r Tuint32_t) {
	return n<<k | n>>(Int32FromInt32(32)-k)
}

var _tab = [64]Tuint32_t{
	0:  uint32(0xd76aa478),
	1:  uint32(0xe8c7b756),
	2:  uint32(0x242070db),
	3:  uint32(0xc1bdceee),
	4:  uint32(0xf57c0faf),
	5:  uint32(0x4787c62a),
	6:  uint32(0xa8304613),
	7:  uint32(0xfd469501),
	8:  uint32(0x698098d8),
	9:  uint32(0x8b44f7af),
	10: uint32(0xffff5bb1),
	11: uint32(0x895cd7be),
	12: uint32(0x6b901122),
	13: uint32(0xfd987193),
	14: uint32(0xa679438e),
	15: uint32(0x49b40821),
	16: uint32(0xf61e2562),
	17: uint32(0xc040b340),
	18: uint32(0x265e5a51),
	19: uint32(0xe9b6c7aa),
	20: uint32(0xd62f105d),
	21: uint32(0x02441453),
	22: uint32(0xd8a1e681),
	23: uint32(0xe7d3fbc8),
	24: uint32(0x21e1cde6),
	25: uint32(0xc33707d6),
	26: uint32(0xf4d50d87),
	27: uint32(0x455a14ed),
	28: uint32(0xa9e3e905),
	29: uint32(0xfcefa3f8),
	30: uint32(0x676f02d9),
	31: uint32(0x8d2a4c8a),
	32: uint32(0xfffa3942),
	33: uint32(0x8771f681),
	34: uint32(0x6d9d6122),
	35: uint32(0xfde5380c),
	36: uint32(0xa4beea44),
	37: uint32(0x4bdecfa9),
	38: uint32(0xf6bb4b60),
	39: uint32(0xbebfbc70),
	40: uint32(0x289b7ec6),
	41: uint32(0xeaa127fa),
	42: uint32(0xd4ef3085),
	43: uint32(0x04881d05),
	44: uint32(0xd9d4d039),
	45: uint32(0xe6db99e5),
	46: uint32(0x1fa27cf8),
	47: uint32(0xc4ac5665),
	48: uint32(0xf4292244),
	49: uint32(0x432aff97),
	50: uint32(0xab9423a7),
	51: uint32(0xfc93a039),
	52: uint32(0x655b59c3),
	53: uint32(0x8f0ccc92),
	54: uint32(0xffeff47d),
	55: uint32(0x85845dd1),
	56: uint32(0x6fa87e4f),
	57: uint32(0xfe2ce6e0),
	58: uint32(0xa3014314),
	59: uint32(0x4e0811a1),
	60: uint32(0xf7537e82),
	61: uint32(0xbd3af235),
	62: uint32(0x2ad7d2bb),
	63: uint32(0xeb86d391)}

func _processblock(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxValist 0 */
	defer tls.Free(64)
	var a Tuint32_t
	var b Tuint32_t
	var c Tuint32_t
	var d Tuint32_t
	var i Tuint32_t
	var _ /* W at bp+0 */ [16]Tuint32_t
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	for i = uint32(0); i < uint32(16); i++ {
		(*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] = uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Uint32FromInt32(4)*i))))
		p1 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Uint32FromInt32(4)*i+Uint32FromInt32(1)))))<<Int32FromInt32(8)
		p2 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Uint32FromInt32(4)*i+Uint32FromInt32(2)))))<<Int32FromInt32(16)
		p3 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p3)) = *(*Tuint32_t)(unsafe.Pointer(p3)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Uint32FromInt32(4)*i+Uint32FromInt32(3)))))<<Int32FromInt32(24)
	}
	a = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*4))
	b = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*4))
	c = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*4))
	d = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*4))
	i = uint32(0)
	for i < uint32(16) {
		a = a + (d ^ b&(c^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i])
		a = _rol(tls, a, int32(7)) + b
		i++
		d = d + (c ^ a&(b^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i])
		d = _rol(tls, d, int32(12)) + a
		i++
		c = c + (b ^ d&(a^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i])
		c = _rol(tls, c, int32(17)) + d
		i++
		b = b + (a ^ c&(d^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i])
		b = _rol(tls, b, int32(22)) + c
		i++
	}
	for i < uint32(32) {
		a = a + (c ^ d&(c^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i])
		a = _rol(tls, a, int32(5)) + b
		i++
		d = d + (b ^ c&(b^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i])
		d = _rol(tls, d, int32(9)) + a
		i++
		c = c + (a ^ b&(a^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i])
		c = _rol(tls, c, int32(14)) + d
		i++
		b = b + (d ^ a&(d^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i])
		b = _rol(tls, b, int32(20)) + c
		i++
	}
	for i < uint32(48) {
		a = a + (b ^ c ^ d + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i])
		a = _rol(tls, a, int32(4)) + b
		i++
		d = d + (a ^ b ^ c + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i])
		d = _rol(tls, d, int32(11)) + a
		i++
		c = c + (d ^ a ^ b + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i])
		c = _rol(tls, c, int32(16)) + d
		i++
		b = b + (c ^ d ^ a + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i])
		b = _rol(tls, b, int32(23)) + c
		i++
	}
	for i < uint32(64) {
		a = a + (c ^ (b | ^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i])
		a = _rol(tls, a, int32(6)) + b
		i++
		d = d + (b ^ (a | ^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i])
		d = _rol(tls, d, int32(10)) + a
		i++
		c = c + (a ^ (d | ^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i])
		c = _rol(tls, c, int32(15)) + d
		i++
		b = b + (d ^ (c | ^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i])
		b = _rol(tls, b, int32(21)) + c
		i++
	}
	p4 = s + 8 + UintptrFromInt32(0)*4
	*(*Tuint32_t)(unsafe.Pointer(p4)) = *(*Tuint32_t)(unsafe.Pointer(p4)) + a
	p5 = s + 8 + UintptrFromInt32(1)*4
	*(*Tuint32_t)(unsafe.Pointer(p5)) = *(*Tuint32_t)(unsafe.Pointer(p5)) + b
	p6 = s + 8 + UintptrFromInt32(2)*4
	*(*Tuint32_t)(unsafe.Pointer(p6)) = *(*Tuint32_t)(unsafe.Pointer(p6)) + c
	p7 = s + 8 + UintptrFromInt32(3)*4
	*(*Tuint32_t)(unsafe.Pointer(p7)) = *(*Tuint32_t)(unsafe.Pointer(p7)) + d
}

func _pad(tls *TLS, s uintptr) {
	var r uint32
	var v1 uint32
	var p2 uintptr
	r = uint32((*Tmd5)(unsafe.Pointer(s)).Flen1 % uint64(64))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + uintptr(v1))) = uint8(0x80)
	if r > uint32(56) {
		x_memset(tls, s+24+uintptr(r), int32(0), uint64(uint32(64)-r))
		r = uint32(0)
		_processblock(tls, s, s+24)
	}
	x_memset(tls, s+24+uintptr(r), int32(0), uint64(uint32(56)-r))
	p2 = s
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) * Uint64FromInt32(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(56))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1)
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(57))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(58))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(59))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(60))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(61))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(62))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + UintptrFromInt32(63))) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(56))
	_processblock(tls, s, s+24)
}

func _md5_init(tls *TLS, s uintptr) {
	(*Tmd5)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*4)) = uint32(0x67452301)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*4)) = uint32(0xefcdab89)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*4)) = uint32(0x98badcfe)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*4)) = uint32(0x10325476)
}

func _md5_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_pad(tls, s)
	for i = int32(0); i < int32(4); i++ {
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(1)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(2)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(3)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(24))
	}
}

func _md5_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	var p1 uintptr
	p = m
	r = uint32((*Tmd5)(unsafe.Pointer(s)).Flen1 % uint64(64))
	p1 = s
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) + len1
	if r != 0 {
		if len1 < uint64(uint32(64)-r) {
			x_memcpy(tls, s+24+uintptr(r), p, len1)
			return
		}
		x_memcpy(tls, s+24+uintptr(r), p, uint64(uint32(64)-r))
		len1 = len1 - uint64(Uint32FromInt32(64)-r)
		p = p + uintptr(Uint32FromInt32(64)-r)
		_processblock(tls, s, s+24)
	}
	for len1 >= uint64(64) {
		_processblock(tls, s, p)
		goto _2
	_2:
		len1 = len1 - Uint64FromInt32(64)
		p = p + UintptrFromInt32(64)
	}
	x_memcpy(tls, s+24, p, len1)
}

/*-
 * Copyright (c) 2003 Poul-Henning Kamp
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* key limit is not part of the original design, added for DoS protection */

var _b64 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to64(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	for {
		n--
		v1 = n
		if !(v1 >= int32(0)) {
			break
		}
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v2)) = int8(_b64[u%uint32(64)])
		u = u / Uint32FromInt32(64)
	}
	return s
}

func _md5crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(104) /* tlsAllocs 104 maxValist 0 */
	defer tls.Free(104)
	var i uint32
	var klen uint32
	var p uintptr
	var salt uintptr
	var slen uint32
	var _ /* ctx at bp+0 */ Tmd5
	var _ /* md at bp+88 */ [16]uint8
	var v3 uintptr
	/* reject large keys */
	klen = uint32(x_strnlen(tls, key, uint64(Int32FromInt32(m_KEY_MAX)+Int32FromInt32(1))))
	if klen > uint32(m_KEY_MAX) {
		return uintptr(0)
	}
	/* setting: $1$salt$ (closing $ is optional) */
	if x_strncmp(tls, setting, ts+138, uint64(3)) != int32(0) {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	for i = uint32(0); i < uint32(m_SALT_MAX) && *(*int8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$'); i++ {
	}
	slen = i
	/* md5(key salt key) */
	_md5_init(tls, bp)
	_md5_update(tls, bp, key, uint64(klen))
	_md5_update(tls, bp, salt, uint64(slen))
	_md5_update(tls, bp, key, uint64(klen))
	_md5_sum(tls, bp, bp+88)
	/* md5(key $1$ salt repeated-md weird-key[0]-0) */
	_md5_init(tls, bp)
	_md5_update(tls, bp, key, uint64(klen))
	_md5_update(tls, bp, setting, uint64(uint32(3)+slen))
	for i = klen; uint64(i) > uint64(16); {
		_md5_update(tls, bp, bp+88, uint64(16))
		goto _1
	_1:
		i = uint32(uint64(i) - Uint64FromInt64(16))
	}
	_md5_update(tls, bp, bp+88, uint64(i))
	(*(*[16]uint8)(unsafe.Pointer(bp + 88)))[int32(0)] = uint8(0)
	for i = klen; i != 0; {
		if i&uint32(1) != 0 {
			_md5_update(tls, bp, bp+88, uint64(1))
		} else {
			_md5_update(tls, bp, key, uint64(1))
		}
		goto _2
	_2:
		i = i >> Uint32FromInt32(1)
	}
	_md5_sum(tls, bp, bp+88)
	/* md = f(md, key, salt) iteration */
	for i = uint32(0); i < uint32(1000); i++ {
		_md5_init(tls, bp)
		if i%uint32(2) != 0 {
			_md5_update(tls, bp, key, uint64(klen))
		} else {
			_md5_update(tls, bp, bp+88, uint64(16))
		}
		if i%uint32(3) != 0 {
			_md5_update(tls, bp, salt, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_md5_update(tls, bp, key, uint64(klen))
		}
		if i%uint32(2) != 0 {
			_md5_update(tls, bp, bp+88, uint64(16))
		} else {
			_md5_update(tls, bp, key, uint64(klen))
		}
		_md5_sum(tls, bp, bp+88)
	}
	/* output is $1$salt$hash */
	x_memcpy(tls, output, setting, uint64(uint32(3)+slen))
	p = output + uintptr(3) + uintptr(slen)
	v3 = p
	p++
	*(*int8)(unsafe.Pointer(v3)) = int8('$')
	for i = uint32(0); i < uint32(5); i++ {
		p = _to64(tls, p, uint32(int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3 + UintptrFromInt32(0)))])<<int32(16)|int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3 + UintptrFromInt32(1)))])<<int32(8)|int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3 + UintptrFromInt32(2)))])), int32(4))
	}
	p = _to64(tls, p, uint32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[int32(11)]), int32(2))
	*(*int8)(unsafe.Pointer(p)) = int8(0)
	return output
}

var _perm = [5][3]uint8{
	0: {
		0: uint8(0),
		1: uint8(6),
		2: uint8(12)},
	1: {
		0: uint8(1),
		1: uint8(7),
		2: uint8(13)},
	2: {
		0: uint8(2),
		1: uint8(8),
		2: uint8(14)},
	3: {
		0: uint8(3),
		1: uint8(9),
		2: uint8(15)},
	4: {
		0: uint8(4),
		1: uint8(10),
		2: uint8(5)}}

func x___crypt_md5(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxValist 0 */
	defer tls.Free(64)
	var p uintptr
	var q uintptr
	var _ /* testbuf at bp+0 */ [64]int8
	p = _md5crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _md5crypt(tls, uintptr(unsafe.Pointer(&_testkey)), uintptr(unsafe.Pointer(&_testsetting)), bp)
	if !(p != 0) || q != bp || x_memcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash)), uint64(35)) != 0 {
		return ts + 65
	}
	return p
}

var _testkey = [18]int8{'X', 'y', '0', '1', '@', '#', 1, 2, -128, 127, -1, 13, 10, -127, 9, ' ', '!'}

var _testsetting = [13]int8{'$', '1', '$', 'a', 'b', 'c', 'd', '0', '1', '2', '3', '$'}

var _testhash = [35]int8{'$', '1', '$', 'a', 'b', 'c', 'd', '0', '1', '2', '3', '$', '9', 'Q', 'c', 'g', '8', 'D', 'y', 'v', 'i', 'e', 'k', 'V', '3', 't', 'D', 'G', 'M', 'Z', 'y', 'n', 'J', '1'}

func x___crypt_r(tls *TLS, key uintptr, salt uintptr, data uintptr) (r uintptr) {
	var output uintptr
	/* Per the crypt_r API, the caller has provided a pointer to
	 * struct crypt_data; however, this implementation does not
	 * use the structure to store any internal state, and treats
	 * it purely as a char buffer for storing the result. */
	output = data
	if int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(0)))) == int32('$') && *(*int8)(unsafe.Pointer(salt + UintptrFromInt32(1))) != 0 && *(*int8)(unsafe.Pointer(salt + UintptrFromInt32(2))) != 0 {
		if int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(1)))) == int32('1') && int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(2)))) == int32('$') {
			return x___crypt_md5(tls, key, salt, output)
		}
		if int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(1)))) == int32('2') && int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(3)))) == int32('$') {
			return x___crypt_blowfish(tls, key, salt, output)
		}
		if int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(1)))) == int32('5') && int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(2)))) == int32('$') {
			return x___crypt_sha256(tls, key, salt, output)
		}
		if int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(1)))) == int32('6') && int32(*(*int8)(unsafe.Pointer(salt + UintptrFromInt32(2)))) == int32('$') {
			return x___crypt_sha512(tls, key, salt, output)
		}
	}
	return x___crypt_des(tls, key, salt, output)
}

const m_KEY_MAX1 = 256
const m_ROUNDS_DEFAULT = 5000
const m_ROUNDS_MAX = 9999999
const m_ROUNDS_MIN = 1000
const m_SALT_MAX1 = 16

/* public domain sha256 implementation based on fips180-3 */

type Tsha256 = struct {
	Flen1 Tuint64_t
	Fh    [8]Tuint32_t
	Fbuf  [64]Tuint8_t
}

func _ror(tls *TLS, n Tuint32_t, k int32) (r Tuint32_t) {
	return n>>k | n<<(Int32FromInt32(32)-k)
}

var _K = [64]Tuint32_t{
	0:  uint32(0x428a2f98),
	1:  uint32(0x71374491),
	2:  uint32(0xb5c0fbcf),
	3:  uint32(0xe9b5dba5),
	4:  uint32(0x3956c25b),
	5:  uint32(0x59f111f1),
	6:  uint32(0x923f82a4),
	7:  uint32(0xab1c5ed5),
	8:  uint32(0xd807aa98),
	9:  uint32(0x12835b01),
	10: uint32(0x243185be),
	11: uint32(0x550c7dc3),
	12: uint32(0x72be5d74),
	13: uint32(0x80deb1fe),
	14: uint32(0x9bdc06a7),
	15: uint32(0xc19bf174),
	16: uint32(0xe49b69c1),
	17: uint32(0xefbe4786),
	18: uint32(0x0fc19dc6),
	19: uint32(0x240ca1cc),
	20: uint32(0x2de92c6f),
	21: uint32(0x4a7484aa),
	22: uint32(0x5cb0a9dc),
	23: uint32(0x76f988da),
	24: uint32(0x983e5152),
	25: uint32(0xa831c66d),
	26: uint32(0xb00327c8),
	27: uint32(0xbf597fc7),
	28: uint32(0xc6e00bf3),
	29: uint32(0xd5a79147),
	30: uint32(0x06ca6351),
	31: uint32(0x14292967),
	32: uint32(0x27b70a85),
	33: uint32(0x2e1b2138),
	34: uint32(0x4d2c6dfc),
	35: uint32(0x53380d13),
	36: uint32(0x650a7354),
	37: uint32(0x766a0abb),
	38: uint32(0x81c2c92e),
	39: uint32(0x92722c85),
	40: uint32(0xa2bfe8a1),
	41: uint32(0xa81a664b),
	42: uint32(0xc24b8b70),
	43: uint32(0xc76c51a3),
	44: uint32(0xd192e819),
	45: uint32(0xd6990624),
	46: uint32(0xf40e3585),
	47: uint32(0x106aa070),
	48: uint32(0x19a4c116),
	49: uint32(0x1e376c08),
	50: uint32(0x2748774c),
	51: uint32(0x34b0bcb5),
	52: uint32(0x391c0cb3),
	53: uint32(0x4ed8aa4a),
	54: uint32(0x5b9cca4f),
	55: uint32(0x682e6ff3),
	56: uint32(0x748f82ee),
	57: uint32(0x78a5636f),
	58: uint32(0x84c87814),
	59: uint32(0x8cc70208),
	60: uint32(0x90befffa),
	61: uint32(0xa4506ceb),
	62: uint32(0xbef9a3f7),
	63: uint32(0xc67178f2)}

func _processblock1(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var a Tuint32_t
	var b Tuint32_t
	var c Tuint32_t
	var d Tuint32_t
	var e Tuint32_t
	var f Tuint32_t
	var g Tuint32_t
	var h Tuint32_t
	var i int32
	var t1 Tuint32_t
	var t2 Tuint32_t
	var _ /* W at bp+0 */ [64]Tuint32_t
	var p1 uintptr
	var p10 uintptr
	var p11 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	var p8 uintptr
	var p9 uintptr
	for i = int32(0); i < int32(16); i++ {
		(*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i] = uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(4)*i)))) << int32(24)
		p1 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(4)*i+Int32FromInt32(1)))))<<Int32FromInt32(16)
		p2 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(4)*i+Int32FromInt32(2)))))<<Int32FromInt32(8)
		p3 = bp + uintptr(i)*4
		*(*Tuint32_t)(unsafe.Pointer(p3)) = *(*Tuint32_t)(unsafe.Pointer(p3)) | uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(4)*i+Int32FromInt32(3)))))
	}
	for ; i < int32(64); i++ {
		(*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i] = _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(17)) ^ _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(19)) ^ (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)]>>Int32FromInt32(10) + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(7)] + (_ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(7)) ^ _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(18)) ^ (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)]>>Int32FromInt32(3)) + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(16)]
	}
	a = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*4))
	b = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*4))
	c = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*4))
	d = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*4))
	e = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(4)*4))
	f = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(5)*4))
	g = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(6)*4))
	h = *(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(7)*4))
	for i = int32(0); i < int32(64); i++ {
		t1 = h + (_ror(tls, e, int32(6)) ^ _ror(tls, e, int32(11)) ^ _ror(tls, e, int32(25))) + (g ^ e&(f^g)) + _K[i] + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i]
		t2 = _ror(tls, a, int32(2)) ^ _ror(tls, a, int32(13)) ^ _ror(tls, a, int32(22)) + (a&b | c&(a|b))
		h = g
		g = f
		f = e
		e = d + t1
		d = c
		c = b
		b = a
		a = t1 + t2
	}
	p4 = s + 8 + UintptrFromInt32(0)*4
	*(*Tuint32_t)(unsafe.Pointer(p4)) = *(*Tuint32_t)(unsafe.Pointer(p4)) + a
	p5 = s + 8 + UintptrFromInt32(1)*4
	*(*Tuint32_t)(unsafe.Pointer(p5)) = *(*Tuint32_t)(unsafe.Pointer(p5)) + b
	p6 = s + 8 + UintptrFromInt32(2)*4
	*(*Tuint32_t)(unsafe.Pointer(p6)) = *(*Tuint32_t)(unsafe.Pointer(p6)) + c
	p7 = s + 8 + UintptrFromInt32(3)*4
	*(*Tuint32_t)(unsafe.Pointer(p7)) = *(*Tuint32_t)(unsafe.Pointer(p7)) + d
	p8 = s + 8 + UintptrFromInt32(4)*4
	*(*Tuint32_t)(unsafe.Pointer(p8)) = *(*Tuint32_t)(unsafe.Pointer(p8)) + e
	p9 = s + 8 + UintptrFromInt32(5)*4
	*(*Tuint32_t)(unsafe.Pointer(p9)) = *(*Tuint32_t)(unsafe.Pointer(p9)) + f
	p10 = s + 8 + UintptrFromInt32(6)*4
	*(*Tuint32_t)(unsafe.Pointer(p10)) = *(*Tuint32_t)(unsafe.Pointer(p10)) + g
	p11 = s + 8 + UintptrFromInt32(7)*4
	*(*Tuint32_t)(unsafe.Pointer(p11)) = *(*Tuint32_t)(unsafe.Pointer(p11)) + h
}

func _pad1(tls *TLS, s uintptr) {
	var r uint32
	var v1 uint32
	var p2 uintptr
	r = uint32((*Tsha256)(unsafe.Pointer(s)).Flen1 % uint64(64))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + uintptr(v1))) = uint8(0x80)
	if r > uint32(56) {
		x_memset(tls, s+40+uintptr(r), int32(0), uint64(uint32(64)-r))
		r = uint32(0)
		_processblock1(tls, s, s+40)
	}
	x_memset(tls, s+40+uintptr(r), int32(0), uint64(uint32(56)-r))
	p2 = s
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) * Uint64FromInt32(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(56))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(56))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(57))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(58))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(59))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(60))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(61))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(62))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + UintptrFromInt32(63))) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1)
	_processblock1(tls, s, s+40)
}

func _sha256_init(tls *TLS, s uintptr) {
	(*Tsha256)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*4)) = uint32(0x6a09e667)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*4)) = uint32(0xbb67ae85)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*4)) = uint32(0x3c6ef372)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*4)) = uint32(0xa54ff53a)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(4)*4)) = uint32(0x510e527f)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(5)*4)) = uint32(0x9b05688c)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(6)*4)) = uint32(0x1f83d9ab)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(7)*4)) = uint32(0x5be0cd19)
}

func _sha256_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_pad1(tls, s)
	for i = int32(0); i < int32(8); i++ {
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(24))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(1)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(2)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(4)*i+Int32FromInt32(3)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)))
	}
}

func _sha256_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	var p1 uintptr
	p = m
	r = uint32((*Tsha256)(unsafe.Pointer(s)).Flen1 % uint64(64))
	p1 = s
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) + len1
	if r != 0 {
		if len1 < uint64(uint32(64)-r) {
			x_memcpy(tls, s+40+uintptr(r), p, len1)
			return
		}
		x_memcpy(tls, s+40+uintptr(r), p, uint64(uint32(64)-r))
		len1 = len1 - uint64(Uint32FromInt32(64)-r)
		p = p + uintptr(Uint32FromInt32(64)-r)
		_processblock1(tls, s, s+40)
	}
	for len1 >= uint64(64) {
		_processblock1(tls, s, p)
		goto _2
	_2:
		len1 = len1 - Uint64FromInt32(64)
		p = p + UintptrFromInt32(64)
	}
	x_memcpy(tls, s+40, p, len1)
}

var _b641 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to641(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	for {
		n--
		v1 = n
		if !(v1 >= int32(0)) {
			break
		}
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v2)) = int8(_b641[u%uint32(64)])
		u = u / Uint32FromInt32(64)
	}
	return s
}

/* key limit is not part of the original design, added for DoS protection.
 * rounds limit has been lowered (versus the reference/spec), also for DoS
 * protection. runtime is O(klen^2 + klen*rounds) */

// C documentation
//
//	/* hash n bytes of the repeated md message digest */
func _hashmd(tls *TLS, s uintptr, n uint32, md uintptr) {
	var i uint32
	for i = n; i > uint32(32); {
		_sha256_update(tls, s, md, uint64(32))
		goto _1
	_1:
		i = i - Uint32FromInt32(32)
	}
	_sha256_update(tls, s, md, uint64(i))
}

func _sha256crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r1 uintptr) {
	bp := tls.Alloc(264) /* tlsAllocs 232 maxValist 3 */
	defer tls.Free(264)
	var i uint32
	var klen uint32
	var p uintptr
	var r uint32
	var salt uintptr
	var slen uint32
	var u uint64
	var _ /* ctx at bp+0 */ Tsha256
	var _ /* end at bp+224 */ uintptr
	var _ /* kmd at bp+136 */ [32]uint8
	var _ /* md at bp+104 */ [32]uint8
	var _ /* rounds at bp+200 */ [20]int8
	var _ /* smd at bp+168 */ [32]uint8
	*(*[20]int8)(unsafe.Pointer(bp + 200)) = [20]int8{}
	/* reject large keys */
	klen = uint32(x_strnlen(tls, key, uint64(Int32FromInt32(m_KEY_MAX1)+Int32FromInt32(1))))
	if klen > uint32(m_KEY_MAX1) {
		return uintptr(0)
	}
	/* setting: $5$rounds=n$salt$ (rounds=n$ and closing $ are optional) */
	if x_strncmp(tls, setting, ts+142, uint64(3)) != int32(0) {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	r = uint32(m_ROUNDS_DEFAULT)
	if x_strncmp(tls, salt, ts+146, Uint64FromInt64(8)-Uint64FromInt32(1)) == int32(0) {
		/*
		 * this is a deviation from the reference:
		 * bad rounds setting is rejected if it is
		 * - empty
		 * - unterminated (missing '$')
		 * - begins with anything but a decimal digit
		 * the reference implementation treats these bad
		 * rounds as part of the salt or parse them with
		 * strtoul semantics which may cause problems
		 * including non-portable hashes that depend on
		 * the host's value of ULONG_MAX.
		 */
		salt = salt + uintptr(Uint64FromInt64(8)-Uint64FromInt32(1))
		if !(BoolInt32(uint32(*(*int8)(unsafe.Pointer(salt)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		u = x_strtoul(tls, salt, bp+224, int32(10))
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 224))))) != int32('$') {
			return uintptr(0)
		}
		salt = *(*uintptr)(unsafe.Pointer(bp + 224)) + uintptr(1)
		if u < uint64(m_ROUNDS_MIN) {
			r = uint32(m_ROUNDS_MIN)
		} else {
			if u > uint64(m_ROUNDS_MAX) {
				return uintptr(0)
			} else {
				r = uint32(u)
			}
		}
		/* needed when rounds is zero prefixed or out of bounds */
		x_sprintf(tls, bp+200, ts+154, VaList(bp+240, r))
	}
	for i = uint32(0); i < uint32(m_SALT_MAX1) && *(*int8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$'); i++ {
		/* reject characters that interfere with /etc/shadow parsing */
		if int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) == int32('\n') || int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) == int32(':') {
			return uintptr(0)
		}
	}
	slen = i
	/* B = sha(key salt key) */
	_sha256_init(tls, bp)
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_update(tls, bp, salt, uint64(slen))
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_sum(tls, bp, bp+104)
	/* A = sha(key salt repeat-B alternate-B-key) */
	_sha256_init(tls, bp)
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_update(tls, bp, salt, uint64(slen))
	_hashmd(tls, bp, klen, bp+104)
	for i = klen; i > uint32(0); {
		if i&uint32(1) != 0 {
			_sha256_update(tls, bp, bp+104, uint64(32))
		} else {
			_sha256_update(tls, bp, key, uint64(klen))
		}
		goto _1
	_1:
		i = i >> Uint32FromInt32(1)
	}
	_sha256_sum(tls, bp, bp+104)
	/* DP = sha(repeat-key), this step takes O(klen^2) time */
	_sha256_init(tls, bp)
	for i = uint32(0); i < klen; i++ {
		_sha256_update(tls, bp, key, uint64(klen))
	}
	_sha256_sum(tls, bp, bp+136)
	/* DS = sha(repeat-salt) */
	_sha256_init(tls, bp)
	for i = uint32(0); i < uint32(int32(16)+int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[int32(0)])); i++ {
		_sha256_update(tls, bp, salt, uint64(slen))
	}
	_sha256_sum(tls, bp, bp+168)
	/* iterate A = f(A,DP,DS), this step takes O(rounds*klen) time */
	for i = uint32(0); i < r; i++ {
		_sha256_init(tls, bp)
		if i%uint32(2) != 0 {
			_hashmd(tls, bp, klen, bp+136)
		} else {
			_sha256_update(tls, bp, bp+104, uint64(32))
		}
		if i%uint32(3) != 0 {
			_sha256_update(tls, bp, bp+168, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_hashmd(tls, bp, klen, bp+136)
		}
		if i%uint32(2) != 0 {
			_sha256_update(tls, bp, bp+104, uint64(32))
		} else {
			_hashmd(tls, bp, klen, bp+136)
		}
		_sha256_sum(tls, bp, bp+104)
	}
	/* output is $5$rounds=n$salt$hash */
	p = output
	p = p + uintptr(x_sprintf(tls, p, ts+165, VaList(bp+240, bp+200, slen, salt)))
	for i = uint32(0); i < uint32(10); i++ {
		p = _to641(tls, p, uint32(int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3 + UintptrFromInt32(0)))])<<int32(16)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3 + UintptrFromInt32(1)))])<<int32(8)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3 + UintptrFromInt32(2)))])), int32(4))
	}
	p = _to641(tls, p, uint32(int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[int32(31)])<<int32(8)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[int32(30)])), int32(3))
	*(*int8)(unsafe.Pointer(p)) = int8(0)
	return output
}

var _perm1 = [10][3]uint8{
	0: {
		0: uint8(0),
		1: uint8(10),
		2: uint8(20)},
	1: {
		0: uint8(21),
		1: uint8(1),
		2: uint8(11)},
	2: {
		0: uint8(12),
		1: uint8(22),
		2: uint8(2)},
	3: {
		0: uint8(3),
		1: uint8(13),
		2: uint8(23)},
	4: {
		0: uint8(24),
		1: uint8(4),
		2: uint8(14)},
	5: {
		0: uint8(15),
		1: uint8(25),
		2: uint8(5)},
	6: {
		0: uint8(6),
		1: uint8(16),
		2: uint8(26)},
	7: {
		0: uint8(27),
		1: uint8(7),
		2: uint8(17)},
	8: {
		0: uint8(18),
		1: uint8(28),
		2: uint8(8)},
	9: {
		0: uint8(9),
		1: uint8(19),
		2: uint8(29)}}

func x___crypt_sha256(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var p uintptr
	var q uintptr
	var _ /* testbuf at bp+0 */ [128]int8
	p = _sha256crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _sha256crypt(tls, uintptr(unsafe.Pointer(&_testkey1)), uintptr(unsafe.Pointer(&_testsetting1)), bp)
	if !(p != 0) || q != bp || x_memcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash1)), uint64(73)) != 0 {
		return ts + 65
	}
	return p
}

var _testkey1 = [18]int8{'X', 'y', '0', '1', '@', '#', 1, 2, -128, 127, -1, 13, 10, -127, 9, ' ', '!'}

var _testsetting1 = [30]int8{'$', '5', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$'}

var _testhash1 = [73]int8{'$', '5', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$', '3', 'V', 'f', 'D', 'j', 'P', 't', '0', '5', 'V', 'H', 'F', 'n', '4', '7', 'C', '/', 'o', 'j', 'F', 'Z', '6', 'K', 'R', 'P', 'Y', 'r', 'O', 'j', 'j', '1', 'l', 'L', 'b', 'H', '.', 'd', 'k', 'F', '3', 'b', 'Z', '6'}

/* public domain sha512 implementation based on fips180-3 */
/* >=2^64 bits messages are not supported (about 2000 peta bytes) */

type Tsha512 = struct {
	Flen1 Tuint64_t
	Fh    [8]Tuint64_t
	Fbuf  [128]Tuint8_t
}

func _ror1(tls *TLS, n Tuint64_t, k int32) (r Tuint64_t) {
	return n>>k | n<<(Int32FromInt32(64)-k)
}

var _K1 = [80]Tuint64_t{
	0:  uint64(0x428a2f98d728ae22),
	1:  uint64(0x7137449123ef65cd),
	2:  uint64(0xb5c0fbcfec4d3b2f),
	3:  uint64(0xe9b5dba58189dbbc),
	4:  uint64(0x3956c25bf348b538),
	5:  uint64(0x59f111f1b605d019),
	6:  uint64(0x923f82a4af194f9b),
	7:  uint64(0xab1c5ed5da6d8118),
	8:  uint64(0xd807aa98a3030242),
	9:  uint64(0x12835b0145706fbe),
	10: uint64(0x243185be4ee4b28c),
	11: uint64(0x550c7dc3d5ffb4e2),
	12: uint64(0x72be5d74f27b896f),
	13: uint64(0x80deb1fe3b1696b1),
	14: uint64(0x9bdc06a725c71235),
	15: uint64(0xc19bf174cf692694),
	16: uint64(0xe49b69c19ef14ad2),
	17: uint64(0xefbe4786384f25e3),
	18: uint64(0x0fc19dc68b8cd5b5),
	19: uint64(0x240ca1cc77ac9c65),
	20: uint64(0x2de92c6f592b0275),
	21: uint64(0x4a7484aa6ea6e483),
	22: uint64(0x5cb0a9dcbd41fbd4),
	23: uint64(0x76f988da831153b5),
	24: uint64(0x983e5152ee66dfab),
	25: uint64(0xa831c66d2db43210),
	26: uint64(0xb00327c898fb213f),
	27: uint64(0xbf597fc7beef0ee4),
	28: uint64(0xc6e00bf33da88fc2),
	29: uint64(0xd5a79147930aa725),
	30: uint64(0x06ca6351e003826f),
	31: uint64(0x142929670a0e6e70),
	32: uint64(0x27b70a8546d22ffc),
	33: uint64(0x2e1b21385c26c926),
	34: uint64(0x4d2c6dfc5ac42aed),
	35: uint64(0x53380d139d95b3df),
	36: uint64(0x650a73548baf63de),
	37: uint64(0x766a0abb3c77b2a8),
	38: uint64(0x81c2c92e47edaee6),
	39: uint64(0x92722c851482353b),
	40: uint64(0xa2bfe8a14cf10364),
	41: uint64(0xa81a664bbc423001),
	42: uint64(0xc24b8b70d0f89791),
	43: uint64(0xc76c51a30654be30),
	44: uint64(0xd192e819d6ef5218),
	45: uint64(0xd69906245565a910),
	46: uint64(0xf40e35855771202a),
	47: uint64(0x106aa07032bbd1b8),
	48: uint64(0x19a4c116b8d2d0c8),
	49: uint64(0x1e376c085141ab53),
	50: uint64(0x2748774cdf8eeb99),
	51: uint64(0x34b0bcb5e19b48a8),
	52: uint64(0x391c0cb3c5c95a63),
	53: uint64(0x4ed8aa4ae3418acb),
	54: uint64(0x5b9cca4f7763e373),
	55: uint64(0x682e6ff3d6b2b8a3),
	56: uint64(0x748f82ee5defb2fc),
	57: uint64(0x78a5636f43172f60),
	58: uint64(0x84c87814a1f0ab72),
	59: uint64(0x8cc702081a6439ec),
	60: uint64(0x90befffa23631e28),
	61: uint64(0xa4506cebde82bde9),
	62: uint64(0xbef9a3f7b2c67915),
	63: uint64(0xc67178f2e372532b),
	64: uint64(0xca273eceea26619c),
	65: uint64(0xd186b8c721c0c207),
	66: uint64(0xeada7dd6cde0eb1e),
	67: uint64(0xf57d4f7fee6ed178),
	68: uint64(0x06f067aa72176fba),
	69: uint64(0x0a637dc5a2c898a6),
	70: uint64(0x113f9804bef90dae),
	71: uint64(0x1b710b35131c471b),
	72: uint64(0x28db77f523047d84),
	73: uint64(0x32caab7b40c72493),
	74: uint64(0x3c9ebe0a15c9bebc),
	75: uint64(0x431d67c49c100d4c),
	76: uint64(0x4cc5d4becb3e42b6),
	77: uint64(0x597f299cfc657e2a),
	78: uint64(0x5fcb6fab3ad6faec),
	79: uint64(0x6c44198c4a475817)}

func _processblock2(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(640) /* tlsAllocs 640 maxValist 0 */
	defer tls.Free(640)
	var a Tuint64_t
	var b Tuint64_t
	var c Tuint64_t
	var d Tuint64_t
	var e Tuint64_t
	var f Tuint64_t
	var g Tuint64_t
	var h Tuint64_t
	var i int32
	var t1 Tuint64_t
	var t2 Tuint64_t
	var _ /* W at bp+0 */ [80]Tuint64_t
	var p1 uintptr
	var p10 uintptr
	var p11 uintptr
	var p12 uintptr
	var p13 uintptr
	var p14 uintptr
	var p15 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	var p8 uintptr
	var p9 uintptr
	for i = int32(0); i < int32(16); i++ {
		(*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i] = uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i)))) << int32(56)
		p1 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(1)))))<<Int32FromInt32(48)
		p2 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(2)))))<<Int32FromInt32(40)
		p3 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(3)))))<<Int32FromInt32(32)
		p4 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p4)) = *(*Tuint64_t)(unsafe.Pointer(p4)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(4)))))<<Int32FromInt32(24)
		p5 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p5)) = *(*Tuint64_t)(unsafe.Pointer(p5)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(5)))))<<Int32FromInt32(16)
		p6 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p6)) = *(*Tuint64_t)(unsafe.Pointer(p6)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(6)))))<<Int32FromInt32(8)
		p7 = bp + uintptr(i)*8
		*(*Tuint64_t)(unsafe.Pointer(p7)) = *(*Tuint64_t)(unsafe.Pointer(p7)) | uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(Int32FromInt32(8)*i+Int32FromInt32(7)))))
	}
	for ; i < int32(80); i++ {
		(*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i] = _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(19)) ^ _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(61)) ^ (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)]>>Int32FromInt32(6) + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(7)] + (_ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(1)) ^ _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(8)) ^ (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)]>>Int32FromInt32(7)) + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(16)]
	}
	a = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*8))
	b = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*8))
	c = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*8))
	d = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*8))
	e = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(4)*8))
	f = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(5)*8))
	g = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(6)*8))
	h = *(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(7)*8))
	for i = int32(0); i < int32(80); i++ {
		t1 = h + (_ror1(tls, e, int32(14)) ^ _ror1(tls, e, int32(18)) ^ _ror1(tls, e, int32(41))) + (g ^ e&(f^g)) + _K1[i] + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i]
		t2 = _ror1(tls, a, int32(28)) ^ _ror1(tls, a, int32(34)) ^ _ror1(tls, a, int32(39)) + (a&b | c&(a|b))
		h = g
		g = f
		f = e
		e = d + t1
		d = c
		c = b
		b = a
		a = t1 + t2
	}
	p8 = s + 8 + UintptrFromInt32(0)*8
	*(*Tuint64_t)(unsafe.Pointer(p8)) = *(*Tuint64_t)(unsafe.Pointer(p8)) + a
	p9 = s + 8 + UintptrFromInt32(1)*8
	*(*Tuint64_t)(unsafe.Pointer(p9)) = *(*Tuint64_t)(unsafe.Pointer(p9)) + b
	p10 = s + 8 + UintptrFromInt32(2)*8
	*(*Tuint64_t)(unsafe.Pointer(p10)) = *(*Tuint64_t)(unsafe.Pointer(p10)) + c
	p11 = s + 8 + UintptrFromInt32(3)*8
	*(*Tuint64_t)(unsafe.Pointer(p11)) = *(*Tuint64_t)(unsafe.Pointer(p11)) + d
	p12 = s + 8 + UintptrFromInt32(4)*8
	*(*Tuint64_t)(unsafe.Pointer(p12)) = *(*Tuint64_t)(unsafe.Pointer(p12)) + e
	p13 = s + 8 + UintptrFromInt32(5)*8
	*(*Tuint64_t)(unsafe.Pointer(p13)) = *(*Tuint64_t)(unsafe.Pointer(p13)) + f
	p14 = s + 8 + UintptrFromInt32(6)*8
	*(*Tuint64_t)(unsafe.Pointer(p14)) = *(*Tuint64_t)(unsafe.Pointer(p14)) + g
	p15 = s + 8 + UintptrFromInt32(7)*8
	*(*Tuint64_t)(unsafe.Pointer(p15)) = *(*Tuint64_t)(unsafe.Pointer(p15)) + h
}

func _pad2(tls *TLS, s uintptr) {
	var r uint32
	var v1 uint32
	var p2 uintptr
	r = uint32((*Tsha512)(unsafe.Pointer(s)).Flen1 % uint64(128))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + uintptr(v1))) = uint8(0x80)
	if r > uint32(112) {
		x_memset(tls, s+72+uintptr(r), int32(0), uint64(uint32(128)-r))
		r = uint32(0)
		_processblock2(tls, s, s+72)
	}
	x_memset(tls, s+72+uintptr(r), int32(0), uint64(uint32(120)-r))
	p2 = s
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) * Uint64FromInt32(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(120))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(56))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(121))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(122))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(123))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(124))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(125))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(126))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + UintptrFromInt32(127))) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1)
	_processblock2(tls, s, s+72)
}

func _sha512_init(tls *TLS, s uintptr) {
	(*Tsha512)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(0)*8)) = uint64(0x6a09e667f3bcc908)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(1)*8)) = uint64(0xbb67ae8584caa73b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(2)*8)) = uint64(0x3c6ef372fe94f82b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(3)*8)) = uint64(0xa54ff53a5f1d36f1)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(4)*8)) = uint64(0x510e527fade682d1)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(5)*8)) = uint64(0x9b05688c2b3e6c1f)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(6)*8)) = uint64(0x1f83d9abfb41bd6b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + UintptrFromInt32(7)*8)) = uint64(0x5be0cd19137e2179)
}

func _sha512_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_pad2(tls, s)
	for i = int32(0); i < int32(8); i++ {
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(56))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(1)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(48))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(2)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(40))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(3)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(32))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(4)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(24))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(5)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(6)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(Int32FromInt32(8)*i+Int32FromInt32(7)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)))
	}
}

func _sha512_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	var p1 uintptr
	p = m
	r = uint32((*Tsha512)(unsafe.Pointer(s)).Flen1 % uint64(128))
	p1 = s
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) + len1
	if r != 0 {
		if len1 < uint64(uint32(128)-r) {
			x_memcpy(tls, s+72+uintptr(r), p, len1)
			return
		}
		x_memcpy(tls, s+72+uintptr(r), p, uint64(uint32(128)-r))
		len1 = len1 - uint64(Uint32FromInt32(128)-r)
		p = p + uintptr(Uint32FromInt32(128)-r)
		_processblock2(tls, s, s+72)
	}
	for len1 >= uint64(128) {
		_processblock2(tls, s, p)
		goto _2
	_2:
		len1 = len1 - Uint64FromInt32(128)
		p = p + UintptrFromInt32(128)
	}
	x_memcpy(tls, s+72, p, len1)
}

var _b642 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to642(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	for {
		n--
		v1 = n
		if !(v1 >= int32(0)) {
			break
		}
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v2)) = int8(_b642[u%uint32(64)])
		u = u / Uint32FromInt32(64)
	}
	return s
}

/* key limit is not part of the original design, added for DoS protection.
 * rounds limit has been lowered (versus the reference/spec), also for DoS
 * protection. runtime is O(klen^2 + klen*rounds) */

// C documentation
//
//	/* hash n bytes of the repeated md message digest */
func _hashmd1(tls *TLS, s uintptr, n uint32, md uintptr) {
	var i uint32
	for i = n; i > uint32(64); {
		_sha512_update(tls, s, md, uint64(64))
		goto _1
	_1:
		i = i - Uint32FromInt32(64)
	}
	_sha512_update(tls, s, md, uint64(i))
}

func _sha512crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r1 uintptr) {
	bp := tls.Alloc(456) /* tlsAllocs 424 maxValist 3 */
	defer tls.Free(456)
	var i uint32
	var klen uint32
	var p uintptr
	var r uint32
	var salt uintptr
	var slen uint32
	var u uint64
	var _ /* ctx at bp+0 */ Tsha512
	var _ /* end at bp+416 */ uintptr
	var _ /* kmd at bp+264 */ [64]uint8
	var _ /* md at bp+200 */ [64]uint8
	var _ /* rounds at bp+392 */ [20]int8
	var _ /* smd at bp+328 */ [64]uint8
	*(*[20]int8)(unsafe.Pointer(bp + 392)) = [20]int8{}
	/* reject large keys */
	for i = uint32(0); i <= uint32(m_KEY_MAX1) && *(*int8)(unsafe.Pointer(key + uintptr(i))) != 0; i++ {
	}
	if i > uint32(m_KEY_MAX1) {
		return uintptr(0)
	}
	klen = i
	/* setting: $6$rounds=n$salt$ (rounds=n$ and closing $ are optional) */
	if x_strncmp(tls, setting, ts+176, uint64(3)) != int32(0) {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	r = uint32(m_ROUNDS_DEFAULT)
	if x_strncmp(tls, salt, ts+146, Uint64FromInt64(8)-Uint64FromInt32(1)) == int32(0) {
		/*
		 * this is a deviation from the reference:
		 * bad rounds setting is rejected if it is
		 * - empty
		 * - unterminated (missing '$')
		 * - begins with anything but a decimal digit
		 * the reference implementation treats these bad
		 * rounds as part of the salt or parse them with
		 * strtoul semantics which may cause problems
		 * including non-portable hashes that depend on
		 * the host's value of ULONG_MAX.
		 */
		salt = salt + uintptr(Uint64FromInt64(8)-Uint64FromInt32(1))
		if !(BoolInt32(uint32(*(*int8)(unsafe.Pointer(salt)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		u = x_strtoul(tls, salt, bp+416, int32(10))
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 416))))) != int32('$') {
			return uintptr(0)
		}
		salt = *(*uintptr)(unsafe.Pointer(bp + 416)) + uintptr(1)
		if u < uint64(m_ROUNDS_MIN) {
			r = uint32(m_ROUNDS_MIN)
		} else {
			if u > uint64(m_ROUNDS_MAX) {
				return uintptr(0)
			} else {
				r = uint32(u)
			}
		}
		/* needed when rounds is zero prefixed or out of bounds */
		x_sprintf(tls, bp+392, ts+154, VaList(bp+432, r))
	}
	for i = uint32(0); i < uint32(m_SALT_MAX1) && *(*int8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$'); i++ {
		/* reject characters that interfere with /etc/shadow parsing */
		if int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) == int32('\n') || int32(*(*int8)(unsafe.Pointer(salt + uintptr(i)))) == int32(':') {
			return uintptr(0)
		}
	}
	slen = i
	/* B = sha(key salt key) */
	_sha512_init(tls, bp)
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_update(tls, bp, salt, uint64(slen))
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_sum(tls, bp, bp+200)
	/* A = sha(key salt repeat-B alternate-B-key) */
	_sha512_init(tls, bp)
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_update(tls, bp, salt, uint64(slen))
	_hashmd1(tls, bp, klen, bp+200)
	for i = klen; i > uint32(0); {
		if i&uint32(1) != 0 {
			_sha512_update(tls, bp, bp+200, uint64(64))
		} else {
			_sha512_update(tls, bp, key, uint64(klen))
		}
		goto _1
	_1:
		i = i >> Uint32FromInt32(1)
	}
	_sha512_sum(tls, bp, bp+200)
	/* DP = sha(repeat-key), this step takes O(klen^2) time */
	_sha512_init(tls, bp)
	for i = uint32(0); i < klen; i++ {
		_sha512_update(tls, bp, key, uint64(klen))
	}
	_sha512_sum(tls, bp, bp+264)
	/* DS = sha(repeat-salt) */
	_sha512_init(tls, bp)
	for i = uint32(0); i < uint32(int32(16)+int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[int32(0)])); i++ {
		_sha512_update(tls, bp, salt, uint64(slen))
	}
	_sha512_sum(tls, bp, bp+328)
	/* iterate A = f(A,DP,DS), this step takes O(rounds*klen) time */
	for i = uint32(0); i < r; i++ {
		_sha512_init(tls, bp)
		if i%uint32(2) != 0 {
			_hashmd1(tls, bp, klen, bp+264)
		} else {
			_sha512_update(tls, bp, bp+200, uint64(64))
		}
		if i%uint32(3) != 0 {
			_sha512_update(tls, bp, bp+328, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_hashmd1(tls, bp, klen, bp+264)
		}
		if i%uint32(2) != 0 {
			_sha512_update(tls, bp, bp+200, uint64(64))
		} else {
			_hashmd1(tls, bp, klen, bp+264)
		}
		_sha512_sum(tls, bp, bp+200)
	}
	/* output is $6$rounds=n$salt$hash */
	p = output
	p = p + uintptr(x_sprintf(tls, p, ts+180, VaList(bp+432, bp+392, slen, salt)))
	for i = uint32(0); i < uint32(21); i++ {
		p = _to642(tls, p, uint32(int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3 + UintptrFromInt32(0)))])<<int32(16)|int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3 + UintptrFromInt32(1)))])<<int32(8)|int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3 + UintptrFromInt32(2)))])), int32(4))
	}
	p = _to642(tls, p, uint32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[int32(63)]), int32(2))
	*(*int8)(unsafe.Pointer(p)) = int8(0)
	return output
}

var _perm2 = [21][3]uint8{
	0: {
		0: uint8(0),
		1: uint8(21),
		2: uint8(42)},
	1: {
		0: uint8(22),
		1: uint8(43),
		2: uint8(1)},
	2: {
		0: uint8(44),
		1: uint8(2),
		2: uint8(23)},
	3: {
		0: uint8(3),
		1: uint8(24),
		2: uint8(45)},
	4: {
		0: uint8(25),
		1: uint8(46),
		2: uint8(4)},
	5: {
		0: uint8(47),
		1: uint8(5),
		2: uint8(26)},
	6: {
		0: uint8(6),
		1: uint8(27),
		2: uint8(48)},
	7: {
		0: uint8(28),
		1: uint8(49),
		2: uint8(7)},
	8: {
		0: uint8(50),
		1: uint8(8),
		2: uint8(29)},
	9: {
		0: uint8(9),
		1: uint8(30),
		2: uint8(51)},
	10: {
		0: uint8(31),
		1: uint8(52),
		2: uint8(10)},
	11: {
		0: uint8(53),
		1: uint8(11),
		2: uint8(32)},
	12: {
		0: uint8(12),
		1: uint8(33),
		2: uint8(54)},
	13: {
		0: uint8(34),
		1: uint8(55),
		2: uint8(13)},
	14: {
		0: uint8(56),
		1: uint8(14),
		2: uint8(35)},
	15: {
		0: uint8(15),
		1: uint8(36),
		2: uint8(57)},
	16: {
		0: uint8(37),
		1: uint8(58),
		2: uint8(16)},
	17: {
		0: uint8(59),
		1: uint8(17),
		2: uint8(38)},
	18: {
		0: uint8(18),
		1: uint8(39),
		2: uint8(60)},
	19: {
		0: uint8(40),
		1: uint8(61),
		2: uint8(19)},
	20: {
		0: uint8(62),
		1: uint8(20),
		2: uint8(41)}}

func x___crypt_sha512(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var p uintptr
	var q uintptr
	var _ /* testbuf at bp+0 */ [128]int8
	p = _sha512crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _sha512crypt(tls, uintptr(unsafe.Pointer(&_testkey2)), uintptr(unsafe.Pointer(&_testsetting2)), bp)
	if !(p != 0) || q != bp || x_memcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash2)), uint64(116)) != 0 {
		return ts + 65
	}
	return p
}

var _testkey2 = [18]int8{'X', 'y', '0', '1', '@', '#', 1, 2, -128, 127, -1, 13, 10, -127, 9, ' ', '!'}

var _testsetting2 = [30]int8{'$', '6', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$'}

var _testhash2 = [116]int8{'$', '6', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$', 'B', 'C', 'p', 't', '8', 'z', 'L', 'r', 'c', '/', 'R', 'c', 'y', 'u', 'X', 'm', 'C', 'D', 'O', 'E', '1', 'A', 'L', 'q', 'M', 'X', 'B', '2', 'M', 'H', '6', 'n', '1', 'g', '8', '9', '1', 'H', 'h', 'F', 'j', '8', '.', 'w', '7', 'L', 'x', 'G', 'v', '.', 'F', 'T', 'k', 'q', 'q', '6', 'V', 'x', 'c', '/', 'k', 'm', '3', 'Y', '0', 'j', 'E', '0', 'j', '2', '4', 'j', 'Y', '5', 'P', 'I', 'v', '/', 'o', 'O', 'u', '6', 'r', 'e', 'g', '1'}

var ___encrypt_key Texpanded_key

func x_setkey(tls *TLS, key uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var i int32
	var j int32
	var _ /* bkey at bp+0 */ [8]uint8
	var p2 uintptr
	for i = int32(0); i < int32(8); i++ {
		(*(*[8]uint8)(unsafe.Pointer(bp)))[i] = uint8(0)
		for j = int32(7); j >= int32(0); {
			p2 = bp + uintptr(i)
			*(*uint8)(unsafe.Pointer(p2)) = uint8(uint32(*(*uint8)(unsafe.Pointer(p2))) | uint32(int32(*(*int8)(unsafe.Pointer(key)))&Int32FromInt32(1))<<j)
			goto _1
		_1:
			j--
			key++
		}
	}
	x___des_setkey(tls, bp, uintptr(unsafe.Pointer(&___encrypt_key)))
}

func x_encrypt(tls *TLS, block uintptr, edflag int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxValist 0 */
	defer tls.Free(136)
	var i int32
	var j int32
	var key uintptr
	var p uintptr
	var _ /* b at bp+128 */ [2]Tuint32_t
	var _ /* decrypt_key at bp+0 */ Texpanded_key
	var v3 uintptr
	var p2 uintptr
	p = block
	for i = int32(0); i < int32(2); i++ {
		(*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[i] = uint32(0)
		for j = int32(31); j >= int32(0); {
			p2 = bp + 128 + uintptr(i)*4
			*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | uint32(int32(*(*int8)(unsafe.Pointer(p)))&Int32FromInt32(1))<<j
			goto _1
		_1:
			j--
			p++
		}
	}
	key = uintptr(unsafe.Pointer(&___encrypt_key))
	if edflag != 0 {
		key = bp
		for i = int32(0); i < int32(16); i++ {
			*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Texpanded_key)(unsafe.Pointer(bp))).Fl)) + uintptr(i)*4)) = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&___encrypt_key.Fl)) + uintptr(Int32FromInt32(15)-i)*4))
			*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Texpanded_key)(unsafe.Pointer(bp))).Fr)) + uintptr(i)*4)) = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&___encrypt_key.Fr)) + uintptr(Int32FromInt32(15)-i)*4))
		}
	}
	x___do_des(tls, (*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[int32(0)], (*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[int32(1)], bp+128, bp+128+uintptr(1)*4, uint32(1), uint32(0), key)
	p = block
	for i = int32(0); i < int32(2); i++ {
		for j = int32(31); j >= int32(0); j-- {
			v3 = p
			p++
			*(*int8)(unsafe.Pointer(v3)) = int8((*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[i] >> j & uint32(1))
		}
	}
}

var _table = [384]uint16{
	0:   uint16(0),
	1:   uint16(0),
	2:   uint16(0),
	3:   uint16(0),
	4:   uint16(0),
	5:   uint16(0),
	6:   uint16(0),
	7:   uint16(0),
	8:   uint16(0),
	9:   uint16(0),
	10:  uint16(0),
	11:  uint16(0),
	12:  uint16(0),
	13:  uint16(0),
	14:  uint16(0),
	15:  uint16(0),
	16:  uint16(0),
	17:  uint16(0),
	18:  uint16(0),
	19:  uint16(0),
	20:  uint16(0),
	21:  uint16(0),
	22:  uint16(0),
	23:  uint16(0),
	24:  uint16(0),
	25:  uint16(0),
	26:  uint16(0),
	27:  uint16(0),
	28:  uint16(0),
	29:  uint16(0),
	30:  uint16(0),
	31:  uint16(0),
	32:  uint16(0),
	33:  uint16(0),
	34:  uint16(0),
	35:  uint16(0),
	36:  uint16(0),
	37:  uint16(0),
	38:  uint16(0),
	39:  uint16(0),
	40:  uint16(0),
	41:  uint16(0),
	42:  uint16(0),
	43:  uint16(0),
	44:  uint16(0),
	45:  uint16(0),
	46:  uint16(0),
	47:  uint16(0),
	48:  uint16(0),
	49:  uint16(0),
	50:  uint16(0),
	51:  uint16(0),
	52:  uint16(0),
	53:  uint16(0),
	54:  uint16(0),
	55:  uint16(0),
	56:  uint16(0),
	57:  uint16(0),
	58:  uint16(0),
	59:  uint16(0),
	60:  uint16(0),
	61:  uint16(0),
	62:  uint16(0),
	63:  uint16(0),
	64:  uint16(0),
	65:  uint16(0),
	66:  uint16(0),
	67:  uint16(0),
	68:  uint16(0),
	69:  uint16(0),
	70:  uint16(0),
	71:  uint16(0),
	72:  uint16(0),
	73:  uint16(0),
	74:  uint16(0),
	75:  uint16(0),
	76:  uint16(0),
	77:  uint16(0),
	78:  uint16(0),
	79:  uint16(0),
	80:  uint16(0),
	81:  uint16(0),
	82:  uint16(0),
	83:  uint16(0),
	84:  uint16(0),
	85:  uint16(0),
	86:  uint16(0),
	87:  uint16(0),
	88:  uint16(0),
	89:  uint16(0),
	90:  uint16(0),
	91:  uint16(0),
	92:  uint16(0),
	93:  uint16(0),
	94:  uint16(0),
	95:  uint16(0),
	96:  uint16(0),
	97:  uint16(0),
	98:  uint16(0),
	99:  uint16(0),
	100: uint16(0),
	101: uint16(0),
	102: uint16(0),
	103: uint16(0),
	104: uint16(0),
	105: uint16(0),
	106: uint16(0),
	107: uint16(0),
	108: uint16(0),
	109: uint16(0),
	110: uint16(0),
	111: uint16(0),
	112: uint16(0),
	113: uint16(0),
	114: uint16(0),
	115: uint16(0),
	116: uint16(0),
	117: uint16(0),
	118: uint16(0),
	119: uint16(0),
	120: uint16(0),
	121: uint16(0),
	122: uint16(0),
	123: uint16(0),
	124: uint16(0),
	125: uint16(0),
	126: uint16(0),
	127: uint16(0),
	128: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	129: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	130: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	131: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	132: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	133: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	134: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	135: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	136: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	137: uint16((Int32FromInt32(0x320)/Int32FromInt32(256) | Int32FromInt32(0x320)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	138: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	139: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	140: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	141: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	142: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	143: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	144: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	145: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	146: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	147: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	148: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	149: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	150: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	151: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	152: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	153: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	154: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	155: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	156: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	157: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	158: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	159: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	160: uint16((Int32FromInt32(0x160)/Int32FromInt32(256) | Int32FromInt32(0x160)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	161: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	162: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	163: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	164: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	165: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	166: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	167: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	168: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	169: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	170: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	171: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	172: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	173: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	174: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	175: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	176: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	177: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	178: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	179: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	180: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	181: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	182: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	183: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	184: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	185: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	186: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	187: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	188: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	189: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	190: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	191: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	192: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	193: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	194: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	195: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	196: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	197: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	198: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	199: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	200: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	201: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	202: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	203: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	204: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	205: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	206: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	207: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	208: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	209: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	210: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	211: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	212: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	213: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	214: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	215: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	216: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	217: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	218: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	219: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	220: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	221: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	222: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	223: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	224: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	225: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	226: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	227: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	228: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	229: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	230: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	231: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	232: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	233: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	234: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	235: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	236: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	237: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	238: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	239: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	240: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	241: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	242: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	243: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	244: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	245: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	246: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	247: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	248: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	249: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	250: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	251: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	252: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	253: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	254: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	255: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	256: uint16(0),
	257: uint16(0),
	258: uint16(0),
	259: uint16(0),
	260: uint16(0),
	261: uint16(0),
	262: uint16(0),
	263: uint16(0),
	264: uint16(0),
	265: uint16(0),
	266: uint16(0),
	267: uint16(0),
	268: uint16(0),
	269: uint16(0),
	270: uint16(0),
	271: uint16(0),
	272: uint16(0),
	273: uint16(0),
	274: uint16(0),
	275: uint16(0),
	276: uint16(0),
	277: uint16(0),
	278: uint16(0),
	279: uint16(0),
	280: uint16(0),
	281: uint16(0),
	282: uint16(0),
	283: uint16(0),
	284: uint16(0),
	285: uint16(0),
	286: uint16(0),
	287: uint16(0),
	288: uint16(0),
	289: uint16(0),
	290: uint16(0),
	291: uint16(0),
	292: uint16(0),
	293: uint16(0),
	294: uint16(0),
	295: uint16(0),
	296: uint16(0),
	297: uint16(0),
	298: uint16(0),
	299: uint16(0),
	300: uint16(0),
	301: uint16(0),
	302: uint16(0),
	303: uint16(0),
	304: uint16(0),
	305: uint16(0),
	306: uint16(0),
	307: uint16(0),
	308: uint16(0),
	309: uint16(0),
	310: uint16(0),
	311: uint16(0),
	312: uint16(0),
	313: uint16(0),
	314: uint16(0),
	315: uint16(0),
	316: uint16(0),
	317: uint16(0),
	318: uint16(0),
	319: uint16(0),
	320: uint16(0),
	321: uint16(0),
	322: uint16(0),
	323: uint16(0),
	324: uint16(0),
	325: uint16(0),
	326: uint16(0),
	327: uint16(0),
	328: uint16(0),
	329: uint16(0),
	330: uint16(0),
	331: uint16(0),
	332: uint16(0),
	333: uint16(0),
	334: uint16(0),
	335: uint16(0),
	336: uint16(0),
	337: uint16(0),
	338: uint16(0),
	339: uint16(0),
	340: uint16(0),
	341: uint16(0),
	342: uint16(0),
	343: uint16(0),
	344: uint16(0),
	345: uint16(0),
	346: uint16(0),
	347: uint16(0),
	348: uint16(0),
	349: uint16(0),
	350: uint16(0),
	351: uint16(0),
	352: uint16(0),
	353: uint16(0),
	354: uint16(0),
	355: uint16(0),
	356: uint16(0),
	357: uint16(0),
	358: uint16(0),
	359: uint16(0),
	360: uint16(0),
	361: uint16(0),
	362: uint16(0),
	363: uint16(0),
	364: uint16(0),
	365: uint16(0),
	366: uint16(0),
	367: uint16(0),
	368: uint16(0),
	369: uint16(0),
	370: uint16(0),
	371: uint16(0),
	372: uint16(0),
	373: uint16(0),
	374: uint16(0),
	375: uint16(0),
	376: uint16(0),
	377: uint16(0),
	378: uint16(0),
	379: uint16(0),
	380: uint16(0),
	381: uint16(0),
	382: uint16(0),
	383: uint16(0)}

var _ptable = uintptr(unsafe.Pointer(&_table)) + uintptr(128)*2

func x___ctype_b_loc(tls *TLS) (r uintptr) {
	return uintptr(unsafe.Pointer(&_ptable))
}

const m_LC_CTYPE = 0
const m_LOCALE_NAME_MAX = 23

type Tlconv = struct {
	Fdecimal_point      uintptr
	Fthousands_sep      uintptr
	Fgrouping           uintptr
	Fint_curr_symbol    uintptr
	Fcurrency_symbol    uintptr
	Fmon_decimal_point  uintptr
	Fmon_thousands_sep  uintptr
	Fmon_grouping       uintptr
	Fpositive_sign      uintptr
	Fnegative_sign      uintptr
	Fint_frac_digits    int8
	Ffrac_digits        int8
	Fp_cs_precedes      int8
	Fp_sep_by_space     int8
	Fn_cs_precedes      int8
	Fn_sep_by_space     int8
	Fp_sign_posn        int8
	Fn_sign_posn        int8
	Fint_p_cs_precedes  int8
	Fint_p_sep_by_space int8
	Fint_n_cs_precedes  int8
	Fint_n_sep_by_space int8
	Fint_p_sign_posn    int8
	Fint_n_sign_posn    int8
	F__ccgo_pad24       [2]byte
}

type T__locale_map = struct {
	Fmap1     uintptr
	Fmap_size Tsize_t
	Fname     [24]int8
	Fnext     uintptr
}

func x___ctype_get_mb_cur_max(tls *TLS) (r Tsize_t) {
	var v1 int32
	if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
		v1 = int32(4)
	} else {
		v1 = int32(1)
	}
	return uint64(v1)
}

var _table1 = [384]Tint32_t{
	0:   int32(0),
	1:   int32(0),
	2:   int32(0),
	3:   int32(0),
	4:   int32(0),
	5:   int32(0),
	6:   int32(0),
	7:   int32(0),
	8:   int32(0),
	9:   int32(0),
	10:  int32(0),
	11:  int32(0),
	12:  int32(0),
	13:  int32(0),
	14:  int32(0),
	15:  int32(0),
	16:  int32(0),
	17:  int32(0),
	18:  int32(0),
	19:  int32(0),
	20:  int32(0),
	21:  int32(0),
	22:  int32(0),
	23:  int32(0),
	24:  int32(0),
	25:  int32(0),
	26:  int32(0),
	27:  int32(0),
	28:  int32(0),
	29:  int32(0),
	30:  int32(0),
	31:  int32(0),
	32:  int32(0),
	33:  int32(0),
	34:  int32(0),
	35:  int32(0),
	36:  int32(0),
	37:  int32(0),
	38:  int32(0),
	39:  int32(0),
	40:  int32(0),
	41:  int32(0),
	42:  int32(0),
	43:  int32(0),
	44:  int32(0),
	45:  int32(0),
	46:  int32(0),
	47:  int32(0),
	48:  int32(0),
	49:  int32(0),
	50:  int32(0),
	51:  int32(0),
	52:  int32(0),
	53:  int32(0),
	54:  int32(0),
	55:  int32(0),
	56:  int32(0),
	57:  int32(0),
	58:  int32(0),
	59:  int32(0),
	60:  int32(0),
	61:  int32(0),
	62:  int32(0),
	63:  int32(0),
	64:  int32(0),
	65:  int32(0),
	66:  int32(0),
	67:  int32(0),
	68:  int32(0),
	69:  int32(0),
	70:  int32(0),
	71:  int32(0),
	72:  int32(0),
	73:  int32(0),
	74:  int32(0),
	75:  int32(0),
	76:  int32(0),
	77:  int32(0),
	78:  int32(0),
	79:  int32(0),
	80:  int32(0),
	81:  int32(0),
	82:  int32(0),
	83:  int32(0),
	84:  int32(0),
	85:  int32(0),
	86:  int32(0),
	87:  int32(0),
	88:  int32(0),
	89:  int32(0),
	90:  int32(0),
	91:  int32(0),
	92:  int32(0),
	93:  int32(0),
	94:  int32(0),
	95:  int32(0),
	96:  int32(0),
	97:  int32(0),
	98:  int32(0),
	99:  int32(0),
	100: int32(0),
	101: int32(0),
	102: int32(0),
	103: int32(0),
	104: int32(0),
	105: int32(0),
	106: int32(0),
	107: int32(0),
	108: int32(0),
	109: int32(0),
	110: int32(0),
	111: int32(0),
	112: int32(0),
	113: int32(0),
	114: int32(0),
	115: int32(0),
	116: int32(0),
	117: int32(0),
	118: int32(0),
	119: int32(0),
	120: int32(0),
	121: int32(0),
	122: int32(0),
	123: int32(0),
	124: int32(0),
	125: int32(0),
	126: int32(0),
	127: int32(0),
	128: int32(0),
	129: int32(1),
	130: int32(2),
	131: int32(3),
	132: int32(4),
	133: int32(5),
	134: int32(6),
	135: int32(7),
	136: int32(8),
	137: int32(9),
	138: int32(10),
	139: int32(11),
	140: int32(12),
	141: int32(13),
	142: int32(14),
	143: int32(15),
	144: int32(16),
	145: int32(17),
	146: int32(18),
	147: int32(19),
	148: int32(20),
	149: int32(21),
	150: int32(22),
	151: int32(23),
	152: int32(24),
	153: int32(25),
	154: int32(26),
	155: int32(27),
	156: int32(28),
	157: int32(29),
	158: int32(30),
	159: int32(31),
	160: int32(32),
	161: int32(33),
	162: int32(34),
	163: int32(35),
	164: int32(36),
	165: int32(37),
	166: int32(38),
	167: int32(39),
	168: int32(40),
	169: int32(41),
	170: int32(42),
	171: int32(43),
	172: int32(44),
	173: int32(45),
	174: int32(46),
	175: int32(47),
	176: int32(48),
	177: int32(49),
	178: int32(50),
	179: int32(51),
	180: int32(52),
	181: int32(53),
	182: int32(54),
	183: int32(55),
	184: int32(56),
	185: int32(57),
	186: int32(58),
	187: int32(59),
	188: int32(60),
	189: int32(61),
	190: int32(62),
	191: int32(63),
	192: int32(64),
	193: int32('a'),
	194: int32('b'),
	195: int32('c'),
	196: int32('d'),
	197: int32('e'),
	198: int32('f'),
	199: int32('g'),
	200: int32('h'),
	201: int32('i'),
	202: int32('j'),
	203: int32('k'),
	204: int32('l'),
	205: int32('m'),
	206: int32('n'),
	207: int32('o'),
	208: int32('p'),
	209: int32('q'),
	210: int32('r'),
	211: int32('s'),
	212: int32('t'),
	213: int32('u'),
	214: int32('v'),
	215: int32('w'),
	216: int32('x'),
	217: int32('y'),
	218: int32('z'),
	219: int32(91),
	220: int32(92),
	221: int32(93),
	222: int32(94),
	223: int32(95),
	224: int32(96),
	225: int32('a'),
	226: int32('b'),
	227: int32('c'),
	228: int32('d'),
	229: int32('e'),
	230: int32('f'),
	231: int32('g'),
	232: int32('h'),
	233: int32('i'),
	234: int32('j'),
	235: int32('k'),
	236: int32('l'),
	237: int32('m'),
	238: int32('n'),
	239: int32('o'),
	240: int32('p'),
	241: int32('q'),
	242: int32('r'),
	243: int32('s'),
	244: int32('t'),
	245: int32('u'),
	246: int32('v'),
	247: int32('w'),
	248: int32('x'),
	249: int32('y'),
	250: int32('z'),
	251: int32(123),
	252: int32(124),
	253: int32(125),
	254: int32(126),
	255: int32(127),
	256: int32(0),
	257: int32(0),
	258: int32(0),
	259: int32(0),
	260: int32(0),
	261: int32(0),
	262: int32(0),
	263: int32(0),
	264: int32(0),
	265: int32(0),
	266: int32(0),
	267: int32(0),
	268: int32(0),
	269: int32(0),
	270: int32(0),
	271: int32(0),
	272: int32(0),
	273: int32(0),
	274: int32(0),
	275: int32(0),
	276: int32(0),
	277: int32(0),
	278: int32(0),
	279: int32(0),
	280: int32(0),
	281: int32(0),
	282: int32(0),
	283: int32(0),
	284: int32(0),
	285: int32(0),
	286: int32(0),
	287: int32(0),
	288: int32(0),
	289: int32(0),
	290: int32(0),
	291: int32(0),
	292: int32(0),
	293: int32(0),
	294: int32(0),
	295: int32(0),
	296: int32(0),
	297: int32(0),
	298: int32(0),
	299: int32(0),
	300: int32(0),
	301: int32(0),
	302: int32(0),
	303: int32(0),
	304: int32(0),
	305: int32(0),
	306: int32(0),
	307: int32(0),
	308: int32(0),
	309: int32(0),
	310: int32(0),
	311: int32(0),
	312: int32(0),
	313: int32(0),
	314: int32(0),
	315: int32(0),
	316: int32(0),
	317: int32(0),
	318: int32(0),
	319: int32(0),
	320: int32(0),
	321: int32(0),
	322: int32(0),
	323: int32(0),
	324: int32(0),
	325: int32(0),
	326: int32(0),
	327: int32(0),
	328: int32(0),
	329: int32(0),
	330: int32(0),
	331: int32(0),
	332: int32(0),
	333: int32(0),
	334: int32(0),
	335: int32(0),
	336: int32(0),
	337: int32(0),
	338: int32(0),
	339: int32(0),
	340: int32(0),
	341: int32(0),
	342: int32(0),
	343: int32(0),
	344: int32(0),
	345: int32(0),
	346: int32(0),
	347: int32(0),
	348: int32(0),
	349: int32(0),
	350: int32(0),
	351: int32(0),
	352: int32(0),
	353: int32(0),
	354: int32(0),
	355: int32(0),
	356: int32(0),
	357: int32(0),
	358: int32(0),
	359: int32(0),
	360: int32(0),
	361: int32(0),
	362: int32(0),
	363: int32(0),
	364: int32(0),
	365: int32(0),
	366: int32(0),
	367: int32(0),
	368: int32(0),
	369: int32(0),
	370: int32(0),
	371: int32(0),
	372: int32(0),
	373: int32(0),
	374: int32(0),
	375: int32(0),
	376: int32(0),
	377: int32(0),
	378: int32(0),
	379: int32(0),
	380: int32(0),
	381: int32(0),
	382: int32(0),
	383: int32(0)}

var _ptable1 = uintptr(unsafe.Pointer(&_table1)) + uintptr(128)*4

func x___ctype_tolower_loc(tls *TLS) (r uintptr) {
	return uintptr(unsafe.Pointer(&_ptable1))
}

var _table2 = [384]Tint32_t{
	0:   int32(0),
	1:   int32(0),
	2:   int32(0),
	3:   int32(0),
	4:   int32(0),
	5:   int32(0),
	6:   int32(0),
	7:   int32(0),
	8:   int32(0),
	9:   int32(0),
	10:  int32(0),
	11:  int32(0),
	12:  int32(0),
	13:  int32(0),
	14:  int32(0),
	15:  int32(0),
	16:  int32(0),
	17:  int32(0),
	18:  int32(0),
	19:  int32(0),
	20:  int32(0),
	21:  int32(0),
	22:  int32(0),
	23:  int32(0),
	24:  int32(0),
	25:  int32(0),
	26:  int32(0),
	27:  int32(0),
	28:  int32(0),
	29:  int32(0),
	30:  int32(0),
	31:  int32(0),
	32:  int32(0),
	33:  int32(0),
	34:  int32(0),
	35:  int32(0),
	36:  int32(0),
	37:  int32(0),
	38:  int32(0),
	39:  int32(0),
	40:  int32(0),
	41:  int32(0),
	42:  int32(0),
	43:  int32(0),
	44:  int32(0),
	45:  int32(0),
	46:  int32(0),
	47:  int32(0),
	48:  int32(0),
	49:  int32(0),
	50:  int32(0),
	51:  int32(0),
	52:  int32(0),
	53:  int32(0),
	54:  int32(0),
	55:  int32(0),
	56:  int32(0),
	57:  int32(0),
	58:  int32(0),
	59:  int32(0),
	60:  int32(0),
	61:  int32(0),
	62:  int32(0),
	63:  int32(0),
	64:  int32(0),
	65:  int32(0),
	66:  int32(0),
	67:  int32(0),
	68:  int32(0),
	69:  int32(0),
	70:  int32(0),
	71:  int32(0),
	72:  int32(0),
	73:  int32(0),
	74:  int32(0),
	75:  int32(0),
	76:  int32(0),
	77:  int32(0),
	78:  int32(0),
	79:  int32(0),
	80:  int32(0),
	81:  int32(0),
	82:  int32(0),
	83:  int32(0),
	84:  int32(0),
	85:  int32(0),
	86:  int32(0),
	87:  int32(0),
	88:  int32(0),
	89:  int32(0),
	90:  int32(0),
	91:  int32(0),
	92:  int32(0),
	93:  int32(0),
	94:  int32(0),
	95:  int32(0),
	96:  int32(0),
	97:  int32(0),
	98:  int32(0),
	99:  int32(0),
	100: int32(0),
	101: int32(0),
	102: int32(0),
	103: int32(0),
	104: int32(0),
	105: int32(0),
	106: int32(0),
	107: int32(0),
	108: int32(0),
	109: int32(0),
	110: int32(0),
	111: int32(0),
	112: int32(0),
	113: int32(0),
	114: int32(0),
	115: int32(0),
	116: int32(0),
	117: int32(0),
	118: int32(0),
	119: int32(0),
	120: int32(0),
	121: int32(0),
	122: int32(0),
	123: int32(0),
	124: int32(0),
	125: int32(0),
	126: int32(0),
	127: int32(0),
	128: int32(0),
	129: int32(1),
	130: int32(2),
	131: int32(3),
	132: int32(4),
	133: int32(5),
	134: int32(6),
	135: int32(7),
	136: int32(8),
	137: int32(9),
	138: int32(10),
	139: int32(11),
	140: int32(12),
	141: int32(13),
	142: int32(14),
	143: int32(15),
	144: int32(16),
	145: int32(17),
	146: int32(18),
	147: int32(19),
	148: int32(20),
	149: int32(21),
	150: int32(22),
	151: int32(23),
	152: int32(24),
	153: int32(25),
	154: int32(26),
	155: int32(27),
	156: int32(28),
	157: int32(29),
	158: int32(30),
	159: int32(31),
	160: int32(32),
	161: int32(33),
	162: int32(34),
	163: int32(35),
	164: int32(36),
	165: int32(37),
	166: int32(38),
	167: int32(39),
	168: int32(40),
	169: int32(41),
	170: int32(42),
	171: int32(43),
	172: int32(44),
	173: int32(45),
	174: int32(46),
	175: int32(47),
	176: int32(48),
	177: int32(49),
	178: int32(50),
	179: int32(51),
	180: int32(52),
	181: int32(53),
	182: int32(54),
	183: int32(55),
	184: int32(56),
	185: int32(57),
	186: int32(58),
	187: int32(59),
	188: int32(60),
	189: int32(61),
	190: int32(62),
	191: int32(63),
	192: int32(64),
	193: int32('A'),
	194: int32('B'),
	195: int32('C'),
	196: int32('D'),
	197: int32('E'),
	198: int32('F'),
	199: int32('G'),
	200: int32('H'),
	201: int32('I'),
	202: int32('J'),
	203: int32('K'),
	204: int32('L'),
	205: int32('M'),
	206: int32('N'),
	207: int32('O'),
	208: int32('P'),
	209: int32('Q'),
	210: int32('R'),
	211: int32('S'),
	212: int32('T'),
	213: int32('U'),
	214: int32('V'),
	215: int32('W'),
	216: int32('X'),
	217: int32('Y'),
	218: int32('Z'),
	219: int32(91),
	220: int32(92),
	221: int32(93),
	222: int32(94),
	223: int32(95),
	224: int32(96),
	225: int32('A'),
	226: int32('B'),
	227: int32('C'),
	228: int32('D'),
	229: int32('E'),
	230: int32('F'),
	231: int32('G'),
	232: int32('H'),
	233: int32('I'),
	234: int32('J'),
	235: int32('K'),
	236: int32('L'),
	237: int32('M'),
	238: int32('N'),
	239: int32('O'),
	240: int32('P'),
	241: int32('Q'),
	242: int32('R'),
	243: int32('S'),
	244: int32('T'),
	245: int32('U'),
	246: int32('V'),
	247: int32('W'),
	248: int32('X'),
	249: int32('Y'),
	250: int32('Z'),
	251: int32(123),
	252: int32(124),
	253: int32(125),
	254: int32(126),
	255: int32(127),
	256: int32(0),
	257: int32(0),
	258: int32(0),
	259: int32(0),
	260: int32(0),
	261: int32(0),
	262: int32(0),
	263: int32(0),
	264: int32(0),
	265: int32(0),
	266: int32(0),
	267: int32(0),
	268: int32(0),
	269: int32(0),
	270: int32(0),
	271: int32(0),
	272: int32(0),
	273: int32(0),
	274: int32(0),
	275: int32(0),
	276: int32(0),
	277: int32(0),
	278: int32(0),
	279: int32(0),
	280: int32(0),
	281: int32(0),
	282: int32(0),
	283: int32(0),
	284: int32(0),
	285: int32(0),
	286: int32(0),
	287: int32(0),
	288: int32(0),
	289: int32(0),
	290: int32(0),
	291: int32(0),
	292: int32(0),
	293: int32(0),
	294: int32(0),
	295: int32(0),
	296: int32(0),
	297: int32(0),
	298: int32(0),
	299: int32(0),
	300: int32(0),
	301: int32(0),
	302: int32(0),
	303: int32(0),
	304: int32(0),
	305: int32(0),
	306: int32(0),
	307: int32(0),
	308: int32(0),
	309: int32(0),
	310: int32(0),
	311: int32(0),
	312: int32(0),
	313: int32(0),
	314: int32(0),
	315: int32(0),
	316: int32(0),
	317: int32(0),
	318: int32(0),
	319: int32(0),
	320: int32(0),
	321: int32(0),
	322: int32(0),
	323: int32(0),
	324: int32(0),
	325: int32(0),
	326: int32(0),
	327: int32(0),
	328: int32(0),
	329: int32(0),
	330: int32(0),
	331: int32(0),
	332: int32(0),
	333: int32(0),
	334: int32(0),
	335: int32(0),
	336: int32(0),
	337: int32(0),
	338: int32(0),
	339: int32(0),
	340: int32(0),
	341: int32(0),
	342: int32(0),
	343: int32(0),
	344: int32(0),
	345: int32(0),
	346: int32(0),
	347: int32(0),
	348: int32(0),
	349: int32(0),
	350: int32(0),
	351: int32(0),
	352: int32(0),
	353: int32(0),
	354: int32(0),
	355: int32(0),
	356: int32(0),
	357: int32(0),
	358: int32(0),
	359: int32(0),
	360: int32(0),
	361: int32(0),
	362: int32(0),
	363: int32(0),
	364: int32(0),
	365: int32(0),
	366: int32(0),
	367: int32(0),
	368: int32(0),
	369: int32(0),
	370: int32(0),
	371: int32(0),
	372: int32(0),
	373: int32(0),
	374: int32(0),
	375: int32(0),
	376: int32(0),
	377: int32(0),
	378: int32(0),
	379: int32(0),
	380: int32(0),
	381: int32(0),
	382: int32(0),
	383: int32(0)}

var _ptable2 = uintptr(unsafe.Pointer(&_table2)) + uintptr(128)*4

func x___ctype_toupper_loc(tls *TLS) (r uintptr) {
	return uintptr(unsafe.Pointer(&_ptable2))
}

func x_isalnum(tls *TLS, c int32) (r int32) {
	return BoolInt32(BoolInt32(uint32(c)|uint32(32)-uint32('a') < uint32(26)) != 0 || BoolInt32(uint32(c)-uint32('0') < uint32(10)) != 0)
}

func x___isalnum_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isalnum(tls, c)
}

func x_isalpha(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)|uint32(32)-uint32('a') < uint32(26))
}

func x___isalpha_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isalpha(tls, c)
}

func x_isascii(tls *TLS, c int32) (r int32) {
	return BoolInt32(!(c & ^Int32FromInt32(0x7f) != 0))
}

func x_isblank(tls *TLS, c int32) (r int32) {
	return BoolInt32(c == int32(' ') || c == int32('\t'))
}

func x___isblank_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isblank(tls, c)
}

func x_iscntrl(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c) < uint32(0x20) || c == int32(0x7f))
}

func x___iscntrl_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_iscntrl(tls, c)
}

func x_isdigit(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('0') < uint32(10))
}

func x___isdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isdigit(tls, c)
}

func x_isgraph(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32(0x21) < uint32(0x5e))
}

func x___isgraph_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isgraph(tls, c)
}

func x_islower(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('a') < uint32(26))
}

func x___islower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_islower(tls, c)
}

func x_isprint(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32(0x20) < uint32(0x5f))
}

func x___isprint_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isprint(tls, c)
}

func x_ispunct(tls *TLS, c int32) (r int32) {
	return BoolInt32(BoolInt32(uint32(c)-uint32(0x21) < uint32(0x5e)) != 0 && !(x_isalnum(tls, c) != 0))
}

func x___ispunct_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_ispunct(tls, c)
}

func x_isspace(tls *TLS, c int32) (r int32) {
	return BoolInt32(c == int32(' ') || uint32(c)-uint32('\t') < uint32(5))
}

func x___isspace_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isspace(tls, c)
}

func x_isupper(tls *TLS, c int32) (r int32) {
	return BoolInt32(uint32(c)-uint32('A') < uint32(26))
}

func x___isupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isupper(tls, c)
}

type Twint_t = uint32

type Twctype_t = uint64

type Twctrans_t = uintptr

func x_iswalnum(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(BoolInt32(wc-uint32('0') < uint32(10)) != 0 || x_iswalpha(tls, wc) != 0)
}

func x___iswalnum_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswalnum(tls, c)
}

var _table3 = [3904]uint8{
	0:    uint8(18),
	1:    uint8(17),
	2:    uint8(19),
	3:    uint8(20),
	4:    uint8(21),
	5:    uint8(22),
	6:    uint8(23),
	7:    uint8(24),
	8:    uint8(25),
	9:    uint8(26),
	10:   uint8(27),
	11:   uint8(28),
	12:   uint8(29),
	13:   uint8(30),
	14:   uint8(31),
	15:   uint8(32),
	16:   uint8(33),
	17:   uint8(17),
	18:   uint8(34),
	19:   uint8(35),
	20:   uint8(36),
	21:   uint8(17),
	22:   uint8(37),
	23:   uint8(38),
	24:   uint8(39),
	25:   uint8(40),
	26:   uint8(41),
	27:   uint8(42),
	28:   uint8(43),
	29:   uint8(44),
	30:   uint8(17),
	31:   uint8(45),
	32:   uint8(46),
	33:   uint8(47),
	34:   uint8(16),
	35:   uint8(16),
	36:   uint8(48),
	37:   uint8(16),
	38:   uint8(16),
	39:   uint8(16),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(16),
	44:   uint8(49),
	45:   uint8(50),
	46:   uint8(51),
	47:   uint8(16),
	48:   uint8(52),
	49:   uint8(53),
	50:   uint8(16),
	51:   uint8(16),
	52:   uint8(17),
	53:   uint8(17),
	54:   uint8(17),
	55:   uint8(17),
	56:   uint8(17),
	57:   uint8(17),
	58:   uint8(17),
	59:   uint8(17),
	60:   uint8(17),
	61:   uint8(17),
	62:   uint8(17),
	63:   uint8(17),
	64:   uint8(17),
	65:   uint8(17),
	66:   uint8(17),
	67:   uint8(17),
	68:   uint8(17),
	69:   uint8(17),
	70:   uint8(17),
	71:   uint8(17),
	72:   uint8(17),
	73:   uint8(17),
	74:   uint8(17),
	75:   uint8(17),
	76:   uint8(17),
	77:   uint8(54),
	78:   uint8(17),
	79:   uint8(17),
	80:   uint8(17),
	81:   uint8(17),
	82:   uint8(17),
	83:   uint8(17),
	84:   uint8(17),
	85:   uint8(17),
	86:   uint8(17),
	87:   uint8(17),
	88:   uint8(17),
	89:   uint8(17),
	90:   uint8(17),
	91:   uint8(17),
	92:   uint8(17),
	93:   uint8(17),
	94:   uint8(17),
	95:   uint8(17),
	96:   uint8(17),
	97:   uint8(17),
	98:   uint8(17),
	99:   uint8(17),
	100:  uint8(17),
	101:  uint8(17),
	102:  uint8(17),
	103:  uint8(17),
	104:  uint8(17),
	105:  uint8(17),
	106:  uint8(17),
	107:  uint8(17),
	108:  uint8(17),
	109:  uint8(17),
	110:  uint8(17),
	111:  uint8(17),
	112:  uint8(17),
	113:  uint8(17),
	114:  uint8(17),
	115:  uint8(17),
	116:  uint8(17),
	117:  uint8(17),
	118:  uint8(17),
	119:  uint8(17),
	120:  uint8(17),
	121:  uint8(17),
	122:  uint8(17),
	123:  uint8(17),
	124:  uint8(17),
	125:  uint8(17),
	126:  uint8(17),
	127:  uint8(17),
	128:  uint8(17),
	129:  uint8(17),
	130:  uint8(17),
	131:  uint8(17),
	132:  uint8(17),
	133:  uint8(17),
	134:  uint8(17),
	135:  uint8(17),
	136:  uint8(17),
	137:  uint8(17),
	138:  uint8(17),
	139:  uint8(17),
	140:  uint8(17),
	141:  uint8(17),
	142:  uint8(17),
	143:  uint8(17),
	144:  uint8(17),
	145:  uint8(17),
	146:  uint8(17),
	147:  uint8(17),
	148:  uint8(17),
	149:  uint8(17),
	150:  uint8(17),
	151:  uint8(17),
	152:  uint8(17),
	153:  uint8(17),
	154:  uint8(17),
	155:  uint8(17),
	156:  uint8(17),
	157:  uint8(17),
	158:  uint8(17),
	159:  uint8(55),
	160:  uint8(17),
	161:  uint8(17),
	162:  uint8(17),
	163:  uint8(17),
	164:  uint8(56),
	165:  uint8(17),
	166:  uint8(57),
	167:  uint8(58),
	168:  uint8(59),
	169:  uint8(60),
	170:  uint8(61),
	171:  uint8(62),
	172:  uint8(17),
	173:  uint8(17),
	174:  uint8(17),
	175:  uint8(17),
	176:  uint8(17),
	177:  uint8(17),
	178:  uint8(17),
	179:  uint8(17),
	180:  uint8(17),
	181:  uint8(17),
	182:  uint8(17),
	183:  uint8(17),
	184:  uint8(17),
	185:  uint8(17),
	186:  uint8(17),
	187:  uint8(17),
	188:  uint8(17),
	189:  uint8(17),
	190:  uint8(17),
	191:  uint8(17),
	192:  uint8(17),
	193:  uint8(17),
	194:  uint8(17),
	195:  uint8(17),
	196:  uint8(17),
	197:  uint8(17),
	198:  uint8(17),
	199:  uint8(17),
	200:  uint8(17),
	201:  uint8(17),
	202:  uint8(17),
	203:  uint8(17),
	204:  uint8(17),
	205:  uint8(17),
	206:  uint8(17),
	207:  uint8(17),
	208:  uint8(17),
	209:  uint8(17),
	210:  uint8(17),
	211:  uint8(17),
	212:  uint8(17),
	213:  uint8(17),
	214:  uint8(17),
	215:  uint8(63),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(17),
	250:  uint8(64),
	251:  uint8(65),
	252:  uint8(17),
	253:  uint8(66),
	254:  uint8(67),
	255:  uint8(68),
	256:  uint8(69),
	257:  uint8(70),
	258:  uint8(71),
	259:  uint8(72),
	260:  uint8(73),
	261:  uint8(74),
	262:  uint8(17),
	263:  uint8(75),
	264:  uint8(76),
	265:  uint8(77),
	266:  uint8(78),
	267:  uint8(79),
	268:  uint8(80),
	269:  uint8(81),
	270:  uint8(16),
	271:  uint8(82),
	272:  uint8(83),
	273:  uint8(84),
	274:  uint8(85),
	275:  uint8(86),
	276:  uint8(87),
	277:  uint8(88),
	278:  uint8(89),
	279:  uint8(90),
	280:  uint8(91),
	281:  uint8(92),
	282:  uint8(93),
	283:  uint8(16),
	284:  uint8(94),
	285:  uint8(95),
	286:  uint8(96),
	287:  uint8(16),
	288:  uint8(17),
	289:  uint8(17),
	290:  uint8(17),
	291:  uint8(97),
	292:  uint8(98),
	293:  uint8(99),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(17),
	305:  uint8(17),
	306:  uint8(17),
	307:  uint8(17),
	308:  uint8(100),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(17),
	325:  uint8(17),
	326:  uint8(101),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(17),
	361:  uint8(17),
	362:  uint8(102),
	363:  uint8(103),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(104),
	367:  uint8(105),
	368:  uint8(17),
	369:  uint8(17),
	370:  uint8(17),
	371:  uint8(17),
	372:  uint8(17),
	373:  uint8(17),
	374:  uint8(17),
	375:  uint8(17),
	376:  uint8(17),
	377:  uint8(17),
	378:  uint8(17),
	379:  uint8(17),
	380:  uint8(17),
	381:  uint8(17),
	382:  uint8(17),
	383:  uint8(17),
	384:  uint8(17),
	385:  uint8(17),
	386:  uint8(17),
	387:  uint8(17),
	388:  uint8(17),
	389:  uint8(17),
	390:  uint8(17),
	391:  uint8(106),
	392:  uint8(17),
	393:  uint8(17),
	394:  uint8(107),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(17),
	433:  uint8(108),
	434:  uint8(109),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(110),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(16),
	466:  uint8(16),
	467:  uint8(16),
	468:  uint8(111),
	469:  uint8(112),
	470:  uint8(113),
	471:  uint8(114),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(16),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(115),
	481:  uint8(116),
	482:  uint8(117),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(118),
	489:  uint8(119),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(120),
	495:  uint8(16),
	496:  uint8(16),
	497:  uint8(121),
	498:  uint8(16),
	499:  uint8(16),
	500:  uint8(16),
	501:  uint8(16),
	502:  uint8(16),
	503:  uint8(16),
	504:  uint8(16),
	505:  uint8(16),
	506:  uint8(16),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	512:  uint8(0),
	513:  uint8(0),
	514:  uint8(0),
	515:  uint8(0),
	516:  uint8(0),
	517:  uint8(0),
	518:  uint8(0),
	519:  uint8(0),
	520:  uint8(0),
	521:  uint8(0),
	522:  uint8(0),
	523:  uint8(0),
	524:  uint8(0),
	525:  uint8(0),
	526:  uint8(0),
	527:  uint8(0),
	528:  uint8(0),
	529:  uint8(0),
	530:  uint8(0),
	531:  uint8(0),
	532:  uint8(0),
	533:  uint8(0),
	534:  uint8(0),
	535:  uint8(0),
	536:  uint8(0),
	537:  uint8(0),
	538:  uint8(0),
	539:  uint8(0),
	540:  uint8(0),
	541:  uint8(0),
	542:  uint8(0),
	543:  uint8(0),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(0),
	577:  uint8(0),
	578:  uint8(0),
	579:  uint8(0),
	580:  uint8(0),
	581:  uint8(0),
	582:  uint8(0),
	583:  uint8(0),
	584:  uint8(254),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(7),
	588:  uint8(254),
	589:  uint8(255),
	590:  uint8(255),
	591:  uint8(7),
	592:  uint8(0),
	593:  uint8(0),
	594:  uint8(0),
	595:  uint8(0),
	596:  uint8(0),
	597:  uint8(4),
	598:  uint8(32),
	599:  uint8(4),
	600:  uint8(255),
	601:  uint8(255),
	602:  uint8(127),
	603:  uint8(255),
	604:  uint8(255),
	605:  uint8(255),
	606:  uint8(127),
	607:  uint8(255),
	608:  uint8(255),
	609:  uint8(255),
	610:  uint8(255),
	611:  uint8(255),
	612:  uint8(255),
	613:  uint8(255),
	614:  uint8(255),
	615:  uint8(255),
	616:  uint8(255),
	617:  uint8(255),
	618:  uint8(255),
	619:  uint8(255),
	620:  uint8(255),
	621:  uint8(255),
	622:  uint8(255),
	623:  uint8(255),
	624:  uint8(255),
	625:  uint8(255),
	626:  uint8(255),
	627:  uint8(255),
	628:  uint8(255),
	629:  uint8(255),
	630:  uint8(255),
	631:  uint8(255),
	632:  uint8(195),
	633:  uint8(255),
	634:  uint8(3),
	635:  uint8(0),
	636:  uint8(31),
	637:  uint8(80),
	638:  uint8(0),
	639:  uint8(0),
	640:  uint8(0),
	641:  uint8(0),
	642:  uint8(0),
	643:  uint8(0),
	644:  uint8(0),
	645:  uint8(0),
	646:  uint8(0),
	647:  uint8(0),
	648:  uint8(32),
	649:  uint8(0),
	650:  uint8(0),
	651:  uint8(0),
	652:  uint8(0),
	653:  uint8(0),
	654:  uint8(223),
	655:  uint8(188),
	656:  uint8(64),
	657:  uint8(215),
	658:  uint8(255),
	659:  uint8(255),
	660:  uint8(251),
	661:  uint8(255),
	662:  uint8(255),
	663:  uint8(255),
	664:  uint8(255),
	665:  uint8(255),
	666:  uint8(255),
	667:  uint8(255),
	668:  uint8(255),
	669:  uint8(255),
	670:  uint8(191),
	671:  uint8(255),
	672:  uint8(255),
	673:  uint8(255),
	674:  uint8(255),
	675:  uint8(255),
	676:  uint8(255),
	677:  uint8(255),
	678:  uint8(255),
	679:  uint8(255),
	680:  uint8(255),
	681:  uint8(255),
	682:  uint8(255),
	683:  uint8(255),
	684:  uint8(255),
	685:  uint8(255),
	686:  uint8(255),
	687:  uint8(255),
	688:  uint8(3),
	689:  uint8(252),
	690:  uint8(255),
	691:  uint8(255),
	692:  uint8(255),
	693:  uint8(255),
	694:  uint8(255),
	695:  uint8(255),
	696:  uint8(255),
	697:  uint8(255),
	698:  uint8(255),
	699:  uint8(255),
	700:  uint8(255),
	701:  uint8(255),
	702:  uint8(255),
	703:  uint8(255),
	704:  uint8(255),
	705:  uint8(255),
	706:  uint8(255),
	707:  uint8(255),
	708:  uint8(255),
	709:  uint8(255),
	710:  uint8(254),
	711:  uint8(255),
	712:  uint8(255),
	713:  uint8(255),
	714:  uint8(127),
	715:  uint8(2),
	716:  uint8(255),
	717:  uint8(255),
	718:  uint8(255),
	719:  uint8(255),
	720:  uint8(255),
	721:  uint8(1),
	722:  uint8(0),
	723:  uint8(0),
	724:  uint8(0),
	725:  uint8(0),
	726:  uint8(255),
	727:  uint8(191),
	728:  uint8(182),
	729:  uint8(0),
	730:  uint8(255),
	731:  uint8(255),
	732:  uint8(255),
	733:  uint8(135),
	734:  uint8(7),
	735:  uint8(0),
	736:  uint8(0),
	737:  uint8(0),
	738:  uint8(255),
	739:  uint8(7),
	740:  uint8(255),
	741:  uint8(255),
	742:  uint8(255),
	743:  uint8(255),
	744:  uint8(255),
	745:  uint8(255),
	746:  uint8(255),
	747:  uint8(254),
	748:  uint8(255),
	749:  uint8(195),
	750:  uint8(255),
	751:  uint8(255),
	752:  uint8(255),
	753:  uint8(255),
	754:  uint8(255),
	755:  uint8(255),
	756:  uint8(255),
	757:  uint8(255),
	758:  uint8(255),
	759:  uint8(255),
	760:  uint8(255),
	761:  uint8(255),
	762:  uint8(239),
	763:  uint8(31),
	764:  uint8(254),
	765:  uint8(225),
	766:  uint8(255),
	767:  uint8(159),
	768:  uint8(0),
	769:  uint8(0),
	770:  uint8(255),
	771:  uint8(255),
	772:  uint8(255),
	773:  uint8(255),
	774:  uint8(255),
	775:  uint8(255),
	776:  uint8(0),
	777:  uint8(224),
	778:  uint8(255),
	779:  uint8(255),
	780:  uint8(255),
	781:  uint8(255),
	782:  uint8(255),
	783:  uint8(255),
	784:  uint8(255),
	785:  uint8(255),
	786:  uint8(255),
	787:  uint8(255),
	788:  uint8(255),
	789:  uint8(255),
	790:  uint8(3),
	791:  uint8(0),
	792:  uint8(255),
	793:  uint8(255),
	794:  uint8(255),
	795:  uint8(255),
	796:  uint8(255),
	797:  uint8(7),
	798:  uint8(48),
	799:  uint8(4),
	800:  uint8(255),
	801:  uint8(255),
	802:  uint8(255),
	803:  uint8(252),
	804:  uint8(255),
	805:  uint8(31),
	806:  uint8(0),
	807:  uint8(0),
	808:  uint8(255),
	809:  uint8(255),
	810:  uint8(255),
	811:  uint8(1),
	812:  uint8(255),
	813:  uint8(7),
	814:  uint8(0),
	815:  uint8(0),
	816:  uint8(0),
	817:  uint8(0),
	818:  uint8(0),
	819:  uint8(0),
	820:  uint8(255),
	821:  uint8(255),
	822:  uint8(223),
	823:  uint8(63),
	824:  uint8(0),
	825:  uint8(0),
	826:  uint8(240),
	827:  uint8(255),
	828:  uint8(248),
	829:  uint8(3),
	830:  uint8(255),
	831:  uint8(255),
	832:  uint8(255),
	833:  uint8(255),
	834:  uint8(255),
	835:  uint8(255),
	836:  uint8(255),
	837:  uint8(255),
	838:  uint8(255),
	839:  uint8(239),
	840:  uint8(255),
	841:  uint8(223),
	842:  uint8(225),
	843:  uint8(255),
	844:  uint8(207),
	845:  uint8(255),
	846:  uint8(254),
	847:  uint8(255),
	848:  uint8(239),
	849:  uint8(159),
	850:  uint8(249),
	851:  uint8(255),
	852:  uint8(255),
	853:  uint8(253),
	854:  uint8(197),
	855:  uint8(227),
	856:  uint8(159),
	857:  uint8(89),
	858:  uint8(128),
	859:  uint8(176),
	860:  uint8(207),
	861:  uint8(255),
	862:  uint8(3),
	863:  uint8(16),
	864:  uint8(238),
	865:  uint8(135),
	866:  uint8(249),
	867:  uint8(255),
	868:  uint8(255),
	869:  uint8(253),
	870:  uint8(109),
	871:  uint8(195),
	872:  uint8(135),
	873:  uint8(25),
	874:  uint8(2),
	875:  uint8(94),
	876:  uint8(192),
	877:  uint8(255),
	878:  uint8(63),
	879:  uint8(0),
	880:  uint8(238),
	881:  uint8(191),
	882:  uint8(251),
	883:  uint8(255),
	884:  uint8(255),
	885:  uint8(253),
	886:  uint8(237),
	887:  uint8(227),
	888:  uint8(191),
	889:  uint8(27),
	890:  uint8(1),
	891:  uint8(0),
	892:  uint8(207),
	893:  uint8(255),
	894:  uint8(0),
	895:  uint8(30),
	896:  uint8(238),
	897:  uint8(159),
	898:  uint8(249),
	899:  uint8(255),
	900:  uint8(255),
	901:  uint8(253),
	902:  uint8(237),
	903:  uint8(227),
	904:  uint8(159),
	905:  uint8(25),
	906:  uint8(192),
	907:  uint8(176),
	908:  uint8(207),
	909:  uint8(255),
	910:  uint8(2),
	911:  uint8(0),
	912:  uint8(236),
	913:  uint8(199),
	914:  uint8(61),
	915:  uint8(214),
	916:  uint8(24),
	917:  uint8(199),
	918:  uint8(255),
	919:  uint8(195),
	920:  uint8(199),
	921:  uint8(29),
	922:  uint8(129),
	923:  uint8(0),
	924:  uint8(192),
	925:  uint8(255),
	926:  uint8(0),
	927:  uint8(0),
	928:  uint8(239),
	929:  uint8(223),
	930:  uint8(253),
	931:  uint8(255),
	932:  uint8(255),
	933:  uint8(253),
	934:  uint8(255),
	935:  uint8(227),
	936:  uint8(223),
	937:  uint8(29),
	938:  uint8(96),
	939:  uint8(7),
	940:  uint8(207),
	941:  uint8(255),
	942:  uint8(0),
	943:  uint8(0),
	944:  uint8(239),
	945:  uint8(223),
	946:  uint8(253),
	947:  uint8(255),
	948:  uint8(255),
	949:  uint8(253),
	950:  uint8(239),
	951:  uint8(227),
	952:  uint8(223),
	953:  uint8(29),
	954:  uint8(96),
	955:  uint8(64),
	956:  uint8(207),
	957:  uint8(255),
	958:  uint8(6),
	959:  uint8(0),
	960:  uint8(239),
	961:  uint8(223),
	962:  uint8(253),
	963:  uint8(255),
	964:  uint8(255),
	965:  uint8(255),
	966:  uint8(255),
	967:  uint8(231),
	968:  uint8(223),
	969:  uint8(93),
	970:  uint8(240),
	971:  uint8(128),
	972:  uint8(207),
	973:  uint8(255),
	974:  uint8(0),
	975:  uint8(252),
	976:  uint8(236),
	977:  uint8(255),
	978:  uint8(127),
	979:  uint8(252),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(251),
	983:  uint8(47),
	984:  uint8(127),
	985:  uint8(128),
	986:  uint8(95),
	987:  uint8(255),
	988:  uint8(192),
	989:  uint8(255),
	990:  uint8(12),
	991:  uint8(0),
	992:  uint8(254),
	993:  uint8(255),
	994:  uint8(255),
	995:  uint8(255),
	996:  uint8(255),
	997:  uint8(127),
	998:  uint8(255),
	999:  uint8(7),
	1000: uint8(63),
	1001: uint8(32),
	1002: uint8(255),
	1003: uint8(3),
	1004: uint8(0),
	1005: uint8(0),
	1006: uint8(0),
	1007: uint8(0),
	1008: uint8(214),
	1009: uint8(247),
	1010: uint8(255),
	1011: uint8(255),
	1012: uint8(175),
	1013: uint8(255),
	1014: uint8(255),
	1015: uint8(59),
	1016: uint8(95),
	1017: uint8(32),
	1018: uint8(255),
	1019: uint8(243),
	1020: uint8(0),
	1021: uint8(0),
	1022: uint8(0),
	1023: uint8(0),
	1024: uint8(1),
	1025: uint8(0),
	1026: uint8(0),
	1027: uint8(0),
	1028: uint8(255),
	1029: uint8(3),
	1030: uint8(0),
	1031: uint8(0),
	1032: uint8(255),
	1033: uint8(254),
	1034: uint8(255),
	1035: uint8(255),
	1036: uint8(255),
	1037: uint8(31),
	1038: uint8(254),
	1039: uint8(255),
	1040: uint8(3),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(254),
	1044: uint8(255),
	1045: uint8(255),
	1046: uint8(255),
	1047: uint8(31),
	1048: uint8(0),
	1049: uint8(0),
	1050: uint8(0),
	1051: uint8(0),
	1052: uint8(0),
	1053: uint8(0),
	1054: uint8(0),
	1055: uint8(0),
	1056: uint8(255),
	1057: uint8(255),
	1058: uint8(255),
	1059: uint8(255),
	1060: uint8(255),
	1061: uint8(255),
	1062: uint8(127),
	1063: uint8(249),
	1064: uint8(255),
	1065: uint8(3),
	1066: uint8(255),
	1067: uint8(255),
	1068: uint8(255),
	1069: uint8(255),
	1070: uint8(255),
	1071: uint8(255),
	1072: uint8(255),
	1073: uint8(255),
	1074: uint8(255),
	1075: uint8(63),
	1076: uint8(255),
	1077: uint8(255),
	1078: uint8(255),
	1079: uint8(255),
	1080: uint8(191),
	1081: uint8(32),
	1082: uint8(255),
	1083: uint8(255),
	1084: uint8(255),
	1085: uint8(255),
	1086: uint8(255),
	1087: uint8(247),
	1088: uint8(255),
	1089: uint8(255),
	1090: uint8(255),
	1091: uint8(255),
	1092: uint8(255),
	1093: uint8(255),
	1094: uint8(255),
	1095: uint8(255),
	1096: uint8(255),
	1097: uint8(61),
	1098: uint8(127),
	1099: uint8(61),
	1100: uint8(255),
	1101: uint8(255),
	1102: uint8(255),
	1103: uint8(255),
	1104: uint8(255),
	1105: uint8(61),
	1106: uint8(255),
	1107: uint8(255),
	1108: uint8(255),
	1109: uint8(255),
	1110: uint8(61),
	1111: uint8(127),
	1112: uint8(61),
	1113: uint8(255),
	1114: uint8(127),
	1115: uint8(255),
	1116: uint8(255),
	1117: uint8(255),
	1118: uint8(255),
	1119: uint8(255),
	1120: uint8(255),
	1121: uint8(255),
	1122: uint8(61),
	1123: uint8(255),
	1124: uint8(255),
	1125: uint8(255),
	1126: uint8(255),
	1127: uint8(255),
	1128: uint8(255),
	1129: uint8(255),
	1130: uint8(255),
	1131: uint8(7),
	1132: uint8(0),
	1133: uint8(0),
	1134: uint8(0),
	1135: uint8(0),
	1136: uint8(255),
	1137: uint8(255),
	1138: uint8(0),
	1139: uint8(0),
	1140: uint8(255),
	1141: uint8(255),
	1142: uint8(255),
	1143: uint8(255),
	1144: uint8(255),
	1145: uint8(255),
	1146: uint8(255),
	1147: uint8(255),
	1148: uint8(255),
	1149: uint8(255),
	1150: uint8(63),
	1151: uint8(63),
	1152: uint8(254),
	1153: uint8(255),
	1154: uint8(255),
	1155: uint8(255),
	1156: uint8(255),
	1157: uint8(255),
	1158: uint8(255),
	1159: uint8(255),
	1160: uint8(255),
	1161: uint8(255),
	1162: uint8(255),
	1163: uint8(255),
	1164: uint8(255),
	1165: uint8(255),
	1166: uint8(255),
	1167: uint8(255),
	1168: uint8(255),
	1169: uint8(255),
	1170: uint8(255),
	1171: uint8(255),
	1172: uint8(255),
	1173: uint8(255),
	1174: uint8(255),
	1175: uint8(255),
	1176: uint8(255),
	1177: uint8(255),
	1178: uint8(255),
	1179: uint8(255),
	1180: uint8(255),
	1181: uint8(255),
	1182: uint8(255),
	1183: uint8(255),
	1184: uint8(255),
	1185: uint8(255),
	1186: uint8(255),
	1187: uint8(255),
	1188: uint8(255),
	1189: uint8(255),
	1190: uint8(255),
	1191: uint8(255),
	1192: uint8(255),
	1193: uint8(255),
	1194: uint8(255),
	1195: uint8(255),
	1196: uint8(255),
	1197: uint8(159),
	1198: uint8(255),
	1199: uint8(255),
	1200: uint8(254),
	1201: uint8(255),
	1202: uint8(255),
	1203: uint8(7),
	1204: uint8(255),
	1205: uint8(255),
	1206: uint8(255),
	1207: uint8(255),
	1208: uint8(255),
	1209: uint8(255),
	1210: uint8(255),
	1211: uint8(255),
	1212: uint8(255),
	1213: uint8(199),
	1214: uint8(255),
	1215: uint8(1),
	1216: uint8(255),
	1217: uint8(223),
	1218: uint8(15),
	1219: uint8(0),
	1220: uint8(255),
	1221: uint8(255),
	1222: uint8(15),
	1223: uint8(0),
	1224: uint8(255),
	1225: uint8(255),
	1226: uint8(15),
	1227: uint8(0),
	1228: uint8(255),
	1229: uint8(223),
	1230: uint8(13),
	1231: uint8(0),
	1232: uint8(255),
	1233: uint8(255),
	1234: uint8(255),
	1235: uint8(255),
	1236: uint8(255),
	1237: uint8(255),
	1238: uint8(207),
	1239: uint8(255),
	1240: uint8(255),
	1241: uint8(1),
	1242: uint8(128),
	1243: uint8(16),
	1244: uint8(255),
	1245: uint8(3),
	1246: uint8(0),
	1247: uint8(0),
	1248: uint8(0),
	1249: uint8(0),
	1250: uint8(255),
	1251: uint8(3),
	1252: uint8(255),
	1253: uint8(255),
	1254: uint8(255),
	1255: uint8(255),
	1256: uint8(255),
	1257: uint8(255),
	1258: uint8(255),
	1259: uint8(255),
	1260: uint8(255),
	1261: uint8(255),
	1262: uint8(255),
	1263: uint8(1),
	1264: uint8(255),
	1265: uint8(255),
	1266: uint8(255),
	1267: uint8(255),
	1268: uint8(255),
	1269: uint8(7),
	1270: uint8(255),
	1271: uint8(255),
	1272: uint8(255),
	1273: uint8(255),
	1274: uint8(255),
	1275: uint8(255),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(63),
	1279: uint8(0),
	1280: uint8(255),
	1281: uint8(255),
	1282: uint8(255),
	1283: uint8(127),
	1284: uint8(255),
	1285: uint8(15),
	1286: uint8(255),
	1287: uint8(1),
	1288: uint8(192),
	1289: uint8(255),
	1290: uint8(255),
	1291: uint8(255),
	1292: uint8(255),
	1293: uint8(63),
	1294: uint8(31),
	1295: uint8(0),
	1296: uint8(255),
	1297: uint8(255),
	1298: uint8(255),
	1299: uint8(255),
	1300: uint8(255),
	1301: uint8(15),
	1302: uint8(255),
	1303: uint8(255),
	1304: uint8(255),
	1305: uint8(3),
	1306: uint8(255),
	1307: uint8(3),
	1308: uint8(0),
	1309: uint8(0),
	1310: uint8(0),
	1311: uint8(0),
	1312: uint8(255),
	1313: uint8(255),
	1314: uint8(255),
	1315: uint8(15),
	1316: uint8(255),
	1317: uint8(255),
	1318: uint8(255),
	1319: uint8(255),
	1320: uint8(255),
	1321: uint8(255),
	1322: uint8(255),
	1323: uint8(127),
	1324: uint8(254),
	1325: uint8(255),
	1326: uint8(31),
	1327: uint8(0),
	1328: uint8(255),
	1329: uint8(3),
	1330: uint8(255),
	1331: uint8(3),
	1332: uint8(128),
	1333: uint8(0),
	1334: uint8(0),
	1335: uint8(0),
	1336: uint8(0),
	1337: uint8(0),
	1338: uint8(0),
	1339: uint8(0),
	1340: uint8(0),
	1341: uint8(0),
	1342: uint8(0),
	1343: uint8(0),
	1344: uint8(255),
	1345: uint8(255),
	1346: uint8(255),
	1347: uint8(255),
	1348: uint8(255),
	1349: uint8(255),
	1350: uint8(239),
	1351: uint8(255),
	1352: uint8(239),
	1353: uint8(15),
	1354: uint8(255),
	1355: uint8(3),
	1356: uint8(0),
	1357: uint8(0),
	1358: uint8(0),
	1359: uint8(0),
	1360: uint8(255),
	1361: uint8(255),
	1362: uint8(255),
	1363: uint8(255),
	1364: uint8(255),
	1365: uint8(243),
	1366: uint8(255),
	1367: uint8(255),
	1368: uint8(255),
	1369: uint8(255),
	1370: uint8(255),
	1371: uint8(255),
	1372: uint8(191),
	1373: uint8(255),
	1374: uint8(3),
	1375: uint8(0),
	1376: uint8(255),
	1377: uint8(255),
	1378: uint8(255),
	1379: uint8(255),
	1380: uint8(255),
	1381: uint8(255),
	1382: uint8(127),
	1383: uint8(0),
	1384: uint8(255),
	1385: uint8(227),
	1386: uint8(255),
	1387: uint8(255),
	1388: uint8(255),
	1389: uint8(255),
	1390: uint8(255),
	1391: uint8(63),
	1392: uint8(255),
	1393: uint8(1),
	1394: uint8(255),
	1395: uint8(255),
	1396: uint8(255),
	1397: uint8(255),
	1398: uint8(255),
	1399: uint8(231),
	1400: uint8(0),
	1401: uint8(0),
	1402: uint8(0),
	1403: uint8(0),
	1404: uint8(0),
	1405: uint8(222),
	1406: uint8(111),
	1407: uint8(4),
	1408: uint8(255),
	1409: uint8(255),
	1410: uint8(255),
	1411: uint8(255),
	1412: uint8(255),
	1413: uint8(255),
	1414: uint8(255),
	1415: uint8(255),
	1416: uint8(255),
	1417: uint8(255),
	1418: uint8(255),
	1419: uint8(255),
	1420: uint8(255),
	1421: uint8(255),
	1422: uint8(255),
	1423: uint8(255),
	1424: uint8(255),
	1425: uint8(255),
	1426: uint8(255),
	1427: uint8(255),
	1428: uint8(255),
	1429: uint8(255),
	1430: uint8(255),
	1431: uint8(255),
	1432: uint8(0),
	1433: uint8(0),
	1434: uint8(0),
	1435: uint8(0),
	1436: uint8(128),
	1437: uint8(255),
	1438: uint8(31),
	1439: uint8(0),
	1440: uint8(255),
	1441: uint8(255),
	1442: uint8(63),
	1443: uint8(63),
	1444: uint8(255),
	1445: uint8(255),
	1446: uint8(255),
	1447: uint8(255),
	1448: uint8(63),
	1449: uint8(63),
	1450: uint8(255),
	1451: uint8(170),
	1452: uint8(255),
	1453: uint8(255),
	1454: uint8(255),
	1455: uint8(63),
	1456: uint8(255),
	1457: uint8(255),
	1458: uint8(255),
	1459: uint8(255),
	1460: uint8(255),
	1461: uint8(255),
	1462: uint8(223),
	1463: uint8(95),
	1464: uint8(220),
	1465: uint8(31),
	1466: uint8(207),
	1467: uint8(15),
	1468: uint8(255),
	1469: uint8(31),
	1470: uint8(220),
	1471: uint8(31),
	1472: uint8(0),
	1473: uint8(0),
	1474: uint8(0),
	1475: uint8(0),
	1476: uint8(0),
	1477: uint8(0),
	1478: uint8(0),
	1479: uint8(0),
	1480: uint8(0),
	1481: uint8(0),
	1482: uint8(0),
	1483: uint8(0),
	1484: uint8(0),
	1485: uint8(0),
	1486: uint8(2),
	1487: uint8(128),
	1488: uint8(0),
	1489: uint8(0),
	1490: uint8(255),
	1491: uint8(31),
	1492: uint8(0),
	1493: uint8(0),
	1494: uint8(0),
	1495: uint8(0),
	1496: uint8(0),
	1497: uint8(0),
	1498: uint8(0),
	1499: uint8(0),
	1500: uint8(0),
	1501: uint8(0),
	1502: uint8(0),
	1503: uint8(0),
	1504: uint8(132),
	1505: uint8(252),
	1506: uint8(47),
	1507: uint8(62),
	1508: uint8(80),
	1509: uint8(189),
	1510: uint8(255),
	1511: uint8(243),
	1512: uint8(224),
	1513: uint8(67),
	1514: uint8(0),
	1515: uint8(0),
	1516: uint8(255),
	1517: uint8(255),
	1518: uint8(255),
	1519: uint8(255),
	1520: uint8(255),
	1521: uint8(1),
	1522: uint8(0),
	1523: uint8(0),
	1524: uint8(0),
	1525: uint8(0),
	1526: uint8(0),
	1527: uint8(0),
	1528: uint8(0),
	1529: uint8(0),
	1530: uint8(0),
	1531: uint8(0),
	1532: uint8(0),
	1533: uint8(0),
	1534: uint8(0),
	1535: uint8(0),
	1536: uint8(0),
	1537: uint8(0),
	1538: uint8(0),
	1539: uint8(0),
	1540: uint8(0),
	1541: uint8(0),
	1542: uint8(0),
	1543: uint8(0),
	1544: uint8(0),
	1545: uint8(0),
	1546: uint8(0),
	1547: uint8(0),
	1548: uint8(0),
	1549: uint8(0),
	1550: uint8(0),
	1551: uint8(0),
	1552: uint8(0),
	1553: uint8(0),
	1554: uint8(0),
	1555: uint8(0),
	1556: uint8(0),
	1557: uint8(0),
	1558: uint8(192),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(255),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(3),
	1566: uint8(0),
	1567: uint8(0),
	1568: uint8(255),
	1569: uint8(255),
	1570: uint8(255),
	1571: uint8(255),
	1572: uint8(255),
	1573: uint8(127),
	1574: uint8(255),
	1575: uint8(255),
	1576: uint8(255),
	1577: uint8(255),
	1578: uint8(255),
	1579: uint8(127),
	1580: uint8(255),
	1581: uint8(255),
	1582: uint8(255),
	1583: uint8(255),
	1584: uint8(255),
	1585: uint8(255),
	1586: uint8(255),
	1587: uint8(255),
	1588: uint8(255),
	1589: uint8(255),
	1590: uint8(255),
	1591: uint8(255),
	1592: uint8(255),
	1593: uint8(255),
	1594: uint8(255),
	1595: uint8(255),
	1596: uint8(31),
	1597: uint8(120),
	1598: uint8(12),
	1599: uint8(0),
	1600: uint8(255),
	1601: uint8(255),
	1602: uint8(255),
	1603: uint8(255),
	1604: uint8(191),
	1605: uint8(32),
	1606: uint8(255),
	1607: uint8(255),
	1608: uint8(255),
	1609: uint8(255),
	1610: uint8(255),
	1611: uint8(255),
	1612: uint8(255),
	1613: uint8(128),
	1614: uint8(0),
	1615: uint8(0),
	1616: uint8(255),
	1617: uint8(255),
	1618: uint8(127),
	1619: uint8(0),
	1620: uint8(127),
	1621: uint8(127),
	1622: uint8(127),
	1623: uint8(127),
	1624: uint8(127),
	1625: uint8(127),
	1626: uint8(127),
	1627: uint8(127),
	1628: uint8(255),
	1629: uint8(255),
	1630: uint8(255),
	1631: uint8(255),
	1632: uint8(0),
	1633: uint8(0),
	1634: uint8(0),
	1635: uint8(0),
	1636: uint8(0),
	1637: uint8(128),
	1638: uint8(0),
	1639: uint8(0),
	1640: uint8(0),
	1641: uint8(0),
	1642: uint8(0),
	1643: uint8(0),
	1644: uint8(0),
	1645: uint8(0),
	1646: uint8(0),
	1647: uint8(0),
	1648: uint8(0),
	1649: uint8(0),
	1650: uint8(0),
	1651: uint8(0),
	1652: uint8(0),
	1653: uint8(0),
	1654: uint8(0),
	1655: uint8(0),
	1656: uint8(0),
	1657: uint8(0),
	1658: uint8(0),
	1659: uint8(0),
	1660: uint8(0),
	1661: uint8(0),
	1662: uint8(0),
	1663: uint8(0),
	1664: uint8(224),
	1665: uint8(0),
	1666: uint8(0),
	1667: uint8(0),
	1668: uint8(254),
	1669: uint8(3),
	1670: uint8(62),
	1671: uint8(31),
	1672: uint8(254),
	1673: uint8(255),
	1674: uint8(255),
	1675: uint8(255),
	1676: uint8(255),
	1677: uint8(255),
	1678: uint8(255),
	1679: uint8(255),
	1680: uint8(255),
	1681: uint8(255),
	1682: uint8(127),
	1683: uint8(224),
	1684: uint8(254),
	1685: uint8(255),
	1686: uint8(255),
	1687: uint8(255),
	1688: uint8(255),
	1689: uint8(255),
	1690: uint8(255),
	1691: uint8(255),
	1692: uint8(255),
	1693: uint8(255),
	1694: uint8(255),
	1695: uint8(247),
	1696: uint8(224),
	1697: uint8(255),
	1698: uint8(255),
	1699: uint8(255),
	1700: uint8(255),
	1701: uint8(255),
	1702: uint8(254),
	1703: uint8(255),
	1704: uint8(255),
	1705: uint8(255),
	1706: uint8(255),
	1707: uint8(255),
	1708: uint8(255),
	1709: uint8(255),
	1710: uint8(255),
	1711: uint8(255),
	1712: uint8(255),
	1713: uint8(127),
	1714: uint8(0),
	1715: uint8(0),
	1716: uint8(255),
	1717: uint8(255),
	1718: uint8(255),
	1719: uint8(7),
	1720: uint8(0),
	1721: uint8(0),
	1722: uint8(0),
	1723: uint8(0),
	1724: uint8(0),
	1725: uint8(0),
	1726: uint8(255),
	1727: uint8(255),
	1728: uint8(255),
	1729: uint8(255),
	1730: uint8(255),
	1731: uint8(255),
	1732: uint8(255),
	1733: uint8(255),
	1734: uint8(255),
	1735: uint8(255),
	1736: uint8(255),
	1737: uint8(255),
	1738: uint8(255),
	1739: uint8(255),
	1740: uint8(255),
	1741: uint8(255),
	1742: uint8(255),
	1743: uint8(255),
	1744: uint8(255),
	1745: uint8(255),
	1746: uint8(255),
	1747: uint8(255),
	1748: uint8(255),
	1749: uint8(255),
	1750: uint8(63),
	1751: uint8(0),
	1752: uint8(0),
	1753: uint8(0),
	1754: uint8(0),
	1755: uint8(0),
	1756: uint8(0),
	1757: uint8(0),
	1758: uint8(0),
	1759: uint8(0),
	1760: uint8(255),
	1761: uint8(255),
	1762: uint8(255),
	1763: uint8(255),
	1764: uint8(255),
	1765: uint8(255),
	1766: uint8(255),
	1767: uint8(255),
	1768: uint8(255),
	1769: uint8(255),
	1770: uint8(255),
	1771: uint8(255),
	1772: uint8(255),
	1773: uint8(255),
	1774: uint8(255),
	1775: uint8(255),
	1776: uint8(255),
	1777: uint8(255),
	1778: uint8(255),
	1779: uint8(255),
	1780: uint8(255),
	1781: uint8(255),
	1782: uint8(255),
	1783: uint8(255),
	1784: uint8(255),
	1785: uint8(255),
	1786: uint8(255),
	1787: uint8(255),
	1788: uint8(255),
	1789: uint8(255),
	1790: uint8(0),
	1791: uint8(0),
	1792: uint8(255),
	1793: uint8(255),
	1794: uint8(255),
	1795: uint8(255),
	1796: uint8(255),
	1797: uint8(255),
	1798: uint8(255),
	1799: uint8(255),
	1800: uint8(255),
	1801: uint8(255),
	1802: uint8(255),
	1803: uint8(255),
	1804: uint8(255),
	1805: uint8(255),
	1806: uint8(255),
	1807: uint8(255),
	1808: uint8(255),
	1809: uint8(31),
	1810: uint8(0),
	1811: uint8(0),
	1812: uint8(0),
	1813: uint8(0),
	1814: uint8(0),
	1815: uint8(0),
	1816: uint8(0),
	1817: uint8(0),
	1818: uint8(255),
	1819: uint8(255),
	1820: uint8(255),
	1821: uint8(255),
	1822: uint8(255),
	1823: uint8(63),
	1824: uint8(255),
	1825: uint8(31),
	1826: uint8(255),
	1827: uint8(255),
	1828: uint8(255),
	1829: uint8(15),
	1830: uint8(0),
	1831: uint8(0),
	1832: uint8(255),
	1833: uint8(255),
	1834: uint8(255),
	1835: uint8(255),
	1836: uint8(255),
	1837: uint8(127),
	1838: uint8(240),
	1839: uint8(143),
	1840: uint8(255),
	1841: uint8(255),
	1842: uint8(255),
	1843: uint8(255),
	1844: uint8(255),
	1845: uint8(255),
	1846: uint8(255),
	1847: uint8(255),
	1848: uint8(255),
	1849: uint8(255),
	1850: uint8(255),
	1851: uint8(255),
	1852: uint8(255),
	1853: uint8(255),
	1854: uint8(0),
	1855: uint8(0),
	1856: uint8(0),
	1857: uint8(0),
	1858: uint8(128),
	1859: uint8(255),
	1860: uint8(252),
	1861: uint8(255),
	1862: uint8(255),
	1863: uint8(255),
	1864: uint8(255),
	1865: uint8(255),
	1866: uint8(255),
	1867: uint8(255),
	1868: uint8(255),
	1869: uint8(255),
	1870: uint8(255),
	1871: uint8(255),
	1872: uint8(255),
	1873: uint8(249),
	1874: uint8(255),
	1875: uint8(255),
	1876: uint8(255),
	1877: uint8(255),
	1878: uint8(255),
	1879: uint8(255),
	1880: uint8(124),
	1881: uint8(0),
	1882: uint8(0),
	1883: uint8(0),
	1884: uint8(0),
	1885: uint8(0),
	1886: uint8(128),
	1887: uint8(255),
	1888: uint8(191),
	1889: uint8(255),
	1890: uint8(255),
	1891: uint8(255),
	1892: uint8(255),
	1893: uint8(0),
	1894: uint8(0),
	1895: uint8(0),
	1896: uint8(255),
	1897: uint8(255),
	1898: uint8(255),
	1899: uint8(255),
	1900: uint8(255),
	1901: uint8(255),
	1902: uint8(15),
	1903: uint8(0),
	1904: uint8(255),
	1905: uint8(255),
	1906: uint8(255),
	1907: uint8(255),
	1908: uint8(255),
	1909: uint8(255),
	1910: uint8(255),
	1911: uint8(255),
	1912: uint8(47),
	1913: uint8(0),
	1914: uint8(255),
	1915: uint8(3),
	1916: uint8(0),
	1917: uint8(0),
	1918: uint8(252),
	1919: uint8(232),
	1920: uint8(255),
	1921: uint8(255),
	1922: uint8(255),
	1923: uint8(255),
	1924: uint8(255),
	1925: uint8(7),
	1926: uint8(255),
	1927: uint8(255),
	1928: uint8(255),
	1929: uint8(255),
	1930: uint8(7),
	1931: uint8(0),
	1932: uint8(255),
	1933: uint8(255),
	1934: uint8(255),
	1935: uint8(31),
	1936: uint8(255),
	1937: uint8(255),
	1938: uint8(255),
	1939: uint8(255),
	1940: uint8(255),
	1941: uint8(255),
	1942: uint8(247),
	1943: uint8(255),
	1944: uint8(0),
	1945: uint8(128),
	1946: uint8(255),
	1947: uint8(3),
	1948: uint8(255),
	1949: uint8(255),
	1950: uint8(255),
	1951: uint8(127),
	1952: uint8(255),
	1953: uint8(255),
	1954: uint8(255),
	1955: uint8(255),
	1956: uint8(255),
	1957: uint8(255),
	1958: uint8(127),
	1959: uint8(0),
	1960: uint8(255),
	1961: uint8(63),
	1962: uint8(255),
	1963: uint8(3),
	1964: uint8(255),
	1965: uint8(255),
	1966: uint8(127),
	1967: uint8(252),
	1968: uint8(255),
	1969: uint8(255),
	1970: uint8(255),
	1971: uint8(255),
	1972: uint8(255),
	1973: uint8(255),
	1974: uint8(255),
	1975: uint8(127),
	1976: uint8(5),
	1977: uint8(0),
	1978: uint8(0),
	1979: uint8(56),
	1980: uint8(255),
	1981: uint8(255),
	1982: uint8(60),
	1983: uint8(0),
	1984: uint8(126),
	1985: uint8(126),
	1986: uint8(126),
	1987: uint8(0),
	1988: uint8(127),
	1989: uint8(127),
	1990: uint8(255),
	1991: uint8(255),
	1992: uint8(255),
	1993: uint8(255),
	1994: uint8(255),
	1995: uint8(247),
	1996: uint8(255),
	1997: uint8(0),
	1998: uint8(255),
	1999: uint8(255),
	2000: uint8(255),
	2001: uint8(255),
	2002: uint8(255),
	2003: uint8(255),
	2004: uint8(255),
	2005: uint8(255),
	2006: uint8(255),
	2007: uint8(255),
	2008: uint8(255),
	2009: uint8(255),
	2010: uint8(255),
	2011: uint8(255),
	2012: uint8(255),
	2013: uint8(7),
	2014: uint8(255),
	2015: uint8(3),
	2016: uint8(255),
	2017: uint8(255),
	2018: uint8(255),
	2019: uint8(255),
	2020: uint8(255),
	2021: uint8(255),
	2022: uint8(255),
	2023: uint8(255),
	2024: uint8(255),
	2025: uint8(255),
	2026: uint8(255),
	2027: uint8(255),
	2028: uint8(255),
	2029: uint8(255),
	2030: uint8(255),
	2031: uint8(255),
	2032: uint8(255),
	2033: uint8(255),
	2034: uint8(255),
	2035: uint8(255),
	2036: uint8(15),
	2037: uint8(0),
	2038: uint8(255),
	2039: uint8(255),
	2040: uint8(127),
	2041: uint8(248),
	2042: uint8(255),
	2043: uint8(255),
	2044: uint8(255),
	2045: uint8(255),
	2046: uint8(255),
	2047: uint8(15),
	2048: uint8(255),
	2049: uint8(255),
	2050: uint8(255),
	2051: uint8(255),
	2052: uint8(255),
	2053: uint8(255),
	2054: uint8(255),
	2055: uint8(255),
	2056: uint8(255),
	2057: uint8(255),
	2058: uint8(255),
	2059: uint8(255),
	2060: uint8(255),
	2061: uint8(63),
	2062: uint8(255),
	2063: uint8(255),
	2064: uint8(255),
	2065: uint8(255),
	2066: uint8(255),
	2067: uint8(255),
	2068: uint8(255),
	2069: uint8(255),
	2070: uint8(255),
	2071: uint8(255),
	2072: uint8(255),
	2073: uint8(255),
	2074: uint8(255),
	2075: uint8(3),
	2076: uint8(0),
	2077: uint8(0),
	2078: uint8(0),
	2079: uint8(0),
	2080: uint8(127),
	2081: uint8(0),
	2082: uint8(248),
	2083: uint8(224),
	2084: uint8(255),
	2085: uint8(253),
	2086: uint8(127),
	2087: uint8(95),
	2088: uint8(219),
	2089: uint8(255),
	2090: uint8(255),
	2091: uint8(255),
	2092: uint8(255),
	2093: uint8(255),
	2094: uint8(255),
	2095: uint8(255),
	2096: uint8(255),
	2097: uint8(255),
	2098: uint8(255),
	2099: uint8(255),
	2100: uint8(255),
	2101: uint8(255),
	2102: uint8(3),
	2103: uint8(0),
	2104: uint8(0),
	2105: uint8(0),
	2106: uint8(248),
	2107: uint8(255),
	2108: uint8(255),
	2109: uint8(255),
	2110: uint8(255),
	2111: uint8(255),
	2112: uint8(255),
	2113: uint8(255),
	2114: uint8(255),
	2115: uint8(255),
	2116: uint8(255),
	2117: uint8(255),
	2118: uint8(255),
	2119: uint8(63),
	2120: uint8(0),
	2121: uint8(0),
	2122: uint8(255),
	2123: uint8(255),
	2124: uint8(255),
	2125: uint8(255),
	2126: uint8(255),
	2127: uint8(255),
	2128: uint8(255),
	2129: uint8(255),
	2130: uint8(252),
	2131: uint8(255),
	2132: uint8(255),
	2133: uint8(255),
	2134: uint8(255),
	2135: uint8(255),
	2136: uint8(255),
	2137: uint8(0),
	2138: uint8(0),
	2139: uint8(0),
	2140: uint8(0),
	2141: uint8(0),
	2142: uint8(255),
	2143: uint8(15),
	2144: uint8(0),
	2145: uint8(0),
	2146: uint8(0),
	2147: uint8(0),
	2148: uint8(0),
	2149: uint8(0),
	2150: uint8(0),
	2151: uint8(0),
	2152: uint8(0),
	2153: uint8(0),
	2154: uint8(0),
	2155: uint8(0),
	2156: uint8(0),
	2157: uint8(0),
	2158: uint8(223),
	2159: uint8(255),
	2160: uint8(255),
	2161: uint8(255),
	2162: uint8(255),
	2163: uint8(255),
	2164: uint8(255),
	2165: uint8(255),
	2166: uint8(255),
	2167: uint8(255),
	2168: uint8(255),
	2169: uint8(255),
	2170: uint8(255),
	2171: uint8(255),
	2172: uint8(255),
	2173: uint8(255),
	2174: uint8(255),
	2175: uint8(31),
	2176: uint8(0),
	2177: uint8(0),
	2178: uint8(255),
	2179: uint8(3),
	2180: uint8(254),
	2181: uint8(255),
	2182: uint8(255),
	2183: uint8(7),
	2184: uint8(254),
	2185: uint8(255),
	2186: uint8(255),
	2187: uint8(7),
	2188: uint8(192),
	2189: uint8(255),
	2190: uint8(255),
	2191: uint8(255),
	2192: uint8(255),
	2193: uint8(255),
	2194: uint8(255),
	2195: uint8(255),
	2196: uint8(255),
	2197: uint8(255),
	2198: uint8(255),
	2199: uint8(127),
	2200: uint8(252),
	2201: uint8(252),
	2202: uint8(252),
	2203: uint8(28),
	2204: uint8(0),
	2205: uint8(0),
	2206: uint8(0),
	2207: uint8(0),
	2208: uint8(255),
	2209: uint8(239),
	2210: uint8(255),
	2211: uint8(255),
	2212: uint8(127),
	2213: uint8(255),
	2214: uint8(255),
	2215: uint8(183),
	2216: uint8(255),
	2217: uint8(63),
	2218: uint8(255),
	2219: uint8(63),
	2220: uint8(0),
	2221: uint8(0),
	2222: uint8(0),
	2223: uint8(0),
	2224: uint8(255),
	2225: uint8(255),
	2226: uint8(255),
	2227: uint8(255),
	2228: uint8(255),
	2229: uint8(255),
	2230: uint8(255),
	2231: uint8(255),
	2232: uint8(255),
	2233: uint8(255),
	2234: uint8(255),
	2235: uint8(255),
	2236: uint8(255),
	2237: uint8(255),
	2238: uint8(255),
	2239: uint8(7),
	2240: uint8(0),
	2241: uint8(0),
	2242: uint8(0),
	2243: uint8(0),
	2244: uint8(0),
	2245: uint8(0),
	2246: uint8(0),
	2247: uint8(0),
	2248: uint8(255),
	2249: uint8(255),
	2250: uint8(255),
	2251: uint8(255),
	2252: uint8(255),
	2253: uint8(255),
	2254: uint8(31),
	2255: uint8(0),
	2256: uint8(0),
	2257: uint8(0),
	2258: uint8(0),
	2259: uint8(0),
	2260: uint8(0),
	2261: uint8(0),
	2262: uint8(0),
	2263: uint8(0),
	2264: uint8(0),
	2265: uint8(0),
	2266: uint8(0),
	2267: uint8(0),
	2268: uint8(0),
	2269: uint8(0),
	2270: uint8(0),
	2271: uint8(0),
	2272: uint8(0),
	2273: uint8(0),
	2274: uint8(0),
	2275: uint8(0),
	2276: uint8(0),
	2277: uint8(0),
	2278: uint8(0),
	2279: uint8(0),
	2280: uint8(0),
	2281: uint8(0),
	2282: uint8(0),
	2283: uint8(0),
	2284: uint8(0),
	2285: uint8(0),
	2286: uint8(0),
	2287: uint8(0),
	2288: uint8(255),
	2289: uint8(255),
	2290: uint8(255),
	2291: uint8(31),
	2292: uint8(255),
	2293: uint8(255),
	2294: uint8(255),
	2295: uint8(255),
	2296: uint8(255),
	2297: uint8(255),
	2298: uint8(1),
	2299: uint8(0),
	2300: uint8(0),
	2301: uint8(0),
	2302: uint8(0),
	2303: uint8(0),
	2304: uint8(255),
	2305: uint8(255),
	2306: uint8(255),
	2307: uint8(255),
	2308: uint8(0),
	2309: uint8(224),
	2310: uint8(255),
	2311: uint8(255),
	2312: uint8(255),
	2313: uint8(7),
	2314: uint8(255),
	2315: uint8(255),
	2316: uint8(255),
	2317: uint8(255),
	2318: uint8(255),
	2319: uint8(7),
	2320: uint8(255),
	2321: uint8(255),
	2322: uint8(255),
	2323: uint8(63),
	2324: uint8(255),
	2325: uint8(255),
	2326: uint8(255),
	2327: uint8(255),
	2328: uint8(15),
	2329: uint8(255),
	2330: uint8(62),
	2331: uint8(0),
	2332: uint8(0),
	2333: uint8(0),
	2334: uint8(0),
	2335: uint8(0),
	2336: uint8(255),
	2337: uint8(255),
	2338: uint8(255),
	2339: uint8(255),
	2340: uint8(255),
	2341: uint8(255),
	2342: uint8(255),
	2343: uint8(255),
	2344: uint8(255),
	2345: uint8(255),
	2346: uint8(255),
	2347: uint8(255),
	2348: uint8(255),
	2349: uint8(255),
	2350: uint8(255),
	2351: uint8(255),
	2352: uint8(255),
	2353: uint8(255),
	2354: uint8(255),
	2355: uint8(63),
	2356: uint8(255),
	2357: uint8(3),
	2358: uint8(255),
	2359: uint8(255),
	2360: uint8(255),
	2361: uint8(255),
	2362: uint8(15),
	2363: uint8(255),
	2364: uint8(255),
	2365: uint8(255),
	2366: uint8(255),
	2367: uint8(15),
	2368: uint8(255),
	2369: uint8(255),
	2370: uint8(255),
	2371: uint8(255),
	2372: uint8(255),
	2373: uint8(0),
	2374: uint8(255),
	2375: uint8(255),
	2376: uint8(255),
	2377: uint8(255),
	2378: uint8(255),
	2379: uint8(255),
	2380: uint8(15),
	2381: uint8(0),
	2382: uint8(0),
	2383: uint8(0),
	2384: uint8(0),
	2385: uint8(0),
	2386: uint8(0),
	2387: uint8(0),
	2388: uint8(0),
	2389: uint8(0),
	2390: uint8(0),
	2391: uint8(0),
	2392: uint8(0),
	2393: uint8(0),
	2394: uint8(0),
	2395: uint8(0),
	2396: uint8(0),
	2397: uint8(0),
	2398: uint8(0),
	2399: uint8(0),
	2400: uint8(255),
	2401: uint8(255),
	2402: uint8(255),
	2403: uint8(255),
	2404: uint8(255),
	2405: uint8(255),
	2406: uint8(127),
	2407: uint8(0),
	2408: uint8(255),
	2409: uint8(255),
	2410: uint8(63),
	2411: uint8(0),
	2412: uint8(255),
	2413: uint8(0),
	2414: uint8(0),
	2415: uint8(0),
	2416: uint8(0),
	2417: uint8(0),
	2418: uint8(0),
	2419: uint8(0),
	2420: uint8(0),
	2421: uint8(0),
	2422: uint8(0),
	2423: uint8(0),
	2424: uint8(0),
	2425: uint8(0),
	2426: uint8(0),
	2427: uint8(0),
	2428: uint8(0),
	2429: uint8(0),
	2430: uint8(0),
	2431: uint8(0),
	2432: uint8(63),
	2433: uint8(253),
	2434: uint8(255),
	2435: uint8(255),
	2436: uint8(255),
	2437: uint8(255),
	2438: uint8(191),
	2439: uint8(145),
	2440: uint8(255),
	2441: uint8(255),
	2442: uint8(63),
	2443: uint8(0),
	2444: uint8(255),
	2445: uint8(255),
	2446: uint8(127),
	2447: uint8(0),
	2448: uint8(255),
	2449: uint8(255),
	2450: uint8(255),
	2451: uint8(127),
	2452: uint8(0),
	2453: uint8(0),
	2454: uint8(0),
	2455: uint8(0),
	2456: uint8(0),
	2457: uint8(0),
	2458: uint8(0),
	2459: uint8(0),
	2460: uint8(255),
	2461: uint8(255),
	2462: uint8(55),
	2463: uint8(0),
	2464: uint8(255),
	2465: uint8(255),
	2466: uint8(63),
	2467: uint8(0),
	2468: uint8(255),
	2469: uint8(255),
	2470: uint8(255),
	2471: uint8(3),
	2472: uint8(0),
	2473: uint8(0),
	2474: uint8(0),
	2475: uint8(0),
	2476: uint8(0),
	2477: uint8(0),
	2478: uint8(0),
	2479: uint8(0),
	2480: uint8(255),
	2481: uint8(255),
	2482: uint8(255),
	2483: uint8(255),
	2484: uint8(255),
	2485: uint8(255),
	2486: uint8(255),
	2487: uint8(192),
	2488: uint8(0),
	2489: uint8(0),
	2490: uint8(0),
	2491: uint8(0),
	2492: uint8(0),
	2493: uint8(0),
	2494: uint8(0),
	2495: uint8(0),
	2496: uint8(111),
	2497: uint8(240),
	2498: uint8(239),
	2499: uint8(254),
	2500: uint8(255),
	2501: uint8(255),
	2502: uint8(63),
	2503: uint8(0),
	2504: uint8(0),
	2505: uint8(0),
	2506: uint8(0),
	2507: uint8(0),
	2508: uint8(255),
	2509: uint8(255),
	2510: uint8(255),
	2511: uint8(31),
	2512: uint8(255),
	2513: uint8(255),
	2514: uint8(255),
	2515: uint8(31),
	2516: uint8(0),
	2517: uint8(0),
	2518: uint8(0),
	2519: uint8(0),
	2520: uint8(255),
	2521: uint8(254),
	2522: uint8(255),
	2523: uint8(255),
	2524: uint8(31),
	2525: uint8(0),
	2526: uint8(0),
	2527: uint8(0),
	2528: uint8(255),
	2529: uint8(255),
	2530: uint8(255),
	2531: uint8(255),
	2532: uint8(255),
	2533: uint8(255),
	2534: uint8(63),
	2535: uint8(0),
	2536: uint8(255),
	2537: uint8(255),
	2538: uint8(63),
	2539: uint8(0),
	2540: uint8(255),
	2541: uint8(255),
	2542: uint8(7),
	2543: uint8(0),
	2544: uint8(255),
	2545: uint8(255),
	2546: uint8(3),
	2547: uint8(0),
	2548: uint8(0),
	2549: uint8(0),
	2550: uint8(0),
	2551: uint8(0),
	2552: uint8(0),
	2553: uint8(0),
	2554: uint8(0),
	2555: uint8(0),
	2556: uint8(0),
	2557: uint8(0),
	2558: uint8(0),
	2559: uint8(0),
	2560: uint8(255),
	2561: uint8(255),
	2562: uint8(255),
	2563: uint8(255),
	2564: uint8(255),
	2565: uint8(255),
	2566: uint8(255),
	2567: uint8(255),
	2568: uint8(255),
	2569: uint8(1),
	2570: uint8(0),
	2571: uint8(0),
	2572: uint8(0),
	2573: uint8(0),
	2574: uint8(0),
	2575: uint8(0),
	2576: uint8(255),
	2577: uint8(255),
	2578: uint8(255),
	2579: uint8(255),
	2580: uint8(255),
	2581: uint8(255),
	2582: uint8(7),
	2583: uint8(0),
	2584: uint8(255),
	2585: uint8(255),
	2586: uint8(255),
	2587: uint8(255),
	2588: uint8(255),
	2589: uint8(255),
	2590: uint8(7),
	2591: uint8(0),
	2592: uint8(255),
	2593: uint8(255),
	2594: uint8(255),
	2595: uint8(255),
	2596: uint8(255),
	2597: uint8(0),
	2598: uint8(255),
	2599: uint8(3),
	2600: uint8(0),
	2601: uint8(0),
	2602: uint8(0),
	2603: uint8(0),
	2604: uint8(0),
	2605: uint8(0),
	2606: uint8(0),
	2607: uint8(0),
	2608: uint8(0),
	2609: uint8(0),
	2610: uint8(0),
	2611: uint8(0),
	2612: uint8(0),
	2613: uint8(0),
	2614: uint8(0),
	2615: uint8(0),
	2616: uint8(0),
	2617: uint8(0),
	2618: uint8(0),
	2619: uint8(0),
	2620: uint8(0),
	2621: uint8(0),
	2622: uint8(0),
	2623: uint8(0),
	2624: uint8(255),
	2625: uint8(255),
	2626: uint8(255),
	2627: uint8(31),
	2628: uint8(128),
	2629: uint8(0),
	2630: uint8(255),
	2631: uint8(255),
	2632: uint8(63),
	2633: uint8(0),
	2634: uint8(0),
	2635: uint8(0),
	2636: uint8(0),
	2637: uint8(0),
	2638: uint8(0),
	2639: uint8(0),
	2640: uint8(0),
	2641: uint8(0),
	2642: uint8(0),
	2643: uint8(0),
	2644: uint8(0),
	2645: uint8(0),
	2646: uint8(0),
	2647: uint8(0),
	2648: uint8(0),
	2649: uint8(0),
	2650: uint8(0),
	2651: uint8(0),
	2652: uint8(255),
	2653: uint8(255),
	2654: uint8(127),
	2655: uint8(0),
	2656: uint8(255),
	2657: uint8(255),
	2658: uint8(255),
	2659: uint8(255),
	2660: uint8(255),
	2661: uint8(255),
	2662: uint8(255),
	2663: uint8(255),
	2664: uint8(63),
	2665: uint8(0),
	2666: uint8(0),
	2667: uint8(0),
	2668: uint8(192),
	2669: uint8(255),
	2670: uint8(0),
	2671: uint8(0),
	2672: uint8(252),
	2673: uint8(255),
	2674: uint8(255),
	2675: uint8(255),
	2676: uint8(255),
	2677: uint8(255),
	2678: uint8(255),
	2679: uint8(1),
	2680: uint8(0),
	2681: uint8(0),
	2682: uint8(255),
	2683: uint8(255),
	2684: uint8(255),
	2685: uint8(1),
	2686: uint8(255),
	2687: uint8(3),
	2688: uint8(255),
	2689: uint8(255),
	2690: uint8(255),
	2691: uint8(255),
	2692: uint8(255),
	2693: uint8(255),
	2694: uint8(199),
	2695: uint8(255),
	2696: uint8(112),
	2697: uint8(0),
	2698: uint8(255),
	2699: uint8(255),
	2700: uint8(255),
	2701: uint8(255),
	2702: uint8(71),
	2703: uint8(0),
	2704: uint8(255),
	2705: uint8(255),
	2706: uint8(255),
	2707: uint8(255),
	2708: uint8(255),
	2709: uint8(255),
	2710: uint8(255),
	2711: uint8(255),
	2712: uint8(30),
	2713: uint8(0),
	2714: uint8(255),
	2715: uint8(23),
	2716: uint8(0),
	2717: uint8(0),
	2718: uint8(0),
	2719: uint8(0),
	2720: uint8(255),
	2721: uint8(255),
	2722: uint8(251),
	2723: uint8(255),
	2724: uint8(255),
	2725: uint8(255),
	2726: uint8(159),
	2727: uint8(64),
	2728: uint8(0),
	2729: uint8(0),
	2730: uint8(0),
	2731: uint8(0),
	2732: uint8(0),
	2733: uint8(0),
	2734: uint8(0),
	2735: uint8(0),
	2736: uint8(127),
	2737: uint8(189),
	2738: uint8(255),
	2739: uint8(191),
	2740: uint8(255),
	2741: uint8(1),
	2742: uint8(255),
	2743: uint8(255),
	2744: uint8(255),
	2745: uint8(255),
	2746: uint8(255),
	2747: uint8(255),
	2748: uint8(255),
	2749: uint8(1),
	2750: uint8(255),
	2751: uint8(3),
	2752: uint8(239),
	2753: uint8(159),
	2754: uint8(249),
	2755: uint8(255),
	2756: uint8(255),
	2757: uint8(253),
	2758: uint8(237),
	2759: uint8(227),
	2760: uint8(159),
	2761: uint8(25),
	2762: uint8(129),
	2763: uint8(224),
	2764: uint8(15),
	2765: uint8(0),
	2766: uint8(0),
	2767: uint8(0),
	2768: uint8(0),
	2769: uint8(0),
	2770: uint8(0),
	2771: uint8(0),
	2772: uint8(0),
	2773: uint8(0),
	2774: uint8(0),
	2775: uint8(0),
	2776: uint8(0),
	2777: uint8(0),
	2778: uint8(0),
	2779: uint8(0),
	2780: uint8(0),
	2781: uint8(0),
	2782: uint8(0),
	2783: uint8(0),
	2784: uint8(255),
	2785: uint8(255),
	2786: uint8(255),
	2787: uint8(255),
	2788: uint8(255),
	2789: uint8(255),
	2790: uint8(255),
	2791: uint8(255),
	2792: uint8(187),
	2793: uint8(7),
	2794: uint8(255),
	2795: uint8(131),
	2796: uint8(0),
	2797: uint8(0),
	2798: uint8(0),
	2799: uint8(0),
	2800: uint8(255),
	2801: uint8(255),
	2802: uint8(255),
	2803: uint8(255),
	2804: uint8(255),
	2805: uint8(255),
	2806: uint8(255),
	2807: uint8(255),
	2808: uint8(179),
	2809: uint8(0),
	2810: uint8(255),
	2811: uint8(3),
	2812: uint8(0),
	2813: uint8(0),
	2814: uint8(0),
	2815: uint8(0),
	2816: uint8(0),
	2817: uint8(0),
	2818: uint8(0),
	2819: uint8(0),
	2820: uint8(0),
	2821: uint8(0),
	2822: uint8(0),
	2823: uint8(0),
	2824: uint8(0),
	2825: uint8(0),
	2826: uint8(0),
	2827: uint8(0),
	2828: uint8(0),
	2829: uint8(0),
	2830: uint8(0),
	2831: uint8(0),
	2832: uint8(255),
	2833: uint8(255),
	2834: uint8(255),
	2835: uint8(255),
	2836: uint8(255),
	2837: uint8(255),
	2838: uint8(63),
	2839: uint8(127),
	2840: uint8(0),
	2841: uint8(0),
	2842: uint8(0),
	2843: uint8(63),
	2844: uint8(0),
	2845: uint8(0),
	2846: uint8(0),
	2847: uint8(0),
	2848: uint8(255),
	2849: uint8(255),
	2850: uint8(255),
	2851: uint8(255),
	2852: uint8(255),
	2853: uint8(255),
	2854: uint8(255),
	2855: uint8(127),
	2856: uint8(17),
	2857: uint8(0),
	2858: uint8(255),
	2859: uint8(3),
	2860: uint8(0),
	2861: uint8(0),
	2862: uint8(0),
	2863: uint8(0),
	2864: uint8(255),
	2865: uint8(255),
	2866: uint8(255),
	2867: uint8(255),
	2868: uint8(255),
	2869: uint8(255),
	2870: uint8(63),
	2871: uint8(1),
	2872: uint8(255),
	2873: uint8(3),
	2874: uint8(0),
	2875: uint8(0),
	2876: uint8(0),
	2877: uint8(0),
	2878: uint8(0),
	2879: uint8(0),
	2880: uint8(255),
	2881: uint8(255),
	2882: uint8(255),
	2883: uint8(231),
	2884: uint8(255),
	2885: uint8(7),
	2886: uint8(255),
	2887: uint8(3),
	2888: uint8(0),
	2889: uint8(0),
	2890: uint8(0),
	2891: uint8(0),
	2892: uint8(0),
	2893: uint8(0),
	2894: uint8(0),
	2895: uint8(0),
	2896: uint8(0),
	2897: uint8(0),
	2898: uint8(0),
	2899: uint8(0),
	2900: uint8(0),
	2901: uint8(0),
	2902: uint8(0),
	2903: uint8(0),
	2904: uint8(0),
	2905: uint8(0),
	2906: uint8(0),
	2907: uint8(0),
	2908: uint8(0),
	2909: uint8(0),
	2910: uint8(0),
	2911: uint8(0),
	2912: uint8(255),
	2913: uint8(255),
	2914: uint8(255),
	2915: uint8(255),
	2916: uint8(255),
	2917: uint8(255),
	2918: uint8(255),
	2919: uint8(1),
	2920: uint8(0),
	2921: uint8(0),
	2922: uint8(0),
	2923: uint8(0),
	2924: uint8(0),
	2925: uint8(0),
	2926: uint8(0),
	2927: uint8(0),
	2928: uint8(0),
	2929: uint8(0),
	2930: uint8(0),
	2931: uint8(0),
	2932: uint8(255),
	2933: uint8(255),
	2934: uint8(255),
	2935: uint8(255),
	2936: uint8(255),
	2937: uint8(255),
	2938: uint8(255),
	2939: uint8(255),
	2940: uint8(255),
	2941: uint8(3),
	2942: uint8(0),
	2943: uint8(128),
	2944: uint8(0),
	2945: uint8(0),
	2946: uint8(0),
	2947: uint8(0),
	2948: uint8(0),
	2949: uint8(0),
	2950: uint8(0),
	2951: uint8(0),
	2952: uint8(0),
	2953: uint8(0),
	2954: uint8(0),
	2955: uint8(0),
	2956: uint8(0),
	2957: uint8(0),
	2958: uint8(0),
	2959: uint8(0),
	2960: uint8(0),
	2961: uint8(0),
	2962: uint8(0),
	2963: uint8(0),
	2964: uint8(255),
	2965: uint8(252),
	2966: uint8(255),
	2967: uint8(255),
	2968: uint8(255),
	2969: uint8(255),
	2970: uint8(255),
	2971: uint8(252),
	2972: uint8(26),
	2973: uint8(0),
	2974: uint8(0),
	2975: uint8(0),
	2976: uint8(255),
	2977: uint8(255),
	2978: uint8(255),
	2979: uint8(255),
	2980: uint8(255),
	2981: uint8(255),
	2982: uint8(231),
	2983: uint8(127),
	2984: uint8(0),
	2985: uint8(0),
	2986: uint8(255),
	2987: uint8(255),
	2988: uint8(255),
	2989: uint8(255),
	2990: uint8(255),
	2991: uint8(255),
	2992: uint8(255),
	2993: uint8(255),
	2994: uint8(255),
	2995: uint8(32),
	2996: uint8(0),
	2997: uint8(0),
	2998: uint8(0),
	2999: uint8(0),
	3000: uint8(255),
	3001: uint8(255),
	3002: uint8(255),
	3003: uint8(255),
	3004: uint8(255),
	3005: uint8(255),
	3006: uint8(255),
	3007: uint8(1),
	3008: uint8(255),
	3009: uint8(253),
	3010: uint8(255),
	3011: uint8(255),
	3012: uint8(255),
	3013: uint8(255),
	3014: uint8(127),
	3015: uint8(127),
	3016: uint8(1),
	3017: uint8(0),
	3018: uint8(255),
	3019: uint8(3),
	3020: uint8(0),
	3021: uint8(0),
	3022: uint8(252),
	3023: uint8(255),
	3024: uint8(255),
	3025: uint8(255),
	3026: uint8(252),
	3027: uint8(255),
	3028: uint8(255),
	3029: uint8(254),
	3030: uint8(127),
	3031: uint8(0),
	3032: uint8(0),
	3033: uint8(0),
	3034: uint8(0),
	3035: uint8(0),
	3036: uint8(0),
	3037: uint8(0),
	3038: uint8(0),
	3039: uint8(0),
	3040: uint8(127),
	3041: uint8(251),
	3042: uint8(255),
	3043: uint8(255),
	3044: uint8(255),
	3045: uint8(255),
	3046: uint8(127),
	3047: uint8(180),
	3048: uint8(203),
	3049: uint8(0),
	3050: uint8(255),
	3051: uint8(3),
	3052: uint8(191),
	3053: uint8(253),
	3054: uint8(255),
	3055: uint8(255),
	3056: uint8(255),
	3057: uint8(127),
	3058: uint8(123),
	3059: uint8(1),
	3060: uint8(255),
	3061: uint8(3),
	3062: uint8(0),
	3063: uint8(0),
	3064: uint8(0),
	3065: uint8(0),
	3066: uint8(0),
	3067: uint8(0),
	3068: uint8(0),
	3069: uint8(0),
	3070: uint8(0),
	3071: uint8(0),
	3072: uint8(0),
	3073: uint8(0),
	3074: uint8(0),
	3075: uint8(0),
	3076: uint8(0),
	3077: uint8(0),
	3078: uint8(0),
	3079: uint8(0),
	3080: uint8(0),
	3081: uint8(0),
	3082: uint8(0),
	3083: uint8(0),
	3084: uint8(0),
	3085: uint8(0),
	3086: uint8(0),
	3087: uint8(0),
	3088: uint8(0),
	3089: uint8(0),
	3090: uint8(0),
	3091: uint8(0),
	3092: uint8(0),
	3093: uint8(0),
	3094: uint8(0),
	3095: uint8(0),
	3096: uint8(0),
	3097: uint8(0),
	3098: uint8(0),
	3099: uint8(0),
	3100: uint8(255),
	3101: uint8(255),
	3102: uint8(127),
	3103: uint8(0),
	3104: uint8(255),
	3105: uint8(255),
	3106: uint8(255),
	3107: uint8(255),
	3108: uint8(255),
	3109: uint8(255),
	3110: uint8(255),
	3111: uint8(255),
	3112: uint8(255),
	3113: uint8(255),
	3114: uint8(255),
	3115: uint8(255),
	3116: uint8(255),
	3117: uint8(255),
	3118: uint8(255),
	3119: uint8(255),
	3120: uint8(255),
	3121: uint8(255),
	3122: uint8(255),
	3123: uint8(3),
	3124: uint8(0),
	3125: uint8(0),
	3126: uint8(0),
	3127: uint8(0),
	3128: uint8(0),
	3129: uint8(0),
	3130: uint8(0),
	3131: uint8(0),
	3132: uint8(0),
	3133: uint8(0),
	3134: uint8(0),
	3135: uint8(0),
	3136: uint8(255),
	3137: uint8(255),
	3138: uint8(255),
	3139: uint8(255),
	3140: uint8(255),
	3141: uint8(255),
	3142: uint8(255),
	3143: uint8(255),
	3144: uint8(255),
	3145: uint8(255),
	3146: uint8(255),
	3147: uint8(255),
	3148: uint8(255),
	3149: uint8(127),
	3150: uint8(0),
	3151: uint8(0),
	3152: uint8(255),
	3153: uint8(255),
	3154: uint8(255),
	3155: uint8(255),
	3156: uint8(255),
	3157: uint8(255),
	3158: uint8(255),
	3159: uint8(255),
	3160: uint8(255),
	3161: uint8(255),
	3162: uint8(255),
	3163: uint8(255),
	3164: uint8(255),
	3165: uint8(255),
	3166: uint8(255),
	3167: uint8(255),
	3168: uint8(255),
	3169: uint8(255),
	3170: uint8(255),
	3171: uint8(255),
	3172: uint8(255),
	3173: uint8(255),
	3174: uint8(255),
	3175: uint8(255),
	3176: uint8(15),
	3177: uint8(0),
	3178: uint8(0),
	3179: uint8(0),
	3180: uint8(0),
	3181: uint8(0),
	3182: uint8(0),
	3183: uint8(0),
	3184: uint8(0),
	3185: uint8(0),
	3186: uint8(0),
	3187: uint8(0),
	3188: uint8(0),
	3189: uint8(0),
	3190: uint8(0),
	3191: uint8(0),
	3192: uint8(0),
	3193: uint8(0),
	3194: uint8(0),
	3195: uint8(0),
	3196: uint8(0),
	3197: uint8(0),
	3198: uint8(0),
	3199: uint8(0),
	3200: uint8(255),
	3201: uint8(255),
	3202: uint8(255),
	3203: uint8(255),
	3204: uint8(255),
	3205: uint8(127),
	3206: uint8(0),
	3207: uint8(0),
	3208: uint8(0),
	3209: uint8(0),
	3210: uint8(0),
	3211: uint8(0),
	3212: uint8(0),
	3213: uint8(0),
	3214: uint8(0),
	3215: uint8(0),
	3216: uint8(0),
	3217: uint8(0),
	3218: uint8(0),
	3219: uint8(0),
	3220: uint8(0),
	3221: uint8(0),
	3222: uint8(0),
	3223: uint8(0),
	3224: uint8(0),
	3225: uint8(0),
	3226: uint8(0),
	3227: uint8(0),
	3228: uint8(0),
	3229: uint8(0),
	3230: uint8(0),
	3231: uint8(0),
	3232: uint8(255),
	3233: uint8(255),
	3234: uint8(255),
	3235: uint8(255),
	3236: uint8(255),
	3237: uint8(255),
	3238: uint8(255),
	3239: uint8(255),
	3240: uint8(127),
	3241: uint8(0),
	3242: uint8(0),
	3243: uint8(0),
	3244: uint8(0),
	3245: uint8(0),
	3246: uint8(0),
	3247: uint8(0),
	3248: uint8(0),
	3249: uint8(0),
	3250: uint8(0),
	3251: uint8(0),
	3252: uint8(0),
	3253: uint8(0),
	3254: uint8(0),
	3255: uint8(0),
	3256: uint8(0),
	3257: uint8(0),
	3258: uint8(0),
	3259: uint8(0),
	3260: uint8(0),
	3261: uint8(0),
	3262: uint8(0),
	3263: uint8(0),
	3264: uint8(255),
	3265: uint8(255),
	3266: uint8(255),
	3267: uint8(255),
	3268: uint8(255),
	3269: uint8(255),
	3270: uint8(255),
	3271: uint8(1),
	3272: uint8(255),
	3273: uint8(255),
	3274: uint8(255),
	3275: uint8(127),
	3276: uint8(255),
	3277: uint8(3),
	3278: uint8(0),
	3279: uint8(0),
	3280: uint8(0),
	3281: uint8(0),
	3282: uint8(0),
	3283: uint8(0),
	3284: uint8(0),
	3285: uint8(0),
	3286: uint8(0),
	3287: uint8(0),
	3288: uint8(0),
	3289: uint8(0),
	3290: uint8(255),
	3291: uint8(255),
	3292: uint8(255),
	3293: uint8(63),
	3294: uint8(0),
	3295: uint8(0),
	3296: uint8(255),
	3297: uint8(255),
	3298: uint8(255),
	3299: uint8(255),
	3300: uint8(255),
	3301: uint8(255),
	3302: uint8(0),
	3303: uint8(0),
	3304: uint8(15),
	3305: uint8(0),
	3306: uint8(255),
	3307: uint8(3),
	3308: uint8(248),
	3309: uint8(255),
	3310: uint8(255),
	3311: uint8(224),
	3312: uint8(255),
	3313: uint8(255),
	3314: uint8(0),
	3315: uint8(0),
	3316: uint8(0),
	3317: uint8(0),
	3318: uint8(0),
	3319: uint8(0),
	3320: uint8(0),
	3321: uint8(0),
	3322: uint8(0),
	3323: uint8(0),
	3324: uint8(0),
	3325: uint8(0),
	3326: uint8(0),
	3327: uint8(0),
	3328: uint8(0),
	3329: uint8(0),
	3330: uint8(0),
	3331: uint8(0),
	3332: uint8(0),
	3333: uint8(0),
	3334: uint8(0),
	3335: uint8(0),
	3336: uint8(255),
	3337: uint8(255),
	3338: uint8(255),
	3339: uint8(255),
	3340: uint8(255),
	3341: uint8(255),
	3342: uint8(255),
	3343: uint8(255),
	3344: uint8(0),
	3345: uint8(0),
	3346: uint8(0),
	3347: uint8(0),
	3348: uint8(0),
	3349: uint8(0),
	3350: uint8(0),
	3351: uint8(0),
	3352: uint8(0),
	3353: uint8(0),
	3354: uint8(0),
	3355: uint8(0),
	3356: uint8(0),
	3357: uint8(0),
	3358: uint8(0),
	3359: uint8(0),
	3360: uint8(255),
	3361: uint8(255),
	3362: uint8(255),
	3363: uint8(255),
	3364: uint8(255),
	3365: uint8(255),
	3366: uint8(255),
	3367: uint8(255),
	3368: uint8(255),
	3369: uint8(135),
	3370: uint8(255),
	3371: uint8(255),
	3372: uint8(255),
	3373: uint8(255),
	3374: uint8(255),
	3375: uint8(255),
	3376: uint8(255),
	3377: uint8(128),
	3378: uint8(255),
	3379: uint8(255),
	3380: uint8(0),
	3381: uint8(0),
	3382: uint8(0),
	3383: uint8(0),
	3384: uint8(0),
	3385: uint8(0),
	3386: uint8(0),
	3387: uint8(0),
	3388: uint8(11),
	3389: uint8(0),
	3390: uint8(0),
	3391: uint8(0),
	3392: uint8(255),
	3393: uint8(255),
	3394: uint8(255),
	3395: uint8(255),
	3396: uint8(255),
	3397: uint8(255),
	3398: uint8(255),
	3399: uint8(255),
	3400: uint8(255),
	3401: uint8(255),
	3402: uint8(255),
	3403: uint8(255),
	3404: uint8(255),
	3405: uint8(255),
	3406: uint8(255),
	3407: uint8(255),
	3408: uint8(255),
	3409: uint8(255),
	3410: uint8(255),
	3411: uint8(255),
	3412: uint8(255),
	3413: uint8(255),
	3414: uint8(255),
	3415: uint8(255),
	3416: uint8(255),
	3417: uint8(255),
	3418: uint8(255),
	3419: uint8(255),
	3420: uint8(255),
	3421: uint8(255),
	3422: uint8(255),
	3423: uint8(0),
	3424: uint8(255),
	3425: uint8(255),
	3426: uint8(255),
	3427: uint8(255),
	3428: uint8(255),
	3429: uint8(255),
	3430: uint8(255),
	3431: uint8(255),
	3432: uint8(255),
	3433: uint8(255),
	3434: uint8(255),
	3435: uint8(255),
	3436: uint8(255),
	3437: uint8(255),
	3438: uint8(255),
	3439: uint8(255),
	3440: uint8(255),
	3441: uint8(255),
	3442: uint8(255),
	3443: uint8(255),
	3444: uint8(255),
	3445: uint8(255),
	3446: uint8(255),
	3447: uint8(255),
	3448: uint8(255),
	3449: uint8(255),
	3450: uint8(255),
	3451: uint8(255),
	3452: uint8(255),
	3453: uint8(255),
	3454: uint8(7),
	3455: uint8(0),
	3456: uint8(255),
	3457: uint8(255),
	3458: uint8(255),
	3459: uint8(127),
	3460: uint8(0),
	3461: uint8(0),
	3462: uint8(0),
	3463: uint8(0),
	3464: uint8(0),
	3465: uint8(0),
	3466: uint8(7),
	3467: uint8(0),
	3468: uint8(240),
	3469: uint8(0),
	3470: uint8(255),
	3471: uint8(255),
	3472: uint8(255),
	3473: uint8(255),
	3474: uint8(255),
	3475: uint8(255),
	3476: uint8(255),
	3477: uint8(255),
	3478: uint8(255),
	3479: uint8(255),
	3480: uint8(255),
	3481: uint8(255),
	3482: uint8(255),
	3483: uint8(255),
	3484: uint8(255),
	3485: uint8(255),
	3486: uint8(255),
	3487: uint8(255),
	3488: uint8(255),
	3489: uint8(255),
	3490: uint8(255),
	3491: uint8(255),
	3492: uint8(255),
	3493: uint8(255),
	3494: uint8(255),
	3495: uint8(255),
	3496: uint8(255),
	3497: uint8(255),
	3498: uint8(255),
	3499: uint8(255),
	3500: uint8(255),
	3501: uint8(255),
	3502: uint8(255),
	3503: uint8(255),
	3504: uint8(255),
	3505: uint8(255),
	3506: uint8(255),
	3507: uint8(255),
	3508: uint8(255),
	3509: uint8(255),
	3510: uint8(255),
	3511: uint8(255),
	3512: uint8(255),
	3513: uint8(255),
	3514: uint8(255),
	3515: uint8(255),
	3516: uint8(255),
	3517: uint8(255),
	3518: uint8(255),
	3519: uint8(15),
	3520: uint8(255),
	3521: uint8(255),
	3522: uint8(255),
	3523: uint8(255),
	3524: uint8(255),
	3525: uint8(255),
	3526: uint8(255),
	3527: uint8(255),
	3528: uint8(255),
	3529: uint8(255),
	3530: uint8(255),
	3531: uint8(255),
	3532: uint8(255),
	3533: uint8(7),
	3534: uint8(255),
	3535: uint8(31),
	3536: uint8(255),
	3537: uint8(1),
	3538: uint8(255),
	3539: uint8(67),
	3540: uint8(0),
	3541: uint8(0),
	3542: uint8(0),
	3543: uint8(0),
	3544: uint8(0),
	3545: uint8(0),
	3546: uint8(0),
	3547: uint8(0),
	3548: uint8(0),
	3549: uint8(0),
	3550: uint8(0),
	3551: uint8(0),
	3552: uint8(255),
	3553: uint8(255),
	3554: uint8(255),
	3555: uint8(255),
	3556: uint8(255),
	3557: uint8(255),
	3558: uint8(255),
	3559: uint8(255),
	3560: uint8(255),
	3561: uint8(255),
	3562: uint8(223),
	3563: uint8(255),
	3564: uint8(255),
	3565: uint8(255),
	3566: uint8(255),
	3567: uint8(255),
	3568: uint8(255),
	3569: uint8(255),
	3570: uint8(255),
	3571: uint8(223),
	3572: uint8(100),
	3573: uint8(222),
	3574: uint8(255),
	3575: uint8(235),
	3576: uint8(239),
	3577: uint8(255),
	3578: uint8(255),
	3579: uint8(255),
	3580: uint8(255),
	3581: uint8(255),
	3582: uint8(255),
	3583: uint8(255),
	3584: uint8(191),
	3585: uint8(231),
	3586: uint8(223),
	3587: uint8(223),
	3588: uint8(255),
	3589: uint8(255),
	3590: uint8(255),
	3591: uint8(123),
	3592: uint8(95),
	3593: uint8(252),
	3594: uint8(253),
	3595: uint8(255),
	3596: uint8(255),
	3597: uint8(255),
	3598: uint8(255),
	3599: uint8(255),
	3600: uint8(255),
	3601: uint8(255),
	3602: uint8(255),
	3603: uint8(255),
	3604: uint8(255),
	3605: uint8(255),
	3606: uint8(255),
	3607: uint8(255),
	3608: uint8(255),
	3609: uint8(255),
	3610: uint8(255),
	3611: uint8(255),
	3612: uint8(255),
	3613: uint8(255),
	3614: uint8(255),
	3615: uint8(255),
	3616: uint8(255),
	3617: uint8(255),
	3618: uint8(255),
	3619: uint8(255),
	3620: uint8(255),
	3621: uint8(255),
	3622: uint8(255),
	3623: uint8(255),
	3624: uint8(255),
	3625: uint8(255),
	3626: uint8(255),
	3627: uint8(255),
	3628: uint8(255),
	3629: uint8(255),
	3630: uint8(255),
	3631: uint8(255),
	3632: uint8(255),
	3633: uint8(255),
	3634: uint8(255),
	3635: uint8(255),
	3636: uint8(63),
	3637: uint8(255),
	3638: uint8(255),
	3639: uint8(255),
	3640: uint8(253),
	3641: uint8(255),
	3642: uint8(255),
	3643: uint8(247),
	3644: uint8(255),
	3645: uint8(255),
	3646: uint8(255),
	3647: uint8(247),
	3648: uint8(255),
	3649: uint8(255),
	3650: uint8(223),
	3651: uint8(255),
	3652: uint8(255),
	3653: uint8(255),
	3654: uint8(223),
	3655: uint8(255),
	3656: uint8(255),
	3657: uint8(127),
	3658: uint8(255),
	3659: uint8(255),
	3660: uint8(255),
	3661: uint8(127),
	3662: uint8(255),
	3663: uint8(255),
	3664: uint8(255),
	3665: uint8(253),
	3666: uint8(255),
	3667: uint8(255),
	3668: uint8(255),
	3669: uint8(253),
	3670: uint8(255),
	3671: uint8(255),
	3672: uint8(247),
	3673: uint8(207),
	3674: uint8(255),
	3675: uint8(255),
	3676: uint8(255),
	3677: uint8(255),
	3678: uint8(255),
	3679: uint8(255),
	3680: uint8(127),
	3681: uint8(255),
	3682: uint8(255),
	3683: uint8(249),
	3684: uint8(219),
	3685: uint8(7),
	3686: uint8(0),
	3687: uint8(0),
	3688: uint8(0),
	3689: uint8(0),
	3690: uint8(0),
	3691: uint8(0),
	3692: uint8(0),
	3693: uint8(0),
	3694: uint8(0),
	3695: uint8(0),
	3696: uint8(0),
	3697: uint8(0),
	3698: uint8(0),
	3699: uint8(0),
	3700: uint8(0),
	3701: uint8(0),
	3702: uint8(0),
	3703: uint8(0),
	3704: uint8(0),
	3705: uint8(0),
	3706: uint8(0),
	3707: uint8(0),
	3708: uint8(0),
	3709: uint8(0),
	3710: uint8(0),
	3711: uint8(0),
	3712: uint8(255),
	3713: uint8(255),
	3714: uint8(255),
	3715: uint8(255),
	3716: uint8(255),
	3717: uint8(31),
	3718: uint8(128),
	3719: uint8(63),
	3720: uint8(255),
	3721: uint8(67),
	3722: uint8(0),
	3723: uint8(0),
	3724: uint8(0),
	3725: uint8(0),
	3726: uint8(0),
	3727: uint8(0),
	3728: uint8(0),
	3729: uint8(0),
	3730: uint8(0),
	3731: uint8(0),
	3732: uint8(0),
	3733: uint8(0),
	3734: uint8(0),
	3735: uint8(0),
	3736: uint8(0),
	3737: uint8(0),
	3738: uint8(0),
	3739: uint8(0),
	3740: uint8(0),
	3741: uint8(0),
	3742: uint8(0),
	3743: uint8(0),
	3744: uint8(0),
	3745: uint8(0),
	3746: uint8(0),
	3747: uint8(0),
	3748: uint8(0),
	3749: uint8(0),
	3750: uint8(0),
	3751: uint8(0),
	3752: uint8(0),
	3753: uint8(0),
	3754: uint8(0),
	3755: uint8(0),
	3756: uint8(0),
	3757: uint8(0),
	3758: uint8(0),
	3759: uint8(0),
	3760: uint8(0),
	3761: uint8(0),
	3762: uint8(0),
	3763: uint8(0),
	3764: uint8(0),
	3765: uint8(0),
	3766: uint8(0),
	3767: uint8(0),
	3768: uint8(255),
	3769: uint8(255),
	3770: uint8(255),
	3771: uint8(255),
	3772: uint8(255),
	3773: uint8(15),
	3774: uint8(255),
	3775: uint8(3),
	3776: uint8(255),
	3777: uint8(255),
	3778: uint8(255),
	3779: uint8(255),
	3780: uint8(255),
	3781: uint8(255),
	3782: uint8(255),
	3783: uint8(255),
	3784: uint8(255),
	3785: uint8(255),
	3786: uint8(255),
	3787: uint8(255),
	3788: uint8(255),
	3789: uint8(255),
	3790: uint8(255),
	3791: uint8(255),
	3792: uint8(255),
	3793: uint8(255),
	3794: uint8(255),
	3795: uint8(255),
	3796: uint8(255),
	3797: uint8(255),
	3798: uint8(255),
	3799: uint8(255),
	3800: uint8(31),
	3801: uint8(0),
	3802: uint8(0),
	3803: uint8(0),
	3804: uint8(0),
	3805: uint8(0),
	3806: uint8(0),
	3807: uint8(0),
	3808: uint8(255),
	3809: uint8(255),
	3810: uint8(255),
	3811: uint8(255),
	3812: uint8(255),
	3813: uint8(255),
	3814: uint8(255),
	3815: uint8(255),
	3816: uint8(143),
	3817: uint8(8),
	3818: uint8(255),
	3819: uint8(3),
	3820: uint8(0),
	3821: uint8(0),
	3822: uint8(0),
	3823: uint8(0),
	3824: uint8(0),
	3825: uint8(0),
	3826: uint8(0),
	3827: uint8(0),
	3828: uint8(0),
	3829: uint8(0),
	3830: uint8(0),
	3831: uint8(0),
	3832: uint8(0),
	3833: uint8(0),
	3834: uint8(0),
	3835: uint8(0),
	3836: uint8(0),
	3837: uint8(0),
	3838: uint8(0),
	3839: uint8(0),
	3840: uint8(239),
	3841: uint8(255),
	3842: uint8(255),
	3843: uint8(255),
	3844: uint8(150),
	3845: uint8(254),
	3846: uint8(247),
	3847: uint8(10),
	3848: uint8(132),
	3849: uint8(234),
	3850: uint8(150),
	3851: uint8(170),
	3852: uint8(150),
	3853: uint8(247),
	3854: uint8(247),
	3855: uint8(94),
	3856: uint8(255),
	3857: uint8(251),
	3858: uint8(255),
	3859: uint8(15),
	3860: uint8(238),
	3861: uint8(251),
	3862: uint8(255),
	3863: uint8(15),
	3864: uint8(0),
	3865: uint8(0),
	3866: uint8(0),
	3867: uint8(0),
	3868: uint8(0),
	3869: uint8(0),
	3870: uint8(0),
	3871: uint8(0),
	3872: uint8(0),
	3873: uint8(0),
	3874: uint8(0),
	3875: uint8(0),
	3876: uint8(0),
	3877: uint8(0),
	3878: uint8(255),
	3879: uint8(255),
	3880: uint8(255),
	3881: uint8(3),
	3882: uint8(255),
	3883: uint8(255),
	3884: uint8(255),
	3885: uint8(3),
	3886: uint8(255),
	3887: uint8(255),
	3888: uint8(255),
	3889: uint8(3),
	3890: uint8(0),
	3891: uint8(0),
	3892: uint8(0),
	3893: uint8(0),
	3894: uint8(0),
	3895: uint8(0),
	3896: uint8(0),
	3897: uint8(0),
	3898: uint8(0),
	3899: uint8(0),
	3900: uint8(0),
	3901: uint8(0),
	3902: uint8(0),
	3903: uint8(0)}

func x_iswalpha(tls *TLS, wc Twint_t) (r int32) {
	if wc < uint32(0x20000) {
		return int32(_table3[uint32(int32(_table3[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)]) >> (wc & uint32(7)) & int32(1)
	}
	if wc < uint32(0x2fffe) {
		return int32(1)
	}
	return int32(0)
}

func x___iswalpha_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswalpha(tls, c)
}

func x_iswblank(tls *TLS, wc Twint_t) (r int32) {
	return x_isblank(tls, int32(wc))
}

func x___iswblank_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswblank(tls, c)
}

func x_iswcntrl(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(wc < uint32(32) || wc-Uint32FromInt32(0x7f) < uint32(33) || wc-Uint32FromInt32(0x2028) < uint32(2) || wc-Uint32FromInt32(0xfff9) < uint32(3))
}

func x___iswcntrl_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswcntrl(tls, c)
}

const m_WCTYPE_ALNUM = 1
const m_WCTYPE_ALPHA = 2
const m_WCTYPE_BLANK = 3
const m_WCTYPE_CNTRL = 4
const m_WCTYPE_DIGIT = 5
const m_WCTYPE_GRAPH = 6
const m_WCTYPE_LOWER = 7
const m_WCTYPE_PRINT = 8
const m_WCTYPE_PUNCT = 9
const m_WCTYPE_SPACE = 10
const m_WCTYPE_UPPER = 11
const m_WCTYPE_XDIGIT = 12

func x_iswctype(tls *TLS, wc Twint_t, type1 Twctype_t) (r int32) {
	switch type1 {
	case uint64(m_WCTYPE_ALNUM):
		return x_iswalnum(tls, wc)
	case uint64(m_WCTYPE_ALPHA):
		return x_iswalpha(tls, wc)
	case uint64(m_WCTYPE_BLANK):
		return x_iswblank(tls, wc)
	case uint64(m_WCTYPE_CNTRL):
		return x_iswcntrl(tls, wc)
	case uint64(m_WCTYPE_DIGIT):
		return BoolInt32(wc-uint32('0') < uint32(10))
	case uint64(m_WCTYPE_GRAPH):
		return x_iswgraph(tls, wc)
	case uint64(m_WCTYPE_LOWER):
		return x_iswlower(tls, wc)
	case uint64(m_WCTYPE_PRINT):
		return x_iswprint(tls, wc)
	case uint64(m_WCTYPE_PUNCT):
		return x_iswpunct(tls, wc)
	case uint64(m_WCTYPE_SPACE):
		return x_iswspace(tls, wc)
	case uint64(m_WCTYPE_UPPER):
		return x_iswupper(tls, wc)
	case uint64(m_WCTYPE_XDIGIT):
		return x_iswxdigit(tls, wc)
	}
	return int32(0)
}

func x_wctype(tls *TLS, s uintptr) (r Twctype_t) {
	var i int32
	var p uintptr
	i = int32(1)
	p = uintptr(unsafe.Pointer(&_names))
	for *(*int8)(unsafe.Pointer(p)) != 0 {
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(*(*int8)(unsafe.Pointer(p))) && !(x_strcmp(tls, s, p) != 0) {
			return uint64(i)
		}
		goto _1
	_1:
		i++
		p = p + UintptrFromInt32(6)
	}
	return uint64(0)
}

/* order must match! */
var _names = [73]int8{'a', 'l', 'n', 'u', 'm', 0, 'a', 'l', 'p', 'h', 'a', 0, 'b', 'l', 'a', 'n', 'k', 0, 'c', 'n', 't', 'r', 'l', 0, 'd', 'i', 'g', 'i', 't', 0, 'g', 'r', 'a', 'p', 'h', 0, 'l', 'o', 'w', 'e', 'r', 0, 'p', 'r', 'i', 'n', 't', 0, 'p', 'u', 'n', 'c', 't', 0, 's', 'p', 'a', 'c', 'e', 0, 'u', 'p', 'p', 'e', 'r', 0, 'x', 'd', 'i', 'g', 'i', 't'}

func x___iswctype_l(tls *TLS, c Twint_t, t Twctype_t, l Tlocale_t) (r int32) {
	return x_iswctype(tls, c, t)
}

func x___wctype_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctype_t) {
	return x_wctype(tls, s)
}

func x_iswdigit(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(wc-uint32('0') < uint32(10))
}

func x___iswdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswdigit(tls, c)
}

func x_iswgraph(tls *TLS, wc Twint_t) (r int32) {
	/* ISO C defines this function as: */
	return BoolInt32(!(x_iswspace(tls, wc) != 0) && x_iswprint(tls, wc) != 0)
}

func x___iswgraph_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswgraph(tls, c)
}

func x_iswlower(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(x_towupper(tls, wc) != wc)
}

func x___iswlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswlower(tls, c)
}

func x_iswprint(tls *TLS, wc Twint_t) (r int32) {
	if wc < uint32(0xff) {
		return BoolInt32((wc+uint32(1))&uint32(0x7f) >= uint32(0x21))
	}
	if wc < uint32(0x2028) || wc-uint32(0x202a) < uint32(Int32FromInt32(0xd800)-Int32FromInt32(0x202a)) || wc-uint32(0xe000) < uint32(Int32FromInt32(0xfff9)-Int32FromInt32(0xe000)) {
		return int32(1)
	}
	if wc-uint32(0xfffc) > uint32(Int32FromInt32(0x10ffff)-Int32FromInt32(0xfffc)) || wc&uint32(0xfffe) == uint32(0xfffe) {
		return int32(0)
	}
	return int32(1)
}

func x___iswprint_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswprint(tls, c)
}

var _table4 = [4000]uint8{
	0:    uint8(18),
	1:    uint8(16),
	2:    uint8(19),
	3:    uint8(20),
	4:    uint8(21),
	5:    uint8(22),
	6:    uint8(23),
	7:    uint8(24),
	8:    uint8(25),
	9:    uint8(26),
	10:   uint8(27),
	11:   uint8(28),
	12:   uint8(29),
	13:   uint8(30),
	14:   uint8(31),
	15:   uint8(32),
	16:   uint8(33),
	17:   uint8(16),
	18:   uint8(16),
	19:   uint8(34),
	20:   uint8(35),
	21:   uint8(16),
	22:   uint8(36),
	23:   uint8(37),
	24:   uint8(38),
	25:   uint8(39),
	26:   uint8(40),
	27:   uint8(41),
	28:   uint8(42),
	29:   uint8(43),
	30:   uint8(16),
	31:   uint8(44),
	32:   uint8(45),
	33:   uint8(46),
	34:   uint8(17),
	35:   uint8(17),
	36:   uint8(47),
	37:   uint8(17),
	38:   uint8(17),
	39:   uint8(17),
	40:   uint8(17),
	41:   uint8(17),
	42:   uint8(17),
	43:   uint8(48),
	44:   uint8(49),
	45:   uint8(50),
	46:   uint8(51),
	47:   uint8(52),
	48:   uint8(53),
	49:   uint8(54),
	50:   uint8(55),
	51:   uint8(17),
	52:   uint8(16),
	53:   uint8(16),
	54:   uint8(16),
	55:   uint8(16),
	56:   uint8(16),
	57:   uint8(16),
	58:   uint8(16),
	59:   uint8(16),
	60:   uint8(16),
	61:   uint8(16),
	62:   uint8(16),
	63:   uint8(16),
	64:   uint8(16),
	65:   uint8(16),
	66:   uint8(16),
	67:   uint8(16),
	68:   uint8(16),
	69:   uint8(16),
	70:   uint8(16),
	71:   uint8(16),
	72:   uint8(16),
	73:   uint8(16),
	74:   uint8(16),
	75:   uint8(16),
	76:   uint8(16),
	77:   uint8(56),
	78:   uint8(16),
	79:   uint8(16),
	80:   uint8(16),
	81:   uint8(16),
	82:   uint8(16),
	83:   uint8(16),
	84:   uint8(16),
	85:   uint8(16),
	86:   uint8(16),
	87:   uint8(16),
	88:   uint8(16),
	89:   uint8(16),
	90:   uint8(16),
	91:   uint8(16),
	92:   uint8(16),
	93:   uint8(16),
	94:   uint8(16),
	95:   uint8(16),
	96:   uint8(16),
	97:   uint8(16),
	98:   uint8(16),
	99:   uint8(16),
	100:  uint8(16),
	101:  uint8(16),
	102:  uint8(16),
	103:  uint8(16),
	104:  uint8(16),
	105:  uint8(16),
	106:  uint8(16),
	107:  uint8(16),
	108:  uint8(16),
	109:  uint8(16),
	110:  uint8(16),
	111:  uint8(16),
	112:  uint8(16),
	113:  uint8(16),
	114:  uint8(16),
	115:  uint8(16),
	116:  uint8(16),
	117:  uint8(16),
	118:  uint8(16),
	119:  uint8(16),
	120:  uint8(16),
	121:  uint8(16),
	122:  uint8(16),
	123:  uint8(16),
	124:  uint8(16),
	125:  uint8(16),
	126:  uint8(16),
	127:  uint8(16),
	128:  uint8(16),
	129:  uint8(16),
	130:  uint8(16),
	131:  uint8(16),
	132:  uint8(16),
	133:  uint8(16),
	134:  uint8(16),
	135:  uint8(16),
	136:  uint8(16),
	137:  uint8(16),
	138:  uint8(16),
	139:  uint8(16),
	140:  uint8(16),
	141:  uint8(16),
	142:  uint8(16),
	143:  uint8(16),
	144:  uint8(16),
	145:  uint8(16),
	146:  uint8(16),
	147:  uint8(16),
	148:  uint8(16),
	149:  uint8(16),
	150:  uint8(16),
	151:  uint8(16),
	152:  uint8(16),
	153:  uint8(16),
	154:  uint8(16),
	155:  uint8(16),
	156:  uint8(16),
	157:  uint8(16),
	158:  uint8(16),
	159:  uint8(16),
	160:  uint8(16),
	161:  uint8(16),
	162:  uint8(16),
	163:  uint8(16),
	164:  uint8(57),
	165:  uint8(16),
	166:  uint8(58),
	167:  uint8(59),
	168:  uint8(60),
	169:  uint8(61),
	170:  uint8(62),
	171:  uint8(63),
	172:  uint8(16),
	173:  uint8(16),
	174:  uint8(16),
	175:  uint8(16),
	176:  uint8(16),
	177:  uint8(16),
	178:  uint8(16),
	179:  uint8(16),
	180:  uint8(16),
	181:  uint8(16),
	182:  uint8(16),
	183:  uint8(16),
	184:  uint8(16),
	185:  uint8(16),
	186:  uint8(16),
	187:  uint8(16),
	188:  uint8(16),
	189:  uint8(16),
	190:  uint8(16),
	191:  uint8(16),
	192:  uint8(16),
	193:  uint8(16),
	194:  uint8(16),
	195:  uint8(16),
	196:  uint8(16),
	197:  uint8(16),
	198:  uint8(16),
	199:  uint8(16),
	200:  uint8(16),
	201:  uint8(16),
	202:  uint8(16),
	203:  uint8(16),
	204:  uint8(16),
	205:  uint8(16),
	206:  uint8(16),
	207:  uint8(16),
	208:  uint8(16),
	209:  uint8(16),
	210:  uint8(16),
	211:  uint8(16),
	212:  uint8(16),
	213:  uint8(16),
	214:  uint8(16),
	215:  uint8(16),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(64),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(65),
	249:  uint8(16),
	250:  uint8(16),
	251:  uint8(66),
	252:  uint8(16),
	253:  uint8(67),
	254:  uint8(68),
	255:  uint8(69),
	256:  uint8(16),
	257:  uint8(70),
	258:  uint8(71),
	259:  uint8(72),
	260:  uint8(16),
	261:  uint8(73),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(74),
	265:  uint8(75),
	266:  uint8(76),
	267:  uint8(77),
	268:  uint8(78),
	269:  uint8(16),
	270:  uint8(79),
	271:  uint8(80),
	272:  uint8(81),
	273:  uint8(82),
	274:  uint8(83),
	275:  uint8(84),
	276:  uint8(85),
	277:  uint8(86),
	278:  uint8(87),
	279:  uint8(88),
	280:  uint8(89),
	281:  uint8(90),
	282:  uint8(91),
	283:  uint8(16),
	284:  uint8(92),
	285:  uint8(93),
	286:  uint8(94),
	287:  uint8(95),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(96),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(97),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(98),
	363:  uint8(99),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(100),
	367:  uint8(101),
	368:  uint8(16),
	369:  uint8(16),
	370:  uint8(16),
	371:  uint8(16),
	372:  uint8(16),
	373:  uint8(16),
	374:  uint8(16),
	375:  uint8(16),
	376:  uint8(16),
	377:  uint8(16),
	378:  uint8(16),
	379:  uint8(16),
	380:  uint8(16),
	381:  uint8(16),
	382:  uint8(16),
	383:  uint8(16),
	384:  uint8(16),
	385:  uint8(16),
	386:  uint8(16),
	387:  uint8(16),
	388:  uint8(16),
	389:  uint8(16),
	390:  uint8(16),
	391:  uint8(16),
	392:  uint8(16),
	393:  uint8(16),
	394:  uint8(16),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(16),
	433:  uint8(16),
	434:  uint8(16),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(102),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(103),
	465:  uint8(104),
	466:  uint8(105),
	467:  uint8(106),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(107),
	471:  uint8(108),
	472:  uint8(17),
	473:  uint8(17),
	474:  uint8(109),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(16),
	481:  uint8(110),
	482:  uint8(111),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(112),
	489:  uint8(113),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(114),
	493:  uint8(115),
	494:  uint8(116),
	495:  uint8(16),
	496:  uint8(117),
	497:  uint8(118),
	498:  uint8(119),
	499:  uint8(17),
	500:  uint8(17),
	501:  uint8(17),
	502:  uint8(120),
	503:  uint8(121),
	504:  uint8(122),
	505:  uint8(123),
	506:  uint8(124),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	512:  uint8(0),
	513:  uint8(0),
	514:  uint8(0),
	515:  uint8(0),
	516:  uint8(0),
	517:  uint8(0),
	518:  uint8(0),
	519:  uint8(0),
	520:  uint8(0),
	521:  uint8(0),
	522:  uint8(0),
	523:  uint8(0),
	524:  uint8(0),
	525:  uint8(0),
	526:  uint8(0),
	527:  uint8(0),
	528:  uint8(0),
	529:  uint8(0),
	530:  uint8(0),
	531:  uint8(0),
	532:  uint8(0),
	533:  uint8(0),
	534:  uint8(0),
	535:  uint8(0),
	536:  uint8(0),
	537:  uint8(0),
	538:  uint8(0),
	539:  uint8(0),
	540:  uint8(0),
	541:  uint8(0),
	542:  uint8(0),
	543:  uint8(0),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(0),
	577:  uint8(0),
	578:  uint8(0),
	579:  uint8(0),
	580:  uint8(254),
	581:  uint8(255),
	582:  uint8(0),
	583:  uint8(252),
	584:  uint8(1),
	585:  uint8(0),
	586:  uint8(0),
	587:  uint8(248),
	588:  uint8(1),
	589:  uint8(0),
	590:  uint8(0),
	591:  uint8(120),
	592:  uint8(0),
	593:  uint8(0),
	594:  uint8(0),
	595:  uint8(0),
	596:  uint8(255),
	597:  uint8(251),
	598:  uint8(223),
	599:  uint8(251),
	600:  uint8(0),
	601:  uint8(0),
	602:  uint8(128),
	603:  uint8(0),
	604:  uint8(0),
	605:  uint8(0),
	606:  uint8(128),
	607:  uint8(0),
	608:  uint8(0),
	609:  uint8(0),
	610:  uint8(0),
	611:  uint8(0),
	612:  uint8(0),
	613:  uint8(0),
	614:  uint8(0),
	615:  uint8(0),
	616:  uint8(0),
	617:  uint8(0),
	618:  uint8(0),
	619:  uint8(0),
	620:  uint8(0),
	621:  uint8(0),
	622:  uint8(0),
	623:  uint8(0),
	624:  uint8(0),
	625:  uint8(0),
	626:  uint8(0),
	627:  uint8(0),
	628:  uint8(0),
	629:  uint8(0),
	630:  uint8(0),
	631:  uint8(0),
	632:  uint8(60),
	633:  uint8(0),
	634:  uint8(252),
	635:  uint8(255),
	636:  uint8(224),
	637:  uint8(175),
	638:  uint8(255),
	639:  uint8(255),
	640:  uint8(255),
	641:  uint8(255),
	642:  uint8(255),
	643:  uint8(255),
	644:  uint8(255),
	645:  uint8(255),
	646:  uint8(255),
	647:  uint8(255),
	648:  uint8(223),
	649:  uint8(255),
	650:  uint8(255),
	651:  uint8(255),
	652:  uint8(255),
	653:  uint8(255),
	654:  uint8(32),
	655:  uint8(64),
	656:  uint8(176),
	657:  uint8(0),
	658:  uint8(0),
	659:  uint8(0),
	660:  uint8(0),
	661:  uint8(0),
	662:  uint8(0),
	663:  uint8(0),
	664:  uint8(0),
	665:  uint8(0),
	666:  uint8(0),
	667:  uint8(0),
	668:  uint8(0),
	669:  uint8(0),
	670:  uint8(64),
	671:  uint8(0),
	672:  uint8(0),
	673:  uint8(0),
	674:  uint8(0),
	675:  uint8(0),
	676:  uint8(0),
	677:  uint8(0),
	678:  uint8(0),
	679:  uint8(0),
	680:  uint8(0),
	681:  uint8(0),
	682:  uint8(0),
	683:  uint8(0),
	684:  uint8(0),
	685:  uint8(0),
	686:  uint8(0),
	687:  uint8(0),
	688:  uint8(252),
	689:  uint8(3),
	690:  uint8(0),
	691:  uint8(0),
	692:  uint8(0),
	693:  uint8(0),
	694:  uint8(0),
	695:  uint8(0),
	696:  uint8(0),
	697:  uint8(0),
	698:  uint8(0),
	699:  uint8(0),
	700:  uint8(0),
	701:  uint8(0),
	702:  uint8(0),
	703:  uint8(0),
	704:  uint8(0),
	705:  uint8(0),
	706:  uint8(0),
	707:  uint8(0),
	708:  uint8(0),
	709:  uint8(0),
	710:  uint8(0),
	711:  uint8(0),
	712:  uint8(0),
	713:  uint8(0),
	714:  uint8(0),
	715:  uint8(252),
	716:  uint8(0),
	717:  uint8(0),
	718:  uint8(0),
	719:  uint8(0),
	720:  uint8(0),
	721:  uint8(230),
	722:  uint8(254),
	723:  uint8(255),
	724:  uint8(255),
	725:  uint8(255),
	726:  uint8(0),
	727:  uint8(64),
	728:  uint8(73),
	729:  uint8(0),
	730:  uint8(0),
	731:  uint8(0),
	732:  uint8(0),
	733:  uint8(0),
	734:  uint8(24),
	735:  uint8(0),
	736:  uint8(255),
	737:  uint8(255),
	738:  uint8(0),
	739:  uint8(216),
	740:  uint8(0),
	741:  uint8(0),
	742:  uint8(0),
	743:  uint8(0),
	744:  uint8(0),
	745:  uint8(0),
	746:  uint8(0),
	747:  uint8(1),
	748:  uint8(0),
	749:  uint8(60),
	750:  uint8(0),
	751:  uint8(0),
	752:  uint8(0),
	753:  uint8(0),
	754:  uint8(0),
	755:  uint8(0),
	756:  uint8(0),
	757:  uint8(0),
	758:  uint8(0),
	759:  uint8(0),
	760:  uint8(0),
	761:  uint8(0),
	762:  uint8(16),
	763:  uint8(224),
	764:  uint8(1),
	765:  uint8(30),
	766:  uint8(0),
	767:  uint8(96),
	768:  uint8(255),
	769:  uint8(191),
	770:  uint8(0),
	771:  uint8(0),
	772:  uint8(0),
	773:  uint8(0),
	774:  uint8(0),
	775:  uint8(0),
	776:  uint8(255),
	777:  uint8(7),
	778:  uint8(0),
	779:  uint8(0),
	780:  uint8(0),
	781:  uint8(0),
	782:  uint8(0),
	783:  uint8(0),
	784:  uint8(0),
	785:  uint8(0),
	786:  uint8(0),
	787:  uint8(0),
	788:  uint8(0),
	789:  uint8(0),
	790:  uint8(0),
	791:  uint8(0),
	792:  uint8(0),
	793:  uint8(0),
	794:  uint8(0),
	795:  uint8(0),
	796:  uint8(0),
	797:  uint8(248),
	798:  uint8(207),
	799:  uint8(227),
	800:  uint8(0),
	801:  uint8(0),
	802:  uint8(0),
	803:  uint8(3),
	804:  uint8(0),
	805:  uint8(32),
	806:  uint8(255),
	807:  uint8(127),
	808:  uint8(0),
	809:  uint8(0),
	810:  uint8(0),
	811:  uint8(78),
	812:  uint8(0),
	813:  uint8(0),
	814:  uint8(0),
	815:  uint8(0),
	816:  uint8(0),
	817:  uint8(0),
	818:  uint8(0),
	819:  uint8(0),
	820:  uint8(0),
	821:  uint8(0),
	822:  uint8(0),
	823:  uint8(0),
	824:  uint8(0),
	825:  uint8(0),
	826:  uint8(8),
	827:  uint8(0),
	828:  uint8(7),
	829:  uint8(252),
	830:  uint8(0),
	831:  uint8(0),
	832:  uint8(0),
	833:  uint8(0),
	834:  uint8(0),
	835:  uint8(0),
	836:  uint8(0),
	837:  uint8(0),
	838:  uint8(0),
	839:  uint8(16),
	840:  uint8(0),
	841:  uint8(32),
	842:  uint8(30),
	843:  uint8(0),
	844:  uint8(48),
	845:  uint8(0),
	846:  uint8(1),
	847:  uint8(0),
	848:  uint8(0),
	849:  uint8(0),
	850:  uint8(0),
	851:  uint8(0),
	852:  uint8(0),
	853:  uint8(0),
	854:  uint8(0),
	855:  uint8(16),
	856:  uint8(0),
	857:  uint8(32),
	858:  uint8(0),
	859:  uint8(0),
	860:  uint8(0),
	861:  uint8(0),
	862:  uint8(252),
	863:  uint8(111),
	864:  uint8(0),
	865:  uint8(0),
	866:  uint8(0),
	867:  uint8(0),
	868:  uint8(0),
	869:  uint8(0),
	870:  uint8(0),
	871:  uint8(16),
	872:  uint8(0),
	873:  uint8(32),
	874:  uint8(0),
	875:  uint8(0),
	876:  uint8(0),
	877:  uint8(0),
	878:  uint8(64),
	879:  uint8(0),
	880:  uint8(0),
	881:  uint8(0),
	882:  uint8(0),
	883:  uint8(0),
	884:  uint8(0),
	885:  uint8(0),
	886:  uint8(0),
	887:  uint8(16),
	888:  uint8(0),
	889:  uint8(32),
	890:  uint8(0),
	891:  uint8(0),
	892:  uint8(0),
	893:  uint8(0),
	894:  uint8(3),
	895:  uint8(224),
	896:  uint8(0),
	897:  uint8(0),
	898:  uint8(0),
	899:  uint8(0),
	900:  uint8(0),
	901:  uint8(0),
	902:  uint8(0),
	903:  uint8(16),
	904:  uint8(0),
	905:  uint8(32),
	906:  uint8(0),
	907:  uint8(0),
	908:  uint8(0),
	909:  uint8(0),
	910:  uint8(253),
	911:  uint8(0),
	912:  uint8(0),
	913:  uint8(0),
	914:  uint8(0),
	915:  uint8(0),
	916:  uint8(0),
	917:  uint8(0),
	918:  uint8(0),
	919:  uint8(0),
	920:  uint8(0),
	921:  uint8(32),
	922:  uint8(0),
	923:  uint8(0),
	924:  uint8(0),
	925:  uint8(0),
	926:  uint8(255),
	927:  uint8(7),
	928:  uint8(16),
	929:  uint8(0),
	930:  uint8(0),
	931:  uint8(0),
	932:  uint8(0),
	933:  uint8(0),
	934:  uint8(0),
	935:  uint8(0),
	936:  uint8(0),
	937:  uint8(32),
	938:  uint8(0),
	939:  uint8(0),
	940:  uint8(0),
	941:  uint8(0),
	942:  uint8(128),
	943:  uint8(255),
	944:  uint8(16),
	945:  uint8(0),
	946:  uint8(0),
	947:  uint8(0),
	948:  uint8(0),
	949:  uint8(0),
	950:  uint8(0),
	951:  uint8(16),
	952:  uint8(0),
	953:  uint8(32),
	954:  uint8(0),
	955:  uint8(0),
	956:  uint8(0),
	957:  uint8(0),
	958:  uint8(0),
	959:  uint8(0),
	960:  uint8(0),
	961:  uint8(0),
	962:  uint8(0),
	963:  uint8(0),
	964:  uint8(0),
	965:  uint8(0),
	966:  uint8(0),
	967:  uint8(24),
	968:  uint8(0),
	969:  uint8(160),
	970:  uint8(0),
	971:  uint8(127),
	972:  uint8(0),
	973:  uint8(0),
	974:  uint8(255),
	975:  uint8(3),
	976:  uint8(0),
	977:  uint8(0),
	978:  uint8(0),
	979:  uint8(0),
	980:  uint8(0),
	981:  uint8(0),
	982:  uint8(0),
	983:  uint8(0),
	984:  uint8(0),
	985:  uint8(4),
	986:  uint8(0),
	987:  uint8(0),
	988:  uint8(0),
	989:  uint8(0),
	990:  uint8(16),
	991:  uint8(0),
	992:  uint8(0),
	993:  uint8(0),
	994:  uint8(0),
	995:  uint8(0),
	996:  uint8(0),
	997:  uint8(128),
	998:  uint8(0),
	999:  uint8(128),
	1000: uint8(192),
	1001: uint8(223),
	1002: uint8(0),
	1003: uint8(12),
	1004: uint8(0),
	1005: uint8(0),
	1006: uint8(0),
	1007: uint8(0),
	1008: uint8(0),
	1009: uint8(0),
	1010: uint8(0),
	1011: uint8(0),
	1012: uint8(0),
	1013: uint8(0),
	1014: uint8(0),
	1015: uint8(4),
	1016: uint8(0),
	1017: uint8(31),
	1018: uint8(0),
	1019: uint8(0),
	1020: uint8(0),
	1021: uint8(0),
	1022: uint8(0),
	1023: uint8(0),
	1024: uint8(254),
	1025: uint8(255),
	1026: uint8(255),
	1027: uint8(255),
	1028: uint8(0),
	1029: uint8(252),
	1030: uint8(255),
	1031: uint8(255),
	1032: uint8(0),
	1033: uint8(0),
	1034: uint8(0),
	1035: uint8(0),
	1036: uint8(0),
	1037: uint8(0),
	1038: uint8(0),
	1039: uint8(0),
	1040: uint8(252),
	1041: uint8(0),
	1042: uint8(0),
	1043: uint8(0),
	1044: uint8(0),
	1045: uint8(0),
	1046: uint8(0),
	1047: uint8(192),
	1048: uint8(255),
	1049: uint8(223),
	1050: uint8(255),
	1051: uint8(7),
	1052: uint8(0),
	1053: uint8(0),
	1054: uint8(0),
	1055: uint8(0),
	1056: uint8(0),
	1057: uint8(0),
	1058: uint8(0),
	1059: uint8(0),
	1060: uint8(0),
	1061: uint8(0),
	1062: uint8(128),
	1063: uint8(6),
	1064: uint8(0),
	1065: uint8(252),
	1066: uint8(0),
	1067: uint8(0),
	1068: uint8(0),
	1069: uint8(0),
	1070: uint8(0),
	1071: uint8(0),
	1072: uint8(0),
	1073: uint8(0),
	1074: uint8(0),
	1075: uint8(192),
	1076: uint8(0),
	1077: uint8(0),
	1078: uint8(0),
	1079: uint8(0),
	1080: uint8(0),
	1081: uint8(0),
	1082: uint8(0),
	1083: uint8(0),
	1084: uint8(0),
	1085: uint8(0),
	1086: uint8(0),
	1087: uint8(8),
	1088: uint8(0),
	1089: uint8(0),
	1090: uint8(0),
	1091: uint8(0),
	1092: uint8(0),
	1093: uint8(0),
	1094: uint8(0),
	1095: uint8(0),
	1096: uint8(0),
	1097: uint8(0),
	1098: uint8(0),
	1099: uint8(224),
	1100: uint8(255),
	1101: uint8(255),
	1102: uint8(255),
	1103: uint8(31),
	1104: uint8(0),
	1105: uint8(0),
	1106: uint8(255),
	1107: uint8(3),
	1108: uint8(0),
	1109: uint8(0),
	1110: uint8(0),
	1111: uint8(0),
	1112: uint8(0),
	1113: uint8(0),
	1114: uint8(0),
	1115: uint8(0),
	1116: uint8(0),
	1117: uint8(0),
	1118: uint8(0),
	1119: uint8(0),
	1120: uint8(1),
	1121: uint8(0),
	1122: uint8(0),
	1123: uint8(0),
	1124: uint8(0),
	1125: uint8(0),
	1126: uint8(0),
	1127: uint8(0),
	1128: uint8(0),
	1129: uint8(0),
	1130: uint8(0),
	1131: uint8(0),
	1132: uint8(0),
	1133: uint8(0),
	1134: uint8(0),
	1135: uint8(0),
	1136: uint8(0),
	1137: uint8(0),
	1138: uint8(0),
	1139: uint8(0),
	1140: uint8(0),
	1141: uint8(0),
	1142: uint8(0),
	1143: uint8(0),
	1144: uint8(0),
	1145: uint8(0),
	1146: uint8(0),
	1147: uint8(0),
	1148: uint8(0),
	1149: uint8(0),
	1150: uint8(0),
	1151: uint8(0),
	1152: uint8(0),
	1153: uint8(0),
	1154: uint8(0),
	1155: uint8(0),
	1156: uint8(0),
	1157: uint8(0),
	1158: uint8(0),
	1159: uint8(0),
	1160: uint8(0),
	1161: uint8(0),
	1162: uint8(0),
	1163: uint8(0),
	1164: uint8(0),
	1165: uint8(96),
	1166: uint8(0),
	1167: uint8(0),
	1168: uint8(1),
	1169: uint8(0),
	1170: uint8(0),
	1171: uint8(24),
	1172: uint8(0),
	1173: uint8(0),
	1174: uint8(0),
	1175: uint8(0),
	1176: uint8(0),
	1177: uint8(0),
	1178: uint8(0),
	1179: uint8(0),
	1180: uint8(0),
	1181: uint8(56),
	1182: uint8(0),
	1183: uint8(0),
	1184: uint8(0),
	1185: uint8(0),
	1186: uint8(16),
	1187: uint8(0),
	1188: uint8(0),
	1189: uint8(0),
	1190: uint8(112),
	1191: uint8(0),
	1192: uint8(0),
	1193: uint8(0),
	1194: uint8(0),
	1195: uint8(0),
	1196: uint8(0),
	1197: uint8(0),
	1198: uint8(0),
	1199: uint8(0),
	1200: uint8(0),
	1201: uint8(0),
	1202: uint8(0),
	1203: uint8(0),
	1204: uint8(0),
	1205: uint8(0),
	1206: uint8(48),
	1207: uint8(0),
	1208: uint8(0),
	1209: uint8(254),
	1210: uint8(127),
	1211: uint8(47),
	1212: uint8(0),
	1213: uint8(0),
	1214: uint8(255),
	1215: uint8(3),
	1216: uint8(255),
	1217: uint8(127),
	1218: uint8(0),
	1219: uint8(0),
	1220: uint8(0),
	1221: uint8(0),
	1222: uint8(0),
	1223: uint8(0),
	1224: uint8(0),
	1225: uint8(0),
	1226: uint8(0),
	1227: uint8(0),
	1228: uint8(0),
	1229: uint8(0),
	1230: uint8(0),
	1231: uint8(0),
	1232: uint8(0),
	1233: uint8(0),
	1234: uint8(0),
	1235: uint8(0),
	1236: uint8(0),
	1237: uint8(0),
	1238: uint8(0),
	1239: uint8(0),
	1240: uint8(0),
	1241: uint8(0),
	1242: uint8(0),
	1243: uint8(0),
	1244: uint8(0),
	1245: uint8(0),
	1246: uint8(0),
	1247: uint8(0),
	1248: uint8(0),
	1249: uint8(0),
	1250: uint8(0),
	1251: uint8(0),
	1252: uint8(0),
	1253: uint8(0),
	1254: uint8(0),
	1255: uint8(14),
	1256: uint8(49),
	1257: uint8(0),
	1258: uint8(0),
	1259: uint8(0),
	1260: uint8(0),
	1261: uint8(0),
	1262: uint8(0),
	1263: uint8(0),
	1264: uint8(0),
	1265: uint8(0),
	1266: uint8(0),
	1267: uint8(0),
	1268: uint8(0),
	1269: uint8(0),
	1270: uint8(0),
	1271: uint8(0),
	1272: uint8(0),
	1273: uint8(0),
	1274: uint8(0),
	1275: uint8(196),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(255),
	1279: uint8(255),
	1280: uint8(0),
	1281: uint8(0),
	1282: uint8(0),
	1283: uint8(192),
	1284: uint8(0),
	1285: uint8(0),
	1286: uint8(0),
	1287: uint8(0),
	1288: uint8(0),
	1289: uint8(0),
	1290: uint8(0),
	1291: uint8(0),
	1292: uint8(1),
	1293: uint8(0),
	1294: uint8(224),
	1295: uint8(159),
	1296: uint8(0),
	1297: uint8(0),
	1298: uint8(0),
	1299: uint8(0),
	1300: uint8(127),
	1301: uint8(63),
	1302: uint8(255),
	1303: uint8(127),
	1304: uint8(0),
	1305: uint8(0),
	1306: uint8(0),
	1307: uint8(0),
	1308: uint8(0),
	1309: uint8(0),
	1310: uint8(0),
	1311: uint8(0),
	1312: uint8(0),
	1313: uint8(0),
	1314: uint8(0),
	1315: uint8(0),
	1316: uint8(0),
	1317: uint8(0),
	1318: uint8(16),
	1319: uint8(0),
	1320: uint8(16),
	1321: uint8(0),
	1322: uint8(0),
	1323: uint8(252),
	1324: uint8(255),
	1325: uint8(255),
	1326: uint8(255),
	1327: uint8(31),
	1328: uint8(0),
	1329: uint8(0),
	1330: uint8(0),
	1331: uint8(0),
	1332: uint8(0),
	1333: uint8(12),
	1334: uint8(0),
	1335: uint8(0),
	1336: uint8(0),
	1337: uint8(0),
	1338: uint8(0),
	1339: uint8(0),
	1340: uint8(64),
	1341: uint8(0),
	1342: uint8(12),
	1343: uint8(240),
	1344: uint8(0),
	1345: uint8(0),
	1346: uint8(0),
	1347: uint8(0),
	1348: uint8(0),
	1349: uint8(0),
	1350: uint8(128),
	1351: uint8(248),
	1352: uint8(0),
	1353: uint8(0),
	1354: uint8(0),
	1355: uint8(0),
	1356: uint8(0),
	1357: uint8(0),
	1358: uint8(0),
	1359: uint8(192),
	1360: uint8(0),
	1361: uint8(0),
	1362: uint8(0),
	1363: uint8(0),
	1364: uint8(0),
	1365: uint8(0),
	1366: uint8(0),
	1367: uint8(0),
	1368: uint8(255),
	1369: uint8(0),
	1370: uint8(255),
	1371: uint8(255),
	1372: uint8(255),
	1373: uint8(33),
	1374: uint8(144),
	1375: uint8(3),
	1376: uint8(0),
	1377: uint8(0),
	1378: uint8(0),
	1379: uint8(0),
	1380: uint8(0),
	1381: uint8(0),
	1382: uint8(0),
	1383: uint8(0),
	1384: uint8(0),
	1385: uint8(0),
	1386: uint8(0),
	1387: uint8(0),
	1388: uint8(0),
	1389: uint8(0),
	1390: uint8(0),
	1391: uint8(0),
	1392: uint8(0),
	1393: uint8(0),
	1394: uint8(0),
	1395: uint8(0),
	1396: uint8(0),
	1397: uint8(0),
	1398: uint8(0),
	1399: uint8(0),
	1400: uint8(255),
	1401: uint8(255),
	1402: uint8(255),
	1403: uint8(255),
	1404: uint8(127),
	1405: uint8(0),
	1406: uint8(224),
	1407: uint8(251),
	1408: uint8(0),
	1409: uint8(0),
	1410: uint8(0),
	1411: uint8(0),
	1412: uint8(0),
	1413: uint8(0),
	1414: uint8(0),
	1415: uint8(0),
	1416: uint8(0),
	1417: uint8(0),
	1418: uint8(0),
	1419: uint8(0),
	1420: uint8(0),
	1421: uint8(0),
	1422: uint8(0),
	1423: uint8(0),
	1424: uint8(0),
	1425: uint8(0),
	1426: uint8(0),
	1427: uint8(0),
	1428: uint8(0),
	1429: uint8(0),
	1430: uint8(0),
	1431: uint8(160),
	1432: uint8(3),
	1433: uint8(224),
	1434: uint8(0),
	1435: uint8(224),
	1436: uint8(0),
	1437: uint8(224),
	1438: uint8(0),
	1439: uint8(96),
	1440: uint8(128),
	1441: uint8(248),
	1442: uint8(255),
	1443: uint8(255),
	1444: uint8(255),
	1445: uint8(252),
	1446: uint8(255),
	1447: uint8(255),
	1448: uint8(255),
	1449: uint8(255),
	1450: uint8(255),
	1451: uint8(127),
	1452: uint8(223),
	1453: uint8(255),
	1454: uint8(241),
	1455: uint8(127),
	1456: uint8(255),
	1457: uint8(127),
	1458: uint8(0),
	1459: uint8(0),
	1460: uint8(255),
	1461: uint8(255),
	1462: uint8(255),
	1463: uint8(255),
	1464: uint8(0),
	1465: uint8(0),
	1466: uint8(255),
	1467: uint8(255),
	1468: uint8(255),
	1469: uint8(255),
	1470: uint8(1),
	1471: uint8(0),
	1472: uint8(123),
	1473: uint8(3),
	1474: uint8(208),
	1475: uint8(193),
	1476: uint8(175),
	1477: uint8(66),
	1478: uint8(0),
	1479: uint8(12),
	1480: uint8(31),
	1481: uint8(188),
	1482: uint8(255),
	1483: uint8(255),
	1484: uint8(0),
	1485: uint8(0),
	1486: uint8(0),
	1487: uint8(0),
	1488: uint8(0),
	1489: uint8(14),
	1490: uint8(255),
	1491: uint8(255),
	1492: uint8(255),
	1493: uint8(255),
	1494: uint8(255),
	1495: uint8(255),
	1496: uint8(255),
	1497: uint8(255),
	1498: uint8(255),
	1499: uint8(255),
	1500: uint8(255),
	1501: uint8(255),
	1502: uint8(255),
	1503: uint8(255),
	1504: uint8(255),
	1505: uint8(255),
	1506: uint8(255),
	1507: uint8(255),
	1508: uint8(127),
	1509: uint8(0),
	1510: uint8(0),
	1511: uint8(0),
	1512: uint8(255),
	1513: uint8(7),
	1514: uint8(0),
	1515: uint8(0),
	1516: uint8(255),
	1517: uint8(255),
	1518: uint8(255),
	1519: uint8(255),
	1520: uint8(255),
	1521: uint8(255),
	1522: uint8(255),
	1523: uint8(255),
	1524: uint8(255),
	1525: uint8(255),
	1526: uint8(63),
	1527: uint8(0),
	1528: uint8(0),
	1529: uint8(0),
	1530: uint8(0),
	1531: uint8(0),
	1532: uint8(0),
	1533: uint8(252),
	1534: uint8(255),
	1535: uint8(255),
	1536: uint8(255),
	1537: uint8(255),
	1538: uint8(255),
	1539: uint8(255),
	1540: uint8(255),
	1541: uint8(255),
	1542: uint8(255),
	1543: uint8(255),
	1544: uint8(255),
	1545: uint8(255),
	1546: uint8(255),
	1547: uint8(255),
	1548: uint8(255),
	1549: uint8(255),
	1550: uint8(207),
	1551: uint8(255),
	1552: uint8(255),
	1553: uint8(255),
	1554: uint8(63),
	1555: uint8(255),
	1556: uint8(255),
	1557: uint8(255),
	1558: uint8(255),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(255),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(255),
	1566: uint8(255),
	1567: uint8(255),
	1568: uint8(0),
	1569: uint8(0),
	1570: uint8(0),
	1571: uint8(0),
	1572: uint8(0),
	1573: uint8(0),
	1574: uint8(0),
	1575: uint8(0),
	1576: uint8(0),
	1577: uint8(0),
	1578: uint8(0),
	1579: uint8(0),
	1580: uint8(0),
	1581: uint8(0),
	1582: uint8(0),
	1583: uint8(0),
	1584: uint8(0),
	1585: uint8(0),
	1586: uint8(0),
	1587: uint8(0),
	1588: uint8(0),
	1589: uint8(0),
	1590: uint8(0),
	1591: uint8(0),
	1592: uint8(0),
	1593: uint8(0),
	1594: uint8(0),
	1595: uint8(0),
	1596: uint8(224),
	1597: uint8(135),
	1598: uint8(3),
	1599: uint8(254),
	1600: uint8(0),
	1601: uint8(0),
	1602: uint8(0),
	1603: uint8(0),
	1604: uint8(0),
	1605: uint8(0),
	1606: uint8(0),
	1607: uint8(0),
	1608: uint8(0),
	1609: uint8(0),
	1610: uint8(0),
	1611: uint8(0),
	1612: uint8(0),
	1613: uint8(0),
	1614: uint8(1),
	1615: uint8(128),
	1616: uint8(0),
	1617: uint8(0),
	1618: uint8(0),
	1619: uint8(0),
	1620: uint8(0),
	1621: uint8(0),
	1622: uint8(0),
	1623: uint8(0),
	1624: uint8(0),
	1625: uint8(0),
	1626: uint8(0),
	1627: uint8(0),
	1628: uint8(0),
	1629: uint8(0),
	1630: uint8(0),
	1631: uint8(0),
	1632: uint8(255),
	1633: uint8(255),
	1634: uint8(255),
	1635: uint8(255),
	1636: uint8(255),
	1637: uint8(127),
	1638: uint8(255),
	1639: uint8(255),
	1640: uint8(255),
	1641: uint8(255),
	1642: uint8(0),
	1643: uint8(0),
	1644: uint8(0),
	1645: uint8(0),
	1646: uint8(0),
	1647: uint8(0),
	1648: uint8(255),
	1649: uint8(255),
	1650: uint8(255),
	1651: uint8(251),
	1652: uint8(255),
	1653: uint8(255),
	1654: uint8(255),
	1655: uint8(255),
	1656: uint8(255),
	1657: uint8(255),
	1658: uint8(255),
	1659: uint8(255),
	1660: uint8(255),
	1661: uint8(255),
	1662: uint8(15),
	1663: uint8(0),
	1664: uint8(255),
	1665: uint8(255),
	1666: uint8(255),
	1667: uint8(255),
	1668: uint8(255),
	1669: uint8(255),
	1670: uint8(255),
	1671: uint8(255),
	1672: uint8(255),
	1673: uint8(255),
	1674: uint8(255),
	1675: uint8(255),
	1676: uint8(255),
	1677: uint8(255),
	1678: uint8(255),
	1679: uint8(255),
	1680: uint8(255),
	1681: uint8(255),
	1682: uint8(255),
	1683: uint8(255),
	1684: uint8(255),
	1685: uint8(255),
	1686: uint8(255),
	1687: uint8(255),
	1688: uint8(255),
	1689: uint8(255),
	1690: uint8(63),
	1691: uint8(0),
	1692: uint8(0),
	1693: uint8(0),
	1694: uint8(255),
	1695: uint8(15),
	1696: uint8(30),
	1697: uint8(255),
	1698: uint8(255),
	1699: uint8(255),
	1700: uint8(1),
	1701: uint8(252),
	1702: uint8(193),
	1703: uint8(224),
	1704: uint8(0),
	1705: uint8(0),
	1706: uint8(0),
	1707: uint8(0),
	1708: uint8(0),
	1709: uint8(0),
	1710: uint8(0),
	1711: uint8(0),
	1712: uint8(0),
	1713: uint8(0),
	1714: uint8(0),
	1715: uint8(30),
	1716: uint8(1),
	1717: uint8(0),
	1718: uint8(0),
	1719: uint8(0),
	1720: uint8(0),
	1721: uint8(0),
	1722: uint8(0),
	1723: uint8(0),
	1724: uint8(0),
	1725: uint8(0),
	1726: uint8(0),
	1727: uint8(8),
	1728: uint8(0),
	1729: uint8(0),
	1730: uint8(0),
	1731: uint8(0),
	1732: uint8(0),
	1733: uint8(0),
	1734: uint8(0),
	1735: uint8(0),
	1736: uint8(0),
	1737: uint8(0),
	1738: uint8(0),
	1739: uint8(0),
	1740: uint8(0),
	1741: uint8(0),
	1742: uint8(0),
	1743: uint8(0),
	1744: uint8(0),
	1745: uint8(0),
	1746: uint8(255),
	1747: uint8(255),
	1748: uint8(0),
	1749: uint8(0),
	1750: uint8(0),
	1751: uint8(0),
	1752: uint8(255),
	1753: uint8(255),
	1754: uint8(255),
	1755: uint8(255),
	1756: uint8(15),
	1757: uint8(0),
	1758: uint8(0),
	1759: uint8(0),
	1760: uint8(255),
	1761: uint8(255),
	1762: uint8(255),
	1763: uint8(127),
	1764: uint8(255),
	1765: uint8(255),
	1766: uint8(255),
	1767: uint8(255),
	1768: uint8(255),
	1769: uint8(255),
	1770: uint8(255),
	1771: uint8(255),
	1772: uint8(255),
	1773: uint8(255),
	1774: uint8(255),
	1775: uint8(255),
	1776: uint8(255),
	1777: uint8(255),
	1778: uint8(255),
	1779: uint8(255),
	1780: uint8(255),
	1781: uint8(255),
	1782: uint8(255),
	1783: uint8(255),
	1784: uint8(255),
	1785: uint8(255),
	1786: uint8(255),
	1787: uint8(255),
	1788: uint8(255),
	1789: uint8(255),
	1790: uint8(255),
	1791: uint8(255),
	1792: uint8(0),
	1793: uint8(0),
	1794: uint8(0),
	1795: uint8(0),
	1796: uint8(0),
	1797: uint8(0),
	1798: uint8(0),
	1799: uint8(0),
	1800: uint8(0),
	1801: uint8(0),
	1802: uint8(0),
	1803: uint8(0),
	1804: uint8(0),
	1805: uint8(0),
	1806: uint8(0),
	1807: uint8(0),
	1808: uint8(0),
	1809: uint8(0),
	1810: uint8(0),
	1811: uint8(0),
	1812: uint8(0),
	1813: uint8(0),
	1814: uint8(0),
	1815: uint8(0),
	1816: uint8(255),
	1817: uint8(255),
	1818: uint8(255),
	1819: uint8(255),
	1820: uint8(255),
	1821: uint8(255),
	1822: uint8(255),
	1823: uint8(255),
	1824: uint8(0),
	1825: uint8(0),
	1826: uint8(0),
	1827: uint8(0),
	1828: uint8(0),
	1829: uint8(0),
	1830: uint8(0),
	1831: uint8(0),
	1832: uint8(0),
	1833: uint8(0),
	1834: uint8(0),
	1835: uint8(0),
	1836: uint8(0),
	1837: uint8(0),
	1838: uint8(0),
	1839: uint8(0),
	1840: uint8(0),
	1841: uint8(0),
	1842: uint8(255),
	1843: uint8(255),
	1844: uint8(255),
	1845: uint8(255),
	1846: uint8(255),
	1847: uint8(255),
	1848: uint8(127),
	1849: uint8(0),
	1850: uint8(0),
	1851: uint8(0),
	1852: uint8(0),
	1853: uint8(0),
	1854: uint8(0),
	1855: uint8(192),
	1856: uint8(0),
	1857: uint8(224),
	1858: uint8(0),
	1859: uint8(0),
	1860: uint8(0),
	1861: uint8(0),
	1862: uint8(0),
	1863: uint8(0),
	1864: uint8(0),
	1865: uint8(0),
	1866: uint8(0),
	1867: uint8(0),
	1868: uint8(0),
	1869: uint8(128),
	1870: uint8(15),
	1871: uint8(112),
	1872: uint8(0),
	1873: uint8(0),
	1874: uint8(0),
	1875: uint8(0),
	1876: uint8(0),
	1877: uint8(0),
	1878: uint8(0),
	1879: uint8(0),
	1880: uint8(0),
	1881: uint8(0),
	1882: uint8(0),
	1883: uint8(0),
	1884: uint8(0),
	1885: uint8(0),
	1886: uint8(255),
	1887: uint8(0),
	1888: uint8(255),
	1889: uint8(255),
	1890: uint8(127),
	1891: uint8(0),
	1892: uint8(3),
	1893: uint8(0),
	1894: uint8(0),
	1895: uint8(0),
	1896: uint8(0),
	1897: uint8(0),
	1898: uint8(0),
	1899: uint8(0),
	1900: uint8(0),
	1901: uint8(0),
	1902: uint8(0),
	1903: uint8(0),
	1904: uint8(0),
	1905: uint8(6),
	1906: uint8(0),
	1907: uint8(0),
	1908: uint8(0),
	1909: uint8(0),
	1910: uint8(0),
	1911: uint8(0),
	1912: uint8(0),
	1913: uint8(0),
	1914: uint8(0),
	1915: uint8(0),
	1916: uint8(0),
	1917: uint8(0),
	1918: uint8(0),
	1919: uint8(0),
	1920: uint8(64),
	1921: uint8(0),
	1922: uint8(0),
	1923: uint8(0),
	1924: uint8(0),
	1925: uint8(15),
	1926: uint8(255),
	1927: uint8(3),
	1928: uint8(0),
	1929: uint8(0),
	1930: uint8(0),
	1931: uint8(0),
	1932: uint8(0),
	1933: uint8(0),
	1934: uint8(240),
	1935: uint8(0),
	1936: uint8(0),
	1937: uint8(0),
	1938: uint8(0),
	1939: uint8(0),
	1940: uint8(0),
	1941: uint8(0),
	1942: uint8(0),
	1943: uint8(0),
	1944: uint8(16),
	1945: uint8(192),
	1946: uint8(0),
	1947: uint8(0),
	1948: uint8(255),
	1949: uint8(255),
	1950: uint8(3),
	1951: uint8(23),
	1952: uint8(0),
	1953: uint8(0),
	1954: uint8(0),
	1955: uint8(0),
	1956: uint8(0),
	1957: uint8(248),
	1958: uint8(0),
	1959: uint8(0),
	1960: uint8(0),
	1961: uint8(0),
	1962: uint8(8),
	1963: uint8(128),
	1964: uint8(0),
	1965: uint8(0),
	1966: uint8(0),
	1967: uint8(0),
	1968: uint8(0),
	1969: uint8(0),
	1970: uint8(0),
	1971: uint8(0),
	1972: uint8(0),
	1973: uint8(0),
	1974: uint8(8),
	1975: uint8(0),
	1976: uint8(255),
	1977: uint8(63),
	1978: uint8(0),
	1979: uint8(192),
	1980: uint8(0),
	1981: uint8(0),
	1982: uint8(0),
	1983: uint8(0),
	1984: uint8(0),
	1985: uint8(0),
	1986: uint8(0),
	1987: uint8(0),
	1988: uint8(0),
	1989: uint8(0),
	1990: uint8(0),
	1991: uint8(0),
	1992: uint8(0),
	1993: uint8(0),
	1994: uint8(0),
	1995: uint8(240),
	1996: uint8(0),
	1997: uint8(0),
	1998: uint8(128),
	1999: uint8(3),
	2000: uint8(0),
	2001: uint8(0),
	2002: uint8(0),
	2003: uint8(0),
	2004: uint8(0),
	2005: uint8(0),
	2006: uint8(0),
	2007: uint8(128),
	2008: uint8(2),
	2009: uint8(0),
	2010: uint8(0),
	2011: uint8(192),
	2012: uint8(0),
	2013: uint8(0),
	2014: uint8(67),
	2015: uint8(0),
	2016: uint8(0),
	2017: uint8(0),
	2018: uint8(0),
	2019: uint8(0),
	2020: uint8(0),
	2021: uint8(0),
	2022: uint8(0),
	2023: uint8(0),
	2024: uint8(0),
	2025: uint8(0),
	2026: uint8(0),
	2027: uint8(8),
	2028: uint8(0),
	2029: uint8(0),
	2030: uint8(0),
	2031: uint8(0),
	2032: uint8(0),
	2033: uint8(0),
	2034: uint8(0),
	2035: uint8(0),
	2036: uint8(0),
	2037: uint8(0),
	2038: uint8(0),
	2039: uint8(0),
	2040: uint8(0),
	2041: uint8(0),
	2042: uint8(0),
	2043: uint8(0),
	2044: uint8(0),
	2045: uint8(56),
	2046: uint8(0),
	2047: uint8(0),
	2048: uint8(1),
	2049: uint8(0),
	2050: uint8(0),
	2051: uint8(0),
	2052: uint8(0),
	2053: uint8(0),
	2054: uint8(0),
	2055: uint8(0),
	2056: uint8(0),
	2057: uint8(0),
	2058: uint8(0),
	2059: uint8(0),
	2060: uint8(0),
	2061: uint8(0),
	2062: uint8(0),
	2063: uint8(0),
	2064: uint8(0),
	2065: uint8(0),
	2066: uint8(0),
	2067: uint8(0),
	2068: uint8(0),
	2069: uint8(0),
	2070: uint8(0),
	2071: uint8(0),
	2072: uint8(0),
	2073: uint8(0),
	2074: uint8(0),
	2075: uint8(0),
	2076: uint8(0),
	2077: uint8(0),
	2078: uint8(0),
	2079: uint8(0),
	2080: uint8(0),
	2081: uint8(0),
	2082: uint8(0),
	2083: uint8(0),
	2084: uint8(0),
	2085: uint8(0),
	2086: uint8(0),
	2087: uint8(0),
	2088: uint8(0),
	2089: uint8(0),
	2090: uint8(0),
	2091: uint8(0),
	2092: uint8(0),
	2093: uint8(0),
	2094: uint8(0),
	2095: uint8(0),
	2096: uint8(0),
	2097: uint8(0),
	2098: uint8(0),
	2099: uint8(0),
	2100: uint8(0),
	2101: uint8(0),
	2102: uint8(0),
	2103: uint8(0),
	2104: uint8(0),
	2105: uint8(0),
	2106: uint8(0),
	2107: uint8(0),
	2108: uint8(0),
	2109: uint8(0),
	2110: uint8(0),
	2111: uint8(128),
	2112: uint8(0),
	2113: uint8(0),
	2114: uint8(0),
	2115: uint8(0),
	2116: uint8(0),
	2117: uint8(2),
	2118: uint8(0),
	2119: uint8(0),
	2120: uint8(0),
	2121: uint8(0),
	2122: uint8(0),
	2123: uint8(0),
	2124: uint8(0),
	2125: uint8(0),
	2126: uint8(0),
	2127: uint8(0),
	2128: uint8(0),
	2129: uint8(0),
	2130: uint8(0),
	2131: uint8(0),
	2132: uint8(0),
	2133: uint8(0),
	2134: uint8(252),
	2135: uint8(255),
	2136: uint8(3),
	2137: uint8(0),
	2138: uint8(0),
	2139: uint8(0),
	2140: uint8(0),
	2141: uint8(0),
	2142: uint8(0),
	2143: uint8(0),
	2144: uint8(0),
	2145: uint8(0),
	2146: uint8(0),
	2147: uint8(0),
	2148: uint8(0),
	2149: uint8(0),
	2150: uint8(0),
	2151: uint8(192),
	2152: uint8(0),
	2153: uint8(0),
	2154: uint8(0),
	2155: uint8(0),
	2156: uint8(0),
	2157: uint8(0),
	2158: uint8(0),
	2159: uint8(0),
	2160: uint8(0),
	2161: uint8(0),
	2162: uint8(0),
	2163: uint8(0),
	2164: uint8(0),
	2165: uint8(0),
	2166: uint8(0),
	2167: uint8(0),
	2168: uint8(0),
	2169: uint8(0),
	2170: uint8(0),
	2171: uint8(0),
	2172: uint8(0),
	2173: uint8(0),
	2174: uint8(0),
	2175: uint8(48),
	2176: uint8(255),
	2177: uint8(255),
	2178: uint8(255),
	2179: uint8(3),
	2180: uint8(255),
	2181: uint8(255),
	2182: uint8(255),
	2183: uint8(255),
	2184: uint8(255),
	2185: uint8(255),
	2186: uint8(247),
	2187: uint8(255),
	2188: uint8(127),
	2189: uint8(15),
	2190: uint8(0),
	2191: uint8(0),
	2192: uint8(0),
	2193: uint8(0),
	2194: uint8(0),
	2195: uint8(0),
	2196: uint8(0),
	2197: uint8(0),
	2198: uint8(0),
	2199: uint8(0),
	2200: uint8(0),
	2201: uint8(0),
	2202: uint8(0),
	2203: uint8(0),
	2204: uint8(0),
	2205: uint8(0),
	2206: uint8(0),
	2207: uint8(128),
	2208: uint8(254),
	2209: uint8(255),
	2210: uint8(0),
	2211: uint8(252),
	2212: uint8(1),
	2213: uint8(0),
	2214: uint8(0),
	2215: uint8(248),
	2216: uint8(1),
	2217: uint8(0),
	2218: uint8(0),
	2219: uint8(248),
	2220: uint8(63),
	2221: uint8(0),
	2222: uint8(0),
	2223: uint8(0),
	2224: uint8(0),
	2225: uint8(0),
	2226: uint8(0),
	2227: uint8(0),
	2228: uint8(0),
	2229: uint8(0),
	2230: uint8(0),
	2231: uint8(0),
	2232: uint8(0),
	2233: uint8(0),
	2234: uint8(0),
	2235: uint8(0),
	2236: uint8(127),
	2237: uint8(127),
	2238: uint8(0),
	2239: uint8(48),
	2240: uint8(135),
	2241: uint8(255),
	2242: uint8(255),
	2243: uint8(255),
	2244: uint8(255),
	2245: uint8(255),
	2246: uint8(143),
	2247: uint8(255),
	2248: uint8(0),
	2249: uint8(0),
	2250: uint8(0),
	2251: uint8(0),
	2252: uint8(0),
	2253: uint8(0),
	2254: uint8(224),
	2255: uint8(255),
	2256: uint8(255),
	2257: uint8(127),
	2258: uint8(255),
	2259: uint8(15),
	2260: uint8(1),
	2261: uint8(0),
	2262: uint8(0),
	2263: uint8(0),
	2264: uint8(0),
	2265: uint8(0),
	2266: uint8(255),
	2267: uint8(255),
	2268: uint8(255),
	2269: uint8(255),
	2270: uint8(255),
	2271: uint8(63),
	2272: uint8(0),
	2273: uint8(0),
	2274: uint8(0),
	2275: uint8(0),
	2276: uint8(0),
	2277: uint8(0),
	2278: uint8(0),
	2279: uint8(0),
	2280: uint8(0),
	2281: uint8(0),
	2282: uint8(0),
	2283: uint8(0),
	2284: uint8(0),
	2285: uint8(0),
	2286: uint8(0),
	2287: uint8(0),
	2288: uint8(0),
	2289: uint8(0),
	2290: uint8(0),
	2291: uint8(0),
	2292: uint8(0),
	2293: uint8(0),
	2294: uint8(0),
	2295: uint8(0),
	2296: uint8(0),
	2297: uint8(0),
	2298: uint8(0),
	2299: uint8(0),
	2300: uint8(255),
	2301: uint8(255),
	2302: uint8(255),
	2303: uint8(15),
	2304: uint8(0),
	2305: uint8(0),
	2306: uint8(0),
	2307: uint8(0),
	2308: uint8(15),
	2309: uint8(0),
	2310: uint8(0),
	2311: uint8(0),
	2312: uint8(0),
	2313: uint8(0),
	2314: uint8(0),
	2315: uint8(0),
	2316: uint8(0),
	2317: uint8(0),
	2318: uint8(0),
	2319: uint8(0),
	2320: uint8(0),
	2321: uint8(0),
	2322: uint8(0),
	2323: uint8(128),
	2324: uint8(0),
	2325: uint8(0),
	2326: uint8(0),
	2327: uint8(0),
	2328: uint8(0),
	2329: uint8(0),
	2330: uint8(1),
	2331: uint8(0),
	2332: uint8(0),
	2333: uint8(0),
	2334: uint8(0),
	2335: uint8(0),
	2336: uint8(0),
	2337: uint8(0),
	2338: uint8(0),
	2339: uint8(0),
	2340: uint8(0),
	2341: uint8(0),
	2342: uint8(0),
	2343: uint8(0),
	2344: uint8(0),
	2345: uint8(0),
	2346: uint8(0),
	2347: uint8(0),
	2348: uint8(0),
	2349: uint8(128),
	2350: uint8(0),
	2351: uint8(0),
	2352: uint8(0),
	2353: uint8(0),
	2354: uint8(0),
	2355: uint8(0),
	2356: uint8(0),
	2357: uint8(0),
	2358: uint8(0),
	2359: uint8(0),
	2360: uint8(0),
	2361: uint8(0),
	2362: uint8(0),
	2363: uint8(0),
	2364: uint8(0),
	2365: uint8(0),
	2366: uint8(0),
	2367: uint8(0),
	2368: uint8(0),
	2369: uint8(0),
	2370: uint8(0),
	2371: uint8(0),
	2372: uint8(0),
	2373: uint8(0),
	2374: uint8(0),
	2375: uint8(0),
	2376: uint8(0),
	2377: uint8(0),
	2378: uint8(128),
	2379: uint8(255),
	2380: uint8(0),
	2381: uint8(0),
	2382: uint8(128),
	2383: uint8(255),
	2384: uint8(0),
	2385: uint8(0),
	2386: uint8(0),
	2387: uint8(0),
	2388: uint8(128),
	2389: uint8(255),
	2390: uint8(0),
	2391: uint8(0),
	2392: uint8(0),
	2393: uint8(0),
	2394: uint8(0),
	2395: uint8(0),
	2396: uint8(0),
	2397: uint8(0),
	2398: uint8(0),
	2399: uint8(248),
	2400: uint8(0),
	2401: uint8(0),
	2402: uint8(192),
	2403: uint8(143),
	2404: uint8(0),
	2405: uint8(0),
	2406: uint8(0),
	2407: uint8(128),
	2408: uint8(0),
	2409: uint8(0),
	2410: uint8(0),
	2411: uint8(0),
	2412: uint8(0),
	2413: uint8(0),
	2414: uint8(0),
	2415: uint8(0),
	2416: uint8(0),
	2417: uint8(0),
	2418: uint8(0),
	2419: uint8(0),
	2420: uint8(0),
	2421: uint8(0),
	2422: uint8(0),
	2423: uint8(48),
	2424: uint8(255),
	2425: uint8(255),
	2426: uint8(252),
	2427: uint8(255),
	2428: uint8(255),
	2429: uint8(255),
	2430: uint8(255),
	2431: uint8(255),
	2432: uint8(0),
	2433: uint8(0),
	2434: uint8(0),
	2435: uint8(0),
	2436: uint8(0),
	2437: uint8(0),
	2438: uint8(0),
	2439: uint8(135),
	2440: uint8(255),
	2441: uint8(1),
	2442: uint8(255),
	2443: uint8(1),
	2444: uint8(0),
	2445: uint8(0),
	2446: uint8(0),
	2447: uint8(224),
	2448: uint8(0),
	2449: uint8(0),
	2450: uint8(0),
	2451: uint8(224),
	2452: uint8(0),
	2453: uint8(0),
	2454: uint8(0),
	2455: uint8(0),
	2456: uint8(0),
	2457: uint8(1),
	2458: uint8(0),
	2459: uint8(0),
	2460: uint8(96),
	2461: uint8(248),
	2462: uint8(127),
	2463: uint8(0),
	2464: uint8(0),
	2465: uint8(0),
	2466: uint8(0),
	2467: uint8(0),
	2468: uint8(0),
	2469: uint8(0),
	2470: uint8(0),
	2471: uint8(254),
	2472: uint8(0),
	2473: uint8(0),
	2474: uint8(0),
	2475: uint8(255),
	2476: uint8(0),
	2477: uint8(0),
	2478: uint8(0),
	2479: uint8(255),
	2480: uint8(0),
	2481: uint8(0),
	2482: uint8(0),
	2483: uint8(30),
	2484: uint8(0),
	2485: uint8(254),
	2486: uint8(0),
	2487: uint8(0),
	2488: uint8(0),
	2489: uint8(0),
	2490: uint8(0),
	2491: uint8(0),
	2492: uint8(0),
	2493: uint8(0),
	2494: uint8(0),
	2495: uint8(0),
	2496: uint8(0),
	2497: uint8(0),
	2498: uint8(0),
	2499: uint8(0),
	2500: uint8(0),
	2501: uint8(0),
	2502: uint8(0),
	2503: uint8(0),
	2504: uint8(0),
	2505: uint8(0),
	2506: uint8(0),
	2507: uint8(0),
	2508: uint8(0),
	2509: uint8(0),
	2510: uint8(0),
	2511: uint8(0),
	2512: uint8(0),
	2513: uint8(0),
	2514: uint8(0),
	2515: uint8(0),
	2516: uint8(0),
	2517: uint8(0),
	2518: uint8(0),
	2519: uint8(0),
	2520: uint8(0),
	2521: uint8(0),
	2522: uint8(0),
	2523: uint8(0),
	2524: uint8(0),
	2525: uint8(0),
	2526: uint8(0),
	2527: uint8(252),
	2528: uint8(0),
	2529: uint8(0),
	2530: uint8(0),
	2531: uint8(0),
	2532: uint8(0),
	2533: uint8(0),
	2534: uint8(0),
	2535: uint8(0),
	2536: uint8(0),
	2537: uint8(0),
	2538: uint8(0),
	2539: uint8(0),
	2540: uint8(255),
	2541: uint8(255),
	2542: uint8(255),
	2543: uint8(127),
	2544: uint8(0),
	2545: uint8(0),
	2546: uint8(0),
	2547: uint8(0),
	2548: uint8(0),
	2549: uint8(0),
	2550: uint8(0),
	2551: uint8(0),
	2552: uint8(0),
	2553: uint8(0),
	2554: uint8(0),
	2555: uint8(0),
	2556: uint8(0),
	2557: uint8(0),
	2558: uint8(0),
	2559: uint8(0),
	2560: uint8(0),
	2561: uint8(0),
	2562: uint8(0),
	2563: uint8(224),
	2564: uint8(127),
	2565: uint8(0),
	2566: uint8(0),
	2567: uint8(0),
	2568: uint8(192),
	2569: uint8(255),
	2570: uint8(255),
	2571: uint8(3),
	2572: uint8(0),
	2573: uint8(0),
	2574: uint8(0),
	2575: uint8(0),
	2576: uint8(0),
	2577: uint8(0),
	2578: uint8(0),
	2579: uint8(0),
	2580: uint8(0),
	2581: uint8(0),
	2582: uint8(0),
	2583: uint8(0),
	2584: uint8(0),
	2585: uint8(0),
	2586: uint8(0),
	2587: uint8(0),
	2588: uint8(0),
	2589: uint8(0),
	2590: uint8(0),
	2591: uint8(0),
	2592: uint8(0),
	2593: uint8(0),
	2594: uint8(0),
	2595: uint8(0),
	2596: uint8(0),
	2597: uint8(0),
	2598: uint8(0),
	2599: uint8(0),
	2600: uint8(192),
	2601: uint8(63),
	2602: uint8(252),
	2603: uint8(255),
	2604: uint8(63),
	2605: uint8(0),
	2606: uint8(0),
	2607: uint8(128),
	2608: uint8(3),
	2609: uint8(0),
	2610: uint8(0),
	2611: uint8(0),
	2612: uint8(0),
	2613: uint8(0),
	2614: uint8(0),
	2615: uint8(254),
	2616: uint8(3),
	2617: uint8(32),
	2618: uint8(0),
	2619: uint8(0),
	2620: uint8(0),
	2621: uint8(0),
	2622: uint8(0),
	2623: uint8(0),
	2624: uint8(0),
	2625: uint8(0),
	2626: uint8(0),
	2627: uint8(0),
	2628: uint8(0),
	2629: uint8(0),
	2630: uint8(24),
	2631: uint8(0),
	2632: uint8(15),
	2633: uint8(0),
	2634: uint8(0),
	2635: uint8(0),
	2636: uint8(0),
	2637: uint8(0),
	2638: uint8(56),
	2639: uint8(0),
	2640: uint8(0),
	2641: uint8(0),
	2642: uint8(0),
	2643: uint8(0),
	2644: uint8(0),
	2645: uint8(0),
	2646: uint8(0),
	2647: uint8(0),
	2648: uint8(225),
	2649: uint8(63),
	2650: uint8(0),
	2651: uint8(232),
	2652: uint8(254),
	2653: uint8(255),
	2654: uint8(31),
	2655: uint8(0),
	2656: uint8(0),
	2657: uint8(0),
	2658: uint8(0),
	2659: uint8(0),
	2660: uint8(0),
	2661: uint8(0),
	2662: uint8(96),
	2663: uint8(63),
	2664: uint8(0),
	2665: uint8(0),
	2666: uint8(0),
	2667: uint8(0),
	2668: uint8(0),
	2669: uint8(0),
	2670: uint8(0),
	2671: uint8(0),
	2672: uint8(0),
	2673: uint8(0),
	2674: uint8(0),
	2675: uint8(0),
	2676: uint8(0),
	2677: uint8(2),
	2678: uint8(0),
	2679: uint8(0),
	2680: uint8(0),
	2681: uint8(0),
	2682: uint8(0),
	2683: uint8(0),
	2684: uint8(0),
	2685: uint8(6),
	2686: uint8(0),
	2687: uint8(0),
	2688: uint8(0),
	2689: uint8(0),
	2690: uint8(0),
	2691: uint8(0),
	2692: uint8(0),
	2693: uint8(0),
	2694: uint8(0),
	2695: uint8(24),
	2696: uint8(0),
	2697: uint8(32),
	2698: uint8(0),
	2699: uint8(0),
	2700: uint8(192),
	2701: uint8(31),
	2702: uint8(31),
	2703: uint8(0),
	2704: uint8(0),
	2705: uint8(0),
	2706: uint8(0),
	2707: uint8(0),
	2708: uint8(0),
	2709: uint8(0),
	2710: uint8(0),
	2711: uint8(0),
	2712: uint8(0),
	2713: uint8(0),
	2714: uint8(0),
	2715: uint8(0),
	2716: uint8(0),
	2717: uint8(0),
	2718: uint8(0),
	2719: uint8(0),
	2720: uint8(0),
	2721: uint8(0),
	2722: uint8(0),
	2723: uint8(0),
	2724: uint8(0),
	2725: uint8(0),
	2726: uint8(0),
	2727: uint8(0),
	2728: uint8(68),
	2729: uint8(248),
	2730: uint8(0),
	2731: uint8(104),
	2732: uint8(0),
	2733: uint8(0),
	2734: uint8(0),
	2735: uint8(0),
	2736: uint8(0),
	2737: uint8(0),
	2738: uint8(0),
	2739: uint8(0),
	2740: uint8(0),
	2741: uint8(0),
	2742: uint8(0),
	2743: uint8(0),
	2744: uint8(76),
	2745: uint8(0),
	2746: uint8(0),
	2747: uint8(0),
	2748: uint8(0),
	2749: uint8(0),
	2750: uint8(0),
	2751: uint8(0),
	2752: uint8(0),
	2753: uint8(0),
	2754: uint8(0),
	2755: uint8(0),
	2756: uint8(0),
	2757: uint8(0),
	2758: uint8(0),
	2759: uint8(0),
	2760: uint8(0),
	2761: uint8(0),
	2762: uint8(0),
	2763: uint8(0),
	2764: uint8(0),
	2765: uint8(0),
	2766: uint8(0),
	2767: uint8(0),
	2768: uint8(0),
	2769: uint8(0),
	2770: uint8(0),
	2771: uint8(0),
	2772: uint8(0),
	2773: uint8(0),
	2774: uint8(0),
	2775: uint8(128),
	2776: uint8(255),
	2777: uint8(255),
	2778: uint8(255),
	2779: uint8(0),
	2780: uint8(0),
	2781: uint8(0),
	2782: uint8(0),
	2783: uint8(0),
	2784: uint8(0),
	2785: uint8(0),
	2786: uint8(0),
	2787: uint8(0),
	2788: uint8(0),
	2789: uint8(0),
	2790: uint8(0),
	2791: uint8(128),
	2792: uint8(14),
	2793: uint8(0),
	2794: uint8(0),
	2795: uint8(0),
	2796: uint8(255),
	2797: uint8(31),
	2798: uint8(0),
	2799: uint8(0),
	2800: uint8(0),
	2801: uint8(0),
	2802: uint8(0),
	2803: uint8(0),
	2804: uint8(0),
	2805: uint8(0),
	2806: uint8(192),
	2807: uint8(0),
	2808: uint8(0),
	2809: uint8(0),
	2810: uint8(0),
	2811: uint8(0),
	2812: uint8(0),
	2813: uint8(0),
	2814: uint8(0),
	2815: uint8(0),
	2816: uint8(0),
	2817: uint8(0),
	2818: uint8(0),
	2819: uint8(0),
	2820: uint8(0),
	2821: uint8(8),
	2822: uint8(0),
	2823: uint8(252),
	2824: uint8(0),
	2825: uint8(0),
	2826: uint8(0),
	2827: uint8(0),
	2828: uint8(0),
	2829: uint8(0),
	2830: uint8(0),
	2831: uint8(0),
	2832: uint8(0),
	2833: uint8(0),
	2834: uint8(0),
	2835: uint8(0),
	2836: uint8(0),
	2837: uint8(0),
	2838: uint8(0),
	2839: uint8(0),
	2840: uint8(0),
	2841: uint8(0),
	2842: uint8(0),
	2843: uint8(0),
	2844: uint8(0),
	2845: uint8(0),
	2846: uint8(0),
	2847: uint8(0),
	2848: uint8(0),
	2849: uint8(0),
	2850: uint8(0),
	2851: uint8(0),
	2852: uint8(0),
	2853: uint8(0),
	2854: uint8(0),
	2855: uint8(14),
	2856: uint8(0),
	2857: uint8(0),
	2858: uint8(0),
	2859: uint8(0),
	2860: uint8(0),
	2861: uint8(0),
	2862: uint8(0),
	2863: uint8(0),
	2864: uint8(0),
	2865: uint8(0),
	2866: uint8(0),
	2867: uint8(0),
	2868: uint8(0),
	2869: uint8(0),
	2870: uint8(0),
	2871: uint8(0),
	2872: uint8(0),
	2873: uint8(0),
	2874: uint8(0),
	2875: uint8(0),
	2876: uint8(0),
	2877: uint8(252),
	2878: uint8(7),
	2879: uint8(0),
	2880: uint8(0),
	2881: uint8(0),
	2882: uint8(0),
	2883: uint8(0),
	2884: uint8(0),
	2885: uint8(0),
	2886: uint8(0),
	2887: uint8(0),
	2888: uint8(0),
	2889: uint8(0),
	2890: uint8(0),
	2891: uint8(0),
	2892: uint8(0),
	2893: uint8(0),
	2894: uint8(0),
	2895: uint8(0),
	2896: uint8(0),
	2897: uint8(0),
	2898: uint8(0),
	2899: uint8(0),
	2900: uint8(0),
	2901: uint8(0),
	2902: uint8(0),
	2903: uint8(0),
	2904: uint8(0),
	2905: uint8(0),
	2906: uint8(0),
	2907: uint8(0),
	2908: uint8(5),
	2909: uint8(0),
	2910: uint8(0),
	2911: uint8(0),
	2912: uint8(0),
	2913: uint8(0),
	2914: uint8(0),
	2915: uint8(0),
	2916: uint8(0),
	2917: uint8(0),
	2918: uint8(24),
	2919: uint8(128),
	2920: uint8(255),
	2921: uint8(0),
	2922: uint8(0),
	2923: uint8(0),
	2924: uint8(0),
	2925: uint8(0),
	2926: uint8(0),
	2927: uint8(0),
	2928: uint8(0),
	2929: uint8(0),
	2930: uint8(0),
	2931: uint8(223),
	2932: uint8(7),
	2933: uint8(0),
	2934: uint8(0),
	2935: uint8(0),
	2936: uint8(0),
	2937: uint8(0),
	2938: uint8(0),
	2939: uint8(0),
	2940: uint8(0),
	2941: uint8(0),
	2942: uint8(0),
	2943: uint8(0),
	2944: uint8(0),
	2945: uint8(0),
	2946: uint8(0),
	2947: uint8(0),
	2948: uint8(0),
	2949: uint8(0),
	2950: uint8(0),
	2951: uint8(128),
	2952: uint8(62),
	2953: uint8(0),
	2954: uint8(0),
	2955: uint8(252),
	2956: uint8(255),
	2957: uint8(31),
	2958: uint8(3),
	2959: uint8(0),
	2960: uint8(0),
	2961: uint8(0),
	2962: uint8(0),
	2963: uint8(0),
	2964: uint8(0),
	2965: uint8(0),
	2966: uint8(0),
	2967: uint8(0),
	2968: uint8(0),
	2969: uint8(0),
	2970: uint8(0),
	2971: uint8(0),
	2972: uint8(0),
	2973: uint8(0),
	2974: uint8(0),
	2975: uint8(0),
	2976: uint8(0),
	2977: uint8(0),
	2978: uint8(0),
	2979: uint8(0),
	2980: uint8(0),
	2981: uint8(0),
	2982: uint8(0),
	2983: uint8(0),
	2984: uint8(52),
	2985: uint8(0),
	2986: uint8(0),
	2987: uint8(0),
	2988: uint8(0),
	2989: uint8(0),
	2990: uint8(0),
	2991: uint8(0),
	2992: uint8(0),
	2993: uint8(0),
	2994: uint8(128),
	2995: uint8(0),
	2996: uint8(0),
	2997: uint8(0),
	2998: uint8(0),
	2999: uint8(0),
	3000: uint8(0),
	3001: uint8(0),
	3002: uint8(0),
	3003: uint8(0),
	3004: uint8(0),
	3005: uint8(0),
	3006: uint8(0),
	3007: uint8(0),
	3008: uint8(0),
	3009: uint8(0),
	3010: uint8(0),
	3011: uint8(0),
	3012: uint8(0),
	3013: uint8(0),
	3014: uint8(0),
	3015: uint8(0),
	3016: uint8(0),
	3017: uint8(0),
	3018: uint8(0),
	3019: uint8(0),
	3020: uint8(0),
	3021: uint8(0),
	3022: uint8(0),
	3023: uint8(0),
	3024: uint8(0),
	3025: uint8(0),
	3026: uint8(0),
	3027: uint8(0),
	3028: uint8(0),
	3029: uint8(0),
	3030: uint8(0),
	3031: uint8(0),
	3032: uint8(0),
	3033: uint8(0),
	3034: uint8(0),
	3035: uint8(0),
	3036: uint8(0),
	3037: uint8(0),
	3038: uint8(128),
	3039: uint8(1),
	3040: uint8(0),
	3041: uint8(0),
	3042: uint8(0),
	3043: uint8(0),
	3044: uint8(0),
	3045: uint8(0),
	3046: uint8(0),
	3047: uint8(0),
	3048: uint8(0),
	3049: uint8(0),
	3050: uint8(0),
	3051: uint8(0),
	3052: uint8(0),
	3053: uint8(0),
	3054: uint8(0),
	3055: uint8(0),
	3056: uint8(0),
	3057: uint8(0),
	3058: uint8(0),
	3059: uint8(0),
	3060: uint8(0),
	3061: uint8(0),
	3062: uint8(0),
	3063: uint8(0),
	3064: uint8(255),
	3065: uint8(255),
	3066: uint8(255),
	3067: uint8(255),
	3068: uint8(255),
	3069: uint8(255),
	3070: uint8(3),
	3071: uint8(128),
	3072: uint8(0),
	3073: uint8(0),
	3074: uint8(0),
	3075: uint8(0),
	3076: uint8(0),
	3077: uint8(0),
	3078: uint8(0),
	3079: uint8(0),
	3080: uint8(0),
	3081: uint8(0),
	3082: uint8(0),
	3083: uint8(0),
	3084: uint8(0),
	3085: uint8(0),
	3086: uint8(31),
	3087: uint8(0),
	3088: uint8(0),
	3089: uint8(0),
	3090: uint8(0),
	3091: uint8(0),
	3092: uint8(0),
	3093: uint8(0),
	3094: uint8(0),
	3095: uint8(0),
	3096: uint8(0),
	3097: uint8(0),
	3098: uint8(0),
	3099: uint8(0),
	3100: uint8(0),
	3101: uint8(0),
	3102: uint8(0),
	3103: uint8(0),
	3104: uint8(0),
	3105: uint8(0),
	3106: uint8(0),
	3107: uint8(0),
	3108: uint8(0),
	3109: uint8(0),
	3110: uint8(255),
	3111: uint8(1),
	3112: uint8(0),
	3113: uint8(0),
	3114: uint8(0),
	3115: uint8(0),
	3116: uint8(0),
	3117: uint8(0),
	3118: uint8(0),
	3119: uint8(0),
	3120: uint8(0),
	3121: uint8(0),
	3122: uint8(0),
	3123: uint8(0),
	3124: uint8(0),
	3125: uint8(0),
	3126: uint8(0),
	3127: uint8(0),
	3128: uint8(0),
	3129: uint8(0),
	3130: uint8(0),
	3131: uint8(0),
	3132: uint8(0),
	3133: uint8(0),
	3134: uint8(0),
	3135: uint8(0),
	3136: uint8(0),
	3137: uint8(0),
	3138: uint8(0),
	3139: uint8(0),
	3140: uint8(0),
	3141: uint8(0),
	3142: uint8(0),
	3143: uint8(0),
	3144: uint8(0),
	3145: uint8(0),
	3146: uint8(0),
	3147: uint8(0),
	3148: uint8(0),
	3149: uint8(192),
	3150: uint8(0),
	3151: uint8(0),
	3152: uint8(0),
	3153: uint8(0),
	3154: uint8(0),
	3155: uint8(0),
	3156: uint8(0),
	3157: uint8(0),
	3158: uint8(0),
	3159: uint8(0),
	3160: uint8(0),
	3161: uint8(0),
	3162: uint8(0),
	3163: uint8(0),
	3164: uint8(0),
	3165: uint8(0),
	3166: uint8(63),
	3167: uint8(0),
	3168: uint8(0),
	3169: uint8(0),
	3170: uint8(0),
	3171: uint8(0),
	3172: uint8(0),
	3173: uint8(0),
	3174: uint8(255),
	3175: uint8(255),
	3176: uint8(48),
	3177: uint8(0),
	3178: uint8(0),
	3179: uint8(248),
	3180: uint8(3),
	3181: uint8(0),
	3182: uint8(0),
	3183: uint8(0),
	3184: uint8(0),
	3185: uint8(0),
	3186: uint8(0),
	3187: uint8(0),
	3188: uint8(0),
	3189: uint8(0),
	3190: uint8(0),
	3191: uint8(0),
	3192: uint8(0),
	3193: uint8(0),
	3194: uint8(0),
	3195: uint8(0),
	3196: uint8(0),
	3197: uint8(0),
	3198: uint8(0),
	3199: uint8(0),
	3200: uint8(0),
	3201: uint8(0),
	3202: uint8(0),
	3203: uint8(0),
	3204: uint8(0),
	3205: uint8(0),
	3206: uint8(0),
	3207: uint8(0),
	3208: uint8(0),
	3209: uint8(0),
	3210: uint8(0),
	3211: uint8(0),
	3212: uint8(0),
	3213: uint8(0),
	3214: uint8(0),
	3215: uint8(0),
	3216: uint8(255),
	3217: uint8(255),
	3218: uint8(255),
	3219: uint8(7),
	3220: uint8(0),
	3221: uint8(0),
	3222: uint8(0),
	3223: uint8(0),
	3224: uint8(0),
	3225: uint8(0),
	3226: uint8(0),
	3227: uint8(0),
	3228: uint8(0),
	3229: uint8(0),
	3230: uint8(0),
	3231: uint8(0),
	3232: uint8(0),
	3233: uint8(0),
	3234: uint8(0),
	3235: uint8(0),
	3236: uint8(0),
	3237: uint8(0),
	3238: uint8(0),
	3239: uint8(0),
	3240: uint8(0),
	3241: uint8(0),
	3242: uint8(0),
	3243: uint8(0),
	3244: uint8(0),
	3245: uint8(0),
	3246: uint8(0),
	3247: uint8(0),
	3248: uint8(0),
	3249: uint8(0),
	3250: uint8(0),
	3251: uint8(0),
	3252: uint8(0),
	3253: uint8(0),
	3254: uint8(0),
	3255: uint8(0),
	3256: uint8(0),
	3257: uint8(0),
	3258: uint8(0),
	3259: uint8(0),
	3260: uint8(4),
	3261: uint8(0),
	3262: uint8(0),
	3263: uint8(0),
	3264: uint8(0),
	3265: uint8(0),
	3266: uint8(0),
	3267: uint8(0),
	3268: uint8(0),
	3269: uint8(0),
	3270: uint8(0),
	3271: uint8(0),
	3272: uint8(0),
	3273: uint8(0),
	3274: uint8(0),
	3275: uint8(0),
	3276: uint8(0),
	3277: uint8(0),
	3278: uint8(0),
	3279: uint8(0),
	3280: uint8(0),
	3281: uint8(0),
	3282: uint8(0),
	3283: uint8(176),
	3284: uint8(15),
	3285: uint8(0),
	3286: uint8(0),
	3287: uint8(0),
	3288: uint8(0),
	3289: uint8(0),
	3290: uint8(0),
	3291: uint8(0),
	3292: uint8(0),
	3293: uint8(0),
	3294: uint8(0),
	3295: uint8(0),
	3296: uint8(255),
	3297: uint8(255),
	3298: uint8(255),
	3299: uint8(255),
	3300: uint8(255),
	3301: uint8(255),
	3302: uint8(255),
	3303: uint8(255),
	3304: uint8(255),
	3305: uint8(255),
	3306: uint8(255),
	3307: uint8(255),
	3308: uint8(255),
	3309: uint8(255),
	3310: uint8(255),
	3311: uint8(255),
	3312: uint8(255),
	3313: uint8(255),
	3314: uint8(255),
	3315: uint8(255),
	3316: uint8(255),
	3317: uint8(255),
	3318: uint8(255),
	3319: uint8(255),
	3320: uint8(255),
	3321: uint8(255),
	3322: uint8(255),
	3323: uint8(255),
	3324: uint8(255),
	3325: uint8(255),
	3326: uint8(63),
	3327: uint8(0),
	3328: uint8(255),
	3329: uint8(255),
	3330: uint8(255),
	3331: uint8(255),
	3332: uint8(127),
	3333: uint8(254),
	3334: uint8(255),
	3335: uint8(255),
	3336: uint8(255),
	3337: uint8(255),
	3338: uint8(255),
	3339: uint8(255),
	3340: uint8(255),
	3341: uint8(255),
	3342: uint8(255),
	3343: uint8(255),
	3344: uint8(255),
	3345: uint8(255),
	3346: uint8(255),
	3347: uint8(255),
	3348: uint8(255),
	3349: uint8(255),
	3350: uint8(255),
	3351: uint8(255),
	3352: uint8(255),
	3353: uint8(255),
	3354: uint8(255),
	3355: uint8(255),
	3356: uint8(255),
	3357: uint8(1),
	3358: uint8(0),
	3359: uint8(0),
	3360: uint8(255),
	3361: uint8(255),
	3362: uint8(255),
	3363: uint8(255),
	3364: uint8(255),
	3365: uint8(255),
	3366: uint8(255),
	3367: uint8(255),
	3368: uint8(63),
	3369: uint8(0),
	3370: uint8(0),
	3371: uint8(0),
	3372: uint8(0),
	3373: uint8(0),
	3374: uint8(0),
	3375: uint8(0),
	3376: uint8(0),
	3377: uint8(0),
	3378: uint8(0),
	3379: uint8(0),
	3380: uint8(0),
	3381: uint8(0),
	3382: uint8(0),
	3383: uint8(0),
	3384: uint8(0),
	3385: uint8(0),
	3386: uint8(0),
	3387: uint8(0),
	3388: uint8(255),
	3389: uint8(255),
	3390: uint8(15),
	3391: uint8(0),
	3392: uint8(255),
	3393: uint8(255),
	3394: uint8(255),
	3395: uint8(255),
	3396: uint8(255),
	3397: uint8(255),
	3398: uint8(255),
	3399: uint8(255),
	3400: uint8(255),
	3401: uint8(255),
	3402: uint8(127),
	3403: uint8(0),
	3404: uint8(255),
	3405: uint8(255),
	3406: uint8(255),
	3407: uint8(1),
	3408: uint8(0),
	3409: uint8(0),
	3410: uint8(0),
	3411: uint8(0),
	3412: uint8(0),
	3413: uint8(0),
	3414: uint8(0),
	3415: uint8(0),
	3416: uint8(0),
	3417: uint8(0),
	3418: uint8(0),
	3419: uint8(0),
	3420: uint8(0),
	3421: uint8(0),
	3422: uint8(0),
	3423: uint8(0),
	3424: uint8(0),
	3425: uint8(0),
	3426: uint8(0),
	3427: uint8(0),
	3428: uint8(0),
	3429: uint8(0),
	3430: uint8(0),
	3431: uint8(0),
	3432: uint8(0),
	3433: uint8(0),
	3434: uint8(0),
	3435: uint8(0),
	3436: uint8(0),
	3437: uint8(0),
	3438: uint8(0),
	3439: uint8(0),
	3440: uint8(0),
	3441: uint8(0),
	3442: uint8(0),
	3443: uint8(0),
	3444: uint8(0),
	3445: uint8(0),
	3446: uint8(0),
	3447: uint8(0),
	3448: uint8(2),
	3449: uint8(0),
	3450: uint8(0),
	3451: uint8(8),
	3452: uint8(0),
	3453: uint8(0),
	3454: uint8(0),
	3455: uint8(8),
	3456: uint8(0),
	3457: uint8(0),
	3458: uint8(32),
	3459: uint8(0),
	3460: uint8(0),
	3461: uint8(0),
	3462: uint8(32),
	3463: uint8(0),
	3464: uint8(0),
	3465: uint8(128),
	3466: uint8(0),
	3467: uint8(0),
	3468: uint8(0),
	3469: uint8(128),
	3470: uint8(0),
	3471: uint8(0),
	3472: uint8(0),
	3473: uint8(2),
	3474: uint8(0),
	3475: uint8(0),
	3476: uint8(0),
	3477: uint8(2),
	3478: uint8(0),
	3479: uint8(0),
	3480: uint8(8),
	3481: uint8(0),
	3482: uint8(0),
	3483: uint8(0),
	3484: uint8(0),
	3485: uint8(0),
	3486: uint8(0),
	3487: uint8(0),
	3488: uint8(255),
	3489: uint8(255),
	3490: uint8(255),
	3491: uint8(255),
	3492: uint8(255),
	3493: uint8(255),
	3494: uint8(255),
	3495: uint8(255),
	3496: uint8(255),
	3497: uint8(255),
	3498: uint8(255),
	3499: uint8(255),
	3500: uint8(255),
	3501: uint8(255),
	3502: uint8(255),
	3503: uint8(255),
	3504: uint8(255),
	3505: uint8(15),
	3506: uint8(0),
	3507: uint8(248),
	3508: uint8(254),
	3509: uint8(255),
	3510: uint8(0),
	3511: uint8(0),
	3512: uint8(0),
	3513: uint8(0),
	3514: uint8(0),
	3515: uint8(0),
	3516: uint8(0),
	3517: uint8(0),
	3518: uint8(0),
	3519: uint8(0),
	3520: uint8(0),
	3521: uint8(0),
	3522: uint8(0),
	3523: uint8(0),
	3524: uint8(0),
	3525: uint8(0),
	3526: uint8(127),
	3527: uint8(0),
	3528: uint8(0),
	3529: uint8(128),
	3530: uint8(0),
	3531: uint8(0),
	3532: uint8(0),
	3533: uint8(0),
	3534: uint8(0),
	3535: uint8(0),
	3536: uint8(0),
	3537: uint8(0),
	3538: uint8(0),
	3539: uint8(0),
	3540: uint8(0),
	3541: uint8(0),
	3542: uint8(0),
	3543: uint8(0),
	3544: uint8(0),
	3545: uint8(0),
	3546: uint8(0),
	3547: uint8(0),
	3548: uint8(0),
	3549: uint8(0),
	3550: uint8(0),
	3551: uint8(0),
	3552: uint8(0),
	3553: uint8(0),
	3554: uint8(0),
	3555: uint8(0),
	3556: uint8(0),
	3557: uint8(0),
	3558: uint8(0),
	3559: uint8(0),
	3560: uint8(0),
	3561: uint8(0),
	3562: uint8(0),
	3563: uint8(0),
	3564: uint8(0),
	3565: uint8(0),
	3566: uint8(0),
	3567: uint8(0),
	3568: uint8(0),
	3569: uint8(0),
	3570: uint8(0),
	3571: uint8(0),
	3572: uint8(0),
	3573: uint8(0),
	3574: uint8(0),
	3575: uint8(0),
	3576: uint8(0),
	3577: uint8(0),
	3578: uint8(0),
	3579: uint8(0),
	3580: uint8(0),
	3581: uint8(240),
	3582: uint8(0),
	3583: uint8(128),
	3584: uint8(0),
	3585: uint8(0),
	3586: uint8(0),
	3587: uint8(0),
	3588: uint8(0),
	3589: uint8(0),
	3590: uint8(0),
	3591: uint8(0),
	3592: uint8(0),
	3593: uint8(0),
	3594: uint8(0),
	3595: uint8(0),
	3596: uint8(0),
	3597: uint8(0),
	3598: uint8(0),
	3599: uint8(0),
	3600: uint8(0),
	3601: uint8(0),
	3602: uint8(0),
	3603: uint8(0),
	3604: uint8(0),
	3605: uint8(0),
	3606: uint8(0),
	3607: uint8(0),
	3608: uint8(128),
	3609: uint8(255),
	3610: uint8(127),
	3611: uint8(0),
	3612: uint8(0),
	3613: uint8(0),
	3614: uint8(0),
	3615: uint8(0),
	3616: uint8(0),
	3617: uint8(0),
	3618: uint8(0),
	3619: uint8(0),
	3620: uint8(0),
	3621: uint8(0),
	3622: uint8(0),
	3623: uint8(0),
	3624: uint8(112),
	3625: uint8(7),
	3626: uint8(0),
	3627: uint8(192),
	3628: uint8(0),
	3629: uint8(0),
	3630: uint8(0),
	3631: uint8(0),
	3632: uint8(0),
	3633: uint8(0),
	3634: uint8(0),
	3635: uint8(0),
	3636: uint8(0),
	3637: uint8(0),
	3638: uint8(0),
	3639: uint8(0),
	3640: uint8(0),
	3641: uint8(0),
	3642: uint8(0),
	3643: uint8(0),
	3644: uint8(0),
	3645: uint8(0),
	3646: uint8(0),
	3647: uint8(0),
	3648: uint8(0),
	3649: uint8(0),
	3650: uint8(0),
	3651: uint8(0),
	3652: uint8(0),
	3653: uint8(0),
	3654: uint8(0),
	3655: uint8(0),
	3656: uint8(0),
	3657: uint8(0),
	3658: uint8(0),
	3659: uint8(0),
	3660: uint8(0),
	3661: uint8(0),
	3662: uint8(254),
	3663: uint8(255),
	3664: uint8(255),
	3665: uint8(255),
	3666: uint8(255),
	3667: uint8(255),
	3668: uint8(255),
	3669: uint8(255),
	3670: uint8(31),
	3671: uint8(0),
	3672: uint8(0),
	3673: uint8(0),
	3674: uint8(0),
	3675: uint8(0),
	3676: uint8(0),
	3677: uint8(0),
	3678: uint8(0),
	3679: uint8(0),
	3680: uint8(254),
	3681: uint8(255),
	3682: uint8(255),
	3683: uint8(255),
	3684: uint8(255),
	3685: uint8(255),
	3686: uint8(255),
	3687: uint8(63),
	3688: uint8(0),
	3689: uint8(0),
	3690: uint8(0),
	3691: uint8(0),
	3692: uint8(0),
	3693: uint8(0),
	3694: uint8(0),
	3695: uint8(0),
	3696: uint8(0),
	3697: uint8(0),
	3698: uint8(0),
	3699: uint8(0),
	3700: uint8(0),
	3701: uint8(0),
	3702: uint8(0),
	3703: uint8(0),
	3704: uint8(0),
	3705: uint8(0),
	3706: uint8(0),
	3707: uint8(0),
	3708: uint8(0),
	3709: uint8(0),
	3710: uint8(0),
	3711: uint8(0),
	3712: uint8(0),
	3713: uint8(0),
	3714: uint8(0),
	3715: uint8(0),
	3716: uint8(0),
	3717: uint8(0),
	3718: uint8(0),
	3719: uint8(0),
	3720: uint8(0),
	3721: uint8(0),
	3722: uint8(0),
	3723: uint8(0),
	3724: uint8(0),
	3725: uint8(0),
	3726: uint8(0),
	3727: uint8(0),
	3728: uint8(0),
	3729: uint8(0),
	3730: uint8(0),
	3731: uint8(0),
	3732: uint8(0),
	3733: uint8(0),
	3734: uint8(0),
	3735: uint8(0),
	3736: uint8(0),
	3737: uint8(0),
	3738: uint8(0),
	3739: uint8(0),
	3740: uint8(0),
	3741: uint8(0),
	3742: uint8(3),
	3743: uint8(0),
	3744: uint8(255),
	3745: uint8(255),
	3746: uint8(255),
	3747: uint8(255),
	3748: uint8(255),
	3749: uint8(15),
	3750: uint8(255),
	3751: uint8(255),
	3752: uint8(255),
	3753: uint8(255),
	3754: uint8(255),
	3755: uint8(255),
	3756: uint8(255),
	3757: uint8(255),
	3758: uint8(255),
	3759: uint8(255),
	3760: uint8(255),
	3761: uint8(255),
	3762: uint8(15),
	3763: uint8(0),
	3764: uint8(255),
	3765: uint8(127),
	3766: uint8(254),
	3767: uint8(255),
	3768: uint8(254),
	3769: uint8(255),
	3770: uint8(254),
	3771: uint8(255),
	3772: uint8(255),
	3773: uint8(255),
	3774: uint8(63),
	3775: uint8(0),
	3776: uint8(255),
	3777: uint8(31),
	3778: uint8(255),
	3779: uint8(255),
	3780: uint8(255),
	3781: uint8(255),
	3782: uint8(0),
	3783: uint8(0),
	3784: uint8(0),
	3785: uint8(252),
	3786: uint8(0),
	3787: uint8(0),
	3788: uint8(0),
	3789: uint8(28),
	3790: uint8(0),
	3791: uint8(0),
	3792: uint8(0),
	3793: uint8(252),
	3794: uint8(255),
	3795: uint8(255),
	3796: uint8(255),
	3797: uint8(31),
	3798: uint8(0),
	3799: uint8(0),
	3800: uint8(0),
	3801: uint8(0),
	3802: uint8(0),
	3803: uint8(0),
	3804: uint8(192),
	3805: uint8(255),
	3806: uint8(255),
	3807: uint8(255),
	3808: uint8(7),
	3809: uint8(0),
	3810: uint8(255),
	3811: uint8(255),
	3812: uint8(255),
	3813: uint8(255),
	3814: uint8(255),
	3815: uint8(15),
	3816: uint8(255),
	3817: uint8(1),
	3818: uint8(3),
	3819: uint8(0),
	3820: uint8(63),
	3821: uint8(0),
	3822: uint8(0),
	3823: uint8(0),
	3824: uint8(0),
	3825: uint8(0),
	3826: uint8(0),
	3827: uint8(0),
	3828: uint8(0),
	3829: uint8(0),
	3830: uint8(0),
	3831: uint8(0),
	3832: uint8(0),
	3833: uint8(0),
	3834: uint8(0),
	3835: uint8(0),
	3836: uint8(0),
	3837: uint8(0),
	3838: uint8(0),
	3839: uint8(0),
	3840: uint8(255),
	3841: uint8(255),
	3842: uint8(255),
	3843: uint8(255),
	3844: uint8(255),
	3845: uint8(255),
	3846: uint8(255),
	3847: uint8(255),
	3848: uint8(255),
	3849: uint8(255),
	3850: uint8(255),
	3851: uint8(255),
	3852: uint8(255),
	3853: uint8(255),
	3854: uint8(255),
	3855: uint8(255),
	3856: uint8(255),
	3857: uint8(255),
	3858: uint8(255),
	3859: uint8(255),
	3860: uint8(255),
	3861: uint8(255),
	3862: uint8(255),
	3863: uint8(255),
	3864: uint8(255),
	3865: uint8(255),
	3866: uint8(63),
	3867: uint8(0),
	3868: uint8(255),
	3869: uint8(31),
	3870: uint8(255),
	3871: uint8(7),
	3872: uint8(255),
	3873: uint8(255),
	3874: uint8(255),
	3875: uint8(255),
	3876: uint8(255),
	3877: uint8(255),
	3878: uint8(255),
	3879: uint8(255),
	3880: uint8(255),
	3881: uint8(255),
	3882: uint8(255),
	3883: uint8(255),
	3884: uint8(255),
	3885: uint8(255),
	3886: uint8(15),
	3887: uint8(0),
	3888: uint8(255),
	3889: uint8(255),
	3890: uint8(255),
	3891: uint8(255),
	3892: uint8(255),
	3893: uint8(255),
	3894: uint8(255),
	3895: uint8(255),
	3896: uint8(255),
	3897: uint8(255),
	3898: uint8(255),
	3899: uint8(1),
	3900: uint8(255),
	3901: uint8(15),
	3902: uint8(0),
	3903: uint8(0),
	3904: uint8(255),
	3905: uint8(15),
	3906: uint8(255),
	3907: uint8(255),
	3908: uint8(255),
	3909: uint8(255),
	3910: uint8(255),
	3911: uint8(255),
	3912: uint8(255),
	3913: uint8(0),
	3914: uint8(255),
	3915: uint8(3),
	3916: uint8(255),
	3917: uint8(255),
	3918: uint8(255),
	3919: uint8(255),
	3920: uint8(255),
	3921: uint8(0),
	3922: uint8(255),
	3923: uint8(255),
	3924: uint8(255),
	3925: uint8(63),
	3926: uint8(0),
	3927: uint8(0),
	3928: uint8(0),
	3929: uint8(0),
	3930: uint8(0),
	3931: uint8(0),
	3932: uint8(0),
	3933: uint8(0),
	3934: uint8(0),
	3935: uint8(0),
	3936: uint8(255),
	3937: uint8(239),
	3938: uint8(255),
	3939: uint8(255),
	3940: uint8(255),
	3941: uint8(255),
	3942: uint8(255),
	3943: uint8(255),
	3944: uint8(255),
	3945: uint8(255),
	3946: uint8(255),
	3947: uint8(255),
	3948: uint8(255),
	3949: uint8(255),
	3950: uint8(123),
	3951: uint8(252),
	3952: uint8(255),
	3953: uint8(255),
	3954: uint8(255),
	3955: uint8(255),
	3956: uint8(231),
	3957: uint8(199),
	3958: uint8(255),
	3959: uint8(255),
	3960: uint8(255),
	3961: uint8(231),
	3962: uint8(255),
	3963: uint8(255),
	3964: uint8(255),
	3965: uint8(255),
	3966: uint8(255),
	3967: uint8(255),
	3968: uint8(255),
	3969: uint8(255),
	3970: uint8(255),
	3971: uint8(255),
	3972: uint8(255),
	3973: uint8(255),
	3974: uint8(255),
	3975: uint8(255),
	3976: uint8(255),
	3977: uint8(255),
	3978: uint8(15),
	3979: uint8(0),
	3980: uint8(255),
	3981: uint8(63),
	3982: uint8(15),
	3983: uint8(7),
	3984: uint8(7),
	3985: uint8(0),
	3986: uint8(63),
	3987: uint8(0),
	3988: uint8(0),
	3989: uint8(0),
	3990: uint8(0),
	3991: uint8(0),
	3992: uint8(0),
	3993: uint8(0),
	3994: uint8(0),
	3995: uint8(0),
	3996: uint8(0),
	3997: uint8(0),
	3998: uint8(0),
	3999: uint8(0)}

func x_iswpunct(tls *TLS, wc Twint_t) (r int32) {
	if wc < uint32(0x20000) {
		return int32(_table4[uint32(int32(_table4[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)]) >> (wc & uint32(7)) & int32(1)
	}
	return int32(0)
}

func x___iswpunct_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswpunct(tls, c)
}

type Tmbstate_t = struct {
	F__opaque1 uint32
	F__opaque2 uint32
}

type T__mbstate_t = Tmbstate_t

func x_iswspace(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(wc != 0 && x_wcschr(tls, uintptr(unsafe.Pointer(&_spaces)), int32(wc)) != 0)
}

var _spaces = [22]Twchar_t{
	0:  int32(' '),
	1:  int32('\t'),
	2:  int32('\n'),
	3:  int32('\r'),
	4:  int32(11),
	5:  int32(12),
	6:  int32(0x0085),
	7:  int32(0x2000),
	8:  int32(0x2001),
	9:  int32(0x2002),
	10: int32(0x2003),
	11: int32(0x2004),
	12: int32(0x2005),
	13: int32(0x2006),
	14: int32(0x2008),
	15: int32(0x2009),
	16: int32(0x200a),
	17: int32(0x2028),
	18: int32(0x2029),
	19: int32(0x205f),
	20: int32(0x3000),
	21: int32(0)}

func x___iswspace_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswspace(tls, c)
}

func x_iswupper(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(x_towlower(tls, wc) != wc)
}

func x___iswupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswupper(tls, c)
}

func x_iswxdigit(tls *TLS, wc Twint_t) (r int32) {
	return BoolInt32(wc-Uint32FromUint8('0') < uint32(10) || wc|Uint32FromInt32(32)-Uint32FromUint8('a') < uint32(6))
}

func x___iswxdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	return x_iswxdigit(tls, c)
}

func x_isxdigit(tls *TLS, c int32) (r int32) {
	return BoolInt32(BoolInt32(uint32(c)-uint32('0') < uint32(10)) != 0 || uint32(c)|uint32(32)-uint32('a') < uint32(6))
}

func x___isxdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_isxdigit(tls, c)
}

// C documentation
//
//	/* nonsense function that should NEVER be used! */
func x_toascii(tls *TLS, c int32) (r int32) {
	return c & int32(0x7f)
}

func x_tolower(tls *TLS, c int32) (r int32) {
	if BoolInt32(uint32(c)-uint32('A') < uint32(26)) != 0 {
		return c | int32(32)
	}
	return c
}

func x___tolower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_tolower(tls, c)
}

func x_toupper(tls *TLS, c int32) (r int32) {
	if BoolInt32(uint32(c)-uint32('a') < uint32(26)) != 0 {
		return c & int32(0x5f)
	}
	return c
}

func x___toupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	return x_toupper(tls, c)
}

var _tab1 = [2666]uint8{
	0:    uint8(7),
	1:    uint8(8),
	2:    uint8(9),
	3:    uint8(10),
	4:    uint8(11),
	5:    uint8(12),
	6:    uint8(6),
	7:    uint8(6),
	8:    uint8(6),
	9:    uint8(6),
	10:   uint8(6),
	11:   uint8(6),
	12:   uint8(6),
	13:   uint8(6),
	14:   uint8(6),
	15:   uint8(6),
	16:   uint8(13),
	17:   uint8(6),
	18:   uint8(6),
	19:   uint8(14),
	20:   uint8(6),
	21:   uint8(6),
	22:   uint8(6),
	23:   uint8(6),
	24:   uint8(6),
	25:   uint8(6),
	26:   uint8(6),
	27:   uint8(6),
	28:   uint8(15),
	29:   uint8(16),
	30:   uint8(17),
	31:   uint8(18),
	32:   uint8(6),
	33:   uint8(19),
	34:   uint8(6),
	35:   uint8(6),
	36:   uint8(6),
	37:   uint8(6),
	38:   uint8(6),
	39:   uint8(6),
	40:   uint8(6),
	41:   uint8(6),
	42:   uint8(6),
	43:   uint8(6),
	44:   uint8(20),
	45:   uint8(21),
	46:   uint8(6),
	47:   uint8(6),
	48:   uint8(6),
	49:   uint8(6),
	50:   uint8(6),
	51:   uint8(6),
	52:   uint8(6),
	53:   uint8(6),
	54:   uint8(6),
	55:   uint8(6),
	56:   uint8(6),
	57:   uint8(6),
	58:   uint8(6),
	59:   uint8(6),
	60:   uint8(6),
	61:   uint8(6),
	62:   uint8(6),
	63:   uint8(6),
	64:   uint8(6),
	65:   uint8(6),
	66:   uint8(6),
	67:   uint8(6),
	68:   uint8(6),
	69:   uint8(6),
	70:   uint8(6),
	71:   uint8(6),
	72:   uint8(6),
	73:   uint8(6),
	74:   uint8(6),
	75:   uint8(6),
	76:   uint8(6),
	77:   uint8(6),
	78:   uint8(6),
	79:   uint8(6),
	80:   uint8(6),
	81:   uint8(6),
	82:   uint8(6),
	83:   uint8(6),
	84:   uint8(6),
	85:   uint8(6),
	86:   uint8(6),
	87:   uint8(6),
	88:   uint8(6),
	89:   uint8(6),
	90:   uint8(6),
	91:   uint8(6),
	92:   uint8(6),
	93:   uint8(6),
	94:   uint8(6),
	95:   uint8(6),
	96:   uint8(6),
	97:   uint8(6),
	98:   uint8(6),
	99:   uint8(6),
	100:  uint8(6),
	101:  uint8(6),
	102:  uint8(6),
	103:  uint8(6),
	104:  uint8(6),
	105:  uint8(6),
	106:  uint8(6),
	107:  uint8(6),
	108:  uint8(6),
	109:  uint8(6),
	110:  uint8(6),
	111:  uint8(6),
	112:  uint8(6),
	113:  uint8(6),
	114:  uint8(6),
	115:  uint8(6),
	116:  uint8(6),
	117:  uint8(6),
	118:  uint8(6),
	119:  uint8(6),
	120:  uint8(6),
	121:  uint8(6),
	122:  uint8(6),
	123:  uint8(6),
	124:  uint8(6),
	125:  uint8(6),
	126:  uint8(6),
	127:  uint8(6),
	128:  uint8(6),
	129:  uint8(6),
	130:  uint8(6),
	131:  uint8(6),
	132:  uint8(6),
	133:  uint8(6),
	134:  uint8(6),
	135:  uint8(6),
	136:  uint8(6),
	137:  uint8(6),
	138:  uint8(6),
	139:  uint8(6),
	140:  uint8(6),
	141:  uint8(6),
	142:  uint8(6),
	143:  uint8(6),
	144:  uint8(6),
	145:  uint8(6),
	146:  uint8(6),
	147:  uint8(6),
	148:  uint8(6),
	149:  uint8(6),
	150:  uint8(6),
	151:  uint8(6),
	152:  uint8(6),
	153:  uint8(6),
	154:  uint8(6),
	155:  uint8(6),
	156:  uint8(6),
	157:  uint8(6),
	158:  uint8(6),
	159:  uint8(6),
	160:  uint8(6),
	161:  uint8(6),
	162:  uint8(6),
	163:  uint8(6),
	164:  uint8(6),
	165:  uint8(6),
	166:  uint8(22),
	167:  uint8(23),
	168:  uint8(6),
	169:  uint8(6),
	170:  uint8(6),
	171:  uint8(24),
	172:  uint8(6),
	173:  uint8(6),
	174:  uint8(6),
	175:  uint8(6),
	176:  uint8(6),
	177:  uint8(6),
	178:  uint8(6),
	179:  uint8(6),
	180:  uint8(6),
	181:  uint8(6),
	182:  uint8(6),
	183:  uint8(6),
	184:  uint8(6),
	185:  uint8(6),
	186:  uint8(6),
	187:  uint8(6),
	188:  uint8(6),
	189:  uint8(6),
	190:  uint8(6),
	191:  uint8(6),
	192:  uint8(6),
	193:  uint8(6),
	194:  uint8(6),
	195:  uint8(6),
	196:  uint8(6),
	197:  uint8(6),
	198:  uint8(6),
	199:  uint8(6),
	200:  uint8(6),
	201:  uint8(6),
	202:  uint8(6),
	203:  uint8(6),
	204:  uint8(6),
	205:  uint8(6),
	206:  uint8(6),
	207:  uint8(6),
	208:  uint8(6),
	209:  uint8(6),
	210:  uint8(6),
	211:  uint8(6),
	212:  uint8(6),
	213:  uint8(6),
	214:  uint8(6),
	215:  uint8(6),
	216:  uint8(6),
	217:  uint8(6),
	218:  uint8(6),
	219:  uint8(6),
	220:  uint8(6),
	221:  uint8(6),
	222:  uint8(6),
	223:  uint8(6),
	224:  uint8(6),
	225:  uint8(6),
	226:  uint8(6),
	227:  uint8(6),
	228:  uint8(6),
	229:  uint8(6),
	230:  uint8(6),
	231:  uint8(6),
	232:  uint8(6),
	233:  uint8(6),
	234:  uint8(6),
	235:  uint8(6),
	236:  uint8(6),
	237:  uint8(6),
	238:  uint8(6),
	239:  uint8(6),
	240:  uint8(6),
	241:  uint8(6),
	242:  uint8(6),
	243:  uint8(6),
	244:  uint8(6),
	245:  uint8(6),
	246:  uint8(6),
	247:  uint8(6),
	248:  uint8(6),
	249:  uint8(6),
	250:  uint8(6),
	251:  uint8(6),
	252:  uint8(6),
	253:  uint8(6),
	254:  uint8(6),
	255:  uint8(25),
	256:  uint8(6),
	257:  uint8(6),
	258:  uint8(6),
	259:  uint8(6),
	260:  uint8(26),
	261:  uint8(6),
	262:  uint8(6),
	263:  uint8(6),
	264:  uint8(6),
	265:  uint8(6),
	266:  uint8(6),
	267:  uint8(6),
	268:  uint8(27),
	269:  uint8(6),
	270:  uint8(6),
	271:  uint8(6),
	272:  uint8(6),
	273:  uint8(6),
	274:  uint8(6),
	275:  uint8(6),
	276:  uint8(6),
	277:  uint8(6),
	278:  uint8(6),
	279:  uint8(6),
	280:  uint8(28),
	281:  uint8(6),
	282:  uint8(6),
	283:  uint8(6),
	284:  uint8(6),
	285:  uint8(6),
	286:  uint8(6),
	287:  uint8(6),
	288:  uint8(6),
	289:  uint8(6),
	290:  uint8(6),
	291:  uint8(6),
	292:  uint8(6),
	293:  uint8(6),
	294:  uint8(6),
	295:  uint8(6),
	296:  uint8(6),
	297:  uint8(6),
	298:  uint8(6),
	299:  uint8(6),
	300:  uint8(6),
	301:  uint8(6),
	302:  uint8(6),
	303:  uint8(6),
	304:  uint8(6),
	305:  uint8(6),
	306:  uint8(6),
	307:  uint8(6),
	308:  uint8(6),
	309:  uint8(6),
	310:  uint8(6),
	311:  uint8(6),
	312:  uint8(6),
	313:  uint8(6),
	314:  uint8(6),
	315:  uint8(6),
	316:  uint8(6),
	317:  uint8(6),
	318:  uint8(6),
	319:  uint8(6),
	320:  uint8(6),
	321:  uint8(6),
	322:  uint8(6),
	323:  uint8(6),
	324:  uint8(6),
	325:  uint8(6),
	326:  uint8(6),
	327:  uint8(6),
	328:  uint8(6),
	329:  uint8(6),
	330:  uint8(6),
	331:  uint8(6),
	332:  uint8(6),
	333:  uint8(6),
	334:  uint8(6),
	335:  uint8(6),
	336:  uint8(6),
	337:  uint8(6),
	338:  uint8(6),
	339:  uint8(6),
	340:  uint8(6),
	341:  uint8(6),
	342:  uint8(6),
	343:  uint8(6),
	344:  uint8(6),
	345:  uint8(6),
	346:  uint8(6),
	347:  uint8(6),
	348:  uint8(6),
	349:  uint8(6),
	350:  uint8(6),
	351:  uint8(6),
	352:  uint8(6),
	353:  uint8(6),
	354:  uint8(6),
	355:  uint8(6),
	356:  uint8(6),
	357:  uint8(6),
	358:  uint8(6),
	359:  uint8(6),
	360:  uint8(6),
	361:  uint8(6),
	362:  uint8(6),
	363:  uint8(6),
	364:  uint8(6),
	365:  uint8(6),
	366:  uint8(29),
	367:  uint8(6),
	368:  uint8(6),
	369:  uint8(6),
	370:  uint8(6),
	371:  uint8(6),
	372:  uint8(6),
	373:  uint8(6),
	374:  uint8(6),
	375:  uint8(6),
	376:  uint8(6),
	377:  uint8(6),
	378:  uint8(6),
	379:  uint8(6),
	380:  uint8(6),
	381:  uint8(6),
	382:  uint8(6),
	383:  uint8(6),
	384:  uint8(6),
	385:  uint8(6),
	386:  uint8(6),
	387:  uint8(6),
	388:  uint8(6),
	389:  uint8(6),
	390:  uint8(6),
	391:  uint8(6),
	392:  uint8(6),
	393:  uint8(6),
	394:  uint8(6),
	395:  uint8(6),
	396:  uint8(6),
	397:  uint8(6),
	398:  uint8(6),
	399:  uint8(6),
	400:  uint8(6),
	401:  uint8(6),
	402:  uint8(6),
	403:  uint8(6),
	404:  uint8(6),
	405:  uint8(6),
	406:  uint8(6),
	407:  uint8(6),
	408:  uint8(6),
	409:  uint8(6),
	410:  uint8(6),
	411:  uint8(6),
	412:  uint8(6),
	413:  uint8(6),
	414:  uint8(6),
	415:  uint8(6),
	416:  uint8(6),
	417:  uint8(6),
	418:  uint8(6),
	419:  uint8(6),
	420:  uint8(6),
	421:  uint8(6),
	422:  uint8(6),
	423:  uint8(6),
	424:  uint8(6),
	425:  uint8(6),
	426:  uint8(6),
	427:  uint8(6),
	428:  uint8(6),
	429:  uint8(6),
	430:  uint8(6),
	431:  uint8(6),
	432:  uint8(6),
	433:  uint8(6),
	434:  uint8(6),
	435:  uint8(6),
	436:  uint8(6),
	437:  uint8(6),
	438:  uint8(6),
	439:  uint8(6),
	440:  uint8(6),
	441:  uint8(6),
	442:  uint8(6),
	443:  uint8(6),
	444:  uint8(6),
	445:  uint8(6),
	446:  uint8(6),
	447:  uint8(6),
	448:  uint8(6),
	449:  uint8(6),
	450:  uint8(6),
	451:  uint8(6),
	452:  uint8(6),
	453:  uint8(6),
	454:  uint8(6),
	455:  uint8(6),
	456:  uint8(6),
	457:  uint8(6),
	458:  uint8(6),
	459:  uint8(6),
	460:  uint8(6),
	461:  uint8(6),
	462:  uint8(6),
	463:  uint8(6),
	464:  uint8(6),
	465:  uint8(6),
	466:  uint8(6),
	467:  uint8(6),
	468:  uint8(6),
	469:  uint8(6),
	470:  uint8(6),
	471:  uint8(6),
	472:  uint8(6),
	473:  uint8(6),
	474:  uint8(6),
	475:  uint8(6),
	476:  uint8(6),
	477:  uint8(6),
	478:  uint8(6),
	479:  uint8(6),
	480:  uint8(6),
	481:  uint8(6),
	482:  uint8(6),
	483:  uint8(6),
	484:  uint8(6),
	485:  uint8(6),
	486:  uint8(6),
	487:  uint8(6),
	488:  uint8(6),
	489:  uint8(30),
	490:  uint8(6),
	491:  uint8(6),
	492:  uint8(6),
	493:  uint8(6),
	494:  uint8(6),
	495:  uint8(6),
	496:  uint8(6),
	497:  uint8(6),
	498:  uint8(6),
	499:  uint8(6),
	500:  uint8(6),
	501:  uint8(6),
	502:  uint8(6),
	503:  uint8(6),
	504:  uint8(6),
	505:  uint8(6),
	506:  uint8(6),
	507:  uint8(6),
	508:  uint8(6),
	509:  uint8(6),
	510:  uint8(6),
	511:  uint8(6),
	512:  uint8(0),
	513:  uint8(0),
	514:  uint8(0),
	515:  uint8(0),
	516:  uint8(0),
	517:  uint8(0),
	518:  uint8(0),
	519:  uint8(0),
	520:  uint8(0),
	521:  uint8(0),
	522:  uint8(0),
	523:  uint8(0),
	524:  uint8(0),
	525:  uint8(0),
	526:  uint8(0),
	527:  uint8(0),
	528:  uint8(0),
	529:  uint8(0),
	530:  uint8(0),
	531:  uint8(0),
	532:  uint8(0),
	533:  uint8(0),
	534:  uint8(0),
	535:  uint8(0),
	536:  uint8(0),
	537:  uint8(0),
	538:  uint8(0),
	539:  uint8(0),
	540:  uint8(0),
	541:  uint8(0),
	542:  uint8(0),
	543:  uint8(0),
	544:  uint8(0),
	545:  uint8(0),
	546:  uint8(0),
	547:  uint8(0),
	548:  uint8(0),
	549:  uint8(0),
	550:  uint8(0),
	551:  uint8(0),
	552:  uint8(0),
	553:  uint8(0),
	554:  uint8(0),
	555:  uint8(0),
	556:  uint8(0),
	557:  uint8(0),
	558:  uint8(0),
	559:  uint8(0),
	560:  uint8(0),
	561:  uint8(0),
	562:  uint8(0),
	563:  uint8(0),
	564:  uint8(0),
	565:  uint8(0),
	566:  uint8(0),
	567:  uint8(0),
	568:  uint8(0),
	569:  uint8(0),
	570:  uint8(0),
	571:  uint8(0),
	572:  uint8(0),
	573:  uint8(0),
	574:  uint8(0),
	575:  uint8(0),
	576:  uint8(0),
	577:  uint8(0),
	578:  uint8(0),
	579:  uint8(0),
	580:  uint8(0),
	581:  uint8(0),
	582:  uint8(0),
	583:  uint8(0),
	584:  uint8(0),
	585:  uint8(0),
	586:  uint8(0),
	587:  uint8(0),
	588:  uint8(0),
	589:  uint8(0),
	590:  uint8(0),
	591:  uint8(0),
	592:  uint8(0),
	593:  uint8(0),
	594:  uint8(0),
	595:  uint8(0),
	596:  uint8(0),
	597:  uint8(0),
	598:  uint8(0),
	599:  uint8(0),
	600:  uint8(0),
	601:  uint8(0),
	602:  uint8(0),
	603:  uint8(0),
	604:  uint8(0),
	605:  uint8(0),
	606:  uint8(0),
	607:  uint8(0),
	608:  uint8(0),
	609:  uint8(0),
	610:  uint8(0),
	611:  uint8(0),
	612:  uint8(0),
	613:  uint8(0),
	614:  uint8(0),
	615:  uint8(0),
	616:  uint8(0),
	617:  uint8(0),
	618:  uint8(0),
	619:  uint8(0),
	620:  uint8(0),
	621:  uint8(0),
	622:  uint8(0),
	623:  uint8(36),
	624:  uint8(43),
	625:  uint8(43),
	626:  uint8(43),
	627:  uint8(43),
	628:  uint8(43),
	629:  uint8(43),
	630:  uint8(43),
	631:  uint8(43),
	632:  uint8(1),
	633:  uint8(0),
	634:  uint8(84),
	635:  uint8(86),
	636:  uint8(86),
	637:  uint8(86),
	638:  uint8(86),
	639:  uint8(86),
	640:  uint8(86),
	641:  uint8(86),
	642:  uint8(86),
	643:  uint8(0),
	644:  uint8(0),
	645:  uint8(0),
	646:  uint8(0),
	647:  uint8(0),
	648:  uint8(0),
	649:  uint8(0),
	650:  uint8(0),
	651:  uint8(0),
	652:  uint8(0),
	653:  uint8(0),
	654:  uint8(0),
	655:  uint8(0),
	656:  uint8(0),
	657:  uint8(0),
	658:  uint8(0),
	659:  uint8(0),
	660:  uint8(0),
	661:  uint8(0),
	662:  uint8(24),
	663:  uint8(0),
	664:  uint8(0),
	665:  uint8(0),
	666:  uint8(43),
	667:  uint8(43),
	668:  uint8(43),
	669:  uint8(43),
	670:  uint8(43),
	671:  uint8(43),
	672:  uint8(43),
	673:  uint8(7),
	674:  uint8(43),
	675:  uint8(43),
	676:  uint8(91),
	677:  uint8(86),
	678:  uint8(86),
	679:  uint8(86),
	680:  uint8(86),
	681:  uint8(86),
	682:  uint8(86),
	683:  uint8(86),
	684:  uint8(74),
	685:  uint8(86),
	686:  uint8(86),
	687:  uint8(5),
	688:  uint8(49),
	689:  uint8(80),
	690:  uint8(49),
	691:  uint8(80),
	692:  uint8(49),
	693:  uint8(80),
	694:  uint8(49),
	695:  uint8(80),
	696:  uint8(49),
	697:  uint8(80),
	698:  uint8(49),
	699:  uint8(80),
	700:  uint8(49),
	701:  uint8(80),
	702:  uint8(49),
	703:  uint8(80),
	704:  uint8(36),
	705:  uint8(80),
	706:  uint8(121),
	707:  uint8(49),
	708:  uint8(80),
	709:  uint8(49),
	710:  uint8(80),
	711:  uint8(49),
	712:  uint8(56),
	713:  uint8(80),
	714:  uint8(49),
	715:  uint8(80),
	716:  uint8(49),
	717:  uint8(80),
	718:  uint8(49),
	719:  uint8(80),
	720:  uint8(49),
	721:  uint8(80),
	722:  uint8(49),
	723:  uint8(80),
	724:  uint8(49),
	725:  uint8(80),
	726:  uint8(49),
	727:  uint8(80),
	728:  uint8(78),
	729:  uint8(49),
	730:  uint8(2),
	731:  uint8(78),
	732:  uint8(13),
	733:  uint8(13),
	734:  uint8(78),
	735:  uint8(3),
	736:  uint8(78),
	737:  uint8(0),
	738:  uint8(36),
	739:  uint8(110),
	740:  uint8(0),
	741:  uint8(78),
	742:  uint8(49),
	743:  uint8(38),
	744:  uint8(110),
	745:  uint8(81),
	746:  uint8(78),
	747:  uint8(36),
	748:  uint8(80),
	749:  uint8(78),
	750:  uint8(57),
	751:  uint8(20),
	752:  uint8(129),
	753:  uint8(27),
	754:  uint8(29),
	755:  uint8(29),
	756:  uint8(83),
	757:  uint8(49),
	758:  uint8(80),
	759:  uint8(49),
	760:  uint8(80),
	761:  uint8(13),
	762:  uint8(49),
	763:  uint8(80),
	764:  uint8(49),
	765:  uint8(80),
	766:  uint8(49),
	767:  uint8(80),
	768:  uint8(27),
	769:  uint8(83),
	770:  uint8(36),
	771:  uint8(80),
	772:  uint8(49),
	773:  uint8(2),
	774:  uint8(92),
	775:  uint8(123),
	776:  uint8(92),
	777:  uint8(123),
	778:  uint8(92),
	779:  uint8(123),
	780:  uint8(92),
	781:  uint8(123),
	782:  uint8(92),
	783:  uint8(123),
	784:  uint8(20),
	785:  uint8(121),
	786:  uint8(92),
	787:  uint8(123),
	788:  uint8(92),
	789:  uint8(123),
	790:  uint8(92),
	791:  uint8(45),
	792:  uint8(43),
	793:  uint8(73),
	794:  uint8(3),
	795:  uint8(72),
	796:  uint8(3),
	797:  uint8(120),
	798:  uint8(92),
	799:  uint8(123),
	800:  uint8(20),
	801:  uint8(0),
	802:  uint8(150),
	803:  uint8(10),
	804:  uint8(1),
	805:  uint8(43),
	806:  uint8(40),
	807:  uint8(6),
	808:  uint8(6),
	809:  uint8(0),
	810:  uint8(42),
	811:  uint8(6),
	812:  uint8(42),
	813:  uint8(42),
	814:  uint8(43),
	815:  uint8(7),
	816:  uint8(187),
	817:  uint8(181),
	818:  uint8(43),
	819:  uint8(30),
	820:  uint8(0),
	821:  uint8(43),
	822:  uint8(7),
	823:  uint8(43),
	824:  uint8(43),
	825:  uint8(43),
	826:  uint8(1),
	827:  uint8(43),
	828:  uint8(43),
	829:  uint8(43),
	830:  uint8(43),
	831:  uint8(43),
	832:  uint8(43),
	833:  uint8(43),
	834:  uint8(43),
	835:  uint8(43),
	836:  uint8(43),
	837:  uint8(43),
	838:  uint8(43),
	839:  uint8(43),
	840:  uint8(43),
	841:  uint8(43),
	842:  uint8(43),
	843:  uint8(43),
	844:  uint8(43),
	845:  uint8(43),
	846:  uint8(43),
	847:  uint8(43),
	848:  uint8(43),
	849:  uint8(43),
	850:  uint8(43),
	851:  uint8(43),
	852:  uint8(43),
	853:  uint8(43),
	854:  uint8(43),
	855:  uint8(43),
	856:  uint8(43),
	857:  uint8(43),
	858:  uint8(43),
	859:  uint8(1),
	860:  uint8(43),
	861:  uint8(43),
	862:  uint8(43),
	863:  uint8(43),
	864:  uint8(43),
	865:  uint8(43),
	866:  uint8(43),
	867:  uint8(43),
	868:  uint8(43),
	869:  uint8(43),
	870:  uint8(43),
	871:  uint8(43),
	872:  uint8(43),
	873:  uint8(43),
	874:  uint8(43),
	875:  uint8(43),
	876:  uint8(43),
	877:  uint8(43),
	878:  uint8(43),
	879:  uint8(43),
	880:  uint8(43),
	881:  uint8(43),
	882:  uint8(43),
	883:  uint8(42),
	884:  uint8(43),
	885:  uint8(43),
	886:  uint8(43),
	887:  uint8(43),
	888:  uint8(43),
	889:  uint8(43),
	890:  uint8(43),
	891:  uint8(43),
	892:  uint8(43),
	893:  uint8(43),
	894:  uint8(43),
	895:  uint8(43),
	896:  uint8(43),
	897:  uint8(205),
	898:  uint8(70),
	899:  uint8(205),
	900:  uint8(43),
	901:  uint8(0),
	902:  uint8(37),
	903:  uint8(43),
	904:  uint8(7),
	905:  uint8(1),
	906:  uint8(6),
	907:  uint8(1),
	908:  uint8(85),
	909:  uint8(86),
	910:  uint8(86),
	911:  uint8(86),
	912:  uint8(86),
	913:  uint8(86),
	914:  uint8(85),
	915:  uint8(86),
	916:  uint8(86),
	917:  uint8(2),
	918:  uint8(36),
	919:  uint8(129),
	920:  uint8(129),
	921:  uint8(129),
	922:  uint8(129),
	923:  uint8(129),
	924:  uint8(21),
	925:  uint8(129),
	926:  uint8(129),
	927:  uint8(129),
	928:  uint8(0),
	929:  uint8(0),
	930:  uint8(43),
	931:  uint8(0),
	932:  uint8(178),
	933:  uint8(209),
	934:  uint8(178),
	935:  uint8(209),
	936:  uint8(178),
	937:  uint8(209),
	938:  uint8(178),
	939:  uint8(209),
	940:  uint8(0),
	941:  uint8(0),
	942:  uint8(205),
	943:  uint8(204),
	944:  uint8(1),
	945:  uint8(0),
	946:  uint8(215),
	947:  uint8(215),
	948:  uint8(215),
	949:  uint8(215),
	950:  uint8(215),
	951:  uint8(131),
	952:  uint8(129),
	953:  uint8(129),
	954:  uint8(129),
	955:  uint8(129),
	956:  uint8(129),
	957:  uint8(129),
	958:  uint8(129),
	959:  uint8(129),
	960:  uint8(129),
	961:  uint8(129),
	962:  uint8(172),
	963:  uint8(172),
	964:  uint8(172),
	965:  uint8(172),
	966:  uint8(172),
	967:  uint8(172),
	968:  uint8(172),
	969:  uint8(172),
	970:  uint8(172),
	971:  uint8(172),
	972:  uint8(28),
	973:  uint8(0),
	974:  uint8(0),
	975:  uint8(0),
	976:  uint8(0),
	977:  uint8(0),
	978:  uint8(49),
	979:  uint8(80),
	980:  uint8(49),
	981:  uint8(80),
	982:  uint8(49),
	983:  uint8(80),
	984:  uint8(49),
	985:  uint8(80),
	986:  uint8(49),
	987:  uint8(80),
	988:  uint8(49),
	989:  uint8(2),
	990:  uint8(0),
	991:  uint8(0),
	992:  uint8(49),
	993:  uint8(80),
	994:  uint8(49),
	995:  uint8(80),
	996:  uint8(49),
	997:  uint8(80),
	998:  uint8(49),
	999:  uint8(80),
	1000: uint8(49),
	1001: uint8(80),
	1002: uint8(49),
	1003: uint8(80),
	1004: uint8(49),
	1005: uint8(80),
	1006: uint8(49),
	1007: uint8(80),
	1008: uint8(49),
	1009: uint8(80),
	1010: uint8(78),
	1011: uint8(49),
	1012: uint8(80),
	1013: uint8(49),
	1014: uint8(80),
	1015: uint8(78),
	1016: uint8(49),
	1017: uint8(80),
	1018: uint8(49),
	1019: uint8(80),
	1020: uint8(49),
	1021: uint8(80),
	1022: uint8(49),
	1023: uint8(80),
	1024: uint8(49),
	1025: uint8(80),
	1026: uint8(49),
	1027: uint8(80),
	1028: uint8(49),
	1029: uint8(80),
	1030: uint8(49),
	1031: uint8(2),
	1032: uint8(135),
	1033: uint8(166),
	1034: uint8(135),
	1035: uint8(166),
	1036: uint8(135),
	1037: uint8(166),
	1038: uint8(135),
	1039: uint8(166),
	1040: uint8(135),
	1041: uint8(166),
	1042: uint8(135),
	1043: uint8(166),
	1044: uint8(135),
	1045: uint8(166),
	1046: uint8(135),
	1047: uint8(166),
	1048: uint8(42),
	1049: uint8(43),
	1050: uint8(43),
	1051: uint8(43),
	1052: uint8(43),
	1053: uint8(43),
	1054: uint8(43),
	1055: uint8(43),
	1056: uint8(43),
	1057: uint8(43),
	1058: uint8(43),
	1059: uint8(43),
	1060: uint8(43),
	1061: uint8(0),
	1062: uint8(0),
	1063: uint8(0),
	1064: uint8(84),
	1065: uint8(86),
	1066: uint8(86),
	1067: uint8(86),
	1068: uint8(86),
	1069: uint8(86),
	1070: uint8(86),
	1071: uint8(86),
	1072: uint8(86),
	1073: uint8(86),
	1074: uint8(86),
	1075: uint8(86),
	1076: uint8(86),
	1077: uint8(0),
	1078: uint8(0),
	1079: uint8(0),
	1080: uint8(0),
	1081: uint8(0),
	1082: uint8(0),
	1083: uint8(0),
	1084: uint8(0),
	1085: uint8(0),
	1086: uint8(0),
	1087: uint8(0),
	1088: uint8(0),
	1089: uint8(0),
	1090: uint8(0),
	1091: uint8(0),
	1092: uint8(0),
	1093: uint8(0),
	1094: uint8(0),
	1095: uint8(0),
	1096: uint8(0),
	1097: uint8(0),
	1098: uint8(0),
	1099: uint8(0),
	1100: uint8(0),
	1101: uint8(0),
	1102: uint8(0),
	1103: uint8(0),
	1104: uint8(0),
	1105: uint8(0),
	1106: uint8(0),
	1107: uint8(0),
	1108: uint8(0),
	1109: uint8(0),
	1110: uint8(0),
	1111: uint8(0),
	1112: uint8(0),
	1113: uint8(0),
	1114: uint8(0),
	1115: uint8(0),
	1116: uint8(0),
	1117: uint8(0),
	1118: uint8(0),
	1119: uint8(0),
	1120: uint8(0),
	1121: uint8(0),
	1122: uint8(0),
	1123: uint8(0),
	1124: uint8(0),
	1125: uint8(0),
	1126: uint8(0),
	1127: uint8(0),
	1128: uint8(0),
	1129: uint8(0),
	1130: uint8(0),
	1131: uint8(0),
	1132: uint8(0),
	1133: uint8(0),
	1134: uint8(0),
	1135: uint8(0),
	1136: uint8(0),
	1137: uint8(0),
	1138: uint8(0),
	1139: uint8(0),
	1140: uint8(0),
	1141: uint8(0),
	1142: uint8(0),
	1143: uint8(0),
	1144: uint8(0),
	1145: uint8(0),
	1146: uint8(0),
	1147: uint8(0),
	1148: uint8(0),
	1149: uint8(0),
	1150: uint8(0),
	1151: uint8(0),
	1152: uint8(0),
	1153: uint8(0),
	1154: uint8(0),
	1155: uint8(0),
	1156: uint8(0),
	1157: uint8(0),
	1158: uint8(0),
	1159: uint8(0),
	1160: uint8(0),
	1161: uint8(0),
	1162: uint8(0),
	1163: uint8(0),
	1164: uint8(0),
	1165: uint8(0),
	1166: uint8(0),
	1167: uint8(0),
	1168: uint8(0),
	1169: uint8(0),
	1170: uint8(0),
	1171: uint8(84),
	1172: uint8(86),
	1173: uint8(86),
	1174: uint8(86),
	1175: uint8(86),
	1176: uint8(86),
	1177: uint8(86),
	1178: uint8(86),
	1179: uint8(86),
	1180: uint8(86),
	1181: uint8(86),
	1182: uint8(86),
	1183: uint8(86),
	1184: uint8(12),
	1185: uint8(0),
	1186: uint8(12),
	1187: uint8(42),
	1188: uint8(43),
	1189: uint8(43),
	1190: uint8(43),
	1191: uint8(43),
	1192: uint8(43),
	1193: uint8(43),
	1194: uint8(43),
	1195: uint8(43),
	1196: uint8(43),
	1197: uint8(43),
	1198: uint8(43),
	1199: uint8(43),
	1200: uint8(43),
	1201: uint8(7),
	1202: uint8(42),
	1203: uint8(1),
	1204: uint8(0),
	1205: uint8(0),
	1206: uint8(0),
	1207: uint8(0),
	1208: uint8(0),
	1209: uint8(0),
	1210: uint8(0),
	1211: uint8(0),
	1212: uint8(0),
	1213: uint8(0),
	1214: uint8(0),
	1215: uint8(0),
	1216: uint8(0),
	1217: uint8(0),
	1218: uint8(0),
	1219: uint8(0),
	1220: uint8(0),
	1221: uint8(0),
	1222: uint8(0),
	1223: uint8(0),
	1224: uint8(0),
	1225: uint8(0),
	1226: uint8(0),
	1227: uint8(0),
	1228: uint8(0),
	1229: uint8(0),
	1230: uint8(0),
	1231: uint8(0),
	1232: uint8(0),
	1233: uint8(0),
	1234: uint8(0),
	1235: uint8(0),
	1236: uint8(0),
	1237: uint8(0),
	1238: uint8(0),
	1239: uint8(0),
	1240: uint8(0),
	1241: uint8(0),
	1242: uint8(0),
	1243: uint8(0),
	1244: uint8(0),
	1245: uint8(0),
	1246: uint8(0),
	1247: uint8(0),
	1248: uint8(0),
	1249: uint8(0),
	1250: uint8(0),
	1251: uint8(0),
	1252: uint8(0),
	1253: uint8(0),
	1254: uint8(0),
	1255: uint8(0),
	1256: uint8(0),
	1257: uint8(42),
	1258: uint8(43),
	1259: uint8(43),
	1260: uint8(43),
	1261: uint8(43),
	1262: uint8(43),
	1263: uint8(43),
	1264: uint8(43),
	1265: uint8(43),
	1266: uint8(43),
	1267: uint8(43),
	1268: uint8(43),
	1269: uint8(43),
	1270: uint8(43),
	1271: uint8(43),
	1272: uint8(43),
	1273: uint8(43),
	1274: uint8(43),
	1275: uint8(43),
	1276: uint8(43),
	1277: uint8(43),
	1278: uint8(43),
	1279: uint8(43),
	1280: uint8(43),
	1281: uint8(43),
	1282: uint8(43),
	1283: uint8(43),
	1284: uint8(86),
	1285: uint8(86),
	1286: uint8(108),
	1287: uint8(129),
	1288: uint8(21),
	1289: uint8(0),
	1290: uint8(43),
	1291: uint8(43),
	1292: uint8(43),
	1293: uint8(43),
	1294: uint8(43),
	1295: uint8(43),
	1296: uint8(43),
	1297: uint8(43),
	1298: uint8(43),
	1299: uint8(43),
	1300: uint8(43),
	1301: uint8(43),
	1302: uint8(43),
	1303: uint8(43),
	1304: uint8(43),
	1305: uint8(43),
	1306: uint8(43),
	1307: uint8(43),
	1308: uint8(43),
	1309: uint8(43),
	1310: uint8(43),
	1311: uint8(43),
	1312: uint8(43),
	1313: uint8(43),
	1314: uint8(43),
	1315: uint8(43),
	1316: uint8(43),
	1317: uint8(43),
	1318: uint8(43),
	1319: uint8(43),
	1320: uint8(43),
	1321: uint8(43),
	1322: uint8(43),
	1323: uint8(43),
	1324: uint8(43),
	1325: uint8(43),
	1326: uint8(43),
	1327: uint8(43),
	1328: uint8(43),
	1329: uint8(43),
	1330: uint8(43),
	1331: uint8(43),
	1332: uint8(7),
	1333: uint8(108),
	1334: uint8(3),
	1335: uint8(65),
	1336: uint8(43),
	1337: uint8(43),
	1338: uint8(86),
	1339: uint8(86),
	1340: uint8(86),
	1341: uint8(86),
	1342: uint8(86),
	1343: uint8(86),
	1344: uint8(86),
	1345: uint8(86),
	1346: uint8(86),
	1347: uint8(86),
	1348: uint8(86),
	1349: uint8(86),
	1350: uint8(86),
	1351: uint8(86),
	1352: uint8(44),
	1353: uint8(86),
	1354: uint8(43),
	1355: uint8(43),
	1356: uint8(43),
	1357: uint8(43),
	1358: uint8(43),
	1359: uint8(43),
	1360: uint8(43),
	1361: uint8(43),
	1362: uint8(43),
	1363: uint8(43),
	1364: uint8(43),
	1365: uint8(43),
	1366: uint8(43),
	1367: uint8(43),
	1368: uint8(43),
	1369: uint8(43),
	1370: uint8(43),
	1371: uint8(43),
	1372: uint8(43),
	1373: uint8(43),
	1374: uint8(43),
	1375: uint8(1),
	1376: uint8(0),
	1377: uint8(0),
	1378: uint8(0),
	1379: uint8(0),
	1380: uint8(0),
	1381: uint8(0),
	1382: uint8(0),
	1383: uint8(0),
	1384: uint8(0),
	1385: uint8(0),
	1386: uint8(0),
	1387: uint8(0),
	1388: uint8(0),
	1389: uint8(0),
	1390: uint8(0),
	1391: uint8(0),
	1392: uint8(0),
	1393: uint8(0),
	1394: uint8(0),
	1395: uint8(0),
	1396: uint8(0),
	1397: uint8(0),
	1398: uint8(0),
	1399: uint8(0),
	1400: uint8(0),
	1401: uint8(0),
	1402: uint8(0),
	1403: uint8(0),
	1404: uint8(0),
	1405: uint8(0),
	1406: uint8(0),
	1407: uint8(0),
	1408: uint8(0),
	1409: uint8(0),
	1410: uint8(0),
	1411: uint8(0),
	1412: uint8(0),
	1413: uint8(0),
	1414: uint8(0),
	1415: uint8(0),
	1416: uint8(12),
	1417: uint8(108),
	1418: uint8(0),
	1419: uint8(0),
	1420: uint8(0),
	1421: uint8(0),
	1422: uint8(0),
	1423: uint8(6),
	1424: uint8(0),
	1425: uint8(0),
	1426: uint8(0),
	1427: uint8(0),
	1428: uint8(0),
	1429: uint8(0),
	1430: uint8(0),
	1431: uint8(0),
	1432: uint8(0),
	1433: uint8(0),
	1434: uint8(0),
	1435: uint8(0),
	1436: uint8(0),
	1437: uint8(0),
	1438: uint8(0),
	1439: uint8(0),
	1440: uint8(0),
	1441: uint8(0),
	1442: uint8(0),
	1443: uint8(0),
	1444: uint8(0),
	1445: uint8(0),
	1446: uint8(0),
	1447: uint8(0),
	1448: uint8(0),
	1449: uint8(0),
	1450: uint8(0),
	1451: uint8(0),
	1452: uint8(0),
	1453: uint8(0),
	1454: uint8(0),
	1455: uint8(0),
	1456: uint8(0),
	1457: uint8(0),
	1458: uint8(0),
	1459: uint8(0),
	1460: uint8(0),
	1461: uint8(0),
	1462: uint8(6),
	1463: uint8(37),
	1464: uint8(6),
	1465: uint8(37),
	1466: uint8(6),
	1467: uint8(37),
	1468: uint8(6),
	1469: uint8(37),
	1470: uint8(6),
	1471: uint8(37),
	1472: uint8(6),
	1473: uint8(37),
	1474: uint8(6),
	1475: uint8(37),
	1476: uint8(6),
	1477: uint8(37),
	1478: uint8(6),
	1479: uint8(37),
	1480: uint8(6),
	1481: uint8(37),
	1482: uint8(6),
	1483: uint8(37),
	1484: uint8(6),
	1485: uint8(37),
	1486: uint8(6),
	1487: uint8(37),
	1488: uint8(6),
	1489: uint8(37),
	1490: uint8(6),
	1491: uint8(37),
	1492: uint8(6),
	1493: uint8(37),
	1494: uint8(6),
	1495: uint8(37),
	1496: uint8(6),
	1497: uint8(37),
	1498: uint8(6),
	1499: uint8(37),
	1500: uint8(6),
	1501: uint8(37),
	1502: uint8(6),
	1503: uint8(37),
	1504: uint8(6),
	1505: uint8(37),
	1506: uint8(6),
	1507: uint8(37),
	1508: uint8(6),
	1509: uint8(37),
	1510: uint8(6),
	1511: uint8(37),
	1512: uint8(86),
	1513: uint8(122),
	1514: uint8(158),
	1515: uint8(38),
	1516: uint8(6),
	1517: uint8(37),
	1518: uint8(6),
	1519: uint8(37),
	1520: uint8(6),
	1521: uint8(37),
	1522: uint8(6),
	1523: uint8(37),
	1524: uint8(6),
	1525: uint8(37),
	1526: uint8(6),
	1527: uint8(37),
	1528: uint8(6),
	1529: uint8(37),
	1530: uint8(6),
	1531: uint8(37),
	1532: uint8(6),
	1533: uint8(37),
	1534: uint8(6),
	1535: uint8(37),
	1536: uint8(6),
	1537: uint8(37),
	1538: uint8(6),
	1539: uint8(37),
	1540: uint8(6),
	1541: uint8(37),
	1542: uint8(6),
	1543: uint8(37),
	1544: uint8(6),
	1545: uint8(37),
	1546: uint8(6),
	1547: uint8(1),
	1548: uint8(43),
	1549: uint8(43),
	1550: uint8(79),
	1551: uint8(86),
	1552: uint8(86),
	1553: uint8(44),
	1554: uint8(43),
	1555: uint8(127),
	1556: uint8(86),
	1557: uint8(86),
	1558: uint8(57),
	1559: uint8(43),
	1560: uint8(43),
	1561: uint8(85),
	1562: uint8(86),
	1563: uint8(86),
	1564: uint8(43),
	1565: uint8(43),
	1566: uint8(79),
	1567: uint8(86),
	1568: uint8(86),
	1569: uint8(44),
	1570: uint8(43),
	1571: uint8(127),
	1572: uint8(86),
	1573: uint8(86),
	1574: uint8(129),
	1575: uint8(55),
	1576: uint8(117),
	1577: uint8(91),
	1578: uint8(123),
	1579: uint8(92),
	1580: uint8(43),
	1581: uint8(43),
	1582: uint8(79),
	1583: uint8(86),
	1584: uint8(86),
	1585: uint8(2),
	1586: uint8(172),
	1587: uint8(4),
	1588: uint8(0),
	1589: uint8(0),
	1590: uint8(57),
	1591: uint8(43),
	1592: uint8(43),
	1593: uint8(85),
	1594: uint8(86),
	1595: uint8(86),
	1596: uint8(43),
	1597: uint8(43),
	1598: uint8(79),
	1599: uint8(86),
	1600: uint8(86),
	1601: uint8(44),
	1602: uint8(43),
	1603: uint8(43),
	1604: uint8(86),
	1605: uint8(86),
	1606: uint8(50),
	1607: uint8(19),
	1608: uint8(129),
	1609: uint8(87),
	1610: uint8(0),
	1611: uint8(111),
	1612: uint8(129),
	1613: uint8(126),
	1614: uint8(201),
	1615: uint8(215),
	1616: uint8(126),
	1617: uint8(45),
	1618: uint8(129),
	1619: uint8(129),
	1620: uint8(14),
	1621: uint8(126),
	1622: uint8(57),
	1623: uint8(127),
	1624: uint8(111),
	1625: uint8(87),
	1626: uint8(0),
	1627: uint8(129),
	1628: uint8(129),
	1629: uint8(126),
	1630: uint8(21),
	1631: uint8(0),
	1632: uint8(126),
	1633: uint8(3),
	1634: uint8(43),
	1635: uint8(43),
	1636: uint8(43),
	1637: uint8(43),
	1638: uint8(43),
	1639: uint8(43),
	1640: uint8(43),
	1641: uint8(43),
	1642: uint8(43),
	1643: uint8(43),
	1644: uint8(43),
	1645: uint8(43),
	1646: uint8(7),
	1647: uint8(43),
	1648: uint8(36),
	1649: uint8(43),
	1650: uint8(151),
	1651: uint8(43),
	1652: uint8(43),
	1653: uint8(43),
	1654: uint8(43),
	1655: uint8(43),
	1656: uint8(43),
	1657: uint8(43),
	1658: uint8(43),
	1659: uint8(43),
	1660: uint8(42),
	1661: uint8(43),
	1662: uint8(43),
	1663: uint8(43),
	1664: uint8(43),
	1665: uint8(43),
	1666: uint8(86),
	1667: uint8(86),
	1668: uint8(86),
	1669: uint8(86),
	1670: uint8(86),
	1671: uint8(128),
	1672: uint8(129),
	1673: uint8(129),
	1674: uint8(129),
	1675: uint8(129),
	1676: uint8(57),
	1677: uint8(187),
	1678: uint8(42),
	1679: uint8(43),
	1680: uint8(43),
	1681: uint8(43),
	1682: uint8(43),
	1683: uint8(43),
	1684: uint8(43),
	1685: uint8(43),
	1686: uint8(43),
	1687: uint8(43),
	1688: uint8(43),
	1689: uint8(43),
	1690: uint8(43),
	1691: uint8(43),
	1692: uint8(43),
	1693: uint8(43),
	1694: uint8(43),
	1695: uint8(43),
	1696: uint8(43),
	1697: uint8(43),
	1698: uint8(43),
	1699: uint8(43),
	1700: uint8(43),
	1701: uint8(43),
	1702: uint8(43),
	1703: uint8(43),
	1704: uint8(43),
	1705: uint8(43),
	1706: uint8(43),
	1707: uint8(43),
	1708: uint8(43),
	1709: uint8(43),
	1710: uint8(43),
	1711: uint8(43),
	1712: uint8(43),
	1713: uint8(43),
	1714: uint8(43),
	1715: uint8(43),
	1716: uint8(43),
	1717: uint8(43),
	1718: uint8(43),
	1719: uint8(1),
	1720: uint8(129),
	1721: uint8(129),
	1722: uint8(129),
	1723: uint8(129),
	1724: uint8(129),
	1725: uint8(129),
	1726: uint8(129),
	1727: uint8(129),
	1728: uint8(129),
	1729: uint8(129),
	1730: uint8(129),
	1731: uint8(129),
	1732: uint8(129),
	1733: uint8(129),
	1734: uint8(129),
	1735: uint8(201),
	1736: uint8(172),
	1737: uint8(172),
	1738: uint8(172),
	1739: uint8(172),
	1740: uint8(172),
	1741: uint8(172),
	1742: uint8(172),
	1743: uint8(172),
	1744: uint8(172),
	1745: uint8(172),
	1746: uint8(172),
	1747: uint8(172),
	1748: uint8(172),
	1749: uint8(172),
	1750: uint8(172),
	1751: uint8(208),
	1752: uint8(13),
	1753: uint8(0),
	1754: uint8(78),
	1755: uint8(49),
	1756: uint8(2),
	1757: uint8(180),
	1758: uint8(193),
	1759: uint8(193),
	1760: uint8(215),
	1761: uint8(215),
	1762: uint8(36),
	1763: uint8(80),
	1764: uint8(49),
	1765: uint8(80),
	1766: uint8(49),
	1767: uint8(80),
	1768: uint8(49),
	1769: uint8(80),
	1770: uint8(49),
	1771: uint8(80),
	1772: uint8(49),
	1773: uint8(80),
	1774: uint8(49),
	1775: uint8(80),
	1776: uint8(49),
	1777: uint8(80),
	1778: uint8(49),
	1779: uint8(80),
	1780: uint8(49),
	1781: uint8(80),
	1782: uint8(49),
	1783: uint8(80),
	1784: uint8(49),
	1785: uint8(80),
	1786: uint8(49),
	1787: uint8(80),
	1788: uint8(49),
	1789: uint8(80),
	1790: uint8(49),
	1791: uint8(80),
	1792: uint8(49),
	1793: uint8(80),
	1794: uint8(49),
	1795: uint8(80),
	1796: uint8(215),
	1797: uint8(215),
	1798: uint8(83),
	1799: uint8(193),
	1800: uint8(71),
	1801: uint8(212),
	1802: uint8(215),
	1803: uint8(215),
	1804: uint8(215),
	1805: uint8(5),
	1806: uint8(43),
	1807: uint8(43),
	1808: uint8(43),
	1809: uint8(43),
	1810: uint8(43),
	1811: uint8(43),
	1812: uint8(43),
	1813: uint8(43),
	1814: uint8(43),
	1815: uint8(43),
	1816: uint8(43),
	1817: uint8(43),
	1818: uint8(7),
	1819: uint8(1),
	1820: uint8(0),
	1821: uint8(1),
	1822: uint8(0),
	1823: uint8(0),
	1824: uint8(0),
	1825: uint8(0),
	1826: uint8(0),
	1827: uint8(0),
	1828: uint8(0),
	1829: uint8(0),
	1830: uint8(0),
	1831: uint8(0),
	1832: uint8(0),
	1833: uint8(0),
	1834: uint8(0),
	1835: uint8(0),
	1836: uint8(0),
	1837: uint8(0),
	1838: uint8(0),
	1839: uint8(0),
	1840: uint8(0),
	1841: uint8(0),
	1842: uint8(0),
	1843: uint8(0),
	1844: uint8(0),
	1845: uint8(0),
	1846: uint8(0),
	1847: uint8(0),
	1848: uint8(0),
	1849: uint8(0),
	1850: uint8(0),
	1851: uint8(0),
	1852: uint8(0),
	1853: uint8(0),
	1854: uint8(0),
	1855: uint8(0),
	1856: uint8(0),
	1857: uint8(0),
	1858: uint8(0),
	1859: uint8(0),
	1860: uint8(0),
	1861: uint8(0),
	1862: uint8(0),
	1863: uint8(0),
	1864: uint8(0),
	1865: uint8(0),
	1866: uint8(0),
	1867: uint8(0),
	1868: uint8(0),
	1869: uint8(0),
	1870: uint8(0),
	1871: uint8(0),
	1872: uint8(0),
	1873: uint8(0),
	1874: uint8(0),
	1875: uint8(0),
	1876: uint8(0),
	1877: uint8(0),
	1878: uint8(0),
	1879: uint8(0),
	1880: uint8(0),
	1881: uint8(0),
	1882: uint8(0),
	1883: uint8(0),
	1884: uint8(0),
	1885: uint8(0),
	1886: uint8(0),
	1887: uint8(0),
	1888: uint8(0),
	1889: uint8(0),
	1890: uint8(0),
	1891: uint8(0),
	1892: uint8(0),
	1893: uint8(0),
	1894: uint8(0),
	1895: uint8(0),
	1896: uint8(0),
	1897: uint8(0),
	1898: uint8(0),
	1899: uint8(0),
	1900: uint8(0),
	1901: uint8(0),
	1902: uint8(0),
	1903: uint8(0),
	1904: uint8(0),
	1905: uint8(0),
	1906: uint8(0),
	1907: uint8(0),
	1908: uint8(0),
	1909: uint8(0),
	1910: uint8(0),
	1911: uint8(0),
	1912: uint8(0),
	1913: uint8(78),
	1914: uint8(49),
	1915: uint8(80),
	1916: uint8(49),
	1917: uint8(80),
	1918: uint8(49),
	1919: uint8(80),
	1920: uint8(49),
	1921: uint8(80),
	1922: uint8(49),
	1923: uint8(80),
	1924: uint8(49),
	1925: uint8(80),
	1926: uint8(49),
	1927: uint8(80),
	1928: uint8(13),
	1929: uint8(0),
	1930: uint8(0),
	1931: uint8(0),
	1932: uint8(0),
	1933: uint8(0),
	1934: uint8(36),
	1935: uint8(80),
	1936: uint8(49),
	1937: uint8(80),
	1938: uint8(49),
	1939: uint8(80),
	1940: uint8(49),
	1941: uint8(80),
	1942: uint8(49),
	1943: uint8(80),
	1944: uint8(0),
	1945: uint8(0),
	1946: uint8(0),
	1947: uint8(0),
	1948: uint8(0),
	1949: uint8(0),
	1950: uint8(0),
	1951: uint8(0),
	1952: uint8(0),
	1953: uint8(0),
	1954: uint8(0),
	1955: uint8(0),
	1956: uint8(0),
	1957: uint8(0),
	1958: uint8(0),
	1959: uint8(0),
	1960: uint8(0),
	1961: uint8(0),
	1962: uint8(0),
	1963: uint8(0),
	1964: uint8(0),
	1965: uint8(0),
	1966: uint8(0),
	1967: uint8(0),
	1968: uint8(0),
	1969: uint8(0),
	1970: uint8(0),
	1971: uint8(0),
	1972: uint8(0),
	1973: uint8(0),
	1974: uint8(0),
	1975: uint8(0),
	1976: uint8(0),
	1977: uint8(0),
	1978: uint8(43),
	1979: uint8(43),
	1980: uint8(43),
	1981: uint8(43),
	1982: uint8(43),
	1983: uint8(43),
	1984: uint8(43),
	1985: uint8(43),
	1986: uint8(43),
	1987: uint8(43),
	1988: uint8(43),
	1989: uint8(121),
	1990: uint8(92),
	1991: uint8(123),
	1992: uint8(92),
	1993: uint8(123),
	1994: uint8(79),
	1995: uint8(123),
	1996: uint8(92),
	1997: uint8(123),
	1998: uint8(92),
	1999: uint8(123),
	2000: uint8(92),
	2001: uint8(123),
	2002: uint8(92),
	2003: uint8(123),
	2004: uint8(92),
	2005: uint8(123),
	2006: uint8(92),
	2007: uint8(123),
	2008: uint8(92),
	2009: uint8(123),
	2010: uint8(92),
	2011: uint8(123),
	2012: uint8(92),
	2013: uint8(123),
	2014: uint8(92),
	2015: uint8(45),
	2016: uint8(43),
	2017: uint8(43),
	2018: uint8(121),
	2019: uint8(20),
	2020: uint8(92),
	2021: uint8(123),
	2022: uint8(92),
	2023: uint8(45),
	2024: uint8(121),
	2025: uint8(42),
	2026: uint8(92),
	2027: uint8(39),
	2028: uint8(92),
	2029: uint8(123),
	2030: uint8(92),
	2031: uint8(123),
	2032: uint8(92),
	2033: uint8(123),
	2034: uint8(164),
	2035: uint8(0),
	2036: uint8(10),
	2037: uint8(180),
	2038: uint8(92),
	2039: uint8(123),
	2040: uint8(92),
	2041: uint8(123),
	2042: uint8(79),
	2043: uint8(3),
	2044: uint8(42),
	2045: uint8(43),
	2046: uint8(43),
	2047: uint8(43),
	2048: uint8(43),
	2049: uint8(43),
	2050: uint8(43),
	2051: uint8(43),
	2052: uint8(43),
	2053: uint8(43),
	2054: uint8(43),
	2055: uint8(43),
	2056: uint8(43),
	2057: uint8(43),
	2058: uint8(43),
	2059: uint8(43),
	2060: uint8(43),
	2061: uint8(43),
	2062: uint8(43),
	2063: uint8(1),
	2064: uint8(0),
	2065: uint8(0),
	2066: uint8(0),
	2067: uint8(0),
	2068: uint8(0),
	2069: uint8(0),
	2070: uint8(0),
	2071: uint8(0),
	2072: uint8(0),
	2073: uint8(0),
	2074: uint8(0),
	2075: uint8(0),
	2076: uint8(0),
	2077: uint8(0),
	2078: uint8(0),
	2079: uint8(0),
	2080: uint8(0),
	2081: uint8(0),
	2082: uint8(0),
	2083: uint8(0),
	2084: uint8(0),
	2085: uint8(0),
	2086: uint8(0),
	2087: uint8(0),
	2088: uint8(0),
	2089: uint8(0),
	2090: uint8(0),
	2091: uint8(72),
	2092: uint8(0),
	2093: uint8(0),
	2094: uint8(0),
	2095: uint8(0),
	2096: uint8(0),
	2097: uint8(0),
	2098: uint8(0),
	2099: uint8(0),
	2100: uint8(0),
	2101: uint8(42),
	2102: uint8(43),
	2103: uint8(43),
	2104: uint8(43),
	2105: uint8(43),
	2106: uint8(43),
	2107: uint8(43),
	2108: uint8(43),
	2109: uint8(43),
	2110: uint8(43),
	2111: uint8(43),
	2112: uint8(43),
	2113: uint8(43),
	2114: uint8(43),
	2115: uint8(43),
	2116: uint8(43),
	2117: uint8(43),
	2118: uint8(43),
	2119: uint8(43),
	2120: uint8(43),
	2121: uint8(43),
	2122: uint8(43),
	2123: uint8(43),
	2124: uint8(43),
	2125: uint8(43),
	2126: uint8(43),
	2127: uint8(43),
	2128: uint8(0),
	2129: uint8(0),
	2130: uint8(0),
	2131: uint8(0),
	2132: uint8(0),
	2133: uint8(0),
	2134: uint8(0),
	2135: uint8(0),
	2136: uint8(0),
	2137: uint8(0),
	2138: uint8(0),
	2139: uint8(0),
	2140: uint8(0),
	2141: uint8(0),
	2142: uint8(0),
	2143: uint8(0),
	2144: uint8(0),
	2145: uint8(0),
	2146: uint8(0),
	2147: uint8(0),
	2148: uint8(0),
	2149: uint8(0),
	2150: uint8(0),
	2151: uint8(0),
	2152: uint8(0),
	2153: uint8(0),
	2154: uint8(0),
	2155: uint8(0),
	2156: uint8(0),
	2157: uint8(0),
	2158: uint8(0),
	2159: uint8(0),
	2160: uint8(0),
	2161: uint8(43),
	2162: uint8(43),
	2163: uint8(43),
	2164: uint8(43),
	2165: uint8(43),
	2166: uint8(43),
	2167: uint8(43),
	2168: uint8(43),
	2169: uint8(7),
	2170: uint8(0),
	2171: uint8(72),
	2172: uint8(86),
	2173: uint8(86),
	2174: uint8(86),
	2175: uint8(86),
	2176: uint8(86),
	2177: uint8(86),
	2178: uint8(86),
	2179: uint8(86),
	2180: uint8(2),
	2181: uint8(0),
	2182: uint8(0),
	2183: uint8(0),
	2184: uint8(0),
	2185: uint8(0),
	2186: uint8(0),
	2187: uint8(0),
	2188: uint8(0),
	2189: uint8(0),
	2190: uint8(0),
	2191: uint8(0),
	2192: uint8(0),
	2193: uint8(0),
	2194: uint8(0),
	2195: uint8(0),
	2196: uint8(0),
	2197: uint8(0),
	2198: uint8(0),
	2199: uint8(0),
	2200: uint8(0),
	2201: uint8(0),
	2202: uint8(0),
	2203: uint8(0),
	2204: uint8(0),
	2205: uint8(0),
	2206: uint8(0),
	2207: uint8(0),
	2208: uint8(0),
	2209: uint8(0),
	2210: uint8(0),
	2211: uint8(0),
	2212: uint8(0),
	2213: uint8(0),
	2214: uint8(0),
	2215: uint8(0),
	2216: uint8(0),
	2217: uint8(0),
	2218: uint8(0),
	2219: uint8(0),
	2220: uint8(0),
	2221: uint8(0),
	2222: uint8(0),
	2223: uint8(0),
	2224: uint8(0),
	2225: uint8(0),
	2226: uint8(0),
	2227: uint8(0),
	2228: uint8(0),
	2229: uint8(0),
	2230: uint8(0),
	2231: uint8(0),
	2232: uint8(0),
	2233: uint8(0),
	2234: uint8(0),
	2235: uint8(0),
	2236: uint8(43),
	2237: uint8(43),
	2238: uint8(43),
	2239: uint8(43),
	2240: uint8(43),
	2241: uint8(43),
	2242: uint8(43),
	2243: uint8(43),
	2244: uint8(43),
	2245: uint8(43),
	2246: uint8(43),
	2247: uint8(43),
	2248: uint8(43),
	2249: uint8(85),
	2250: uint8(86),
	2251: uint8(86),
	2252: uint8(86),
	2253: uint8(86),
	2254: uint8(86),
	2255: uint8(86),
	2256: uint8(86),
	2257: uint8(86),
	2258: uint8(86),
	2259: uint8(86),
	2260: uint8(86),
	2261: uint8(86),
	2262: uint8(14),
	2263: uint8(0),
	2264: uint8(0),
	2265: uint8(0),
	2266: uint8(0),
	2267: uint8(0),
	2268: uint8(0),
	2269: uint8(0),
	2270: uint8(0),
	2271: uint8(0),
	2272: uint8(0),
	2273: uint8(0),
	2274: uint8(0),
	2275: uint8(0),
	2276: uint8(0),
	2277: uint8(0),
	2278: uint8(0),
	2279: uint8(0),
	2280: uint8(0),
	2281: uint8(0),
	2282: uint8(0),
	2283: uint8(0),
	2284: uint8(0),
	2285: uint8(0),
	2286: uint8(0),
	2287: uint8(0),
	2288: uint8(0),
	2289: uint8(0),
	2290: uint8(0),
	2291: uint8(0),
	2292: uint8(0),
	2293: uint8(0),
	2294: uint8(36),
	2295: uint8(43),
	2296: uint8(43),
	2297: uint8(43),
	2298: uint8(43),
	2299: uint8(43),
	2300: uint8(43),
	2301: uint8(43),
	2302: uint8(43),
	2303: uint8(43),
	2304: uint8(43),
	2305: uint8(43),
	2306: uint8(7),
	2307: uint8(0),
	2308: uint8(86),
	2309: uint8(86),
	2310: uint8(86),
	2311: uint8(86),
	2312: uint8(86),
	2313: uint8(86),
	2314: uint8(86),
	2315: uint8(86),
	2316: uint8(86),
	2317: uint8(86),
	2318: uint8(86),
	2319: uint8(86),
	2320: uint8(0),
	2321: uint8(0),
	2322: uint8(0),
	2323: uint8(0),
	2324: uint8(0),
	2325: uint8(0),
	2326: uint8(0),
	2327: uint8(0),
	2328: uint8(0),
	2329: uint8(0),
	2330: uint8(0),
	2331: uint8(0),
	2332: uint8(0),
	2333: uint8(0),
	2334: uint8(0),
	2335: uint8(0),
	2336: uint8(0),
	2337: uint8(0),
	2338: uint8(0),
	2339: uint8(0),
	2340: uint8(0),
	2341: uint8(0),
	2342: uint8(0),
	2343: uint8(0),
	2344: uint8(0),
	2345: uint8(0),
	2346: uint8(0),
	2347: uint8(0),
	2348: uint8(0),
	2349: uint8(0),
	2350: uint8(0),
	2351: uint8(0),
	2352: uint8(0),
	2353: uint8(0),
	2354: uint8(0),
	2355: uint8(0),
	2356: uint8(0),
	2357: uint8(0),
	2358: uint8(0),
	2359: uint8(0),
	2360: uint8(0),
	2361: uint8(0),
	2362: uint8(0),
	2363: uint8(0),
	2364: uint8(36),
	2365: uint8(43),
	2366: uint8(43),
	2367: uint8(43),
	2368: uint8(43),
	2369: uint8(43),
	2370: uint8(43),
	2371: uint8(43),
	2372: uint8(43),
	2373: uint8(43),
	2374: uint8(43),
	2375: uint8(43),
	2376: uint8(43),
	2377: uint8(43),
	2378: uint8(43),
	2379: uint8(43),
	2380: uint8(43),
	2381: uint8(7),
	2382: uint8(0),
	2383: uint8(0),
	2384: uint8(0),
	2385: uint8(0),
	2386: uint8(86),
	2387: uint8(86),
	2388: uint8(86),
	2389: uint8(86),
	2390: uint8(86),
	2391: uint8(86),
	2392: uint8(86),
	2393: uint8(86),
	2394: uint8(86),
	2395: uint8(86),
	2396: uint8(86),
	2397: uint8(86),
	2398: uint8(86),
	2399: uint8(86),
	2400: uint8(86),
	2401: uint8(86),
	2402: uint8(86),
	2403: uint8(0),
	2404: uint8(0),
	2405: uint8(0),
	2406: uint8(0),
	2407: uint8(0),
	2408: uint8(0),
	2409: uint8(0),
	2410: uint8(0),
	2411: uint8(0),
	2412: uint8(0),
	2413: uint8(0),
	2414: uint8(0),
	2415: uint8(0),
	2416: uint8(0),
	2417: uint8(0),
	2418: uint8(0),
	2419: uint8(0),
	2420: uint8(0),
	2421: uint8(0),
	2422: uint8(0),
	2423: uint8(0),
	2424: uint8(0),
	2425: uint8(0),
	2426: uint8(0),
	2427: uint8(0),
	2428: uint8(0),
	2429: uint8(0),
	2430: uint8(0),
	2431: uint8(0),
	2432: uint8(0),
	2433: uint8(0),
	2434: uint8(0),
	2435: uint8(0),
	2436: uint8(0),
	2437: uint8(0),
	2438: uint8(0),
	2439: uint8(0),
	2440: uint8(0),
	2441: uint8(0),
	2442: uint8(0),
	2443: uint8(0),
	2444: uint8(0),
	2445: uint8(0),
	2446: uint8(0),
	2447: uint8(0),
	2448: uint8(0),
	2449: uint8(0),
	2450: uint8(0),
	2451: uint8(0),
	2452: uint8(0),
	2453: uint8(0),
	2454: uint8(0),
	2455: uint8(0),
	2456: uint8(0),
	2457: uint8(0),
	2458: uint8(0),
	2459: uint8(0),
	2460: uint8(0),
	2461: uint8(42),
	2462: uint8(43),
	2463: uint8(43),
	2464: uint8(43),
	2465: uint8(43),
	2466: uint8(43),
	2467: uint8(43),
	2468: uint8(43),
	2469: uint8(43),
	2470: uint8(43),
	2471: uint8(43),
	2472: uint8(86),
	2473: uint8(86),
	2474: uint8(86),
	2475: uint8(86),
	2476: uint8(86),
	2477: uint8(86),
	2478: uint8(86),
	2479: uint8(86),
	2480: uint8(86),
	2481: uint8(86),
	2482: uint8(14),
	2483: uint8(0),
	2484: uint8(0),
	2485: uint8(0),
	2486: uint8(0),
	2487: uint8(0),
	2488: uint8(0),
	2489: uint8(0),
	2490: uint8(0),
	2491: uint8(0),
	2492: uint8(0),
	2493: uint8(0),
	2494: uint8(0),
	2495: uint8(0),
	2496: uint8(0),
	2497: uint8(0),
	2498: uint8(0),
	2499: uint8(0),
	2500: uint8(0),
	2501: uint8(0),
	2502: uint8(0),
	2503: uint8(0),
	2504: uint8(0),
	2505: uint8(0),
	2506: uint8(0),
	2507: uint8(0),
	2508: uint8(0),
	2509: uint8(0),
	2510: uint8(0),
	2511: uint8(0),
	2512: uint8(0),
	2513: uint8(0),
	2514: uint8(0),
	2515: uint8(42),
	2516: uint8(43),
	2517: uint8(43),
	2518: uint8(43),
	2519: uint8(43),
	2520: uint8(43),
	2521: uint8(43),
	2522: uint8(43),
	2523: uint8(43),
	2524: uint8(43),
	2525: uint8(43),
	2526: uint8(86),
	2527: uint8(86),
	2528: uint8(86),
	2529: uint8(86),
	2530: uint8(86),
	2531: uint8(86),
	2532: uint8(86),
	2533: uint8(86),
	2534: uint8(86),
	2535: uint8(86),
	2536: uint8(14),
	2537: uint8(0),
	2538: uint8(0),
	2539: uint8(0),
	2540: uint8(0),
	2541: uint8(0),
	2542: uint8(0),
	2543: uint8(0),
	2544: uint8(0),
	2545: uint8(0),
	2546: uint8(0),
	2547: uint8(0),
	2548: uint8(0),
	2549: uint8(0),
	2550: uint8(0),
	2551: uint8(0),
	2552: uint8(0),
	2553: uint8(0),
	2554: uint8(0),
	2555: uint8(0),
	2556: uint8(0),
	2557: uint8(0),
	2558: uint8(0),
	2559: uint8(0),
	2560: uint8(0),
	2561: uint8(0),
	2562: uint8(0),
	2563: uint8(0),
	2564: uint8(0),
	2565: uint8(0),
	2566: uint8(0),
	2567: uint8(0),
	2568: uint8(0),
	2569: uint8(0),
	2570: uint8(0),
	2571: uint8(0),
	2572: uint8(0),
	2573: uint8(0),
	2574: uint8(0),
	2575: uint8(0),
	2576: uint8(0),
	2577: uint8(0),
	2578: uint8(0),
	2579: uint8(0),
	2580: uint8(43),
	2581: uint8(43),
	2582: uint8(43),
	2583: uint8(43),
	2584: uint8(43),
	2585: uint8(43),
	2586: uint8(43),
	2587: uint8(43),
	2588: uint8(43),
	2589: uint8(43),
	2590: uint8(43),
	2591: uint8(85),
	2592: uint8(86),
	2593: uint8(86),
	2594: uint8(86),
	2595: uint8(86),
	2596: uint8(86),
	2597: uint8(86),
	2598: uint8(86),
	2599: uint8(86),
	2600: uint8(86),
	2601: uint8(86),
	2602: uint8(14),
	2603: uint8(0),
	2604: uint8(0),
	2605: uint8(0),
	2606: uint8(0),
	2607: uint8(0),
	2608: uint8(0),
	2609: uint8(0),
	2610: uint8(0),
	2611: uint8(0),
	2612: uint8(0),
	2613: uint8(0),
	2614: uint8(0),
	2615: uint8(0),
	2616: uint8(0),
	2617: uint8(0),
	2618: uint8(0),
	2619: uint8(0),
	2620: uint8(0),
	2621: uint8(0),
	2622: uint8(0),
	2623: uint8(0),
	2624: uint8(0),
	2625: uint8(0),
	2626: uint8(0),
	2627: uint8(0),
	2628: uint8(0),
	2629: uint8(0),
	2630: uint8(0),
	2631: uint8(0),
	2632: uint8(0),
	2633: uint8(0),
	2634: uint8(0),
	2635: uint8(0),
	2636: uint8(0),
	2637: uint8(0),
	2638: uint8(0),
	2639: uint8(0),
	2640: uint8(0),
	2641: uint8(0),
	2642: uint8(0),
	2643: uint8(0),
	2644: uint8(0),
	2645: uint8(0),
	2646: uint8(0),
	2647: uint8(0),
	2648: uint8(0),
	2649: uint8(0),
	2650: uint8(0),
	2651: uint8(0),
	2652: uint8(0),
	2653: uint8(0),
	2654: uint8(0),
	2655: uint8(0),
	2656: uint8(0),
	2657: uint8(0),
	2658: uint8(0),
	2659: uint8(0),
	2660: uint8(0),
	2661: uint8(0),
	2662: uint8(0),
	2663: uint8(0),
	2664: uint8(0),
	2665: uint8(0)}
var _rules = [240]int32{
	0:   int32(0x0),
	1:   int32(0x2001),
	2:   -int32(0x2000),
	3:   int32(0x1dbf00),
	4:   int32(0x2e700),
	5:   int32(0x7900),
	6:   int32(0x2402),
	7:   int32(0x101),
	8:   -int32(0x100),
	9:   int32(0x0),
	10:  int32(0x201),
	11:  -int32(0x200),
	12:  -int32(0xc6ff),
	13:  -int32(0xe800),
	14:  -int32(0x78ff),
	15:  -int32(0x12c00),
	16:  int32(0xc300),
	17:  int32(0xd201),
	18:  int32(0xce01),
	19:  int32(0xcd01),
	20:  int32(0x4f01),
	21:  int32(0xca01),
	22:  int32(0xcb01),
	23:  int32(0xcf01),
	24:  int32(0x6100),
	25:  int32(0xd301),
	26:  int32(0xd101),
	27:  int32(0xa300),
	28:  int32(0xd501),
	29:  int32(0x8200),
	30:  int32(0xd601),
	31:  int32(0xda01),
	32:  int32(0xd901),
	33:  int32(0xdb01),
	34:  int32(0x3800),
	35:  int32(0x3),
	36:  -int32(0x4f00),
	37:  -int32(0x60ff),
	38:  -int32(0x37ff),
	39:  int32(0x242802),
	40:  int32(0x0),
	41:  int32(0x101),
	42:  -int32(0x100),
	43:  -int32(0xcd00),
	44:  -int32(0xda00),
	45:  -int32(0x81ff),
	46:  int32(0x2a2b01),
	47:  -int32(0xa2ff),
	48:  int32(0x2a2801),
	49:  int32(0x2a3f00),
	50:  -int32(0xc2ff),
	51:  int32(0x4501),
	52:  int32(0x4701),
	53:  int32(0x2a1f00),
	54:  int32(0x2a1c00),
	55:  int32(0x2a1e00),
	56:  -int32(0xd200),
	57:  -int32(0xce00),
	58:  -int32(0xca00),
	59:  -int32(0xcb00),
	60:  int32(0xa54f00),
	61:  int32(0xa54b00),
	62:  -int32(0xcf00),
	63:  int32(0xa52800),
	64:  int32(0xa54400),
	65:  -int32(0xd100),
	66:  -int32(0xd300),
	67:  int32(0x29f700),
	68:  int32(0xa54100),
	69:  int32(0x29fd00),
	70:  -int32(0xd500),
	71:  -int32(0xd600),
	72:  int32(0x29e700),
	73:  int32(0xa54300),
	74:  int32(0xa52a00),
	75:  -int32(0x4500),
	76:  -int32(0xd900),
	77:  -int32(0x4700),
	78:  -int32(0xdb00),
	79:  int32(0xa51500),
	80:  int32(0xa51200),
	81:  int32(0x4c2402),
	82:  int32(0x0),
	83:  int32(0x2001),
	84:  -int32(0x2000),
	85:  int32(0x101),
	86:  -int32(0x100),
	87:  int32(0x5400),
	88:  int32(0x7401),
	89:  int32(0x2601),
	90:  int32(0x2501),
	91:  int32(0x4001),
	92:  int32(0x3f01),
	93:  -int32(0x2600),
	94:  -int32(0x2500),
	95:  -int32(0x1f00),
	96:  -int32(0x4000),
	97:  -int32(0x3f00),
	98:  int32(0x801),
	99:  -int32(0x3e00),
	100: -int32(0x3900),
	101: -int32(0x2f00),
	102: -int32(0x3600),
	103: -int32(0x800),
	104: -int32(0x5600),
	105: -int32(0x5000),
	106: int32(0x700),
	107: -int32(0x7400),
	108: -int32(0x3bff),
	109: -int32(0x6000),
	110: -int32(0x6ff),
	111: int32(0x701a02),
	112: int32(0x101),
	113: -int32(0x100),
	114: int32(0x2001),
	115: -int32(0x2000),
	116: int32(0x5001),
	117: int32(0xf01),
	118: -int32(0xf00),
	119: int32(0x0),
	120: int32(0x3001),
	121: -int32(0x3000),
	122: int32(0x101),
	123: -int32(0x100),
	124: int32(0x0),
	125: int32(0xbc000),
	126: int32(0x1c6001),
	127: int32(0x0),
	128: int32(0x97d001),
	129: int32(0x801),
	130: -int32(0x800),
	131: int32(0x8a0502),
	132: int32(0x0),
	133: -int32(0xbbfff),
	134: -int32(0x186200),
	135: int32(0x89c200),
	136: -int32(0x182500),
	137: -int32(0x186e00),
	138: -int32(0x186d00),
	139: -int32(0x186400),
	140: -int32(0x186300),
	141: -int32(0x185c00),
	142: int32(0x0),
	143: int32(0x8a3800),
	144: int32(0x8a0400),
	145: int32(0xee600),
	146: int32(0x101),
	147: -int32(0x100),
	148: int32(0x0),
	149: -int32(0x3b00),
	150: -int32(0x1dbeff),
	151: int32(0x8f1d02),
	152: int32(0x800),
	153: -int32(0x7ff),
	154: int32(0x0),
	155: int32(0x5600),
	156: -int32(0x55ff),
	157: int32(0x4a00),
	158: int32(0x6400),
	159: int32(0x8000),
	160: int32(0x7000),
	161: int32(0x7e00),
	162: int32(0x900),
	163: -int32(0x49ff),
	164: -int32(0x8ff),
	165: -int32(0x1c2500),
	166: -int32(0x63ff),
	167: -int32(0x6fff),
	168: -int32(0x7fff),
	169: -int32(0x7dff),
	170: int32(0xac0502),
	171: int32(0x0),
	172: int32(0x1001),
	173: -int32(0x1000),
	174: int32(0x1c01),
	175: int32(0x101),
	176: -int32(0x1d5cff),
	177: -int32(0x20beff),
	178: -int32(0x2045ff),
	179: -int32(0x1c00),
	180: int32(0xb10b02),
	181: int32(0x101),
	182: -int32(0x100),
	183: int32(0x3001),
	184: -int32(0x3000),
	185: int32(0x0),
	186: -int32(0x29f6ff),
	187: -int32(0xee5ff),
	188: -int32(0x29e6ff),
	189: -int32(0x2a2b00),
	190: -int32(0x2a2800),
	191: -int32(0x2a1bff),
	192: -int32(0x29fcff),
	193: -int32(0x2a1eff),
	194: -int32(0x2a1dff),
	195: -int32(0x2a3eff),
	196: int32(0x0),
	197: -int32(0x1c6000),
	198: int32(0x0),
	199: int32(0x101),
	200: -int32(0x100),
	201: int32(0xbc0c02),
	202: int32(0x0),
	203: int32(0x101),
	204: -int32(0x100),
	205: -int32(0xa543ff),
	206: int32(0x3a001),
	207: -int32(0x8a03ff),
	208: -int32(0xa527ff),
	209: int32(0x3000),
	210: -int32(0xa54eff),
	211: -int32(0xa54aff),
	212: -int32(0xa540ff),
	213: -int32(0xa511ff),
	214: -int32(0xa529ff),
	215: -int32(0xa514ff),
	216: -int32(0x2fff),
	217: -int32(0xa542ff),
	218: -int32(0x8a37ff),
	219: int32(0x0),
	220: -int32(0x97d000),
	221: -int32(0x3a000),
	222: int32(0x0),
	223: int32(0x2001),
	224: -int32(0x2000),
	225: int32(0x0),
	226: int32(0x2801),
	227: -int32(0x2800),
	228: int32(0x0),
	229: int32(0x4001),
	230: -int32(0x4000),
	231: int32(0x0),
	232: int32(0x2001),
	233: -int32(0x2000),
	234: int32(0x0),
	235: int32(0x2001),
	236: -int32(0x2000),
	237: int32(0x0),
	238: int32(0x2201),
	239: -int32(0x2200)}
var _rulebases = [512]uint8{
	0:   uint8(0),
	1:   uint8(6),
	2:   uint8(39),
	3:   uint8(81),
	4:   uint8(111),
	5:   uint8(119),
	6:   uint8(0),
	7:   uint8(0),
	8:   uint8(0),
	9:   uint8(0),
	10:  uint8(0),
	11:  uint8(0),
	12:  uint8(0),
	13:  uint8(0),
	14:  uint8(0),
	15:  uint8(0),
	16:  uint8(124),
	17:  uint8(0),
	18:  uint8(0),
	19:  uint8(127),
	20:  uint8(0),
	21:  uint8(0),
	22:  uint8(0),
	23:  uint8(0),
	24:  uint8(0),
	25:  uint8(0),
	26:  uint8(0),
	27:  uint8(0),
	28:  uint8(131),
	29:  uint8(142),
	30:  uint8(146),
	31:  uint8(151),
	32:  uint8(0),
	33:  uint8(170),
	34:  uint8(0),
	35:  uint8(0),
	36:  uint8(0),
	37:  uint8(0),
	38:  uint8(0),
	39:  uint8(0),
	40:  uint8(0),
	41:  uint8(0),
	42:  uint8(0),
	43:  uint8(0),
	44:  uint8(180),
	45:  uint8(196),
	46:  uint8(0),
	47:  uint8(0),
	48:  uint8(0),
	49:  uint8(0),
	50:  uint8(0),
	51:  uint8(0),
	52:  uint8(0),
	53:  uint8(0),
	54:  uint8(0),
	55:  uint8(0),
	56:  uint8(0),
	57:  uint8(0),
	58:  uint8(0),
	59:  uint8(0),
	60:  uint8(0),
	61:  uint8(0),
	62:  uint8(0),
	63:  uint8(0),
	64:  uint8(0),
	65:  uint8(0),
	66:  uint8(0),
	67:  uint8(0),
	68:  uint8(0),
	69:  uint8(0),
	70:  uint8(0),
	71:  uint8(0),
	72:  uint8(0),
	73:  uint8(0),
	74:  uint8(0),
	75:  uint8(0),
	76:  uint8(0),
	77:  uint8(0),
	78:  uint8(0),
	79:  uint8(0),
	80:  uint8(0),
	81:  uint8(0),
	82:  uint8(0),
	83:  uint8(0),
	84:  uint8(0),
	85:  uint8(0),
	86:  uint8(0),
	87:  uint8(0),
	88:  uint8(0),
	89:  uint8(0),
	90:  uint8(0),
	91:  uint8(0),
	92:  uint8(0),
	93:  uint8(0),
	94:  uint8(0),
	95:  uint8(0),
	96:  uint8(0),
	97:  uint8(0),
	98:  uint8(0),
	99:  uint8(0),
	100: uint8(0),
	101: uint8(0),
	102: uint8(0),
	103: uint8(0),
	104: uint8(0),
	105: uint8(0),
	106: uint8(0),
	107: uint8(0),
	108: uint8(0),
	109: uint8(0),
	110: uint8(0),
	111: uint8(0),
	112: uint8(0),
	113: uint8(0),
	114: uint8(0),
	115: uint8(0),
	116: uint8(0),
	117: uint8(0),
	118: uint8(0),
	119: uint8(0),
	120: uint8(0),
	121: uint8(0),
	122: uint8(0),
	123: uint8(0),
	124: uint8(0),
	125: uint8(0),
	126: uint8(0),
	127: uint8(0),
	128: uint8(0),
	129: uint8(0),
	130: uint8(0),
	131: uint8(0),
	132: uint8(0),
	133: uint8(0),
	134: uint8(0),
	135: uint8(0),
	136: uint8(0),
	137: uint8(0),
	138: uint8(0),
	139: uint8(0),
	140: uint8(0),
	141: uint8(0),
	142: uint8(0),
	143: uint8(0),
	144: uint8(0),
	145: uint8(0),
	146: uint8(0),
	147: uint8(0),
	148: uint8(0),
	149: uint8(0),
	150: uint8(0),
	151: uint8(0),
	152: uint8(0),
	153: uint8(0),
	154: uint8(0),
	155: uint8(0),
	156: uint8(0),
	157: uint8(0),
	158: uint8(0),
	159: uint8(0),
	160: uint8(0),
	161: uint8(0),
	162: uint8(0),
	163: uint8(0),
	164: uint8(0),
	165: uint8(0),
	166: uint8(198),
	167: uint8(201),
	168: uint8(0),
	169: uint8(0),
	170: uint8(0),
	171: uint8(219),
	172: uint8(0),
	173: uint8(0),
	174: uint8(0),
	175: uint8(0),
	176: uint8(0),
	177: uint8(0),
	178: uint8(0),
	179: uint8(0),
	180: uint8(0),
	181: uint8(0),
	182: uint8(0),
	183: uint8(0),
	184: uint8(0),
	185: uint8(0),
	186: uint8(0),
	187: uint8(0),
	188: uint8(0),
	189: uint8(0),
	190: uint8(0),
	191: uint8(0),
	192: uint8(0),
	193: uint8(0),
	194: uint8(0),
	195: uint8(0),
	196: uint8(0),
	197: uint8(0),
	198: uint8(0),
	199: uint8(0),
	200: uint8(0),
	201: uint8(0),
	202: uint8(0),
	203: uint8(0),
	204: uint8(0),
	205: uint8(0),
	206: uint8(0),
	207: uint8(0),
	208: uint8(0),
	209: uint8(0),
	210: uint8(0),
	211: uint8(0),
	212: uint8(0),
	213: uint8(0),
	214: uint8(0),
	215: uint8(0),
	216: uint8(0),
	217: uint8(0),
	218: uint8(0),
	219: uint8(0),
	220: uint8(0),
	221: uint8(0),
	222: uint8(0),
	223: uint8(0),
	224: uint8(0),
	225: uint8(0),
	226: uint8(0),
	227: uint8(0),
	228: uint8(0),
	229: uint8(0),
	230: uint8(0),
	231: uint8(0),
	232: uint8(0),
	233: uint8(0),
	234: uint8(0),
	235: uint8(0),
	236: uint8(0),
	237: uint8(0),
	238: uint8(0),
	239: uint8(0),
	240: uint8(0),
	241: uint8(0),
	242: uint8(0),
	243: uint8(0),
	244: uint8(0),
	245: uint8(0),
	246: uint8(0),
	247: uint8(0),
	248: uint8(0),
	249: uint8(0),
	250: uint8(0),
	251: uint8(0),
	252: uint8(0),
	253: uint8(0),
	254: uint8(0),
	255: uint8(222),
	256: uint8(0),
	257: uint8(0),
	258: uint8(0),
	259: uint8(0),
	260: uint8(225),
	261: uint8(0),
	262: uint8(0),
	263: uint8(0),
	264: uint8(0),
	265: uint8(0),
	266: uint8(0),
	267: uint8(0),
	268: uint8(228),
	269: uint8(0),
	270: uint8(0),
	271: uint8(0),
	272: uint8(0),
	273: uint8(0),
	274: uint8(0),
	275: uint8(0),
	276: uint8(0),
	277: uint8(0),
	278: uint8(0),
	279: uint8(0),
	280: uint8(231),
	281: uint8(0),
	282: uint8(0),
	283: uint8(0),
	284: uint8(0),
	285: uint8(0),
	286: uint8(0),
	287: uint8(0),
	288: uint8(0),
	289: uint8(0),
	290: uint8(0),
	291: uint8(0),
	292: uint8(0),
	293: uint8(0),
	294: uint8(0),
	295: uint8(0),
	296: uint8(0),
	297: uint8(0),
	298: uint8(0),
	299: uint8(0),
	300: uint8(0),
	301: uint8(0),
	302: uint8(0),
	303: uint8(0),
	304: uint8(0),
	305: uint8(0),
	306: uint8(0),
	307: uint8(0),
	308: uint8(0),
	309: uint8(0),
	310: uint8(0),
	311: uint8(0),
	312: uint8(0),
	313: uint8(0),
	314: uint8(0),
	315: uint8(0),
	316: uint8(0),
	317: uint8(0),
	318: uint8(0),
	319: uint8(0),
	320: uint8(0),
	321: uint8(0),
	322: uint8(0),
	323: uint8(0),
	324: uint8(0),
	325: uint8(0),
	326: uint8(0),
	327: uint8(0),
	328: uint8(0),
	329: uint8(0),
	330: uint8(0),
	331: uint8(0),
	332: uint8(0),
	333: uint8(0),
	334: uint8(0),
	335: uint8(0),
	336: uint8(0),
	337: uint8(0),
	338: uint8(0),
	339: uint8(0),
	340: uint8(0),
	341: uint8(0),
	342: uint8(0),
	343: uint8(0),
	344: uint8(0),
	345: uint8(0),
	346: uint8(0),
	347: uint8(0),
	348: uint8(0),
	349: uint8(0),
	350: uint8(0),
	351: uint8(0),
	352: uint8(0),
	353: uint8(0),
	354: uint8(0),
	355: uint8(0),
	356: uint8(0),
	357: uint8(0),
	358: uint8(0),
	359: uint8(0),
	360: uint8(0),
	361: uint8(0),
	362: uint8(0),
	363: uint8(0),
	364: uint8(0),
	365: uint8(0),
	366: uint8(234),
	367: uint8(0),
	368: uint8(0),
	369: uint8(0),
	370: uint8(0),
	371: uint8(0),
	372: uint8(0),
	373: uint8(0),
	374: uint8(0),
	375: uint8(0),
	376: uint8(0),
	377: uint8(0),
	378: uint8(0),
	379: uint8(0),
	380: uint8(0),
	381: uint8(0),
	382: uint8(0),
	383: uint8(0),
	384: uint8(0),
	385: uint8(0),
	386: uint8(0),
	387: uint8(0),
	388: uint8(0),
	389: uint8(0),
	390: uint8(0),
	391: uint8(0),
	392: uint8(0),
	393: uint8(0),
	394: uint8(0),
	395: uint8(0),
	396: uint8(0),
	397: uint8(0),
	398: uint8(0),
	399: uint8(0),
	400: uint8(0),
	401: uint8(0),
	402: uint8(0),
	403: uint8(0),
	404: uint8(0),
	405: uint8(0),
	406: uint8(0),
	407: uint8(0),
	408: uint8(0),
	409: uint8(0),
	410: uint8(0),
	411: uint8(0),
	412: uint8(0),
	413: uint8(0),
	414: uint8(0),
	415: uint8(0),
	416: uint8(0),
	417: uint8(0),
	418: uint8(0),
	419: uint8(0),
	420: uint8(0),
	421: uint8(0),
	422: uint8(0),
	423: uint8(0),
	424: uint8(0),
	425: uint8(0),
	426: uint8(0),
	427: uint8(0),
	428: uint8(0),
	429: uint8(0),
	430: uint8(0),
	431: uint8(0),
	432: uint8(0),
	433: uint8(0),
	434: uint8(0),
	435: uint8(0),
	436: uint8(0),
	437: uint8(0),
	438: uint8(0),
	439: uint8(0),
	440: uint8(0),
	441: uint8(0),
	442: uint8(0),
	443: uint8(0),
	444: uint8(0),
	445: uint8(0),
	446: uint8(0),
	447: uint8(0),
	448: uint8(0),
	449: uint8(0),
	450: uint8(0),
	451: uint8(0),
	452: uint8(0),
	453: uint8(0),
	454: uint8(0),
	455: uint8(0),
	456: uint8(0),
	457: uint8(0),
	458: uint8(0),
	459: uint8(0),
	460: uint8(0),
	461: uint8(0),
	462: uint8(0),
	463: uint8(0),
	464: uint8(0),
	465: uint8(0),
	466: uint8(0),
	467: uint8(0),
	468: uint8(0),
	469: uint8(0),
	470: uint8(0),
	471: uint8(0),
	472: uint8(0),
	473: uint8(0),
	474: uint8(0),
	475: uint8(0),
	476: uint8(0),
	477: uint8(0),
	478: uint8(0),
	479: uint8(0),
	480: uint8(0),
	481: uint8(0),
	482: uint8(0),
	483: uint8(0),
	484: uint8(0),
	485: uint8(0),
	486: uint8(0),
	487: uint8(0),
	488: uint8(0),
	489: uint8(237),
	490: uint8(0),
	491: uint8(0),
	492: uint8(0),
	493: uint8(0),
	494: uint8(0),
	495: uint8(0),
	496: uint8(0),
	497: uint8(0),
	498: uint8(0),
	499: uint8(0),
	500: uint8(0),
	501: uint8(0),
	502: uint8(0),
	503: uint8(0),
	504: uint8(0),
	505: uint8(0),
	506: uint8(0),
	507: uint8(0),
	508: uint8(0),
	509: uint8(0),
	510: uint8(0),
	511: uint8(0)}
var _exceptions = [200][2]uint8{
	0: {
		0: uint8(48),
		1: uint8(12)},
	1: {
		0: uint8(49),
		1: uint8(13)},
	2: {
		0: uint8(120),
		1: uint8(14)},
	3: {
		0: uint8(127),
		1: uint8(15)},
	4: {
		0: uint8(128),
		1: uint8(16)},
	5: {
		0: uint8(129),
		1: uint8(17)},
	6: {
		0: uint8(134),
		1: uint8(18)},
	7: {
		0: uint8(137),
		1: uint8(19)},
	8: {
		0: uint8(138),
		1: uint8(19)},
	9: {
		0: uint8(142),
		1: uint8(20)},
	10: {
		0: uint8(143),
		1: uint8(21)},
	11: {
		0: uint8(144),
		1: uint8(22)},
	12: {
		0: uint8(147),
		1: uint8(19)},
	13: {
		0: uint8(148),
		1: uint8(23)},
	14: {
		0: uint8(149),
		1: uint8(24)},
	15: {
		0: uint8(150),
		1: uint8(25)},
	16: {
		0: uint8(151),
		1: uint8(26)},
	17: {
		0: uint8(154),
		1: uint8(27)},
	18: {
		0: uint8(156),
		1: uint8(25)},
	19: {
		0: uint8(157),
		1: uint8(28)},
	20: {
		0: uint8(158),
		1: uint8(29)},
	21: {
		0: uint8(159),
		1: uint8(30)},
	22: {
		0: uint8(166),
		1: uint8(31)},
	23: {
		0: uint8(169),
		1: uint8(31)},
	24: {
		0: uint8(174),
		1: uint8(31)},
	25: {
		0: uint8(177),
		1: uint8(32)},
	26: {
		0: uint8(178),
		1: uint8(32)},
	27: {
		0: uint8(183),
		1: uint8(33)},
	28: {
		0: uint8(191),
		1: uint8(34)},
	29: {
		0: uint8(197),
		1: uint8(35)},
	30: {
		0: uint8(200),
		1: uint8(35)},
	31: {
		0: uint8(203),
		1: uint8(35)},
	32: {
		0: uint8(221),
		1: uint8(36)},
	33: {
		0: uint8(242),
		1: uint8(35)},
	34: {
		0: uint8(246),
		1: uint8(37)},
	35: {
		0: uint8(247),
		1: uint8(38)},
	36: {
		0: uint8(32),
		1: uint8(45)},
	37: {
		0: uint8(58),
		1: uint8(46)},
	38: {
		0: uint8(61),
		1: uint8(47)},
	39: {
		0: uint8(62),
		1: uint8(48)},
	40: {
		0: uint8(63),
		1: uint8(49)},
	41: {
		0: uint8(64),
		1: uint8(49)},
	42: {
		0: uint8(67),
		1: uint8(50)},
	43: {
		0: uint8(68),
		1: uint8(51)},
	44: {
		0: uint8(69),
		1: uint8(52)},
	45: {
		0: uint8(80),
		1: uint8(53)},
	46: {
		0: uint8(81),
		1: uint8(54)},
	47: {
		0: uint8(82),
		1: uint8(55)},
	48: {
		0: uint8(83),
		1: uint8(56)},
	49: {
		0: uint8(84),
		1: uint8(57)},
	50: {
		0: uint8(89),
		1: uint8(58)},
	51: {
		0: uint8(91),
		1: uint8(59)},
	52: {
		0: uint8(92),
		1: uint8(60)},
	53: {
		0: uint8(97),
		1: uint8(61)},
	54: {
		0: uint8(99),
		1: uint8(62)},
	55: {
		0: uint8(101),
		1: uint8(63)},
	56: {
		0: uint8(102),
		1: uint8(64)},
	57: {
		0: uint8(104),
		1: uint8(65)},
	58: {
		0: uint8(105),
		1: uint8(66)},
	59: {
		0: uint8(106),
		1: uint8(64)},
	60: {
		0: uint8(107),
		1: uint8(67)},
	61: {
		0: uint8(108),
		1: uint8(68)},
	62: {
		0: uint8(111),
		1: uint8(66)},
	63: {
		0: uint8(113),
		1: uint8(69)},
	64: {
		0: uint8(114),
		1: uint8(70)},
	65: {
		0: uint8(117),
		1: uint8(71)},
	66: {
		0: uint8(125),
		1: uint8(72)},
	67: {
		0: uint8(130),
		1: uint8(73)},
	68: {
		0: uint8(135),
		1: uint8(74)},
	69: {
		0: uint8(137),
		1: uint8(75)},
	70: {
		0: uint8(138),
		1: uint8(76)},
	71: {
		0: uint8(139),
		1: uint8(76)},
	72: {
		0: uint8(140),
		1: uint8(77)},
	73: {
		0: uint8(146),
		1: uint8(78)},
	74: {
		0: uint8(157),
		1: uint8(79)},
	75: {
		0: uint8(158),
		1: uint8(80)},
	76: {
		0: uint8(69),
		1: uint8(87)},
	77: {
		0: uint8(123),
		1: uint8(29)},
	78: {
		0: uint8(124),
		1: uint8(29)},
	79: {
		0: uint8(125),
		1: uint8(29)},
	80: {
		0: uint8(127),
		1: uint8(88)},
	81: {
		0: uint8(134),
		1: uint8(89)},
	82: {
		0: uint8(136),
		1: uint8(90)},
	83: {
		0: uint8(137),
		1: uint8(90)},
	84: {
		0: uint8(138),
		1: uint8(90)},
	85: {
		0: uint8(140),
		1: uint8(91)},
	86: {
		0: uint8(142),
		1: uint8(92)},
	87: {
		0: uint8(143),
		1: uint8(92)},
	88: {
		0: uint8(172),
		1: uint8(93)},
	89: {
		0: uint8(173),
		1: uint8(94)},
	90: {
		0: uint8(174),
		1: uint8(94)},
	91: {
		0: uint8(175),
		1: uint8(94)},
	92: {
		0: uint8(194),
		1: uint8(95)},
	93: {
		0: uint8(204),
		1: uint8(96)},
	94: {
		0: uint8(205),
		1: uint8(97)},
	95: {
		0: uint8(206),
		1: uint8(97)},
	96: {
		0: uint8(207),
		1: uint8(98)},
	97: {
		0: uint8(208),
		1: uint8(99)},
	98: {
		0: uint8(209),
		1: uint8(100)},
	99: {
		0: uint8(213),
		1: uint8(101)},
	100: {
		0: uint8(214),
		1: uint8(102)},
	101: {
		0: uint8(215),
		1: uint8(103)},
	102: {
		0: uint8(240),
		1: uint8(104)},
	103: {
		0: uint8(241),
		1: uint8(105)},
	104: {
		0: uint8(242),
		1: uint8(106)},
	105: {
		0: uint8(243),
		1: uint8(107)},
	106: {
		0: uint8(244),
		1: uint8(108)},
	107: {
		0: uint8(245),
		1: uint8(109)},
	108: {
		0: uint8(249),
		1: uint8(110)},
	109: {
		0: uint8(253),
		1: uint8(45)},
	110: {
		0: uint8(254),
		1: uint8(45)},
	111: {
		0: uint8(255),
		1: uint8(45)},
	112: {
		0: uint8(80),
		1: uint8(105)},
	113: {
		0: uint8(81),
		1: uint8(105)},
	114: {
		0: uint8(82),
		1: uint8(105)},
	115: {
		0: uint8(83),
		1: uint8(105)},
	116: {
		0: uint8(84),
		1: uint8(105)},
	117: {
		0: uint8(85),
		1: uint8(105)},
	118: {
		0: uint8(86),
		1: uint8(105)},
	119: {
		0: uint8(87),
		1: uint8(105)},
	120: {
		0: uint8(88),
		1: uint8(105)},
	121: {
		0: uint8(89),
		1: uint8(105)},
	122: {
		0: uint8(90),
		1: uint8(105)},
	123: {
		0: uint8(91),
		1: uint8(105)},
	124: {
		0: uint8(92),
		1: uint8(105)},
	125: {
		0: uint8(93),
		1: uint8(105)},
	126: {
		0: uint8(94),
		1: uint8(105)},
	127: {
		0: uint8(95),
		1: uint8(105)},
	128: {
		0: uint8(130),
		1: uint8(0)},
	129: {
		0: uint8(131),
		1: uint8(0)},
	130: {
		0: uint8(132),
		1: uint8(0)},
	131: {
		0: uint8(133),
		1: uint8(0)},
	132: {
		0: uint8(134),
		1: uint8(0)},
	133: {
		0: uint8(135),
		1: uint8(0)},
	134: {
		0: uint8(136),
		1: uint8(0)},
	135: {
		0: uint8(137),
		1: uint8(0)},
	136: {
		0: uint8(192),
		1: uint8(117)},
	137: {
		0: uint8(207),
		1: uint8(118)},
	138: {
		0: uint8(128),
		1: uint8(137)},
	139: {
		0: uint8(129),
		1: uint8(138)},
	140: {
		0: uint8(130),
		1: uint8(139)},
	141: {
		0: uint8(133),
		1: uint8(140)},
	142: {
		0: uint8(134),
		1: uint8(141)},
	143: {
		0: uint8(112),
		1: uint8(157)},
	144: {
		0: uint8(113),
		1: uint8(157)},
	145: {
		0: uint8(118),
		1: uint8(158)},
	146: {
		0: uint8(119),
		1: uint8(158)},
	147: {
		0: uint8(120),
		1: uint8(159)},
	148: {
		0: uint8(121),
		1: uint8(159)},
	149: {
		0: uint8(122),
		1: uint8(160)},
	150: {
		0: uint8(123),
		1: uint8(160)},
	151: {
		0: uint8(124),
		1: uint8(161)},
	152: {
		0: uint8(125),
		1: uint8(161)},
	153: {
		0: uint8(179),
		1: uint8(162)},
	154: {
		0: uint8(186),
		1: uint8(163)},
	155: {
		0: uint8(187),
		1: uint8(163)},
	156: {
		0: uint8(188),
		1: uint8(164)},
	157: {
		0: uint8(190),
		1: uint8(165)},
	158: {
		0: uint8(195),
		1: uint8(162)},
	159: {
		0: uint8(204),
		1: uint8(164)},
	160: {
		0: uint8(218),
		1: uint8(166)},
	161: {
		0: uint8(219),
		1: uint8(166)},
	162: {
		0: uint8(229),
		1: uint8(106)},
	163: {
		0: uint8(234),
		1: uint8(167)},
	164: {
		0: uint8(235),
		1: uint8(167)},
	165: {
		0: uint8(236),
		1: uint8(110)},
	166: {
		0: uint8(243),
		1: uint8(162)},
	167: {
		0: uint8(248),
		1: uint8(168)},
	168: {
		0: uint8(249),
		1: uint8(168)},
	169: {
		0: uint8(250),
		1: uint8(169)},
	170: {
		0: uint8(251),
		1: uint8(169)},
	171: {
		0: uint8(252),
		1: uint8(164)},
	172: {
		0: uint8(38),
		1: uint8(176)},
	173: {
		0: uint8(42),
		1: uint8(177)},
	174: {
		0: uint8(43),
		1: uint8(178)},
	175: {
		0: uint8(78),
		1: uint8(179)},
	176: {
		0: uint8(132),
		1: uint8(8)},
	177: {
		0: uint8(98),
		1: uint8(186)},
	178: {
		0: uint8(99),
		1: uint8(187)},
	179: {
		0: uint8(100),
		1: uint8(188)},
	180: {
		0: uint8(101),
		1: uint8(189)},
	181: {
		0: uint8(102),
		1: uint8(190)},
	182: {
		0: uint8(109),
		1: uint8(191)},
	183: {
		0: uint8(110),
		1: uint8(192)},
	184: {
		0: uint8(111),
		1: uint8(193)},
	185: {
		0: uint8(112),
		1: uint8(194)},
	186: {
		0: uint8(126),
		1: uint8(195)},
	187: {
		0: uint8(127),
		1: uint8(195)},
	188: {
		0: uint8(125),
		1: uint8(207)},
	189: {
		0: uint8(141),
		1: uint8(208)},
	190: {
		0: uint8(148),
		1: uint8(209)},
	191: {
		0: uint8(171),
		1: uint8(210)},
	192: {
		0: uint8(172),
		1: uint8(211)},
	193: {
		0: uint8(173),
		1: uint8(212)},
	194: {
		0: uint8(176),
		1: uint8(213)},
	195: {
		0: uint8(177),
		1: uint8(214)},
	196: {
		0: uint8(178),
		1: uint8(215)},
	197: {
		0: uint8(196),
		1: uint8(216)},
	198: {
		0: uint8(197),
		1: uint8(217)},
	199: {
		0: uint8(198),
		1: uint8(218)}}

func _casemap(tls *TLS, c uint32, dir int32) (r1 int32) {
	var b uint32
	var c0 int32
	var r int32
	var rd int32
	var rt uint32
	var try uint32
	var v uint32
	var x uint32
	var xb uint32
	var xn uint32
	var y uint32
	var v1 int32
	c0 = int32(c)
	if c >= uint32(0x20000) {
		return int32(c)
	}
	b = c >> int32(8)
	c = c & Uint32FromInt32(255)
	x = c / uint32(3)
	y = c % uint32(3)
	/* lookup entry in two-level base-6 table */
	v = uint32(_tab1[uint32(int32(_tab1[b])*int32(86))+x])
	v = v * uint32(_mt[y]) >> int32(11) % uint32(6)
	/* use the bit vector out of the tables as an index into
	 * a block-specific set of rules and decode the rule into
	 * a type and a case-mapping delta. */
	r = _rules[uint32(_rulebases[b])+v]
	rt = uint32(r & int32(255))
	rd = r >> int32(8)
	/* rules 0/1 are simple lower/upper case with a delta.
	 * apply according to desired mapping direction. */
	if rt < uint32(2) {
		return int32(uint32(c0) + uint32(rd)&-(rt^uint32(dir)))
	}
	/* binary search. endpoints of the binary search for
	 * this block are stored in the rule delta field. */
	xn = uint32(rd & int32(0xff))
	xb = uint32(rd) >> int32(8)
	for xn != 0 {
		try = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_exceptions)) + uintptr(xb+xn/Uint32FromInt32(2))*2 + UintptrFromInt32(0))))
		if try == c {
			r = _rules[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_exceptions)) + uintptr(xb+xn/Uint32FromInt32(2))*2 + UintptrFromInt32(1)))]
			rt = uint32(r & int32(255))
			rd = r >> int32(8)
			if rt < uint32(2) {
				return int32(uint32(c0) + uint32(rd)&-(rt^uint32(dir)))
			}
			/* Hard-coded for the four exceptional titlecase */
			if dir != 0 {
				v1 = -int32(1)
			} else {
				v1 = int32(1)
			}
			return c0 + v1
		} else {
			if try > c {
				xn = xn / Uint32FromInt32(2)
			} else {
				xb = xb + xn/Uint32FromInt32(2)
				xn = xn - xn/Uint32FromInt32(2)
			}
		}
	}
	return c0
}

var _mt = [3]int32{
	0: int32(2048),
	1: int32(342),
	2: int32(57)}

func x_towlower(tls *TLS, wc Twint_t) (r Twint_t) {
	return uint32(_casemap(tls, wc, int32(0)))
}

func x_towupper(tls *TLS, wc Twint_t) (r Twint_t) {
	return uint32(_casemap(tls, wc, int32(1)))
}

func x___towupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	return x_towupper(tls, c)
}

func x___towlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	return x_towlower(tls, c)
}

func x_wcswidth(tls *TLS, wcs uintptr, n Tsize_t) (r int32) {
	var k int32
	var l int32
	var v1 Tsize_t
	var v2 int32
	var v3 bool
	var v5 int32
	l = int32(0)
	k = int32(0)
	for {
		v1 = n
		n--
		if v3 = v1 != 0 && *(*Twchar_t)(unsafe.Pointer(wcs)) != 0; v3 {
			v2 = x_wcwidth(tls, *(*Twchar_t)(unsafe.Pointer(wcs)))
			k = v2
		}
		if !(v3 && v2 >= int32(0)) {
			break
		}
		goto _4
	_4:
		l = l + k
		wcs += 4
	}
	if k < int32(0) {
		v5 = k
	} else {
		v5 = l
	}
	return v5
}

func x_wctrans(tls *TLS, class uintptr) (r Twctrans_t) {
	if !(x_strcmp(tls, class, ts+191) != 0) {
		return UintptrFromInt32(1)
	}
	if !(x_strcmp(tls, class, ts+199) != 0) {
		return UintptrFromInt32(2)
	}
	return uintptr(0)
}

func x_towctrans(tls *TLS, wc Twint_t, trans Twctrans_t) (r Twint_t) {
	if trans == UintptrFromInt32(1) {
		return x_towupper(tls, wc)
	}
	if trans == UintptrFromInt32(2) {
		return x_towlower(tls, wc)
	}
	return wc
}

func x___wctrans_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctrans_t) {
	return x_wctrans(tls, s)
}

func x___towctrans_l(tls *TLS, c Twint_t, t Twctrans_t, l Tlocale_t) (r Twint_t) {
	return x_towctrans(tls, c, t)
}

var _table5 = [2784]uint8{
	0:    uint8(16),
	1:    uint8(16),
	2:    uint8(16),
	3:    uint8(18),
	4:    uint8(19),
	5:    uint8(20),
	6:    uint8(21),
	7:    uint8(22),
	8:    uint8(23),
	9:    uint8(24),
	10:   uint8(25),
	11:   uint8(26),
	12:   uint8(27),
	13:   uint8(28),
	14:   uint8(29),
	15:   uint8(30),
	16:   uint8(31),
	17:   uint8(32),
	18:   uint8(16),
	19:   uint8(33),
	20:   uint8(16),
	21:   uint8(16),
	22:   uint8(16),
	23:   uint8(34),
	24:   uint8(35),
	25:   uint8(36),
	26:   uint8(37),
	27:   uint8(38),
	28:   uint8(39),
	29:   uint8(40),
	30:   uint8(16),
	31:   uint8(16),
	32:   uint8(41),
	33:   uint8(16),
	34:   uint8(16),
	35:   uint8(16),
	36:   uint8(16),
	37:   uint8(16),
	38:   uint8(16),
	39:   uint8(16),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(16),
	44:   uint8(42),
	45:   uint8(43),
	46:   uint8(16),
	47:   uint8(16),
	48:   uint8(44),
	49:   uint8(16),
	50:   uint8(16),
	51:   uint8(16),
	52:   uint8(16),
	53:   uint8(16),
	54:   uint8(16),
	55:   uint8(16),
	56:   uint8(16),
	57:   uint8(16),
	58:   uint8(16),
	59:   uint8(16),
	60:   uint8(16),
	61:   uint8(16),
	62:   uint8(16),
	63:   uint8(16),
	64:   uint8(16),
	65:   uint8(16),
	66:   uint8(16),
	67:   uint8(16),
	68:   uint8(16),
	69:   uint8(16),
	70:   uint8(16),
	71:   uint8(16),
	72:   uint8(16),
	73:   uint8(16),
	74:   uint8(16),
	75:   uint8(16),
	76:   uint8(16),
	77:   uint8(16),
	78:   uint8(16),
	79:   uint8(16),
	80:   uint8(16),
	81:   uint8(16),
	82:   uint8(16),
	83:   uint8(16),
	84:   uint8(16),
	85:   uint8(16),
	86:   uint8(16),
	87:   uint8(16),
	88:   uint8(16),
	89:   uint8(16),
	90:   uint8(16),
	91:   uint8(16),
	92:   uint8(16),
	93:   uint8(16),
	94:   uint8(16),
	95:   uint8(16),
	96:   uint8(16),
	97:   uint8(16),
	98:   uint8(16),
	99:   uint8(16),
	100:  uint8(16),
	101:  uint8(16),
	102:  uint8(16),
	103:  uint8(16),
	104:  uint8(16),
	105:  uint8(16),
	106:  uint8(16),
	107:  uint8(16),
	108:  uint8(16),
	109:  uint8(16),
	110:  uint8(16),
	111:  uint8(16),
	112:  uint8(16),
	113:  uint8(16),
	114:  uint8(16),
	115:  uint8(16),
	116:  uint8(16),
	117:  uint8(16),
	118:  uint8(16),
	119:  uint8(16),
	120:  uint8(16),
	121:  uint8(16),
	122:  uint8(16),
	123:  uint8(16),
	124:  uint8(16),
	125:  uint8(16),
	126:  uint8(16),
	127:  uint8(16),
	128:  uint8(16),
	129:  uint8(16),
	130:  uint8(16),
	131:  uint8(16),
	132:  uint8(16),
	133:  uint8(16),
	134:  uint8(16),
	135:  uint8(16),
	136:  uint8(16),
	137:  uint8(16),
	138:  uint8(16),
	139:  uint8(16),
	140:  uint8(16),
	141:  uint8(16),
	142:  uint8(16),
	143:  uint8(16),
	144:  uint8(16),
	145:  uint8(16),
	146:  uint8(16),
	147:  uint8(16),
	148:  uint8(16),
	149:  uint8(16),
	150:  uint8(16),
	151:  uint8(16),
	152:  uint8(16),
	153:  uint8(16),
	154:  uint8(16),
	155:  uint8(16),
	156:  uint8(16),
	157:  uint8(16),
	158:  uint8(16),
	159:  uint8(16),
	160:  uint8(16),
	161:  uint8(16),
	162:  uint8(16),
	163:  uint8(16),
	164:  uint8(16),
	165:  uint8(16),
	166:  uint8(45),
	167:  uint8(16),
	168:  uint8(46),
	169:  uint8(47),
	170:  uint8(48),
	171:  uint8(49),
	172:  uint8(16),
	173:  uint8(16),
	174:  uint8(16),
	175:  uint8(16),
	176:  uint8(16),
	177:  uint8(16),
	178:  uint8(16),
	179:  uint8(16),
	180:  uint8(16),
	181:  uint8(16),
	182:  uint8(16),
	183:  uint8(16),
	184:  uint8(16),
	185:  uint8(16),
	186:  uint8(16),
	187:  uint8(16),
	188:  uint8(16),
	189:  uint8(16),
	190:  uint8(16),
	191:  uint8(16),
	192:  uint8(16),
	193:  uint8(16),
	194:  uint8(16),
	195:  uint8(16),
	196:  uint8(16),
	197:  uint8(16),
	198:  uint8(16),
	199:  uint8(16),
	200:  uint8(16),
	201:  uint8(16),
	202:  uint8(16),
	203:  uint8(16),
	204:  uint8(16),
	205:  uint8(16),
	206:  uint8(16),
	207:  uint8(16),
	208:  uint8(16),
	209:  uint8(16),
	210:  uint8(16),
	211:  uint8(16),
	212:  uint8(16),
	213:  uint8(16),
	214:  uint8(16),
	215:  uint8(50),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(16),
	250:  uint8(16),
	251:  uint8(51),
	252:  uint8(16),
	253:  uint8(16),
	254:  uint8(52),
	255:  uint8(53),
	256:  uint8(16),
	257:  uint8(54),
	258:  uint8(55),
	259:  uint8(56),
	260:  uint8(16),
	261:  uint8(16),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(16),
	265:  uint8(16),
	266:  uint8(57),
	267:  uint8(16),
	268:  uint8(16),
	269:  uint8(58),
	270:  uint8(16),
	271:  uint8(59),
	272:  uint8(60),
	273:  uint8(61),
	274:  uint8(62),
	275:  uint8(63),
	276:  uint8(64),
	277:  uint8(65),
	278:  uint8(66),
	279:  uint8(67),
	280:  uint8(68),
	281:  uint8(69),
	282:  uint8(70),
	283:  uint8(16),
	284:  uint8(71),
	285:  uint8(72),
	286:  uint8(73),
	287:  uint8(16),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(16),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(74),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(75),
	363:  uint8(76),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(16),
	367:  uint8(77),
	368:  uint8(16),
	369:  uint8(16),
	370:  uint8(16),
	371:  uint8(16),
	372:  uint8(16),
	373:  uint8(16),
	374:  uint8(16),
	375:  uint8(16),
	376:  uint8(16),
	377:  uint8(16),
	378:  uint8(16),
	379:  uint8(16),
	380:  uint8(16),
	381:  uint8(16),
	382:  uint8(16),
	383:  uint8(16),
	384:  uint8(16),
	385:  uint8(16),
	386:  uint8(16),
	387:  uint8(16),
	388:  uint8(16),
	389:  uint8(16),
	390:  uint8(16),
	391:  uint8(16),
	392:  uint8(16),
	393:  uint8(16),
	394:  uint8(16),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(16),
	433:  uint8(16),
	434:  uint8(16),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(78),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(79),
	466:  uint8(80),
	467:  uint8(16),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(16),
	471:  uint8(16),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(81),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(82),
	481:  uint8(83),
	482:  uint8(84),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(85),
	489:  uint8(86),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(16),
	495:  uint8(16),
	496:  uint8(16),
	497:  uint8(16),
	498:  uint8(16),
	499:  uint8(16),
	500:  uint8(16),
	501:  uint8(16),
	502:  uint8(16),
	503:  uint8(16),
	504:  uint8(16),
	505:  uint8(16),
	506:  uint8(16),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	512:  uint8(0),
	513:  uint8(0),
	514:  uint8(0),
	515:  uint8(0),
	516:  uint8(0),
	517:  uint8(0),
	518:  uint8(0),
	519:  uint8(0),
	520:  uint8(0),
	521:  uint8(0),
	522:  uint8(0),
	523:  uint8(0),
	524:  uint8(0),
	525:  uint8(0),
	526:  uint8(0),
	527:  uint8(0),
	528:  uint8(0),
	529:  uint8(0),
	530:  uint8(0),
	531:  uint8(0),
	532:  uint8(0),
	533:  uint8(0),
	534:  uint8(0),
	535:  uint8(0),
	536:  uint8(0),
	537:  uint8(0),
	538:  uint8(0),
	539:  uint8(0),
	540:  uint8(0),
	541:  uint8(0),
	542:  uint8(0),
	543:  uint8(0),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(255),
	577:  uint8(255),
	578:  uint8(255),
	579:  uint8(255),
	580:  uint8(255),
	581:  uint8(255),
	582:  uint8(255),
	583:  uint8(255),
	584:  uint8(255),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(255),
	588:  uint8(255),
	589:  uint8(255),
	590:  uint8(0),
	591:  uint8(0),
	592:  uint8(0),
	593:  uint8(0),
	594:  uint8(0),
	595:  uint8(0),
	596:  uint8(0),
	597:  uint8(0),
	598:  uint8(0),
	599:  uint8(0),
	600:  uint8(0),
	601:  uint8(0),
	602:  uint8(0),
	603:  uint8(0),
	604:  uint8(0),
	605:  uint8(0),
	606:  uint8(0),
	607:  uint8(0),
	608:  uint8(0),
	609:  uint8(0),
	610:  uint8(0),
	611:  uint8(0),
	612:  uint8(0),
	613:  uint8(0),
	614:  uint8(0),
	615:  uint8(0),
	616:  uint8(0),
	617:  uint8(0),
	618:  uint8(0),
	619:  uint8(0),
	620:  uint8(0),
	621:  uint8(0),
	622:  uint8(0),
	623:  uint8(0),
	624:  uint8(248),
	625:  uint8(3),
	626:  uint8(0),
	627:  uint8(0),
	628:  uint8(0),
	629:  uint8(0),
	630:  uint8(0),
	631:  uint8(0),
	632:  uint8(0),
	633:  uint8(0),
	634:  uint8(0),
	635:  uint8(0),
	636:  uint8(0),
	637:  uint8(0),
	638:  uint8(0),
	639:  uint8(0),
	640:  uint8(0),
	641:  uint8(0),
	642:  uint8(0),
	643:  uint8(0),
	644:  uint8(0),
	645:  uint8(0),
	646:  uint8(0),
	647:  uint8(0),
	648:  uint8(0),
	649:  uint8(0),
	650:  uint8(0),
	651:  uint8(0),
	652:  uint8(0),
	653:  uint8(0),
	654:  uint8(0),
	655:  uint8(0),
	656:  uint8(0),
	657:  uint8(0),
	658:  uint8(254),
	659:  uint8(255),
	660:  uint8(255),
	661:  uint8(255),
	662:  uint8(255),
	663:  uint8(191),
	664:  uint8(182),
	665:  uint8(0),
	666:  uint8(0),
	667:  uint8(0),
	668:  uint8(0),
	669:  uint8(0),
	670:  uint8(0),
	671:  uint8(0),
	672:  uint8(63),
	673:  uint8(0),
	674:  uint8(255),
	675:  uint8(23),
	676:  uint8(0),
	677:  uint8(0),
	678:  uint8(0),
	679:  uint8(0),
	680:  uint8(0),
	681:  uint8(248),
	682:  uint8(255),
	683:  uint8(255),
	684:  uint8(0),
	685:  uint8(0),
	686:  uint8(1),
	687:  uint8(0),
	688:  uint8(0),
	689:  uint8(0),
	690:  uint8(0),
	691:  uint8(0),
	692:  uint8(0),
	693:  uint8(0),
	694:  uint8(0),
	695:  uint8(0),
	696:  uint8(0),
	697:  uint8(0),
	698:  uint8(192),
	699:  uint8(191),
	700:  uint8(159),
	701:  uint8(61),
	702:  uint8(0),
	703:  uint8(0),
	704:  uint8(0),
	705:  uint8(128),
	706:  uint8(2),
	707:  uint8(0),
	708:  uint8(0),
	709:  uint8(0),
	710:  uint8(255),
	711:  uint8(255),
	712:  uint8(255),
	713:  uint8(7),
	714:  uint8(0),
	715:  uint8(0),
	716:  uint8(0),
	717:  uint8(0),
	718:  uint8(0),
	719:  uint8(0),
	720:  uint8(0),
	721:  uint8(0),
	722:  uint8(0),
	723:  uint8(0),
	724:  uint8(192),
	725:  uint8(255),
	726:  uint8(1),
	727:  uint8(0),
	728:  uint8(0),
	729:  uint8(0),
	730:  uint8(0),
	731:  uint8(0),
	732:  uint8(0),
	733:  uint8(248),
	734:  uint8(15),
	735:  uint8(32),
	736:  uint8(0),
	737:  uint8(0),
	738:  uint8(192),
	739:  uint8(251),
	740:  uint8(239),
	741:  uint8(62),
	742:  uint8(0),
	743:  uint8(0),
	744:  uint8(0),
	745:  uint8(0),
	746:  uint8(0),
	747:  uint8(14),
	748:  uint8(0),
	749:  uint8(0),
	750:  uint8(0),
	751:  uint8(0),
	752:  uint8(0),
	753:  uint8(0),
	754:  uint8(0),
	755:  uint8(0),
	756:  uint8(0),
	757:  uint8(0),
	758:  uint8(0),
	759:  uint8(0),
	760:  uint8(0),
	761:  uint8(0),
	762:  uint8(248),
	763:  uint8(255),
	764:  uint8(255),
	765:  uint8(255),
	766:  uint8(255),
	767:  uint8(255),
	768:  uint8(7),
	769:  uint8(0),
	770:  uint8(0),
	771:  uint8(0),
	772:  uint8(0),
	773:  uint8(0),
	774:  uint8(0),
	775:  uint8(20),
	776:  uint8(254),
	777:  uint8(33),
	778:  uint8(254),
	779:  uint8(0),
	780:  uint8(12),
	781:  uint8(0),
	782:  uint8(0),
	783:  uint8(0),
	784:  uint8(2),
	785:  uint8(0),
	786:  uint8(0),
	787:  uint8(0),
	788:  uint8(0),
	789:  uint8(0),
	790:  uint8(0),
	791:  uint8(16),
	792:  uint8(30),
	793:  uint8(32),
	794:  uint8(0),
	795:  uint8(0),
	796:  uint8(12),
	797:  uint8(0),
	798:  uint8(0),
	799:  uint8(64),
	800:  uint8(6),
	801:  uint8(0),
	802:  uint8(0),
	803:  uint8(0),
	804:  uint8(0),
	805:  uint8(0),
	806:  uint8(0),
	807:  uint8(16),
	808:  uint8(134),
	809:  uint8(57),
	810:  uint8(2),
	811:  uint8(0),
	812:  uint8(0),
	813:  uint8(0),
	814:  uint8(35),
	815:  uint8(0),
	816:  uint8(6),
	817:  uint8(0),
	818:  uint8(0),
	819:  uint8(0),
	820:  uint8(0),
	821:  uint8(0),
	822:  uint8(0),
	823:  uint8(16),
	824:  uint8(190),
	825:  uint8(33),
	826:  uint8(0),
	827:  uint8(0),
	828:  uint8(12),
	829:  uint8(0),
	830:  uint8(0),
	831:  uint8(252),
	832:  uint8(2),
	833:  uint8(0),
	834:  uint8(0),
	835:  uint8(0),
	836:  uint8(0),
	837:  uint8(0),
	838:  uint8(0),
	839:  uint8(144),
	840:  uint8(30),
	841:  uint8(32),
	842:  uint8(64),
	843:  uint8(0),
	844:  uint8(12),
	845:  uint8(0),
	846:  uint8(0),
	847:  uint8(0),
	848:  uint8(4),
	849:  uint8(0),
	850:  uint8(0),
	851:  uint8(0),
	852:  uint8(0),
	853:  uint8(0),
	854:  uint8(0),
	855:  uint8(0),
	856:  uint8(1),
	857:  uint8(32),
	858:  uint8(0),
	859:  uint8(0),
	860:  uint8(0),
	861:  uint8(0),
	862:  uint8(0),
	863:  uint8(0),
	864:  uint8(17),
	865:  uint8(0),
	866:  uint8(0),
	867:  uint8(0),
	868:  uint8(0),
	869:  uint8(0),
	870:  uint8(0),
	871:  uint8(192),
	872:  uint8(193),
	873:  uint8(61),
	874:  uint8(96),
	875:  uint8(0),
	876:  uint8(12),
	877:  uint8(0),
	878:  uint8(0),
	879:  uint8(0),
	880:  uint8(2),
	881:  uint8(0),
	882:  uint8(0),
	883:  uint8(0),
	884:  uint8(0),
	885:  uint8(0),
	886:  uint8(0),
	887:  uint8(144),
	888:  uint8(64),
	889:  uint8(48),
	890:  uint8(0),
	891:  uint8(0),
	892:  uint8(12),
	893:  uint8(0),
	894:  uint8(0),
	895:  uint8(0),
	896:  uint8(3),
	897:  uint8(0),
	898:  uint8(0),
	899:  uint8(0),
	900:  uint8(0),
	901:  uint8(0),
	902:  uint8(0),
	903:  uint8(24),
	904:  uint8(30),
	905:  uint8(32),
	906:  uint8(0),
	907:  uint8(0),
	908:  uint8(12),
	909:  uint8(0),
	910:  uint8(0),
	911:  uint8(0),
	912:  uint8(0),
	913:  uint8(0),
	914:  uint8(0),
	915:  uint8(0),
	916:  uint8(0),
	917:  uint8(0),
	918:  uint8(0),
	919:  uint8(0),
	920:  uint8(0),
	921:  uint8(4),
	922:  uint8(92),
	923:  uint8(0),
	924:  uint8(0),
	925:  uint8(0),
	926:  uint8(0),
	927:  uint8(0),
	928:  uint8(0),
	929:  uint8(0),
	930:  uint8(0),
	931:  uint8(0),
	932:  uint8(0),
	933:  uint8(0),
	934:  uint8(242),
	935:  uint8(7),
	936:  uint8(128),
	937:  uint8(127),
	938:  uint8(0),
	939:  uint8(0),
	940:  uint8(0),
	941:  uint8(0),
	942:  uint8(0),
	943:  uint8(0),
	944:  uint8(0),
	945:  uint8(0),
	946:  uint8(0),
	947:  uint8(0),
	948:  uint8(0),
	949:  uint8(0),
	950:  uint8(242),
	951:  uint8(31),
	952:  uint8(0),
	953:  uint8(63),
	954:  uint8(0),
	955:  uint8(0),
	956:  uint8(0),
	957:  uint8(0),
	958:  uint8(0),
	959:  uint8(0),
	960:  uint8(0),
	961:  uint8(0),
	962:  uint8(0),
	963:  uint8(3),
	964:  uint8(0),
	965:  uint8(0),
	966:  uint8(160),
	967:  uint8(2),
	968:  uint8(0),
	969:  uint8(0),
	970:  uint8(0),
	971:  uint8(0),
	972:  uint8(0),
	973:  uint8(0),
	974:  uint8(254),
	975:  uint8(127),
	976:  uint8(223),
	977:  uint8(224),
	978:  uint8(255),
	979:  uint8(254),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(255),
	983:  uint8(31),
	984:  uint8(64),
	985:  uint8(0),
	986:  uint8(0),
	987:  uint8(0),
	988:  uint8(0),
	989:  uint8(0),
	990:  uint8(0),
	991:  uint8(0),
	992:  uint8(0),
	993:  uint8(0),
	994:  uint8(0),
	995:  uint8(0),
	996:  uint8(0),
	997:  uint8(224),
	998:  uint8(253),
	999:  uint8(102),
	1000: uint8(0),
	1001: uint8(0),
	1002: uint8(0),
	1003: uint8(195),
	1004: uint8(1),
	1005: uint8(0),
	1006: uint8(30),
	1007: uint8(0),
	1008: uint8(100),
	1009: uint8(32),
	1010: uint8(0),
	1011: uint8(32),
	1012: uint8(0),
	1013: uint8(0),
	1014: uint8(0),
	1015: uint8(0),
	1016: uint8(0),
	1017: uint8(0),
	1018: uint8(0),
	1019: uint8(0),
	1020: uint8(0),
	1021: uint8(0),
	1022: uint8(0),
	1023: uint8(0),
	1024: uint8(0),
	1025: uint8(0),
	1026: uint8(0),
	1027: uint8(0),
	1028: uint8(0),
	1029: uint8(0),
	1030: uint8(0),
	1031: uint8(0),
	1032: uint8(0),
	1033: uint8(0),
	1034: uint8(0),
	1035: uint8(0),
	1036: uint8(255),
	1037: uint8(255),
	1038: uint8(255),
	1039: uint8(255),
	1040: uint8(255),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(255),
	1044: uint8(255),
	1045: uint8(255),
	1046: uint8(255),
	1047: uint8(255),
	1048: uint8(255),
	1049: uint8(255),
	1050: uint8(255),
	1051: uint8(255),
	1052: uint8(255),
	1053: uint8(255),
	1054: uint8(255),
	1055: uint8(255),
	1056: uint8(0),
	1057: uint8(0),
	1058: uint8(0),
	1059: uint8(0),
	1060: uint8(0),
	1061: uint8(0),
	1062: uint8(0),
	1063: uint8(0),
	1064: uint8(0),
	1065: uint8(0),
	1066: uint8(0),
	1067: uint8(224),
	1068: uint8(0),
	1069: uint8(0),
	1070: uint8(0),
	1071: uint8(0),
	1072: uint8(0),
	1073: uint8(0),
	1074: uint8(0),
	1075: uint8(0),
	1076: uint8(0),
	1077: uint8(0),
	1078: uint8(0),
	1079: uint8(0),
	1080: uint8(0),
	1081: uint8(0),
	1082: uint8(0),
	1083: uint8(0),
	1084: uint8(0),
	1085: uint8(0),
	1086: uint8(0),
	1087: uint8(0),
	1088: uint8(0),
	1089: uint8(0),
	1090: uint8(28),
	1091: uint8(0),
	1092: uint8(0),
	1093: uint8(0),
	1094: uint8(28),
	1095: uint8(0),
	1096: uint8(0),
	1097: uint8(0),
	1098: uint8(12),
	1099: uint8(0),
	1100: uint8(0),
	1101: uint8(0),
	1102: uint8(12),
	1103: uint8(0),
	1104: uint8(0),
	1105: uint8(0),
	1106: uint8(0),
	1107: uint8(0),
	1108: uint8(0),
	1109: uint8(0),
	1110: uint8(176),
	1111: uint8(63),
	1112: uint8(64),
	1113: uint8(254),
	1114: uint8(15),
	1115: uint8(32),
	1116: uint8(0),
	1117: uint8(0),
	1118: uint8(0),
	1119: uint8(0),
	1120: uint8(0),
	1121: uint8(120),
	1122: uint8(0),
	1123: uint8(0),
	1124: uint8(0),
	1125: uint8(0),
	1126: uint8(0),
	1127: uint8(0),
	1128: uint8(0),
	1129: uint8(0),
	1130: uint8(0),
	1131: uint8(0),
	1132: uint8(0),
	1133: uint8(0),
	1134: uint8(0),
	1135: uint8(0),
	1136: uint8(96),
	1137: uint8(0),
	1138: uint8(0),
	1139: uint8(0),
	1140: uint8(0),
	1141: uint8(2),
	1142: uint8(0),
	1143: uint8(0),
	1144: uint8(0),
	1145: uint8(0),
	1146: uint8(0),
	1147: uint8(0),
	1148: uint8(0),
	1149: uint8(0),
	1150: uint8(0),
	1151: uint8(0),
	1152: uint8(0),
	1153: uint8(0),
	1154: uint8(0),
	1155: uint8(0),
	1156: uint8(135),
	1157: uint8(1),
	1158: uint8(4),
	1159: uint8(14),
	1160: uint8(0),
	1161: uint8(0),
	1162: uint8(0),
	1163: uint8(0),
	1164: uint8(0),
	1165: uint8(0),
	1166: uint8(0),
	1167: uint8(0),
	1168: uint8(0),
	1169: uint8(0),
	1170: uint8(0),
	1171: uint8(0),
	1172: uint8(0),
	1173: uint8(0),
	1174: uint8(0),
	1175: uint8(0),
	1176: uint8(0),
	1177: uint8(0),
	1178: uint8(0),
	1179: uint8(0),
	1180: uint8(0),
	1181: uint8(0),
	1182: uint8(0),
	1183: uint8(0),
	1184: uint8(0),
	1185: uint8(0),
	1186: uint8(128),
	1187: uint8(9),
	1188: uint8(0),
	1189: uint8(0),
	1190: uint8(0),
	1191: uint8(0),
	1192: uint8(0),
	1193: uint8(0),
	1194: uint8(64),
	1195: uint8(127),
	1196: uint8(229),
	1197: uint8(31),
	1198: uint8(248),
	1199: uint8(159),
	1200: uint8(0),
	1201: uint8(0),
	1202: uint8(0),
	1203: uint8(0),
	1204: uint8(0),
	1205: uint8(0),
	1206: uint8(255),
	1207: uint8(127),
	1208: uint8(0),
	1209: uint8(0),
	1210: uint8(0),
	1211: uint8(0),
	1212: uint8(0),
	1213: uint8(0),
	1214: uint8(0),
	1215: uint8(0),
	1216: uint8(15),
	1217: uint8(0),
	1218: uint8(0),
	1219: uint8(0),
	1220: uint8(0),
	1221: uint8(0),
	1222: uint8(208),
	1223: uint8(23),
	1224: uint8(4),
	1225: uint8(0),
	1226: uint8(0),
	1227: uint8(0),
	1228: uint8(0),
	1229: uint8(248),
	1230: uint8(15),
	1231: uint8(0),
	1232: uint8(3),
	1233: uint8(0),
	1234: uint8(0),
	1235: uint8(0),
	1236: uint8(60),
	1237: uint8(59),
	1238: uint8(0),
	1239: uint8(0),
	1240: uint8(0),
	1241: uint8(0),
	1242: uint8(0),
	1243: uint8(0),
	1244: uint8(64),
	1245: uint8(163),
	1246: uint8(3),
	1247: uint8(0),
	1248: uint8(0),
	1249: uint8(0),
	1250: uint8(0),
	1251: uint8(0),
	1252: uint8(0),
	1253: uint8(240),
	1254: uint8(207),
	1255: uint8(0),
	1256: uint8(0),
	1257: uint8(0),
	1258: uint8(0),
	1259: uint8(0),
	1260: uint8(0),
	1261: uint8(0),
	1262: uint8(0),
	1263: uint8(0),
	1264: uint8(0),
	1265: uint8(0),
	1266: uint8(0),
	1267: uint8(0),
	1268: uint8(0),
	1269: uint8(0),
	1270: uint8(0),
	1271: uint8(0),
	1272: uint8(0),
	1273: uint8(0),
	1274: uint8(247),
	1275: uint8(255),
	1276: uint8(253),
	1277: uint8(33),
	1278: uint8(16),
	1279: uint8(3),
	1280: uint8(0),
	1281: uint8(0),
	1282: uint8(0),
	1283: uint8(0),
	1284: uint8(0),
	1285: uint8(0),
	1286: uint8(0),
	1287: uint8(0),
	1288: uint8(0),
	1289: uint8(0),
	1290: uint8(0),
	1291: uint8(0),
	1292: uint8(0),
	1293: uint8(0),
	1294: uint8(0),
	1295: uint8(0),
	1296: uint8(0),
	1297: uint8(0),
	1298: uint8(0),
	1299: uint8(0),
	1300: uint8(0),
	1301: uint8(0),
	1302: uint8(0),
	1303: uint8(0),
	1304: uint8(255),
	1305: uint8(255),
	1306: uint8(255),
	1307: uint8(255),
	1308: uint8(255),
	1309: uint8(255),
	1310: uint8(255),
	1311: uint8(251),
	1312: uint8(0),
	1313: uint8(248),
	1314: uint8(0),
	1315: uint8(0),
	1316: uint8(0),
	1317: uint8(124),
	1318: uint8(0),
	1319: uint8(0),
	1320: uint8(0),
	1321: uint8(0),
	1322: uint8(0),
	1323: uint8(0),
	1324: uint8(223),
	1325: uint8(255),
	1326: uint8(0),
	1327: uint8(0),
	1328: uint8(0),
	1329: uint8(0),
	1330: uint8(0),
	1331: uint8(0),
	1332: uint8(0),
	1333: uint8(0),
	1334: uint8(0),
	1335: uint8(0),
	1336: uint8(0),
	1337: uint8(0),
	1338: uint8(255),
	1339: uint8(255),
	1340: uint8(255),
	1341: uint8(255),
	1342: uint8(1),
	1343: uint8(0),
	1344: uint8(0),
	1345: uint8(0),
	1346: uint8(0),
	1347: uint8(0),
	1348: uint8(0),
	1349: uint8(0),
	1350: uint8(0),
	1351: uint8(0),
	1352: uint8(0),
	1353: uint8(0),
	1354: uint8(0),
	1355: uint8(0),
	1356: uint8(0),
	1357: uint8(0),
	1358: uint8(0),
	1359: uint8(0),
	1360: uint8(0),
	1361: uint8(0),
	1362: uint8(0),
	1363: uint8(0),
	1364: uint8(0),
	1365: uint8(0),
	1366: uint8(0),
	1367: uint8(0),
	1368: uint8(0),
	1369: uint8(0),
	1370: uint8(0),
	1371: uint8(0),
	1372: uint8(0),
	1373: uint8(128),
	1374: uint8(3),
	1375: uint8(0),
	1376: uint8(0),
	1377: uint8(0),
	1378: uint8(0),
	1379: uint8(0),
	1380: uint8(0),
	1381: uint8(0),
	1382: uint8(0),
	1383: uint8(0),
	1384: uint8(0),
	1385: uint8(0),
	1386: uint8(0),
	1387: uint8(0),
	1388: uint8(0),
	1389: uint8(0),
	1390: uint8(0),
	1391: uint8(128),
	1392: uint8(0),
	1393: uint8(0),
	1394: uint8(0),
	1395: uint8(0),
	1396: uint8(0),
	1397: uint8(0),
	1398: uint8(0),
	1399: uint8(0),
	1400: uint8(0),
	1401: uint8(0),
	1402: uint8(0),
	1403: uint8(0),
	1404: uint8(255),
	1405: uint8(255),
	1406: uint8(255),
	1407: uint8(255),
	1408: uint8(0),
	1409: uint8(0),
	1410: uint8(0),
	1411: uint8(0),
	1412: uint8(0),
	1413: uint8(60),
	1414: uint8(0),
	1415: uint8(0),
	1416: uint8(0),
	1417: uint8(0),
	1418: uint8(0),
	1419: uint8(0),
	1420: uint8(0),
	1421: uint8(0),
	1422: uint8(0),
	1423: uint8(0),
	1424: uint8(0),
	1425: uint8(0),
	1426: uint8(0),
	1427: uint8(6),
	1428: uint8(0),
	1429: uint8(0),
	1430: uint8(0),
	1431: uint8(0),
	1432: uint8(0),
	1433: uint8(0),
	1434: uint8(0),
	1435: uint8(0),
	1436: uint8(0),
	1437: uint8(0),
	1438: uint8(0),
	1439: uint8(0),
	1440: uint8(0),
	1441: uint8(0),
	1442: uint8(0),
	1443: uint8(0),
	1444: uint8(0),
	1445: uint8(0),
	1446: uint8(0),
	1447: uint8(0),
	1448: uint8(0),
	1449: uint8(0),
	1450: uint8(0),
	1451: uint8(0),
	1452: uint8(0),
	1453: uint8(128),
	1454: uint8(247),
	1455: uint8(63),
	1456: uint8(0),
	1457: uint8(0),
	1458: uint8(0),
	1459: uint8(192),
	1460: uint8(0),
	1461: uint8(0),
	1462: uint8(0),
	1463: uint8(0),
	1464: uint8(0),
	1465: uint8(0),
	1466: uint8(0),
	1467: uint8(0),
	1468: uint8(0),
	1469: uint8(0),
	1470: uint8(3),
	1471: uint8(0),
	1472: uint8(68),
	1473: uint8(8),
	1474: uint8(0),
	1475: uint8(0),
	1476: uint8(96),
	1477: uint8(0),
	1478: uint8(0),
	1479: uint8(0),
	1480: uint8(0),
	1481: uint8(0),
	1482: uint8(0),
	1483: uint8(0),
	1484: uint8(0),
	1485: uint8(0),
	1486: uint8(0),
	1487: uint8(0),
	1488: uint8(0),
	1489: uint8(0),
	1490: uint8(0),
	1491: uint8(0),
	1492: uint8(0),
	1493: uint8(0),
	1494: uint8(0),
	1495: uint8(0),
	1496: uint8(48),
	1497: uint8(0),
	1498: uint8(0),
	1499: uint8(0),
	1500: uint8(255),
	1501: uint8(255),
	1502: uint8(3),
	1503: uint8(128),
	1504: uint8(0),
	1505: uint8(0),
	1506: uint8(0),
	1507: uint8(0),
	1508: uint8(192),
	1509: uint8(63),
	1510: uint8(0),
	1511: uint8(0),
	1512: uint8(128),
	1513: uint8(255),
	1514: uint8(3),
	1515: uint8(0),
	1516: uint8(0),
	1517: uint8(0),
	1518: uint8(0),
	1519: uint8(0),
	1520: uint8(7),
	1521: uint8(0),
	1522: uint8(0),
	1523: uint8(0),
	1524: uint8(0),
	1525: uint8(0),
	1526: uint8(200),
	1527: uint8(51),
	1528: uint8(0),
	1529: uint8(0),
	1530: uint8(0),
	1531: uint8(0),
	1532: uint8(32),
	1533: uint8(0),
	1534: uint8(0),
	1535: uint8(0),
	1536: uint8(0),
	1537: uint8(0),
	1538: uint8(0),
	1539: uint8(0),
	1540: uint8(0),
	1541: uint8(126),
	1542: uint8(102),
	1543: uint8(0),
	1544: uint8(8),
	1545: uint8(16),
	1546: uint8(0),
	1547: uint8(0),
	1548: uint8(0),
	1549: uint8(0),
	1550: uint8(0),
	1551: uint8(16),
	1552: uint8(0),
	1553: uint8(0),
	1554: uint8(0),
	1555: uint8(0),
	1556: uint8(0),
	1557: uint8(0),
	1558: uint8(157),
	1559: uint8(193),
	1560: uint8(2),
	1561: uint8(0),
	1562: uint8(0),
	1563: uint8(0),
	1564: uint8(0),
	1565: uint8(48),
	1566: uint8(64),
	1567: uint8(0),
	1568: uint8(0),
	1569: uint8(0),
	1570: uint8(0),
	1571: uint8(0),
	1572: uint8(0),
	1573: uint8(0),
	1574: uint8(0),
	1575: uint8(0),
	1576: uint8(0),
	1577: uint8(0),
	1578: uint8(0),
	1579: uint8(0),
	1580: uint8(0),
	1581: uint8(0),
	1582: uint8(0),
	1583: uint8(0),
	1584: uint8(0),
	1585: uint8(0),
	1586: uint8(0),
	1587: uint8(0),
	1588: uint8(0),
	1589: uint8(0),
	1590: uint8(0),
	1591: uint8(0),
	1592: uint8(0),
	1593: uint8(0),
	1594: uint8(0),
	1595: uint8(0),
	1596: uint8(32),
	1597: uint8(33),
	1598: uint8(0),
	1599: uint8(0),
	1600: uint8(0),
	1601: uint8(0),
	1602: uint8(0),
	1603: uint8(0),
	1604: uint8(0),
	1605: uint8(0),
	1606: uint8(0),
	1607: uint8(0),
	1608: uint8(0),
	1609: uint8(0),
	1610: uint8(0),
	1611: uint8(0),
	1612: uint8(0),
	1613: uint8(0),
	1614: uint8(0),
	1615: uint8(0),
	1616: uint8(0),
	1617: uint8(0),
	1618: uint8(0),
	1619: uint8(0),
	1620: uint8(0),
	1621: uint8(0),
	1622: uint8(255),
	1623: uint8(255),
	1624: uint8(255),
	1625: uint8(255),
	1626: uint8(255),
	1627: uint8(255),
	1628: uint8(255),
	1629: uint8(255),
	1630: uint8(255),
	1631: uint8(255),
	1632: uint8(0),
	1633: uint8(0),
	1634: uint8(0),
	1635: uint8(64),
	1636: uint8(0),
	1637: uint8(0),
	1638: uint8(0),
	1639: uint8(0),
	1640: uint8(0),
	1641: uint8(0),
	1642: uint8(0),
	1643: uint8(0),
	1644: uint8(0),
	1645: uint8(0),
	1646: uint8(0),
	1647: uint8(0),
	1648: uint8(0),
	1649: uint8(0),
	1650: uint8(0),
	1651: uint8(0),
	1652: uint8(0),
	1653: uint8(0),
	1654: uint8(0),
	1655: uint8(0),
	1656: uint8(0),
	1657: uint8(0),
	1658: uint8(0),
	1659: uint8(0),
	1660: uint8(0),
	1661: uint8(0),
	1662: uint8(0),
	1663: uint8(0),
	1664: uint8(255),
	1665: uint8(255),
	1666: uint8(0),
	1667: uint8(0),
	1668: uint8(255),
	1669: uint8(255),
	1670: uint8(0),
	1671: uint8(0),
	1672: uint8(0),
	1673: uint8(0),
	1674: uint8(0),
	1675: uint8(0),
	1676: uint8(0),
	1677: uint8(0),
	1678: uint8(0),
	1679: uint8(0),
	1680: uint8(0),
	1681: uint8(0),
	1682: uint8(0),
	1683: uint8(0),
	1684: uint8(0),
	1685: uint8(0),
	1686: uint8(0),
	1687: uint8(0),
	1688: uint8(0),
	1689: uint8(0),
	1690: uint8(0),
	1691: uint8(0),
	1692: uint8(0),
	1693: uint8(0),
	1694: uint8(0),
	1695: uint8(128),
	1696: uint8(0),
	1697: uint8(0),
	1698: uint8(0),
	1699: uint8(0),
	1700: uint8(0),
	1701: uint8(0),
	1702: uint8(0),
	1703: uint8(0),
	1704: uint8(0),
	1705: uint8(0),
	1706: uint8(0),
	1707: uint8(0),
	1708: uint8(0),
	1709: uint8(0),
	1710: uint8(0),
	1711: uint8(0),
	1712: uint8(0),
	1713: uint8(0),
	1714: uint8(0),
	1715: uint8(0),
	1716: uint8(0),
	1717: uint8(0),
	1718: uint8(0),
	1719: uint8(0),
	1720: uint8(0),
	1721: uint8(0),
	1722: uint8(0),
	1723: uint8(0),
	1724: uint8(0),
	1725: uint8(0),
	1726: uint8(0),
	1727: uint8(14),
	1728: uint8(0),
	1729: uint8(0),
	1730: uint8(0),
	1731: uint8(0),
	1732: uint8(0),
	1733: uint8(0),
	1734: uint8(0),
	1735: uint8(0),
	1736: uint8(0),
	1737: uint8(0),
	1738: uint8(0),
	1739: uint8(0),
	1740: uint8(0),
	1741: uint8(0),
	1742: uint8(0),
	1743: uint8(0),
	1744: uint8(0),
	1745: uint8(0),
	1746: uint8(0),
	1747: uint8(0),
	1748: uint8(0),
	1749: uint8(0),
	1750: uint8(0),
	1751: uint8(0),
	1752: uint8(0),
	1753: uint8(0),
	1754: uint8(0),
	1755: uint8(0),
	1756: uint8(0),
	1757: uint8(0),
	1758: uint8(0),
	1759: uint8(32),
	1760: uint8(0),
	1761: uint8(0),
	1762: uint8(0),
	1763: uint8(0),
	1764: uint8(0),
	1765: uint8(0),
	1766: uint8(0),
	1767: uint8(0),
	1768: uint8(0),
	1769: uint8(0),
	1770: uint8(0),
	1771: uint8(0),
	1772: uint8(0),
	1773: uint8(0),
	1774: uint8(0),
	1775: uint8(0),
	1776: uint8(0),
	1777: uint8(0),
	1778: uint8(0),
	1779: uint8(0),
	1780: uint8(0),
	1781: uint8(0),
	1782: uint8(0),
	1783: uint8(0),
	1784: uint8(0),
	1785: uint8(0),
	1786: uint8(0),
	1787: uint8(0),
	1788: uint8(1),
	1789: uint8(0),
	1790: uint8(0),
	1791: uint8(0),
	1792: uint8(0),
	1793: uint8(0),
	1794: uint8(0),
	1795: uint8(0),
	1796: uint8(0),
	1797: uint8(0),
	1798: uint8(0),
	1799: uint8(0),
	1800: uint8(0),
	1801: uint8(0),
	1802: uint8(0),
	1803: uint8(0),
	1804: uint8(0),
	1805: uint8(0),
	1806: uint8(192),
	1807: uint8(7),
	1808: uint8(0),
	1809: uint8(0),
	1810: uint8(0),
	1811: uint8(0),
	1812: uint8(0),
	1813: uint8(0),
	1814: uint8(0),
	1815: uint8(0),
	1816: uint8(0),
	1817: uint8(0),
	1818: uint8(0),
	1819: uint8(0),
	1820: uint8(0),
	1821: uint8(0),
	1822: uint8(0),
	1823: uint8(0),
	1824: uint8(110),
	1825: uint8(240),
	1826: uint8(0),
	1827: uint8(0),
	1828: uint8(0),
	1829: uint8(0),
	1830: uint8(0),
	1831: uint8(135),
	1832: uint8(0),
	1833: uint8(0),
	1834: uint8(0),
	1835: uint8(0),
	1836: uint8(0),
	1837: uint8(0),
	1838: uint8(0),
	1839: uint8(0),
	1840: uint8(0),
	1841: uint8(0),
	1842: uint8(0),
	1843: uint8(0),
	1844: uint8(0),
	1845: uint8(0),
	1846: uint8(0),
	1847: uint8(0),
	1848: uint8(0),
	1849: uint8(0),
	1850: uint8(0),
	1851: uint8(0),
	1852: uint8(96),
	1853: uint8(0),
	1854: uint8(0),
	1855: uint8(0),
	1856: uint8(0),
	1857: uint8(0),
	1858: uint8(0),
	1859: uint8(0),
	1860: uint8(240),
	1861: uint8(0),
	1862: uint8(0),
	1863: uint8(0),
	1864: uint8(0),
	1865: uint8(0),
	1866: uint8(0),
	1867: uint8(0),
	1868: uint8(0),
	1869: uint8(0),
	1870: uint8(0),
	1871: uint8(0),
	1872: uint8(0),
	1873: uint8(0),
	1874: uint8(0),
	1875: uint8(0),
	1876: uint8(0),
	1877: uint8(0),
	1878: uint8(0),
	1879: uint8(0),
	1880: uint8(0),
	1881: uint8(0),
	1882: uint8(0),
	1883: uint8(0),
	1884: uint8(0),
	1885: uint8(0),
	1886: uint8(0),
	1887: uint8(0),
	1888: uint8(0),
	1889: uint8(0),
	1890: uint8(0),
	1891: uint8(0),
	1892: uint8(0),
	1893: uint8(0),
	1894: uint8(0),
	1895: uint8(0),
	1896: uint8(192),
	1897: uint8(255),
	1898: uint8(1),
	1899: uint8(0),
	1900: uint8(0),
	1901: uint8(0),
	1902: uint8(0),
	1903: uint8(0),
	1904: uint8(0),
	1905: uint8(0),
	1906: uint8(0),
	1907: uint8(0),
	1908: uint8(0),
	1909: uint8(0),
	1910: uint8(0),
	1911: uint8(0),
	1912: uint8(0),
	1913: uint8(0),
	1914: uint8(0),
	1915: uint8(0),
	1916: uint8(0),
	1917: uint8(0),
	1918: uint8(0),
	1919: uint8(0),
	1920: uint8(2),
	1921: uint8(0),
	1922: uint8(0),
	1923: uint8(0),
	1924: uint8(0),
	1925: uint8(0),
	1926: uint8(0),
	1927: uint8(255),
	1928: uint8(127),
	1929: uint8(0),
	1930: uint8(0),
	1931: uint8(0),
	1932: uint8(0),
	1933: uint8(0),
	1934: uint8(0),
	1935: uint8(128),
	1936: uint8(3),
	1937: uint8(0),
	1938: uint8(0),
	1939: uint8(0),
	1940: uint8(0),
	1941: uint8(0),
	1942: uint8(120),
	1943: uint8(38),
	1944: uint8(0),
	1945: uint8(32),
	1946: uint8(0),
	1947: uint8(0),
	1948: uint8(0),
	1949: uint8(0),
	1950: uint8(0),
	1951: uint8(0),
	1952: uint8(7),
	1953: uint8(0),
	1954: uint8(0),
	1955: uint8(0),
	1956: uint8(128),
	1957: uint8(239),
	1958: uint8(31),
	1959: uint8(0),
	1960: uint8(0),
	1961: uint8(0),
	1962: uint8(0),
	1963: uint8(0),
	1964: uint8(0),
	1965: uint8(0),
	1966: uint8(8),
	1967: uint8(0),
	1968: uint8(3),
	1969: uint8(0),
	1970: uint8(0),
	1971: uint8(0),
	1972: uint8(0),
	1973: uint8(0),
	1974: uint8(192),
	1975: uint8(127),
	1976: uint8(0),
	1977: uint8(30),
	1978: uint8(0),
	1979: uint8(0),
	1980: uint8(0),
	1981: uint8(0),
	1982: uint8(0),
	1983: uint8(0),
	1984: uint8(0),
	1985: uint8(0),
	1986: uint8(0),
	1987: uint8(0),
	1988: uint8(0),
	1989: uint8(128),
	1990: uint8(211),
	1991: uint8(64),
	1992: uint8(0),
	1993: uint8(0),
	1994: uint8(0),
	1995: uint8(0),
	1996: uint8(0),
	1997: uint8(0),
	1998: uint8(0),
	1999: uint8(0),
	2000: uint8(0),
	2001: uint8(0),
	2002: uint8(0),
	2003: uint8(0),
	2004: uint8(0),
	2005: uint8(0),
	2006: uint8(0),
	2007: uint8(0),
	2008: uint8(0),
	2009: uint8(0),
	2010: uint8(0),
	2011: uint8(128),
	2012: uint8(248),
	2013: uint8(7),
	2014: uint8(0),
	2015: uint8(0),
	2016: uint8(3),
	2017: uint8(0),
	2018: uint8(0),
	2019: uint8(0),
	2020: uint8(0),
	2021: uint8(0),
	2022: uint8(0),
	2023: uint8(24),
	2024: uint8(1),
	2025: uint8(0),
	2026: uint8(0),
	2027: uint8(0),
	2028: uint8(192),
	2029: uint8(31),
	2030: uint8(31),
	2031: uint8(0),
	2032: uint8(0),
	2033: uint8(0),
	2034: uint8(0),
	2035: uint8(0),
	2036: uint8(0),
	2037: uint8(0),
	2038: uint8(0),
	2039: uint8(0),
	2040: uint8(0),
	2041: uint8(0),
	2042: uint8(0),
	2043: uint8(0),
	2044: uint8(0),
	2045: uint8(0),
	2046: uint8(0),
	2047: uint8(0),
	2048: uint8(0),
	2049: uint8(0),
	2050: uint8(0),
	2051: uint8(0),
	2052: uint8(0),
	2053: uint8(0),
	2054: uint8(0),
	2055: uint8(255),
	2056: uint8(92),
	2057: uint8(0),
	2058: uint8(0),
	2059: uint8(64),
	2060: uint8(0),
	2061: uint8(0),
	2062: uint8(0),
	2063: uint8(0),
	2064: uint8(0),
	2065: uint8(0),
	2066: uint8(0),
	2067: uint8(0),
	2068: uint8(0),
	2069: uint8(0),
	2070: uint8(248),
	2071: uint8(133),
	2072: uint8(13),
	2073: uint8(0),
	2074: uint8(0),
	2075: uint8(0),
	2076: uint8(0),
	2077: uint8(0),
	2078: uint8(0),
	2079: uint8(0),
	2080: uint8(0),
	2081: uint8(0),
	2082: uint8(0),
	2083: uint8(0),
	2084: uint8(0),
	2085: uint8(0),
	2086: uint8(0),
	2087: uint8(0),
	2088: uint8(0),
	2089: uint8(0),
	2090: uint8(0),
	2091: uint8(0),
	2092: uint8(0),
	2093: uint8(0),
	2094: uint8(0),
	2095: uint8(0),
	2096: uint8(0),
	2097: uint8(0),
	2098: uint8(0),
	2099: uint8(0),
	2100: uint8(0),
	2101: uint8(0),
	2102: uint8(60),
	2103: uint8(176),
	2104: uint8(1),
	2105: uint8(0),
	2106: uint8(0),
	2107: uint8(48),
	2108: uint8(0),
	2109: uint8(0),
	2110: uint8(0),
	2111: uint8(0),
	2112: uint8(0),
	2113: uint8(0),
	2114: uint8(0),
	2115: uint8(0),
	2116: uint8(0),
	2117: uint8(0),
	2118: uint8(248),
	2119: uint8(167),
	2120: uint8(1),
	2121: uint8(0),
	2122: uint8(0),
	2123: uint8(0),
	2124: uint8(0),
	2125: uint8(0),
	2126: uint8(0),
	2127: uint8(0),
	2128: uint8(0),
	2129: uint8(0),
	2130: uint8(0),
	2131: uint8(0),
	2132: uint8(0),
	2133: uint8(40),
	2134: uint8(191),
	2135: uint8(0),
	2136: uint8(0),
	2137: uint8(0),
	2138: uint8(0),
	2139: uint8(0),
	2140: uint8(0),
	2141: uint8(0),
	2142: uint8(0),
	2143: uint8(0),
	2144: uint8(0),
	2145: uint8(0),
	2146: uint8(0),
	2147: uint8(224),
	2148: uint8(188),
	2149: uint8(15),
	2150: uint8(0),
	2151: uint8(0),
	2152: uint8(0),
	2153: uint8(0),
	2154: uint8(0),
	2155: uint8(0),
	2156: uint8(0),
	2157: uint8(0),
	2158: uint8(0),
	2159: uint8(0),
	2160: uint8(0),
	2161: uint8(0),
	2162: uint8(0),
	2163: uint8(0),
	2164: uint8(0),
	2165: uint8(0),
	2166: uint8(0),
	2167: uint8(0),
	2168: uint8(0),
	2169: uint8(0),
	2170: uint8(0),
	2171: uint8(0),
	2172: uint8(0),
	2173: uint8(0),
	2174: uint8(0),
	2175: uint8(0),
	2176: uint8(0),
	2177: uint8(0),
	2178: uint8(0),
	2179: uint8(0),
	2180: uint8(0),
	2181: uint8(128),
	2182: uint8(255),
	2183: uint8(6),
	2184: uint8(0),
	2185: uint8(0),
	2186: uint8(0),
	2187: uint8(0),
	2188: uint8(0),
	2189: uint8(0),
	2190: uint8(0),
	2191: uint8(0),
	2192: uint8(0),
	2193: uint8(0),
	2194: uint8(0),
	2195: uint8(0),
	2196: uint8(0),
	2197: uint8(0),
	2198: uint8(0),
	2199: uint8(0),
	2200: uint8(0),
	2201: uint8(0),
	2202: uint8(0),
	2203: uint8(0),
	2204: uint8(0),
	2205: uint8(0),
	2206: uint8(0),
	2207: uint8(0),
	2208: uint8(0),
	2209: uint8(0),
	2210: uint8(0),
	2211: uint8(0),
	2212: uint8(0),
	2213: uint8(0),
	2214: uint8(0),
	2215: uint8(0),
	2216: uint8(0),
	2217: uint8(0),
	2218: uint8(0),
	2219: uint8(0),
	2220: uint8(0),
	2221: uint8(0),
	2222: uint8(0),
	2223: uint8(0),
	2224: uint8(0),
	2225: uint8(0),
	2226: uint8(0),
	2227: uint8(0),
	2228: uint8(0),
	2229: uint8(0),
	2230: uint8(0),
	2231: uint8(0),
	2232: uint8(0),
	2233: uint8(0),
	2234: uint8(240),
	2235: uint8(12),
	2236: uint8(1),
	2237: uint8(0),
	2238: uint8(0),
	2239: uint8(0),
	2240: uint8(254),
	2241: uint8(7),
	2242: uint8(0),
	2243: uint8(0),
	2244: uint8(0),
	2245: uint8(0),
	2246: uint8(248),
	2247: uint8(121),
	2248: uint8(128),
	2249: uint8(0),
	2250: uint8(126),
	2251: uint8(14),
	2252: uint8(0),
	2253: uint8(0),
	2254: uint8(0),
	2255: uint8(0),
	2256: uint8(0),
	2257: uint8(252),
	2258: uint8(127),
	2259: uint8(3),
	2260: uint8(0),
	2261: uint8(0),
	2262: uint8(0),
	2263: uint8(0),
	2264: uint8(0),
	2265: uint8(0),
	2266: uint8(0),
	2267: uint8(0),
	2268: uint8(0),
	2269: uint8(0),
	2270: uint8(0),
	2271: uint8(0),
	2272: uint8(0),
	2273: uint8(0),
	2274: uint8(0),
	2275: uint8(0),
	2276: uint8(0),
	2277: uint8(0),
	2278: uint8(127),
	2279: uint8(191),
	2280: uint8(0),
	2281: uint8(0),
	2282: uint8(0),
	2283: uint8(0),
	2284: uint8(0),
	2285: uint8(0),
	2286: uint8(0),
	2287: uint8(0),
	2288: uint8(0),
	2289: uint8(0),
	2290: uint8(252),
	2291: uint8(255),
	2292: uint8(255),
	2293: uint8(252),
	2294: uint8(109),
	2295: uint8(0),
	2296: uint8(0),
	2297: uint8(0),
	2298: uint8(0),
	2299: uint8(0),
	2300: uint8(0),
	2301: uint8(0),
	2302: uint8(0),
	2303: uint8(0),
	2304: uint8(0),
	2305: uint8(0),
	2306: uint8(0),
	2307: uint8(0),
	2308: uint8(0),
	2309: uint8(0),
	2310: uint8(126),
	2311: uint8(180),
	2312: uint8(191),
	2313: uint8(0),
	2314: uint8(0),
	2315: uint8(0),
	2316: uint8(0),
	2317: uint8(0),
	2318: uint8(0),
	2319: uint8(0),
	2320: uint8(0),
	2321: uint8(0),
	2322: uint8(163),
	2323: uint8(0),
	2324: uint8(0),
	2325: uint8(0),
	2326: uint8(0),
	2327: uint8(0),
	2328: uint8(0),
	2329: uint8(0),
	2330: uint8(0),
	2331: uint8(0),
	2332: uint8(0),
	2333: uint8(0),
	2334: uint8(0),
	2335: uint8(0),
	2336: uint8(0),
	2337: uint8(0),
	2338: uint8(0),
	2339: uint8(0),
	2340: uint8(0),
	2341: uint8(0),
	2342: uint8(0),
	2343: uint8(0),
	2344: uint8(0),
	2345: uint8(0),
	2346: uint8(0),
	2347: uint8(0),
	2348: uint8(0),
	2349: uint8(0),
	2350: uint8(0),
	2351: uint8(0),
	2352: uint8(0),
	2353: uint8(0),
	2354: uint8(0),
	2355: uint8(0),
	2356: uint8(0),
	2357: uint8(0),
	2358: uint8(0),
	2359: uint8(0),
	2360: uint8(0),
	2361: uint8(0),
	2362: uint8(0),
	2363: uint8(0),
	2364: uint8(0),
	2365: uint8(0),
	2366: uint8(24),
	2367: uint8(0),
	2368: uint8(0),
	2369: uint8(0),
	2370: uint8(0),
	2371: uint8(0),
	2372: uint8(0),
	2373: uint8(0),
	2374: uint8(255),
	2375: uint8(1),
	2376: uint8(0),
	2377: uint8(0),
	2378: uint8(0),
	2379: uint8(0),
	2380: uint8(0),
	2381: uint8(0),
	2382: uint8(0),
	2383: uint8(0),
	2384: uint8(0),
	2385: uint8(0),
	2386: uint8(0),
	2387: uint8(0),
	2388: uint8(0),
	2389: uint8(0),
	2390: uint8(0),
	2391: uint8(0),
	2392: uint8(0),
	2393: uint8(0),
	2394: uint8(0),
	2395: uint8(0),
	2396: uint8(0),
	2397: uint8(0),
	2398: uint8(0),
	2399: uint8(0),
	2400: uint8(0),
	2401: uint8(0),
	2402: uint8(0),
	2403: uint8(0),
	2404: uint8(0),
	2405: uint8(0),
	2406: uint8(0),
	2407: uint8(0),
	2408: uint8(0),
	2409: uint8(0),
	2410: uint8(0),
	2411: uint8(0),
	2412: uint8(0),
	2413: uint8(0),
	2414: uint8(0),
	2415: uint8(0),
	2416: uint8(0),
	2417: uint8(0),
	2418: uint8(0),
	2419: uint8(0),
	2420: uint8(0),
	2421: uint8(0),
	2422: uint8(0),
	2423: uint8(0),
	2424: uint8(0),
	2425: uint8(0),
	2426: uint8(0),
	2427: uint8(0),
	2428: uint8(0),
	2429: uint8(0),
	2430: uint8(31),
	2431: uint8(0),
	2432: uint8(0),
	2433: uint8(0),
	2434: uint8(0),
	2435: uint8(0),
	2436: uint8(0),
	2437: uint8(0),
	2438: uint8(127),
	2439: uint8(0),
	2440: uint8(0),
	2441: uint8(0),
	2442: uint8(0),
	2443: uint8(0),
	2444: uint8(0),
	2445: uint8(0),
	2446: uint8(0),
	2447: uint8(0),
	2448: uint8(0),
	2449: uint8(0),
	2450: uint8(0),
	2451: uint8(0),
	2452: uint8(0),
	2453: uint8(0),
	2454: uint8(0),
	2455: uint8(0),
	2456: uint8(0),
	2457: uint8(0),
	2458: uint8(0),
	2459: uint8(0),
	2460: uint8(0),
	2461: uint8(0),
	2462: uint8(0),
	2463: uint8(0),
	2464: uint8(0),
	2465: uint8(0),
	2466: uint8(0),
	2467: uint8(0),
	2468: uint8(0),
	2469: uint8(0),
	2470: uint8(0),
	2471: uint8(0),
	2472: uint8(0),
	2473: uint8(128),
	2474: uint8(0),
	2475: uint8(0),
	2476: uint8(0),
	2477: uint8(0),
	2478: uint8(0),
	2479: uint8(0),
	2480: uint8(0),
	2481: uint8(128),
	2482: uint8(7),
	2483: uint8(0),
	2484: uint8(0),
	2485: uint8(0),
	2486: uint8(0),
	2487: uint8(0),
	2488: uint8(0),
	2489: uint8(0),
	2490: uint8(0),
	2491: uint8(0),
	2492: uint8(0),
	2493: uint8(0),
	2494: uint8(0),
	2495: uint8(0),
	2496: uint8(0),
	2497: uint8(0),
	2498: uint8(0),
	2499: uint8(0),
	2500: uint8(0),
	2501: uint8(0),
	2502: uint8(0),
	2503: uint8(0),
	2504: uint8(0),
	2505: uint8(0),
	2506: uint8(0),
	2507: uint8(0),
	2508: uint8(0),
	2509: uint8(0),
	2510: uint8(0),
	2511: uint8(0),
	2512: uint8(0),
	2513: uint8(0),
	2514: uint8(0),
	2515: uint8(96),
	2516: uint8(15),
	2517: uint8(0),
	2518: uint8(0),
	2519: uint8(0),
	2520: uint8(0),
	2521: uint8(0),
	2522: uint8(0),
	2523: uint8(0),
	2524: uint8(0),
	2525: uint8(0),
	2526: uint8(0),
	2527: uint8(0),
	2528: uint8(0),
	2529: uint8(0),
	2530: uint8(0),
	2531: uint8(0),
	2532: uint8(0),
	2533: uint8(0),
	2534: uint8(0),
	2535: uint8(0),
	2536: uint8(0),
	2537: uint8(0),
	2538: uint8(0),
	2539: uint8(0),
	2540: uint8(128),
	2541: uint8(3),
	2542: uint8(248),
	2543: uint8(255),
	2544: uint8(231),
	2545: uint8(15),
	2546: uint8(0),
	2547: uint8(0),
	2548: uint8(0),
	2549: uint8(60),
	2550: uint8(0),
	2551: uint8(0),
	2552: uint8(0),
	2553: uint8(0),
	2554: uint8(0),
	2555: uint8(0),
	2556: uint8(0),
	2557: uint8(0),
	2558: uint8(0),
	2559: uint8(0),
	2560: uint8(0),
	2561: uint8(0),
	2562: uint8(0),
	2563: uint8(0),
	2564: uint8(0),
	2565: uint8(0),
	2566: uint8(0),
	2567: uint8(0),
	2568: uint8(28),
	2569: uint8(0),
	2570: uint8(0),
	2571: uint8(0),
	2572: uint8(0),
	2573: uint8(0),
	2574: uint8(0),
	2575: uint8(0),
	2576: uint8(0),
	2577: uint8(0),
	2578: uint8(0),
	2579: uint8(0),
	2580: uint8(0),
	2581: uint8(0),
	2582: uint8(0),
	2583: uint8(0),
	2584: uint8(0),
	2585: uint8(0),
	2586: uint8(0),
	2587: uint8(0),
	2588: uint8(0),
	2589: uint8(0),
	2590: uint8(0),
	2591: uint8(0),
	2592: uint8(255),
	2593: uint8(255),
	2594: uint8(255),
	2595: uint8(255),
	2596: uint8(255),
	2597: uint8(255),
	2598: uint8(127),
	2599: uint8(248),
	2600: uint8(255),
	2601: uint8(255),
	2602: uint8(255),
	2603: uint8(255),
	2604: uint8(255),
	2605: uint8(31),
	2606: uint8(32),
	2607: uint8(0),
	2608: uint8(16),
	2609: uint8(0),
	2610: uint8(0),
	2611: uint8(248),
	2612: uint8(254),
	2613: uint8(255),
	2614: uint8(0),
	2615: uint8(0),
	2616: uint8(0),
	2617: uint8(0),
	2618: uint8(0),
	2619: uint8(0),
	2620: uint8(0),
	2621: uint8(0),
	2622: uint8(0),
	2623: uint8(0),
	2624: uint8(127),
	2625: uint8(255),
	2626: uint8(255),
	2627: uint8(249),
	2628: uint8(219),
	2629: uint8(7),
	2630: uint8(0),
	2631: uint8(0),
	2632: uint8(0),
	2633: uint8(0),
	2634: uint8(0),
	2635: uint8(0),
	2636: uint8(0),
	2637: uint8(0),
	2638: uint8(0),
	2639: uint8(0),
	2640: uint8(0),
	2641: uint8(0),
	2642: uint8(0),
	2643: uint8(0),
	2644: uint8(0),
	2645: uint8(0),
	2646: uint8(0),
	2647: uint8(0),
	2648: uint8(0),
	2649: uint8(0),
	2650: uint8(0),
	2651: uint8(0),
	2652: uint8(0),
	2653: uint8(0),
	2654: uint8(0),
	2655: uint8(0),
	2656: uint8(0),
	2657: uint8(0),
	2658: uint8(0),
	2659: uint8(0),
	2660: uint8(0),
	2661: uint8(0),
	2662: uint8(127),
	2663: uint8(0),
	2664: uint8(0),
	2665: uint8(0),
	2666: uint8(0),
	2667: uint8(0),
	2668: uint8(0),
	2669: uint8(0),
	2670: uint8(0),
	2671: uint8(0),
	2672: uint8(0),
	2673: uint8(0),
	2674: uint8(0),
	2675: uint8(0),
	2676: uint8(0),
	2677: uint8(0),
	2678: uint8(0),
	2679: uint8(0),
	2680: uint8(0),
	2681: uint8(0),
	2682: uint8(0),
	2683: uint8(0),
	2684: uint8(0),
	2685: uint8(0),
	2686: uint8(0),
	2687: uint8(0),
	2688: uint8(0),
	2689: uint8(0),
	2690: uint8(0),
	2691: uint8(0),
	2692: uint8(0),
	2693: uint8(0),
	2694: uint8(0),
	2695: uint8(0),
	2696: uint8(0),
	2697: uint8(0),
	2698: uint8(0),
	2699: uint8(0),
	2700: uint8(0),
	2701: uint8(0),
	2702: uint8(0),
	2703: uint8(0),
	2704: uint8(0),
	2705: uint8(0),
	2706: uint8(0),
	2707: uint8(0),
	2708: uint8(0),
	2709: uint8(0),
	2710: uint8(0),
	2711: uint8(0),
	2712: uint8(0),
	2713: uint8(0),
	2714: uint8(0),
	2715: uint8(0),
	2716: uint8(0),
	2717: uint8(240),
	2718: uint8(0),
	2719: uint8(0),
	2720: uint8(0),
	2721: uint8(0),
	2722: uint8(0),
	2723: uint8(0),
	2724: uint8(0),
	2725: uint8(0),
	2726: uint8(0),
	2727: uint8(0),
	2728: uint8(0),
	2729: uint8(0),
	2730: uint8(0),
	2731: uint8(0),
	2732: uint8(0),
	2733: uint8(0),
	2734: uint8(0),
	2735: uint8(0),
	2736: uint8(0),
	2737: uint8(0),
	2738: uint8(0),
	2739: uint8(0),
	2740: uint8(0),
	2741: uint8(0),
	2742: uint8(0),
	2743: uint8(0),
	2744: uint8(0),
	2745: uint8(0),
	2746: uint8(127),
	2747: uint8(0),
	2748: uint8(0),
	2749: uint8(0),
	2750: uint8(0),
	2751: uint8(0),
	2752: uint8(0),
	2753: uint8(0),
	2754: uint8(0),
	2755: uint8(0),
	2756: uint8(0),
	2757: uint8(0),
	2758: uint8(0),
	2759: uint8(0),
	2760: uint8(240),
	2761: uint8(7),
	2762: uint8(0),
	2763: uint8(0),
	2764: uint8(0),
	2765: uint8(0),
	2766: uint8(0),
	2767: uint8(0),
	2768: uint8(0),
	2769: uint8(0),
	2770: uint8(0),
	2771: uint8(0),
	2772: uint8(0),
	2773: uint8(0),
	2774: uint8(0),
	2775: uint8(0),
	2776: uint8(0),
	2777: uint8(0),
	2778: uint8(0),
	2779: uint8(0),
	2780: uint8(0),
	2781: uint8(0),
	2782: uint8(0),
	2783: uint8(0)}

var _wtable = [1600]uint8{
	0:    uint8(16),
	1:    uint8(16),
	2:    uint8(16),
	3:    uint8(16),
	4:    uint8(16),
	5:    uint8(16),
	6:    uint8(16),
	7:    uint8(16),
	8:    uint8(16),
	9:    uint8(16),
	10:   uint8(16),
	11:   uint8(16),
	12:   uint8(16),
	13:   uint8(16),
	14:   uint8(16),
	15:   uint8(16),
	16:   uint8(16),
	17:   uint8(18),
	18:   uint8(16),
	19:   uint8(16),
	20:   uint8(16),
	21:   uint8(16),
	22:   uint8(16),
	23:   uint8(16),
	24:   uint8(16),
	25:   uint8(16),
	26:   uint8(16),
	27:   uint8(16),
	28:   uint8(16),
	29:   uint8(16),
	30:   uint8(16),
	31:   uint8(16),
	32:   uint8(16),
	33:   uint8(16),
	34:   uint8(16),
	35:   uint8(19),
	36:   uint8(16),
	37:   uint8(20),
	38:   uint8(21),
	39:   uint8(22),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(23),
	44:   uint8(16),
	45:   uint8(16),
	46:   uint8(24),
	47:   uint8(25),
	48:   uint8(26),
	49:   uint8(27),
	50:   uint8(28),
	51:   uint8(17),
	52:   uint8(17),
	53:   uint8(17),
	54:   uint8(17),
	55:   uint8(17),
	56:   uint8(17),
	57:   uint8(17),
	58:   uint8(17),
	59:   uint8(17),
	60:   uint8(17),
	61:   uint8(17),
	62:   uint8(17),
	63:   uint8(17),
	64:   uint8(17),
	65:   uint8(17),
	66:   uint8(17),
	67:   uint8(17),
	68:   uint8(17),
	69:   uint8(17),
	70:   uint8(17),
	71:   uint8(17),
	72:   uint8(17),
	73:   uint8(17),
	74:   uint8(17),
	75:   uint8(17),
	76:   uint8(17),
	77:   uint8(29),
	78:   uint8(17),
	79:   uint8(17),
	80:   uint8(17),
	81:   uint8(17),
	82:   uint8(17),
	83:   uint8(17),
	84:   uint8(17),
	85:   uint8(17),
	86:   uint8(17),
	87:   uint8(17),
	88:   uint8(17),
	89:   uint8(17),
	90:   uint8(17),
	91:   uint8(17),
	92:   uint8(17),
	93:   uint8(17),
	94:   uint8(17),
	95:   uint8(17),
	96:   uint8(17),
	97:   uint8(17),
	98:   uint8(17),
	99:   uint8(17),
	100:  uint8(17),
	101:  uint8(17),
	102:  uint8(17),
	103:  uint8(17),
	104:  uint8(17),
	105:  uint8(17),
	106:  uint8(17),
	107:  uint8(17),
	108:  uint8(17),
	109:  uint8(17),
	110:  uint8(17),
	111:  uint8(17),
	112:  uint8(17),
	113:  uint8(17),
	114:  uint8(17),
	115:  uint8(17),
	116:  uint8(17),
	117:  uint8(17),
	118:  uint8(17),
	119:  uint8(17),
	120:  uint8(17),
	121:  uint8(17),
	122:  uint8(17),
	123:  uint8(17),
	124:  uint8(17),
	125:  uint8(17),
	126:  uint8(17),
	127:  uint8(17),
	128:  uint8(17),
	129:  uint8(17),
	130:  uint8(17),
	131:  uint8(17),
	132:  uint8(17),
	133:  uint8(17),
	134:  uint8(17),
	135:  uint8(17),
	136:  uint8(17),
	137:  uint8(17),
	138:  uint8(17),
	139:  uint8(17),
	140:  uint8(17),
	141:  uint8(17),
	142:  uint8(17),
	143:  uint8(17),
	144:  uint8(17),
	145:  uint8(17),
	146:  uint8(17),
	147:  uint8(17),
	148:  uint8(17),
	149:  uint8(17),
	150:  uint8(17),
	151:  uint8(17),
	152:  uint8(17),
	153:  uint8(17),
	154:  uint8(17),
	155:  uint8(17),
	156:  uint8(17),
	157:  uint8(17),
	158:  uint8(17),
	159:  uint8(17),
	160:  uint8(17),
	161:  uint8(17),
	162:  uint8(17),
	163:  uint8(17),
	164:  uint8(30),
	165:  uint8(16),
	166:  uint8(16),
	167:  uint8(16),
	168:  uint8(16),
	169:  uint8(31),
	170:  uint8(16),
	171:  uint8(16),
	172:  uint8(17),
	173:  uint8(17),
	174:  uint8(17),
	175:  uint8(17),
	176:  uint8(17),
	177:  uint8(17),
	178:  uint8(17),
	179:  uint8(17),
	180:  uint8(17),
	181:  uint8(17),
	182:  uint8(17),
	183:  uint8(17),
	184:  uint8(17),
	185:  uint8(17),
	186:  uint8(17),
	187:  uint8(17),
	188:  uint8(17),
	189:  uint8(17),
	190:  uint8(17),
	191:  uint8(17),
	192:  uint8(17),
	193:  uint8(17),
	194:  uint8(17),
	195:  uint8(17),
	196:  uint8(17),
	197:  uint8(17),
	198:  uint8(17),
	199:  uint8(17),
	200:  uint8(17),
	201:  uint8(17),
	202:  uint8(17),
	203:  uint8(17),
	204:  uint8(17),
	205:  uint8(17),
	206:  uint8(17),
	207:  uint8(17),
	208:  uint8(17),
	209:  uint8(17),
	210:  uint8(17),
	211:  uint8(17),
	212:  uint8(17),
	213:  uint8(17),
	214:  uint8(17),
	215:  uint8(32),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(17),
	250:  uint8(17),
	251:  uint8(16),
	252:  uint8(16),
	253:  uint8(16),
	254:  uint8(33),
	255:  uint8(34),
	256:  uint8(16),
	257:  uint8(16),
	258:  uint8(16),
	259:  uint8(16),
	260:  uint8(16),
	261:  uint8(16),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(16),
	265:  uint8(16),
	266:  uint8(16),
	267:  uint8(16),
	268:  uint8(16),
	269:  uint8(16),
	270:  uint8(16),
	271:  uint8(16),
	272:  uint8(16),
	273:  uint8(16),
	274:  uint8(16),
	275:  uint8(16),
	276:  uint8(16),
	277:  uint8(16),
	278:  uint8(16),
	279:  uint8(16),
	280:  uint8(16),
	281:  uint8(16),
	282:  uint8(16),
	283:  uint8(16),
	284:  uint8(16),
	285:  uint8(16),
	286:  uint8(16),
	287:  uint8(16),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(16),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(16),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(16),
	363:  uint8(16),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(16),
	367:  uint8(35),
	368:  uint8(17),
	369:  uint8(17),
	370:  uint8(17),
	371:  uint8(17),
	372:  uint8(17),
	373:  uint8(17),
	374:  uint8(17),
	375:  uint8(17),
	376:  uint8(17),
	377:  uint8(17),
	378:  uint8(17),
	379:  uint8(17),
	380:  uint8(17),
	381:  uint8(17),
	382:  uint8(17),
	383:  uint8(17),
	384:  uint8(17),
	385:  uint8(17),
	386:  uint8(17),
	387:  uint8(17),
	388:  uint8(17),
	389:  uint8(17),
	390:  uint8(17),
	391:  uint8(36),
	392:  uint8(17),
	393:  uint8(17),
	394:  uint8(37),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(17),
	433:  uint8(38),
	434:  uint8(39),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(16),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(16),
	466:  uint8(16),
	467:  uint8(16),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(16),
	471:  uint8(16),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(16),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(16),
	481:  uint8(16),
	482:  uint8(16),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(16),
	489:  uint8(16),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(16),
	495:  uint8(16),
	496:  uint8(40),
	497:  uint8(41),
	498:  uint8(42),
	499:  uint8(43),
	500:  uint8(44),
	501:  uint8(45),
	502:  uint8(46),
	503:  uint8(47),
	504:  uint8(16),
	505:  uint8(48),
	506:  uint8(49),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	512:  uint8(0),
	513:  uint8(0),
	514:  uint8(0),
	515:  uint8(0),
	516:  uint8(0),
	517:  uint8(0),
	518:  uint8(0),
	519:  uint8(0),
	520:  uint8(0),
	521:  uint8(0),
	522:  uint8(0),
	523:  uint8(0),
	524:  uint8(0),
	525:  uint8(0),
	526:  uint8(0),
	527:  uint8(0),
	528:  uint8(0),
	529:  uint8(0),
	530:  uint8(0),
	531:  uint8(0),
	532:  uint8(0),
	533:  uint8(0),
	534:  uint8(0),
	535:  uint8(0),
	536:  uint8(0),
	537:  uint8(0),
	538:  uint8(0),
	539:  uint8(0),
	540:  uint8(0),
	541:  uint8(0),
	542:  uint8(0),
	543:  uint8(0),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(255),
	577:  uint8(255),
	578:  uint8(255),
	579:  uint8(255),
	580:  uint8(255),
	581:  uint8(255),
	582:  uint8(255),
	583:  uint8(255),
	584:  uint8(255),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(255),
	588:  uint8(0),
	589:  uint8(0),
	590:  uint8(0),
	591:  uint8(0),
	592:  uint8(0),
	593:  uint8(0),
	594:  uint8(0),
	595:  uint8(0),
	596:  uint8(0),
	597:  uint8(0),
	598:  uint8(0),
	599:  uint8(0),
	600:  uint8(0),
	601:  uint8(0),
	602:  uint8(0),
	603:  uint8(0),
	604:  uint8(0),
	605:  uint8(0),
	606:  uint8(0),
	607:  uint8(0),
	608:  uint8(0),
	609:  uint8(0),
	610:  uint8(0),
	611:  uint8(12),
	612:  uint8(0),
	613:  uint8(6),
	614:  uint8(0),
	615:  uint8(0),
	616:  uint8(0),
	617:  uint8(0),
	618:  uint8(0),
	619:  uint8(0),
	620:  uint8(0),
	621:  uint8(0),
	622:  uint8(0),
	623:  uint8(0),
	624:  uint8(0),
	625:  uint8(0),
	626:  uint8(0),
	627:  uint8(0),
	628:  uint8(0),
	629:  uint8(0),
	630:  uint8(0),
	631:  uint8(0),
	632:  uint8(0),
	633:  uint8(0),
	634:  uint8(0),
	635:  uint8(0),
	636:  uint8(0),
	637:  uint8(30),
	638:  uint8(9),
	639:  uint8(0),
	640:  uint8(0),
	641:  uint8(0),
	642:  uint8(0),
	643:  uint8(0),
	644:  uint8(0),
	645:  uint8(0),
	646:  uint8(0),
	647:  uint8(0),
	648:  uint8(0),
	649:  uint8(0),
	650:  uint8(0),
	651:  uint8(0),
	652:  uint8(0),
	653:  uint8(0),
	654:  uint8(0),
	655:  uint8(0),
	656:  uint8(0),
	657:  uint8(0),
	658:  uint8(0),
	659:  uint8(0),
	660:  uint8(0),
	661:  uint8(0),
	662:  uint8(0),
	663:  uint8(0),
	664:  uint8(0),
	665:  uint8(0),
	666:  uint8(0),
	667:  uint8(0),
	668:  uint8(0),
	669:  uint8(0),
	670:  uint8(0),
	671:  uint8(96),
	672:  uint8(0),
	673:  uint8(0),
	674:  uint8(48),
	675:  uint8(0),
	676:  uint8(0),
	677:  uint8(0),
	678:  uint8(0),
	679:  uint8(0),
	680:  uint8(0),
	681:  uint8(255),
	682:  uint8(15),
	683:  uint8(0),
	684:  uint8(0),
	685:  uint8(0),
	686:  uint8(0),
	687:  uint8(128),
	688:  uint8(0),
	689:  uint8(0),
	690:  uint8(8),
	691:  uint8(0),
	692:  uint8(2),
	693:  uint8(12),
	694:  uint8(0),
	695:  uint8(96),
	696:  uint8(48),
	697:  uint8(64),
	698:  uint8(16),
	699:  uint8(0),
	700:  uint8(0),
	701:  uint8(4),
	702:  uint8(44),
	703:  uint8(36),
	704:  uint8(32),
	705:  uint8(12),
	706:  uint8(0),
	707:  uint8(0),
	708:  uint8(0),
	709:  uint8(1),
	710:  uint8(0),
	711:  uint8(0),
	712:  uint8(0),
	713:  uint8(80),
	714:  uint8(184),
	715:  uint8(0),
	716:  uint8(0),
	717:  uint8(0),
	718:  uint8(0),
	719:  uint8(0),
	720:  uint8(0),
	721:  uint8(0),
	722:  uint8(224),
	723:  uint8(0),
	724:  uint8(0),
	725:  uint8(0),
	726:  uint8(1),
	727:  uint8(128),
	728:  uint8(0),
	729:  uint8(0),
	730:  uint8(0),
	731:  uint8(0),
	732:  uint8(0),
	733:  uint8(0),
	734:  uint8(0),
	735:  uint8(0),
	736:  uint8(0),
	737:  uint8(0),
	738:  uint8(0),
	739:  uint8(24),
	740:  uint8(0),
	741:  uint8(0),
	742:  uint8(0),
	743:  uint8(0),
	744:  uint8(0),
	745:  uint8(0),
	746:  uint8(33),
	747:  uint8(0),
	748:  uint8(0),
	749:  uint8(0),
	750:  uint8(0),
	751:  uint8(0),
	752:  uint8(0),
	753:  uint8(0),
	754:  uint8(0),
	755:  uint8(0),
	756:  uint8(0),
	757:  uint8(0),
	758:  uint8(0),
	759:  uint8(0),
	760:  uint8(0),
	761:  uint8(0),
	762:  uint8(0),
	763:  uint8(0),
	764:  uint8(0),
	765:  uint8(0),
	766:  uint8(0),
	767:  uint8(0),
	768:  uint8(0),
	769:  uint8(0),
	770:  uint8(0),
	771:  uint8(0),
	772:  uint8(0),
	773:  uint8(0),
	774:  uint8(0),
	775:  uint8(0),
	776:  uint8(0),
	777:  uint8(0),
	778:  uint8(0),
	779:  uint8(0),
	780:  uint8(0),
	781:  uint8(0),
	782:  uint8(0),
	783:  uint8(0),
	784:  uint8(255),
	785:  uint8(255),
	786:  uint8(255),
	787:  uint8(251),
	788:  uint8(255),
	789:  uint8(255),
	790:  uint8(255),
	791:  uint8(255),
	792:  uint8(255),
	793:  uint8(255),
	794:  uint8(255),
	795:  uint8(255),
	796:  uint8(255),
	797:  uint8(255),
	798:  uint8(15),
	799:  uint8(0),
	800:  uint8(255),
	801:  uint8(255),
	802:  uint8(255),
	803:  uint8(255),
	804:  uint8(255),
	805:  uint8(255),
	806:  uint8(255),
	807:  uint8(255),
	808:  uint8(255),
	809:  uint8(255),
	810:  uint8(255),
	811:  uint8(255),
	812:  uint8(255),
	813:  uint8(255),
	814:  uint8(255),
	815:  uint8(255),
	816:  uint8(255),
	817:  uint8(255),
	818:  uint8(255),
	819:  uint8(255),
	820:  uint8(255),
	821:  uint8(255),
	822:  uint8(255),
	823:  uint8(255),
	824:  uint8(255),
	825:  uint8(255),
	826:  uint8(63),
	827:  uint8(0),
	828:  uint8(0),
	829:  uint8(0),
	830:  uint8(255),
	831:  uint8(15),
	832:  uint8(255),
	833:  uint8(255),
	834:  uint8(255),
	835:  uint8(255),
	836:  uint8(255),
	837:  uint8(255),
	838:  uint8(255),
	839:  uint8(127),
	840:  uint8(254),
	841:  uint8(255),
	842:  uint8(255),
	843:  uint8(255),
	844:  uint8(255),
	845:  uint8(255),
	846:  uint8(255),
	847:  uint8(255),
	848:  uint8(255),
	849:  uint8(255),
	850:  uint8(127),
	851:  uint8(254),
	852:  uint8(255),
	853:  uint8(255),
	854:  uint8(255),
	855:  uint8(255),
	856:  uint8(255),
	857:  uint8(255),
	858:  uint8(255),
	859:  uint8(255),
	860:  uint8(255),
	861:  uint8(255),
	862:  uint8(255),
	863:  uint8(255),
	864:  uint8(224),
	865:  uint8(255),
	866:  uint8(255),
	867:  uint8(255),
	868:  uint8(255),
	869:  uint8(255),
	870:  uint8(254),
	871:  uint8(255),
	872:  uint8(255),
	873:  uint8(255),
	874:  uint8(255),
	875:  uint8(255),
	876:  uint8(255),
	877:  uint8(255),
	878:  uint8(255),
	879:  uint8(255),
	880:  uint8(255),
	881:  uint8(127),
	882:  uint8(255),
	883:  uint8(255),
	884:  uint8(255),
	885:  uint8(255),
	886:  uint8(255),
	887:  uint8(7),
	888:  uint8(255),
	889:  uint8(255),
	890:  uint8(255),
	891:  uint8(255),
	892:  uint8(15),
	893:  uint8(0),
	894:  uint8(255),
	895:  uint8(255),
	896:  uint8(255),
	897:  uint8(255),
	898:  uint8(255),
	899:  uint8(127),
	900:  uint8(255),
	901:  uint8(255),
	902:  uint8(255),
	903:  uint8(255),
	904:  uint8(255),
	905:  uint8(0),
	906:  uint8(255),
	907:  uint8(255),
	908:  uint8(255),
	909:  uint8(255),
	910:  uint8(255),
	911:  uint8(255),
	912:  uint8(255),
	913:  uint8(255),
	914:  uint8(255),
	915:  uint8(255),
	916:  uint8(255),
	917:  uint8(255),
	918:  uint8(255),
	919:  uint8(255),
	920:  uint8(255),
	921:  uint8(255),
	922:  uint8(255),
	923:  uint8(255),
	924:  uint8(255),
	925:  uint8(255),
	926:  uint8(255),
	927:  uint8(255),
	928:  uint8(255),
	929:  uint8(255),
	930:  uint8(255),
	931:  uint8(255),
	932:  uint8(255),
	933:  uint8(255),
	934:  uint8(255),
	935:  uint8(255),
	936:  uint8(255),
	937:  uint8(255),
	938:  uint8(255),
	939:  uint8(255),
	940:  uint8(255),
	941:  uint8(255),
	942:  uint8(255),
	943:  uint8(255),
	944:  uint8(255),
	945:  uint8(255),
	946:  uint8(255),
	947:  uint8(255),
	948:  uint8(255),
	949:  uint8(255),
	950:  uint8(255),
	951:  uint8(255),
	952:  uint8(0),
	953:  uint8(0),
	954:  uint8(0),
	955:  uint8(0),
	956:  uint8(0),
	957:  uint8(0),
	958:  uint8(0),
	959:  uint8(0),
	960:  uint8(255),
	961:  uint8(255),
	962:  uint8(255),
	963:  uint8(255),
	964:  uint8(255),
	965:  uint8(255),
	966:  uint8(255),
	967:  uint8(255),
	968:  uint8(255),
	969:  uint8(255),
	970:  uint8(255),
	971:  uint8(255),
	972:  uint8(255),
	973:  uint8(255),
	974:  uint8(255),
	975:  uint8(255),
	976:  uint8(255),
	977:  uint8(31),
	978:  uint8(255),
	979:  uint8(255),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(255),
	983:  uint8(255),
	984:  uint8(127),
	985:  uint8(0),
	986:  uint8(0),
	987:  uint8(0),
	988:  uint8(0),
	989:  uint8(0),
	990:  uint8(0),
	991:  uint8(0),
	992:  uint8(0),
	993:  uint8(0),
	994:  uint8(0),
	995:  uint8(0),
	996:  uint8(0),
	997:  uint8(0),
	998:  uint8(0),
	999:  uint8(0),
	1000: uint8(0),
	1001: uint8(0),
	1002: uint8(0),
	1003: uint8(0),
	1004: uint8(255),
	1005: uint8(255),
	1006: uint8(255),
	1007: uint8(31),
	1008: uint8(0),
	1009: uint8(0),
	1010: uint8(0),
	1011: uint8(0),
	1012: uint8(0),
	1013: uint8(0),
	1014: uint8(0),
	1015: uint8(0),
	1016: uint8(0),
	1017: uint8(0),
	1018: uint8(0),
	1019: uint8(0),
	1020: uint8(0),
	1021: uint8(0),
	1022: uint8(0),
	1023: uint8(0),
	1024: uint8(255),
	1025: uint8(255),
	1026: uint8(255),
	1027: uint8(255),
	1028: uint8(255),
	1029: uint8(255),
	1030: uint8(255),
	1031: uint8(255),
	1032: uint8(255),
	1033: uint8(255),
	1034: uint8(255),
	1035: uint8(255),
	1036: uint8(255),
	1037: uint8(255),
	1038: uint8(255),
	1039: uint8(255),
	1040: uint8(255),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(255),
	1044: uint8(15),
	1045: uint8(0),
	1046: uint8(0),
	1047: uint8(0),
	1048: uint8(0),
	1049: uint8(0),
	1050: uint8(0),
	1051: uint8(0),
	1052: uint8(0),
	1053: uint8(0),
	1054: uint8(0),
	1055: uint8(0),
	1056: uint8(0),
	1057: uint8(0),
	1058: uint8(255),
	1059: uint8(3),
	1060: uint8(0),
	1061: uint8(0),
	1062: uint8(255),
	1063: uint8(255),
	1064: uint8(255),
	1065: uint8(255),
	1066: uint8(247),
	1067: uint8(255),
	1068: uint8(127),
	1069: uint8(15),
	1070: uint8(0),
	1071: uint8(0),
	1072: uint8(0),
	1073: uint8(0),
	1074: uint8(0),
	1075: uint8(0),
	1076: uint8(0),
	1077: uint8(0),
	1078: uint8(0),
	1079: uint8(0),
	1080: uint8(0),
	1081: uint8(0),
	1082: uint8(0),
	1083: uint8(0),
	1084: uint8(0),
	1085: uint8(0),
	1086: uint8(0),
	1087: uint8(0),
	1088: uint8(254),
	1089: uint8(255),
	1090: uint8(255),
	1091: uint8(255),
	1092: uint8(255),
	1093: uint8(255),
	1094: uint8(255),
	1095: uint8(255),
	1096: uint8(255),
	1097: uint8(255),
	1098: uint8(255),
	1099: uint8(255),
	1100: uint8(1),
	1101: uint8(0),
	1102: uint8(0),
	1103: uint8(0),
	1104: uint8(0),
	1105: uint8(0),
	1106: uint8(0),
	1107: uint8(0),
	1108: uint8(0),
	1109: uint8(0),
	1110: uint8(0),
	1111: uint8(0),
	1112: uint8(0),
	1113: uint8(0),
	1114: uint8(0),
	1115: uint8(0),
	1116: uint8(127),
	1117: uint8(0),
	1118: uint8(0),
	1119: uint8(0),
	1120: uint8(0),
	1121: uint8(0),
	1122: uint8(0),
	1123: uint8(0),
	1124: uint8(0),
	1125: uint8(0),
	1126: uint8(0),
	1127: uint8(0),
	1128: uint8(0),
	1129: uint8(0),
	1130: uint8(0),
	1131: uint8(0),
	1132: uint8(0),
	1133: uint8(0),
	1134: uint8(0),
	1135: uint8(0),
	1136: uint8(0),
	1137: uint8(0),
	1138: uint8(0),
	1139: uint8(0),
	1140: uint8(0),
	1141: uint8(0),
	1142: uint8(0),
	1143: uint8(0),
	1144: uint8(0),
	1145: uint8(0),
	1146: uint8(0),
	1147: uint8(0),
	1148: uint8(15),
	1149: uint8(0),
	1150: uint8(0),
	1151: uint8(0),
	1152: uint8(255),
	1153: uint8(255),
	1154: uint8(255),
	1155: uint8(255),
	1156: uint8(255),
	1157: uint8(255),
	1158: uint8(255),
	1159: uint8(255),
	1160: uint8(255),
	1161: uint8(255),
	1162: uint8(255),
	1163: uint8(255),
	1164: uint8(255),
	1165: uint8(255),
	1166: uint8(255),
	1167: uint8(255),
	1168: uint8(255),
	1169: uint8(255),
	1170: uint8(255),
	1171: uint8(255),
	1172: uint8(255),
	1173: uint8(255),
	1174: uint8(255),
	1175: uint8(255),
	1176: uint8(255),
	1177: uint8(255),
	1178: uint8(255),
	1179: uint8(255),
	1180: uint8(255),
	1181: uint8(255),
	1182: uint8(255),
	1183: uint8(0),
	1184: uint8(255),
	1185: uint8(255),
	1186: uint8(255),
	1187: uint8(255),
	1188: uint8(255),
	1189: uint8(255),
	1190: uint8(255),
	1191: uint8(255),
	1192: uint8(255),
	1193: uint8(255),
	1194: uint8(255),
	1195: uint8(255),
	1196: uint8(255),
	1197: uint8(255),
	1198: uint8(255),
	1199: uint8(255),
	1200: uint8(255),
	1201: uint8(255),
	1202: uint8(255),
	1203: uint8(255),
	1204: uint8(255),
	1205: uint8(255),
	1206: uint8(255),
	1207: uint8(255),
	1208: uint8(255),
	1209: uint8(255),
	1210: uint8(255),
	1211: uint8(255),
	1212: uint8(255),
	1213: uint8(255),
	1214: uint8(7),
	1215: uint8(0),
	1216: uint8(255),
	1217: uint8(255),
	1218: uint8(255),
	1219: uint8(127),
	1220: uint8(0),
	1221: uint8(0),
	1222: uint8(0),
	1223: uint8(0),
	1224: uint8(0),
	1225: uint8(0),
	1226: uint8(7),
	1227: uint8(0),
	1228: uint8(240),
	1229: uint8(0),
	1230: uint8(255),
	1231: uint8(255),
	1232: uint8(255),
	1233: uint8(255),
	1234: uint8(255),
	1235: uint8(255),
	1236: uint8(255),
	1237: uint8(255),
	1238: uint8(255),
	1239: uint8(255),
	1240: uint8(255),
	1241: uint8(255),
	1242: uint8(255),
	1243: uint8(255),
	1244: uint8(255),
	1245: uint8(255),
	1246: uint8(255),
	1247: uint8(255),
	1248: uint8(255),
	1249: uint8(255),
	1250: uint8(255),
	1251: uint8(255),
	1252: uint8(255),
	1253: uint8(255),
	1254: uint8(255),
	1255: uint8(255),
	1256: uint8(255),
	1257: uint8(255),
	1258: uint8(255),
	1259: uint8(255),
	1260: uint8(255),
	1261: uint8(255),
	1262: uint8(255),
	1263: uint8(255),
	1264: uint8(255),
	1265: uint8(255),
	1266: uint8(255),
	1267: uint8(255),
	1268: uint8(255),
	1269: uint8(255),
	1270: uint8(255),
	1271: uint8(255),
	1272: uint8(255),
	1273: uint8(255),
	1274: uint8(255),
	1275: uint8(255),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(255),
	1279: uint8(15),
	1280: uint8(16),
	1281: uint8(0),
	1282: uint8(0),
	1283: uint8(0),
	1284: uint8(0),
	1285: uint8(0),
	1286: uint8(0),
	1287: uint8(0),
	1288: uint8(0),
	1289: uint8(0),
	1290: uint8(0),
	1291: uint8(0),
	1292: uint8(0),
	1293: uint8(0),
	1294: uint8(0),
	1295: uint8(0),
	1296: uint8(0),
	1297: uint8(0),
	1298: uint8(0),
	1299: uint8(0),
	1300: uint8(0),
	1301: uint8(0),
	1302: uint8(0),
	1303: uint8(0),
	1304: uint8(0),
	1305: uint8(128),
	1306: uint8(0),
	1307: uint8(0),
	1308: uint8(0),
	1309: uint8(0),
	1310: uint8(0),
	1311: uint8(0),
	1312: uint8(0),
	1313: uint8(0),
	1314: uint8(0),
	1315: uint8(0),
	1316: uint8(0),
	1317: uint8(0),
	1318: uint8(0),
	1319: uint8(0),
	1320: uint8(0),
	1321: uint8(0),
	1322: uint8(0),
	1323: uint8(0),
	1324: uint8(0),
	1325: uint8(0),
	1326: uint8(0),
	1327: uint8(0),
	1328: uint8(0),
	1329: uint8(64),
	1330: uint8(254),
	1331: uint8(7),
	1332: uint8(0),
	1333: uint8(0),
	1334: uint8(0),
	1335: uint8(0),
	1336: uint8(0),
	1337: uint8(0),
	1338: uint8(0),
	1339: uint8(0),
	1340: uint8(0),
	1341: uint8(0),
	1342: uint8(0),
	1343: uint8(0),
	1344: uint8(7),
	1345: uint8(0),
	1346: uint8(255),
	1347: uint8(255),
	1348: uint8(255),
	1349: uint8(255),
	1350: uint8(255),
	1351: uint8(15),
	1352: uint8(255),
	1353: uint8(1),
	1354: uint8(3),
	1355: uint8(0),
	1356: uint8(63),
	1357: uint8(0),
	1358: uint8(0),
	1359: uint8(0),
	1360: uint8(0),
	1361: uint8(0),
	1362: uint8(0),
	1363: uint8(0),
	1364: uint8(0),
	1365: uint8(0),
	1366: uint8(0),
	1367: uint8(0),
	1368: uint8(0),
	1369: uint8(0),
	1370: uint8(0),
	1371: uint8(0),
	1372: uint8(0),
	1373: uint8(0),
	1374: uint8(0),
	1375: uint8(0),
	1376: uint8(255),
	1377: uint8(255),
	1378: uint8(255),
	1379: uint8(255),
	1380: uint8(1),
	1381: uint8(224),
	1382: uint8(191),
	1383: uint8(255),
	1384: uint8(255),
	1385: uint8(255),
	1386: uint8(255),
	1387: uint8(255),
	1388: uint8(255),
	1389: uint8(255),
	1390: uint8(255),
	1391: uint8(223),
	1392: uint8(255),
	1393: uint8(255),
	1394: uint8(15),
	1395: uint8(0),
	1396: uint8(255),
	1397: uint8(255),
	1398: uint8(255),
	1399: uint8(255),
	1400: uint8(255),
	1401: uint8(135),
	1402: uint8(15),
	1403: uint8(0),
	1404: uint8(255),
	1405: uint8(255),
	1406: uint8(17),
	1407: uint8(255),
	1408: uint8(255),
	1409: uint8(255),
	1410: uint8(255),
	1411: uint8(255),
	1412: uint8(255),
	1413: uint8(255),
	1414: uint8(255),
	1415: uint8(127),
	1416: uint8(253),
	1417: uint8(255),
	1418: uint8(255),
	1419: uint8(255),
	1420: uint8(255),
	1421: uint8(255),
	1422: uint8(255),
	1423: uint8(255),
	1424: uint8(255),
	1425: uint8(255),
	1426: uint8(255),
	1427: uint8(255),
	1428: uint8(255),
	1429: uint8(255),
	1430: uint8(255),
	1431: uint8(255),
	1432: uint8(255),
	1433: uint8(255),
	1434: uint8(255),
	1435: uint8(255),
	1436: uint8(255),
	1437: uint8(255),
	1438: uint8(255),
	1439: uint8(159),
	1440: uint8(255),
	1441: uint8(255),
	1442: uint8(255),
	1443: uint8(255),
	1444: uint8(255),
	1445: uint8(255),
	1446: uint8(255),
	1447: uint8(63),
	1448: uint8(0),
	1449: uint8(120),
	1450: uint8(255),
	1451: uint8(255),
	1452: uint8(255),
	1453: uint8(0),
	1454: uint8(0),
	1455: uint8(4),
	1456: uint8(0),
	1457: uint8(0),
	1458: uint8(96),
	1459: uint8(0),
	1460: uint8(16),
	1461: uint8(0),
	1462: uint8(0),
	1463: uint8(0),
	1464: uint8(0),
	1465: uint8(0),
	1466: uint8(0),
	1467: uint8(0),
	1468: uint8(0),
	1469: uint8(0),
	1470: uint8(0),
	1471: uint8(248),
	1472: uint8(255),
	1473: uint8(255),
	1474: uint8(255),
	1475: uint8(255),
	1476: uint8(255),
	1477: uint8(255),
	1478: uint8(255),
	1479: uint8(255),
	1480: uint8(255),
	1481: uint8(255),
	1482: uint8(0),
	1483: uint8(0),
	1484: uint8(0),
	1485: uint8(0),
	1486: uint8(0),
	1487: uint8(0),
	1488: uint8(255),
	1489: uint8(255),
	1490: uint8(255),
	1491: uint8(255),
	1492: uint8(255),
	1493: uint8(255),
	1494: uint8(255),
	1495: uint8(255),
	1496: uint8(63),
	1497: uint8(16),
	1498: uint8(39),
	1499: uint8(0),
	1500: uint8(0),
	1501: uint8(24),
	1502: uint8(240),
	1503: uint8(7),
	1504: uint8(0),
	1505: uint8(0),
	1506: uint8(0),
	1507: uint8(0),
	1508: uint8(0),
	1509: uint8(0),
	1510: uint8(0),
	1511: uint8(0),
	1512: uint8(0),
	1513: uint8(0),
	1514: uint8(0),
	1515: uint8(0),
	1516: uint8(0),
	1517: uint8(0),
	1518: uint8(0),
	1519: uint8(0),
	1520: uint8(0),
	1521: uint8(0),
	1522: uint8(0),
	1523: uint8(0),
	1524: uint8(0),
	1525: uint8(0),
	1526: uint8(0),
	1527: uint8(0),
	1528: uint8(0),
	1529: uint8(0),
	1530: uint8(0),
	1531: uint8(0),
	1532: uint8(255),
	1533: uint8(15),
	1534: uint8(0),
	1535: uint8(0),
	1536: uint8(0),
	1537: uint8(224),
	1538: uint8(255),
	1539: uint8(255),
	1540: uint8(255),
	1541: uint8(255),
	1542: uint8(255),
	1543: uint8(255),
	1544: uint8(255),
	1545: uint8(255),
	1546: uint8(255),
	1547: uint8(255),
	1548: uint8(255),
	1549: uint8(255),
	1550: uint8(123),
	1551: uint8(252),
	1552: uint8(255),
	1553: uint8(255),
	1554: uint8(255),
	1555: uint8(255),
	1556: uint8(231),
	1557: uint8(199),
	1558: uint8(255),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(231),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(255),
	1566: uint8(255),
	1567: uint8(255),
	1568: uint8(0),
	1569: uint8(0),
	1570: uint8(0),
	1571: uint8(0),
	1572: uint8(0),
	1573: uint8(0),
	1574: uint8(0),
	1575: uint8(0),
	1576: uint8(0),
	1577: uint8(0),
	1578: uint8(0),
	1579: uint8(0),
	1580: uint8(0),
	1581: uint8(0),
	1582: uint8(15),
	1583: uint8(7),
	1584: uint8(7),
	1585: uint8(0),
	1586: uint8(63),
	1587: uint8(0),
	1588: uint8(0),
	1589: uint8(0),
	1590: uint8(0),
	1591: uint8(0),
	1592: uint8(0),
	1593: uint8(0),
	1594: uint8(0),
	1595: uint8(0),
	1596: uint8(0),
	1597: uint8(0),
	1598: uint8(0),
	1599: uint8(0)}

func x_wcwidth(tls *TLS, wc Twchar_t) (r int32) {
	var v1 int32
	var v2 int32
	if uint32(wc) < uint32(0xff) {
		if (wc+int32(1))&int32(0x7f) >= int32(0x21) {
			v1 = int32(1)
		} else {
			if wc != 0 {
				v2 = -int32(1)
			} else {
				v2 = int32(0)
			}
			v1 = v2
		}
		return v1
	}
	if uint32(wc)&uint32(0xfffeffff) < uint32(0xfffe) {
		if int32(_table5[int32(_table5[wc>>int32(8)])*int32(32)+wc&int32(255)>>int32(3)])>>(wc&int32(7))&int32(1) != 0 {
			return int32(0)
		}
		if int32(_wtable[int32(_wtable[wc>>int32(8)])*int32(32)+wc&int32(255)>>int32(3)])>>(wc&int32(7))&int32(1) != 0 {
			return int32(2)
		}
		return int32(1)
	}
	if wc&int32(0xfffe) == int32(0xfffe) {
		return -int32(1)
	}
	if uint32(wc)-uint32(0x20000) < uint32(0x20000) {
		return int32(2)
	}
	if wc == int32(0xe0001) || uint32(wc)-uint32(0xe0020) < uint32(0x5f) || uint32(wc)-uint32(0xe0100) < uint32(0xef) {
		return int32(0)
	}
	return int32(1)
}

type Tino_t = uint64

type Tdirent = struct {
	Fd_ino       Tino_t
	Fd_off       Toff_t
	Fd_reclen    uint16
	Fd_type      uint8
	Fd_name      [256]int8
	F__ccgo_pad5 [5]byte
}

func x_alphasort(tls *TLS, a uintptr, b uintptr) (r int32) {
	return x_strcoll(tls, *(*uintptr)(unsafe.Pointer(a))+19, *(*uintptr)(unsafe.Pointer(b))+19)
}

type TDIR = struct {
	Ftell    Toff_t
	Ffd      int32
	Fbuf_pos int32
	Fbuf_end int32
	Flock    [1]int32
	Fbuf     [2048]int8
}

type T__dirstream = TDIR

func x_closedir(tls *TLS, dir uintptr) (r int32) {
	var ret int32
	ret = x_close(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd)
	x_free(tls, dir)
	return ret
}

func x_dirfd(tls *TLS, d uintptr) (r int32) {
	return (*TDIR)(unsafe.Pointer(d)).Ffd
}

const m_ENOTDIR = 20
const m_FD_CLOEXEC = 1
const m_F_SETFD = 2
const m_O_PATH = 2097152
const m_S_IFDIR = 16384
const m_S_IFMT = 61440

type Tnlink_t = uint64

type Tdev_t = uint64

type Tblksize_t = int64

type Tblkcnt_t = int64

type Tstat = struct {
	Fst_dev     Tdev_t
	Fst_ino     Tino_t
	Fst_nlink   Tnlink_t
	Fst_mode    Tmode_t
	Fst_uid     Tuid_t
	Fst_gid     Tgid_t
	F__pad0     uint32
	Fst_rdev    Tdev_t
	Fst_size    Toff_t
	Fst_blksize Tblksize_t
	Fst_blocks  Tblkcnt_t
	Fst_atim    Ttimespec
	Fst_mtim    Ttimespec
	Fst_ctim    Ttimespec
	F__unused   [3]int64
}

func x_fdopendir(tls *TLS, fd int32) (r uintptr) {
	bp := tls.Alloc(160) /* tlsAllocs 144 maxValist 1 */
	defer tls.Free(160)
	var dir uintptr
	var _ /* st at bp+0 */ Tstat
	var v1 uintptr
	if x___fstat(tls, fd, bp) < int32(0) {
		return uintptr(0)
	}
	if x_fcntl(tls, fd, int32(m_F_GETFL), 0)&int32(m_O_PATH) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EBADF)
		return uintptr(0)
	}
	if !((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&Uint32FromInt32(m_S_IFMT) == Uint32FromInt32(m_S_IFDIR)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOTDIR)
		return uintptr(0)
	}
	v1 = x_calloc(tls, uint64(1), uint64(2072))
	dir = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	x_fcntl(tls, fd, int32(m_F_SETFD), VaList(bp+152, int32(m_FD_CLOEXEC)))
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

const m_O_CLOEXEC = 524288
const m_O_DIRECTORY = 65536
const m_O_RDONLY = 0

type Tiovec = struct {
	Fiov_base uintptr
	Fiov_len  Tsize_t
}

type Tfile_handle = struct {
	Fhandle_bytes uint32
	Fhandle_type  int32
}

type Tf_owner_ex = struct {
	Ftype1 int32
	Fpid   Tpid_t
}

func x_opendir(tls *TLS, name uintptr) (r uintptr) {
	var dir uintptr
	var fd int32
	var v1 int32
	var v2 uintptr
	v1 = x_open(tls, name, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_DIRECTORY)|Int32FromInt32(m_O_CLOEXEC), 0)
	fd = v1
	if v1 < int32(0) {
		return uintptr(0)
	}
	v2 = x_calloc(tls, uint64(1), uint64(2072))
	dir = v2
	if !(v2 != 0) {
		___syscall1(tls, int64(3), int64(fd))
		return uintptr(0)
	}
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

type Tptrdiff_t = int64

type Tdirstream_buf_alignment_check = [1]int8

func x_readdir(tls *TLS, dir uintptr) (r uintptr) {
	var de uintptr
	var len1 int32
	var p1 uintptr
	if (*TDIR)(unsafe.Pointer(dir)).Fbuf_pos >= (*TDIR)(unsafe.Pointer(dir)).Fbuf_end {
		len1 = int32(___syscall3(tls, int64(217), int64((*TDIR)(unsafe.Pointer(dir)).Ffd), int64(dir+24), int64(Uint64FromInt64(2048))))
		if len1 <= int32(0) {
			if len1 < int32(0) && len1 != -int32(m_ENOENT) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = -len1
			}
			return uintptr(0)
		}
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = len1
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = int32(0)
	}
	de = dir + 24 + uintptr((*TDIR)(unsafe.Pointer(dir)).Fbuf_pos)
	p1 = dir + 12
	*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) + int32((*Tdirent)(unsafe.Pointer(de)).Fd_reclen)
	(*TDIR)(unsafe.Pointer(dir)).Ftell = (*Tdirent)(unsafe.Pointer(de)).Fd_off
	return de
}

func x_readdir_r(tls *TLS, dir uintptr, buf uintptr, result uintptr) (r int32) {
	var de uintptr
	var errno_save int32
	var ret int32
	var v1 int32
	errno_save = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	x___lock(tls, dir+20)
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(0)
	de = x_readdir(tls, dir)
	v1 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	ret = v1
	if v1 != 0 {
		x___unlock(tls, dir+20)
		return ret
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = errno_save
	if de != 0 {
		x_memcpy(tls, buf, de, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
	} else {
		buf = UintptrFromInt32(0)
	}
	x___unlock(tls, dir+20)
	*(*uintptr)(unsafe.Pointer(result)) = buf
	return int32(0)
}

const m_SEEK_SET = 0

func x_rewinddir(tls *TLS, dir uintptr) {
	var v1 int32
	x___lock(tls, dir+20)
	x___lseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, int64(0), int32(m_SEEK_SET))
	v1 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v1
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v1
	(*TDIR)(unsafe.Pointer(dir)).Ftell = int64(0)
	x___unlock(tls, dir+20)
}

func x_scandir(tls *TLS, path uintptr, res uintptr, sel uintptr, cmp uintptr) (r int32) {
	var cnt Tsize_t
	var d uintptr
	var de uintptr
	var len1 Tsize_t
	var names uintptr
	var old_errno int32
	var tmp uintptr
	var v1 uintptr
	var v2 Tsize_t
	var v3 Tsize_t
	d = x_opendir(tls, path)
	names = uintptr(0)
	cnt = uint64(0)
	len1 = uint64(0)
	old_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if !(d != 0) {
		return -int32(1)
	}
	for {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(0)
		v1 = x_readdir(tls, d)
		de = v1
		if !(v1 != 0) {
			break
		}
		if sel != 0 && !((*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{sel})))(tls, de) != 0) {
			continue
		}
		if cnt >= len1 {
			len1 = uint64(2)*len1 + uint64(1)
			if len1 > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(8) {
				break
			}
			tmp = x_realloc(tls, names, len1*uint64(8))
			if !(tmp != 0) {
				break
			}
			names = tmp
		}
		*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) = _default_malloc(tls, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
		if !(*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) != 0) {
			break
		}
		v2 = cnt
		cnt++
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(v2)*8)), de, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
	}
	x_closedir(tls, d)
	if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != 0 {
		if names != 0 {
			for {
				v3 = cnt
				cnt--
				if !(v3 > uint64(0)) {
					break
				}
				x_free(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)))
			}
		}
		x_free(tls, names)
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = old_errno
	if cmp != 0 {
		x_qsort(tls, names, cnt, uint64(8), cmp)
	}
	*(*uintptr)(unsafe.Pointer(res)) = names
	return int32(cnt)
}

func x_seekdir(tls *TLS, dir uintptr, off int64) {
	var v1 int32
	x___lock(tls, dir+20)
	(*TDIR)(unsafe.Pointer(dir)).Ftell = x___lseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, off, int32(m_SEEK_SET))
	v1 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v1
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v1
	x___unlock(tls, dir+20)
}

func x_telldir(tls *TLS, dir uintptr) (r int64) {
	return (*TDIR)(unsafe.Pointer(dir)).Ftell
}

func x_versionsort(tls *TLS, a uintptr, b uintptr) (r int32) {
	return x_strverscmp(tls, *(*uintptr)(unsafe.Pointer(a))+19, *(*uintptr)(unsafe.Pointer(b))+19)
}

const m_AT_PHDR = 3
const m_AT_PHENT = 4
const m_AT_PHNUM = 5
const m_DTP_OFFSET = 0
const m_PT_DYNAMIC = 2
const m_PT_GNU_STACK = 1685382481
const m_PT_PHDR = 6
const m_PT_TLS = 7

func x___init_tp(tls *TLS, p uintptr) (r1 int32) {
	var r int32
	var td Tpthread_t
	var v1 uintptr
	td = p
	(*T__pthread)(unsafe.Pointer(td)).Fself = td
	r = ___set_thread_area(tls, p)
	if r < int32(0) {
		return -int32(1)
	}
	if !(r != 0) {
		x___libc.Fcan_do_threads = int8(1)
	}
	(*T__pthread)(unsafe.Pointer(td)).Fdetach_state = int32(_DT_JOINABLE)
	(*T__pthread)(unsafe.Pointer(td)).Ftid = int32(___syscall1(tls, int64(218), int64(uintptr(unsafe.Pointer(&x___thread_list_lock)))))
	(*T__pthread)(unsafe.Pointer(td)).Flocale = uintptr(unsafe.Pointer(&x___libc.Fglobal_locale))
	(*T__pthread)(unsafe.Pointer(td)).Frobust_list.Fhead = uintptr(unsafe.Pointer(&(*T__pthread)(unsafe.Pointer(td)).Frobust_list.Fhead))
	(*T__pthread)(unsafe.Pointer(td)).Fsysinfo = x___sysinfo
	v1 = td
	(*T__pthread)(unsafe.Pointer(td)).Fprev = v1
	(*T__pthread)(unsafe.Pointer(td)).Fnext = v1
	return int32(0)
}

type Tbuiltin_tls = struct {
	Fc     int8
	Fpt    T__pthread
	Fspace [16]uintptr
}

var _builtin_tls [1]Tbuiltin_tls

var _main_tls Ttls_module

func x___copy_tls(tls *TLS, mem uintptr) (r uintptr) {
	var dtv uintptr
	var i Tsize_t
	var p uintptr
	var td Tpthread_t
	dtv = mem
	mem = mem + uintptr(x___libc.Ftls_size-Uint64FromInt64(200))
	mem = mem - uintptr(uint64(mem)&(x___libc.Ftls_align-Uint64FromInt32(1)))
	td = mem
	i = uint64(1)
	p = x___libc.Ftls_head
	for p != 0 {
		*(*Tuintptr_t)(unsafe.Pointer(dtv + uintptr(i)*8)) = uint64(mem-uintptr((*Ttls_module)(unsafe.Pointer(p)).Foffset)) + uint64(m_DTP_OFFSET)
		x_memcpy(tls, mem-uintptr((*Ttls_module)(unsafe.Pointer(p)).Foffset), (*Ttls_module)(unsafe.Pointer(p)).Fimage, (*Ttls_module)(unsafe.Pointer(p)).Flen1)
		goto _1
	_1:
		i++
		p = (*Ttls_module)(unsafe.Pointer(p)).Fnext
	}
	*(*Tuintptr_t)(unsafe.Pointer(dtv + UintptrFromInt32(0)*8)) = x___libc.Ftls_cnt
	(*T__pthread)(unsafe.Pointer(td)).Fdtv = dtv
	return td
}

type TPhdr = struct {
	Fp_type   TElf64_Word
	Fp_flags  TElf64_Word
	Fp_offset TElf64_Off
	Fp_vaddr  TElf64_Addr
	Fp_paddr  TElf64_Addr
	Fp_filesz TElf64_Xword
	Fp_memsz  TElf64_Xword
	Fp_align  TElf64_Xword
}

func _static_init_tls(tls *TLS, aux uintptr) {
	var base Tsize_t
	var mem uintptr
	var n Tsize_t
	var p uintptr
	var phdr uintptr
	var tls_phdr uintptr
	var v2 bool
	var v3 uint64
	var p4 uintptr
	tls_phdr = uintptr(0)
	base = uint64(0)
	p = uintptr(*(*Tsize_t)(unsafe.Pointer(aux + UintptrFromInt32(m_AT_PHDR)*8)))
	n = *(*Tsize_t)(unsafe.Pointer(aux + UintptrFromInt32(m_AT_PHNUM)*8))
	for n != 0 {
		phdr = p
		if (*TPhdr)(unsafe.Pointer(phdr)).Fp_type == uint32(m_PT_PHDR) {
			base = *(*Tsize_t)(unsafe.Pointer(aux + UintptrFromInt32(m_AT_PHDR)*8)) - (*TPhdr)(unsafe.Pointer(phdr)).Fp_vaddr
		}
		if (*TPhdr)(unsafe.Pointer(phdr)).Fp_type == uint32(m_PT_DYNAMIC) && uintptr(unsafe.Pointer(&__DYNAMIC)) != 0 {
			if v2 = int32(0) != 0; !v2 {
				___assert_fail(tls, ts+207, ts+209, int32(96), uintptr(unsafe.Pointer(&___func__)))
			}
			_ = v2 || Int32FromInt32(0) != 0
			// base = (size_t)_DYNAMIC - phdr->p_vaddr;
		}
		if (*TPhdr)(unsafe.Pointer(phdr)).Fp_type == uint32(m_PT_TLS) {
			tls_phdr = phdr
		}
		if (*TPhdr)(unsafe.Pointer(phdr)).Fp_type == uint32(m_PT_GNU_STACK) && (*TPhdr)(unsafe.Pointer(phdr)).Fp_memsz > uint64(x___default_stacksize) {
			if (*TPhdr)(unsafe.Pointer(phdr)).Fp_memsz < uint64(Int32FromInt32(8)<<Int32FromInt32(20)) {
				v3 = (*TPhdr)(unsafe.Pointer(phdr)).Fp_memsz
			} else {
				v3 = uint64(Int32FromInt32(8) << Int32FromInt32(20))
			}
			x___default_stacksize = uint32(v3)
		}
		goto _1
	_1:
		n--
		p = p + uintptr(*(*Tsize_t)(unsafe.Pointer(aux + UintptrFromInt32(m_AT_PHENT)*8)))
	}
	if tls_phdr != 0 {
		_main_tls.Fimage = uintptr(base + (*TPhdr)(unsafe.Pointer(tls_phdr)).Fp_vaddr)
		_main_tls.Flen1 = (*TPhdr)(unsafe.Pointer(tls_phdr)).Fp_filesz
		_main_tls.Fsize = (*TPhdr)(unsafe.Pointer(tls_phdr)).Fp_memsz
		_main_tls.Falign = (*TPhdr)(unsafe.Pointer(tls_phdr)).Fp_align
		x___libc.Ftls_cnt = uint64(1)
		x___libc.Ftls_head = uintptr(unsafe.Pointer(&_main_tls))
	}
	p4 = uintptr(unsafe.Pointer(&_main_tls.Fsize))
	*(*Tsize_t)(unsafe.Pointer(p4)) = *(*Tsize_t)(unsafe.Pointer(p4)) + (-_main_tls.Fsize-uint64(_main_tls.Fimage))&(_main_tls.Falign-Uint64FromInt32(1))
	_main_tls.Foffset = _main_tls.Fsize
	if _main_tls.Falign < uint64(UintptrFromInt32(0)+8) {
		_main_tls.Falign = uint64(UintptrFromInt32(0) + 8)
	}
	x___libc.Ftls_align = _main_tls.Falign
	x___libc.Ftls_size = (Uint64FromInt32(2)*Uint64FromInt64(8) + Uint64FromInt64(200) + _main_tls.Fsize + _main_tls.Falign + uint64(UintptrFromInt32(0)+8) - uint64(1)) & -uint64(UintptrFromInt32(0)+8)
	if x___libc.Ftls_size > uint64(336) {
		mem = uintptr(___syscall6(tls, int64(9), int64(Int32FromInt32(0)), int64(x___libc.Ftls_size), int64(Int32FromInt32(1)|Int32FromInt32(2)), int64(Int32FromInt32(0x20)|Int32FromInt32(0x02)), int64(-Int32FromInt32(1)), int64(Int32FromInt32(0))))
	} else {
		mem = uintptr(unsafe.Pointer(&_builtin_tls))
	}
	/* Failure to initialize thread pointer is always fatal. */
	if x___init_tp(tls, x___copy_tls(tls, mem)) < int32(0) {
		_a_crash(tls)
	}
}

var ___func__ = [16]int8{'s', 't', 'a', 't', 'i', 'c', '_', 'i', 'n', 'i', 't', '_', 't', 'l', 's'}

const m_AT_EGID = 14
const m_AT_EUID = 12
const m_AT_EXECFN = 31
const m_AT_GID = 13
const m_AT_HWCAP = 16
const m_AT_PAGESZ = 6
const m_AT_RANDOM = 25
const m_AT_SECURE = 23
const m_AT_SYSINFO = 32
const m_AT_UID = 11
const m_AUX_CNT = 38
const m_O_LARGEFILE = 32768
const m_POLLNVAL = 32
const m_SYS_open = 2

type Tnfds_t = uint64

type Tpollfd = struct {
	Ffd      int32
	Fevents  int16
	Frevents int16
}

func _dummy(tls *TLS) {
}

func _dummy1(tls *TLS, p uintptr) {
}

func x___init_libc(tls *TLS, envp uintptr, pn uintptr) {
	bp := tls.Alloc(328) /* tlsAllocs 328 maxValist 0 */
	defer tls.Free(328)
	var auxv uintptr
	var i Tsize_t
	var r int32
	var _ /* aux at bp+0 */ [38]Tsize_t
	var _ /* pfd at bp+304 */ [3]Tpollfd
	var v1 uintptr
	var v3 uintptr
	*(*[38]Tsize_t)(unsafe.Pointer(bp)) = [38]Tsize_t{}
	x___environ = envp
	for i = uint64(0); *(*uintptr)(unsafe.Pointer(envp + uintptr(i)*8)) != 0; i++ {
	}
	v1 = envp + uintptr(i)*8 + UintptrFromInt32(1)*8
	auxv = v1
	x___libc.Fauxv = v1
	for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8)) != 0; {
		if *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8)) < uint64(m_AUX_CNT) {
			(*(*[38]Tsize_t)(unsafe.Pointer(bp)))[*(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8))] = *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i+Uint64FromInt32(1))*8))
		}
		goto _2
	_2:
		i = i + Uint64FromInt32(2)
	}
	x___hwcap = (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_HWCAP)]
	if (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_SYSINFO)] != 0 {
		x___sysinfo = (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_SYSINFO)]
	}
	x___libc.Fpage_size = (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_PAGESZ)]
	if !(pn != 0) {
		pn = uintptr((*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_EXECFN)])
	}
	if !(pn != 0) {
		pn = ts
	}
	v3 = pn
	x___progname_full = v3
	x___progname = v3
	for i = uint64(0); *(*int8)(unsafe.Pointer(pn + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(pn + uintptr(i)))) == int32('/') {
			x___progname = pn + uintptr(i) + uintptr(1)
		}
	}
	x___init_tls(tls, bp)
	x___init_ssp(tls, uintptr((*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_RANDOM)]))
	if (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_UID)] == (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_EUID)] && (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_GID)] == (*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_EGID)] && !((*(*[38]Tsize_t)(unsafe.Pointer(bp)))[int32(m_AT_SECURE)] != 0) {
		return
	}
	*(*[3]Tpollfd)(unsafe.Pointer(bp + 304)) = [3]Tpollfd{
		0: {},
		1: {Ffd: int32(1)},
		2: {Ffd: int32(2)}}
	r = int32(___syscall3(tls, int64(7), int64(bp+304), int64(Int32FromInt32(3)), int64(Int32FromInt32(0))))
	if r < int32(0) {
		_a_crash(tls)
	}
	for i = uint64(0); i < uint64(3); i++ {
		if int32((*(*[3]Tpollfd)(unsafe.Pointer(bp + 304)))[i].Frevents)&int32(m_POLLNVAL) != 0 {
			if ___syscall2(tls, int64(m_SYS_open), int64(ts+230), int64(Int32FromInt32(02)|Int32FromInt32(m_O_LARGEFILE))) < int64(0) {
				_a_crash(tls)
			}
		}
	}
	x___libc.Fsecure = int8(1)
}

func _libc_start_init(tls *TLS) {
	var a Tuintptr_t
	_dummy(tls)
	a = Tuintptr_t(uintptr(unsafe.Pointer(&x___init_array_start)))
	for a < Tuintptr_t(uintptr(unsafe.Pointer(&x___init_array_start))) {
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(uintptr(a)))})))(tls)
		goto _1
	_1:
		a = a + Uint64FromInt64(8)
	}
}

func x___libc_start_main(tls *TLS, main1 uintptr, argc int32, argv uintptr, init_dummy uintptr, fini_dummy uintptr, ldso_dummy uintptr) (r int32) {
	var envp uintptr
	var stage2 uintptr
	envp = argv + uintptr(argc)*8 + uintptr(1)*8
	/* External linkage, and explicit noinline attribute if available,
	 * are used to prevent the stack frame used during init from
	 * persisting for the entire process lifetime. */
	x___init_libc(tls, envp, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)))
	/* Barrier against hoisting application code or anything using ssp
	 * or thread pointer prior to its initialization above. */
	stage2 = __ccgo_fp(_libc_start_main_stage2)
	// __asm__ ( "" : "+r"(stage2) : : "memory" );
	___assert_fail(tls, ts+240, ts+275, 85, ts+295)
	return (*(*func(*TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{stage2})))(tls, main1, argc, argv)
}

func _libc_start_main_stage2(tls *TLS, main1 uintptr, argc int32, argv uintptr) (r int32) {
	var envp uintptr
	envp = argv + uintptr(argc)*8 + uintptr(1)*8
	x___libc_start_init(tls)
	/* Pass control to the application */
	x_exit(tls, (*(*func(*TLS, int32, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{main1})))(tls, argc, argv, envp))
	return int32(0)
}

func x___reset_tls(tls *TLS) {
	var i Tsize_t
	var mem uintptr
	var n Tsize_t
	var p uintptr
	var self Tpthread_t
	self = ___get_tp(tls)
	n = *(*Tuintptr_t)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Fdtv + UintptrFromInt32(0)*8))
	if n != 0 {
		p = x___libc.Ftls_head
		i = Uint64FromInt32(1)
		for i <= n {
			mem = uintptr(*(*Tuintptr_t)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Fdtv + uintptr(i)*8)) - Uint64FromInt32(m_DTP_OFFSET))
			x_memcpy(tls, mem, (*Ttls_module)(unsafe.Pointer(p)).Fimage, (*Ttls_module)(unsafe.Pointer(p)).Flen1)
			x_memset(tls, mem+uintptr((*Ttls_module)(unsafe.Pointer(p)).Flen1), int32(0), (*Ttls_module)(unsafe.Pointer(p)).Fsize-(*Ttls_module)(unsafe.Pointer(p)).Flen1)
			goto _1
		_1:
			i++
			p = (*Ttls_module)(unsafe.Pointer(p)).Fnext
		}
	}
}

func x___init_ssp(tls *TLS, entropy uintptr) {
	if entropy != 0 {
		x_memcpy(tls, uintptr(unsafe.Pointer(&x___stack_chk_guard)), entropy, uint64(8))
	} else {
		x___stack_chk_guard = Tuintptr_t(uintptr(unsafe.Pointer(&x___stack_chk_guard))) * uint64(1103515245)
	}
	/* Sacrifice 8 bits of entropy on 64bit to prevent leaking/
	 * overwriting the canary via string-manipulation functions.
	 * The NULL byte is on the second byte so that off-by-ones can
	 * still be detected. Endianness is taken care of
	 * automatically. */
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stack_chk_guard)) + UintptrFromInt32(1))) = int8(0)
	(*T__pthread)(unsafe.Pointer(___get_tp(tls))).Fcanary = x___stack_chk_guard
}

func x___stack_chk_fail(tls *TLS) {
	_a_crash(tls)
}

func _dummy2(tls *TLS, old uintptr, new1 uintptr) {
}

func x_clearenv(tls *TLS) (r int32) {
	var e uintptr
	var v1 uintptr
	e = x___environ
	x___environ = uintptr(0)
	if e != 0 {
		for *(*uintptr)(unsafe.Pointer(e)) != 0 {
			v1 = e
			e += 8
			x___env_rm_add(tls, *(*uintptr)(unsafe.Pointer(v1)), uintptr(0))
		}
	}
	return int32(0)
}

func x_getenv(tls *TLS, name uintptr) (r uintptr) {
	var e uintptr
	var l Tsize_t
	l = uint64(int64(x___strchrnul(tls, name, int32('='))) - int64(name))
	if l != 0 && !(*(*int8)(unsafe.Pointer(name + uintptr(l))) != 0) && x___environ != 0 {
		e = x___environ
		for ; *(*uintptr)(unsafe.Pointer(e)) != 0; e += 8 {
			if !(x_strncmp(tls, name, *(*uintptr)(unsafe.Pointer(e)), l) != 0) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(e)) + uintptr(l)))) == int32('=') {
				return *(*uintptr)(unsafe.Pointer(e)) + uintptr(l) + uintptr(1)
			}
		}
	}
	return uintptr(0)
}

func _dummy3(tls *TLS, old uintptr, new1 uintptr) {
}

func x___putenv(tls *TLS, s uintptr, l Tsize_t, r uintptr) (r1 int32) {
	var e uintptr
	var i Tsize_t
	var newenv uintptr
	var tmp uintptr
	var v2 uintptr
	i = uint64(0)
	if x___environ != 0 {
		e = x___environ
		for *(*uintptr)(unsafe.Pointer(e)) != 0 {
			if !(x_strncmp(tls, s, *(*uintptr)(unsafe.Pointer(e)), l+uint64(1)) != 0) {
				tmp = *(*uintptr)(unsafe.Pointer(e))
				*(*uintptr)(unsafe.Pointer(e)) = s
				x___env_rm_add(tls, tmp, r)
				return int32(0)
			}
			goto _1
		_1:
			e += 8
			i++
		}
	}
	if x___environ == _oldenv {
		newenv = x_realloc(tls, _oldenv, uint64(8)*(i+uint64(2)))
		if !(newenv != 0) {
			goto oom
		}
	} else {
		newenv = _default_malloc(tls, uint64(8)*(i+uint64(2)))
		if !(newenv != 0) {
			goto oom
		}
		if i != 0 {
			x_memcpy(tls, newenv, x___environ, uint64(8)*i)
		}
		x_free(tls, _oldenv)
	}
	*(*uintptr)(unsafe.Pointer(newenv + uintptr(i)*8)) = s
	*(*uintptr)(unsafe.Pointer(newenv + uintptr(i+Uint64FromInt32(1))*8)) = uintptr(0)
	v2 = newenv
	_oldenv = v2
	x___environ = v2
	if r != 0 {
		x___env_rm_add(tls, uintptr(0), r)
	}
	return int32(0)
oom:
	x_free(tls, r)
	return -int32(1)
}

var _oldenv uintptr

func x_putenv(tls *TLS, s uintptr) (r int32) {
	var l Tsize_t
	l = uint64(int64(x___strchrnul(tls, s, int32('='))) - int64(s))
	if !(l != 0) || !(*(*int8)(unsafe.Pointer(s + uintptr(l))) != 0) {
		return x_unsetenv(tls, s)
	}
	return x___putenv(tls, s, l, uintptr(0))
}

type Tcookie_io_functions_t = struct {
	Fread   uintptr
	Fwrite  uintptr
	Fseek   uintptr
	Fclose1 uintptr
}

type T_IO_cookie_io_functions_t = Tcookie_io_functions_t

func x_secure_getenv(tls *TLS, name uintptr) (r uintptr) {
	var v1 uintptr
	if x___libc.Fsecure != 0 {
		v1 = UintptrFromInt32(0)
	} else {
		v1 = x_getenv(tls, name)
	}
	return v1
}

func x___env_rm_add(tls *TLS, old uintptr, new1 uintptr) {
	var i Tsize_t
	var t uintptr
	var v1 uintptr
	var v2 Tsize_t
	i = uint64(0)
	for ; i < _env_alloced_n; i++ {
		if *(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) == old {
			*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) = new1
			x_free(tls, old)
			return
		} else {
			if !(*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) != 0) && new1 != 0 {
				*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) = new1
				new1 = uintptr(0)
			}
		}
	}
	if !(new1 != 0) {
		return
	}
	t = x_realloc(tls, _env_alloced, uint64(8)*(_env_alloced_n+uint64(1)))
	if !(t != 0) {
		return
	}
	v1 = t
	_env_alloced = v1
	v2 = _env_alloced_n
	_env_alloced_n++
	*(*uintptr)(unsafe.Pointer(v1 + uintptr(v2)*8)) = new1
}

var _env_alloced uintptr

var _env_alloced_n Tsize_t

func x_setenv(tls *TLS, var1 uintptr, value uintptr, overwrite int32) (r int32) {
	var l1 Tsize_t
	var l2 Tsize_t
	var s uintptr
	var v1 Tsize_t
	var v2 bool
	if v2 = !(var1 != 0); !v2 {
		v1 = uint64(int64(x___strchrnul(tls, var1, int32('='))) - int64(var1))
		l1 = v1
	}
	if v2 || !(v1 != 0) || *(*int8)(unsafe.Pointer(var1 + uintptr(l1))) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	if !(overwrite != 0) && x_getenv(tls, var1) != 0 {
		return int32(0)
	}
	l2 = x_strlen(tls, value)
	s = _default_malloc(tls, l1+l2+uint64(2))
	if !(s != 0) {
		return -int32(1)
	}
	x_memcpy(tls, s, var1, l1)
	*(*int8)(unsafe.Pointer(s + uintptr(l1))) = int8('=')
	x_memcpy(tls, s+uintptr(l1)+uintptr(1), value, l2+uint64(1))
	return x___putenv(tls, s, l1, s)
}

func _dummy4(tls *TLS, old uintptr, new1 uintptr) {
}

func x_unsetenv(tls *TLS, name uintptr) (r int32) {
	var e uintptr
	var eo uintptr
	var l Tsize_t
	var v1 uintptr
	l = uint64(int64(x___strchrnul(tls, name, int32('='))) - int64(name))
	if !(l != 0) || *(*int8)(unsafe.Pointer(name + uintptr(l))) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	if x___environ != 0 {
		e = x___environ
		eo = e
		for ; *(*uintptr)(unsafe.Pointer(e)) != 0; e += 8 {
			if !(x_strncmp(tls, name, *(*uintptr)(unsafe.Pointer(e)), l) != 0) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(e)) + uintptr(l)))) == int32('=') {
				x___env_rm_add(tls, *(*uintptr)(unsafe.Pointer(e)), uintptr(0))
			} else {
				if eo != e {
					v1 = eo
					eo += 8
					*(*uintptr)(unsafe.Pointer(v1)) = *(*uintptr)(unsafe.Pointer(e))
				} else {
					eo += 8
				}
			}
		}
		if eo != e {
			*(*uintptr)(unsafe.Pointer(eo)) = uintptr(0)
		}
	}
	return int32(0)
}

func x___errno_location(tls *TLS) (r uintptr) {
	return ___get_tp(tls) + 52
}

/* mips has one error code outside of the 8-bit range due to a
 * historical typo, so we just remap it. */

type Terrmsgstr_t = struct {
	Fstr0               [21]int8
	FstrEILSEQ          [22]int8
	FstrEDOM            [13]int8
	FstrERANGE          [25]int8
	FstrENOTTY          [10]int8
	FstrEACCES          [18]int8
	FstrEPERM           [24]int8
	FstrENOENT          [26]int8
	FstrESRCH           [16]int8
	FstrEEXIST          [12]int8
	FstrEOVERFLOW       [30]int8
	FstrENOSPC          [24]int8
	FstrENOMEM          [14]int8
	FstrEBUSY           [14]int8
	FstrEINTR           [24]int8
	FstrEAGAIN          [33]int8
	FstrESPIPE          [13]int8
	FstrEXDEV           [18]int8
	FstrEROFS           [22]int8
	FstrENOTEMPTY       [20]int8
	FstrECONNRESET      [25]int8
	FstrETIMEDOUT       [20]int8
	FstrECONNREFUSED    [19]int8
	FstrEHOSTDOWN       [13]int8
	FstrEHOSTUNREACH    [20]int8
	FstrEADDRINUSE      [15]int8
	FstrEPIPE           [12]int8
	FstrEIO             [10]int8
	FstrENXIO           [26]int8
	FstrENOTBLK         [22]int8
	FstrENODEV          [15]int8
	FstrENOTDIR         [16]int8
	FstrEISDIR          [15]int8
	FstrETXTBSY         [15]int8
	FstrENOEXEC         [18]int8
	FstrEINVAL          [17]int8
	FstrE2BIG           [23]int8
	FstrELOOP           [19]int8
	FstrENAMETOOLONG    [18]int8
	FstrENFILE          [30]int8
	FstrEMFILE          [30]int8
	FstrEBADF           [20]int8
	FstrECHILD          [17]int8
	FstrEFAULT          [12]int8
	FstrEFBIG           [15]int8
	FstrEMLINK          [15]int8
	FstrENOLCK          [19]int8
	FstrEDEADLK         [30]int8
	FstrENOTRECOVERABLE [22]int8
	FstrEOWNERDEAD      [20]int8
	FstrECANCELED       [19]int8
	FstrENOSYS          [25]int8
	FstrENOMSG          [27]int8
	FstrEIDRM           [19]int8
	FstrENOSTR          [20]int8
	FstrENODATA         [18]int8
	FstrETIME           [15]int8
	FstrENOSR           [25]int8
	FstrENOLINK         [22]int8
	FstrEPROTO          [15]int8
	FstrEBADMSG         [12]int8
	FstrEBADFD          [29]int8
	FstrENOTSOCK        [13]int8
	FstrEDESTADDRREQ    [29]int8
	FstrEMSGSIZE        [18]int8
	FstrEPROTOTYPE      [31]int8
	FstrENOPROTOOPT     [23]int8
	FstrEPROTONOSUPPORT [23]int8
	FstrESOCKTNOSUPPORT [26]int8
	FstrENOTSUP         [14]int8
	FstrEPFNOSUPPORT    [30]int8
	FstrEAFNOSUPPORT    [41]int8
	FstrEADDRNOTAVAIL   [22]int8
	FstrENETDOWN        [16]int8
	FstrENETUNREACH     [20]int8
	FstrENETRESET       [28]int8
	FstrECONNABORTED    [19]int8
	FstrENOBUFS         [26]int8
	FstrEISCONN         [20]int8
	FstrENOTCONN        [21]int8
	FstrESHUTDOWN       [34]int8
	FstrEALREADY        [30]int8
	FstrEINPROGRESS     [22]int8
	FstrESTALE          [18]int8
	FstrEREMOTEIO       [17]int8
	FstrEDQUOT          [15]int8
	FstrENOMEDIUM       [16]int8
	FstrEMEDIUMTYPE     [18]int8
	FstrEMULTIHOP       [19]int8
	FstrENOKEY          [27]int8
	FstrEKEYEXPIRED     [16]int8
	FstrEKEYREVOKED     [21]int8
	FstrEKEYREJECTED    [28]int8
}

var _errmsgstr = Terrmsgstr_t{Fstr0: [21]int8{'N', 'o', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n'}, FstrEILSEQ: [22]int8{'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'b', 'y', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'}, FstrEDOM: [13]int8{'D', 'o', 'm', 'a', 'i', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}, FstrERANGE: [25]int8{'R', 'e', 's', 'u', 'l', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'p', 'r', 'e', 's', 'e', 'n', 't', 'a', 'b', 'l', 'e'}, FstrENOTTY: [10]int8{'N', 'o', 't', ' ', 'a', ' ', 't', 't', 'y'}, FstrEACCES: [18]int8{'P', 'e', 'r', 'm', 'i', 's', 's', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd'}, FstrEPERM: [24]int8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'p', 'e', 'r', 'm', 'i', 't', 't', 'e', 'd'}, FstrENOENT: [26]int8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'f', 'i', 'l', 'e', ' ', 'o', 'r', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'}, FstrESRCH: [16]int8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's'}, FstrEEXIST: [12]int8{'F', 'i', 'l', 'e', ' ', 'e', 'x', 'i', 's', 't', 's'}, FstrEOVERFLOW: [30]int8{'V', 'a', 'l', 'u', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', ' ', 'f', 'o', 'r', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e'}, FstrENOSPC: [24]int8{'N', 'o', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'o', 'n', ' ', 'd', 'e', 'v', 'i', 'c', 'e'}, FstrENOMEM: [14]int8{'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y'}, FstrEBUSY: [14]int8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'b', 'u', 's', 'y'}, FstrEINTR: [24]int8{'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 'e', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l'}, FstrEAGAIN: [33]int8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 't', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'i', 'l', 'y', ' ', 'u', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrESPIPE: [13]int8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'e', 'e', 'k'}, FstrEXDEV: [18]int8{'C', 'r', 'o', 's', 's', '-', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'l', 'i', 'n', 'k'}, FstrEROFS: [22]int8{'R', 'e', 'a', 'd', '-', 'o', 'n', 'l', 'y', ' ', 'f', 'i', 'l', 'e', ' ', 's', 'y', 's', 't', 'e', 'm'}, FstrENOTEMPTY: [20]int8{'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y'}, FstrECONNRESET: [25]int8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 's', 'e', 't', ' ', 'b', 'y', ' ', 'p', 'e', 'e', 'r'}, FstrETIMEDOUT: [20]int8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 't', 'i', 'm', 'e', 'd', ' ', 'o', 'u', 't'}, FstrECONNREFUSED: [19]int8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 'f', 'u', 's', 'e', 'd'}, FstrEHOSTDOWN: [13]int8{'H', 'o', 's', 't', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n'}, FstrEHOSTUNREACH: [20]int8{'H', 'o', 's', 't', ' ', 'i', 's', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e'}, FstrEADDRINUSE: [15]int8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'i', 'n', ' ', 'u', 's', 'e'}, FstrEPIPE: [12]int8{'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e'}, FstrEIO: [10]int8{'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r'}, FstrENXIO: [26]int8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'o', 'r', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's'}, FstrENOTBLK: [22]int8{'B', 'l', 'o', 'c', 'k', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'}, FstrENODEV: [15]int8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e'}, FstrENOTDIR: [16]int8{'N', 'o', 't', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'}, FstrEISDIR: [15]int8{'I', 's', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'}, FstrETXTBSY: [15]int8{'T', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 'b', 'u', 's', 'y'}, FstrENOEXEC: [18]int8{'E', 'x', 'e', 'c', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'e', 'r', 'r', 'o', 'r'}, FstrEINVAL: [17]int8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't'}, FstrE2BIG: [23]int8{'A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'l', 'i', 's', 't', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g'}, FstrELOOP: [19]int8{'S', 'y', 'm', 'b', 'o', 'l', 'i', 'c', ' ', 'l', 'i', 'n', 'k', ' ', 'l', 'o', 'o', 'p'}, FstrENAMETOOLONG: [18]int8{'F', 'i', 'l', 'e', 'n', 'a', 'm', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g'}, FstrENFILE: [30]int8{'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', 's', ' ', 'i', 'n', ' ', 's', 'y', 's', 't', 'e', 'm'}, FstrEMFILE: [30]int8{'N', 'o', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrEBADF: [20]int8{'B', 'a', 'd', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r'}, FstrECHILD: [17]int8{'N', 'o', ' ', 'c', 'h', 'i', 'l', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's'}, FstrEFAULT: [12]int8{'B', 'a', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's'}, FstrEFBIG: [15]int8{'F', 'i', 'l', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e'}, FstrEMLINK: [15]int8{'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'l', 'i', 'n', 'k', 's'}, FstrENOLCK: [19]int8{'N', 'o', ' ', 'l', 'o', 'c', 'k', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrEDEADLK: [30]int8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'd', 'e', 'a', 'd', 'l', 'o', 'c', 'k', ' ', 'w', 'o', 'u', 'l', 'd', ' ', 'o', 'c', 'c', 'u', 'r'}, FstrENOTRECOVERABLE: [22]int8{'S', 't', 'a', 't', 'e', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e'}, FstrEOWNERDEAD: [20]int8{'P', 'r', 'e', 'v', 'i', 'o', 'u', 's', ' ', 'o', 'w', 'n', 'e', 'r', ' ', 'd', 'i', 'e', 'd'}, FstrECANCELED: [19]int8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'e', 'd'}, FstrENOSYS: [25]int8{'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'i', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'e', 'd'}, FstrENOMSG: [27]int8{'N', 'o', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'o', 'f', ' ', 'd', 'e', 's', 'i', 'r', 'e', 'd', ' ', 't', 'y', 'p', 'e'}, FstrEIDRM: [19]int8{'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', ' ', 'r', 'e', 'm', 'o', 'v', 'e', 'd'}, FstrENOSTR: [20]int8{'D', 'e', 'v', 'i', 'c', 'e', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 't', 'r', 'e', 'a', 'm'}, FstrENODATA: [18]int8{'N', 'o', ' ', 'd', 'a', 't', 'a', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrETIME: [15]int8{'D', 'e', 'v', 'i', 'c', 'e', ' ', 't', 'i', 'm', 'e', 'o', 'u', 't'}, FstrENOSR: [25]int8{'O', 'u', 't', ' ', 'o', 'f', ' ', 's', 't', 'r', 'e', 'a', 'm', 's', ' ', 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e', 's'}, FstrENOLINK: [22]int8{'L', 'i', 'n', 'k', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 's', 'e', 'v', 'e', 'r', 'e', 'd'}, FstrEPROTO: [15]int8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'e', 'r', 'r', 'o', 'r'}, FstrEBADMSG: [12]int8{'B', 'a', 'd', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e'}, FstrEBADFD: [29]int8{'F', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', ' ', 'i', 'n', ' ', 'b', 'a', 'd', ' ', 's', 't', 'a', 't', 'e'}, FstrENOTSOCK: [13]int8{'N', 'o', 't', ' ', 'a', ' ', 's', 'o', 'c', 'k', 'e', 't'}, FstrEDESTADDRREQ: [29]int8{'D', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'}, FstrEMSGSIZE: [18]int8{'M', 'e', 's', 's', 'a', 'g', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e'}, FstrEPROTOTYPE: [31]int8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'w', 'r', 'o', 'n', 'g', ' ', 't', 'y', 'p', 'e', ' ', 'f', 'o', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't'}, FstrENOPROTOOPT: [23]int8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrEPROTONOSUPPORT: [23]int8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'}, FstrESOCKTNOSUPPORT: [26]int8{'S', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'}, FstrENOTSUP: [14]int8{'N', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'}, FstrEPFNOSUPPORT: [30]int8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'}, FstrEAFNOSUPPORT: [41]int8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l'}, FstrEADDRNOTAVAIL: [22]int8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrENETDOWN: [16]int8{'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n'}, FstrENETUNREACH: [20]int8{'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e'}, FstrENETRESET: [28]int8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 's', 'e', 't', ' ', 'b', 'y', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k'}, FstrECONNABORTED: [19]int8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'a', 'b', 'o', 'r', 't', 'e', 'd'}, FstrENOBUFS: [26]int8{'N', 'o', ' ', 'b', 'u', 'f', 'f', 'e', 'r', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrEISCONN: [20]int8{'S', 'o', 'c', 'k', 'e', 't', ' ', 'i', 's', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd'}, FstrENOTCONN: [21]int8{'S', 'o', 'c', 'k', 'e', 't', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd'}, FstrESHUTDOWN: [34]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 's', 'e', 'n', 'd', ' ', 'a', 'f', 't', 'e', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n'}, FstrEALREADY: [30]int8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's'}, FstrEINPROGRESS: [22]int8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's'}, FstrESTALE: [18]int8{'S', 't', 'a', 'l', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 'h', 'a', 'n', 'd', 'l', 'e'}, FstrEREMOTEIO: [17]int8{'R', 'e', 'm', 'o', 't', 'e', ' ', 'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r'}, FstrEDQUOT: [15]int8{'Q', 'u', 'o', 't', 'a', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd'}, FstrENOMEDIUM: [16]int8{'N', 'o', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 'f', 'o', 'u', 'n', 'd'}, FstrEMEDIUMTYPE: [18]int8{'W', 'r', 'o', 'n', 'g', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 't', 'y', 'p', 'e'}, FstrEMULTIHOP: [19]int8{'M', 'u', 'l', 't', 'i', 'h', 'o', 'p', ' ', 'a', 't', 't', 'e', 'm', 'p', 't', 'e', 'd'}, FstrENOKEY: [27]int8{'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'k', 'e', 'y', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'}, FstrEKEYEXPIRED: [16]int8{'K', 'e', 'y', ' ', 'h', 'a', 's', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd'}, FstrEKEYREVOKED: [21]int8{'K', 'e', 'y', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'r', 'e', 'v', 'o', 'k', 'e', 'd'}, FstrEKEYREJECTED: [28]int8{'K', 'e', 'y', ' ', 'w', 'a', 's', ' ', 'r', 'e', 'j', 'e', 'c', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e'}}

var _errmsgidx = [132]uint16{
	0:   uint16(uint64(UintptrFromInt32(0))),
	1:   uint16(uint64(UintptrFromInt32(0) + 109)),
	2:   uint16(uint64(UintptrFromInt32(0) + 133)),
	3:   uint16(uint64(UintptrFromInt32(0) + 159)),
	4:   uint16(uint64(UintptrFromInt32(0) + 269)),
	5:   uint16(uint64(UintptrFromInt32(0) + 523)),
	6:   uint16(uint64(UintptrFromInt32(0) + 533)),
	7:   uint16(uint64(UintptrFromInt32(0) + 677)),
	8:   uint16(uint64(UintptrFromInt32(0) + 642)),
	9:   uint16(uint64(UintptrFromInt32(0) + 797)),
	10:  uint16(uint64(UintptrFromInt32(0) + 817)),
	11:  uint16(uint64(UintptrFromInt32(0) + 293)),
	12:  uint16(uint64(UintptrFromInt32(0) + 241)),
	13:  uint16(uint64(UintptrFromInt32(0) + 91)),
	14:  uint16(uint64(UintptrFromInt32(0) + 834)),
	15:  uint16(uint64(UintptrFromInt32(0) + 559)),
	16:  uint16(uint64(UintptrFromInt32(0) + 255)),
	17:  uint16(uint64(UintptrFromInt32(0) + 175)),
	18:  uint16(uint64(UintptrFromInt32(0) + 339)),
	19:  uint16(uint64(UintptrFromInt32(0) + 581)),
	20:  uint16(uint64(UintptrFromInt32(0) + 596)),
	21:  uint16(uint64(UintptrFromInt32(0) + 612)),
	22:  uint16(uint64(UintptrFromInt32(0) + 660)),
	23:  uint16(uint64(UintptrFromInt32(0) + 737)),
	24:  uint16(uint64(UintptrFromInt32(0) + 767)),
	25:  uint16(uint64(UintptrFromInt32(0) + 81)),
	26:  uint16(uint64(UintptrFromInt32(0) + 627)),
	27:  uint16(uint64(UintptrFromInt32(0) + 846)),
	28:  uint16(uint64(UintptrFromInt32(0) + 217)),
	29:  uint16(uint64(UintptrFromInt32(0) + 326)),
	30:  uint16(uint64(UintptrFromInt32(0) + 357)),
	31:  uint16(uint64(UintptrFromInt32(0) + 861)),
	32:  uint16(uint64(UintptrFromInt32(0) + 511)),
	33:  uint16(uint64(UintptrFromInt32(0) + 43)),
	34:  uint16(uint64(UintptrFromInt32(0) + 56)),
	35:  uint16(uint64(UintptrFromInt32(0) + 895)),
	36:  uint16(uint64(UintptrFromInt32(0) + 719)),
	37:  uint16(uint64(UintptrFromInt32(0) + 876)),
	38:  uint16(uint64(UintptrFromInt32(0) + 986)),
	39:  uint16(uint64(UintptrFromInt32(0) + 379)),
	40:  uint16(uint64(UintptrFromInt32(0) + 700)),
	42:  uint16(uint64(UintptrFromInt32(0) + 1011)),
	43:  uint16(uint64(UintptrFromInt32(0) + 1038)),
	60:  uint16(uint64(UintptrFromInt32(0) + 1057)),
	61:  uint16(uint64(UintptrFromInt32(0) + 1077)),
	62:  uint16(uint64(UintptrFromInt32(0) + 1095)),
	63:  uint16(uint64(UintptrFromInt32(0) + 1110)),
	67:  uint16(uint64(UintptrFromInt32(0) + 1135)),
	71:  uint16(uint64(UintptrFromInt32(0) + 1157)),
	72:  uint16(uint64(UintptrFromInt32(0) + 1803)),
	74:  uint16(uint64(UintptrFromInt32(0) + 1172)),
	75:  uint16(uint64(UintptrFromInt32(0) + 187)),
	77:  uint16(uint64(UintptrFromInt32(0) + 1184)),
	84:  uint16(uint64(UintptrFromInt32(0) + 21)),
	88:  uint16(uint64(UintptrFromInt32(0) + 1213)),
	89:  uint16(uint64(UintptrFromInt32(0) + 1226)),
	90:  uint16(uint64(UintptrFromInt32(0) + 1255)),
	91:  uint16(uint64(UintptrFromInt32(0) + 1273)),
	92:  uint16(uint64(UintptrFromInt32(0) + 1304)),
	93:  uint16(uint64(UintptrFromInt32(0) + 1327)),
	94:  uint16(uint64(UintptrFromInt32(0) + 1350)),
	95:  uint16(uint64(UintptrFromInt32(0) + 1376)),
	96:  uint16(uint64(UintptrFromInt32(0) + 1390)),
	97:  uint16(uint64(UintptrFromInt32(0) + 1420)),
	98:  uint16(uint64(UintptrFromInt32(0) + 496)),
	99:  uint16(uint64(UintptrFromInt32(0) + 1461)),
	100: uint16(uint64(UintptrFromInt32(0) + 1483)),
	101: uint16(uint64(UintptrFromInt32(0) + 1499)),
	102: uint16(uint64(UintptrFromInt32(0) + 1519)),
	103: uint16(uint64(UintptrFromInt32(0) + 1547)),
	104: uint16(uint64(UintptrFromInt32(0) + 399)),
	105: uint16(uint64(UintptrFromInt32(0) + 1566)),
	106: uint16(uint64(UintptrFromInt32(0) + 1592)),
	107: uint16(uint64(UintptrFromInt32(0) + 1612)),
	108: uint16(uint64(UintptrFromInt32(0) + 1633)),
	110: uint16(uint64(UintptrFromInt32(0) + 424)),
	111: uint16(uint64(UintptrFromInt32(0) + 444)),
	112: uint16(uint64(UintptrFromInt32(0) + 463)),
	113: uint16(uint64(UintptrFromInt32(0) + 476)),
	114: uint16(uint64(UintptrFromInt32(0) + 1667)),
	115: uint16(uint64(UintptrFromInt32(0) + 1697)),
	116: uint16(uint64(UintptrFromInt32(0) + 1719)),
	121: uint16(uint64(UintptrFromInt32(0) + 1737)),
	122: uint16(uint64(UintptrFromInt32(0) + 1754)),
	123: uint16(uint64(UintptrFromInt32(0) + 1769)),
	124: uint16(uint64(UintptrFromInt32(0) + 1785)),
	125: uint16(uint64(UintptrFromInt32(0) + 967)),
	126: uint16(uint64(UintptrFromInt32(0) + 1822)),
	127: uint16(uint64(UintptrFromInt32(0) + 1849)),
	128: uint16(uint64(UintptrFromInt32(0) + 1865)),
	129: uint16(uint64(UintptrFromInt32(0) + 1886)),
	130: uint16(uint64(UintptrFromInt32(0) + 947)),
	131: uint16(uint64(UintptrFromInt32(0) + 925))}

func x___strerror_l(tls *TLS, e int32, loc Tlocale_t) (r uintptr) {
	var s uintptr
	if uint64(e) >= Uint64FromInt64(264)/Uint64FromInt64(2) {
		e = int32(0)
	}
	s = uintptr(unsafe.Pointer(&_errmsgstr)) + uintptr(_errmsgidx[e])
	return x___lctrans(tls, s, *(*uintptr)(unsafe.Pointer(loc + uintptr(Int32FromInt32(5))*8)))
}

func x_strerror(tls *TLS, e int32) (r uintptr) {
	return x___strerror_l(tls, e, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func x__Exit(tls *TLS, ec int32) {
	___syscall1(tls, int64(231), int64(ec))
	for {
		___syscall1(tls, int64(60), int64(ec))
	}
}

const m_SIGABRT = 6
const m_SIGKILL = 9

type Tk_sigaction = struct {
	Fhandler  uintptr
	Fflags    uint64
	Frestorer uintptr
	Fmask     [2]uint32
}

func x_abort(tls *TLS) {
	x_raise(tls, int32(m_SIGABRT))
	/* If there was a SIGABRT handler installed and it returned, or if
	 * SIGABRT was blocked or ignored, take an AS-safe lock to prevent
	 * sigaction from installing a new SIGABRT handler, uninstall any
	 * handler that may be present, and re-raise the signal to generate
	 * the default action of abnormal termination. */
	x___block_all_sigs(tls, uintptr(0))
	x___lock(tls, uintptr(unsafe.Pointer(&x___abort_lock)))
	___syscall4(tls, int64(13), int64(Int32FromInt32(6)), int64(uintptr(unsafe.Pointer(&Tk_sigaction{}))), int64(Int32FromInt32(0)), int64(Int32FromInt32(65)/Int32FromInt32(8)))
	___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid), int64(Int32FromInt32(6)))
	___syscall4(tls, int64(14), int64(Int32FromInt32(1)), int64(uintptr(unsafe.Pointer(&[1]int64{
		0: int64(Uint64FromUint64(1) << (Int32FromInt32(6) - Int32FromInt32(1)))}))), int64(Int32FromInt32(0)), int64(Int32FromInt32(65)/Int32FromInt32(8)))
	/* Beyond this point should be unreachable. */
	_a_crash(tls)
	x_raise(tls, int32(m_SIGKILL))
	x__Exit(tls, int32(127))
}

const m_COUNT = 32

var _funcs [32]uintptr
var _count int32
var _lock [1]int32

func x___funcs_on_quick_exit(tls *TLS) {
	var func1 uintptr
	var v1 int32
	x___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	for _count > int32(0) {
		_count--
		v1 = _count
		func1 = _funcs[v1]
		x___unlock(tls, uintptr(unsafe.Pointer(&_lock)))
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{func1})))(tls)
		x___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	}
}

func x_at_quick_exit(tls *TLS, func1 uintptr) (r1 int32) {
	var r int32
	var v1 int32
	r = int32(0)
	x___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	if _count == int32(32) {
		r = -int32(1)
	} else {
		v1 = _count
		_count++
		_funcs[v1] = func1
	}
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock)))
	return r
}

/* Ensure that at least 32 atexit handlers can be registered without malloc */

type Tfl = struct {
	Fnext uintptr
	Ff    [32]uintptr
	Fa    [32]uintptr
}

var _builtin Tfl
var _head uintptr

var _slot int32
var _lock1 [1]int32

func x___funcs_on_exit(tls *TLS) {
	var arg uintptr
	var func1 uintptr
	var v2 int32
	x___lock(tls, uintptr(unsafe.Pointer(&_lock1)))
	for _head != 0 {
		for {
			v2 = _slot
			_slot--
			if !(v2 > int32(0)) {
				break
			}
			func1 = *(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(_slot)*8))
			arg = *(*uintptr)(unsafe.Pointer(_head + 264 + uintptr(_slot)*8))
			x___unlock(tls, uintptr(unsafe.Pointer(&_lock1)))
			(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{func1})))(tls, arg)
			x___lock(tls, uintptr(unsafe.Pointer(&_lock1)))
		}
		goto _1
	_1:
		_head = (*Tfl)(unsafe.Pointer(_head)).Fnext
		_slot = Int32FromInt32(m_COUNT)
	}
}

func x___cxa_finalize(tls *TLS, dso uintptr) {
}

func x___cxa_atexit(tls *TLS, func1 uintptr, arg uintptr, dso uintptr) (r int32) {
	var new_fl uintptr
	x___lock(tls, uintptr(unsafe.Pointer(&_lock1)))
	/* Defer initialization of head so it can be in BSS */
	if !(_head != 0) {
		_head = uintptr(unsafe.Pointer(&_builtin))
	}
	/* If the current function list is full, add a new one */
	if _slot == int32(m_COUNT) {
		new_fl = x___libc_calloc(tls, uint64(520), uint64(1))
		if !(new_fl != 0) {
			x___unlock(tls, uintptr(unsafe.Pointer(&_lock1)))
			return -int32(1)
		}
		(*Tfl)(unsafe.Pointer(new_fl)).Fnext = _head
		_head = new_fl
		_slot = int32(0)
	}
	/* Append function to the list. */
	*(*uintptr)(unsafe.Pointer(_head + 8 + uintptr(_slot)*8)) = func1
	*(*uintptr)(unsafe.Pointer(_head + 264 + uintptr(_slot)*8)) = arg
	_slot++
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock1)))
	return int32(0)
}

func _call(tls *TLS, p uintptr) {
	(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{uintptr(uint64(p))})))(tls)
}

func x_atexit(tls *TLS, func1 uintptr) (r int32) {
	return x___cxa_atexit(tls, __ccgo_fp(_call), uintptr(uint64(func1)), uintptr(0))
}

func _dummy5(tls *TLS) {
}

/* atexit.c and __stdio_exit.c override these. the latter is linked
 * as a consequence of linking either __toread.c or __towrite.c. */

func _libc_exit_fini(tls *TLS) {
	var a Tuintptr_t
	a = Tuintptr_t(uintptr(unsafe.Pointer(&x___fini_array_start)))
	for a > Tuintptr_t(uintptr(unsafe.Pointer(&x___fini_array_start))) {
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(uintptr(a - Uint64FromInt64(8))))})))(tls)
		goto _1
	_1:
		a = a - Uint64FromInt64(8)
	}
	_dummy5(tls)
}

func x_exit(tls *TLS, code int32) {
	x___funcs_on_exit(tls)
	x___libc_exit_fini(tls)
	x___stdio_exit(tls)
	x__Exit(tls, code)
}

func _dummy6(tls *TLS) {
}

func x_quick_exit(tls *TLS, code int32) {
	x___funcs_on_quick_exit(tls)
	x__Exit(tls, code)
}

const m_O_CREAT = 64
const m_O_TRUNC = 512
const m_O_WRONLY = 1

func x_creat(tls *TLS, filename uintptr, mode Tmode_t) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	return x_open(tls, filename, Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_WRONLY)|Int32FromInt32(m_O_TRUNC), VaList(bp+8, mode))
}

const m_F_DUPFD_CLOEXEC = 1030
const m_F_GETLK = 5
const m_F_GETOWN = 9
const m_F_GETOWN_EX = 16
const m_F_OWNER_PGRP = 2
const m_F_SETFL = 4
const m_F_SETLK = 6
const m_F_SETLKW = 7
const m_F_SETOWN_EX = 15

func x_fcntl(tls *TLS, fd int32, cmd int32, va uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ap Tva_list
	var arg uint64
	var ret int32
	var ret1 int32
	var _ /* ex at bp+0 */ Tf_owner_ex
	var v1 int32
	ap = va
	arg = VaUint64(&ap)
	_ = ap
	if cmd == int32(m_F_SETFL) {
		arg = arg | Uint64FromInt32(m_O_LARGEFILE)
	}
	if cmd == int32(m_F_SETLKW) {
		return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(72), int64(fd), int64(cmd), int64(uintptr(arg)), int64(0), int64(0), int64(0)))))
	}
	if cmd == int32(m_F_GETOWN) {
		ret = int32(___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(16)), int64(bp)))
		if ret == -int32(m_EINVAL) {
			return int32(___syscall3(tls, int64(72), int64(fd), int64(cmd), int64(uintptr(arg))))
		}
		if ret != 0 {
			return int32(x___syscall_ret(tls, uint64(ret)))
		}
		if (*(*Tf_owner_ex)(unsafe.Pointer(bp))).Ftype1 == int32(m_F_OWNER_PGRP) {
			v1 = -(*(*Tf_owner_ex)(unsafe.Pointer(bp))).Fpid
		} else {
			v1 = (*(*Tf_owner_ex)(unsafe.Pointer(bp))).Fpid
		}
		return v1
	}
	if cmd == int32(m_F_DUPFD_CLOEXEC) {
		ret1 = int32(___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(1030)), int64(arg)))
		if ret1 != -int32(m_EINVAL) {
			if ret1 >= int32(0) {
				___syscall3(tls, int64(72), int64(ret1), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
			}
			return int32(x___syscall_ret(tls, uint64(ret1)))
		}
		ret1 = int32(___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(1030)), int64(Int32FromInt32(0))))
		if ret1 != -int32(m_EINVAL) {
			if ret1 >= int32(0) {
				___syscall1(tls, int64(3), int64(ret1))
			}
			return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
		}
		ret1 = int32(___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(0)), int64(arg)))
		if ret1 >= int32(0) {
			___syscall3(tls, int64(72), int64(ret1), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		}
		return int32(x___syscall_ret(tls, uint64(ret1)))
	}
	switch cmd {
	case int32(m_F_SETLK):
		fallthrough
	case int32(m_F_GETLK):
		fallthrough
	case int32(m_F_GETOWN_EX):
		fallthrough
	case int32(m_F_SETOWN_EX):
		return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(72), int64(fd), int64(cmd), int64(uintptr(arg))))))
	default:
		return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(72), int64(fd), int64(cmd), int64(arg)))))
	}
	return r
}

const m_O_TMPFILE = 4259840

func x_open(tls *TLS, filename uintptr, flags int32, va uintptr) (r int32) {
	var ap Tva_list
	var fd int32
	var mode Tmode_t
	mode = uint32(0)
	if flags&int32(m_O_CREAT) != 0 || flags&int32(m_O_TMPFILE) == int32(m_O_TMPFILE) {
		ap = va
		mode = VaUint32(&ap)
		_ = ap
	}
	fd = int32(x___syscall_cp(tls, int64(m_SYS_open), int64(filename), int64(flags|Int32FromInt32(m_O_LARGEFILE)), int64(mode), int64(0), int64(0), int64(0)))
	if fd >= int32(0) && flags&int32(m_O_CLOEXEC) != 0 {
		___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	return int32(x___syscall_ret(tls, uint64(fd)))
}

func x_openat(tls *TLS, fd int32, filename uintptr, flags int32, va uintptr) (r int32) {
	var ap Tva_list
	var mode Tmode_t
	mode = uint32(0)
	if flags&int32(m_O_CREAT) != 0 || flags&int32(m_O_TMPFILE) == int32(m_O_TMPFILE) {
		ap = va
		mode = VaUint32(&ap)
		_ = ap
	}
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(257), int64(fd), int64(filename), int64(flags|Int32FromInt32(0100000)), int64(mode), int64(0), int64(0)))))
}

func x_posix_fadvise(tls *TLS, fd int32, base Toff_t, len1 Toff_t, advice int32) (r int32) {
	return int32(-___syscall4(tls, int64(221), int64(fd), base, len1, int64(advice)))
}

func x_posix_fallocate(tls *TLS, fd int32, base Toff_t, len1 Toff_t) (r int32) {
	return int32(-___syscall4(tls, int64(285), int64(fd), int64(Int32FromInt32(0)), base, len1))
}

const m_FE_DOWNWARD = 1024
const m_FE_TONEAREST = 0
const m_FE_TOWARDZERO = 3072
const m_FE_UPWARD = 2048

type Tfexcept_t = uint16

type Tfenv_t = struct {
	F__control_word  uint16
	F__unused1       uint16
	F__status_word   uint16
	F__unused2       uint16
	F__tags          uint16
	F__unused3       uint16
	F__eip           uint32
	F__cs_selector   uint16
	F__ccgo_align8   [2]byte
	F__ccgo20        uint16
	F__data_offset   uint32
	F__data_selector uint16
	F__unused5       uint16
	F__mxcsr         uint32
}

func x___flt_rounds(tls *TLS) (r int32) {
	switch _fegetround(tls) {
	case int32(m_FE_TOWARDZERO):
		return int32(0)
	case int32(m_FE_TONEAREST):
		return int32(1)
	case int32(m_FE_UPWARD):
		return int32(2)
	case int32(m_FE_DOWNWARD):
		return int32(3)
	}
	return -int32(1)
}

func x_fegetexceptflag(tls *TLS, fp uintptr, mask int32) (r int32) {
	*(*Tfexcept_t)(unsafe.Pointer(fp)) = uint16(_fetestexcept(tls, mask))
	return int32(0)
}

const m_FE_ALL_EXCEPT = 63

func x_feholdexcept(tls *TLS, envp uintptr) (r int32) {
	_fegetenv(tls, envp)
	_feclearexcept(tls, int32(m_FE_ALL_EXCEPT))
	return int32(0)
}

func x_fesetexceptflag(tls *TLS, fp uintptr, mask int32) (r int32) {
	_feclearexcept(tls, ^int32(*(*Tfexcept_t)(unsafe.Pointer(fp)))&mask)
	_feraiseexcept(tls, int32(*(*Tfexcept_t)(unsafe.Pointer(fp)))&mask)
	return int32(0)
}

/* __fesetround wrapper for arch independent argument check */

func x_fesetround(tls *TLS, r int32) (r1 int32) {
	if r != int32(m_FE_TONEAREST) && r != int32(m_FE_DOWNWARD) && r != int32(m_FE_UPWARD) && r != int32(m_FE_TOWARDZERO) {
		return -int32(1)
	}
	return ___fesetround(tls, r)
}

func x_feupdateenv(tls *TLS, envp uintptr) (r int32) {
	var ex int32
	ex = _fetestexcept(tls, int32(m_FE_ALL_EXCEPT))
	_fesetenv(tls, envp)
	_feraiseexcept(tls, ex)
	return int32(0)
}

const m_DBL_MANT_DIG = 53
const m_ERANGE = 34
const m_FLT_MANT_DIG = 24
const m_KMAX = 128
const m_LDBL_MANT_DIG = 53
const m_LD_B1B_DIG = 2
const m_LLONG_MAX = 9223372036854775807

type TFILE = struct {
	Fflags        uint32
	Frpos         uintptr
	Frend         uintptr
	Fclose1       uintptr
	Fwend         uintptr
	Fwpos         uintptr
	Fmustbezero_1 uintptr
	Fwbase        uintptr
	Fread         uintptr
	Fwrite        uintptr
	Fseek         uintptr
	Fbuf          uintptr
	Fbuf_size     Tsize_t
	Fprev         uintptr
	Fnext         uintptr
	Ffd           int32
	Fpipe_pid     int32
	Flockcount    int64
	Fmode         int32
	Flock         int32
	Flbf          int32
	Fcookie       uintptr
	Foff          Toff_t
	Fgetln_buf    uintptr
	Fmustbezero_2 uintptr
	Fshend        uintptr
	Fshlim        Toff_t
	Fshcnt        Toff_t
	Fprev_locked  uintptr
	Fnext_locked  uintptr
	Flocale       uintptr
}

type T_IO_FILE = TFILE

func _scanexp(tls *TLS, f uintptr, pok int32) (r int64) {
	var c int32
	var neg int32
	var x int32
	var y int64
	var v1 int32
	var v10 uintptr
	var v11 uintptr
	var v13 int32
	var v14 uintptr
	var v15 uintptr
	var v17 int32
	var v18 uintptr
	var v19 uintptr
	var v2 uintptr
	var v22 int64
	var v3 uintptr
	var v4 int32
	var v5 uintptr
	var v6 uintptr
	var v9 int32
	neg = int32(0)
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___shgetc(tls, f)
	}
	c = v1
	if c == int32('+') || c == int32('-') {
		neg = BoolInt32(c == int32('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v6 = f + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = x___shgetc(tls, f)
		}
		c = v4
		if uint32(c-int32('0')) >= uint32(10) && pok != 0 {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
		}
	}
	if uint32(c-int32('0')) >= uint32(10) {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		return -Int64FromInt64(0x7fffffffffffffff) - Int64FromInt32(1)
	}
	for x = int32(0); uint32(c-int32('0')) < uint32(10) && x < Int32FromInt32(m_INT_MAX)/Int32FromInt32(10); {
		x = int32(10)*x + c - int32('0')
		goto _12
	_12:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v11 = f + 8
			v10 = *(*uintptr)(unsafe.Pointer(v11))
			*(*uintptr)(unsafe.Pointer(v11))++
			v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
		} else {
			v9 = x___shgetc(tls, f)
		}
		c = v9
	}
	for y = int64(x); uint32(c-int32('0')) < uint32(10) && y < Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(100); {
		y = int64(10)*y + int64(c) - int64('0')
		goto _16
	_16:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v15 = f + 8
			v14 = *(*uintptr)(unsafe.Pointer(v15))
			*(*uintptr)(unsafe.Pointer(v15))++
			v13 = int32(*(*uint8)(unsafe.Pointer(v14)))
		} else {
			v13 = x___shgetc(tls, f)
		}
		c = v13
	}
	for uint32(c-int32('0')) < uint32(10) {
		goto _20
	_20:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v19 = f + 8
			v18 = *(*uintptr)(unsafe.Pointer(v19))
			*(*uintptr)(unsafe.Pointer(v19))++
			v17 = int32(*(*uint8)(unsafe.Pointer(v18)))
		} else {
			v17 = x___shgetc(tls, f)
		}
		c = v17
	}
	if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
		(*TFILE)(unsafe.Pointer(f)).Frpos--
	} else {
		_ = 0
	}
	if neg != 0 {
		v22 = -y
	} else {
		v22 = y
	}
	return v22
}

func _decfloat(tls *TLS, f uintptr, c int32, bits int32, emin int32, sign int32, pok int32) (r float64) {
	bp := tls.Alloc(512) /* tlsAllocs 512 maxValist 0 */
	defer tls.Free(512)
	var a int32
	var bias float64
	var bitlim int32
	var carry Tuint32_t
	var carry1 Tuint32_t
	var carry2 Tuint32_t
	var dc int64
	var denormal int32
	var e10 int64
	var e2 int32
	var emax int32
	var frac float64
	var gotdig int32
	var gotrad int32
	var i int32
	var j int32
	var k int32
	var lnz int32
	var lrp int64
	var p10 int32
	var rp int32
	var rpm9 int32
	var sh int32
	var t Tuint32_t
	var tmp Tuint32_t
	var tmp1 Tuint64_t
	var tmp2 Tuint32_t
	var y float64
	var z int32
	var _ /* x at bp+0 */ [128]Tuint32_t
	var v1 int32
	var v10 uintptr
	var v12 int32
	var v13 uintptr
	var v14 uintptr
	var v16 int32
	var v2 uintptr
	var v21 int32
	var v22 int32
	var v25 int32
	var v26 int32
	var v3 uintptr
	var v5 int32
	var v6 uintptr
	var v7 uintptr
	var v8 int32
	var v9 uintptr
	var p17 uintptr
	var p20 uintptr
	var p23 uintptr
	var p24 uintptr
	lrp = int64(0)
	dc = int64(0)
	e10 = int64(0)
	lnz = int32(0)
	gotdig = int32(0)
	gotrad = int32(0)
	emax = -emin - bits + int32(3)
	denormal = int32(0)
	frac = Float64FromInt32(0)
	bias = Float64FromInt32(0)
	j = int32(0)
	k = int32(0)
	/* Don't let leading zeros consume buffer space */
	for c == int32('0') {
		gotdig = int32(1)
		goto _4
	_4:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v3 = f + 8
			v2 = *(*uintptr)(unsafe.Pointer(v3))
			*(*uintptr)(unsafe.Pointer(v3))++
			v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
		} else {
			v1 = x___shgetc(tls, f)
		}
		c = v1
	}
	if c == int32('.') {
		gotrad = int32(1)
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = x___shgetc(tls, f)
		}
		c = v5
		for c == int32('0') {
			gotdig = int32(1)
			lrp--
			goto _11
		_11:
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v10 = f + 8
				v9 = *(*uintptr)(unsafe.Pointer(v10))
				*(*uintptr)(unsafe.Pointer(v10))++
				v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
			} else {
				v8 = x___shgetc(tls, f)
			}
			c = v8
		}
	}
	(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)] = uint32(0)
	for uint32(c-int32('0')) < uint32(10) || c == int32('.') {
		if c == int32('.') {
			if gotrad != 0 {
				break
			}
			gotrad = int32(1)
			lrp = dc
		} else {
			if k < Int32FromInt32(m_KMAX)-Int32FromInt32(3) {
				dc++
				if c != int32('0') {
					lnz = int32(dc)
				}
				if j != 0 {
					(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]*uint32(10) + uint32(c) - uint32('0')
				} else {
					(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(c - int32('0'))
				}
				j++
				v16 = j
				if v16 == int32(9) {
					k++
					j = int32(0)
				}
				gotdig = int32(1)
			} else {
				dc++
				if c != int32('0') {
					lnz = (Int32FromInt32(m_KMAX) - Int32FromInt32(4)) * Int32FromInt32(9)
					p17 = bp + uintptr(Int32FromInt32(m_KMAX)-Int32FromInt32(4))*4
					*(*Tuint32_t)(unsafe.Pointer(p17)) = *(*Tuint32_t)(unsafe.Pointer(p17)) | Uint32FromInt32(1)
				}
			}
		}
		goto _15
	_15:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v14 = f + 8
			v13 = *(*uintptr)(unsafe.Pointer(v14))
			*(*uintptr)(unsafe.Pointer(v14))++
			v12 = int32(*(*uint8)(unsafe.Pointer(v13)))
		} else {
			v12 = x___shgetc(tls, f)
		}
		c = v12
	}
	if !(gotrad != 0) {
		lrp = dc
	}
	if gotdig != 0 && c|int32(32) == int32('e') {
		e10 = _scanexp(tls, f, pok)
		if e10 == -Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1) {
			if pok != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
			} else {
				x___shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			e10 = int64(0)
		}
		lrp = lrp + e10
	} else {
		if c >= int32(0) {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
		}
	}
	if !(gotdig != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		x___shlim(tls, f, int64(Int32FromInt32(0)))
		return Float64FromInt32(0)
	}
	/* Handle zero specially to avoid nasty special cases later */
	if !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)] != 0) {
		return float64(sign) * float64(0)
	}
	/* Optimize small integers (w/no exponent) and over/under-flow */
	if lrp == dc && dc < int64(10) && (bits > int32(30) || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)]>>bits == uint32(0)) {
		return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)])
	}
	if lrp > int64(-emin/int32(2)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return float64(sign) * Float64FromFloat64(1.79769313486231570815e+308) * Float64FromFloat64(1.79769313486231570815e+308)
	}
	if lrp < int64(emin-Int32FromInt32(2)*Int32FromInt32(m_LDBL_MANT_DIG)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return float64(sign) * Float64FromFloat64(2.22507385850720138309e-308) * Float64FromFloat64(2.22507385850720138309e-308)
	}
	/* Align incomplete final B1B digit */
	if j != 0 {
		for ; j < int32(9); j++ {
			p20 = bp + uintptr(k)*4
			*(*Tuint32_t)(unsafe.Pointer(p20)) = *(*Tuint32_t)(unsafe.Pointer(p20)) * Uint32FromInt32(10)
		}
		k++
		j = int32(0)
	}
	a = int32(0)
	z = k
	e2 = int32(0)
	rp = int32(lrp)
	/* Optimize small to mid-size integers (even in exp. notation) */
	if lnz < int32(9) && lnz <= rp && rp < int32(18) {
		if rp == int32(9) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)])
		}
		if rp < int32(9) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)]) / float64(_p10s[int32(8)-rp])
		}
		bitlim = bits - int32(3)*(rp-Int32FromInt32(9))
		if bitlim > int32(30) || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)]>>bitlim == uint32(0) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[int32(0)]) * float64(_p10s[rp-int32(10)])
		}
	}
	/* Drop trailing zeros */
	for ; !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z-int32(1)] != 0); z-- {
	}
	/* Align radix point to B1B digit boundary */
	if rp%int32(9) != 0 {
		if rp >= int32(0) {
			v21 = rp % int32(9)
		} else {
			v21 = rp%int32(9) + int32(9)
		}
		rpm9 = v21
		p10 = _p10s[int32(8)-rpm9]
		carry = uint32(0)
		for k = a; k != z; k++ {
			tmp = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] % uint32(p10)
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]/uint32(p10) + carry
			carry = uint32(int32(1000000000)/p10) * tmp
			if k == a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				a = (a + int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
				rp = rp - Int32FromInt32(9)
			}
		}
		if carry != 0 {
			v22 = z
			z++
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[v22] = carry
		}
		rp = rp + (Int32FromInt32(9) - rpm9)
	}
	/* Upscale until desired number of bits are left of radix point */
	for rp < Int32FromInt32(9)*Int32FromInt32(m_LD_B1B_DIG) || rp == Int32FromInt32(9)*Int32FromInt32(m_LD_B1B_DIG) && (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[a] < _th[int32(0)] {
		carry1 = uint32(0)
		e2 = e2 - Int32FromInt32(29)
		for k = (z - int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1)); ; k = (k - int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1)) {
			tmp1 = uint64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k])<<Int32FromInt32(29) + uint64(carry1)
			if tmp1 > uint64(1000000000) {
				carry1 = uint32(tmp1 / uint64(1000000000))
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(tmp1 % uint64(1000000000))
			} else {
				carry1 = uint32(0)
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(tmp1)
			}
			if k == (z-int32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) && k != a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				z = k
			}
			if k == a {
				break
			}
		}
		if carry1 != 0 {
			rp = rp + Int32FromInt32(9)
			a = (a - int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
			if a == z {
				z = (z - int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
				p23 = bp + uintptr((z-Int32FromInt32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)))*4
				*(*Tuint32_t)(unsafe.Pointer(p23)) = *(*Tuint32_t)(unsafe.Pointer(p23)) | (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z]
			}
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[a] = carry1
		}
	}
	/* Downscale until exactly number of bits are left of radix point */
	for {
		carry2 = uint32(0)
		sh = int32(1)
		for i = int32(0); i < int32(m_LD_B1B_DIG); i++ {
			k = (a + i) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
			if k == z || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] < _th[i] {
				i = int32(m_LD_B1B_DIG)
				break
			}
			if (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(m_KMAX)-Int32FromInt32(1))] > _th[i] {
				break
			}
		}
		if i == int32(m_LD_B1B_DIG) && rp == Int32FromInt32(9)*Int32FromInt32(m_LD_B1B_DIG) {
			break
		}
		/* FIXME: find a way to compute optimal sh */
		if rp > Int32FromInt32(9)+Int32FromInt32(9)*Int32FromInt32(m_LD_B1B_DIG) {
			sh = int32(9)
		}
		e2 = e2 + sh
		for k = a; k != z; k = (k + int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1)) {
			tmp2 = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] & uint32(int32(1)<<sh-int32(1))
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]>>sh + carry2
			carry2 = uint32(Int32FromInt32(1000000000)>>sh) * tmp2
			if k == a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				a = (a + int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
				i--
				rp = rp - Int32FromInt32(9)
			}
		}
		if carry2 != 0 {
			if (z+int32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) != a {
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z] = carry2
				z = (z + int32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
			} else {
				p24 = bp + uintptr((z-Int32FromInt32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)))*4
				*(*Tuint32_t)(unsafe.Pointer(p24)) = *(*Tuint32_t)(unsafe.Pointer(p24)) | Uint32FromInt32(1)
			}
		}
	}
	/* Assemble desired bits into floating point variable */
	v25 = Int32FromInt32(0)
	i = v25
	y = float64(v25)
	for ; i < int32(m_LD_B1B_DIG); i++ {
		if (a+i)&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) == z {
			v26 = (z + Int32FromInt32(1)) & (Int32FromInt32(m_KMAX) - Int32FromInt32(1))
			z = v26
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[v26-int32(1)] = uint32(0)
		}
		y = Float64FromFloat64(1e+09)*y + float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(m_KMAX)-Int32FromInt32(1))])
	}
	y = y * float64(sign)
	/* Limit precision for denormal results */
	if bits > int32(m_LDBL_MANT_DIG)+e2-emin {
		bits = int32(m_LDBL_MANT_DIG) + e2 - emin
		if bits < int32(0) {
			bits = int32(0)
		}
		denormal = int32(1)
	}
	/* Calculate bias term to force rounding, move out lower bits */
	if bits < int32(m_LDBL_MANT_DIG) {
		bias = x_copysignl(tls, x_scalbn(tls, Float64FromInt32(1), Int32FromInt32(2)*Int32FromInt32(m_LDBL_MANT_DIG)-bits-int32(1)), y)
		frac = x_fmodl(tls, y, x_scalbn(tls, Float64FromInt32(1), int32(m_LDBL_MANT_DIG)-bits))
		y = y - frac
		y = y + bias
	}
	/* Process tail of decimal input so it can affect rounding */
	if (a+i)&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) != z {
		t = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(m_KMAX)-Int32FromInt32(1))]
		if t < uint32(500000000) && (t != 0 || (a+i+int32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) != z) {
			frac = frac + Float64FromFloat64(0.25)*float64(sign)
		} else {
			if t > uint32(500000000) {
				frac = frac + Float64FromFloat64(0.75)*float64(sign)
			} else {
				if t == uint32(500000000) {
					if (a+i+int32(1))&(Int32FromInt32(m_KMAX)-Int32FromInt32(1)) == z {
						frac = frac + Float64FromFloat64(0.5)*float64(sign)
					} else {
						frac = frac + Float64FromFloat64(0.75)*float64(sign)
					}
				}
			}
		}
		if int32(m_LDBL_MANT_DIG)-bits >= int32(2) && !(x_fmodl(tls, frac, Float64FromInt32(1)) != 0) {
			frac++
		}
	}
	y = y + frac
	y = y - bias
	if (e2+int32(m_LDBL_MANT_DIG))&int32(m_INT_MAX) > emax-int32(5) {
		if x_fabsl(tls, y) >= Float64FromInt32(2)/Float64FromFloat64(2.22044604925031308085e-16) {
			if denormal != 0 && bits == int32(m_LDBL_MANT_DIG)+e2-emin {
				denormal = int32(0)
			}
			y = y * Float64FromFloat64(0.5)
			e2++
		}
		if e2+int32(m_LDBL_MANT_DIG) > emax || denormal != 0 && frac != 0 {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		}
	}
	return x_scalbnl(tls, y, e2)
}

var _th = [2]Tuint32_t{
	0: uint32(9007199),
	1: uint32(254740991)}

var _p10s = [8]int32{
	0: int32(10),
	1: int32(100),
	2: int32(1000),
	3: int32(10000),
	4: int32(100000),
	5: int32(1000000),
	6: int32(10000000),
	7: int32(100000000)}

func _hexfloat(tls *TLS, f uintptr, bits int32, emin int32, sign int32, pok int32) (r float64) {
	var bias float64
	var c int32
	var d int32
	var dc int64
	var e2 int64
	var gotdig int32
	var gotrad int32
	var gottail int32
	var rp int64
	var scale float64
	var x Tuint32_t
	var y float64
	var v1 int32
	var v10 uintptr
	var v11 int32
	var v12 uintptr
	var v13 uintptr
	var v15 int32
	var v16 uintptr
	var v17 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 int32
	var v5 uintptr
	var v6 uintptr
	var v8 int32
	var v9 uintptr
	x = uint32(0)
	y = Float64FromInt32(0)
	scale = Float64FromInt32(1)
	bias = Float64FromInt32(0)
	gottail = int32(0)
	gotrad = int32(0)
	gotdig = int32(0)
	rp = int64(0)
	dc = int64(0)
	e2 = int64(0)
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___shgetc(tls, f)
	}
	c = v1
	/* Skip leading zeros */
	for c == int32('0') {
		gotdig = int32(1)
		goto _7
	_7:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v6 = f + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = x___shgetc(tls, f)
		}
		c = v4
	}
	if c == int32('.') {
		gotrad = int32(1)
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v10 = f + 8
			v9 = *(*uintptr)(unsafe.Pointer(v10))
			*(*uintptr)(unsafe.Pointer(v10))++
			v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
		} else {
			v8 = x___shgetc(tls, f)
		}
		c = v8
		/* Count zeros after the radix point before significand */
		for rp = int64(0); c == int32('0'); {
			gotdig = int32(1)
			goto _14
		_14:
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v13 = f + 8
				v12 = *(*uintptr)(unsafe.Pointer(v13))
				*(*uintptr)(unsafe.Pointer(v13))++
				v11 = int32(*(*uint8)(unsafe.Pointer(v12)))
			} else {
				v11 = x___shgetc(tls, f)
			}
			c = v11
			rp--
		}
	}
	for uint32(c-int32('0')) < uint32(10) || uint32(c|int32(32)-int32('a')) < uint32(6) || c == int32('.') {
		if c == int32('.') {
			if gotrad != 0 {
				break
			}
			rp = dc
			gotrad = int32(1)
		} else {
			gotdig = int32(1)
			if c > int32('9') {
				d = c | int32(32) + int32(10) - int32('a')
			} else {
				d = c - int32('0')
			}
			if dc < int64(8) {
				x = x*uint32(16) + uint32(d)
			} else {
				if dc < int64(Int32FromInt32(m_LDBL_MANT_DIG)/Int32FromInt32(4)+Int32FromInt32(1)) {
					scale = scale / Float64FromInt32(16)
					y = y + float64(d)*scale
				} else {
					if d != 0 && !(gottail != 0) {
						y = y + Float64FromFloat64(0.5)*scale
						gottail = int32(1)
					}
				}
			}
			dc++
		}
		goto _18
	_18:
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v17 = f + 8
			v16 = *(*uintptr)(unsafe.Pointer(v17))
			*(*uintptr)(unsafe.Pointer(v17))++
			v15 = int32(*(*uint8)(unsafe.Pointer(v16)))
		} else {
			v15 = x___shgetc(tls, f)
		}
		c = v15
	}
	if !(gotdig != 0) {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		if pok != 0 {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			if gotrad != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
			}
		} else {
			x___shlim(tls, f, int64(Int32FromInt32(0)))
		}
		return float64(sign) * float64(0)
	}
	if !(gotrad != 0) {
		rp = dc
	}
	for dc < int64(8) {
		x = x * Uint32FromInt32(16)
		dc++
	}
	if c|int32(32) == int32('p') {
		e2 = _scanexp(tls, f, pok)
		if e2 == -Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1) {
			if pok != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
			} else {
				x___shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			e2 = int64(0)
		}
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
	}
	e2 = e2 + (Int64FromInt32(4)*rp - Int64FromInt32(32))
	if !(x != 0) {
		return float64(sign) * float64(0)
	}
	if e2 > int64(-emin) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return float64(sign) * Float64FromFloat64(1.79769313486231570815e+308) * Float64FromFloat64(1.79769313486231570815e+308)
	}
	if e2 < int64(emin-Int32FromInt32(2)*Int32FromInt32(m_LDBL_MANT_DIG)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		return float64(sign) * Float64FromFloat64(2.22507385850720138309e-308) * Float64FromFloat64(2.22507385850720138309e-308)
	}
	for x < uint32(0x80000000) {
		if y >= Float64FromFloat64(0.5) {
			x = x + (x + Uint32FromInt32(1))
			y = y + (y - Float64FromInt32(1))
		} else {
			x = x + x
			y = y + y
		}
		e2--
	}
	if int64(bits) > int64(32)+e2-int64(emin) {
		bits = int32(int64(32) + e2 - int64(emin))
		if bits < int32(0) {
			bits = int32(0)
		}
	}
	if bits < int32(m_LDBL_MANT_DIG) {
		bias = x_copysignl(tls, x_scalbn(tls, Float64FromInt32(1), Int32FromInt32(32)+Int32FromInt32(m_LDBL_MANT_DIG)-bits-int32(1)), float64(sign))
	}
	if bits < int32(32) && y != 0 && !(x&Uint32FromInt32(1) != 0) {
		x++
		y = Float64FromInt32(0)
	}
	y = bias + float64(sign)*float64(x) + float64(sign)*y
	y = y - bias
	if !(y != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
	}
	return x_scalbnl(tls, y, int32(e2))
}

func x___floatscan(tls *TLS, f uintptr, prec int32, pok int32) (r float64) {
	var bits int32
	var c int32
	var emin int32
	var i Tsize_t
	var sign int32
	var v1 int32
	var v10 uintptr
	var v13 int32
	var v14 uintptr
	var v15 uintptr
	var v16 int32
	var v17 uintptr
	var v18 uintptr
	var v2 int32
	var v20 int32
	var v21 uintptr
	var v22 uintptr
	var v24 Tsize_t
	var v27 int32
	var v28 uintptr
	var v29 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 int32
	var v6 uintptr
	var v7 uintptr
	var v8 int32
	var v9 uintptr
	sign = int32(1)
	switch prec {
	case int32(0):
		bits = int32(m_FLT_MANT_DIG)
		emin = -int32(125) - bits
	case int32(1):
		bits = int32(m_DBL_MANT_DIG)
		emin = -int32(1021) - bits
	case int32(2):
		bits = int32(m_LDBL_MANT_DIG)
		emin = -int32(1021) - bits
	default:
		return Float64FromInt32(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = x___shgetc(tls, f)
		}
		v1 = v2
		c = v1
		if !(___isspace(tls, v1) != 0) {
			break
		}
	}
	if c == int32('+') || c == int32('-') {
		sign = sign - Int32FromInt32(2)*BoolInt32(c == Int32FromUint8('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = x___shgetc(tls, f)
		}
		c = v5
	}
	for i = uint64(0); i < uint64(8) && c|int32(32) == int32(*(*int8)(unsafe.Pointer(ts + 313 + uintptr(i)))); i++ {
		if i < uint64(7) {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v10 = f + 8
				v9 = *(*uintptr)(unsafe.Pointer(v10))
				*(*uintptr)(unsafe.Pointer(v10))++
				v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
			} else {
				v8 = x___shgetc(tls, f)
			}
			c = v8
		}
	}
	if i == uint64(3) || i == uint64(8) || i > uint64(3) && pok != 0 {
		if i != uint64(8) {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			if pok != 0 {
				for ; i > uint64(3); i-- {
					if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
						(*TFILE)(unsafe.Pointer(f)).Frpos--
					} else {
						_ = 0
					}
				}
			}
		}
		return float64(float32(sign) * ___builtin_inff(tls))
	}
	if !(i != 0) {
		for i = uint64(0); i < uint64(3) && c|int32(32) == int32(*(*int8)(unsafe.Pointer(ts + 322 + uintptr(i)))); i++ {
			if i < uint64(2) {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v15 = f + 8
					v14 = *(*uintptr)(unsafe.Pointer(v15))
					*(*uintptr)(unsafe.Pointer(v15))++
					v13 = int32(*(*uint8)(unsafe.Pointer(v14)))
				} else {
					v13 = x___shgetc(tls, f)
				}
				c = v13
			}
		}
	}
	if i == uint64(3) {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v18 = f + 8
			v17 = *(*uintptr)(unsafe.Pointer(v18))
			*(*uintptr)(unsafe.Pointer(v18))++
			v16 = int32(*(*uint8)(unsafe.Pointer(v17)))
		} else {
			v16 = x___shgetc(tls, f)
		}
		if v16 != int32('(') {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			return float64(___builtin_nanf(tls, ts))
		}
		for i = uint64(1); ; i++ {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v22 = f + 8
				v21 = *(*uintptr)(unsafe.Pointer(v22))
				*(*uintptr)(unsafe.Pointer(v22))++
				v20 = int32(*(*uint8)(unsafe.Pointer(v21)))
			} else {
				v20 = x___shgetc(tls, f)
			}
			c = v20
			if uint32(c-int32('0')) < uint32(10) || uint32(c-int32('A')) < uint32(26) || uint32(c-int32('a')) < uint32(26) || c == int32('_') {
				continue
			}
			if c == int32(')') {
				return float64(___builtin_nanf(tls, ts))
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			if !(pok != 0) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
				x___shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			for {
				v24 = i
				i--
				if !(v24 != 0) {
					break
				}
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
			}
			return float64(___builtin_nanf(tls, ts))
		}
		return float64(___builtin_nanf(tls, ts))
	}
	if i != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		x___shlim(tls, f, int64(Int32FromInt32(0)))
		return Float64FromInt32(0)
	}
	if c == int32('0') {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v29 = f + 8
			v28 = *(*uintptr)(unsafe.Pointer(v29))
			*(*uintptr)(unsafe.Pointer(v29))++
			v27 = int32(*(*uint8)(unsafe.Pointer(v28)))
		} else {
			v27 = x___shgetc(tls, f)
		}
		c = v27
		if c|int32(32) == int32('x') {
			return _hexfloat(tls, f, bits, emin, sign, pok)
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		c = int32('0')
	}
	return _decfloat(tls, f, c, bits, emin, sign, pok)
}

const m_UINT_MAX = 4294967295

/* Lookup table for digit values. -1==255>=36 -> invalid */
var _table6 = [257]uint8{
	0:   uint8(-Int32FromInt32(1)),
	1:   uint8(-Int32FromInt32(1)),
	2:   uint8(-Int32FromInt32(1)),
	3:   uint8(-Int32FromInt32(1)),
	4:   uint8(-Int32FromInt32(1)),
	5:   uint8(-Int32FromInt32(1)),
	6:   uint8(-Int32FromInt32(1)),
	7:   uint8(-Int32FromInt32(1)),
	8:   uint8(-Int32FromInt32(1)),
	9:   uint8(-Int32FromInt32(1)),
	10:  uint8(-Int32FromInt32(1)),
	11:  uint8(-Int32FromInt32(1)),
	12:  uint8(-Int32FromInt32(1)),
	13:  uint8(-Int32FromInt32(1)),
	14:  uint8(-Int32FromInt32(1)),
	15:  uint8(-Int32FromInt32(1)),
	16:  uint8(-Int32FromInt32(1)),
	17:  uint8(-Int32FromInt32(1)),
	18:  uint8(-Int32FromInt32(1)),
	19:  uint8(-Int32FromInt32(1)),
	20:  uint8(-Int32FromInt32(1)),
	21:  uint8(-Int32FromInt32(1)),
	22:  uint8(-Int32FromInt32(1)),
	23:  uint8(-Int32FromInt32(1)),
	24:  uint8(-Int32FromInt32(1)),
	25:  uint8(-Int32FromInt32(1)),
	26:  uint8(-Int32FromInt32(1)),
	27:  uint8(-Int32FromInt32(1)),
	28:  uint8(-Int32FromInt32(1)),
	29:  uint8(-Int32FromInt32(1)),
	30:  uint8(-Int32FromInt32(1)),
	31:  uint8(-Int32FromInt32(1)),
	32:  uint8(-Int32FromInt32(1)),
	33:  uint8(-Int32FromInt32(1)),
	34:  uint8(-Int32FromInt32(1)),
	35:  uint8(-Int32FromInt32(1)),
	36:  uint8(-Int32FromInt32(1)),
	37:  uint8(-Int32FromInt32(1)),
	38:  uint8(-Int32FromInt32(1)),
	39:  uint8(-Int32FromInt32(1)),
	40:  uint8(-Int32FromInt32(1)),
	41:  uint8(-Int32FromInt32(1)),
	42:  uint8(-Int32FromInt32(1)),
	43:  uint8(-Int32FromInt32(1)),
	44:  uint8(-Int32FromInt32(1)),
	45:  uint8(-Int32FromInt32(1)),
	46:  uint8(-Int32FromInt32(1)),
	47:  uint8(-Int32FromInt32(1)),
	48:  uint8(-Int32FromInt32(1)),
	49:  uint8(0),
	50:  uint8(1),
	51:  uint8(2),
	52:  uint8(3),
	53:  uint8(4),
	54:  uint8(5),
	55:  uint8(6),
	56:  uint8(7),
	57:  uint8(8),
	58:  uint8(9),
	59:  uint8(-Int32FromInt32(1)),
	60:  uint8(-Int32FromInt32(1)),
	61:  uint8(-Int32FromInt32(1)),
	62:  uint8(-Int32FromInt32(1)),
	63:  uint8(-Int32FromInt32(1)),
	64:  uint8(-Int32FromInt32(1)),
	65:  uint8(-Int32FromInt32(1)),
	66:  uint8(10),
	67:  uint8(11),
	68:  uint8(12),
	69:  uint8(13),
	70:  uint8(14),
	71:  uint8(15),
	72:  uint8(16),
	73:  uint8(17),
	74:  uint8(18),
	75:  uint8(19),
	76:  uint8(20),
	77:  uint8(21),
	78:  uint8(22),
	79:  uint8(23),
	80:  uint8(24),
	81:  uint8(25),
	82:  uint8(26),
	83:  uint8(27),
	84:  uint8(28),
	85:  uint8(29),
	86:  uint8(30),
	87:  uint8(31),
	88:  uint8(32),
	89:  uint8(33),
	90:  uint8(34),
	91:  uint8(35),
	92:  uint8(-Int32FromInt32(1)),
	93:  uint8(-Int32FromInt32(1)),
	94:  uint8(-Int32FromInt32(1)),
	95:  uint8(-Int32FromInt32(1)),
	96:  uint8(-Int32FromInt32(1)),
	97:  uint8(-Int32FromInt32(1)),
	98:  uint8(10),
	99:  uint8(11),
	100: uint8(12),
	101: uint8(13),
	102: uint8(14),
	103: uint8(15),
	104: uint8(16),
	105: uint8(17),
	106: uint8(18),
	107: uint8(19),
	108: uint8(20),
	109: uint8(21),
	110: uint8(22),
	111: uint8(23),
	112: uint8(24),
	113: uint8(25),
	114: uint8(26),
	115: uint8(27),
	116: uint8(28),
	117: uint8(29),
	118: uint8(30),
	119: uint8(31),
	120: uint8(32),
	121: uint8(33),
	122: uint8(34),
	123: uint8(35),
	124: uint8(-Int32FromInt32(1)),
	125: uint8(-Int32FromInt32(1)),
	126: uint8(-Int32FromInt32(1)),
	127: uint8(-Int32FromInt32(1)),
	128: uint8(-Int32FromInt32(1)),
	129: uint8(-Int32FromInt32(1)),
	130: uint8(-Int32FromInt32(1)),
	131: uint8(-Int32FromInt32(1)),
	132: uint8(-Int32FromInt32(1)),
	133: uint8(-Int32FromInt32(1)),
	134: uint8(-Int32FromInt32(1)),
	135: uint8(-Int32FromInt32(1)),
	136: uint8(-Int32FromInt32(1)),
	137: uint8(-Int32FromInt32(1)),
	138: uint8(-Int32FromInt32(1)),
	139: uint8(-Int32FromInt32(1)),
	140: uint8(-Int32FromInt32(1)),
	141: uint8(-Int32FromInt32(1)),
	142: uint8(-Int32FromInt32(1)),
	143: uint8(-Int32FromInt32(1)),
	144: uint8(-Int32FromInt32(1)),
	145: uint8(-Int32FromInt32(1)),
	146: uint8(-Int32FromInt32(1)),
	147: uint8(-Int32FromInt32(1)),
	148: uint8(-Int32FromInt32(1)),
	149: uint8(-Int32FromInt32(1)),
	150: uint8(-Int32FromInt32(1)),
	151: uint8(-Int32FromInt32(1)),
	152: uint8(-Int32FromInt32(1)),
	153: uint8(-Int32FromInt32(1)),
	154: uint8(-Int32FromInt32(1)),
	155: uint8(-Int32FromInt32(1)),
	156: uint8(-Int32FromInt32(1)),
	157: uint8(-Int32FromInt32(1)),
	158: uint8(-Int32FromInt32(1)),
	159: uint8(-Int32FromInt32(1)),
	160: uint8(-Int32FromInt32(1)),
	161: uint8(-Int32FromInt32(1)),
	162: uint8(-Int32FromInt32(1)),
	163: uint8(-Int32FromInt32(1)),
	164: uint8(-Int32FromInt32(1)),
	165: uint8(-Int32FromInt32(1)),
	166: uint8(-Int32FromInt32(1)),
	167: uint8(-Int32FromInt32(1)),
	168: uint8(-Int32FromInt32(1)),
	169: uint8(-Int32FromInt32(1)),
	170: uint8(-Int32FromInt32(1)),
	171: uint8(-Int32FromInt32(1)),
	172: uint8(-Int32FromInt32(1)),
	173: uint8(-Int32FromInt32(1)),
	174: uint8(-Int32FromInt32(1)),
	175: uint8(-Int32FromInt32(1)),
	176: uint8(-Int32FromInt32(1)),
	177: uint8(-Int32FromInt32(1)),
	178: uint8(-Int32FromInt32(1)),
	179: uint8(-Int32FromInt32(1)),
	180: uint8(-Int32FromInt32(1)),
	181: uint8(-Int32FromInt32(1)),
	182: uint8(-Int32FromInt32(1)),
	183: uint8(-Int32FromInt32(1)),
	184: uint8(-Int32FromInt32(1)),
	185: uint8(-Int32FromInt32(1)),
	186: uint8(-Int32FromInt32(1)),
	187: uint8(-Int32FromInt32(1)),
	188: uint8(-Int32FromInt32(1)),
	189: uint8(-Int32FromInt32(1)),
	190: uint8(-Int32FromInt32(1)),
	191: uint8(-Int32FromInt32(1)),
	192: uint8(-Int32FromInt32(1)),
	193: uint8(-Int32FromInt32(1)),
	194: uint8(-Int32FromInt32(1)),
	195: uint8(-Int32FromInt32(1)),
	196: uint8(-Int32FromInt32(1)),
	197: uint8(-Int32FromInt32(1)),
	198: uint8(-Int32FromInt32(1)),
	199: uint8(-Int32FromInt32(1)),
	200: uint8(-Int32FromInt32(1)),
	201: uint8(-Int32FromInt32(1)),
	202: uint8(-Int32FromInt32(1)),
	203: uint8(-Int32FromInt32(1)),
	204: uint8(-Int32FromInt32(1)),
	205: uint8(-Int32FromInt32(1)),
	206: uint8(-Int32FromInt32(1)),
	207: uint8(-Int32FromInt32(1)),
	208: uint8(-Int32FromInt32(1)),
	209: uint8(-Int32FromInt32(1)),
	210: uint8(-Int32FromInt32(1)),
	211: uint8(-Int32FromInt32(1)),
	212: uint8(-Int32FromInt32(1)),
	213: uint8(-Int32FromInt32(1)),
	214: uint8(-Int32FromInt32(1)),
	215: uint8(-Int32FromInt32(1)),
	216: uint8(-Int32FromInt32(1)),
	217: uint8(-Int32FromInt32(1)),
	218: uint8(-Int32FromInt32(1)),
	219: uint8(-Int32FromInt32(1)),
	220: uint8(-Int32FromInt32(1)),
	221: uint8(-Int32FromInt32(1)),
	222: uint8(-Int32FromInt32(1)),
	223: uint8(-Int32FromInt32(1)),
	224: uint8(-Int32FromInt32(1)),
	225: uint8(-Int32FromInt32(1)),
	226: uint8(-Int32FromInt32(1)),
	227: uint8(-Int32FromInt32(1)),
	228: uint8(-Int32FromInt32(1)),
	229: uint8(-Int32FromInt32(1)),
	230: uint8(-Int32FromInt32(1)),
	231: uint8(-Int32FromInt32(1)),
	232: uint8(-Int32FromInt32(1)),
	233: uint8(-Int32FromInt32(1)),
	234: uint8(-Int32FromInt32(1)),
	235: uint8(-Int32FromInt32(1)),
	236: uint8(-Int32FromInt32(1)),
	237: uint8(-Int32FromInt32(1)),
	238: uint8(-Int32FromInt32(1)),
	239: uint8(-Int32FromInt32(1)),
	240: uint8(-Int32FromInt32(1)),
	241: uint8(-Int32FromInt32(1)),
	242: uint8(-Int32FromInt32(1)),
	243: uint8(-Int32FromInt32(1)),
	244: uint8(-Int32FromInt32(1)),
	245: uint8(-Int32FromInt32(1)),
	246: uint8(-Int32FromInt32(1)),
	247: uint8(-Int32FromInt32(1)),
	248: uint8(-Int32FromInt32(1)),
	249: uint8(-Int32FromInt32(1)),
	250: uint8(-Int32FromInt32(1)),
	251: uint8(-Int32FromInt32(1)),
	252: uint8(-Int32FromInt32(1)),
	253: uint8(-Int32FromInt32(1)),
	254: uint8(-Int32FromInt32(1)),
	255: uint8(-Int32FromInt32(1)),
	256: uint8(-Int32FromInt32(1))}

func x___intscan(tls *TLS, f uintptr, base uint32, pok int32, lim uint64) (r uint64) {
	var bs int32
	var c int32
	var neg int32
	var val uintptr
	var x uint32
	var y uint64
	var v1 int32
	var v10 uintptr
	var v11 int32
	var v12 uintptr
	var v13 uintptr
	var v17 int32
	var v18 uintptr
	var v19 uintptr
	var v2 int32
	var v21 int32
	var v22 uintptr
	var v23 uintptr
	var v25 int32
	var v26 uintptr
	var v27 uintptr
	var v29 int32
	var v3 uintptr
	var v30 uintptr
	var v31 uintptr
	var v33 int32
	var v34 uintptr
	var v35 uintptr
	var v37 int32
	var v38 uintptr
	var v39 uintptr
	var v4 uintptr
	var v41 int32
	var v42 uintptr
	var v43 uintptr
	var v5 int32
	var v6 uintptr
	var v7 uintptr
	var v8 int32
	var v9 uintptr
	val = uintptr(unsafe.Pointer(&_table6)) + uintptr(1)
	neg = int32(0)
	if base > uint32(36) || base == uint32(1) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uint64(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = x___shgetc(tls, f)
		}
		v1 = v2
		c = v1
		if !(___isspace(tls, v1) != 0) {
			break
		}
	}
	if c == int32('+') || c == int32('-') {
		neg = -BoolInt32(c == int32('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = x___shgetc(tls, f)
		}
		c = v5
	}
	if (base == uint32(0) || base == uint32(16)) && c == int32('0') {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v10 = f + 8
			v9 = *(*uintptr)(unsafe.Pointer(v10))
			*(*uintptr)(unsafe.Pointer(v10))++
			v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
		} else {
			v8 = x___shgetc(tls, f)
		}
		c = v8
		if c|int32(32) == int32('x') {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v13 = f + 8
				v12 = *(*uintptr)(unsafe.Pointer(v13))
				*(*uintptr)(unsafe.Pointer(v13))++
				v11 = int32(*(*uint8)(unsafe.Pointer(v12)))
			} else {
				v11 = x___shgetc(tls, f)
			}
			c = v11
			if int32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= int32(16) {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
				if pok != 0 {
					if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
						(*TFILE)(unsafe.Pointer(f)).Frpos--
					} else {
						_ = 0
					}
				} else {
					x___shlim(tls, f, int64(Int32FromInt32(0)))
				}
				return uint64(0)
			}
			base = uint32(16)
		} else {
			if base == uint32(0) {
				base = uint32(8)
			}
		}
	} else {
		if base == uint32(0) {
			base = uint32(10)
		}
		if uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= base {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			x___shlim(tls, f, int64(Int32FromInt32(0)))
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
			return uint64(0)
		}
	}
	if base == uint32(10) {
		for x = uint32(0); uint32(c-int32('0')) < uint32(10) && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(10)-Uint32FromInt32(1); {
			x = x*uint32(10) + uint32(c-Int32FromUint8('0'))
			goto _20
		_20:
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v19 = f + 8
				v18 = *(*uintptr)(unsafe.Pointer(v19))
				*(*uintptr)(unsafe.Pointer(v19))++
				v17 = int32(*(*uint8)(unsafe.Pointer(v18)))
			} else {
				v17 = x___shgetc(tls, f)
			}
			c = v17
		}
		for y = uint64(x); uint32(c-int32('0')) < uint32(10) && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))/Uint64FromInt32(10) && uint64(10)*y <= Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1)-uint64(c-Int32FromUint8('0')); {
			y = y*uint64(10) + uint64(c-Int32FromUint8('0'))
			goto _24
		_24:
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v23 = f + 8
				v22 = *(*uintptr)(unsafe.Pointer(v23))
				*(*uintptr)(unsafe.Pointer(v23))++
				v21 = int32(*(*uint8)(unsafe.Pointer(v22)))
			} else {
				v21 = x___shgetc(tls, f)
			}
			c = v21
		}
		if uint32(c-int32('0')) >= uint32(10) {
			goto done
		}
	} else {
		if !(base&(base-Uint32FromInt32(1)) != 0) {
			bs = int32(*(*int8)(unsafe.Pointer(ts + 326 + uintptr(Uint32FromInt32(0x17)*base>>Int32FromInt32(5)&Uint32FromInt32(7)))))
			for x = uint32(0); uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(32); {
				x = x<<bs | uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _28
			_28:
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v27 = f + 8
					v26 = *(*uintptr)(unsafe.Pointer(v27))
					*(*uintptr)(unsafe.Pointer(v27))++
					v25 = int32(*(*uint8)(unsafe.Pointer(v26)))
				} else {
					v25 = x___shgetc(tls, f)
				}
				c = v25
			}
			for y = uint64(x); uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))>>bs; {
				y = y<<bs | uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _32
			_32:
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v31 = f + 8
					v30 = *(*uintptr)(unsafe.Pointer(v31))
					*(*uintptr)(unsafe.Pointer(v31))++
					v29 = int32(*(*uint8)(unsafe.Pointer(v30)))
				} else {
					v29 = x___shgetc(tls, f)
				}
				c = v29
			}
		} else {
			for x = uint32(0); uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(36)-Uint32FromInt32(1); {
				x = x*base + uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _36
			_36:
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v35 = f + 8
					v34 = *(*uintptr)(unsafe.Pointer(v35))
					*(*uintptr)(unsafe.Pointer(v35))++
					v33 = int32(*(*uint8)(unsafe.Pointer(v34)))
				} else {
					v33 = x___shgetc(tls, f)
				}
				c = v33
			}
			for y = uint64(x); uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))/uint64(base) && uint64(base)*y <= Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1)-uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c)))); {
				y = y*uint64(base) + uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _40
			_40:
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v39 = f + 8
					v38 = *(*uintptr)(unsafe.Pointer(v39))
					*(*uintptr)(unsafe.Pointer(v39))++
					v37 = int32(*(*uint8)(unsafe.Pointer(v38)))
				} else {
					v37 = x___shgetc(tls, f)
				}
				c = v37
			}
		}
	}
	if uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base {
		for uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base {
			goto _44
		_44:
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v43 = f + 8
				v42 = *(*uintptr)(unsafe.Pointer(v43))
				*(*uintptr)(unsafe.Pointer(v43))++
				v41 = int32(*(*uint8)(unsafe.Pointer(v42)))
			} else {
				v41 = x___shgetc(tls, f)
			}
			c = v41
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
		y = lim
		if lim&uint64(1) != 0 {
			neg = int32(0)
		}
	}
done:
	if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
		(*TFILE)(unsafe.Pointer(f)).Frpos--
	} else {
		_ = 0
	}
	if y >= lim {
		if !(lim&Uint64FromInt32(1) != 0) && !(neg != 0) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
			return lim - uint64(1)
		} else {
			if y > lim {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
				return lim
			}
		}
	}
	return y ^ uint64(neg) - uint64(neg)
}

func x___procfdname(tls *TLS, buf uintptr, fd uint32) {
	var i uint32
	var j uint32
	var v1 int8
	var v4 uint32
	for i = uint32(0); ; i++ {
		v1 = *(*int8)(unsafe.Pointer(ts + 335 + uintptr(i)))
		*(*int8)(unsafe.Pointer(buf + uintptr(i))) = v1
		if !(v1 != 0) {
			break
		}
	}
	if !(fd != 0) {
		*(*int8)(unsafe.Pointer(buf + uintptr(i))) = int8('0')
		*(*int8)(unsafe.Pointer(buf + uintptr(i+Uint32FromInt32(1)))) = int8(0)
		return
	}
	for j = fd; j != 0; {
		goto _2
	_2:
		j = j / Uint32FromInt32(10)
		i++
	}
	*(*int8)(unsafe.Pointer(buf + uintptr(i))) = int8(0)
	for fd != 0 {
		i--
		v4 = i
		*(*int8)(unsafe.Pointer(buf + uintptr(v4))) = int8(uint32('0') + fd%uint32(10))
		goto _3
	_3:
		fd = fd / Uint32FromInt32(10)
	}
}

func x___shlim(tls *TLS, f uintptr, lim Toff_t) {
	(*TFILE)(unsafe.Pointer(f)).Fshlim = lim
	(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	/* If lim is nonzero, rend must be a valid pointer. */
	if lim != 0 && int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos) > lim {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(lim)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frend
	}
}

func x___shgetc(tls *TLS, f uintptr) (r int32) {
	var c int32
	var cnt Toff_t
	var v1 int32
	var v2 bool
	cnt = (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
	if v2 = (*TFILE)(unsafe.Pointer(f)).Fshlim != 0 && cnt >= (*TFILE)(unsafe.Pointer(f)).Fshlim; !v2 {
		v1 = x___uflow(tls, f)
		c = v1
	}
	if v2 || v1 < int32(0) {
		(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + cnt
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos
		(*TFILE)(unsafe.Pointer(f)).Fshlim = int64(-int32(1))
		return -int32(1)
	}
	cnt++
	if (*TFILE)(unsafe.Pointer(f)).Fshlim != 0 && int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos) > (*TFILE)(unsafe.Pointer(f)).Fshlim-cnt {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr((*TFILE)(unsafe.Pointer(f)).Fshlim-cnt)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frend
	}
	(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + cnt
	if (*TFILE)(unsafe.Pointer(f)).Frpos <= (*TFILE)(unsafe.Pointer(f)).Fbuf {
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(-Int32FromInt32(1)))) = uint8(c)
	}
	return c
}

func x___syscall_ret(tls *TLS, r uint64) (r1 int64) {
	if r > -Uint64FromUint64(4096) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(-r)
		return int64(-int32(1))
	}
	return int64(r)
}

const m_AT_SYSINFO_EHDR = 33
const m_DT_HASH = 4
const m_DT_STRTAB = 5
const m_DT_SYMTAB = 6
const m_DT_VERDEF = 1879048188
const m_DT_VERSYM = 1879048176
const m_PT_LOAD = 1
const m_STB_GLOBAL = 1
const m_STB_GNU_UNIQUE = 10
const m_STB_WEAK = 2
const m_STT_COMMON = 5
const m_STT_FUNC = 2
const m_STT_NOTYPE = 0
const m_STT_OBJECT = 1
const m_VER_FLG_BASE = 1

type TElf_Symndx = uint32

type Tdl_phdr_info = struct {
	Fdlpi_addr      TElf64_Addr
	Fdlpi_name      uintptr
	Fdlpi_phdr      uintptr
	Fdlpi_phnum     TElf64_Half
	Fdlpi_adds      uint64
	Fdlpi_subs      uint64
	Fdlpi_tls_modid Tsize_t
	Fdlpi_tls_data  uintptr
}

type Tlink_map = struct {
	Fl_addr TElf64_Addr
	Fl_name uintptr
	Fl_ld   uintptr
	Fl_next uintptr
	Fl_prev uintptr
}

type Tr_debug = struct {
	Fr_version int32
	Fr_map     uintptr
	Fr_brk     TElf64_Addr
	Fr_state   int32
	Fr_ldbase  TElf64_Addr
}

const _RT_CONSISTENT = 0
const _RT_ADD = 1
const _RT_DELETE = 2

type TEhdr = struct {
	Fe_ident     [16]uint8
	Fe_type      TElf64_Half
	Fe_machine   TElf64_Half
	Fe_version   TElf64_Word
	Fe_entry     TElf64_Addr
	Fe_phoff     TElf64_Off
	Fe_shoff     TElf64_Off
	Fe_flags     TElf64_Word
	Fe_ehsize    TElf64_Half
	Fe_phentsize TElf64_Half
	Fe_phnum     TElf64_Half
	Fe_shentsize TElf64_Half
	Fe_shnum     TElf64_Half
	Fe_shstrndx  TElf64_Half
}

type TSym = struct {
	Fst_name  TElf64_Word
	Fst_info  uint8
	Fst_other uint8
	Fst_shndx TElf64_Section
	Fst_value TElf64_Addr
	Fst_size  TElf64_Xword
}

type TVerdef = struct {
	Fvd_version TElf64_Half
	Fvd_flags   TElf64_Half
	Fvd_ndx     TElf64_Half
	Fvd_cnt     TElf64_Half
	Fvd_hash    TElf64_Word
	Fvd_aux     TElf64_Word
	Fvd_next    TElf64_Word
}

type TVerdaux = struct {
	Fvda_name TElf64_Word
	Fvda_next TElf64_Word
}

func _checkver(tls *TLS, def uintptr, vsym int32, vername uintptr, strings uintptr) (r int32) {
	var aux uintptr
	vsym = vsym & Int32FromInt32(0x7fff)
	for {
		if !(int32((*TVerdef)(unsafe.Pointer(def)).Fvd_flags)&Int32FromInt32(m_VER_FLG_BASE) != 0) && int32((*TVerdef)(unsafe.Pointer(def)).Fvd_ndx)&int32(0x7fff) == vsym {
			break
		}
		if (*TVerdef)(unsafe.Pointer(def)).Fvd_next == uint32(0) {
			return int32(0)
		}
		def = def + uintptr((*TVerdef)(unsafe.Pointer(def)).Fvd_next)
	}
	aux = def + uintptr((*TVerdef)(unsafe.Pointer(def)).Fvd_aux)
	return BoolInt32(!(x_strcmp(tls, vername, strings+uintptr((*TVerdaux)(unsafe.Pointer(aux)).Fvda_name)) != 0))
}

func x___vdsosym(tls *TLS, vername uintptr, name uintptr) (r uintptr) {
	var base Tsize_t
	var dynv uintptr
	var eh uintptr
	var hashtab uintptr
	var i Tsize_t
	var p uintptr
	var ph uintptr
	var strings uintptr
	var syms uintptr
	var verdef uintptr
	var versym uintptr
	for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(x___libc.Fauxv + uintptr(i)*8)) != uint64(m_AT_SYSINFO_EHDR); {
		if !(*(*Tsize_t)(unsafe.Pointer(x___libc.Fauxv + uintptr(i)*8)) != 0) {
			return uintptr(0)
		}
		goto _1
	_1:
		i = i + Uint64FromInt32(2)
	}
	if !(*(*Tsize_t)(unsafe.Pointer(x___libc.Fauxv + uintptr(i+Uint64FromInt32(1))*8)) != 0) {
		return uintptr(0)
	}
	eh = uintptr(*(*Tsize_t)(unsafe.Pointer(x___libc.Fauxv + uintptr(i+Uint64FromInt32(1))*8)))
	ph = eh + uintptr((*TEhdr)(unsafe.Pointer(eh)).Fe_phoff)
	dynv = uintptr(0)
	base = uint64(-Int32FromInt32(1))
	for i = uint64(0); i < uint64((*TEhdr)(unsafe.Pointer(eh)).Fe_phnum); {
		if (*TPhdr)(unsafe.Pointer(ph)).Fp_type == uint32(m_PT_LOAD) {
			base = uint64(eh) + (*TPhdr)(unsafe.Pointer(ph)).Fp_offset - (*TPhdr)(unsafe.Pointer(ph)).Fp_vaddr
		} else {
			if (*TPhdr)(unsafe.Pointer(ph)).Fp_type == uint32(m_PT_DYNAMIC) {
				dynv = eh + uintptr((*TPhdr)(unsafe.Pointer(ph)).Fp_offset)
			}
		}
		goto _2
	_2:
		i++
		ph = ph + uintptr((*TEhdr)(unsafe.Pointer(eh)).Fe_phentsize)
	}
	if !(dynv != 0) || base == uint64(-Int32FromInt32(1)) {
		return uintptr(0)
	}
	strings = uintptr(0)
	syms = uintptr(0)
	hashtab = uintptr(0)
	versym = uintptr(0)
	verdef = uintptr(0)
	for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) != 0; {
		p = uintptr(base + *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i+Uint64FromInt32(1))*8)))
		switch *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) {
		case uint64(m_DT_STRTAB):
			strings = p
		case uint64(m_DT_SYMTAB):
			syms = p
		case uint64(m_DT_HASH):
			hashtab = p
		case uint64(m_DT_VERSYM):
			versym = p
		case uint64(m_DT_VERDEF):
			verdef = p
			break
		}
		goto _3
	_3:
		i = i + Uint64FromInt32(2)
	}
	if !(strings != 0) || !(syms != 0) || !(hashtab != 0) {
		return uintptr(0)
	}
	if !(verdef != 0) {
		versym = uintptr(0)
	}
	for i = uint64(0); i < uint64(*(*TElf_Symndx)(unsafe.Pointer(hashtab + UintptrFromInt32(1)*4))); i++ {
		if !(Int32FromInt32(1)<<(int32((*(*TSym)(unsafe.Pointer(syms + uintptr(i)*24))).Fst_info)&Int32FromInt32(0xf))&(Int32FromInt32(1)<<Int32FromInt32(m_STT_NOTYPE)|Int32FromInt32(1)<<Int32FromInt32(m_STT_OBJECT)|Int32FromInt32(1)<<Int32FromInt32(m_STT_FUNC)|Int32FromInt32(1)<<Int32FromInt32(m_STT_COMMON)) != 0) {
			continue
		}
		if !(Int32FromInt32(1)<<(int32((*(*TSym)(unsafe.Pointer(syms + uintptr(i)*24))).Fst_info)>>Int32FromInt32(4))&(Int32FromInt32(1)<<Int32FromInt32(m_STB_GLOBAL)|Int32FromInt32(1)<<Int32FromInt32(m_STB_WEAK)|Int32FromInt32(1)<<Int32FromInt32(m_STB_GNU_UNIQUE)) != 0) {
			continue
		}
		if !((*(*TSym)(unsafe.Pointer(syms + uintptr(i)*24))).Fst_shndx != 0) {
			continue
		}
		if x_strcmp(tls, name, strings+uintptr((*(*TSym)(unsafe.Pointer(syms + uintptr(i)*24))).Fst_name)) != 0 {
			continue
		}
		if versym != 0 && !(_checkver(tls, verdef, int32(*(*Tuint16_t)(unsafe.Pointer(versym + uintptr(i)*2))), vername, strings) != 0) {
			continue
		}
		return uintptr(base + (*(*TSym)(unsafe.Pointer(syms + uintptr(i)*24))).Fst_value)
	}
	return uintptr(0)
}

const m_VERSION = "1.2.4"

const m___BYTE_ORDER = 1234

type Tkey_t = int32

type Tipc_perm = struct {
	F__key  Tkey_t
	Fuid    Tuid_t
	Fgid    Tgid_t
	Fcuid   Tuid_t
	Fcgid   Tgid_t
	Fmode   Tmode_t
	F__seq  int32
	F__pad1 int64
	F__pad2 int64
}

func x_ftok(tls *TLS, path uintptr, id int32) (r Tkey_t) {
	bp := tls.Alloc(144) /* tlsAllocs 144 maxValist 0 */
	defer tls.Free(144)
	var _ /* st at bp+0 */ Tstat
	if x_stat(tls, path, bp) < int32(0) {
		return -int32(1)
	}
	return int32((*(*Tstat)(unsafe.Pointer(bp))).Fst_ino&Uint64FromInt32(0xffff) | (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev&Uint64FromInt32(0xff)<<Int32FromInt32(16) | uint64(uint32(id)&Uint32FromUint32(0xff)<<Int32FromInt32(24)))
}

type Tmsgqnum_t = uint64

type Tmsglen_t = uint64

type Tmsqid_ds = struct {
	Fmsg_perm   Tipc_perm
	Fmsg_stime  Ttime_t
	Fmsg_rtime  Ttime_t
	Fmsg_ctime  Ttime_t
	Fmsg_cbytes uint64
	Fmsg_qnum   Tmsgqnum_t
	Fmsg_qbytes Tmsglen_t
	Fmsg_lspid  Tpid_t
	Fmsg_lrpid  Tpid_t
	F__unused   [2]uint64
}

type Tmsginfo = struct {
	Fmsgpool     int32
	Fmsgmap      int32
	Fmsgmax      int32
	Fmsgmnb      int32
	Fmsgmni      int32
	Fmsgssz      int32
	Fmsgtql      int32
	Fmsgseg      uint16
	F__ccgo_pad8 [2]byte
}

func x_msgctl(tls *TLS, q int32, cmd int32, buf uintptr) (r1 int32) {
	var r int32
	r = int32(___syscall3(tls, int64(71), int64(q), int64(cmd & ^(Int32FromInt32(2)&Int32FromInt32(0x100)) | Int32FromInt32(0)), int64(buf)))
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_msgget(tls *TLS, k Tkey_t, flag int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(68), int64(k), int64(flag)))))
}

func x_msgrcv(tls *TLS, q int32, m uintptr, len1 Tsize_t, type1 int64, flag int32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(70), int64(q), int64(m), int64(len1), type1, int64(flag), int64(0))))
}

func x_msgsnd(tls *TLS, q int32, m uintptr, len1 Tsize_t, flag int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(69), int64(q), int64(m), int64(len1), int64(flag), int64(0), int64(0)))))
}

type Tsemid_ds = struct {
	Fsem_perm        Tipc_perm
	Fsem_otime       Ttime_t
	F__unused1       int64
	Fsem_ctime       Ttime_t
	F__unused2       int64
	Fsem_nsems       uint16
	F__sem_nsems_pad [6]int8
	F__unused3       int64
	F__unused4       int64
}

type Tseminfo = struct {
	Fsemmap int32
	Fsemmni int32
	Fsemmns int32
	Fsemmnu int32
	Fsemmsl int32
	Fsemopm int32
	Fsemume int32
	Fsemusz int32
	Fsemvmx int32
	Fsemaem int32
}

type Tsembuf = struct {
	Fsem_num uint16
	Fsem_op  int16
	Fsem_flg int16
}

type Tsemun = struct {
	Fbuf         [0]uintptr
	Farray       [0]uintptr
	Fval         int32
	F__ccgo_pad3 [4]byte
}

func x_semctl(tls *TLS, id int32, num int32, cmd int32, va uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+350, int32(20), uintptr(unsafe.Pointer(&___func__1)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__1 = [7]int8{'s', 'e', 'm', 'c', 't', 'l'}

const m_USHRT_MAX = 65535

func x_semget(tls *TLS, key Tkey_t, n int32, fl int32) (r int32) {
	/* The kernel uses the wrong type for the sem_nsems member
	 * of struct semid_ds, and thus might not check that the
	 * n fits in the correct (per POSIX) userspace type, so
	 * we have to check here. */
	if n > int32(m_USHRT_MAX) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(64), int64(key), int64(n), int64(fl)))))
}

func x_semop(tls *TLS, id int32, buf uintptr, n Tsize_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(65), int64(id), int64(buf), int64(n)))))
}

type Tipc_perm1 = struct {
	Fkey    Tkey_t
	Fuid    Tuid_t
	Fgid    Tgid_t
	Fcuid   Tuid_t
	Fcgid   Tgid_t
	Fmode   Tmode_t
	Fseq    int32
	F__pad1 int64
	F__pad2 int64
}

type Tsemid_ds1 = struct {
	Fsem_perm        Tipc_perm1
	Fsem_otime       Ttime_t
	F__unused1       int64
	Fsem_ctime       Ttime_t
	F__unused2       int64
	Fsem_nsems       uint16
	F__sem_nsems_pad [6]int8
	F__unused3       int64
	F__unused4       int64
}

func x_semtimedop(tls *TLS, id int32, buf uintptr, n Tsize_t, ts uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(220), int64(id), int64(buf), int64(n), int64(ts)))))
}

type Tshmid_ds = struct {
	Fshm_perm   Tipc_perm
	Fshm_segsz  Tsize_t
	Fshm_atime  Ttime_t
	Fshm_dtime  Ttime_t
	Fshm_ctime  Ttime_t
	Fshm_cpid   Tpid_t
	Fshm_lpid   Tpid_t
	Fshm_nattch uint64
	F__pad1     uint64
	F__pad2     uint64
}

type Tshminfo = struct {
	Fshmmax   uint64
	Fshmmin   uint64
	Fshmmni   uint64
	Fshmseg   uint64
	Fshmall   uint64
	F__unused [4]uint64
}

type Tshm_info = struct {
	F__used_ids       int32
	Fshm_tot          uint64
	Fshm_rss          uint64
	Fshm_swp          uint64
	F__swap_attempts  uint64
	F__swap_successes uint64
}

type Tshmatt_t = uint64

func x_shmat(tls *TLS, id int32, addr uintptr, flag int32) (r uintptr) {
	return uintptr(x___syscall_ret(tls, uint64(___syscall3(tls, int64(30), int64(id), int64(addr), int64(flag)))))
}

func x_shmctl(tls *TLS, id int32, cmd int32, buf uintptr) (r1 int32) {
	var r int32
	r = int32(___syscall3(tls, int64(31), int64(id), int64(cmd & ^(Int32FromInt32(2)&Int32FromInt32(0x100)) | Int32FromInt32(0)), int64(buf)))
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_shmdt(tls *TLS, addr uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(67), int64(addr)))))
}

func x_shmget(tls *TLS, key Tkey_t, size Tsize_t, flag int32) (r int32) {
	if size > uint64(Int64FromInt64(0x7fffffffffffffff)) {
		size = Uint64FromUint64(0xffffffffffffffff)
	}
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(29), int64(key), int64(size), int64(flag)))))
}

const _REL_NONE = 0
const _REL_SYMBOLIC = -100
const _REL_USYMBOLIC = -99
const _REL_GOT = -98
const _REL_PLT = -97
const _REL_RELATIVE = -96
const _REL_OFFSET = -95
const _REL_OFFSET32 = -94
const _REL_COPY = -93
const _REL_SYM_OR_REL = -92
const _REL_DTPMOD = -91
const _REL_DTPOFF = -90
const _REL_TPOFF = -89
const _REL_TPOFF_NEG = -88
const _REL_TLSDESC = -87
const _REL_FUNCDESC = -86
const _REL_FUNCDESC_VAL = -85

type Tfdpic_loadseg = struct {
	Faddr    Tuintptr_t
	Fp_vaddr Tuintptr_t
	Fp_memsz Tuintptr_t
}

type Tfdpic_loadmap = struct {
	F__ccgo_align [0]uint64
	Fversion      uint16
	Fnsegs        uint16
}

type Tfdpic_dummy_loadmap = struct {
	Fversion uint16
	Fnsegs   uint16
	Fsegs    [1]Tfdpic_loadseg
}

type Tstage2_func = uintptr

func _stub_dlsym(tls *TLS, p uintptr, s uintptr, ra uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	x___dl_seterr(tls, ts+367, VaList(bp+8, s))
	return uintptr(0)
}

func _static_dl_iterate_phdr(tls *TLS, callback uintptr, data uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+388, int32(13), uintptr(unsafe.Pointer(&___func__2)))
	}
	_ = v1 || Int32FromInt32(0) != 0 //TODO
	return r
}

var ___func__2 = [23]int8{'s', 't', 'a', 't', 'i', 'c', '_', 'd', 'l', '_', 'i', 't', 'e', 'r', 'a', 't', 'e', '_', 'p', 'h', 'd', 'r'}

type TDl_info = struct {
	Fdli_fname uintptr
	Fdli_fbase uintptr
	Fdli_sname uintptr
	Fdli_saddr uintptr
}

func _stub_dladdr(tls *TLS, addr uintptr, info uintptr) (r int32) {
	return int32(0)
}

func x_dlclose(tls *TLS, p uintptr) (r int32) {
	return x___dl_invalid_handle(tls, p)
}

func x_dlerror(tls *TLS) (r uintptr) {
	var s uintptr
	var self Tpthread_t
	self = ___get_tp(tls)
	if !(int32(*(*uint8)(unsafe.Pointer(self + 66))&0x2>>1) != 0) {
		return uintptr(0)
	}
	SetBitFieldPtr8Uint8(self+66, Uint8FromInt32(0), 1, 0x2)
	s = (*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf
	if s == uintptr(-Int32FromInt32(1)) {
		return ts + 415
	} else {
		return s
	}
	return r
}

/* Atomic singly-linked list, used to store list of thread-local dlerror
 * buffers for deferred free. They cannot be freed at thread exit time
 * because, by the time it's known they can be freed, the exiting thread
 * is in a highly restrictive context where it cannot call (even the
 * libc-internal) free. It also can't take locks; thus the atomic list. */

var _freebuf_queue uintptr

func x___dl_thread_cleanup(tls *TLS) {
	var h uintptr
	var self Tpthread_t
	self = ___get_tp(tls)
	if !((*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf != 0) || (*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf == uintptr(-Int32FromInt32(1)) {
		return
	}
	for cond := true; cond; cond = _a_cas_p(tls, uintptr(unsafe.Pointer(&_freebuf_queue)), h, (*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf) != h {
		h = _freebuf_queue
		*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf)) = h
	}
}

func x___dl_vseterr(tls *TLS, fmt uintptr, ap Tva_list) {
	var ap2 Tva_list
	var buf uintptr
	var len1 Tsize_t
	var p uintptr
	var q uintptr
	var self Tpthread_t
	for cond := true; cond; cond = q != 0 && _a_cas_p(tls, uintptr(unsafe.Pointer(&_freebuf_queue)), q, uintptr(0)) != q {
		q = _freebuf_queue
	}
	for q != 0 {
		p = *(*uintptr)(unsafe.Pointer(q))
		x___libc_free(tls, q)
		q = p
	}
	ap2 = ap
	self = ___get_tp(tls)
	if (*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf != uintptr(-Int32FromInt32(1)) {
		x___libc_free(tls, (*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf)
	}
	len1 = uint64(x_vsnprintf(tls, uintptr(0), uint64(0), fmt, ap2))
	if len1 < uint64(8) {
		len1 = uint64(8)
	}
	_ = ap2
	buf = x___libc_malloc(tls, len1+uint64(1))
	if buf != 0 {
		x_vsnprintf(tls, buf, len1+uint64(1), fmt, ap)
	} else {
		buf = uintptr(-Int32FromInt32(1))
	}
	(*T__pthread)(unsafe.Pointer(self)).Fdlerror_buf = buf
	SetBitFieldPtr8Uint8(self+66, Uint8FromInt32(1), 1, 0x2)
}

func x___dl_seterr(tls *TLS, fmt uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	x___dl_vseterr(tls, fmt, ap)
	_ = ap
}

func _stub_invalid_handle(tls *TLS, h uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	x___dl_seterr(tls, ts+474, VaList(bp+8, h))
	return int32(1)
}

const m_RTLD_DI_LINKMAP = 2

func x_dlinfo(tls *TLS, dso uintptr, req int32, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	if x___dl_invalid_handle(tls, dso) != 0 {
		return -int32(1)
	}
	if req != int32(m_RTLD_DI_LINKMAP) {
		x___dl_seterr(tls, ts+500, VaList(bp+8, req))
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(res)) = dso
	return int32(0)
}

func _stub_dlopen(tls *TLS, file uintptr, mode int32) (r uintptr) {
	x___dl_seterr(tls, ts+523, 0)
	return uintptr(0)
}

const m_L_cuserid = 20

type Tpasswd = struct {
	Fpw_name   uintptr
	Fpw_passwd uintptr
	Fpw_uid    Tuid_t
	Fpw_gid    Tgid_t
	Fpw_gecos  uintptr
	Fpw_dir    uintptr
	Fpw_shell  uintptr
}

func x_cuserid(tls *TLS, buf uintptr) (r uintptr) {
	bp := tls.Alloc(2104) /* tlsAllocs 2104 maxValist 0 */
	defer tls.Free(2104)
	var len1 Tsize_t
	var _ /* ppw at bp+48 */ uintptr
	var _ /* pw at bp+0 */ Tpasswd
	var _ /* pwb at bp+56 */ [256]int64
	if buf != 0 {
		*(*int8)(unsafe.Pointer(buf)) = int8(0)
	}
	x_getpwuid_r(tls, x_geteuid(tls), bp, bp+56, uint64(2048), bp+48)
	if !(*(*uintptr)(unsafe.Pointer(bp + 48)) != 0) {
		return buf
	}
	len1 = x_strnlen(tls, (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_name, uint64(m_L_cuserid))
	if len1 == uint64(m_L_cuserid) {
		return buf
	}
	if !(buf != 0) {
		buf = uintptr(unsafe.Pointer(&_usridbuf))
	}
	x_memcpy(tls, buf, (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_name, len1+uint64(1))
	return buf
}

var _usridbuf [20]int8

const m_O_RDWR = 2

func x_daemon(tls *TLS, nochdir int32, noclose int32) (r int32) {
	var failed int32
	var fd int32
	var v1 int32
	if !(nochdir != 0) && x_chdir(tls, ts+553) != 0 {
		return -int32(1)
	}
	if !(noclose != 0) {
		failed = int32(0)
		v1 = x_open(tls, ts+230, int32(m_O_RDWR), 0)
		fd = v1
		if v1 < int32(0) {
			return -int32(1)
		}
		if x_dup2(tls, fd, int32(0)) < int32(0) || x_dup2(tls, fd, int32(1)) < int32(0) || x_dup2(tls, fd, int32(2)) < int32(0) {
			failed++
		}
		if fd > int32(2) {
			x_close(tls, fd)
		}
		if failed != 0 {
			return -int32(1)
		}
	}
	switch x_fork(tls) {
	case int32(0):
	case -int32(1):
		return -int32(1)
	default:
		x__exit(tls, int32(0))
	}
	if x_setsid(tls) < int32(0) {
		return -int32(1)
	}
	switch x_fork(tls) {
	case int32(0):
	case -int32(1):
		return -int32(1)
	default:
		x__exit(tls, int32(0))
	}
	return int32(0)
}

func x_vwarn(tls *TLS, fmt uintptr, ap Tva_list) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	x_fprintf(tls, uintptr(unsafe.Pointer(&x___stderr_FILE)), ts+555, VaList(bp+8, x___progname))
	if fmt != 0 {
		x_vfprintf(tls, uintptr(unsafe.Pointer(&x___stderr_FILE)), fmt, ap)
		x_fputs(tls, ts+560, uintptr(unsafe.Pointer(&x___stderr_FILE)))
	}
	x_perror(tls, uintptr(0))
}

func x_vwarnx(tls *TLS, fmt uintptr, ap Tva_list) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	x_fprintf(tls, uintptr(unsafe.Pointer(&x___stderr_FILE)), ts+555, VaList(bp+8, x___progname))
	if fmt != 0 {
		x_vfprintf(tls, uintptr(unsafe.Pointer(&x___stderr_FILE)), fmt, ap)
	}
	x_putc(tls, int32('\n'), uintptr(unsafe.Pointer(&x___stderr_FILE)))
}

func x_verr(tls *TLS, status int32, fmt uintptr, ap Tva_list) {
	x_vwarn(tls, fmt, ap)
	x_exit(tls, status)
}

func x_verrx(tls *TLS, status int32, fmt uintptr, ap Tva_list) {
	x_vwarnx(tls, fmt, ap)
	x_exit(tls, status)
}

func x_warn(tls *TLS, fmt uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	x_vwarn(tls, fmt, ap)
	_ = ap
}

func x_warnx(tls *TLS, fmt uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	x_vwarnx(tls, fmt, ap)
	_ = ap
}

func x_err(tls *TLS, status int32, fmt uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	x_verr(tls, status, fmt, ap)
	_ = ap
}

func x_errx(tls *TLS, status int32, fmt uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	x_verrx(tls, status, fmt, ap)
	_ = ap
}

const m_AT_EACCESS = 512

func x_euidaccess(tls *TLS, filename uintptr, amode int32) (r int32) {
	return x_faccessat(tls, -int32(100), filename, amode, int32(m_AT_EACCESS))
}

const m_FTW_PHYS = 1

type TFTW = struct {
	Fbase  int32
	Flevel int32
}

func x_ftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32) (r int32) {
	/* The following cast assumes that calling a function with one
	 * argument more than it needs behaves as expected. This is
	 * actually undefined, but works on all real-world machines. */
	return x_nftw(tls, path, fn, fd_limit, int32(m_FTW_PHYS))
}

type Ttimezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

func x_futimes(tls *TLS, fd int32, tv uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var _ /* times at bp+0 */ [2]Ttimespec
	if !(tv != 0) {
		return x_futimens(tls, fd, uintptr(0))
	}
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(0)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(0)*16))).Ftv_sec
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(0)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(0)*16))).Ftv_usec * int64(1000)
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(1)*16))).Ftv_sec
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(1)*16))).Ftv_usec * int64(1000)
	return x_futimens(tls, fd, bp)
}

func x_getdtablesize(tls *TLS) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* rl at bp+0 */ Trlimit
	var v1 uint64
	x_getrlimit(tls, int32(m_RLIMIT_NOFILE), bp)
	if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur < uint64(m_INT_MAX) {
		v1 = (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur
	} else {
		v1 = uint64(m_INT_MAX)
	}
	return int32(v1)
}

const m_SI_LOAD_SHIFT = 16

func x_getloadavg(tls *TLS, a uintptr, n int32) (r int32) {
	bp := tls.Alloc(368) /* tlsAllocs 368 maxValist 0 */
	defer tls.Free(368)
	var i int32
	var _ /* si at bp+0 */ Tsysinfo
	var v1 int32
	if n <= int32(0) {
		if n != 0 {
			v1 = -int32(1)
		} else {
			v1 = int32(0)
		}
		return v1
	}
	x___lsysinfo(tls, bp)
	if n > int32(3) {
		n = int32(3)
	}
	i = int32(0)
	for ; i < n; i++ {
		*(*float64)(unsafe.Pointer(a + uintptr(i)*8)) = Float64FromFloat64(1) / float64(Int32FromInt32(1)<<Int32FromInt32(m_SI_LOAD_SHIFT)) * float64(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsysinfo)(unsafe.Pointer(bp))).Floads)) + uintptr(i)*8)))
	}
	return n
}

func x_getpagesize(tls *TLS) (r int32) {
	return int32(m_PAGESIZE)
}

const m_ECHO = 8
const m_ICANON = 2
const m_ICRNL = 256
const m_IGNCR = 128
const m_INLCR = 64
const m_ISIG = 1
const m_NCCS = 32
const m_O_NOCTTY = 256
const m_TCSAFLUSH = 2

type Twinsize = struct {
	Fws_row    uint16
	Fws_col    uint16
	Fws_xpixel uint16
	Fws_ypixel uint16
}

type Tcc_t = uint8

type Tspeed_t = uint32

type Ttcflag_t = uint32

type Ttermios = struct {
	Fc_iflag    Ttcflag_t
	Fc_oflag    Ttcflag_t
	Fc_cflag    Ttcflag_t
	Fc_lflag    Ttcflag_t
	Fc_line     Tcc_t
	Fc_cc       [32]Tcc_t
	F__c_ispeed Tspeed_t
	F__c_ospeed Tspeed_t
}

func x_getpass(tls *TLS, prompt uintptr) (r uintptr) {
	bp := tls.Alloc(136) /* tlsAllocs 120 maxValist 1 */
	defer tls.Free(136)
	var fd int32
	var l Tssize_t
	var _ /* s at bp+0 */ Ttermios
	var _ /* t at bp+60 */ Ttermios
	var v1 int32
	var v6 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	v1 = x_open(tls, ts+563, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOCTTY)|Int32FromInt32(m_O_CLOEXEC), 0)
	fd = v1
	if v1 < int32(0) {
		return uintptr(0)
	}
	x_tcgetattr(tls, fd, bp+60)
	*(*Ttermios)(unsafe.Pointer(bp)) = *(*Ttermios)(unsafe.Pointer(bp + 60))
	p2 = uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag))
	*(*Ttcflag_t)(unsafe.Pointer(p2)) = *(*Ttcflag_t)(unsafe.Pointer(p2)) & uint32(^(Int32FromInt32(m_ECHO) | Int32FromInt32(m_ISIG)))
	p3 = uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag))
	*(*Ttcflag_t)(unsafe.Pointer(p3)) = *(*Ttcflag_t)(unsafe.Pointer(p3)) | Uint32FromInt32(m_ICANON)
	p4 = uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag))
	*(*Ttcflag_t)(unsafe.Pointer(p4)) = *(*Ttcflag_t)(unsafe.Pointer(p4)) & uint32(^(Int32FromInt32(m_INLCR) | Int32FromInt32(m_IGNCR)))
	p5 = uintptr(unsafe.Pointer(&(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag))
	*(*Ttcflag_t)(unsafe.Pointer(p5)) = *(*Ttcflag_t)(unsafe.Pointer(p5)) | Uint32FromInt32(m_ICRNL)
	x_tcsetattr(tls, fd, int32(m_TCSAFLUSH), bp+60)
	x_tcdrain(tls, fd)
	x_dprintf(tls, fd, ts+15, VaList(bp+128, prompt))
	l = x_read(tls, fd, uintptr(unsafe.Pointer(&_password)), uint64(128))
	if l >= int64(0) {
		if l > int64(0) && int32(_password[l-int64(1)]) == int32('\n') || uint64(l) == uint64(128) {
			l--
		}
		_password[l] = int8(0)
	}
	x_tcsetattr(tls, fd, int32(m_TCSAFLUSH), bp)
	x_dprintf(tls, fd, ts+572, 0)
	x_close(tls, fd)
	if l < int64(0) {
		v6 = uintptr(0)
	} else {
		v6 = uintptr(unsafe.Pointer(&_password))
	}
	return v6
}

var _password [128]int8

var _defshells = [18]int8{'/', 'b', 'i', 'n', '/', 's', 'h', 10, '/', 'b', 'i', 'n', '/', 'c', 's', 'h', 10}

var _line uintptr
var _linesize Tsize_t
var _f uintptr

func x_endusershell(tls *TLS) {
	if _f != 0 {
		x_fclose(tls, _f)
	}
	_f = uintptr(0)
}

func x_setusershell(tls *TLS) {
	if !(_f != 0) {
		_f = x_fopen(tls, ts+574, ts+586)
	}
	if !(_f != 0) {
		_f = x_fmemopen(tls, uintptr(unsafe.Pointer(&_defshells)), Uint64FromInt64(18)-Uint64FromInt32(1), ts+590)
	}
}

func x_getusershell(tls *TLS) (r uintptr) {
	var l Tssize_t
	if !(_f != 0) {
		x_setusershell(tls)
	}
	if !(_f != 0) {
		return uintptr(0)
	}
	l = x_getline(tls, uintptr(unsafe.Pointer(&_line)), uintptr(unsafe.Pointer(&_linesize)), _f)
	if l <= int64(0) {
		return uintptr(0)
	}
	if int32(*(*int8)(unsafe.Pointer(_line + uintptr(l-Int64FromInt32(1))))) == int32('\n') {
		*(*int8)(unsafe.Pointer(_line + uintptr(l-Int64FromInt32(1)))) = int8(0)
	}
	return _line
}

const m_FMNAMESZ = 8

type Tbandinfo = struct {
	Fbi_pri  uint8
	Fbi_flag int32
}

type Tstrbuf = struct {
	Fmaxlen int32
	Flen1   int32
	Fbuf    uintptr
}

type Tstrpeek = struct {
	Fctlbuf      Tstrbuf
	Fdatabuf     Tstrbuf
	Fflags       uint32
	F__ccgo_pad3 [4]byte
}

type Tstrfdinsert = struct {
	Fctlbuf      Tstrbuf
	Fdatabuf     Tstrbuf
	Fflags       uint32
	Ffildes      int32
	Foffset      int32
	F__ccgo_pad5 [4]byte
}

type Tstrioctl = struct {
	Fic_cmd    int32
	Fic_timout int32
	Fic_len    int32
	Fic_dp     uintptr
}

type Tstrrecvfd = struct {
	Ffd     int32
	Fuid    int32
	Fgid    int32
	F__fill [8]int8
}

type Tstr_mlist = struct {
	Fl_name [9]int8
}

type Tstr_list = struct {
	Fsl_nmods   int32
	Fsl_modlist uintptr
}

func x_isastream(tls *TLS, fd int32) (r int32) {
	var v1 int32
	if x_fcntl(tls, fd, int32(m_F_GETFD), 0) < int32(0) {
		v1 = -int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

const m_AT_SYMLINK_NOFOLLOW = 256

func x_lutimes(tls *TLS, filename uintptr, tv uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var _ /* times at bp+0 */ [2]Ttimespec
	var v1 uintptr
	if tv != 0 {
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(0)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(0)*16))).Ftv_sec
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(0)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(0)*16))).Ftv_usec * int64(1000)
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(1)*16))).Ftv_sec
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + UintptrFromInt32(1)*16))).Ftv_usec * int64(1000)
	}
	if tv != 0 {
		v1 = bp
	} else {
		v1 = uintptr(0)
	}
	return x_utimensat(tls, -int32(100), filename, v1, int32(m_AT_SYMLINK_NOFOLLOW))
}

const m_RLIMIT_FSIZE = 1
const m_UL_SETFSIZE = 2

func x_ulimit(tls *TLS, cmd int32, va uintptr) (r int64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ap Tva_list
	var val int64
	var _ /* rl at bp+0 */ Trlimit
	x_getrlimit(tls, int32(m_RLIMIT_FSIZE), bp)
	if cmd == int32(m_UL_SETFSIZE) {
		ap = va
		val = VaInt64(&ap)
		_ = ap
		(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = uint64(512) * uint64(val)
		if x_setrlimit(tls, int32(m_RLIMIT_FSIZE), bp) != 0 {
			return int64(-int32(1))
		}
	}
	return int64((*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur / uint64(512))
}

const m_EOPNOTSUPP = 95

type Tutmpx = struct {
	Fut_type   int16
	F__ut_pad1 int16
	Fut_pid    Tpid_t
	Fut_line   [32]int8
	Fut_id     [4]int8
	Fut_user   [32]int8
	Fut_host   [256]int8
	Fut_exit   struct {
		F__e_termination int16
		F__e_exit        int16
	}
	Fut_session   int32
	F__ut_pad2    int32
	Fut_tv        Ttimeval
	Fut_addr_v6   [4]uint32
	F__unused     [20]int8
	F__ccgo_pad13 [4]byte
}

func x_endutxent(tls *TLS) {
}

func x_setutxent(tls *TLS) {
}

func x_getutxent(tls *TLS) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_getutxid(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_getutxline(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_pututxline(tls *TLS, ut uintptr) (r uintptr) {
	return UintptrFromInt32(0)
}

func x_updwtmpx(tls *TLS, f uintptr, u uintptr) {
}

func ___utmpxname(tls *TLS, f uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOPNOTSUPP)
	return -int32(1)
}

func x_valloc(tls *TLS, size Tsize_t) (r uintptr) {
	return x_memalign(tls, uint64(m_PAGESIZE), size)
}

const m_ADJ_OFFSET_SINGLESHOT = 32769

type Tntptimeval = struct {
	Ftime     Ttimeval
	Fmaxerror int64
	Festerror int64
}

type Ttimex = struct {
	Fmodes     uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime      Ttimeval
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

func x_adjtime(tls *TLS, in uintptr, out uintptr) (r int32) {
	bp := tls.Alloc(208) /* tlsAllocs 208 maxValist 0 */
	defer tls.Free(208)
	var _ /* tx at bp+0 */ Ttimex
	var v1 Tsuseconds_t
	var p2 uintptr
	*(*Ttimex)(unsafe.Pointer(bp)) = Ttimex{}
	if in != 0 {
		if (*Ttimeval)(unsafe.Pointer(in)).Ftv_sec > int64(1000) || (*Ttimeval)(unsafe.Pointer(in)).Ftv_usec > int64(1000000000) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
			return -int32(1)
		}
		(*(*Ttimex)(unsafe.Pointer(bp))).Foffset = (*Ttimeval)(unsafe.Pointer(in)).Ftv_sec*int64(1000000) + (*Ttimeval)(unsafe.Pointer(in)).Ftv_usec
		(*(*Ttimex)(unsafe.Pointer(bp))).Fmodes = uint32(m_ADJ_OFFSET_SINGLESHOT)
	}
	if x_adjtimex(tls, bp) < int32(0) {
		return -int32(1)
	}
	if out != 0 {
		(*Ttimeval)(unsafe.Pointer(out)).Ftv_sec = (*(*Ttimex)(unsafe.Pointer(bp))).Foffset / int64(1000000)
		v1 = (*(*Ttimex)(unsafe.Pointer(bp))).Foffset % Int64FromInt32(1000000)
		(*Ttimeval)(unsafe.Pointer(out)).Ftv_usec = v1
		if v1 < int64(0) {
			(*Ttimeval)(unsafe.Pointer(out)).Ftv_sec--
			p2 = out + 8
			*(*Tsuseconds_t)(unsafe.Pointer(p2)) = *(*Tsuseconds_t)(unsafe.Pointer(p2)) + Int64FromInt32(1000000)
		}
	}
	return int32(0)
}

const m_CLOCK_REALTIME = 0

func x_adjtimex(tls *TLS, tx uintptr) (r int32) {
	return x_clock_adjtime(tls, int32(m_CLOCK_REALTIME), tx)
}

func x_arch_prctl(tls *TLS, code int32, addr uint64) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(158), int64(code), int64(addr)))))
}

const m_ENOMEM = 12

func x_brk(tls *TLS, end uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOMEM))))
}

func x_capset(tls *TLS, a uintptr, b uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(126), int64(a), int64(b)))))
}

func x_capget(tls *TLS, a uintptr, b uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(125), int64(a), int64(b)))))
}

func x_chroot(tls *TLS, path uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(161), int64(path)))))
}

type Tktimex64 = struct {
	Fmodes     uint32
	F__ccgo4   uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	F__ccgo44  uint32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime_sec  int64
	Ftime_usec int64
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	F__ccgo116 uint32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

type Tktimex = struct {
	Fmodes     uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime_sec  int64
	Ftime_usec int64
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

func x_clock_adjtime(tls *TLS, clock_id Tclockid_t, utx uintptr) (r1 int32) {
	bp := tls.Alloc(208) /* tlsAllocs 208 maxValist 0 */
	defer tls.Free(208)
	var r int32
	var _ /* ktx at bp+0 */ Tktimex
	r = -int32(m_ENOSYS)
	if uint64(8) > uint64(8) {
		*(*Tktimex)(unsafe.Pointer(bp)) = Tktimex{Fmodes: (*Ttimex)(unsafe.Pointer(utx)).Fmodes, Foffset: (*Ttimex)(unsafe.Pointer(utx)).Foffset, Ffreq: (*Ttimex)(unsafe.Pointer(utx)).Ffreq, Fmaxerror: (*Ttimex)(unsafe.Pointer(utx)).Fmaxerror, Festerror: (*Ttimex)(unsafe.Pointer(utx)).Festerror, Fstatus: (*Ttimex)(unsafe.Pointer(utx)).Fstatus, Fconstant: (*Ttimex)(unsafe.Pointer(utx)).Fconstant, Fprecision: (*Ttimex)(unsafe.Pointer(utx)).Fprecision, Ftolerance: (*Ttimex)(unsafe.Pointer(utx)).Ftolerance, Ftime_sec: (*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_sec, Ftime_usec: (*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_usec, Ftick: (*Ttimex)(unsafe.Pointer(utx)).Ftick, Fppsfreq: (*Ttimex)(unsafe.Pointer(utx)).Fppsfreq, Fjitter: (*Ttimex)(unsafe.Pointer(utx)).Fjitter, Fshift: (*Ttimex)(unsafe.Pointer(utx)).Fshift, Fstabil: (*Ttimex)(unsafe.Pointer(utx)).Fstabil, Fjitcnt: (*Ttimex)(unsafe.Pointer(utx)).Fjitcnt, Fcalcnt: (*Ttimex)(unsafe.Pointer(utx)).Fcalcnt, Ferrcnt: (*Ttimex)(unsafe.Pointer(utx)).Ferrcnt, Fstbcnt: (*Ttimex)(unsafe.Pointer(utx)).Fstbcnt, Ftai: (*Ttimex)(unsafe.Pointer(utx)).Ftai}
		if clock_id == int32(m_CLOCK_REALTIME) {
			r = int32(___syscall1(tls, int64(159), int64(bp)))
		} else {
			r = int32(___syscall2(tls, int64(305), int64(clock_id), int64(bp)))
		}
		if r >= int32(0) {
			(*Ttimex)(unsafe.Pointer(utx)).Fmodes = (*(*Tktimex)(unsafe.Pointer(bp))).Fmodes
			(*Ttimex)(unsafe.Pointer(utx)).Foffset = (*(*Tktimex)(unsafe.Pointer(bp))).Foffset
			(*Ttimex)(unsafe.Pointer(utx)).Ffreq = (*(*Tktimex)(unsafe.Pointer(bp))).Ffreq
			(*Ttimex)(unsafe.Pointer(utx)).Fmaxerror = (*(*Tktimex)(unsafe.Pointer(bp))).Fmaxerror
			(*Ttimex)(unsafe.Pointer(utx)).Festerror = (*(*Tktimex)(unsafe.Pointer(bp))).Festerror
			(*Ttimex)(unsafe.Pointer(utx)).Fstatus = (*(*Tktimex)(unsafe.Pointer(bp))).Fstatus
			(*Ttimex)(unsafe.Pointer(utx)).Fconstant = (*(*Tktimex)(unsafe.Pointer(bp))).Fconstant
			(*Ttimex)(unsafe.Pointer(utx)).Fprecision = (*(*Tktimex)(unsafe.Pointer(bp))).Fprecision
			(*Ttimex)(unsafe.Pointer(utx)).Ftolerance = (*(*Tktimex)(unsafe.Pointer(bp))).Ftolerance
			(*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_sec = (*(*Tktimex)(unsafe.Pointer(bp))).Ftime_sec
			(*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_usec = (*(*Tktimex)(unsafe.Pointer(bp))).Ftime_usec
			(*Ttimex)(unsafe.Pointer(utx)).Ftick = (*(*Tktimex)(unsafe.Pointer(bp))).Ftick
			(*Ttimex)(unsafe.Pointer(utx)).Fppsfreq = (*(*Tktimex)(unsafe.Pointer(bp))).Fppsfreq
			(*Ttimex)(unsafe.Pointer(utx)).Fjitter = (*(*Tktimex)(unsafe.Pointer(bp))).Fjitter
			(*Ttimex)(unsafe.Pointer(utx)).Fshift = (*(*Tktimex)(unsafe.Pointer(bp))).Fshift
			(*Ttimex)(unsafe.Pointer(utx)).Fstabil = (*(*Tktimex)(unsafe.Pointer(bp))).Fstabil
			(*Ttimex)(unsafe.Pointer(utx)).Fjitcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fjitcnt
			(*Ttimex)(unsafe.Pointer(utx)).Fcalcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fcalcnt
			(*Ttimex)(unsafe.Pointer(utx)).Ferrcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Ferrcnt
			(*Ttimex)(unsafe.Pointer(utx)).Fstbcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fstbcnt
			(*Ttimex)(unsafe.Pointer(utx)).Ftai = (*(*Tktimex)(unsafe.Pointer(bp))).Ftai
		}
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	if clock_id == int32(m_CLOCK_REALTIME) {
		return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(159), int64(utx)))))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(305), int64(clock_id), int64(utx)))))
}

type Tcpu_set_t = struct {
	F__bits [16]uint64
}

type Tcpu_set_t1 = Tcpu_set_t

type Ttm1 = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
}

const _REG_R8 = 0
const _REG_R9 = 1
const _REG_R10 = 2
const _REG_R11 = 3
const _REG_R12 = 4
const _REG_R13 = 5
const _REG_R14 = 6
const _REG_R15 = 7
const _REG_RDI = 8
const _REG_RSI = 9
const _REG_RBP = 10
const _REG_RBX = 11
const _REG_RDX = 12
const _REG_RAX = 13
const _REG_RCX = 14
const _REG_RSP = 15
const _REG_RIP = 16
const _REG_EFL = 17
const _REG_CSGSFS = 18
const _REG_ERR = 19
const _REG_TRAPNO = 20
const _REG_OLDMASK = 21
const _REG_CR2 = 22

type Tgreg_t = int64

type Tgregset_t = [23]int64

type Tfpregset_t = uintptr

type T_fpstate = struct {
	Fcwd       uint16
	Fswd       uint16
	Fftw       uint16
	Ffop       uint16
	Frip       uint64
	Frdp       uint64
	Fmxcsr     uint32
	Fmxcr_mask uint32
	F_st       [8]struct {
		Fsignificand [4]uint16
		Fexponent    uint16
		Fpadding     [3]uint16
	}
	F_xmm [16]struct {
		Felement [4]uint32
	}
	Fpadding [24]uint32
}

type Tsigcontext = struct {
	Fr8          uint64
	Fr9          uint64
	Fr10         uint64
	Fr11         uint64
	Fr12         uint64
	Fr13         uint64
	Fr14         uint64
	Fr15         uint64
	Frdi         uint64
	Frsi         uint64
	Frbp         uint64
	Frbx         uint64
	Frdx         uint64
	Frax         uint64
	Frcx         uint64
	Frsp         uint64
	Frip         uint64
	Feflags      uint64
	Fcs          uint16
	Fgs          uint16
	Ffs          uint16
	F__pad0      uint16
	Ferr         uint64
	Ftrapno      uint64
	Foldmask     uint64
	Fcr2         uint64
	Ffpstate     uintptr
	F__reserved1 [8]uint64
}

type Tmcontext_t1 = struct {
	Fgregs       Tgregset_t
	Ffpregs      Tfpregset_t
	F__reserved1 [8]uint64
}

type Tucontext_t1 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t1
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

type Tucontext = Tucontext_t1

type Tsig_t = uintptr

type Tsighandler_t = uintptr

func x_clone(tls1 *TLS, func1 uintptr, stack uintptr, flags int32, arg uintptr, va uintptr) (r int32) {
	bp := tls1.Alloc(32) /* tlsAllocs 0 maxValist 3 */
	defer tls1.Free(32)
	var ap Tva_list
	var ctid uintptr
	var ptid uintptr
	var tls uintptr
	ap = va
	ptid = VaUintptr(&ap)
	tls = VaUintptr(&ap)
	ctid = VaUintptr(&ap)
	_ = ap
	return int32(x___syscall_ret(tls1, uint64(___clone(tls1, func1, stack, flags, arg, VaList(bp+8, ptid, tls, ctid)))))
}

func x_copy_file_range(tls *TLS, fd_in int32, off_in uintptr, fd_out int32, off_out uintptr, len1 Tsize_t, flags uint32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall6(tls, int64(326), int64(fd_in), int64(off_in), int64(fd_out), int64(off_out), int64(len1), int64(flags))))
}

type Tfsblkcnt_t = uint64

type Tfsfilcnt_t = uint64

type _EPOLL_EVENTS = int32

const ___EPOLL_DUMMY = 0

type Tepoll_data_t = struct {
	Ffd  [0]int32
	Fu32 [0]Tuint32_t
	Fu64 [0]Tuint64_t
	Fptr uintptr
}

type Tepoll_data = Tepoll_data_t

type Tepoll_event = struct {
	Fevents Tuint32_t
	Fdata   Tepoll_data_t
}

type Tucontext_t2 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

func x_epoll_create(tls *TLS, size int32) (r int32) {
	if size <= int32(0) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	return x_epoll_create1(tls, int32(0))
}

func x_epoll_create1(tls *TLS, flags int32) (r1 int32) {
	var r int32
	r = int32(___syscall1(tls, int64(291), int64(flags)))
	if r == -int32(m_ENOSYS) && !(flags != 0) {
		r = int32(___syscall1(tls, int64(213), int64(Int32FromInt32(1))))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_epoll_ctl(tls *TLS, fd int32, op int32, fd2 int32, ev uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(233), int64(fd), int64(op), int64(fd2), int64(ev)))))
}

func x_epoll_pwait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32, sigs uintptr) (r1 int32) {
	var r int32
	r = int32(x___syscall_cp(tls, int64(281), int64(fd), int64(ev), int64(cnt), int64(to), int64(sigs), int64(Int32FromInt32(65)/Int32FromInt32(8))))
	if r == -int32(m_ENOSYS) && !(sigs != 0) {
		r = int32(x___syscall_cp(tls, int64(232), int64(fd), int64(ev), int64(cnt), int64(to), int64(0), int64(0)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_epoll_wait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32) (r int32) {
	return x_epoll_pwait(tls, fd, ev, cnt, to, uintptr(0))
}

type Teventfd_t = uint64

func x_eventfd(tls *TLS, count uint32, flags int32) (r1 int32) {
	var r int32
	r = int32(___syscall2(tls, int64(290), int64(count), int64(flags)))
	if r == -int32(m_ENOSYS) && !(flags != 0) {
		r = int32(___syscall1(tls, int64(284), int64(count)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_eventfd_read(tls *TLS, fd int32, value uintptr) (r int32) {
	var v1 int32
	if uint64(8) == uint64(x_read(tls, fd, value, uint64(8))) {
		v1 = int32(0)
	} else {
		v1 = -int32(1)
	}
	return v1
}

func x_eventfd_write(tls *TLS, fd int32, _value Teventfd_t) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*Teventfd_t)(unsafe.Pointer(bp)) = _value
	var v1 int32
	if uint64(8) == uint64(x_write(tls, fd, bp, uint64(8))) {
		v1 = int32(0)
	} else {
		v1 = -int32(1)
	}
	return v1
}

func x_fallocate(tls *TLS, fd int32, mode int32, base Toff_t, len1 Toff_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(285), int64(fd), int64(mode), base, len1))))
}

type Tstatvfs = struct {
	Ff_bsize    uint64
	Ff_frsize   uint64
	Ff_blocks   Tfsblkcnt_t
	Ff_bfree    Tfsblkcnt_t
	Ff_bavail   Tfsblkcnt_t
	Ff_files    Tfsfilcnt_t
	Ff_ffree    Tfsfilcnt_t
	Ff_favail   Tfsfilcnt_t
	Ff_fsid     uint64
	Ff_flag     uint64
	Ff_namemax  uint64
	F__reserved [6]int32
}

type Tfsid_t = struct {
	F__val [2]int32
}

type T__fsid_t = Tfsid_t

type Tstatfs = struct {
	Ff_type    uint64
	Ff_bsize   uint64
	Ff_blocks  Tfsblkcnt_t
	Ff_bfree   Tfsblkcnt_t
	Ff_bavail  Tfsblkcnt_t
	Ff_files   Tfsfilcnt_t
	Ff_ffree   Tfsfilcnt_t
	Ff_fsid    Tfsid_t
	Ff_namelen uint64
	Ff_frsize  uint64
	Ff_flags   uint64
	Ff_spare   [4]uint64
}

type Tfanotify_event_metadata = struct {
	Fevent_len    uint32
	Fvers         uint8
	Freserved     uint8
	Fmetadata_len uint16
	Fmask         uint64
	Ffd           int32
	Fpid          int32
}

type Tfanotify_event_info_header = struct {
	Finfo_type uint8
	Fpad       uint8
	Flen1      uint16
}

type Tfanotify_event_info_fid = struct {
	Fhdr  Tfanotify_event_info_header
	Ffsid Tfsid_t
}

type Tfanotify_response = struct {
	Ffd       int32
	Fresponse uint32
}

func x_fanotify_init(tls *TLS, flags uint32, event_f_flags uint32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(300), int64(flags), int64(event_f_flags)))))
}

func x_fanotify_mark(tls *TLS, fanotify_fd int32, flags uint32, mask uint64, dfd int32, pathname uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(301), int64(fanotify_fd), int64(flags), int64(mask), int64(dfd), int64(pathname)))))
}

func x_flock(tls *TLS, fd int32, op int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(73), int64(fd), int64(op)))))
}

func x_getdents(tls *TLS, fd int32, buf uintptr, len1 Tsize_t) (r int32) {
	if len1 > uint64(m_INT_MAX) {
		len1 = uint64(m_INT_MAX)
	}
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(217), int64(fd), int64(buf), int64(len1)))))
}

func x_getrandom(tls *TLS, buf uintptr, buflen Tsize_t, flags uint32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(318), int64(buf), int64(buflen), int64(flags), int64(0), int64(0), int64(0))))
}

type Tucontext_t3 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t1
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

func x_gettid(tls *TLS) (r Tpid_t) {
	return (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid
}

type Tinotify_event = struct {
	Fwd     int32
	Fmask   Tuint32_t
	Fcookie Tuint32_t
	Flen1   Tuint32_t
}

func x_inotify_init(tls *TLS) (r int32) {
	return x_inotify_init1(tls, int32(0))
}

func x_inotify_init1(tls *TLS, flags int32) (r1 int32) {
	var r int32
	r = int32(___syscall1(tls, int64(294), int64(flags)))
	if r == -int32(m_ENOSYS) && !(flags != 0) {
		r = int32(___syscall0(tls, int64(253)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_inotify_add_watch(tls *TLS, fd int32, pathname uintptr, mask Tuint32_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(254), int64(fd), int64(pathname), int64(mask)))))
}

func x_inotify_rm_watch(tls *TLS, fd int32, wd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(255), int64(fd), int64(wd)))))
}

func x_ioperm(tls *TLS, from uint64, num uint64, turn_on int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(173), int64(from), int64(num), int64(turn_on)))))
}

func x_iopl(tls *TLS, level int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(172), int64(level)))))
}

func x_klogctl(tls *TLS, type1 int32, buf uintptr, len1 int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(103), int64(type1), int64(buf), int64(len1)))))
}

const m_MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8
const m_SA_ONSTACK = 134217728
const m_SA_RESTART = 268435456
const m_SIGSYNCCALL = 34

func _dummy_0(tls *TLS) {
}

var _barrier_sem Tsem_t

func _bcast_barrier(tls *TLS, s int32) {
	x_sem_post(tls, uintptr(unsafe.Pointer(&_barrier_sem)))
}

func x___membarrier(tls *TLS, cmd int32, flags int32) (r1 int32) {
	bp := tls.Alloc(280) /* tlsAllocs 280 maxValist 0 */
	defer tls.Free(280)
	var r int32
	var self Tpthread_t
	var td Tpthread_t
	var _ /* sa at bp+128 */ Tsigaction
	var _ /* set at bp+0 */ Tsigset_t
	r = int32(___syscall2(tls, int64(324), int64(cmd), int64(flags)))
	/* Emulate the private expedited command, which is needed by the
	 * dynamic linker for installation of dynamic TLS, for older
	 * kernels that lack the syscall. Unlike the syscall, this only
	 * synchronizes with threads of the process, not other processes
	 * sharing the VM, but such sharing is not a supported usage
	 * anyway. */
	if r != 0 && cmd == int32(m_MEMBARRIER_CMD_PRIVATE_EXPEDITED) && !(flags != 0) {
		self = ___get_tp(tls)
		x___block_app_sigs(tls, bp)
		x___tl_lock(tls)
		x_sem_init(tls, uintptr(unsafe.Pointer(&_barrier_sem)), int32(0), uint32(0))
		*(*Tsigaction)(unsafe.Pointer(bp + 128)) = Tsigaction{F__sa_handler: struct {
			Fsa_sigaction [0]uintptr
			Fsa_handler   uintptr
		}{Fsa_handler: __ccgo_fp(_bcast_barrier)}, Fsa_flags: Int32FromInt32(m_SA_RESTART) | Int32FromInt32(m_SA_ONSTACK)}
		x_memset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 128))).Fsa_mask)), -int32(1), uint64(128))
		if !(x___libc_sigaction(tls, int32(m_SIGSYNCCALL), bp+128, uintptr(0)) != 0) {
			for td = (*T__pthread)(unsafe.Pointer(self)).Fnext; td != self; td = (*T__pthread)(unsafe.Pointer(td)).Fnext {
				___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(td)).Ftid), int64(Int32FromInt32(34)))
			}
			for td = (*T__pthread)(unsafe.Pointer(self)).Fnext; td != self; td = (*T__pthread)(unsafe.Pointer(td)).Fnext {
				x_sem_wait(tls, uintptr(unsafe.Pointer(&_barrier_sem)))
			}
			r = int32(0)
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 128))).F__sa_handler)))) = UintptrFromInt32(1)
			x___libc_sigaction(tls, int32(m_SIGSYNCCALL), bp+128, uintptr(0))
		}
		x_sem_destroy(tls, uintptr(unsafe.Pointer(&_barrier_sem)))
		x___tl_unlock(tls)
		x___restore_sigs(tls, bp)
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x___membarrier_init(tls *TLS) {
	/* If membarrier is linked, attempt to pre-register to be able to use
	 * the private expedited command before the process becomes multi-
	 * threaded, since registering later has bad, potentially unbounded
	 * latency. This syscall should be essentially free, and it's arguably
	 * a mistake in the API design that registration was even required.
	 * For other commands, registration may impose some cost, so it's left
	 * to the application to do so if desired. Unfortunately this means
	 * library code initialized after the process becomes multi-threaded
	 * cannot use these features without accepting registration latency. */
	___syscall2(tls, int64(324), int64(Int32FromInt32(16)), int64(Int32FromInt32(0)))
}

func x_memfd_create(tls *TLS, name uintptr, flags uint32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(319), int64(name), int64(flags)))))
}

func x_mlock2(tls *TLS, addr uintptr, len1 Tsize_t, flags uint32) (r int32) {
	if flags == uint32(0) {
		return x_mlock(tls, addr, len1)
	}
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(325), int64(addr), int64(len1), int64(flags)))))
}

func x_init_module(tls *TLS, a uintptr, b uint64, c uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(175), int64(a), int64(b), int64(c)))))
}

func x_delete_module(tls *TLS, a uintptr, b uint32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(176), int64(a), int64(b)))))
}

func x_mount(tls *TLS, special uintptr, dir uintptr, fstype uintptr, flags uint64, data uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(165), int64(special), int64(dir), int64(fstype), int64(flags), int64(data)))))
}

func x_umount(tls *TLS, special uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(166), int64(special), int64(Int32FromInt32(0))))))
}

func x_umount2(tls *TLS, special uintptr, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(166), int64(special), int64(flags)))))
}

func x_name_to_handle_at(tls *TLS, dirfd int32, pathname uintptr, handle uintptr, mount_id uintptr, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(303), int64(dirfd), int64(pathname), int64(handle), int64(mount_id), int64(flags)))))
}

func x_open_by_handle_at(tls *TLS, mount_fd int32, handle uintptr, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(304), int64(mount_fd), int64(handle), int64(flags)))))
}

func x_personality(tls *TLS, persona uint64) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(135), int64(persona)))))
}

func x_pivot_root(tls *TLS, new1 uintptr, old uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(155), int64(new1), int64(old)))))
}

func x_ppoll(tls *TLS, fds uintptr, n Tnfds_t, to uintptr, mask uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+593, int32(13), uintptr(unsafe.Pointer(&___func__3)))
	}
	_ = v1 || Int32FromInt32(0) != 0 //TODO
	return r
}

var ___func__3 = [6]int8{'p', 'p', 'o', 'l', 'l'}

type Tprctl_mm_map = struct {
	Fstart_code  Tuint64_t
	Fend_code    Tuint64_t
	Fstart_data  Tuint64_t
	Fend_data    Tuint64_t
	Fstart_brk   Tuint64_t
	Fbrk         Tuint64_t
	Fstart_stack Tuint64_t
	Farg_start   Tuint64_t
	Farg_end     Tuint64_t
	Fenv_start   Tuint64_t
	Fenv_end     Tuint64_t
	Fauxv        uintptr
	Fauxv_size   Tuint32_t
	Fexe_fd      Tuint32_t
}

func x_prctl(tls *TLS, op int32, va uintptr) (r int32) {
	var ap Tva_list
	var i int32
	var x [4]uint64
	ap = va
	for i = int32(0); i < int32(4); i++ {
		x[i] = VaUint64(&ap)
	}
	_ = ap
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(157), int64(op), int64(x[int32(0)]), int64(x[int32(1)]), int64(x[int32(2)]), int64(x[int32(3)])))))
}

func x_prlimit(tls *TLS, pid Tpid_t, resource int32, new_limit uintptr, old_limit uintptr) (r1 int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var r int32
	var _ /* tmp at bp+0 */ Trlimit
	if new_limit != 0 && ^Uint64FromUint64(0) != ^Uint64FromUint64(0) {
		*(*Trlimit)(unsafe.Pointer(bp)) = *(*Trlimit)(unsafe.Pointer(new_limit))
		{
			if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur >= ^Uint64FromUint64(0) {
				(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = ^Uint64FromUint64(0)
			}
		}
		{
			if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max >= ^Uint64FromUint64(0) {
				(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max = ^Uint64FromUint64(0)
			}
		}
		new_limit = bp
	}
	r = int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(302), int64(pid), int64(resource), int64(new_limit), int64(old_limit)))))
	if !(r != 0) && old_limit != 0 && ^Uint64FromUint64(0) != ^Uint64FromUint64(0) {
		{
			if (*Trlimit)(unsafe.Pointer(old_limit)).Frlim_cur >= ^Uint64FromUint64(0) {
				(*Trlimit)(unsafe.Pointer(old_limit)).Frlim_cur = ^Uint64FromUint64(0)
			}
		}
		{
			if (*Trlimit)(unsafe.Pointer(old_limit)).Frlim_max >= ^Uint64FromUint64(0) {
				(*Trlimit)(unsafe.Pointer(old_limit)).Frlim_max = ^Uint64FromUint64(0)
			}
		}
	}
	return r
}

func x_process_vm_writev(tls *TLS, pid Tpid_t, lvec uintptr, liovcnt uint64, rvec uintptr, riovcnt uint64, flags uint64) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall6(tls, int64(311), int64(pid), int64(lvec), int64(liovcnt), int64(rvec), int64(riovcnt), int64(flags))))
}

func x_process_vm_readv(tls *TLS, pid Tpid_t, lvec uintptr, liovcnt uint64, rvec uintptr, riovcnt uint64, flags uint64) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall6(tls, int64(310), int64(pid), int64(lvec), int64(liovcnt), int64(rvec), int64(riovcnt), int64(flags))))
}

type T__ptrace_peeksiginfo_args = struct {
	Foff   Tuint64_t
	Fflags Tuint32_t
	Fnr    Tint32_t
}

type T__ptrace_seccomp_metadata = struct {
	Ffilter_off Tuint64_t
	Fflags      Tuint64_t
}

type T__ptrace_syscall_info = struct {
	Fop                  Tuint8_t
	F__pad               [3]Tuint8_t
	Farch                Tuint32_t
	Finstruction_pointer Tuint64_t
	Fstack_pointer       Tuint64_t
	F__ccgo5_24          struct {
		Fexit [0]struct {
			Frval        Tint64_t
			Fis_error    Tuint8_t
			F__ccgo_pad2 [7]byte
		}
		Fseccomp [0]struct {
			Fnr          Tuint64_t
			Fargs        [6]Tuint64_t
			Fret_data    Tuint32_t
			F__ccgo_pad3 [4]byte
		}
		Fentry struct {
			Fnr   Tuint64_t
			Fargs [6]Tuint64_t
		}
		F__ccgo_pad3 [8]byte
	}
}

type T__ptrace_rseq_configuration = struct {
	Frseq_abi_pointer Tuint64_t
	Frseq_abi_size    Tuint32_t
	Fsignature        Tuint32_t
	Fflags            Tuint32_t
	Fpad              Tuint32_t
}

func x_ptrace(tls *TLS, req int32, va uintptr) (r int64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var addr uintptr
	var addr2 uintptr
	var ap Tva_list
	var data uintptr
	var pid Tpid_t
	var ret int64
	var _ /* result at bp+0 */ int64
	addr2 = uintptr(0)
	ap = va
	pid = VaInt32(&ap)
	addr = VaUintptr(&ap)
	data = VaUintptr(&ap)
	/* PTRACE_{READ,WRITE}{DATA,TEXT} (16...19) are specific to SPARC. */
	_ = ap
	if uint32(req)-uint32(1) < uint32(3) {
		data = bp
	}
	ret = x___syscall_ret(tls, uint64(___syscall5(tls, int64(101), int64(req), int64(pid), int64(addr), int64(data), int64(addr2))))
	if ret < int64(0) || uint32(req)-uint32(1) >= uint32(3) {
		return ret
	}
	return *(*int64)(unsafe.Pointer(bp))
}

type Tdqblk = struct {
	Fdqb_bhardlimit Tuint64_t
	Fdqb_bsoftlimit Tuint64_t
	Fdqb_curspace   Tuint64_t
	Fdqb_ihardlimit Tuint64_t
	Fdqb_isoftlimit Tuint64_t
	Fdqb_curinodes  Tuint64_t
	Fdqb_btime      Tuint64_t
	Fdqb_itime      Tuint64_t
	Fdqb_valid      Tuint32_t
	F__ccgo_pad9    [4]byte
}

type Tdqinfo = struct {
	Fdqi_bgrace Tuint64_t
	Fdqi_igrace Tuint64_t
	Fdqi_flags  Tuint32_t
	Fdqi_valid  Tuint32_t
}

func x_quotactl(tls *TLS, cmd int32, special uintptr, id int32, addr uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(179), int64(cmd), int64(special), int64(id), int64(addr)))))
}

func x_readahead(tls *TLS, fd int32, pos Toff_t, len1 Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall3(tls, int64(187), int64(fd), pos, int64(len1))))
}

func x_reboot(tls *TLS, type1 int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(169), int64(Uint32FromUint32(0xfee1dead)), int64(Int32FromInt32(672274793)), int64(type1)))))
}

func x_remap_file_pages(tls *TLS, addr uintptr, size Tsize_t, prot int32, pgoff Tsize_t, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(216), int64(addr), int64(size), int64(prot), int64(pgoff), int64(flags)))))
}

func x_sbrk(tls *TLS, inc Tintptr_t) (r uintptr) {
	if inc != 0 {
		return uintptr(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOMEM))))
	}
	return uintptr(___syscall1(tls, int64(12), int64(Int32FromInt32(0))))
}

func x_sendfile(tls *TLS, out_fd int32, in_fd int32, ofs uintptr, count Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(40), int64(out_fd), int64(in_fd), int64(ofs), int64(count))))
}

func x_setfsgid(tls *TLS, gid Tgid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(123), int64(gid)))))
}

func x_setfsuid(tls *TLS, uid Tuid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(122), int64(uid)))))
}

type Tctx = struct {
	Fcount       Tsize_t
	Flist        uintptr
	Fret         int32
	F__ccgo_pad3 [4]byte
}

func _do_setgroups(tls *TLS, p uintptr) {
	var c uintptr
	var ret int32
	c = p
	if (*Tctx)(unsafe.Pointer(c)).Fret < int32(0) {
		return
	}
	ret = int32(___syscall2(tls, int64(116), int64((*Tctx)(unsafe.Pointer(c)).Fcount), int64((*Tctx)(unsafe.Pointer(c)).Flist)))
	if ret != 0 && !((*Tctx)(unsafe.Pointer(c)).Fret != 0) {
		/* If one thread fails to set groups after another has already
		 * succeeded, forcibly killing the process is the only safe
		 * thing to do. State is inconsistent and dangerous. Use
		 * SIGKILL because it is uncatchable. */
		x___block_all_sigs(tls, uintptr(0))
		___syscall2(tls, int64(62), ___syscall0(tls, int64(39)), int64(Int32FromInt32(9)))
	}
	(*Tctx)(unsafe.Pointer(c)).Fret = ret
}

func x_setgroups(tls *TLS, count Tsize_t, list uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* c at bp+0 */ Tctx
	/* ret is initially nonzero so that failure of the first thread does not
	 * trigger the safety kill above. */
	*(*Tctx)(unsafe.Pointer(bp)) = Tctx{Fcount: count, Flist: list, Fret: int32(1)}
	x___synccall(tls, __ccgo_fp(_do_setgroups), bp)
	return int32(x___syscall_ret(tls, uint64((*(*Tctx)(unsafe.Pointer(bp))).Fret)))
}

func x_sethostname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(170), int64(name), int64(len1)))))
}

func x_setns(tls *TLS, fd int32, nstype int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(308), int64(fd), int64(nstype)))))
}

func x_settimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	if !(tv != 0) {
		return int32(0)
	}
	if uint64((*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec) >= uint64(1000000) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	return x_clock_settime(tls, int32(m_CLOCK_REALTIME), uintptr(unsafe.Pointer(&Ttimespec{Ftv_sec: (*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec, Ftv_nsec: (*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec * int64(1000)})))
}

const m_O_NONBLOCK = 2048

type Tsignalfd_siginfo = struct {
	Fssi_signo     Tuint32_t
	Fssi_errno     Tint32_t
	Fssi_code      Tint32_t
	Fssi_pid       Tuint32_t
	Fssi_uid       Tuint32_t
	Fssi_fd        Tint32_t
	Fssi_tid       Tuint32_t
	Fssi_band      Tuint32_t
	Fssi_overrun   Tuint32_t
	Fssi_trapno    Tuint32_t
	Fssi_status    Tint32_t
	Fssi_int       Tint32_t
	Fssi_ptr       Tuint64_t
	Fssi_utime     Tuint64_t
	Fssi_stime     Tuint64_t
	Fssi_addr      Tuint64_t
	Fssi_addr_lsb  Tuint16_t
	F__pad2        Tuint16_t
	Fssi_syscall   Tint32_t
	Fssi_call_addr Tuint64_t
	Fssi_arch      Tuint32_t
	F__pad         [28]Tuint8_t
}

func x_signalfd(tls *TLS, fd int32, sigs uintptr, flags int32) (r int32) {
	var ret int32
	ret = int32(___syscall4(tls, int64(289), int64(fd), int64(sigs), int64(Int32FromInt32(65)/Int32FromInt32(8)), int64(flags)))
	if ret != -int32(m_ENOSYS) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	ret = int32(___syscall3(tls, int64(282), int64(fd), int64(sigs), int64(Int32FromInt32(65)/Int32FromInt32(8))))
	if ret >= int32(0) {
		if flags&int32(m_O_CLOEXEC) != 0 {
			___syscall3(tls, int64(72), int64(ret), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		}
		if flags&int32(m_O_NONBLOCK) != 0 {
			___syscall3(tls, int64(72), int64(ret), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
		}
	}
	return int32(x___syscall_ret(tls, uint64(ret)))
}

func x_splice(tls *TLS, fd_in int32, off_in uintptr, fd_out int32, off_out uintptr, len1 Tsize_t, flags uint32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall6(tls, int64(275), int64(fd_in), int64(off_in), int64(fd_out), int64(off_out), int64(len1), int64(flags))))
}

func x_stime(tls *TLS, t uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimeval
	*(*Ttimeval)(unsafe.Pointer(bp)) = Ttimeval{Ftv_sec: *(*Ttime_t)(unsafe.Pointer(t)), Ftv_usec: int64(0)}
	return x_settimeofday(tls, bp, UintptrFromInt32(0))
}

func x_swapon(tls *TLS, path uintptr, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(167), int64(path), int64(flags)))))
}

func x_swapoff(tls *TLS, path uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(168), int64(path)))))
}

func x_sync_file_range(tls *TLS, fd int32, pos Toff_t, len1 Toff_t, flags uint32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(277), int64(fd), pos, len1, int64(flags)))))
}

func x_syncfs(tls *TLS, fd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(306), int64(fd)))))
}

func x___lsysinfo(tls *TLS, info uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(99), int64(info)))))
}

func x_tee(tls *TLS, src int32, dest int32, len1 Tsize_t, flags uint32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(276), int64(src), int64(dest), int64(len1), int64(flags))))
}

func x_timerfd_create(tls *TLS, clockid int32, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(283), int64(clockid), int64(flags)))))
}

func x_timerfd_settime(tls *TLS, fd int32, flags int32, new1 uintptr, old uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(286), int64(fd), int64(flags), int64(new1), int64(old)))))
}

func x_timerfd_gettime(tls *TLS, fd int32, cur uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(287), int64(fd), int64(cur)))))
}

func x_unshare(tls *TLS, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(272), int64(flags)))))
}

func x_utimes(tls *TLS, path uintptr, times uintptr) (r int32) {
	return x___futimesat(tls, -int32(100), path, times)
}

func x_vhangup(tls *TLS) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall0(tls, int64(153)))))
}

func x_vmsplice(tls *TLS, fd int32, iov uintptr, cnt Tsize_t, flags uint32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(278), int64(fd), int64(iov), int64(cnt), int64(flags))))
}

type Tidtype_t = int32

const _P_ALL = 0
const _P_PID = 1
const _P_PGID = 2
const _P_PIDFD = 3

func x_wait3(tls *TLS, status uintptr, options int32, usage uintptr) (r Tpid_t) {
	return x_wait4(tls, -int32(1), status, options, usage)
}

func x_wait4(tls *TLS, pid Tpid_t, status uintptr, options int32, ru uintptr) (r1 Tpid_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var dest uintptr
	var r int32
	var _ /* kru at bp+0 */ [4]int64
	var v1 uintptr
	if ru != 0 {
		v1 = ru + 32 - uintptr(Uint64FromInt32(4)*Uint64FromInt64(8))
	} else {
		v1 = uintptr(0)
	}
	dest = v1
	r = int32(___syscall4(tls, int64(61), int64(pid), int64(status), int64(options), int64(dest)))
	if r > int32(0) && ru != 0 && uint64(8) > uint64(8) {
		x_memcpy(tls, bp, dest, Uint64FromInt32(4)*Uint64FromInt64(8))
		(*Trusage)(unsafe.Pointer(ru)).Fru_utime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(0)], Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)]}
		(*Trusage)(unsafe.Pointer(ru)).Fru_stime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)], Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)]}
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_getxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(191), int64(path), int64(name), int64(value), int64(size))))
}

func x_lgetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(192), int64(path), int64(name), int64(value), int64(size))))
}

func x_fgetxattr(tls *TLS, filedes int32, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall4(tls, int64(193), int64(filedes), int64(name), int64(value), int64(size))))
}

func x_listxattr(tls *TLS, path uintptr, list uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall3(tls, int64(194), int64(path), int64(list), int64(size))))
}

func x_llistxattr(tls *TLS, path uintptr, list uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall3(tls, int64(195), int64(path), int64(list), int64(size))))
}

func x_flistxattr(tls *TLS, filedes int32, list uintptr, size Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___syscall3(tls, int64(196), int64(filedes), int64(list), int64(size))))
}

func x_setxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(188), int64(path), int64(name), int64(value), int64(size), int64(flags)))))
}

func x_lsetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(189), int64(path), int64(name), int64(value), int64(size), int64(flags)))))
}

func x_fsetxattr(tls *TLS, filedes int32, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(190), int64(filedes), int64(name), int64(value), int64(size), int64(flags)))))
}

func x_removexattr(tls *TLS, path uintptr, name uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(197), int64(path), int64(name)))))
}

func x_lremovexattr(tls *TLS, path uintptr, name uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(198), int64(path), int64(name)))))
}

func x_fremovexattr(tls *TLS, fd int32, name uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(199), int64(fd), int64(name)))))
}

const m_LC_MESSAGES = 5

func _dummy7(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	return msg
}

func x___lctrans(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	return x___lctrans_impl(tls, msg, lm)
}

func x___lctrans_cur(tls *TLS, msg uintptr) (r uintptr) {
	return x___lctrans_impl(tls, msg, *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_MESSAGES)*8)))
}

func _swapc(tls *TLS, x Tuint32_t, c int32) (r Tuint32_t) {
	var v1 uint32
	if c != 0 {
		v1 = x>>int32(24) | x>>int32(8)&uint32(0xff00) | x<<int32(8)&uint32(0xff0000) | x<<int32(24)
	} else {
		v1 = x
	}
	return v1
}

func x___mo_lookup(tls *TLS, p uintptr, size Tsize_t, s uintptr) (r uintptr) {
	var b Tuint32_t
	var mo uintptr
	var n Tuint32_t
	var o Tuint32_t
	var ol Tuint32_t
	var os Tuint32_t
	var sign int32
	var sw int32
	var t Tuint32_t
	var tl Tuint32_t
	var ts Tuint32_t
	mo = p
	sw = int32(*(*Tuint32_t)(unsafe.Pointer(mo)) - uint32(0x950412de))
	b = uint32(0)
	n = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + UintptrFromInt32(2)*4)), sw)
	o = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + UintptrFromInt32(3)*4)), sw)
	t = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + UintptrFromInt32(4)*4)), sw)
	if uint64(n) >= size/uint64(4) || uint64(o) >= size-uint64(uint32(4)*n) || uint64(t) >= size-uint64(uint32(4)*n) || (o|t)%uint32(4) != 0 {
		return uintptr(0)
	}
	o = o / Uint32FromInt32(4)
	t = t / Uint32FromInt32(4)
	for {
		ol = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(o+Uint32FromInt32(2)*(b+n/Uint32FromInt32(2)))*4)), sw)
		os = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(o+Uint32FromInt32(2)*(b+n/Uint32FromInt32(2))+Uint32FromInt32(1))*4)), sw)
		if uint64(os) >= size || uint64(ol) >= size-uint64(os) || *(*int8)(unsafe.Pointer(p + uintptr(os+ol))) != 0 {
			return uintptr(0)
		}
		sign = x_strcmp(tls, s, p+uintptr(os))
		if !(sign != 0) {
			tl = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(t+Uint32FromInt32(2)*(b+n/Uint32FromInt32(2)))*4)), sw)
			ts = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(t+Uint32FromInt32(2)*(b+n/Uint32FromInt32(2))+Uint32FromInt32(1))*4)), sw)
			if uint64(ts) >= size || uint64(tl) >= size-uint64(ts) || *(*int8)(unsafe.Pointer(p + uintptr(ts+tl))) != 0 {
				return uintptr(0)
			}
			return p + uintptr(ts)
		} else {
			if n == uint32(1) {
				return uintptr(0)
			} else {
				if sign < int32(0) {
					n = n / Uint32FromInt32(2)
				} else {
					b = b + n/Uint32FromInt32(2)
					n = n - n/Uint32FromInt32(2)
				}
			}
		}
	}
	return uintptr(0)
}

func x_bind_textdomain_codeset(tls *TLS, domainname uintptr, codeset uintptr) (r uintptr) {
	if codeset != 0 && x_strcasecmp(tls, codeset, ts+611) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
	}
	return UintptrFromInt32(0)
}

var _empty_mo = [5]Tuint32_t{
	0: uint32(0x950412de),
	1: uint32(0),
	2: uint32(-Int32FromInt32(1)),
	3: uint32(-Int32FromInt32(1)),
	4: uint32(-Int32FromInt32(1))}

type Tnl_item = int32

type Tnl_catd = uintptr

func x_catclose(tls *TLS, catd Tnl_catd) (r int32) {
	var map1 uintptr
	map1 = catd
	x___munmap(tls, map1, uint64(___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(8))))+uint32(20)))
	return int32(0)
}

const m_ENOMSG = 42

func _cmp(tls *TLS, a uintptr, b uintptr) (r int32) {
	var x Tuint32_t
	var y Tuint32_t
	var v1 int32
	var v2 int32
	x = ___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(a)))
	y = ___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(b)))
	if x < y {
		v1 = -int32(1)
	} else {
		if x > y {
			v2 = int32(1)
		} else {
			v2 = int32(0)
		}
		v1 = v2
	}
	return v1
}

func x_catgets(tls *TLS, catd Tnl_catd, set_id int32, msg_id int32, s uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var map1 uintptr
	var msg uintptr
	var msgs uintptr
	var nmsgs Tuint32_t
	var nsets Tuint32_t
	var set uintptr
	var sets uintptr
	var strings uintptr
	var _ /* msg_id_be at bp+4 */ Tuint32_t
	var _ /* set_id_be at bp+0 */ Tuint32_t
	map1 = catd
	nsets = ___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(4))))
	sets = map1 + uintptr(20)
	msgs = map1 + uintptr(20) + uintptr(___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(12)))))
	strings = map1 + uintptr(20) + uintptr(___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(16)))))
	*(*Tuint32_t)(unsafe.Pointer(bp)) = ___bswap32(tls, uint32(set_id))
	*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = ___bswap32(tls, uint32(msg_id))
	set = x_bsearch(tls, bp, sets, uint64(nsets), uint64(12), __ccgo_fp(_cmp))
	if !(set != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMSG)
		return s
	}
	nmsgs = ___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(set + UintptrFromInt32(4))))
	msgs = msgs + uintptr(Uint32FromInt32(12)*___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(set + UintptrFromInt32(8)))))
	msg = x_bsearch(tls, bp+4, msgs, uint64(nmsgs), uint64(12), __ccgo_fp(_cmp))
	if !(msg != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMSG)
		return s
	}
	return strings + uintptr(___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(msg + UintptrFromInt32(8)))))
}

func _do_catopen(tls *TLS, name uintptr) (r Tnl_catd) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var map1 uintptr
	var _ /* size at bp+0 */ Tsize_t
	map1 = x___map_file(tls, name, bp)
	/* Size recorded in the file must match file size; otherwise
	 * the information needed to unmap the file will be lost. */
	if !(map1 != 0) || ___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1))) != uint32(0xff88ff89) || uint64(uint32(20)+___bswap32(tls, *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(8))))) != *(*Tsize_t)(unsafe.Pointer(bp)) {
		if map1 != 0 {
			x___munmap(tls, map1, *(*Tsize_t)(unsafe.Pointer(bp)))
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
		return uintptr(-Int32FromInt32(1))
	}
	return map1
}

func x_catopen(tls *TLS, name uintptr, oflag int32) (r Tnl_catd) {
	bp := tls.Alloc(4096) /* tlsAllocs 4096 maxValist 0 */
	defer tls.Free(4096)
	var catd Tnl_catd
	var i Tsize_t
	var l Tsize_t
	var lang uintptr
	var p uintptr
	var path uintptr
	var v uintptr
	var z uintptr
	var _ /* buf at bp+0 */ [4096]int8
	var v1 uintptr
	var v2 bool
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	if x_strchr(tls, name, int32('/')) != 0 {
		return _do_catopen(tls, name)
	}
	if v2 = x___libc.Fsecure != 0; !v2 {
		v1 = x_getenv(tls, ts+617)
		path = v1
	}
	if v2 || !(v1 != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
		return uintptr(-Int32FromInt32(1))
	}
	if oflag != 0 {
		v3 = x___nl_langinfo(tls, Int32FromInt32(5)<<Int32FromInt32(16)|Int32FromInt32(0xffff))
	} else {
		v3 = x_getenv(tls, ts+625)
	}
	lang = v3
	if !(lang != 0) {
		lang = ts
	}
	for p = path; *(*int8)(unsafe.Pointer(p)) != 0; p = z {
		i = uint64(0)
		z = x___strchrnul(tls, p, int32(':'))
		for ; p < z; p++ {
			if int32(*(*int8)(unsafe.Pointer(p))) != int32('%') {
				v = p
				l = Uint64FromInt32(1)
			} else {
				p++
				v4 = p
				switch int32(*(*int8)(unsafe.Pointer(v4))) {
				case int32('N'):
					v = name
					l = x_strlen(tls, v)
				case int32('L'):
					v = lang
					l = x_strlen(tls, v)
				case int32('l'):
					v = lang
					l = x_strcspn(tls, v, ts+630)
				case int32('t'):
					v = x___strchrnul(tls, lang, int32('_'))
					if *(*int8)(unsafe.Pointer(v)) != 0 {
						v++
					}
					l = x_strcspn(tls, v, ts+634)
				case int32('c'):
					v = ts + 611
					l = uint64(5)
				case int32('%'):
					v = ts + 637
					l = uint64(1)
				default:
					v = uintptr(0)
				}
			}
			if !(v != 0) || l >= uint64(4096)-i {
				break
			}
			x_memcpy(tls, bp+uintptr(i), v, l)
			i = i + l
		}
		if !(*(*int8)(unsafe.Pointer(z)) != 0) && (p < z || !(i != 0)) {
			break
		}
		if p < z {
			continue
		}
		if *(*int8)(unsafe.Pointer(z)) != 0 {
			z++
		}
		(*(*[4096]int8)(unsafe.Pointer(bp)))[i] = int8(0)
		/* Leading : or :: in NLSPATH is same as %N */
		if i != 0 {
			v5 = bp
		} else {
			v5 = name
		}
		catd = _do_catopen(tls, v5)
		if catd != uintptr(-Int32FromInt32(1)) {
			return catd
		}
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
	return uintptr(-Int32FromInt32(1))
}

type Tbinding = struct {
	Fnext       uintptr
	Fdirlen     int32
	Factive     int32
	Fdomainname uintptr
	Fdirname    uintptr
}

var _lock2 [1]int32

func x_bindtextdomain(tls *TLS, domainname uintptr, dirname uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(35), uintptr(unsafe.Pointer(&___func__4)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__4 = [15]int8{'b', 'i', 'n', 'd', 't', 'e', 'x', 't', 'd', 'o', 'm', 'a', 'i', 'n'}

type Tmsgcat = struct {
	Fnext        uintptr
	Fmap1        uintptr
	Fmap_size    Tsize_t
	Fplural_rule uintptr
	Fnplurals    int32
	Fbinding     uintptr
	Flm          uintptr
	Fcat         int32
	F__ccgo_pad8 [4]byte
}

func _dummy_gettextdomain(tls *TLS) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(51), uintptr(unsafe.Pointer(&___func__5)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__5 = [20]int8{'d', 'u', 'm', 'm', 'y', '_', 'g', 'e', 't', 't', 'e', 'x', 't', 'd', 'o', 'm', 'a', 'i', 'n'}

func x_dcngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64, category int32) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(58), uintptr(unsafe.Pointer(&___func__6)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__6 = [11]int8{'d', 'c', 'n', 'g', 'e', 't', 't', 'e', 'x', 't'}

func x_dcgettext(tls *TLS, domainname uintptr, msgid uintptr, category int32) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(63), uintptr(unsafe.Pointer(&___func__7)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__7 = [10]int8{'d', 'c', 'g', 'e', 't', 't', 'e', 'x', 't'}

func x_dngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(68), uintptr(unsafe.Pointer(&___func__8)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__8 = [10]int8{'d', 'n', 'g', 'e', 't', 't', 'e', 'x', 't'}

func x_dgettext(tls *TLS, domainname uintptr, msgid uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+639, int32(73), uintptr(unsafe.Pointer(&___func__9)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__9 = [9]int8{'d', 'g', 'e', 't', 't', 'e', 'x', 't'}

func x___duplocale(tls *TLS, old Tlocale_t) (r Tlocale_t) {
	var new1 Tlocale_t
	new1 = x___libc_malloc(tls, uint64(48))
	if !(new1 != 0) {
		return uintptr(0)
	}
	if old == uintptr(-Int32FromInt32(1)) {
		old = uintptr(unsafe.Pointer(&x___libc.Fglobal_locale))
	}
	*(*T__locale_struct)(unsafe.Pointer(new1)) = *(*T__locale_struct)(unsafe.Pointer(old))
	return new1
}

func x_freelocale(tls *TLS, l Tlocale_t) {
	if x___loc_is_allocated(tls, l) != 0 {
		x___libc_free(tls, l)
	}
}

type Ticonv_t = uintptr

type Tstateful_cd = struct {
	Fbase_cd     Ticonv_t
	Fstate       uint32
	F__ccgo_pad2 [4]byte
}

func x_iconv_open(tls *TLS, to uintptr, from uintptr) (r Ticonv_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+663, int32(41), uintptr(unsafe.Pointer(&___func__10)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__10 = [11]int8{'i', 'c', 'o', 'n', 'v', '_', 'o', 'p', 'e', 'n'}

func x_iconv(tls *TLS, cd Ticonv_t, in uintptr, inb uintptr, out uintptr, outb uintptr) (r Tsize_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+663, int32(51), uintptr(unsafe.Pointer(&___func__11)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__11 = [6]int8{'i', 'c', 'o', 'n', 'v'}

func x_iconv_close(tls *TLS, cd Ticonv_t) (r int32) {
	if !(uint64(cd)&Uint64FromInt32(1) != 0) {
		x_free(tls, cd)
	}
	return int32(0)
}

const m_CODESET = 14
const m_LC_ALL = 6
const m_LC_MONETARY = 4
const m_LC_NUMERIC = 1
const m_LC_TIME = 2

var _c_time = [314]int8{'S', 'u', 'n', 0, 'M', 'o', 'n', 0, 'T', 'u', 'e', 0, 'W', 'e', 'd', 0, 'T', 'h', 'u', 0, 'F', 'r', 'i', 0, 'S', 'a', 't', 0, 'S', 'u', 'n', 'd', 'a', 'y', 0, 'M', 'o', 'n', 'd', 'a', 'y', 0, 'T', 'u', 'e', 's', 'd', 'a', 'y', 0, 'W', 'e', 'd', 'n', 'e', 's', 'd', 'a', 'y', 0, 'T', 'h', 'u', 'r', 's', 'd', 'a', 'y', 0, 'F', 'r', 'i', 'd', 'a', 'y', 0, 'S', 'a', 't', 'u', 'r', 'd', 'a', 'y', 0, 'J', 'a', 'n', 0, 'F', 'e', 'b', 0, 'M', 'a', 'r', 0, 'A', 'p', 'r', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 0, 'J', 'u', 'l', 0, 'A', 'u', 'g', 0, 'S', 'e', 'p', 0, 'O', 'c', 't', 0, 'N', 'o', 'v', 0, 'D', 'e', 'c', 0, 'J', 'a', 'n', 'u', 'a', 'r', 'y', 0, 'F', 'e', 'b', 'r', 'u', 'a', 'r', 'y', 0, 'M', 'a', 'r', 'c', 'h', 0, 'A', 'p', 'r', 'i', 'l', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 'e', 0, 'J', 'u', 'l', 'y', 0, 'A', 'u', 'g', 'u', 's', 't', 0, 'S', 'e', 'p', 't', 'e', 'm', 'b', 'e', 'r', 0, 'O', 'c', 't', 'o', 'b', 'e', 'r', 0, 'N', 'o', 'v', 'e', 'm', 'b', 'e', 'r', 0, 'D', 'e', 'c', 'e', 'm', 'b', 'e', 'r', 0, 'A', 'M', 0, 'P', 'M', 0, '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, '%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p', 0, 0, 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 1, '2', '3', '4', '5', '6', '7', '8', '9', 0, '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S'}

var _c_messages = [19]int8{'^', '[', 'y', 'Y', ']', 0, '^', '[', 'n', 'N', ']', 0, 'y', 'e', 's', 0, 'n', 'o'}
var _c_numeric = [3]int8{'.'}

func x___nl_langinfo_l(tls *TLS, item Tnl_item, loc Tlocale_t) (r uintptr) {
	var cat int32
	var idx int32
	var str uintptr
	var v1 uintptr
	var v2 uintptr
	cat = item >> int32(16)
	idx = item & int32(65535)
	if item == int32(m_CODESET) {
		if *(*uintptr)(unsafe.Pointer(loc + UintptrFromInt32(m_LC_CTYPE)*8)) != 0 {
			v1 = ts + 611
		} else {
			v1 = ts + 682
		}
		return v1
	}
	/* _NL_LOCALE_NAME extension */
	if idx == int32(65535) && cat < int32(m_LC_ALL) {
		if *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)) != 0 {
			v2 = *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)) + 16
		} else {
			v2 = ts + 688
		}
		return v2
	}
	switch cat {
	case int32(m_LC_NUMERIC):
		if idx > int32(1) {
			return ts
		}
		str = uintptr(unsafe.Pointer(&_c_numeric))
	case int32(m_LC_TIME):
		if idx > int32(0x31) {
			return ts
		}
		str = uintptr(unsafe.Pointer(&_c_time))
	case int32(m_LC_MONETARY):
		if idx > int32(0) {
			return ts
		}
		str = ts
	case int32(m_LC_MESSAGES):
		if idx > int32(3) {
			return ts
		}
		str = uintptr(unsafe.Pointer(&_c_messages))
	default:
		return ts
	}
	for idx != 0 {
		for ; *(*int8)(unsafe.Pointer(str)) != 0; str++ {
		}
		goto _3
	_3:
		idx--
		str++
	}
	if cat != int32(m_LC_NUMERIC) && *(*int8)(unsafe.Pointer(str)) != 0 {
		str = x___lctrans(tls, str, *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)))
	}
	return str
}

func x___nl_langinfo(tls *TLS, item Tnl_item) (r uintptr) {
	return x___nl_langinfo_l(tls, item, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func x___lctrans_impl(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	var trans uintptr
	var v1 uintptr
	trans = uintptr(0)
	if lm != 0 {
		trans = x___mo_lookup(tls, (*T__locale_map)(unsafe.Pointer(lm)).Fmap1, (*T__locale_map)(unsafe.Pointer(lm)).Fmap_size, msg)
	}
	if trans != 0 {
		v1 = trans
	} else {
		v1 = msg
	}
	return v1
}

var _envvars = [6][12]int8{
	0: {'L', 'C', '_', 'C', 'T', 'Y', 'P', 'E'},
	1: {'L', 'C', '_', 'N', 'U', 'M', 'E', 'R', 'I', 'C'},
	2: {'L', 'C', '_', 'T', 'I', 'M', 'E'},
	3: {'L', 'C', '_', 'C', 'O', 'L', 'L', 'A', 'T', 'E'},
	4: {'L', 'C', '_', 'M', 'O', 'N', 'E', 'T', 'A', 'R', 'Y'},
	5: {'L', 'C', '_', 'M', 'E', 'S', 'S', 'A', 'G', 'E', 'S'}}

func x___get_locale(tls *TLS, cat int32, val uintptr) (r uintptr) {
	bp := tls.Alloc(264) /* tlsAllocs 264 maxValist 0 */
	defer tls.Free(264)
	var builtin int32
	var l Tsize_t
	var map1 uintptr
	var n Tsize_t
	var new1 uintptr
	var p uintptr
	var path uintptr
	var z uintptr
	var _ /* buf at bp+0 */ [256]int8
	var _ /* map_size at bp+256 */ Tsize_t
	var v1 uintptr
	var v2 uintptr
	var v3 bool
	var v4 uintptr
	var v5 bool
	var v6 uintptr
	var v7 bool
	var v8 uintptr
	var v9 bool
	new1 = uintptr(0)
	path = uintptr(0)
	if !(*(*int8)(unsafe.Pointer(val)) != 0) {
		v1 = x_getenv(tls, ts+690)
		val = v1
		if v3 = v1 != 0 && *(*int8)(unsafe.Pointer(val)) != 0; !v3 {
			v2 = x_getenv(tls, uintptr(unsafe.Pointer(&_envvars))+uintptr(cat)*12)
			val = v2
		}
		if v5 = v3 || v2 != 0 && *(*int8)(unsafe.Pointer(val)) != 0; !v5 {
			v4 = x_getenv(tls, ts+625)
			val = v4
		}
		if v7 = v5 || v4 != 0 && *(*int8)(unsafe.Pointer(val)) != 0; !v7 {
			v6 = ts + 697
			val = v6
		}
		_ = v7 || v6 != 0
	}
	/* Limit name length and forbid leading dot or any slashes. */
	for n = uint64(0); n < uint64(m_LOCALE_NAME_MAX) && *(*int8)(unsafe.Pointer(val + uintptr(n))) != 0 && int32(*(*int8)(unsafe.Pointer(val + uintptr(n)))) != int32('/'); n++ {
	}
	if int32(*(*int8)(unsafe.Pointer(val + UintptrFromInt32(0)))) == int32('.') || *(*int8)(unsafe.Pointer(val + uintptr(n))) != 0 {
		val = ts + 697
	}
	builtin = BoolInt32(int32(*(*int8)(unsafe.Pointer(val + UintptrFromInt32(0)))) == int32('C') && !(*(*int8)(unsafe.Pointer(val + UintptrFromInt32(1))) != 0) || !(x_strcmp(tls, val, ts+697) != 0) || !(x_strcmp(tls, val, ts+705) != 0))
	if builtin != 0 {
		if cat == int32(m_LC_CTYPE) && int32(*(*int8)(unsafe.Pointer(val + UintptrFromInt32(1)))) == int32('.') {
			return uintptr(unsafe.Pointer(&x___c_dot_utf8))
		}
		return uintptr(0)
	}
	for p = _loc_head; p != 0; p = (*T__locale_map)(unsafe.Pointer(p)).Fnext {
		if !(x_strcmp(tls, val, p+16) != 0) {
			return p
		}
	}
	if !(x___libc.Fsecure != 0) {
		path = x_getenv(tls, ts+711)
	}
	/* FIXME: add a default path? */
	if path != 0 {
		for ; *(*int8)(unsafe.Pointer(path)) != 0; path = z + BoolUintptr(!!(*(*int8)(unsafe.Pointer(z)) != 0)) {
			z = x___strchrnul(tls, path, int32(':'))
			l = uint64(int64(z) - int64(path))
			if l >= uint64(256)-n-uint64(2) {
				continue
			}
			x_memcpy(tls, bp, path, l)
			(*(*[256]int8)(unsafe.Pointer(bp)))[l] = int8('/')
			x_memcpy(tls, bp+uintptr(l)+uintptr(1), val, n)
			(*(*[256]int8)(unsafe.Pointer(bp)))[l+uint64(1)+n] = int8(0)
			map1 = x___map_file(tls, bp, bp+256)
			if map1 != 0 {
				new1 = x___libc_malloc(tls, uint64(48))
				if !(new1 != 0) {
					x___munmap(tls, map1, *(*Tsize_t)(unsafe.Pointer(bp + 256)))
					break
				}
				(*T__locale_map)(unsafe.Pointer(new1)).Fmap1 = map1
				(*T__locale_map)(unsafe.Pointer(new1)).Fmap_size = *(*Tsize_t)(unsafe.Pointer(bp + 256))
				x_memcpy(tls, new1+16, val, n)
				*(*int8)(unsafe.Pointer(new1 + 16 + uintptr(n))) = int8(0)
				(*T__locale_map)(unsafe.Pointer(new1)).Fnext = _loc_head
				_loc_head = new1
				break
			}
		}
	}
	/* If no locale definition was found, make a locale map
	 * object anyway to store the name, which is kept for the
	 * sake of being able to do message translations at the
	 * application level. */
	if v9 = !(new1 != 0); v9 {
		v8 = x___libc_malloc(tls, uint64(48))
		new1 = v8
	}
	if v9 && v8 != 0 {
		(*T__locale_map)(unsafe.Pointer(new1)).Fmap1 = x___c_dot_utf8.Fmap1
		(*T__locale_map)(unsafe.Pointer(new1)).Fmap_size = x___c_dot_utf8.Fmap_size
		x_memcpy(tls, new1+16, val, n)
		*(*int8)(unsafe.Pointer(new1 + 16 + uintptr(n))) = int8(0)
		(*T__locale_map)(unsafe.Pointer(new1)).Fnext = _loc_head
		_loc_head = new1
	}
	/* For LC_CTYPE, never return a null pointer unless the
	 * requested name was "C" or "POSIX". */
	if !(new1 != 0) && cat == int32(m_LC_CTYPE) {
		new1 = uintptr(unsafe.Pointer(&x___c_dot_utf8))
	}
	return new1
}

var _loc_head uintptr

const m_CHAR_MAX = 255

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _posix_lconv = Tlconv{Fdecimal_point: ts + 724, Fthousands_sep: ts, Fgrouping: ts, Fint_curr_symbol: ts, Fcurrency_symbol: ts, Fmon_decimal_point: ts, Fmon_thousands_sep: ts, Fmon_grouping: ts, Fpositive_sign: ts, Fnegative_sign: ts, Fint_frac_digits: Int8FromInt32(m_CHAR_MAX), Ffrac_digits: Int8FromInt32(m_CHAR_MAX), Fp_cs_precedes: Int8FromInt32(m_CHAR_MAX), Fp_sep_by_space: Int8FromInt32(m_CHAR_MAX), Fn_cs_precedes: Int8FromInt32(m_CHAR_MAX), Fn_sep_by_space: Int8FromInt32(m_CHAR_MAX), Fp_sign_posn: Int8FromInt32(m_CHAR_MAX), Fn_sign_posn: Int8FromInt32(m_CHAR_MAX), Fint_p_cs_precedes: Int8FromInt32(m_CHAR_MAX), Fint_p_sep_by_space: Int8FromInt32(m_CHAR_MAX), Fint_n_cs_precedes: Int8FromInt32(m_CHAR_MAX), Fint_n_sep_by_space: Int8FromInt32(m_CHAR_MAX), Fint_p_sign_posn: Int8FromInt32(m_CHAR_MAX), Fint_n_sign_posn: Int8FromInt32(m_CHAR_MAX)}

func x_localeconv(tls *TLS) (r uintptr) {
	return uintptr(unsafe.Pointer(&_posix_lconv))
}

var _default_locale_init_done int32
var _default_locale T__locale_struct
var _default_ctype_locale T__locale_struct

func x___loc_is_allocated(tls *TLS, loc Tlocale_t) (r int32) {
	return BoolInt32(loc != 0 && loc != uintptr(unsafe.Pointer(&x___c_locale)) && loc != uintptr(unsafe.Pointer(&x___c_dot_utf8_locale)) && loc != uintptr(unsafe.Pointer(&_default_locale)) && loc != uintptr(unsafe.Pointer(&_default_ctype_locale)))
}

func _do_newlocale(tls *TLS, mask int32, name uintptr, loc Tlocale_t) (r Tlocale_t) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxValist 0 */
	defer tls.Free(48)
	var i int32
	var i1 int32
	var _ /* tmp at bp+0 */ T__locale_struct
	var v1 uintptr
	var v2 uintptr
	var v3 Tlocale_t
	i = int32(0)
	for ; i < int32(m_LC_ALL); i++ {
		if !(mask&(Int32FromInt32(1)<<i) != 0) && loc != 0 {
			v1 = *(*uintptr)(unsafe.Pointer(loc + uintptr(i)*8))
		} else {
			if mask&(int32(1)<<i) != 0 {
				v2 = name
			} else {
				v2 = ts
			}
			v1 = x___get_locale(tls, i, v2)
		}
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*T__locale_struct)(unsafe.Pointer(bp))).Fcat)) + uintptr(i)*8)) = v1
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*T__locale_struct)(unsafe.Pointer(bp))).Fcat)) + uintptr(i)*8)) == uintptr(-Int32FromInt32(1)) {
			return uintptr(0)
		}
	}
	/* For locales with allocated storage, modify in-place. */
	if x___loc_is_allocated(tls, loc) != 0 {
		*(*T__locale_struct)(unsafe.Pointer(loc)) = *(*T__locale_struct)(unsafe.Pointer(bp))
		return loc
	}
	/* Otherwise, first see if we can use one of the builtin locales.
	 * This makes the common usage case for newlocale, getting a C locale
	 * with predictable behavior, very fast, and more importantly, fail-safe. */
	if !(x_memcmp(tls, bp, uintptr(unsafe.Pointer(&x___c_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&x___c_locale))
	}
	if !(x_memcmp(tls, bp, uintptr(unsafe.Pointer(&x___c_dot_utf8_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&x___c_dot_utf8_locale))
	}
	/* And provide builtins for the initial default locale, and a
	 * variant of the C locale honoring the default locale's encoding. */
	if !(_default_locale_init_done != 0) {
		i1 = int32(0)
		for ; i1 < int32(m_LC_ALL); i1++ {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_locale.Fcat)) + uintptr(i1)*8)) = x___get_locale(tls, i1, ts)
		}
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_ctype_locale.Fcat)) + UintptrFromInt32(m_LC_CTYPE)*8)) = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_locale.Fcat)) + UintptrFromInt32(m_LC_CTYPE)*8))
		_default_locale_init_done = int32(1)
	}
	if !(x_memcmp(tls, bp, uintptr(unsafe.Pointer(&_default_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&_default_locale))
	}
	if !(x_memcmp(tls, bp, uintptr(unsafe.Pointer(&_default_ctype_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&_default_ctype_locale))
	}
	/* If no builtin locale matched, attempt to allocate and copy. */
	v3 = x___libc_malloc(tls, uint64(48))
	loc = v3
	if v3 != 0 {
		*(*T__locale_struct)(unsafe.Pointer(loc)) = *(*T__locale_struct)(unsafe.Pointer(bp))
	}
	return loc
}

func x___newlocale(tls *TLS, mask int32, name uintptr, loc Tlocale_t) (r Tlocale_t) {
	x___lock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
	loc = _do_newlocale(tls, mask, name, loc)
	x___unlock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
	return loc
}

/*
grammar:

Start = Expr ';'
Expr  = Or | Or '?' Expr ':' Expr
Or    = And | Or '||' And
And   = Eq | And '&&' Eq
Eq    = Rel | Eq '==' Rel | Eq '!=' Rel
Rel   = Add | Rel '<=' Add | Rel '>=' Add | Rel '<' Add | Rel '>' Add
Add   = Mul | Add '+' Mul | Add '-' Mul
Mul   = Prim | Mul '*' Prim | Mul '/' Prim | Mul '%' Prim
Prim  = '(' Expr ')' | '!' Prim | decimal | 'n'

internals:

recursive descent expression evaluator with stack depth limit.
for binary operators an operator-precedence parser is used.
eval* functions store the result of the parsed subexpression
and return a pointer to the next non-space character.
*/

type Tst = struct {
	Fr           uint64
	Fn           uint64
	Fop          int32
	F__ccgo_pad3 [4]byte
}

func _skipspace(tls *TLS, s uintptr) (r uintptr) {
	for ___isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	return s
}

func _evalprim(tls *TLS, st uintptr, s uintptr, d int32) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* e at bp+0 */ uintptr
	var v1 int32
	d--
	v1 = d
	if v1 < int32(0) {
		return ts
	}
	s = _skipspace(tls, s)
	if BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		(*Tst)(unsafe.Pointer(st)).Fr = x_strtoul(tls, s, bp, int32(10))
		if *(*uintptr)(unsafe.Pointer(bp)) == s || (*Tst)(unsafe.Pointer(st)).Fr == uint64(-Int32FromInt32(1)) {
			return ts
		}
		return _skipspace(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	if int32(*(*int8)(unsafe.Pointer(s))) == int32('n') {
		(*Tst)(unsafe.Pointer(st)).Fr = (*Tst)(unsafe.Pointer(st)).Fn
		return _skipspace(tls, s+uintptr(1))
	}
	if int32(*(*int8)(unsafe.Pointer(s))) == int32('(') {
		s = _evalexpr(tls, st, s+uintptr(1), d)
		if int32(*(*int8)(unsafe.Pointer(s))) != int32(')') {
			return ts
		}
		return _skipspace(tls, s+uintptr(1))
	}
	if int32(*(*int8)(unsafe.Pointer(s))) == int32('!') {
		s = _evalprim(tls, st, s+uintptr(1), d)
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(!((*Tst)(unsafe.Pointer(st)).Fr != 0))
		return s
	}
	return ts
}

func _binop(tls *TLS, st uintptr, op int32, left uint64) (r int32) {
	var a uint64
	var b uint64
	a = left
	b = (*Tst)(unsafe.Pointer(st)).Fr
	switch op {
	case int32(0):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != 0 || b != 0)
		return int32(0)
	case int32(1):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != 0 && b != 0)
		return int32(0)
	case int32(2):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a == b)
		return int32(0)
	case int32(3):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != b)
		return int32(0)
	case int32(4):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a >= b)
		return int32(0)
	case int32(5):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a <= b)
		return int32(0)
	case int32(6):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a > b)
		return int32(0)
	case int32(7):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a < b)
		return int32(0)
	case int32(8):
		(*Tst)(unsafe.Pointer(st)).Fr = a + b
		return int32(0)
	case int32(9):
		(*Tst)(unsafe.Pointer(st)).Fr = a - b
		return int32(0)
	case int32(10):
		(*Tst)(unsafe.Pointer(st)).Fr = a * b
		return int32(0)
	case int32(11):
		if b != 0 {
			(*Tst)(unsafe.Pointer(st)).Fr = a % b
			return int32(0)
		}
		return int32(1)
	case int32(12):
		if b != 0 {
			(*Tst)(unsafe.Pointer(st)).Fr = a / b
			return int32(0)
		}
		return int32(1)
	}
	return int32(1)
}

func _parseop(tls *TLS, st uintptr, s uintptr) (r uintptr) {
	var i int32
	for i = int32(0); i < int32(11); i++ {
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(_opch[i]) {
			/* note: >,< are accepted with or without = */
			if i < int32(6) && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32(_opch2[i]) {
				(*Tst)(unsafe.Pointer(st)).Fop = i
				return s + uintptr(2)
			}
			if i >= int32(4) {
				(*Tst)(unsafe.Pointer(st)).Fop = i + int32(2)
				return s + uintptr(1)
			}
			break
		}
	}
	(*Tst)(unsafe.Pointer(st)).Fop = int32(13)
	return s
}

var _opch = [11]int8{'|', '&', '=', '!', '>', '<', '+', '-', '*', '%', '/'}

var _opch2 = [6]int8{'|', '&', '=', '=', '=', '='}

func _evalbinop(tls *TLS, st uintptr, s uintptr, minprec int32, d int32) (r uintptr) {
	var left uint64
	var op int32
	d--
	s = _evalprim(tls, st, s, d)
	s = _parseop(tls, st, s)
	for {
		/*
			st->r (left hand side value) and st->op are now set,
			get the right hand side or back out if op has low prec,
			if op was missing then prec[op]==0
		*/
		op = (*Tst)(unsafe.Pointer(st)).Fop
		if int32(_prec[op]) <= minprec {
			return s
		}
		left = (*Tst)(unsafe.Pointer(st)).Fr
		s = _evalbinop(tls, st, s, int32(_prec[op]), d)
		if _binop(tls, st, op, left) != 0 {
			return ts
		}
	}
	return r
}

var _prec = [14]int8{
	0:  int8(1),
	1:  int8(2),
	2:  int8(3),
	3:  int8(3),
	4:  int8(4),
	5:  int8(4),
	6:  int8(4),
	7:  int8(4),
	8:  int8(5),
	9:  int8(5),
	10: int8(6),
	11: int8(6),
	12: int8(6),
	13: int8(0)}

func _evalexpr(tls *TLS, st uintptr, s uintptr, d int32) (r uintptr) {
	var a uint64
	var b uint64
	var v1 int32
	var v2 uint64
	d--
	v1 = d
	if v1 < int32(0) {
		return ts
	}
	s = _evalbinop(tls, st, s, int32(0), d)
	if int32(*(*int8)(unsafe.Pointer(s))) != int32('?') {
		return s
	}
	a = (*Tst)(unsafe.Pointer(st)).Fr
	s = _evalexpr(tls, st, s+uintptr(1), d)
	if int32(*(*int8)(unsafe.Pointer(s))) != int32(':') {
		return ts
	}
	b = (*Tst)(unsafe.Pointer(st)).Fr
	s = _evalexpr(tls, st, s+uintptr(1), d)
	if a != 0 {
		v2 = b
	} else {
		v2 = (*Tst)(unsafe.Pointer(st)).Fr
	}
	(*Tst)(unsafe.Pointer(st)).Fr = v2
	return s
}

func x___pleval(tls *TLS, s uintptr, n uint64) (r uint64) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* st at bp+0 */ Tst
	var v1 uint64
	(*(*Tst)(unsafe.Pointer(bp))).Fn = n
	s = _evalexpr(tls, bp, s, int32(100))
	if int32(*(*int8)(unsafe.Pointer(s))) == int32(';') {
		v1 = (*(*Tst)(unsafe.Pointer(bp))).Fr
	} else {
		v1 = uint64(-Int32FromInt32(1))
	}
	return v1
}

var _buf1 [144]int8

func x_setlocale(tls *TLS, cat int32, name uintptr) (r uintptr) {
	bp := tls.Alloc(72) /* tlsAllocs 72 maxValist 0 */
	defer tls.Free(72)
	var i int32
	var l Tsize_t
	var lm uintptr
	var lm1 uintptr
	var p uintptr
	var part1 uintptr
	var ret uintptr
	var s uintptr
	var same int32
	var z uintptr
	var _ /* part at bp+48 */ [24]int8
	var _ /* tmp_locale at bp+0 */ T__locale_struct
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	if uint32(cat) > uint32(m_LC_ALL) {
		return uintptr(0)
	}
	x___lock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
	/* For LC_ALL, setlocale is required to return a string which
	 * encodes the current setting for all categories. The format of
	 * this string is unspecified, and only the following code, which
	 * performs both the serialization and deserialization, depends
	 * on the format, so it can easily be changed if needed. */
	if cat == int32(m_LC_ALL) {
		if name != 0 {
			*(*[24]int8)(unsafe.Pointer(bp + 48)) = [24]int8{'C', '.', 'U', 'T', 'F', '-', '8'}
			p = name
			for i = int32(0); i < int32(m_LC_ALL); i++ {
				z = x___strchrnul(tls, p, int32(';'))
				if int64(z)-int64(p) <= int64(m_LOCALE_NAME_MAX) {
					x_memcpy(tls, bp+48, p, uint64(int64(z)-int64(p)))
					(*(*[24]int8)(unsafe.Pointer(bp + 48)))[int64(z)-int64(p)] = int8(0)
					if *(*int8)(unsafe.Pointer(z)) != 0 {
						p = z + uintptr(1)
					}
				}
				lm = x___get_locale(tls, i, bp+48)
				if lm == uintptr(-Int32FromInt32(1)) {
					x___unlock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
					return uintptr(0)
				}
				*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*T__locale_struct)(unsafe.Pointer(bp))).Fcat)) + uintptr(i)*8)) = lm
			}
			x___libc.Fglobal_locale = *(*T__locale_struct)(unsafe.Pointer(bp))
		}
		s = uintptr(unsafe.Pointer(&_buf1))
		same = int32(0)
		for i = int32(0); i < int32(m_LC_ALL); i++ {
			lm1 = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___libc.Fglobal_locale.Fcat)) + uintptr(i)*8))
			if lm1 == *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___libc.Fglobal_locale.Fcat)) + UintptrFromInt32(0)*8)) {
				same++
			}
			if lm1 != 0 {
				v1 = lm1 + 16
			} else {
				v1 = ts + 688
			}
			part1 = v1
			l = x_strlen(tls, part1)
			x_memcpy(tls, s, part1, l)
			*(*int8)(unsafe.Pointer(s + uintptr(l))) = int8(';')
			s = s + uintptr(l+Uint64FromInt32(1))
		}
		s--
		v2 = s
		*(*int8)(unsafe.Pointer(v2)) = int8(0)
		x___unlock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
		if same == int32(m_LC_ALL) {
			v3 = part1
		} else {
			v3 = uintptr(unsafe.Pointer(&_buf1))
		}
		return v3
	}
	if name != 0 {
		lm = x___get_locale(tls, cat, name)
		if lm == uintptr(-Int32FromInt32(1)) {
			x___unlock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
			return uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___libc.Fglobal_locale.Fcat)) + uintptr(cat)*8)) = lm
	} else {
		lm = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___libc.Fglobal_locale.Fcat)) + uintptr(cat)*8))
	}
	if lm != 0 {
		v4 = lm + 16
	} else {
		v4 = ts + 688
	}
	ret = v4
	x___unlock(tls, uintptr(unsafe.Pointer(&x___locale_lock)))
	return ret
}

func x___strcoll_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	return x_strcmp(tls, l, r)
}

func x_strcoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	return x___strcoll_l(tls, l, r, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func x_strfmon_l(tls *TLS, s uintptr, n Tsize_t, loc Tlocale_t, fmt uintptr, va uintptr) (r Tssize_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+726, int32(11), uintptr(unsafe.Pointer(&___func__12)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__12 = [10]int8{'s', 't', 'r', 'f', 'm', 'o', 'n', '_', 'l'}

func x_strfmon(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r Tssize_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+726, int32(17), uintptr(unsafe.Pointer(&___func__13)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__13 = [8]int8{'s', 't', 'r', 'f', 'm', 'o', 'n'}

func x_strtof_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float32) {
	return x_strtof(tls, s, p)
}

func x_strtod_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	return x_strtod(tls, s, p)
}

func x_strtold_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	return x_strtold(tls, s, p)
}

// C documentation
//
//	/* collate only by code points */
func x___strxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	var l Tsize_t
	l = x_strlen(tls, src)
	if n > l {
		x_strcpy(tls, dest, src)
	}
	return l
}

func x_strxfrm(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r Tsize_t) {
	return x___strxfrm_l(tls, dest, src, n, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _current_domain uintptr

func x___gettextdomain(tls *TLS) (r uintptr) {
	var v1 uintptr
	if _current_domain != 0 {
		v1 = _current_domain
	} else {
		v1 = ts + 747
	}
	return v1
}

func x_textdomain(tls *TLS, domainname uintptr) (r uintptr) {
	var domlen Tsize_t
	if !(domainname != 0) {
		return x___gettextdomain(tls)
	}
	domlen = x_strlen(tls, domainname)
	if domlen > uint64(m_NAME_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	if !(_current_domain != 0) {
		_current_domain = _default_malloc(tls, uint64(Int32FromInt32(m_NAME_MAX)+Int32FromInt32(1)))
		if !(_current_domain != 0) {
			return uintptr(0)
		}
	}
	x_memcpy(tls, _current_domain, domainname, domlen+uint64(1))
	return _current_domain
}

func x_gettext(tls *TLS, msgid uintptr) (r uintptr) {
	return x_dgettext(tls, uintptr(0), msgid)
}

func x_ngettext(tls *TLS, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	return x_dngettext(tls, uintptr(0), msgid1, msgid2, n)
}

func x___uselocale(tls *TLS, new1 Tlocale_t) (r Tlocale_t) {
	var global Tlocale_t
	var old Tlocale_t
	var self Tpthread_t
	var v1 Tlocale_t
	var v2 Tlocale_t
	self = ___get_tp(tls)
	old = (*T__pthread)(unsafe.Pointer(self)).Flocale
	global = uintptr(unsafe.Pointer(&x___libc.Fglobal_locale))
	if new1 != 0 {
		if new1 == uintptr(-Int32FromInt32(1)) {
			v1 = global
		} else {
			v1 = new1
		}
		(*T__pthread)(unsafe.Pointer(self)).Flocale = v1
	}
	if old == global {
		v2 = uintptr(-Int32FromInt32(1))
	} else {
		v2 = old
	}
	return v2
}

// C documentation
//
//	/* FIXME: stub */
func x___wcscoll_l(tls *TLS, l uintptr, r uintptr, locale Tlocale_t) (r1 int32) {
	return x_wcscmp(tls, l, r)
}

func x_wcscoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	return x___wcscoll_l(tls, l, r, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

// C documentation
//
//	/* collate only by code points */
func x___wcsxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	var l Tsize_t
	l = x_wcslen(tls, src)
	if l < n {
		x_wmemcpy(tls, dest, src, l+uint64(1))
	} else {
		if n != 0 {
			x_wmemcpy(tls, dest, src, n-uint64(1))
			*(*Twchar_t)(unsafe.Pointer(dest + uintptr(n-Uint64FromInt32(1))*4)) = int32(0)
		}
	}
	return l
}

func x_wcsxfrm(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r Tsize_t) {
	return x___wcsxfrm_l(tls, dest, src, n, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func _mal0_clear(tls *TLS, p uintptr, n Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var pagesz Tsize_t
	var pp uintptr
	pagesz = uint64(4096) /* arbitrary */
	if n < pagesz {
		return n
	}
	pp = p + uintptr(n)
	i = uint64(pp) & (pagesz - uint64(1))
	for {
		pp = x_memset(tls, pp-uintptr(i), int32(0), i)
		if uint64(int64(pp)-int64(p)) < pagesz {
			return uint64(int64(pp) - int64(p))
		}
		for i = pagesz; i != 0; {
			if *(*uint64)(unsafe.Pointer(pp + uintptr(-Int32FromInt32(1))*8))|*(*uint64)(unsafe.Pointer(pp + uintptr(-Int32FromInt32(2))*8)) != 0 {
				break
			}
			goto _1
		_1:
			i = i - Uint64FromInt32(2)*Uint64FromInt64(8)
			pp = pp - uintptr(Uint64FromInt32(2)*Uint64FromInt64(8))
		}
	}
	return r
}

func _allzerop(tls *TLS, p uintptr) (r int32) {
	return int32(0)
}

func x_calloc(tls *TLS, m Tsize_t, n Tsize_t) (r uintptr) {
	var p uintptr
	if n != 0 && m > uint64(-Int32FromInt32(1))/n {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	n = n * m
	p = _default_malloc(tls, n)
	if !(p != 0) || !(x___malloc_replaced != 0) && x___malloc_allzerop(tls, p) != 0 {
		return p
	}
	n = _mal0_clear(tls, p, n)
	return x_memset(tls, p, int32(0), n)
}

func x_free(tls *TLS, p uintptr) {
	x___libc_free(tls, p)
}

func _mal0_clear1(tls *TLS, p uintptr, n Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var pagesz Tsize_t
	var pp uintptr
	pagesz = uint64(4096) /* arbitrary */
	if n < pagesz {
		return n
	}
	pp = p + uintptr(n)
	i = uint64(pp) & (pagesz - uint64(1))
	for {
		pp = x_memset(tls, pp-uintptr(i), int32(0), i)
		if uint64(int64(pp)-int64(p)) < pagesz {
			return uint64(int64(pp) - int64(p))
		}
		for i = pagesz; i != 0; {
			if *(*uint64)(unsafe.Pointer(pp + uintptr(-Int32FromInt32(1))*8))|*(*uint64)(unsafe.Pointer(pp + uintptr(-Int32FromInt32(2))*8)) != 0 {
				break
			}
			goto _1
		_1:
			i = i - Uint64FromInt32(2)*Uint64FromInt64(8)
			pp = pp - uintptr(Uint64FromInt32(2)*Uint64FromInt64(8))
		}
	}
	return r
}

func _allzerop1(tls *TLS, p uintptr) (r int32) {
	return int32(0)
}

func x___libc_calloc(tls *TLS, m Tsize_t, n Tsize_t) (r uintptr) {
	var p uintptr
	if n != 0 && m > uint64(-Int32FromInt32(1))/n {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	n = n * m
	p = x___libc_malloc(tls, n)
	if !(p != 0) || !(x___malloc_replaced != 0) && x___malloc_allzerop(tls, p) != 0 {
		return p
	}
	n = _mal0_clear1(tls, p, n)
	return x_memset(tls, p, int32(0), n)
}

const m_ALIGN = 16
const m_MAP_ANON = 32
const m_MAP_PRIVATE = 2
const m_PROT_READ = 1
const m_PROT_WRITE = 2

func _traverses_stack_p(tls *TLS, old Tuintptr_t, new1 Tuintptr_t) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var a Tuintptr_t
	var len1 Tuintptr_t
	var _ /* b at bp+0 */ Tuintptr_t
	var v1 uint64
	var v2 uint64
	len1 = uint64(Int32FromInt32(8) << Int32FromInt32(20))
	*(*Tuintptr_t)(unsafe.Pointer(bp)) = uint64(x___libc.Fauxv)
	if *(*Tuintptr_t)(unsafe.Pointer(bp)) > len1 {
		v1 = *(*Tuintptr_t)(unsafe.Pointer(bp)) - len1
	} else {
		v1 = uint64(0)
	}
	a = v1
	if new1 > a && old < *(*Tuintptr_t)(unsafe.Pointer(bp)) {
		return int32(1)
	}
	*(*Tuintptr_t)(unsafe.Pointer(bp)) = Tuintptr_t(bp)
	if *(*Tuintptr_t)(unsafe.Pointer(bp)) > len1 {
		v2 = *(*Tuintptr_t)(unsafe.Pointer(bp)) - len1
	} else {
		v2 = uint64(0)
	}
	a = v2
	if new1 > a && old < *(*Tuintptr_t)(unsafe.Pointer(bp)) {
		return int32(1)
	}
	return int32(0)
}

var _lock3 [1]int32

func ___simple_malloc(tls *TLS, n Tsize_t) (r uintptr) {
	var align Tsize_t
	var mem uintptr
	var min Tsize_t
	var new_area int32
	var p uintptr
	var req Tsize_t
	var v1 Tuintptr_t
	var v2 uintptr
	align = uint64(1)
	if n > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	if !(n != 0) {
		n++
	}
	for align < n && align < uint64(m_ALIGN) {
		align = align + align
	}
	x___lock(tls, uintptr(unsafe.Pointer(&_lock3)))
	_cur = _cur + -_cur&(align-Uint64FromInt32(1))
	if n > _end-_cur {
		req = (n - (_end - _cur) + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
		if !(_cur != 0) {
			_brk = uint64(___syscall1(tls, int64(12), int64(Int32FromInt32(0))))
			_brk = _brk + -_brk&uint64(Int32FromInt32(m_PAGESIZE)-Int32FromInt32(1))
			v1 = _brk
			_end = v1
			_cur = v1
		}
		if _brk == _end && req < uint64(0xffffffffffffffff)-_brk && !(_traverses_stack_p(tls, _brk, _brk+req) != 0) && uint64(___syscall1(tls, int64(12), int64(_brk+req))) == _brk+req {
			_end = _end + req
			_brk = _end
		} else {
			new_area = int32(0)
			req = (n + uint64(m_PAGESIZE) - uint64(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
			/* Only make a new area rather than individual mmap
			 * if wasted space would be over 1/8 of the map. */
			if req-n > req/uint64(8) {
				/* Geometric area size growth up to 64 pages,
				 * bounding waste by 1/8 of the area. */
				min = uint64(int32(m_PAGESIZE) << (_mmap_step / uint32(2)))
				if min-n > _end-_cur {
					if req < min {
						req = min
						if _mmap_step < uint32(12) {
							_mmap_step++
						}
					}
					new_area = int32(1)
				}
			}
			mem = x___mmap(tls, uintptr(0), req, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), int64(0))
			if mem == uintptr(-Int32FromInt32(1)) || !(new_area != 0) {
				x___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
				if mem == uintptr(-Int32FromInt32(1)) {
					v2 = uintptr(0)
				} else {
					v2 = mem
				}
				return v2
			}
			_cur = uint64(mem)
			_end = _cur + req
		}
	}
	p = uintptr(_cur)
	_cur = _cur + n
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
	return p
}

var _brk Tuintptr_t

var _cur Tuintptr_t

var _end Tuintptr_t

var _mmap_step uint32

func x___libc_malloc(tls *TLS, n Tsize_t) (r uintptr) {
	return x___libc_malloc_impl(tls, n)
}

func _default_malloc(tls *TLS, n Tsize_t) (r uintptr) {
	return x___libc_malloc_impl(tls, n)
}

const m_IB = 4
const m_UNIT = 16

type Tgroup = struct {
	Fmeta    uintptr
	F__ccgo8 uint8
	Fpad     [7]int8
}

type Tmeta = struct {
	Fprev       uintptr
	Fnext       uintptr
	Fmem        uintptr
	Favail_mask int32
	Ffreed_mask int32
	F__ccgo32   uint64
}

type Tmeta_area = struct {
	Fcheck  Tuint64_t
	Fnext   uintptr
	Fnslots int32
}

type Tmalloc_context = struct {
	Fsecret                Tuint64_t
	Finit_done             int32
	Fmmap_counter          uint32
	Ffree_meta_head        uintptr
	Favail_meta            uintptr
	Favail_meta_count      Tsize_t
	Favail_meta_area_count Tsize_t
	Fmeta_alloc_shift      Tsize_t
	Fmeta_area_head        uintptr
	Fmeta_area_tail        uintptr
	Favail_meta_areas      uintptr
	Factive                [48]uintptr
	Fusage_by_class        [48]Tsize_t
	Funmap_seq             [32]Tuint8_t
	Fbounces               [32]Tuint8_t
	Fseq                   Tuint8_t
	Fbrk                   Tuintptr_t
}

func x_aligned_alloc(tls *TLS, align Tsize_t, len1 Tsize_t) (r uintptr) {
	var adj Tsize_t
	var end uintptr
	var g uintptr
	var idx int32
	var offset Tuint32_t
	var p uintptr
	var start uintptr
	var stride Tsize_t
	if align&-align != align {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	if len1 > uint64(0xffffffffffffffff)-align || align >= Uint64FromUint64(1)<<Int32FromInt32(31)*Uint64FromInt32(m_UNIT) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	if x___malloc_replaced != 0 && !(x___aligned_alloc_replaced != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	if align <= uint64(m_UNIT) {
		align = uint64(m_UNIT)
	}
	p = x___libc_malloc_impl(tls, len1+align-uint64(m_UNIT))
	if !(p != 0) {
		return uintptr(0)
	}
	g = _get_meta(tls, p)
	idx = _get_slot_index(tls, p)
	stride = _get_stride(tls, g)
	start = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(stride*uint64(idx))
	end = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(stride*uint64(idx+Int32FromInt32(1))) - uintptr(m_IB)
	adj = -uint64(p) & (align - uint64(1))
	if !(adj != 0) {
		_set_size(tls, p, end, len1)
		return p
	}
	p = p + uintptr(adj)
	offset = uint32(uint64(int64(p)-Tptrdiff_t((*Tmeta)(unsafe.Pointer(g)).Fmem+16)) / uint64(m_UNIT))
	if offset <= uint32(0xffff) {
		*(*Tuint16_t)(unsafe.Pointer(p - UintptrFromInt32(2))) = uint16(offset)
		*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(4)))) = uint8(0)
	} else {
		// use a 32-bit offset if 16-bit doesn't fit. for this,
		// 16-bit field must be zero, [-4] byte nonzero.
		*(*Tuint16_t)(unsafe.Pointer(p - UintptrFromInt32(2))) = uint16(0)
		*(*Tuint32_t)(unsafe.Pointer(p - UintptrFromInt32(8))) = offset
		*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(4)))) = uint8(1)
	}
	*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(3)))) = uint8(idx)
	_set_size(tls, p, end, len1)
	// store offset to aligned enframing. this facilitates cycling
	// offset and also iteration of heap for debugging/measurement.
	// for extreme overalignment it won't fit but these are classless
	// allocations anyway.
	*(*Tuint16_t)(unsafe.Pointer(start - UintptrFromInt32(2))) = uint16(uint64(int64(p)-int64(start)) / uint64(m_UNIT))
	*(*uint8)(unsafe.Pointer(start + uintptr(-Int32FromInt32(3)))) = uint8(Int32FromInt32(7) << Int32FromInt32(5))
	return p
}

func _donate(tls *TLS, base uintptr, len1 Tsize_t) {
	var a Tuintptr_t
	var b Tuintptr_t
	var m uintptr
	var sc int32
	a = uint64(base)
	b = a + len1
	a = a + -a&uint64(Int32FromInt32(m_UNIT)-Int32FromInt32(1))
	b = b - b&uint64(Int32FromInt32(m_UNIT)-Int32FromInt32(1))
	x_memset(tls, base, int32(0), len1)
	sc = int32(47)
	for sc > int32(0) && b > a {
		if b-a < uint64((int32(x___malloc_size_classes[sc])+int32(1))*int32(m_UNIT)) {
			goto _1
		}
		m = x___malloc_alloc_meta(tls)
		(*Tmeta)(unsafe.Pointer(m)).Favail_mask = int32(0)
		(*Tmeta)(unsafe.Pointer(m)).Ffreed_mask = int32(1)
		(*Tmeta)(unsafe.Pointer(m)).Fmem = uintptr(a)
		(*Tgroup)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem)).Fmeta = m
		SetBitFieldPtr64Uint64(m+32, Uint64FromInt32(0), 0, 0x1f)
		SetBitFieldPtr64Uint64(m+32, Uint64FromInt32(0), 5, 0x20)
		SetBitFieldPtr64Uint64(m+32, uint64(sc), 6, 0xfc0)
		SetBitFieldPtr64Uint64(m+32, Uint64FromInt32(0), 12, 0xfffffffffffff000)
		*(*uint8)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem + UintptrFromInt32(m_UNIT) - UintptrFromInt32(4))) = uint8(0)
		*(*uint8)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem + UintptrFromInt32(m_UNIT) - UintptrFromInt32(3))) = uint8(255)
		*(*uint8)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem + 16 + uintptr(int32(x___malloc_size_classes[sc])*Int32FromInt32(m_UNIT)-Int32FromInt32(4)))) = uint8(0)
		_queue(tls, uintptr(unsafe.Pointer(&x___malloc_context.Factive))+uintptr(sc)*8, m)
		a = a + uint64((int32(x___malloc_size_classes[sc])+Int32FromInt32(1))*Int32FromInt32(m_UNIT))
		goto _1
	_1:
		sc = sc - Int32FromInt32(4)
	}
}

func x___malloc_donate(tls *TLS, start uintptr, end uintptr) {
	_donate(tls, start, uint64(int64(end)-int64(start)))
}

func x___libc_free(tls *TLS, p uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+756, int32(10), uintptr(unsafe.Pointer(&___func__14)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__14 = [12]int8{'_', '_', 'l', 'i', 'b', 'c', '_', 'f', 'r', 'e', 'e'}

const m_MAP_FIXED = 16
const m_MMAP_THRESHOLD = 131052
const m_PROT_NONE = 0
const m_RDLOCK_IS_EXCLUSIVE = 1
const m_SYS_brk = 12

func x___malloc_atfork(tls *TLS, who int32) {
	_malloc_atfork(tls, who)
}

var _small_cnt_tab = [9][3]Tuint8_t{
	0: {
		0: uint8(30),
		1: uint8(30),
		2: uint8(30)},
	1: {
		0: uint8(31),
		1: uint8(15),
		2: uint8(15)},
	2: {
		0: uint8(20),
		1: uint8(10),
		2: uint8(10)},
	3: {
		0: uint8(31),
		1: uint8(15),
		2: uint8(7)},
	4: {
		0: uint8(25),
		1: uint8(12),
		2: uint8(6)},
	5: {
		0: uint8(21),
		1: uint8(10),
		2: uint8(5)},
	6: {
		0: uint8(18),
		1: uint8(8),
		2: uint8(4)},
	7: {
		0: uint8(31),
		1: uint8(15),
		2: uint8(7)},
	8: {
		0: uint8(28),
		1: uint8(14),
		2: uint8(6)}}

var _med_cnt_tab = [4]Tuint8_t{
	0: uint8(28),
	1: uint8(24),
	2: uint8(20),
	3: uint8(32)}

func x___malloc_alloc_meta(tls *TLS) (r uintptr) {
	var m uintptr
	var n Tsize_t
	var need_guard int32
	var need_unprotect int32
	var new1 Tuintptr_t
	var p uintptr
	var pagesize Tsize_t
	var v1 uintptr
	var v3 int32
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var p2 uintptr
	if !(x___malloc_context.Finit_done != 0) {
		x___malloc_context.Fsecret = _get_random_secret(tls)
		x___malloc_context.Finit_done = int32(1)
	}
	pagesize = uint64(m_PAGESIZE)
	if pagesize < uint64(4096) {
		pagesize = uint64(4096)
	}
	v1 = _dequeue_head(tls, uintptr(unsafe.Pointer(&x___malloc_context.Ffree_meta_head)))
	m = v1
	if v1 != 0 {
		return m
	}
	if !(x___malloc_context.Favail_meta_count != 0) {
		need_unprotect = int32(1)
		if !(x___malloc_context.Favail_meta_area_count != 0) && x___malloc_context.Fbrk != uint64(-Int32FromInt32(1)) {
			new1 = x___malloc_context.Fbrk + pagesize
			need_guard = int32(0)
			if !(x___malloc_context.Fbrk != 0) {
				need_guard = int32(1)
				x___malloc_context.Fbrk = uint64(___syscall1(tls, int64(m_SYS_brk), int64(Int32FromInt32(0))))
				// some ancient kernels returned _ebss
				// instead of next page as initial brk.
				p2 = uintptr(unsafe.Pointer(&x___malloc_context.Fbrk))
				*(*Tuintptr_t)(unsafe.Pointer(p2)) = *(*Tuintptr_t)(unsafe.Pointer(p2)) + -x___malloc_context.Fbrk&(pagesize-Uint64FromInt32(1))
				new1 = x___malloc_context.Fbrk + uint64(2)*pagesize
			}
			if uint64(___syscall1(tls, int64(m_SYS_brk), int64(new1))) != new1 {
				x___malloc_context.Fbrk = uint64(-Int32FromInt32(1))
			} else {
				if need_guard != 0 {
					x___mmap(tls, uintptr(x___malloc_context.Fbrk), pagesize, int32(m_PROT_NONE), Int32FromInt32(m_MAP_ANON)|Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_FIXED), -int32(1), int64(0))
				}
				x___malloc_context.Fbrk = new1
				x___malloc_context.Favail_meta_areas = uintptr(new1 - pagesize)
				x___malloc_context.Favail_meta_area_count = pagesize >> int32(12)
				need_unprotect = int32(0)
			}
		}
		if !(x___malloc_context.Favail_meta_area_count != 0) {
			n = uint64(2) << x___malloc_context.Fmeta_alloc_shift
			p = x___mmap(tls, uintptr(0), n*pagesize, int32(m_PROT_NONE), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), int64(0))
			if p == uintptr(-Int32FromInt32(1)) {
				return uintptr(0)
			}
			x___malloc_context.Favail_meta_areas = p + uintptr(pagesize)
			x___malloc_context.Favail_meta_area_count = (n - uint64(1)) * (pagesize >> Int32FromInt32(12))
			x___malloc_context.Fmeta_alloc_shift++
		}
		p = x___malloc_context.Favail_meta_areas
		if uint64(p)&(pagesize-uint64(1)) != 0 {
			need_unprotect = int32(0)
		}
		if need_unprotect != 0 {
			if x___mprotect(tls, p, pagesize, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE)) != 0 && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOSYS) {
				return uintptr(0)
			}
		}
		x___malloc_context.Favail_meta_area_count--
		x___malloc_context.Favail_meta_areas = p + uintptr(4096)
		if x___malloc_context.Fmeta_area_tail != 0 {
			(*Tmeta_area)(unsafe.Pointer(x___malloc_context.Fmeta_area_tail)).Fnext = p
		} else {
			x___malloc_context.Fmeta_area_head = p
		}
		x___malloc_context.Fmeta_area_tail = p
		(*Tmeta_area)(unsafe.Pointer(x___malloc_context.Fmeta_area_tail)).Fcheck = x___malloc_context.Fsecret
		v3 = int32((Uint64FromInt32(4096) - Uint64FromInt64(24)) / Uint64FromInt64(40))
		(*Tmeta_area)(unsafe.Pointer(x___malloc_context.Fmeta_area_tail)).Fnslots = v3
		x___malloc_context.Favail_meta_count = uint64(v3)
		x___malloc_context.Favail_meta = x___malloc_context.Fmeta_area_tail + 24
	}
	x___malloc_context.Favail_meta_count--
	v5 = uintptr(unsafe.Pointer(&x___malloc_context.Favail_meta))
	v4 = *(*uintptr)(unsafe.Pointer(v5))
	*(*uintptr)(unsafe.Pointer(v5)) += 40
	m = v4
	v6 = UintptrFromInt32(0)
	(*Tmeta)(unsafe.Pointer(m)).Fnext = v6
	(*Tmeta)(unsafe.Pointer(m)).Fprev = v6
	return m
}

func _try_avail(tls *TLS, pm uintptr) (r Tuint32_t) {
	var cnt int32
	var first Tuint32_t
	var m uintptr
	var mask Tuint32_t
	var size int32
	var span int32
	var v1 bool
	m = *(*uintptr)(unsafe.Pointer(pm))
	if !(m != 0) {
		return uint32(0)
	}
	mask = uint32((*Tmeta)(unsafe.Pointer(m)).Favail_mask)
	if !(mask != 0) {
		if !(m != 0) {
			return uint32(0)
		}
		if !((*Tmeta)(unsafe.Pointer(m)).Ffreed_mask != 0) {
			_dequeue(tls, pm, m)
			m = *(*uintptr)(unsafe.Pointer(pm))
			if !(m != 0) {
				return uint32(0)
			}
		} else {
			m = (*Tmeta)(unsafe.Pointer(m)).Fnext
			*(*uintptr)(unsafe.Pointer(pm)) = m
		}
		mask = uint32((*Tmeta)(unsafe.Pointer(m)).Ffreed_mask)
		// skip fully-free group unless it's the only one
		// or it's a permanently non-freeable group
		if mask == uint32(2)<<int32(*(*uint64)(unsafe.Pointer(m + 32))&0x1f>>0)-uint32(1) && int32(*(*uint64)(unsafe.Pointer(m + 32))&0x20>>5) != 0 {
			m = (*Tmeta)(unsafe.Pointer(m)).Fnext
			*(*uintptr)(unsafe.Pointer(pm)) = m
			mask = uint32((*Tmeta)(unsafe.Pointer(m)).Ffreed_mask)
		}
		// activate more slots in a not-fully-active group
		// if needed, but only as a last resort. prefer using
		// any other group with free slots. this avoids
		// touching & dirtying as-yet-unused pages.
		if !(mask&(Uint32FromUint32(2)<<int32(*(*uint8)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem + 8))&0x1f>>0)-Uint32FromInt32(1)) != 0) {
			if (*Tmeta)(unsafe.Pointer(m)).Fnext != m {
				m = (*Tmeta)(unsafe.Pointer(m)).Fnext
				*(*uintptr)(unsafe.Pointer(pm)) = m
			} else {
				cnt = int32(*(*uint8)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem + 8))&0x1f>>0) + int32(2)
				size = int32(x___malloc_size_classes[int32(*(*uint64)(unsafe.Pointer(m + 32))&0xfc0>>6)]) * int32(m_UNIT)
				span = int32(m_UNIT) + size*cnt
				// activate up to next 4k boundary
				for span^(span+size-int32(1)) < int32(4096) {
					cnt++
					span = span + size
				}
				if cnt > int32(*(*uint64)(unsafe.Pointer(m + 32))&0x1f>>0)+int32(1) {
					cnt = int32(*(*uint64)(unsafe.Pointer(m + 32))&0x1f>>0) + int32(1)
				}
				SetBitFieldPtr8Uint8((*Tmeta)(unsafe.Pointer(m)).Fmem+8, uint8(cnt-Int32FromInt32(1)), 0, 0x1f)
			}
		}
		mask = _activate_group(tls, m)
		if v1 = mask != 0; !v1 {
			___assert_fail(tls, ts+783, ts+788, int32(165), uintptr(unsafe.Pointer(&___func__15)))
		}
		_ = v1 || Int32FromInt32(0) != 0
		_decay_bounces(tls, int32(*(*uint64)(unsafe.Pointer(m + 32))&0xfc0>>6))
	}
	first = mask & -mask
	(*Tmeta)(unsafe.Pointer(m)).Favail_mask = int32(mask - first)
	return first
}

var ___func__15 = [10]int8{'t', 'r', 'y', '_', 'a', 'v', 'a', 'i', 'l'}

func _alloc_group(tls *TLS, sc int32, req Tsize_t) (r uintptr) {
	var active_idx int32
	var cnt int32
	var g uintptr
	var i int32
	var i1 int32
	var idx int32
	var j int32
	var m uintptr
	var needed Tsize_t
	var nosmall int32
	var p uintptr
	var pagesize Tsize_t
	var size Tsize_t
	var usage Tsize_t
	var p1 uintptr
	size = uint64(int32(m_UNIT) * int32(x___malloc_size_classes[sc]))
	i = int32(0)
	m = x___malloc_alloc_meta(tls)
	if !(m != 0) {
		return uintptr(0)
	}
	usage = *(*Tsize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Fusage_by_class)) + uintptr(sc)*8))
	pagesize = uint64(m_PAGESIZE)
	if sc < int32(9) {
		for i < int32(2) && uint64(int32(4)*int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_small_cnt_tab)) + uintptr(sc)*3 + uintptr(i))))) > usage {
			i++
		}
		cnt = int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_small_cnt_tab)) + uintptr(sc)*3 + uintptr(i))))
	} else {
		// lookup max number of slots fitting in power-of-two size
		// from a table, along with number of factors of two we
		// can divide out without a remainder or reaching 1.
		cnt = int32(_med_cnt_tab[sc&int32(3)])
		// reduce cnt to avoid excessive eagar allocation.
		for !(cnt&Int32FromInt32(1) != 0) && uint64(int32(4)*cnt) > usage {
			cnt = cnt >> Int32FromInt32(1)
		}
		// data structures don't support groups whose slot offsets
		// in units don't fit in 16 bits.
		for size*uint64(cnt) >= uint64(Int32FromInt32(65536)*Int32FromInt32(m_UNIT)) {
			cnt = cnt >> Int32FromInt32(1)
		}
	}
	// If we selected a count of 1 above but it's not sufficient to use
	// mmap, increase to 2. Then it might be; if not it will nest.
	if cnt == int32(1) && size*uint64(cnt)+uint64(m_UNIT) <= pagesize/uint64(2) {
		cnt = int32(2)
	}
	// All choices of size*cnt are "just below" a power of two, so anything
	// larger than half the page size should be allocated as whole pages.
	if size*uint64(cnt)+uint64(m_UNIT) > pagesize/uint64(2) {
		// check/update bounce counter to start/increase retention
		// of freed maps, and inhibit use of low-count, odd-size
		// small mappings and single-slot groups if activated.
		nosmall = _is_bouncing(tls, sc)
		_account_bounce(tls, sc)
		_step_seq(tls)
		// since the following count reduction opportunities have
		// an absolute memory usage cost, don't overdo them. count
		// coarse usage as part of usage.
		if !(sc&Int32FromInt32(1) != 0) && sc < int32(32) {
			usage = usage + *(*Tsize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Fusage_by_class)) + uintptr(sc+Int32FromInt32(1))*8))
		}
		// try to drop to a lower count if the one found above
		// increases usage by more than 25%. these reduced counts
		// roughly fill an integral number of pages, just not a
		// power of two, limiting amount of unusable space.
		if uint64(int32(4)*cnt) > usage && !(nosmall != 0) {
			if !(int32(0) != 0) {
				if sc&int32(3) == int32(1) && size*uint64(cnt) > uint64(8)*pagesize {
					cnt = int32(2)
				} else {
					if sc&int32(3) == int32(2) && size*uint64(cnt) > uint64(4)*pagesize {
						cnt = int32(3)
					} else {
						if sc&int32(3) == int32(0) && size*uint64(cnt) > uint64(8)*pagesize {
							cnt = int32(3)
						} else {
							if sc&int32(3) == int32(0) && size*uint64(cnt) > uint64(2)*pagesize {
								cnt = int32(5)
							}
						}
					}
				}
			}
		}
		needed = size*uint64(cnt) + uint64(m_UNIT)
		needed = needed + -needed&(pagesize-Uint64FromInt32(1))
		// produce an individually-mmapped allocation if usage is low,
		// bounce counter hasn't triggered, and either it saves memory
		// or it avoids eagar slot allocation without wasting too much.
		if !(nosmall != 0) && cnt <= int32(7) {
			req = req + uint64(Int32FromInt32(m_IB)+Int32FromInt32(m_UNIT))
			req = req + -req&(pagesize-Uint64FromInt32(1))
			if req < size+uint64(m_UNIT) || req >= uint64(4)*pagesize && uint64(int32(2)*cnt) > usage {
				cnt = int32(1)
				needed = req
			}
		}
		p = x___mmap(tls, uintptr(0), needed, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), int64(0))
		if p == uintptr(-Int32FromInt32(1)) {
			_free_meta(tls, m)
			return uintptr(0)
		}
		SetBitFieldPtr64Uint64(m+32, needed>>Int32FromInt32(12), 12, 0xfffffffffffff000)
		x___malloc_context.Fmmap_counter++
		active_idx = int32(uint64(Int32FromInt32(4096)-Int32FromInt32(m_UNIT))/size - uint64(1))
		if active_idx > cnt-int32(1) {
			active_idx = cnt - int32(1)
		}
		if active_idx < int32(0) {
			active_idx = int32(0)
		}
	} else {
		j = _size_to_class(tls, uint64(m_UNIT)+uint64(cnt)*size-uint64(m_IB))
		idx = _alloc_slot(tls, j, uint64(m_UNIT)+uint64(cnt)*size-uint64(m_IB))
		if idx < int32(0) {
			_free_meta(tls, m)
			return uintptr(0)
		}
		g = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(j)*8))
		p = _enframe(tls, g, idx, uint64(int32(m_UNIT)*int32(x___malloc_size_classes[j])-int32(m_IB)), int32(x___malloc_context.Fmmap_counter))
		SetBitFieldPtr64Uint64(m+32, Uint64FromInt32(0), 12, 0xfffffffffffff000)
		*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(3)))) = uint8(int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(3)))))&int32(31) | Int32FromInt32(6)<<Int32FromInt32(5))
		i1 = int32(0)
		for ; i1 <= cnt; i1++ {
			*(*uint8)(unsafe.Pointer(p + uintptr(Uint64FromInt32(m_UNIT)+uint64(i1)*size-Uint64FromInt32(4)))) = uint8(0)
		}
		active_idx = cnt - int32(1)
	}
	p1 = uintptr(unsafe.Pointer(&x___malloc_context.Fusage_by_class)) + uintptr(sc)*8
	*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) + uint64(cnt)
	(*Tmeta)(unsafe.Pointer(m)).Favail_mask = int32(uint32(2)<<active_idx - uint32(1))
	(*Tmeta)(unsafe.Pointer(m)).Ffreed_mask = int32(uint32(2)<<(cnt-int32(1)) - uint32(1) - uint32((*Tmeta)(unsafe.Pointer(m)).Favail_mask))
	(*Tmeta)(unsafe.Pointer(m)).Fmem = p
	(*Tgroup)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(m)).Fmem)).Fmeta = m
	SetBitFieldPtr8Uint8((*Tmeta)(unsafe.Pointer(m)).Fmem+8, uint8(active_idx), 0, 0x1f)
	SetBitFieldPtr64Uint64(m+32, uint64(cnt-Int32FromInt32(1)), 0, 0x1f)
	SetBitFieldPtr64Uint64(m+32, Uint64FromInt32(1), 5, 0x20)
	SetBitFieldPtr64Uint64(m+32, uint64(sc), 6, 0xfc0)
	return m
}

func _alloc_slot(tls *TLS, sc int32, req Tsize_t) (r int32) {
	var first Tuint32_t
	var g uintptr
	first = _try_avail(tls, uintptr(unsafe.Pointer(&x___malloc_context.Factive))+uintptr(sc)*8)
	if first != 0 {
		return _a_ctz_32(tls, first)
	}
	g = _alloc_group(tls, sc, req)
	if !(g != 0) {
		return -int32(1)
	}
	(*Tmeta)(unsafe.Pointer(g)).Favail_mask--
	_queue(tls, uintptr(unsafe.Pointer(&x___malloc_context.Factive))+uintptr(sc)*8, g)
	return int32(0)
}

func x___libc_malloc_impl(tls *TLS, n Tsize_t) (r uintptr) {
	var ctr int32
	var first Tuint32_t
	var g uintptr
	var idx int32
	var mask Tuint32_t
	var needed Tsize_t
	var p uintptr
	var sc int32
	var usage Tsize_t
	var v1 bool
	var v2 int32
	var v3 int32
	var v4 bool
	var v5 bool
	if _size_overflows(tls, n) != 0 {
		return uintptr(0)
	}
	if n >= uint64(m_MMAP_THRESHOLD) {
		needed = n + uint64(m_IB) + uint64(m_UNIT)
		p = x___mmap(tls, uintptr(0), needed, Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), Int32FromInt32(m_MAP_PRIVATE)|Int32FromInt32(m_MAP_ANON), -int32(1), int64(0))
		if p == uintptr(-Int32FromInt32(1)) {
			return uintptr(0)
		}
		_wrlock(tls)
		_step_seq(tls)
		g = x___malloc_alloc_meta(tls)
		if !(g != 0) {
			if v1 = int32(0) != 0; !v1 {
				___assert_fail(tls, ts+207, ts+788, int32(318), uintptr(unsafe.Pointer(&___func__16)))
			}
			_ = v1 || Int32FromInt32(0) != 0
			// unlock();
			x___munmap(tls, p, needed)
			return uintptr(0)
		}
		(*Tmeta)(unsafe.Pointer(g)).Fmem = p
		(*Tgroup)(unsafe.Pointer((*Tmeta)(unsafe.Pointer(g)).Fmem)).Fmeta = g
		SetBitFieldPtr64Uint64(g+32, Uint64FromInt32(0), 0, 0x1f)
		SetBitFieldPtr64Uint64(g+32, Uint64FromInt32(1), 5, 0x20)
		SetBitFieldPtr64Uint64(g+32, Uint64FromInt32(63), 6, 0xfc0)
		SetBitFieldPtr64Uint64(g+32, (needed+Uint64FromInt32(4095))/Uint64FromInt32(4096), 12, 0xfffffffffffff000)
		v2 = Int32FromInt32(0)
		(*Tmeta)(unsafe.Pointer(g)).Ffreed_mask = v2
		(*Tmeta)(unsafe.Pointer(g)).Favail_mask = v2
		// use a global counter to cycle offset in
		// individually-mmapped allocations.
		x___malloc_context.Fmmap_counter++
		idx = int32(0)
		goto success
	}
	sc = _size_to_class(tls, n)
	_rdlock(tls)
	g = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc)*8))
	// use coarse size classes initially when there are not yet
	// any groups of desired size. this allows counts of 2 or 3
	// to be allocated at first rather than having to start with
	// 7 or 5, the min counts for even size classes.
	if !(g != 0) && sc >= int32(4) && sc < int32(32) && sc != int32(6) && !(sc&Int32FromInt32(1) != 0) && !(*(*Tsize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Fusage_by_class)) + uintptr(sc)*8)) != 0) {
		usage = *(*Tsize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Fusage_by_class)) + uintptr(sc|Int32FromInt32(1))*8))
		// if a new group may be allocated, count it toward
		// usage in deciding if we can use coarse class.
		if !(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc|Int32FromInt32(1))*8)) != 0) || !((*Tmeta)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc|Int32FromInt32(1))*8)))).Favail_mask != 0) && !((*Tmeta)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc|Int32FromInt32(1))*8)))).Ffreed_mask != 0) {
			usage = usage + Uint64FromInt32(3)
		}
		if usage <= uint64(12) {
			sc = sc | Int32FromInt32(1)
		}
		g = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc)*8))
	}
	for {
		if g != 0 {
			v3 = (*Tmeta)(unsafe.Pointer(g)).Favail_mask
		} else {
			v3 = int32(0)
		}
		mask = uint32(v3)
		first = mask & -mask
		if !(first != 0) {
			break
		}
		if int32(m_RDLOCK_IS_EXCLUSIVE) != 0 || !(x___libc.Fneed_locks != 0) {
			(*Tmeta)(unsafe.Pointer(g)).Favail_mask = int32(mask - first)
		} else {
			if uint32(_a_cas(tls, g+24, int32(mask), int32(mask-first))) != mask {
				continue
			}
		}
		idx = _a_ctz_32(tls, first)
		goto success
	}
	_upgradelock(tls)
	idx = _alloc_slot(tls, sc, n)
	if idx < int32(0) {
		if v4 = int32(0) != 0; !v4 {
			___assert_fail(tls, ts+207, ts+788, int32(373), uintptr(unsafe.Pointer(&___func__16)))
		}
		_ = v4 || Int32FromInt32(0) != 0
		//unlock();
		return uintptr(0)
	}
	g = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___malloc_context.Factive)) + uintptr(sc)*8))
success:
	ctr = int32(x___malloc_context.Fmmap_counter)
	if v5 = int32(0) != 0; !v5 {
		___assert_fail(tls, ts+207, ts+788, int32(381), uintptr(unsafe.Pointer(&___func__16)))
	}
	_ = v5 || Int32FromInt32(0) != 0
	// unlock();
	return _enframe(tls, g, idx, n, ctr)
}

var ___func__16 = [19]int8{'_', '_', 'l', 'i', 'b', 'c', '_', 'm', 'a', 'l', 'l', 'o', 'c', '_', 'i', 'm', 'p', 'l'}

func x___malloc_allzerop(tls *TLS, p uintptr) (r int32) {
	var g uintptr
	g = _get_meta(tls, p)
	return BoolInt32(int32(*(*uint64)(unsafe.Pointer(g + 32))&0xfc0>>6) >= int32(48) || _get_stride(tls, g) < uint64(int32(m_UNIT)*int32(x___malloc_size_classes[int32(*(*uint64)(unsafe.Pointer(g + 32))&0xfc0>>6)])))
}

func x_malloc_usable_size(tls *TLS, p uintptr) (r Tsize_t) {
	var end uintptr
	var g uintptr
	var idx int32
	var start uintptr
	var stride Tsize_t
	if !(p != 0) {
		return uint64(0)
	}
	g = _get_meta(tls, p)
	idx = _get_slot_index(tls, p)
	stride = _get_stride(tls, g)
	start = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(stride*uint64(idx))
	end = start + uintptr(stride) - uintptr(m_IB)
	return _get_nominal_size(tls, p, end)
}

const m_MREMAP_MAYMOVE = 1

func x___libc_realloc(tls *TLS, p uintptr, n Tsize_t) (r uintptr) {
	var avail_size Tsize_t
	var base Tsize_t
	var end uintptr
	var g uintptr
	var idx int32
	var needed Tsize_t
	var new1 uintptr
	var old_size Tsize_t
	var start uintptr
	var stride Tsize_t
	var v1 uintptr
	var v2 uint64
	if !(p != 0) {
		return x___libc_malloc_impl(tls, n)
	}
	if _size_overflows(tls, n) != 0 {
		return uintptr(0)
	}
	g = _get_meta(tls, p)
	idx = _get_slot_index(tls, p)
	stride = _get_stride(tls, g)
	start = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(stride*uint64(idx))
	end = start + uintptr(stride) - uintptr(m_IB)
	old_size = _get_nominal_size(tls, p, end)
	avail_size = uint64(int64(end) - int64(p))
	// only resize in-place if size class matches
	if n <= avail_size && n < uint64(m_MMAP_THRESHOLD) && _size_to_class(tls, n)+int32(1) >= int32(*(*uint64)(unsafe.Pointer(g + 32))&0xfc0>>6) {
		_set_size(tls, p, end, n)
		return p
	}
	// use mremap if old and new size are both mmap-worthy
	if int32(*(*uint64)(unsafe.Pointer(g + 32))&0xfc0>>6) >= int32(48) && n >= uint64(m_MMAP_THRESHOLD) {
		{
			if !(int32(*(*uint64)(unsafe.Pointer(g + 32))&0xfc0>>6) == Int32FromInt32(63)) {
				_a_crash(tls)
			}
		}
		base = uint64(int64(p) - int64(start))
		needed = (n + base + uint64(m_UNIT) + uint64(m_IB) + uint64(4095)) & uint64(-Int32FromInt32(4096))
		if *(*uint64)(unsafe.Pointer(g + 32))&0xfffffffffffff000>>12*uint64(4096)&0xfffffffffffff == needed {
			v1 = (*Tmeta)(unsafe.Pointer(g)).Fmem
		} else {
			v1 = x___mremap(tls, (*Tmeta)(unsafe.Pointer(g)).Fmem, *(*uint64)(unsafe.Pointer(g + 32))&0xfffffffffffff000>>12*uint64(4096)&0xfffffffffffff, needed, int32(m_MREMAP_MAYMOVE), 0)
		}
		new1 = v1
		if new1 != uintptr(-Int32FromInt32(1)) {
			(*Tmeta)(unsafe.Pointer(g)).Fmem = new1
			SetBitFieldPtr64Uint64(g+32, needed/Uint64FromInt32(4096), 12, 0xfffffffffffff000)
			p = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(base)
			end = (*Tmeta)(unsafe.Pointer(g)).Fmem + 16 + uintptr(needed-Uint64FromInt32(m_UNIT)) - uintptr(m_IB)
			*(*uint8)(unsafe.Pointer(end)) = uint8(0)
			_set_size(tls, p, end, n)
			return p
		}
	}
	new1 = x___libc_malloc_impl(tls, n)
	if !(new1 != 0) {
		return uintptr(0)
	}
	if n < old_size {
		v2 = n
	} else {
		v2 = old_size
	}
	x_memcpy(tls, new1, p, v2)
	x___libc_free(tls, p)
	return new1
}

func x_memalign(tls *TLS, align Tsize_t, len1 Tsize_t) (r uintptr) {
	return x_aligned_alloc(tls, align, len1)
}

func x_posix_memalign(tls *TLS, res uintptr, align Tsize_t, len1 Tsize_t) (r int32) {
	var mem uintptr
	if align < uint64(8) {
		return int32(m_EINVAL)
	}
	mem = x_aligned_alloc(tls, align, len1)
	if !(mem != 0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	*(*uintptr)(unsafe.Pointer(res)) = mem
	return int32(0)
}

func x_realloc(tls *TLS, p uintptr, n Tsize_t) (r uintptr) {
	return x___libc_realloc(tls, p, n)
}

func x_reallocarray(tls *TLS, ptr uintptr, m Tsize_t, n Tsize_t) (r uintptr) {
	if n != 0 && m > uint64(-Int32FromInt32(1))/n {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(0)
	}
	return x_realloc(tls, ptr, m*n)
}

var _C1 = float64(0.0416666666666666)                 /* 0x3FA55555, 0x5555554C */
var _C2 = -Float64FromFloat64(0.001388888888887411)   /* 0xBF56C16C, 0x16C15177 */
var _C3 = float64(2.480158728947673e-05)              /* 0x3EFA01A0, 0x19CB1590 */
var _C4 = -Float64FromFloat64(2.7557314351390663e-07) /* 0xBE927E4F, 0x809C52AD */
var _C5 = float64(2.087572321298175e-09)              /* 0x3E21EE9E, 0xBDB4B1C4 */
var _C6 = -Float64FromFloat64(1.1359647557788195e-11)

func x___cos(tls *TLS, x float64, y float64) (r1 float64) {
	var hz Tdouble_t
	var r Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	z = x * x
	w = z * z
	r = z*(_C1+z*(_C2+z*_C3)) + w*w*(_C4+z*(_C5+z*_C6))
	hz = float64(0.5) * z
	w = float64(1) - hz
	return w + (Float64FromFloat64(1) - w - hz + (z*r - x*y))
}

/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */

var _C0 = -Float64FromFloat64(0.499999997251031)     /* -0.499999997251031003120 */
var _C11 = float64(0.04166662332373906)              /*  0.0416666233237390631894 */
var _C21 = -Float64FromFloat64(0.001388676377460993) /* -0.00138867637746099294692 */
var _C31 = float64(2.439044879627741e-05)

func x___cosdf(tls *TLS, x float64) (r1 float32) {
	var r Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	/* Try to optimize for parallel evaluation as in __tandf.c. */
	z = x * x
	w = z * z
	r = _C21 + z*_C31
	return float32(float64(1) + z*_C0 + w*_C11 + w*z*r)
}

/* k is such that k*ln2 has minimal relative error and x - kln2 > log(DBL_MIN) */
var _k2 = int32(2043)
var _kln22 = float64(1416.0996898839683)

// C documentation
//
//	/* exp(x)/2 for x >= log(DBL_MAX), slightly better than 0.5*exp(x/2)*exp(x/2) */
func x___expo2(tls *TLS, x float64, sign float64) (r float64) {
	var scale float64
	/* note that k is odd and scale*scale overflows */
	{
		scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: uint64(uint32(Int32FromInt32(0x3ff)+_k2/Int32FromInt32(2))<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	/* exp(x - k ln2) * 2**(k-1) */
	/* in directed rounding correct sign before rounding or overflow is important */
	return x_exp(tls, x-_kln22) * (sign * scale) * scale
}

/* k is such that k*ln2 has minimal relative error and x - kln2 > log(FLT_MIN) */
var _k3 = int32(235)
var _kln23 = Float32FromFloat32(162.88958740234375)

// C documentation
//
//	/* expf(x)/2 for x >= log(FLT_MAX), slightly better than 0.5f*expf(x/2)*expf(x/2) */
func x___expo2f(tls *TLS, x float32, sign float32) (r float32) {
	var scale float32
	/* note that k is odd and scale*scale overflows */
	{
		scale = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: uint32(Int32FromInt32(0x7f)+_k3/Int32FromInt32(2)) << int32(23)}))))
	}
	/* exp(x - k ln2) * 2**(k-1) */
	/* in directed rounding correct sign before rounding or overflow is important */
	return x_expf(tls, x-_kln23) * (sign * scale) * scale
}

const m_FP_NORMAL = 4
const m_FP_SUBNORMAL = 3
const m_FP_ZERO = 2

func x___fpclassify(tls *TLS, x float64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 int32
	var v2 int32
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(e != 0) {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(m_FP_SUBNORMAL)
		} else {
			v1 = int32(m_FP_ZERO)
		}
		return v1
	}
	if e == int32(0x7ff) {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(12) != 0 {
			v2 = int32(m_FP_NAN)
		} else {
			v2 = int32(m_FP_INFINITE)
		}
		return v2
	}
	return int32(m_FP_NORMAL)
}

func x___fpclassifyf(tls *TLS, x float32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v1 int32
	var v2 int32
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(e != 0) {
		if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(m_FP_SUBNORMAL)
		} else {
			v1 = int32(m_FP_ZERO)
		}
		return v1
	}
	if e == int32(0xff) {
		if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(9) != 0 {
			v2 = int32(m_FP_NAN)
		} else {
			v2 = int32(m_FP_INFINITE)
		}
		return v2
	}
	return int32(m_FP_NORMAL)
}

func x___fpclassifyl(tls *TLS, x float64) (r int32) {
	return x___fpclassify(tls, x)
}

func x___math_divzero(tls *TLS, sign Tuint32_t) (r float64) {
	var v1 float64
	if sign != 0 {
		v1 = -Float64FromFloat64(1)
	} else {
		v1 = float64(1)
	}
	return _fp_barrier(tls, v1) / float64(0)
}

func x___math_divzerof(tls *TLS, sign Tuint32_t) (r float32) {
	var v1 float32
	if sign != 0 {
		v1 = -Float32FromFloat32(1)
	} else {
		v1 = Float32FromFloat32(1)
	}
	return _fp_barrierf(tls, v1) / Float32FromFloat32(0)
}

func x___math_invalid(tls *TLS, x float64) (r float64) {
	return (x - x) / (x - x)
}

func x___math_invalidf(tls *TLS, x float32) (r float32) {
	return (x - x) / (x - x)
}

func x___math_oflow(tls *TLS, sign Tuint32_t) (r float64) {
	return x___math_xflow(tls, sign, float64(3.105036184601418e+231))
}

func x___math_oflowf(tls *TLS, sign Tuint32_t) (r float32) {
	return x___math_xflowf(tls, sign, Float32FromFloat32(1.5845632502852868e+29))
}

func x___math_uflow(tls *TLS, sign Tuint32_t) (r float64) {
	return x___math_xflow(tls, sign, float64(1.2882297539194267e-231))
}

func x___math_uflowf(tls *TLS, sign Tuint32_t) (r float32) {
	return x___math_xflowf(tls, sign, Float32FromFloat32(2.524354896707238e-29))
}

func x___math_xflow(tls *TLS, sign Tuint32_t, y float64) (r float64) {
	var v1 float64
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return _eval_as_double(tls, _fp_barrier(tls, v1)*y)
}

func x___math_xflowf(tls *TLS, sign Tuint32_t, y float32) (r float32) {
	var v1 float32
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return _eval_as_float(tls, _fp_barrierf(tls, v1)*y)
}

/*
 * invpio2:  53 bits of 2/pi
 * pio2_1:   first  33 bit of pi/2
 * pio2_1t:  pi/2 - pio2_1
 * pio2_2:   second 33 bit of pi/2
 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
 * pio2_3:   third  33 bit of pi/2
 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
 */

var _toint = Float64FromFloat64(1.5) / Float64FromFloat64(2.220446049250313e-16)
var _pio4 = float64(0.7853981633974483)
var _invpio2 = float64(0.6366197723675814)     /* 0x3FE45F30, 0x6DC9C883 */
var _pio2_1 = float64(1.5707963267341256)      /* 0x3FF921FB, 0x54400000 */
var _pio2_1t = float64(6.077100506506192e-11)  /* 0x3DD0B461, 0x1A626331 */
var _pio2_2 = float64(6.077100506303966e-11)   /* 0x3DD0B461, 0x1A600000 */
var _pio2_2t = float64(2.0222662487959506e-21) /* 0x3BA3198A, 0x2E037073 */
var _pio2_3 = float64(2.0222662487111665e-21)  /* 0x3BA3198A, 0x2E000000 */
var _pio2_3t = float64(8.4784276603689e-32)    /* 0x397B839A, 0x252049C1 */

// C documentation
//
//	/* caller must handle the case when reduction is not needed: |x| ~<= pi/4 */
func x___rem_pio2(tls *TLS, x float64, y uintptr) (r1 int32) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxValist 0 */
	defer tls.Free(48)
	var ex int32
	var ey int32
	var fn Tdouble_t
	var i int32
	var ix Tuint32_t
	var n int32
	var r Tdouble_t
	var sign int32
	var t Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	var _ /* tx at bp+8 */ [3]float64
	var _ /* ty at bp+32 */ [2]float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v2 float64
	var p3 uintptr
	var p4 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if ix <= uint32(0x400f6a7a) {
		/* |x| ~<= 5pi/4 */
		if ix&uint32(0xfffff) == uint32(0x921fb) { /* |x| ~= pi/2 or 2pi/2 */
			goto medium
		} /* cancellation -- use medium case */
		if ix <= uint32(0x4002d97c) { /* |x| ~<= 3pi/4 */
			if !(sign != 0) {
				z = x - _pio2_1 /* one round good to 85 bits */
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z - _pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) - _pio2_1t
				return int32(1)
			} else {
				z = x + _pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z + _pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) + _pio2_1t
				return -int32(1)
			}
		} else {
			if !(sign != 0) {
				z = x - Float64FromInt32(2)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z - Float64FromInt32(2)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) - Float64FromInt32(2)*_pio2_1t
				return int32(2)
			} else {
				z = x + Float64FromInt32(2)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z + Float64FromInt32(2)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) + Float64FromInt32(2)*_pio2_1t
				return -int32(2)
			}
		}
	}
	if ix <= uint32(0x401c463b) {
		/* |x| ~<= 9pi/4 */
		if ix <= uint32(0x4015fdbc) { /* |x| ~<= 7pi/4 */
			if ix == uint32(0x4012d97c) { /* |x| ~= 3pi/2 */
				goto medium
			}
			if !(sign != 0) {
				z = x - Float64FromInt32(3)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z - Float64FromInt32(3)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) - Float64FromInt32(3)*_pio2_1t
				return int32(3)
			} else {
				z = x + Float64FromInt32(3)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z + Float64FromInt32(3)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) + Float64FromInt32(3)*_pio2_1t
				return -int32(3)
			}
		} else {
			if ix == uint32(0x401921fb) { /* |x| ~= 4pi/2 */
				goto medium
			}
			if !(sign != 0) {
				z = x - Float64FromInt32(4)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z - Float64FromInt32(4)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) - Float64FromInt32(4)*_pio2_1t
				return int32(4)
			} else {
				z = x + Float64FromInt32(4)*_pio2_1
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = z + Float64FromInt32(4)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = z - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) + Float64FromInt32(4)*_pio2_1t
				return -int32(4)
			}
		}
	}
	if !(ix < uint32(0x413921fb)) {
		goto _1
	} /* |x| ~< 2^20*(pi/2), medium size */
medium:
	/* rint(x/(pi/2)) */
	fn = x*_invpio2 + _toint - _toint
	n = int32(fn)
	r = x - fn*_pio2_1
	w = fn * _pio2_1t /* 1st round, good to 85 bits */
	/* Matters with directed rounding. */
	if ___builtin_expect(tls, BoolInt32(r-w < -_pio4), int32(0)) != 0 {
		n--
		fn--
		r = x - fn*_pio2_1
		w = fn * _pio2_1t
	} else {
		if ___builtin_expect(tls, BoolInt32(r-w > _pio4), int32(0)) != 0 {
			n++
			fn++
			r = x - fn*_pio2_1
			w = fn * _pio2_1t
		}
	}
	*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = r - w
	*(*float64)(unsafe.Pointer(bp)) = *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	ex = int32(ix >> int32(20))
	if ex-ey > int32(16) {
		/* 2nd round, good to 118 bits */
		t = r
		w = fn * _pio2_2
		r = t - w
		w = fn*_pio2_2t - (t - r - w)
		*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = r - w
		*(*float64)(unsafe.Pointer(bp)) = *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8))
		ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
		if ex-ey > int32(49) {
			/* 3rd round, good to 151 bits, covers all cases */
			t = r
			w = fn * _pio2_3
			r = t - w
			w = fn*_pio2_3t - (t - r - w)
			*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = r - w
		}
	}
	*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = r - *(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) - w
	return n
_1:
	/*
	 * all other (large) arguments
	 */
	if ix >= uint32(0x7ff00000) {
		/* x is inf or NaN */
		v2 = x - x
		*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = v2
		*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = v2
		return int32(0)
	}
	/* set z = scalbn(|x|,-ilogb(x)+23) */
	*(*float64)(unsafe.Pointer(bp)) = x
	p3 = bp
	*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) & (uint64(-Int32FromInt32(1)) >> Int32FromInt32(12))
	p4 = bp
	*(*Tuint64_t)(unsafe.Pointer(p4)) = *(*Tuint64_t)(unsafe.Pointer(p4)) | uint64(Int32FromInt32(0x3ff)+Int32FromInt32(23))<<Int32FromInt32(52)
	z = *(*float64)(unsafe.Pointer(bp))
	for i = int32(0); i < int32(2); i++ {
		(*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] = float64(int32(z))
		z = (z - (*(*[3]float64)(unsafe.Pointer(bp + 8)))[i]) * float64(1.6777216e+07)
	}
	(*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] = z
	/* skip zero terms, first term is non-zero */
	for (*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] == float64(0) {
		i--
	}
	n = x___rem_pio2_large(tls, bp+8, bp+32, int32(ix>>Int32FromInt32(20))-(Int32FromInt32(0x3ff)+Int32FromInt32(23)), i+int32(1), int32(1))
	if sign != 0 {
		*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = -(*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(0)]
		*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = -(*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(1)]
		return -n
	}
	*(*float64)(unsafe.Pointer(y + UintptrFromInt32(0)*8)) = (*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(0)]
	*(*float64)(unsafe.Pointer(y + UintptrFromInt32(1)*8)) = (*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(1)]
	return n
}

func x___rem_pio2_large(tls *TLS, x uintptr, y uintptr, e0 int32, nx int32, prec int32) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+817, int32(5), uintptr(unsafe.Pointer(&___func__17)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__17 = [17]int8{'_', '_', 'r', 'e', 'm', '_', 'p', 'i', 'o', '2', '_', 'l', 'a', 'r', 'g', 'e'}

/*
 * invpio2:  53 bits of 2/pi
 * pio2_1:   first 25 bits of pi/2
 * pio2_1t:  pi/2 - pio2_1
 */

var _toint1 = Float64FromFloat64(1.5) / Float64FromFloat64(2.220446049250313e-16)
var _pio41 = float64(0.7853981852531433)
var _invpio21 = float64(0.6366197723675814) /* 0x3FE45F30, 0x6DC9C883 */
var _pio2_11 = float64(1.5707963109016418)  /* 0x3FF921FB, 0x50000000 */
var _pio2_1t1 = float64(1.5893254773528196e-08)

func x___rem_pio2f(tls *TLS, x float32, y uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var e0 int32
	var fn Tdouble_t
	var ix Tuint32_t
	var n int32
	var sign int32
	var _ /* tx at bp+8 */ [1]float64
	var _ /* ty at bp+16 */ [1]float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	/* 25+53 bit pi is good enough for medium size */
	if ix < uint32(0x4dc90fdb) {
		/* |x| ~< 2^28*(pi/2), medium size */
		/* Use a specialized rint() to get fn. */
		fn = float64(x)*_invpio21 + _toint1 - _toint1
		n = int32(fn)
		*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
		/* Matters with directed rounding. */
		if ___builtin_expect(tls, BoolInt32(*(*float64)(unsafe.Pointer(y)) < -_pio41), int32(0)) != 0 {
			n--
			fn--
			*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
		} else {
			if ___builtin_expect(tls, BoolInt32(*(*float64)(unsafe.Pointer(y)) > _pio41), int32(0)) != 0 {
				n++
				fn++
				*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
			}
		}
		return n
	}
	if ix >= uint32(0x7f800000) {
		/* x is inf or NaN */
		*(*float64)(unsafe.Pointer(y)) = float64(x - x)
		return int32(0)
	}
	/* scale x into [2^23, 2^24-1] */
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	e0 = int32(ix>>Int32FromInt32(23) - uint32(Int32FromInt32(0x7f)+Int32FromInt32(23))) /* e0 = ilogb(|x|)-23, positive */
	*(*Tuint32_t)(unsafe.Pointer(bp)) = ix - uint32(e0<<Int32FromInt32(23))
	(*(*[1]float64)(unsafe.Pointer(bp + 8)))[int32(0)] = float64(*(*float32)(unsafe.Pointer(bp)))
	n = x___rem_pio2_large(tls, bp+8, bp+16, e0, int32(1), int32(0))
	if sign != 0 {
		*(*float64)(unsafe.Pointer(y)) = -(*(*[1]float64)(unsafe.Pointer(bp + 16)))[int32(0)]
		return -n
	}
	*(*float64)(unsafe.Pointer(y)) = (*(*[1]float64)(unsafe.Pointer(bp + 16)))[int32(0)]
	return n
}

// C documentation
//
//	// FIXME: macro in math.h
func x___signbit(tls *TLS, x float64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint64_t
		Fd float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	return int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
}

// C documentation
//
//	// FIXME: macro in math.h
func x___signbitf(tls *TLS, x float32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	return int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
}

func x___signbitl(tls *TLS, x float64) (r int32) {
	return x___signbit(tls, x)
}

var _S1 = -Float64FromFloat64(0.16666666666666632)    /* 0xBFC55555, 0x55555549 */
var _S2 = float64(0.00833333333332249)                /* 0x3F811111, 0x1110F8A6 */
var _S3 = -Float64FromFloat64(0.0001984126982985795)  /* 0xBF2A01A0, 0x19C161D5 */
var _S4 = float64(2.7557313707070068e-06)             /* 0x3EC71DE3, 0x57B1FE7D */
var _S5 = -Float64FromFloat64(2.5050760253406863e-08) /* 0xBE5AE5E6, 0x8A2B9CEB */
var _S6 = float64(1.58969099521155e-10)

func x___sin(tls *TLS, x float64, y float64, iy int32) (r1 float64) {
	var r Tdouble_t
	var v Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	z = x * x
	w = z * z
	r = _S2 + z*(_S3+z*_S4) + z*w*(_S5+z*_S6)
	v = z * x
	if iy == int32(0) {
		return x + v*(_S1+z*r)
	} else {
		return x - (z*(Float64FromFloat64(0.5)*y-v*r) - y - v*_S1)
	}
	return r1
}

/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */

var _S11 = -Float64FromFloat64(0.16666666641626524)    /* -0.166666666416265235595 */
var _S21 = float64(0.008333329385889463)               /*  0.0083333293858894631756 */
var _S31 = -Float64FromFloat64(0.00019839334836096632) /* -0.000198393348360966317347 */
var _S41 = float64(2.718311493989822e-06)

func x___sindf(tls *TLS, x float64) (r1 float32) {
	var r Tdouble_t
	var s Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	/* Try to optimize for parallel evaluation as in __tandf.c. */
	z = x * x
	w = z * z
	r = _S31 + z*_S41
	s = z * x
	return float32(x + s*(_S11+z*_S21) + s*w*r)
}

var _T = [13]float64{
						0:  float64(0.3333333333333341),
						1:  float64(0.13333333333320124),
						2:  float64(0.05396825397622605),
						3:  float64(0.021869488294859542),
						4:  float64(0.0088632398235993),
						5:  float64(0.0035920791075913124),
						6:  float64(0.0014562094543252903),
						7:  float64(0.0005880412408202641),
						8:  float64(0.0002464631348184699),
						9:  float64(7.817944429395571e-05),
						10: float64(7.140724913826082e-05),
						11: -Float64FromFloat64(1.8558637485527546e-05),
						12: float64(2.590730518636337e-05)}
var _pio42 = float64(0.7853981633974483) /* 3FE921FB, 54442D18 */
var _pio4lo = float64(3.061616997868383e-17)

func x___tan(tls *TLS, x float64, y float64, odd int32) (r1 float64) {
	var a Tdouble_t
	var a0 float64
	var big int32
	var hx Tuint32_t
	var r Tdouble_t
	var s Tdouble_t
	var sign int32
	var v Tdouble_t
	var w Tdouble_t
	var w0 float64
	var z Tdouble_t
	var v1 Tdouble_t
	var v2 Tdouble_t
	{
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	big = BoolInt32(hx&uint32(0x7fffffff) >= uint32(0x3FE59428)) /* |x| >= 0.6744 */
	if big != 0 {
		sign = int32(hx >> int32(31))
		if sign != 0 {
			x = -x
			y = -y
		}
		x = _pio42 - x + (_pio4lo - y)
		y = float64(0)
	}
	z = x * x
	w = z * z
	/*
	 * Break x^5*(T[1]+x^2*T[2]+...) into
	 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = _T[int32(1)] + w*(_T[int32(3)]+w*(_T[int32(5)]+w*(_T[int32(7)]+w*(_T[int32(9)]+w*_T[int32(11)]))))
	v = z * (_T[int32(2)] + w*(_T[int32(4)]+w*(_T[int32(6)]+w*(_T[int32(8)]+w*(_T[int32(10)]+w*_T[int32(12)])))))
	s = z * x
	r = y + z*(s*(r+v)+y) + s*_T[int32(0)]
	w = x + r
	if big != 0 {
		s = float64(int32(1) - int32(2)*odd)
		v = s - float64(2)*(x+(r-w*w/(w+s)))
		if sign != 0 {
			v1 = -v
		} else {
			v1 = v
		}
		return v1
	}
	if !(odd != 0) {
		return w
	}
	/* -1.0/(x+r) has up to 2ulp error, so compute it accurately */
	w0 = w
	{
		w0 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: w0}))))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	v = r - (w0 - x) /* w0+v = r+x */
	v2 = -Float64FromFloat64(1) / w
	a = v2
	a0 = v2
	{
		a0 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: a0}))))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	return a0 + a*(Float64FromFloat64(1)+a0*w0+a0*v)
}

/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */
var _T1 = [6]float64{
	0: float64(0.3333313950307914),
	1: float64(0.13339200271297674),
	2: float64(0.05338123784456704),
	3: float64(0.024528318116654728),
	4: float64(0.002974357433599673),
	5: float64(0.009465647849436732)}

func x___tandf(tls *TLS, x float64, odd int32) (r1 float32) {
	var r Tdouble_t
	var s Tdouble_t
	var t Tdouble_t
	var u Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	var v1 float64
	z = x * x
	/*
	 * Split up the polynomial into small independent terms to give
	 * opportunities for parallel evaluation.  The chosen splitting is
	 * micro-optimized for Athlons (XP, X64).  It costs 2 multiplications
	 * relative to Horner's method on sequential machines.
	 *
	 * We add the small terms from lowest degree up for efficiency on
	 * non-sequential machines (the lowest degree terms tend to be ready
	 * earlier).  Apart from this, we don't care about order of
	 * operations, and don't need to to care since we have precision to
	 * spare.  However, the chosen splitting is good for accuracy too,
	 * and would give results as accurate as Horner's method if the
	 * small terms were added from highest degree down.
	 */
	r = _T1[int32(4)] + z*_T1[int32(5)]
	t = _T1[int32(2)] + z*_T1[int32(3)]
	w = z * z
	s = z * x
	u = _T1[int32(0)] + z*_T1[int32(1)]
	r = x + s*u + s*w*(t+w*r)
	if odd != 0 {
		v1 = -Float64FromFloat64(1) / r
	} else {
		v1 = r
	}
	return float32(v1)
}

var _pio2_hi = float64(1.5707963267948966)          /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo = float64(6.123233995736766e-17)       /* 0x3C91A626, 0x33145C07 */
var _pS0 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS1 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS2 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS3 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS4 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS5 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS1 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS2 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS3 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS4 = float64(0.07703815055590194)

func _R(tls *TLS, z float64) (r float64) {
	var p Tdouble_t
	var q Tdouble_t
	p = z * (_pS0 + z*(_pS1+z*(_pS2+z*(_pS3+z*(_pS4+z*_pS5)))))
	q = float64(1) + z*(_qS1+z*(_qS2+z*(_qS3+z*_qS4)))
	return p / q
}

func x_acos(tls *TLS, x float64) (r float64) {
	var c float64
	var df float64
	var hx Tuint32_t
	var ix Tuint32_t
	var lx Tuint32_t
	var s float64
	var w float64
	var z float64
	{
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3ff00000) {
		{
			lx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x})))))
		}
		if ix-uint32(0x3ff00000)|lx == uint32(0) {
			/* acos(1)=0, acos(-1)=pi */
			if hx>>int32(31) != 0 {
				return Float64FromInt32(2)*_pio2_hi + Float64FromFloat32(7.52316384526264e-37)
			}
			return Float64FromInt32(0)
		}
		return Float64FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3fe00000) {
		if ix <= uint32(0x3c600000) { /* |x| < 2**-57 */
			return _pio2_hi + Float64FromFloat32(7.52316384526264e-37)
		}
		return _pio2_hi - (x - (_pio2_lo - x*_R(tls, x*x)))
	}
	/* x < -0.5 */
	if hx>>int32(31) != 0 {
		z = (float64(1) + x) * float64(0.5)
		s = x_sqrt(tls, z)
		w = _R(tls, z)*s - _pio2_lo
		return Float64FromInt32(2) * (_pio2_hi - (s + w))
	}
	/* x > 0.5 */
	z = (float64(1) - x) * float64(0.5)
	s = x_sqrt(tls, z)
	df = s
	{
		df = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: df}))))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	c = (z - df*df) / (s + df)
	w = _R(tls, z)*s + c
	return Float64FromInt32(2) * (df + w)
}

var _pio2_hi1 = float32(1.5707962513)     /* 0x3fc90fda */
var _pio2_lo1 = float32(7.5497894159e-08) /* 0x33a22168 */
var _pS01 = float32(0.16666586697)
var _pS11 = float32(-Float64FromFloat64(0.042743422091))
var _pS21 = float32(-Float64FromFloat64(0.008656363003))
var _qS11 = float32(-Float64FromFloat64(0.7066296339))

func _R1(tls *TLS, z float32) (r float32) {
	var p Tfloat_t
	var q Tfloat_t
	p = z * (_pS01 + z*(_pS11+z*_pS21))
	q = Float32FromFloat32(1) + z*_qS11
	return p / q
}

func x_acosf(tls *TLS, x float32) (r float32) {
	var c float32
	var df float32
	var hx Tuint32_t
	var ix Tuint32_t
	var s float32
	var w float32
	var z float32
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3f800000) {
		if ix == uint32(0x3f800000) {
			if hx>>int32(31) != 0 {
				return Float32FromInt32(2)*_pio2_hi1 + Float32FromFloat32(7.52316384526264e-37)
			}
			return Float32FromInt32(0)
		}
		return Float32FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3f000000) {
		if ix <= uint32(0x32800000) { /* |x| < 2**-26 */
			return _pio2_hi1 + Float32FromFloat32(7.52316384526264e-37)
		}
		return _pio2_hi1 - (x - (_pio2_lo1 - x*_R1(tls, x*x)))
	}
	/* x < -0.5 */
	if hx>>int32(31) != 0 {
		z = (Float32FromInt32(1) + x) * Float32FromFloat32(0.5)
		s = x_sqrtf(tls, z)
		w = _R1(tls, z)*s - _pio2_lo1
		return Float32FromInt32(2) * (_pio2_hi1 - (s + w))
	}
	/* x > 0.5 */
	z = (Float32FromInt32(1) - x) * Float32FromFloat32(0.5)
	s = x_sqrtf(tls, z)
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: s}))))
	}
	{
		df = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: hx & uint32(0xfffff000)}))))
	}
	c = (z - df*df) / (s + df)
	w = _R1(tls, z)*s + c
	return Float32FromInt32(2) * (df + w)
}

// C documentation
//
//	/* acosh(x) = log(x + sqrt(x*x-1)) */
func x_acosh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e uint32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	/* x < 1 domain error is handled in the called functions */
	if e < uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1)) {
		/* |x| < 2, up to 2ulp error in [1,1.125] */
		return x_log1p(tls, x-Float64FromInt32(1)+x_sqrt(tls, (x-Float64FromInt32(1))*(x-Float64FromInt32(1))+Float64FromInt32(2)*(x-Float64FromInt32(1))))
	}
	if e < uint32(Int32FromInt32(0x3ff)+Int32FromInt32(26)) {
		/* |x| < 0x1p26 */
		return x_log(tls, Float64FromInt32(2)*x-Float64FromInt32(1)/(x+x_sqrt(tls, x*x-Float64FromInt32(1))))
	}
	/* |x| >= 0x1p26 or nan */
	return x_log(tls, x) + float64(0.6931471805599453)
}

// C documentation
//
//	/* acosh(x) = log(x + sqrt(x*x-1)) */
func x_acoshf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var a Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	a = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if a < uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(1)<<Int32FromInt32(23)) {
		/* |x| < 2, invalid if x < 1 */
		/* up to 2ulp error in [1,1.125] */
		return x_log1pf(tls, x-Float32FromInt32(1)+x_sqrtf(tls, (x-Float32FromInt32(1))*(x-Float32FromInt32(1))+Float32FromInt32(2)*(x-Float32FromInt32(1))))
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(12)<<Int32FromInt32(23)) {
		/* 2 <= x < 0x1p12 */
		return x_logf(tls, Float32FromInt32(2)*x-Float32FromInt32(1)/(x+x_sqrtf(tls, x*x-Float32FromInt32(1))))
	}
	/* x >= 0x1p12 or x <= -2 or nan */
	return x_logf(tls, x) + Float32FromFloat32(0.6931471805599453)
}

func x_acoshl(tls *TLS, x float64) (r float64) {
	return x_acosh(tls, x)
}

var _pio2_hi2 = float64(1.5707963267948966)    /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo2 = float64(6.123233995736766e-17) /* 0x3C91A626, 0x33145C07 */
/* coefficients for R(x^2) */
var _pS02 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS12 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS22 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS31 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS41 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS51 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS12 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS21 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS31 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS41 = float64(0.07703815055590194)

func _R2(tls *TLS, z float64) (r float64) {
	var p Tdouble_t
	var q Tdouble_t
	p = z * (_pS02 + z*(_pS12+z*(_pS22+z*(_pS31+z*(_pS41+z*_pS51)))))
	q = float64(1) + z*(_qS12+z*(_qS21+z*(_qS31+z*_qS41)))
	return p / q
}

func x_asin(tls *TLS, x float64) (r1 float64) {
	var c float64
	var f float64
	var hx Tuint32_t
	var ix Tuint32_t
	var lx Tuint32_t
	var r float64
	var s float64
	var z float64
	{
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3ff00000) {
		{
			lx = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x})))))
		}
		if ix-uint32(0x3ff00000)|lx == uint32(0) {
			/* asin(1) = +-pi/2 with inexact */
			return x*_pio2_hi2 + Float64FromFloat32(7.52316384526264e-37)
		}
		return Float64FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3fe00000) {
		/* if 0x1p-1022 <= |x| < 0x1p-26, avoid raising underflow */
		if ix < uint32(0x3e500000) && ix >= uint32(0x00100000) {
			return x
		}
		return x + x*_R2(tls, x*x)
	}
	/* 1 > |x| >= 0.5 */
	z = (Float64FromInt32(1) - x_fabs(tls, x)) * float64(0.5)
	s = x_sqrt(tls, z)
	r = _R2(tls, z)
	if ix >= uint32(0x3fef3333) { /* if |x| > 0.975 */
		x = _pio2_hi2 - (Float64FromInt32(2)*(s+s*r) - _pio2_lo2)
	} else {
		/* f+c = sqrt(z) */
		f = s
		{
			f = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_f [0]float64
				F_i Tuint64_t
			}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: f}))))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
		}
		c = (z - f*f) / (s + f)
		x = float64(0.5)*_pio2_hi2 - (Float64FromInt32(2)*s*r - (_pio2_lo2 - Float64FromInt32(2)*c) - (float64(0.5)*_pio2_hi2 - Float64FromInt32(2)*f))
	}
	if hx>>int32(31) != 0 {
		return -x
	}
	return x
}

var _pio2 = float64(1.5707963267948966)

/* coefficients for R(x^2) */
var _pS03 = float32(0.16666586697)
var _pS13 = float32(-Float64FromFloat64(0.042743422091))
var _pS23 = float32(-Float64FromFloat64(0.008656363003))
var _qS13 = float32(-Float64FromFloat64(0.7066296339))

func _R3(tls *TLS, z float32) (r float32) {
	var p Tfloat_t
	var q Tfloat_t
	p = z * (_pS03 + z*(_pS13+z*_pS23))
	q = Float32FromFloat32(1) + z*_qS13
	return p / q
}

func x_asinf(tls *TLS, x float32) (r float32) {
	var hx Tuint32_t
	var ix Tuint32_t
	var s float64
	var z float32
	{
		hx = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = hx & uint32(0x7fffffff)
	if ix >= uint32(0x3f800000) {
		/* |x| >= 1 */
		if ix == uint32(0x3f800000) { /* |x| == 1 */
			return float32(float64(x)*_pio2 + Float64FromFloat32(7.52316384526264e-37))
		} /* asin(+-1) = +-pi/2 with inexact */
		return Float32FromInt32(0) / (x - x) /* asin(|x|>1) is NaN */
	}
	if ix < uint32(0x3f000000) {
		/* |x| < 0.5 */
		/* if 0x1p-126 <= |x| < 0x1p-12, avoid raising underflow */
		if ix < uint32(0x39800000) && ix >= uint32(0x00800000) {
			return x
		}
		return x + x*_R3(tls, x*x)
	}
	/* 1 > |x| >= 0.5 */
	z = (Float32FromInt32(1) - x_fabsf(tls, x)) * Float32FromFloat32(0.5)
	s = x_sqrt(tls, float64(z))
	x = float32(_pio2 - Float64FromInt32(2)*(s+s*float64(_R3(tls, z))))
	if hx>>int32(31) != 0 {
		return -x
	}
	return x
}

const m_fp_force_evall = 0

// C documentation
//
//	/* asinh(x) = sign(x)*log(|x|+sqrt(x*x+1)) ~= x - x^3/6 + o(x^5) */
func x_asinh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e uint32
	var s uint32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v2 float64
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* |x| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) / Uint64FromInt32(2))
	x = *(*float64)(unsafe.Pointer(bp))
	if e >= uint32(Int32FromInt32(0x3ff)+Int32FromInt32(26)) {
		/* |x| >= 0x1p26 or inf or nan */
		x = x_log(tls, x) + float64(0.6931471805599453)
	} else {
		if e >= uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1)) {
			/* |x| >= 2 */
			x = x_log(tls, Float64FromInt32(2)*x+Float64FromInt32(1)/(x_sqrt(tls, x*x+Float64FromInt32(1))+x))
		} else {
			if e >= uint32(Int32FromInt32(0x3ff)-Int32FromInt32(26)) {
				/* |x| >= 0x1p-26, up to 1.6ulp error in [0.125,0.5] */
				x = x_log1p(tls, x+x*x/(x_sqrt(tls, x*x+Float64FromInt32(1))+Float64FromInt32(1)))
			} else {
				/* |x| < 0x1p-26, raise inexact if x != 0 */
				{
					if uint64(8) == uint64(4) {
						_fp_force_evalf(tls, float32(x+Float64FromFloat32(1.329227995784916e+36)))
					} else {
						if uint64(8) == uint64(8) {
							_fp_force_eval(tls, x+Float64FromFloat32(1.329227995784916e+36))
						} else {
							_fp_force_evall(tls, x+Float64FromFloat32(1.329227995784916e+36))
						}
					}
				}
			}
		}
	}
	if s != 0 {
		v2 = -x
	} else {
		v2 = x
	}
	return v2
}

// C documentation
//
//	/* asinh(x) = sign(x)*log(|x|+sqrt(x*x+1)) ~= x - x^3/6 + o(x^5) */
func x_asinhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var i Tuint32_t
	var s uint32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v1 float32
	*(*float32)(unsafe.Pointer(bp)) = x
	i = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	s = *(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31)
	/* |x| */
	*(*Tuint32_t)(unsafe.Pointer(bp)) = i
	x = *(*float32)(unsafe.Pointer(bp))
	if i >= uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(12)<<Int32FromInt32(23)) {
		/* |x| >= 0x1p12 or inf or nan */
		x = x_logf(tls, x) + Float32FromFloat32(0.6931471805599453)
	} else {
		if i >= uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(1)<<Int32FromInt32(23)) {
			/* |x| >= 2 */
			x = x_logf(tls, Float32FromInt32(2)*x+Float32FromInt32(1)/(x_sqrtf(tls, x*x+Float32FromInt32(1))+x))
		} else {
			if i >= uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
				/* |x| >= 0x1p-12, up to 1.6ulp error in [0.125,0.5] */
				x = x_log1pf(tls, x+x*x/(x_sqrtf(tls, x*x+Float32FromInt32(1))+Float32FromInt32(1)))
			} else {
				/* |x| < 0x1p-12, raise inexact if x!=0 */
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
						} else {
							_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
						}
					}
				}
			}
		}
	}
	if s != 0 {
		v1 = -x
	} else {
		v1 = x
	}
	return v1
}

func x_asinhl(tls *TLS, x float64) (r float64) {
	return x_asinh(tls, x)
}

var _atanhi = [4]float64{
	0: float64(0.4636476090008061),
	1: float64(0.7853981633974483),
	2: float64(0.982793723247329),
	3: float64(1.5707963267948966)}

var _atanlo = [4]float64{
	0: float64(2.2698777452961687e-17),
	1: float64(3.061616997868383e-17),
	2: float64(1.3903311031230998e-17),
	3: float64(6.123233995736766e-17)}

var _aT = [11]float64{
	0:  float64(0.3333333333333293),
	1:  -Float64FromFloat64(0.19999999999876483),
	2:  float64(0.14285714272503466),
	3:  -Float64FromFloat64(0.11111110405462356),
	4:  float64(0.09090887133436507),
	5:  -Float64FromFloat64(0.0769187620504483),
	6:  float64(0.06661073137387531),
	7:  -Float64FromFloat64(0.058335701337905735),
	8:  float64(0.049768779946159324),
	9:  -Float64FromFloat64(0.036531572744216916),
	10: float64(0.016285820115365782)}

func x_atan(tls *TLS, x float64) (r float64) {
	var id int32
	var ix Tuint32_t
	var s1 Tdouble_t
	var s2 Tdouble_t
	var sign Tuint32_t
	var w Tdouble_t
	var z Tdouble_t
	var v1 Tdouble_t
	var v2 Tdouble_t
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	sign = ix >> int32(31)
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x44100000) {
		/* if |x| >= 2^66 */
		if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			return x
		}
		z = _atanhi[int32(3)] + Float64FromFloat32(7.52316384526264e-37)
		if sign != 0 {
			v1 = -z
		} else {
			v1 = z
		}
		return v1
	}
	if ix < uint32(0x3fdc0000) { /* |x| < 0.4375 */
		if ix < uint32(0x3e400000) {
			/* |x| < 2^-27 */
			if ix < uint32(0x00100000) {
				/* raise underflow for subnormal x */
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, float32(x))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(float32(x)))
						} else {
							_fp_force_evall(tls, float64(float32(x)))
						}
					}
				}
			}
			return x
		}
		id = -int32(1)
	} else {
		x = x_fabs(tls, x)
		if ix < uint32(0x3ff30000) { /* |x| < 1.1875 */
			if ix < uint32(0x3fe60000) { /*  7/16 <= |x| < 11/16 */
				id = int32(0)
				x = (float64(2)*x - float64(1)) / (float64(2) + x)
			} else { /* 11/16 <= |x| < 19/16 */
				id = int32(1)
				x = (x - float64(1)) / (x + float64(1))
			}
		} else {
			if ix < uint32(0x40038000) { /* |x| < 2.4375 */
				id = int32(2)
				x = (x - float64(1.5)) / (float64(1) + float64(1.5)*x)
			} else { /* 2.4375 <= |x| < 2^66 */
				id = int32(3)
				x = -Float64FromFloat64(1) / x
			}
		}
	}
	/* end of argument reduction */
	z = x * x
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT[int32(0)] + w*(_aT[int32(2)]+w*(_aT[int32(4)]+w*(_aT[int32(6)]+w*(_aT[int32(8)]+w*_aT[int32(10)])))))
	s2 = w * (_aT[int32(1)] + w*(_aT[int32(3)]+w*(_aT[int32(5)]+w*(_aT[int32(7)]+w*_aT[int32(9)]))))
	if id < int32(0) {
		return x - x*(s1+s2)
	}
	z = _atanhi[id] - (x*(s1+s2) - _atanlo[id] - x)
	if sign != 0 {
		v2 = -z
	} else {
		v2 = z
	}
	return v2
}

var _pi = float64(3.141592653589793) /* 0x400921FB, 0x54442D18 */
var _pi_lo = float64(1.2246467991473532e-16)

func x_atan2(tls *TLS, y float64, x float64) (r float64) {
	var __u Tuint64_t
	var __u1 Tuint64_t
	var ix Tuint32_t
	var iy Tuint32_t
	var lx Tuint32_t
	var ly Tuint32_t
	var m Tuint32_t
	var z float64
	var v1 float64
	var v2 float64
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x + y
	}
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		ix = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	{
		__u1 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: y}))))
		iy = uint32(__u1 >> int32(32))
		ly = uint32(__u1)
	}
	if ix-uint32(0x3ff00000)|lx == uint32(0) { /* x = 1.0 */
		return x_atan(tls, y)
	}
	m = iy>>Int32FromInt32(31)&uint32(1) | ix>>Int32FromInt32(30)&uint32(2) /* 2*sign(x)+sign(y) */
	ix = ix & uint32(0x7fffffff)
	iy = iy & uint32(0x7fffffff)
	/* when y = 0 */
	if iy|ly == uint32(0) {
		switch m {
		case uint32(0):
			fallthrough
		case uint32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case uint32(2):
			return _pi /* atan(+0,-anything) = pi */
		case uint32(3):
			return -_pi /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ix|lx == uint32(0) {
		if m&uint32(1) != 0 {
			v1 = -_pi / Float64FromInt32(2)
		} else {
			v1 = _pi / Float64FromInt32(2)
		}
		return v1
	}
	/* when x is INF */
	if ix == uint32(0x7ff00000) {
		if iy == uint32(0x7ff00000) {
			switch m {
			case uint32(0):
				return _pi / Float64FromInt32(4) /* atan(+INF,+INF) */
			case uint32(1):
				return -_pi / Float64FromInt32(4) /* atan(-INF,+INF) */
			case uint32(2):
				return Float64FromInt32(3) * _pi / Float64FromInt32(4) /* atan(+INF,-INF) */
			case uint32(3):
				return float64(-Int32FromInt32(3)) * _pi / Float64FromInt32(4) /* atan(-INF,-INF) */
			}
		} else {
			switch m {
			case uint32(0):
				return float64(0) /* atan(+...,+INF) */
			case uint32(1):
				return -Float64FromFloat64(0) /* atan(-...,+INF) */
			case uint32(2):
				return _pi /* atan(+...,-INF) */
			case uint32(3):
				return -_pi /* atan(-...,-INF) */
			}
		}
	}
	/* |y/x| > 0x1p64 */
	if ix+uint32(Int32FromInt32(64)<<Int32FromInt32(20)) < iy || iy == uint32(0x7ff00000) {
		if m&uint32(1) != 0 {
			v2 = -_pi / Float64FromInt32(2)
		} else {
			v2 = _pi / Float64FromInt32(2)
		}
		return v2
	}
	/* z = atan(|y/x|) without spurious underflow */
	if m&uint32(2) != 0 && iy+uint32(Int32FromInt32(64)<<Int32FromInt32(20)) < ix { /* |y/x| < 0x1p-64, x<0 */
		z = Float64FromInt32(0)
	} else {
		z = x_atan(tls, x_fabs(tls, y/x))
	}
	switch m {
	case uint32(0):
		return z /* atan(+,+) */
	case uint32(1):
		return -z /* atan(-,+) */
	case uint32(2):
		return _pi - (z - _pi_lo) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo - _pi /* atan(-,-) */
	}
	return r
}

var _pi1 = float32(3.141592741) /* 0x40490fdb */
var _pi_lo1 = float32(-Float64FromFloat64(8.7422776573e-08))

func x_atan2f(tls *TLS, y float32, x float32) (r float32) {
	var ix Tuint32_t
	var iy Tuint32_t
	var m Tuint32_t
	var z float32
	var v1 float32
	var v2 float32
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x + y
	}
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	{
		iy = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: y}))))
	}
	if ix == uint32(0x3f800000) { /* x=1.0 */
		return x_atanf(tls, y)
	}
	m = iy>>Int32FromInt32(31)&uint32(1) | ix>>Int32FromInt32(30)&uint32(2) /* 2*sign(x)+sign(y) */
	ix = ix & Uint32FromInt32(0x7fffffff)
	iy = iy & Uint32FromInt32(0x7fffffff)
	/* when y = 0 */
	if iy == uint32(0) {
		switch m {
		case uint32(0):
			fallthrough
		case uint32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case uint32(2):
			return _pi1 /* atan(+0,-anything) = pi */
		case uint32(3):
			return -_pi1 /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ix == uint32(0) {
		if m&uint32(1) != 0 {
			v1 = -_pi1 / Float32FromInt32(2)
		} else {
			v1 = _pi1 / Float32FromInt32(2)
		}
		return v1
	}
	/* when x is INF */
	if ix == uint32(0x7f800000) {
		if iy == uint32(0x7f800000) {
			switch m {
			case uint32(0):
				return _pi1 / Float32FromInt32(4) /* atan(+INF,+INF) */
			case uint32(1):
				return -_pi1 / Float32FromInt32(4) /* atan(-INF,+INF) */
			case uint32(2):
				return Float32FromInt32(3) * _pi1 / Float32FromInt32(4) /*atan(+INF,-INF)*/
			case uint32(3):
				return float32(-Int32FromInt32(3)) * _pi1 / Float32FromInt32(4) /*atan(-INF,-INF)*/
			}
		} else {
			switch m {
			case uint32(0):
				return Float32FromFloat32(0) /* atan(+...,+INF) */
			case uint32(1):
				return -Float32FromFloat32(0) /* atan(-...,+INF) */
			case uint32(2):
				return _pi1 /* atan(+...,-INF) */
			case uint32(3):
				return -_pi1 /* atan(-...,-INF) */
			}
		}
	}
	/* |y/x| > 0x1p26 */
	if ix+uint32(Int32FromInt32(26)<<Int32FromInt32(23)) < iy || iy == uint32(0x7f800000) {
		if m&uint32(1) != 0 {
			v2 = -_pi1 / Float32FromInt32(2)
		} else {
			v2 = _pi1 / Float32FromInt32(2)
		}
		return v2
	}
	/* z = atan(|y/x|) with correct underflow */
	if m&uint32(2) != 0 && iy+uint32(Int32FromInt32(26)<<Int32FromInt32(23)) < ix { /*|y/x| < 0x1p-26, x < 0 */
		z = float32(0)
	} else {
		z = x_atanf(tls, x_fabsf(tls, y/x))
	}
	switch m {
	case uint32(0):
		return z /* atan(+,+) */
	case uint32(1):
		return -z /* atan(-,+) */
	case uint32(2):
		return _pi1 - (z - _pi_lo1) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo1 - _pi1 /* atan(-,-) */
	}
	return r
}

var _atanhi1 = [4]float32{
	0: float32(0.46364760399),
	1: float32(0.78539812565),
	2: float32(0.98279368877),
	3: float32(1.5707962513)}

var _atanlo1 = [4]float32{
	0: float32(5.012158244e-09),
	1: float32(3.7748947079e-08),
	2: float32(3.447321717e-08),
	3: float32(7.5497894159e-08)}

var _aT1 = [5]float32{
	0: float32(0.33333328366),
	1: float32(-Float64FromFloat64(0.19999158382)),
	2: float32(0.14253635705),
	3: float32(-Float64FromFloat64(0.10648017377)),
	4: float32(0.061687607318)}

func x_atanf(tls *TLS, x float32) (r float32) {
	var id int32
	var ix Tuint32_t
	var s1 Tfloat_t
	var s2 Tfloat_t
	var sign Tuint32_t
	var w Tfloat_t
	var z Tfloat_t
	var v1 Tfloat_t
	var v2 Tfloat_t
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = ix >> int32(31)
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x4c800000) {
		/* if |x| >= 2**26 */
		if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
			return x
		}
		z = _atanhi1[int32(3)] + Float32FromFloat32(7.52316384526264e-37)
		if sign != 0 {
			v1 = -z
		} else {
			v1 = z
		}
		return v1
	}
	if ix < uint32(0x3ee00000) { /* |x| < 0.4375 */
		if ix < uint32(0x39800000) {
			/* |x| < 2**-12 */
			if ix < uint32(0x00800000) {
				/* raise underflow for subnormal x */
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, x*x)
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(x*x))
						} else {
							_fp_force_evall(tls, float64(x*x))
						}
					}
				}
			}
			return x
		}
		id = -int32(1)
	} else {
		x = x_fabsf(tls, x)
		if ix < uint32(0x3f980000) { /* |x| < 1.1875 */
			if ix < uint32(0x3f300000) { /*  7/16 <= |x| < 11/16 */
				id = int32(0)
				x = (Float32FromFloat32(2)*x - Float32FromFloat32(1)) / (Float32FromFloat32(2) + x)
			} else { /* 11/16 <= |x| < 19/16 */
				id = int32(1)
				x = (x - Float32FromFloat32(1)) / (x + Float32FromFloat32(1))
			}
		} else {
			if ix < uint32(0x401c0000) { /* |x| < 2.4375 */
				id = int32(2)
				x = (x - Float32FromFloat32(1.5)) / (Float32FromFloat32(1) + Float32FromFloat32(1.5)*x)
			} else { /* 2.4375 <= |x| < 2**26 */
				id = int32(3)
				x = -Float32FromFloat32(1) / x
			}
		}
	}
	/* end of argument reduction */
	z = x * x
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT1[int32(0)] + w*(_aT1[int32(2)]+w*_aT1[int32(4)]))
	s2 = w * (_aT1[int32(1)] + w*_aT1[int32(3)])
	if id < int32(0) {
		return x - x*(s1+s2)
	}
	z = _atanhi1[id] - (x*(s1+s2) - _atanlo1[id] - x)
	if sign != 0 {
		v2 = -z
	} else {
		v2 = z
	}
	return v2
}

// C documentation
//
//	/* atanh(x) = log((1+x)/(1-x))/2 = log1p(2x/(1-x))/2 ~= x + x^3/3 + o(x^5) */
func x_atanh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e uint32
	var s uint32
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v2 Tdouble_t
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* |x| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) / Uint64FromInt32(2))
	y = *(*float64)(unsafe.Pointer(bp))
	if e < uint32(Int32FromInt32(0x3ff)-Int32FromInt32(1)) {
		if e < uint32(Int32FromInt32(0x3ff)-Int32FromInt32(32)) {
			/* handle underflow */
			if e == uint32(0) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, float32(y))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(float32(y)))
						} else {
							_fp_force_evall(tls, float64(float32(y)))
						}
					}
				}
			}
		} else {
			/* |x| < 0.5, up to 1.7ulp error */
			y = float64(0.5) * x_log1p(tls, Float64FromInt32(2)*y+Float64FromInt32(2)*y*y/(Float64FromInt32(1)-y))
		}
	} else {
		/* avoid overflow */
		y = float64(0.5) * x_log1p(tls, Float64FromInt32(2)*(y/(Float64FromInt32(1)-y)))
	}
	if s != 0 {
		v2 = -y
	} else {
		v2 = y
	}
	return v2
}

// C documentation
//
//	/* atanh(x) = log((1+x)/(1-x))/2 = log1p(2x/(1-x))/2 ~= x + x^3/3 + o(x^5) */
func x_atanhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var s uint32
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v2 Tfloat_t
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	s = *(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31)
	/* |x| */
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	y = *(*float32)(unsafe.Pointer(bp))
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(1)<<Int32FromInt32(23)) {
		if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(32)<<Int32FromInt32(23)) {
			/* handle underflow */
			if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(1)<<Int32FromInt32(23)) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, y*y)
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(y*y))
						} else {
							_fp_force_evall(tls, float64(y*y))
						}
					}
				}
			}
		} else {
			/* |x| < 0.5, up to 1.7ulp error */
			y = Float32FromFloat32(0.5) * x_log1pf(tls, Float32FromInt32(2)*y+Float32FromInt32(2)*y*y/(Float32FromInt32(1)-y))
		}
	} else {
		/* avoid overflow */
		y = Float32FromFloat32(0.5) * x_log1pf(tls, Float32FromInt32(2)*(y/(Float32FromInt32(1)-y)))
	}
	if s != 0 {
		v2 = -y
	} else {
		v2 = y
	}
	return v2
}

func x_atanhl(tls *TLS, x float64) (r float64) {
	return x_atanh(tls, x)
}

var _B1 = uint32(715094163) /* B1 = (1023-1023/3-0.03306235651)*2**20 */
var _B2 = uint32(696219795) /* B2 = (1023-1023/3-54/3-0.03306235651)*2**20 */

/* |1/cbrt(x) - p(x)| < 2**-23.5 (~[-7.93e-8, 7.929e-8]). */

var _P0 = float64(1.87595182427177)               /* 0x3ffe03e6, 0x0f61e692 */
var _P1 = -Float64FromFloat64(1.8849797954337717) /* 0xbffe28e0, 0x92f02420 */
var _P2 = float64(1.6214297201053545)             /* 0x3ff9f160, 0x4a49d6c2 */
var _P3 = -Float64FromFloat64(0.758397934778766)  /* 0xbfe844cb, 0xbee751d9 */
var _P4 = float64(0.14599619288661245)

func x_cbrt(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var hx Tuint32_t
	var r Tdouble_t
	var s Tdouble_t
	var t Tdouble_t
	var w Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	var p2 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if hx >= uint32(0x7ff00000) { /* cbrt(NaN,INF) is itself */
		return x + x
	}
	/*
	 * Rough cbrt to 5 bits:
	 *    cbrt(2**e*(1+m) ~= 2**(e/3)*(1+(e%3+m)/3)
	 * where e is integral and >= 0, m is real and in [0, 1), and "/" and
	 * "%" are integer division and modulus with rounding towards minus
	 * infinity.  The RHS is always >= the LHS and has a maximum relative
	 * error of about 1 in 16.  Adding a bias of -0.03306235651 to the
	 * (e%3+m)/3 term reduces the error to about 1 in 32. With the IEEE
	 * floating point representation, for finite positive normal values,
	 * ordinary integer divison of the value in bits magically gives
	 * almost exactly the RHS of the above provided we first subtract the
	 * exponent bias (1023 for doubles) and later add it back.  We do the
	 * subtraction virtually to keep e >= 0 so that ordinary integer
	 * division rounds towards minus infinity; this is also efficient.
	 */
	if hx < uint32(0x00100000) { /* zero or subnormal? */
		*(*float64)(unsafe.Pointer(bp)) = x * float64(1.8014398509481984e+16)
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
		if hx == uint32(0) {
			return x
		} /* cbrt(0) is itself */
		hx = hx/uint32(3) + _B2
	} else {
		hx = hx/uint32(3) + _B1
	}
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (Uint64FromUint64(1) << Int32FromInt32(63))
	p2 = bp
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) | uint64(hx)<<Int32FromInt32(32)
	t = *(*float64)(unsafe.Pointer(bp))
	/*
	 * New cbrt to 23 bits:
	 *    cbrt(x) = t*cbrt(x/t**3) ~= t*P(t**3/x)
	 * where P(r) is a polynomial of degree 4 that approximates 1/cbrt(r)
	 * to within 2**-23.5 when |r - 1| < 1/10.  The rough approximation
	 * has produced t such than |t/cbrt(x) - 1| ~< 1/32, and cubing this
	 * gives us bounds for r = t**3/x.
	 *
	 * Try to optimize for parallel evaluation as in __tanf.c.
	 */
	r = t * t * (t / x)
	t = t * (_P0 + r*(_P1+r*_P2) + r*r*r*(_P3+r*_P4))
	/*
	 * Round t away from zero to 23 bits (sloppily except for ensuring that
	 * the result is larger in magnitude than cbrt(x) but not much more than
	 * 2 23-bit ulps larger).  With rounding towards zero, the error bound
	 * would be ~5/6 instead of ~4/6.  With a maximum error of 2 23-bit ulps
	 * in the rounded t, the infinite-precision error in the Newton
	 * approximation barely affects third digit in the final error
	 * 0.667; the error in the rounded t can be up to about 3 23-bit ulps
	 * before the final error is larger than 0.667 ulps.
	 */
	*(*float64)(unsafe.Pointer(bp)) = t
	*(*Tuint64_t)(unsafe.Pointer(bp)) = (*(*Tuint64_t)(unsafe.Pointer(bp)) + Uint64FromUint32(0x80000000)) & uint64(0xffffffffc0000000)
	t = *(*float64)(unsafe.Pointer(bp))
	/* one step Newton iteration to 53 bits with error < 0.667 ulps */
	s = t * t             /* t*t is exact */
	r = x / s             /* error <= 0.5 ulps; |r| < |t| */
	w = t + t             /* t+t is exact */
	r = (r - t) / (w + r) /* r-t is exact; w+r ~= 3*t */
	t = t + t*r           /* error <= 0.5 + 0.5/3 + epsilon */
	return t
}

var _B11 = uint32(709958130) /* B1 = (127-127.0/3-0.03306235651)*2**23 */
var _B21 = uint32(642849266)

func x_cbrtf(tls *TLS, x float32) (r1 float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var T Tdouble_t
	var hx Tuint32_t
	var r Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if hx >= uint32(0x7f800000) { /* cbrt(NaN,INF) is itself */
		return x + x
	}
	/* rough cbrt to 5 bits */
	if hx < uint32(0x00800000) { /* zero or subnormal? */
		if hx == uint32(0) {
			return x
		} /* cbrt(+-0) is itself */
		*(*float32)(unsafe.Pointer(bp)) = x * Float32FromFloat32(1.6777216e+07)
		hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
		hx = hx/uint32(3) + _B21
	} else {
		hx = hx/uint32(3) + _B11
	}
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromUint32(0x80000000)
	p2 = bp
	*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | hx
	/*
	 * First step Newton iteration (solving t*t-x/t == 0) to 16 bits.  In
	 * double precision so that its terms can be arranged for efficiency
	 * without causing overflow or underflow.
	 */
	T = float64(*(*float32)(unsafe.Pointer(bp)))
	r = T * T * T
	T = T * (float64(x) + float64(x) + r) / (float64(x) + r + r)
	/*
	 * Second step Newton iteration to 47 bits.  In double precision for
	 * efficiency and accuracy.
	 */
	r = T * T * T
	T = T * (float64(x) + float64(x) + r) / (float64(x) + r + r)
	/* rounding to 24 bits is perfect in round-to-nearest mode */
	return float32(T)
}

func x_cbrtl(tls *TLS, x float64) (r float64) {
	return x_cbrt(tls, x)
}

var _toint2 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func x_ceil(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 float64
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) || x == Float64FromInt32(0) {
		return x
	}
	/* y = int(x) - x, where int(x) is an integer neighbor of x */
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y = x - _toint2 + _toint2 - x
	} else {
		y = x + _toint2 - _toint2 - x
	}
	/* special case because of non-nearest rounding modes */
	if e <= Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		{
			if uint64(8) == uint64(4) {
				_fp_force_evalf(tls, float32(y))
			} else {
				if uint64(8) == uint64(8) {
					_fp_force_eval(tls, y)
				} else {
					_fp_force_evall(tls, y)
				}
			}
		}
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			v1 = -Float64FromFloat64(0)
		} else {
			v1 = Float64FromInt32(1)
		}
		return v1
	}
	if y < Float64FromInt32(0) {
		return x + y + Float64FromInt32(1)
	}
	return x + y
}

func x_ceilf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var m Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	if e >= int32(23) {
		return x
	}
	if e >= int32(0) {
		m = uint32(int32(0x007fffff) >> e)
		if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
			return x
		}
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				} else {
					_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				}
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) == uint32(0) {
			p1 = bp
			*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) + m
		}
		p2 = bp
		*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) & ^m
	} else {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				} else {
					_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				}
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
			*(*float32)(unsafe.Pointer(bp)) = float32(-Float64FromFloat64(0))
		} else {
			if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
				*(*float32)(unsafe.Pointer(bp)) = float32(1)
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func x_copysign(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	var p2 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	p2 = bp
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))&(Uint64FromUint64(1)<<Int32FromInt32(63))
	return *(*float64)(unsafe.Pointer(bp))
}

func x_copysignf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	p2 = bp
	*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | *(*Tuint32_t)(unsafe.Pointer(bp + 4))&Uint32FromUint32(0x80000000)
	return *(*float32)(unsafe.Pointer(bp))
}

func x_copysignl(tls *TLS, x float64, y float64) (r float64) {
	return x_copysign(tls, x, y)
}

func x_cos(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var _ /* y at bp+0 */ [2]float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e46a09e) {
			/* |x| < 2**-27 * sqrt(2) */
			/* raise inexact if x!=0 */
			{
				if uint64(8) == uint64(4) {
					_fp_force_evalf(tls, float32(x+Float64FromFloat32(1.329227995784916e+36)))
				} else {
					if uint64(8) == uint64(8) {
						_fp_force_eval(tls, x+Float64FromFloat32(1.329227995784916e+36))
					} else {
						_fp_force_evall(tls, x+Float64FromFloat32(1.329227995784916e+36))
					}
				}
			}
			return float64(1)
		}
		return x___cos(tls, x, Float64FromInt32(0))
	}
	/* cos(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x - x
	}
	/* argument reduction */
	n = uint32(x___rem_pio2(tls, x, bp))
	switch n & uint32(3) {
	case uint32(0):
		return x___cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	case uint32(1):
		return -x___sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	case uint32(2):
		return -x___cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	default:
		return x___sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	}
	return r
}

/* Small multiples of pi/2 rounded to double precision. */

var _c1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _c2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _c3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _c4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966)

func x_cosf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ix Tuint32_t
	var n uint32
	var sign uint32
	var _ /* y at bp+0 */ float64
	var v1 float64
	var v2 float64
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = ix >> int32(31)
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix <= uint32(0x3f490fda) {
		/* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) {
			/* |x| < 2**-12 */
			/* raise inexact if x != 0 */
			{
				if uint64(4) == uint64(4) {
					_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
				} else {
					if uint64(4) == uint64(8) {
						_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
					} else {
						_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
					}
				}
			}
			return Float32FromFloat32(1)
		}
		return x___cosdf(tls, float64(x))
	}
	if ix <= uint32(0x407b53d1) {
		/* |x| ~<= 5*pi/4 */
		if ix > uint32(0x4016cbe3) { /* |x|  ~> 3*pi/4 */
			if sign != 0 {
				v1 = float64(x) + _c2pio2
			} else {
				v1 = float64(x) - _c2pio2
			}
			return -x___cosdf(tls, v1)
		} else {
			if sign != 0 {
				return x___sindf(tls, float64(x)+_c1pio2)
			} else {
				return x___sindf(tls, _c1pio2-float64(x))
			}
		}
	}
	if ix <= uint32(0x40e231d5) {
		/* |x| ~<= 9*pi/4 */
		if ix > uint32(0x40afeddf) { /* |x| ~> 7*pi/4 */
			if sign != 0 {
				v2 = float64(x) + _c4pio2
			} else {
				v2 = float64(x) - _c4pio2
			}
			return x___cosdf(tls, v2)
		} else {
			if sign != 0 {
				return x___sindf(tls, float64(-x)-_c3pio2)
			} else {
				return x___sindf(tls, float64(x)-_c3pio2)
			}
		}
	}
	/* cos(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x - x
	}
	/* general argument reduction needed */
	n = uint32(x___rem_pio2f(tls, x, bp))
	switch n & uint32(3) {
	case uint32(0):
		return x___cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	case uint32(1):
		return x___sindf(tls, -*(*float64)(unsafe.Pointer(bp)))
	case uint32(2):
		return -x___cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	default:
		return x___sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	}
	return r
}

// C documentation
//
//	/* cosh(x) = (exp(x) + 1/exp(x))/2
//	 *         = 1 + 0.5*(exp(x)-1)*(exp(x)-1)/exp(x)
//	 *         = 1 + x*x/2 + o(x^4)
//	 */
func x_cosh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var t float64
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	/* |x| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) / Uint64FromInt32(2))
	x = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	/* |x| < log(2) */
	if w < uint32(0x3fe62e42) {
		if w < uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(26)<<Int32FromInt32(20)) {
			/* raise inexact if x!=0 */
			{
				if uint64(8) == uint64(4) {
					_fp_force_evalf(tls, float32(x+Float64FromFloat32(1.329227995784916e+36)))
				} else {
					if uint64(8) == uint64(8) {
						_fp_force_eval(tls, x+Float64FromFloat32(1.329227995784916e+36))
					} else {
						_fp_force_evall(tls, x+Float64FromFloat32(1.329227995784916e+36))
					}
				}
			}
			return Float64FromInt32(1)
		}
		t = x_expm1(tls, x)
		return Float64FromInt32(1) + t*t/(Float64FromInt32(2)*(Float64FromInt32(1)+t))
	}
	/* |x| < log(DBL_MAX) */
	if w < uint32(0x40862e42) {
		t = x_exp(tls, x)
		/* note: if x>log(0x1p26) then the 1/t is not needed */
		return float64(0.5) * (t + Float64FromInt32(1)/t)
	}
	/* |x| > log(DBL_MAX) or nan */
	/* note: the result is stored to handle overflow */
	t = x___expo2(tls, x, float64(1))
	return t
}

func x_coshf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var t float32
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	/* |x| */
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	x = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	/* |x| < log(2) */
	if w < uint32(0x3f317217) {
		if w < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
			{
				if uint64(4) == uint64(4) {
					_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
				} else {
					if uint64(4) == uint64(8) {
						_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
					} else {
						_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
					}
				}
			}
			return Float32FromInt32(1)
		}
		t = x_expm1f(tls, x)
		return Float32FromInt32(1) + t*t/(Float32FromInt32(2)*(Float32FromInt32(1)+t))
	}
	/* |x| < log(FLT_MAX) */
	if w < uint32(0x42b17217) {
		t = x_expf(tls, x)
		return Float32FromFloat32(0.5) * (t + Float32FromInt32(1)/t)
	}
	/* |x| > log(FLT_MAX) or nan */
	t = x___expo2f(tls, x, Float32FromFloat32(1))
	return t
}

func x_coshl(tls *TLS, x float64) (r float64) {
	return x_cosh(tls, x)
}

func x_cosl(tls *TLS, x float64) (r float64) {
	return x_cos(tls, x)
}

var _erx = float64(0.8450629115104675) /* 0x3FEB0AC1, 0x60000000 */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx8 = float64(1.0270333367641007)                /* 0x3FF06EBA, 0x8214DB69 */
var _pp0 = float64(0.12837916709551256)                /* 0x3FC06EBA, 0x8214DB68 */
var _pp1 = -Float64FromFloat64(0.3250421072470015)     /* 0xBFD4CD7D, 0x691CB913 */
var _pp2 = -Float64FromFloat64(0.02848174957559851)    /* 0xBF9D2A51, 0xDBD7194F */
var _pp3 = -Float64FromFloat64(0.005770270296489442)   /* 0xBF77A291, 0x236668E4 */
var _pp4 = -Float64FromFloat64(2.3763016656650163e-05) /* 0xBEF8EAD6, 0x120016AC */
var _qq1 = float64(0.39791722395915535)                /* 0x3FD97779, 0xCDDADC09 */
var _qq2 = float64(0.0650222499887673)                 /* 0x3FB0A54C, 0x5536CEBA */
var _qq3 = float64(0.005081306281875766)               /* 0x3F74D022, 0xC4D36B0F */
var _qq4 = float64(0.00013249473800432164)             /* 0x3F215DC9, 0x221C1A10 */
var _qq5 = -Float64FromFloat64(3.960228278775368e-06)  /* 0xBED09C43, 0x42A26120 */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa0 = -Float64FromFloat64(0.0023621185607526594) /* 0xBF6359B8, 0xBEF77538 */
var _pa1 = float64(0.41485611868374833)               /* 0x3FDA8D00, 0xAD92B34D */
var _pa2 = -Float64FromFloat64(0.3722078760357013)    /* 0xBFD7D240, 0xFBB8C3F1 */
var _pa3 = float64(0.31834661990116175)               /* 0x3FD45FCA, 0x805120E4 */
var _pa4 = -Float64FromFloat64(0.11089469428239668)   /* 0xBFBC6398, 0x3D3E28EC */
var _pa5 = float64(0.035478304325618236)              /* 0x3FA22A36, 0x599795EB */
var _pa6 = -Float64FromFloat64(0.002166375594868791)  /* 0xBF61BF38, 0x0A96073F */
var _qa1 = float64(0.10642088040084423)               /* 0x3FBB3E66, 0x18EEE323 */
var _qa2 = float64(0.540397917702171)                 /* 0x3FE14AF0, 0x92EB6F33 */
var _qa3 = float64(0.07182865441419627)               /* 0x3FB2635C, 0xD99FE9A7 */
var _qa4 = float64(0.12617121980876164)               /* 0x3FC02660, 0xE763351F */
var _qa5 = float64(0.01363708391202905)               /* 0x3F8BEDC2, 0x6B51DD1C */
var _qa6 = float64(0.011984499846799107)              /* 0x3F888B54, 0x5735151D */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra0 = -Float64FromFloat64(0.009864944034847148) /* 0xBF843412, 0x600D6435 */
var _ra1 = -Float64FromFloat64(0.6938585727071818)   /* 0xBFE63416, 0xE4BA7360 */
var _ra2 = -Float64FromFloat64(10.558626225323291)   /* 0xC0251E04, 0x41B0E726 */
var _ra3 = -Float64FromFloat64(62.375332450326006)   /* 0xC04F300A, 0xE4CBA38D */
var _ra4 = -Float64FromFloat64(162.39666946257347)   /* 0xC0644CB1, 0x84282266 */
var _ra5 = -Float64FromFloat64(184.60509290671104)   /* 0xC067135C, 0xEBCCABB2 */
var _ra6 = -Float64FromFloat64(81.2874355063066)     /* 0xC0545265, 0x57E4D2F2 */
var _ra7 = -Float64FromFloat64(9.814329344169145)    /* 0xC023A0EF, 0xC69AC25C */
var _sa1 = float64(19.651271667439257)               /* 0x4033A6B9, 0xBD707687 */
var _sa2 = float64(137.65775414351904)               /* 0x4061350C, 0x526AE721 */
var _sa3 = float64(434.56587747522923)               /* 0x407B290D, 0xD58A1A71 */
var _sa4 = float64(645.3872717332679)                /* 0x40842B19, 0x21EC2868 */
var _sa5 = float64(429.00814002756783)               /* 0x407AD021, 0x57700314 */
var _sa6 = float64(108.63500554177944)               /* 0x405B28A3, 0xEE48AE2C */
var _sa7 = float64(6.570249770319282)                /* 0x401A47EF, 0x8E484A93 */
var _sa8 = -Float64FromFloat64(0.0604244152148581)   /* 0xBFAEEFF2, 0xEE749A62 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb0 = -Float64FromFloat64(0.0098649429247001) /* 0xBF843412, 0x39E86F4A */
var _rb1 = -Float64FromFloat64(0.799283237680523)  /* 0xBFE993BA, 0x70C285DE */
var _rb2 = -Float64FromFloat64(17.757954917754752) /* 0xC031C209, 0x555F995A */
var _rb3 = -Float64FromFloat64(160.63638485582192) /* 0xC064145D, 0x43C5ED98 */
var _rb4 = -Float64FromFloat64(637.5664433683896)  /* 0xC083EC88, 0x1375F228 */
var _rb5 = -Float64FromFloat64(1025.0951316110772) /* 0xC0900461, 0x6A2E5992 */
var _rb6 = -Float64FromFloat64(483.5191916086514)  /* 0xC07E384E, 0x9BDC383F */
var _sb1 = float64(30.33806074348246)              /* 0x403E568B, 0x261D5190 */
var _sb2 = float64(325.7925129965739)              /* 0x40745CAE, 0x221B9F0A */
var _sb3 = float64(1536.729586084437)              /* 0x409802EB, 0x189D5118 */
var _sb4 = float64(3199.8582195085955)             /* 0x40A8FFB7, 0x688C246A */
var _sb5 = float64(2553.0504064331644)             /* 0x40A3F219, 0xCEDF3BE6 */
var _sb6 = float64(474.52854120695537)             /* 0x407DA874, 0xE79FE763 */
var _sb7 = -Float64FromFloat64(22.44095244658582)

func _erfc1(tls *TLS, x float64) (r float64) {
	var P Tdouble_t
	var Q Tdouble_t
	var s Tdouble_t
	s = x_fabs(tls, x) - Float64FromInt32(1)
	P = _pa0 + s*(_pa1+s*(_pa2+s*(_pa3+s*(_pa4+s*(_pa5+s*_pa6)))))
	Q = Float64FromInt32(1) + s*(_qa1+s*(_qa2+s*(_qa3+s*(_qa4+s*(_qa5+s*_qa6)))))
	return Float64FromInt32(1) - _erx - P/Q
}

func _erfc2(tls *TLS, ix Tuint32_t, x float64) (r float64) {
	var R Tdouble_t
	var S Tdouble_t
	var s Tdouble_t
	var z float64
	if ix < uint32(0x3ff40000) { /* |x| < 1.25 */
		return _erfc1(tls, x)
	}
	x = x_fabs(tls, x)
	s = Float64FromInt32(1) / (x * x)
	if ix < uint32(0x4006db6d) { /* |x| < 1/.35 ~ 2.85714 */
		R = _ra0 + s*(_ra1+s*(_ra2+s*(_ra3+s*(_ra4+s*(_ra5+s*(_ra6+s*_ra7))))))
		S = float64(1) + s*(_sa1+s*(_sa2+s*(_sa3+s*(_sa4+s*(_sa5+s*(_sa6+s*(_sa7+s*_sa8)))))))
	} else { /* |x| > 1/.35 */
		R = _rb0 + s*(_rb1+s*(_rb2+s*(_rb3+s*(_rb4+s*(_rb5+s*_rb6)))))
		S = float64(1) + s*(_sb1+s*(_sb2+s*(_sb3+s*(_sb4+s*(_sb5+s*(_sb6+s*_sb7))))))
	}
	z = x
	{
		z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: z}))))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))}))))
	}
	return x_exp(tls, -z*z-float64(0.5625)) * x_exp(tls, (z-x)*(z+x)+R/S) / x
}

func x_erf(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var r float64
	var s float64
	var sign int32
	var y float64
	var z float64
	var v1 float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		/* erf(nan)=nan, erf(+-inf)=+-1 */
		return float64(int32(1)-int32(2)*sign) + Float64FromInt32(1)/x
	}
	if ix < uint32(0x3feb0000) {
		/* |x| < 0.84375 */
		if ix < uint32(0x3e300000) {
			/* |x| < 2**-28 */
			/* avoid underflow */
			return float64(0.125) * (Float64FromInt32(8)*x + _efx8*x)
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = float64(1) + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		return x + x*y
	}
	if ix < uint32(0x40180000) { /* 0.84375 <= |x| < 6 */
		y = Float64FromInt32(1) - _erfc2(tls, ix, x)
	} else {
		y = Float64FromInt32(1) - Float64FromFloat64(2.2250738585072014e-308)
	}
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return v1
}

func x_erfc(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var r float64
	var s float64
	var sign int32
	var y float64
	var z float64
	var v1 float64
	var v2 float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		/* erfc(nan)=nan, erfc(+-inf)=0,2 */
		return float64(int32(2)*sign) + Float64FromInt32(1)/x
	}
	if ix < uint32(0x3feb0000) {
		/* |x| < 0.84375 */
		if ix < uint32(0x3c700000) { /* |x| < 2**-56 */
			return float64(1) - x
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = float64(1) + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		if sign != 0 || ix < uint32(0x3fd00000) {
			/* x < 1/4 */
			return float64(1) - (x + x*y)
		}
		return float64(0.5) - (x - float64(0.5) + x*y)
	}
	if ix < uint32(0x403c0000) {
		/* 0.84375 <= |x| < 28 */
		if sign != 0 {
			v1 = Float64FromInt32(2) - _erfc2(tls, ix, x)
		} else {
			v1 = _erfc2(tls, ix, x)
		}
		return v1
	}
	if sign != 0 {
		v2 = Float64FromInt32(2) - Float64FromFloat64(2.2250738585072014e-308)
	} else {
		v2 = Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(2.2250738585072014e-308)
	}
	return v2
}

var _erx1 = float32(0.84506291151) /* 0x3f58560b */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx81 = float32(1.027033329)                          /* 0x3f8375d4 */
var _pp01 = float32(0.12837916613)                         /* 0x3e0375d4 */
var _pp11 = float32(-Float64FromFloat64(0.32504209876))    /* 0xbea66beb */
var _pp21 = float32(-Float64FromFloat64(0.028481749818))   /* 0xbce9528f */
var _pp31 = float32(-Float64FromFloat64(0.005770270247))   /* 0xbbbd1489 */
var _pp41 = float32(-Float64FromFloat64(2.3763017452e-05)) /* 0xb7c756b1 */
var _qq11 = float32(0.39791721106)                         /* 0x3ecbbbce */
var _qq21 = float32(0.0650222525)                          /* 0x3d852a63 */
var _qq31 = float32(0.0050813062117)                       /* 0x3ba68116 */
var _qq41 = float32(0.00013249473704)                      /* 0x390aee49 */
var _qq51 = float32(-Float64FromFloat64(3.9602282413e-06)) /* 0xb684e21a */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa01 = float32(-Float64FromFloat64(0.0023621185683)) /* 0xbb1acdc6 */
var _pa11 = float32(0.41485610604)                        /* 0x3ed46805 */
var _pa21 = float32(-Float64FromFloat64(0.37220788002))   /* 0xbebe9208 */
var _pa31 = float32(0.31834661961)                        /* 0x3ea2fe54 */
var _pa41 = float32(-Float64FromFloat64(0.11089469492))   /* 0xbde31cc2 */
var _pa51 = float32(0.035478305072)                       /* 0x3d1151b3 */
var _pa61 = float32(-Float64FromFloat64(0.0021663755178)) /* 0xbb0df9c0 */
var _qa11 = float32(0.10642088205)                        /* 0x3dd9f331 */
var _qa21 = float32(0.54039794207)                        /* 0x3f0a5785 */
var _qa31 = float32(0.071828655899)                       /* 0x3d931ae7 */
var _qa41 = float32(0.12617121637)                        /* 0x3e013307 */
var _qa51 = float32(0.013637083583)                       /* 0x3c5f6e13 */
var _qa61 = float32(0.011984500103)                       /* 0x3c445aa3 */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra01 = float32(-Float64FromFloat64(0.0098649440333)) /* 0xbc21a093 */
var _ra11 = float32(-Float64FromFloat64(0.6938585639))    /* 0xbf31a0b7 */
var _ra21 = float32(-Float64FromFloat64(10.558626175))    /* 0xc128f022 */
var _ra31 = float32(-Float64FromFloat64(62.375331879))    /* 0xc2798057 */
var _ra41 = float32(-Float64FromFloat64(162.39666748))    /* 0xc322658c */
var _ra51 = float32(-Float64FromFloat64(184.60508728))    /* 0xc3389ae7 */
var _ra61 = float32(-Float64FromFloat64(81.287437439))    /* 0xc2a2932b */
var _ra71 = float32(-Float64FromFloat64(9.8143291473))    /* 0xc11d077e */
var _sa11 = float32(19.65127182)                          /* 0x419d35ce */
var _sa21 = float32(137.65776062)                         /* 0x4309a863 */
var _sa31 = float32(434.56588745)                         /* 0x43d9486f */
var _sa41 = float32(645.38726807)                         /* 0x442158c9 */
var _sa51 = float32(429.00814819)                         /* 0x43d6810b */
var _sa61 = float32(108.63500214)                         /* 0x42d9451f */
var _sa71 = float32(6.5702495575)                         /* 0x40d23f7c */
var _sa81 = float32(-Float64FromFloat64(0.060424413532))  /* 0xbd777f97 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb01 = float32(-Float64FromFloat64(0.009864943102)) /* 0xbc21a092 */
var _rb11 = float32(-Float64FromFloat64(0.79928326607))  /* 0xbf4c9dd4 */
var _rb21 = float32(-Float64FromFloat64(17.757955551))   /* 0xc18e104b */
var _rb31 = float32(-Float64FromFloat64(160.63638306))   /* 0xc320a2ea */
var _rb41 = float32(-Float64FromFloat64(637.56646729))   /* 0xc41f6441 */
var _rb51 = float32(-Float64FromFloat64(1025.0950928))   /* 0xc480230b */
var _rb61 = float32(-Float64FromFloat64(483.51919556))   /* 0xc3f1c275 */
var _sb11 = float32(30.338060379)                        /* 0x41f2b459 */
var _sb21 = float32(325.79251099)                        /* 0x43a2e571 */
var _sb31 = float32(1536.7296143)                        /* 0x44c01759 */
var _sb41 = float32(3199.8581543)                        /* 0x4547fdbb */
var _sb51 = float32(2553.050293)                         /* 0x451f90ce */
var _sb61 = float32(474.52853394)                        /* 0x43ed43a7 */
var _sb71 = float32(-Float64FromFloat64(22.440952301))

func _erfc11(tls *TLS, x float32) (r float32) {
	var P Tfloat_t
	var Q Tfloat_t
	var s Tfloat_t
	s = x_fabsf(tls, x) - Float32FromInt32(1)
	P = _pa01 + s*(_pa11+s*(_pa21+s*(_pa31+s*(_pa41+s*(_pa51+s*_pa61)))))
	Q = Float32FromInt32(1) + s*(_qa11+s*(_qa21+s*(_qa31+s*(_qa41+s*(_qa51+s*_qa61)))))
	return Float32FromInt32(1) - _erx1 - P/Q
}

func _erfc21(tls *TLS, ix Tuint32_t, x float32) (r float32) {
	var R Tfloat_t
	var S Tfloat_t
	var s Tfloat_t
	var z float32
	if ix < uint32(0x3fa00000) { /* |x| < 1.25 */
		return _erfc11(tls, x)
	}
	x = x_fabsf(tls, x)
	s = Float32FromInt32(1) / (x * x)
	if ix < uint32(0x4036db6d) { /* |x| < 1/0.35 */
		R = _ra01 + s*(_ra11+s*(_ra21+s*(_ra31+s*(_ra41+s*(_ra51+s*(_ra61+s*_ra71))))))
		S = Float32FromFloat32(1) + s*(_sa11+s*(_sa21+s*(_sa31+s*(_sa41+s*(_sa51+s*(_sa61+s*(_sa71+s*_sa81)))))))
	} else { /* |x| >= 1/0.35 */
		R = _rb01 + s*(_rb11+s*(_rb21+s*(_rb31+s*(_rb41+s*(_rb51+s*_rb61)))))
		S = Float32FromFloat32(1) + s*(_sb11+s*(_sb21+s*(_sb31+s*(_sb41+s*(_sb51+s*(_sb61+s*_sb71))))))
	}
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	{
		z = *(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float32
			F_i Tuint32_t
		}{F_i: ix & uint32(0xffffe000)}))))
	}
	return x_expf(tls, -z*z-Float32FromFloat32(0.5625)) * x_expf(tls, (z-x)*(z+x)+R/S) / x
}

func x_erff(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var r float32
	var s float32
	var sign int32
	var y float32
	var z float32
	var v1 float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		/* erf(nan)=nan, erf(+-inf)=+-1 */
		return float32(int32(1)-int32(2)*sign) + Float32FromInt32(1)/x
	}
	if ix < uint32(0x3f580000) {
		/* |x| < 0.84375 */
		if ix < uint32(0x31800000) {
			/* |x| < 2**-28 */
			/*avoid underflow */
			return Float32FromFloat32(0.125) * (Float32FromInt32(8)*x + _efx81*x)
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = Float32FromInt32(1) + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		return x + x*y
	}
	if ix < uint32(0x40c00000) { /* |x| < 6 */
		y = Float32FromInt32(1) - _erfc21(tls, ix, x)
	} else {
		y = Float32FromInt32(1) - Float32FromFloat32(7.52316384526264e-37)
	}
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return v1
}

func x_erfcf(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var r float32
	var s float32
	var sign int32
	var y float32
	var z float32
	var v1 float32
	var v2 float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		/* erfc(nan)=nan, erfc(+-inf)=0,2 */
		return float32(int32(2)*sign) + Float32FromInt32(1)/x
	}
	if ix < uint32(0x3f580000) {
		/* |x| < 0.84375 */
		if ix < uint32(0x23800000) { /* |x| < 2**-56 */
			return Float32FromFloat32(1) - x
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = Float32FromFloat32(1) + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		if sign != 0 || ix < uint32(0x3e800000) { /* x < 1/4 */
			return Float32FromFloat32(1) - (x + x*y)
		}
		return Float32FromFloat32(0.5) - (x - Float32FromFloat32(0.5) + x*y)
	}
	if ix < uint32(0x41e00000) {
		/* |x| < 28 */
		if sign != 0 {
			v1 = Float32FromInt32(2) - _erfc21(tls, ix, x)
		} else {
			v1 = _erfc21(tls, ix, x)
		}
		return v1
	}
	if sign != 0 {
		v2 = Float32FromInt32(2) - Float32FromFloat32(7.52316384526264e-37)
	} else {
		v2 = Float32FromFloat32(7.52316384526264e-37) * Float32FromFloat32(7.52316384526264e-37)
	}
	return v2
}

func x_erfl(tls *TLS, x float64) (r float64) {
	return x_erf(tls, x)
}

func x_erfcl(tls *TLS, x float64) (r float64) {
	return x_erfc(tls, x)
}

const m_EXP2_POLY_ORDER = 5
const m_EXP_POLY_ORDER = 5
const m_EXP_TABLE_BITS = 7
const m_WANT_ROUNDING = 1

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi Tdouble_t
	var lo Tdouble_t
	var scale Tdouble_t
	var y Tdouble_t
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by <= 460.  */
		sbits = sbits - Uint64FromUint64(1009)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: sbits}))))
		y = float64(5.486124068793689e+303) * (scale + scale*tmp)
		return _eval_as_double(tls, y)
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	y = scale + scale*tmp
	if y < float64(1) {
		/* Round y to the right precision before scaling it into the subnormal
		range to avoid double rounding that can cause 0.5+E/2 ulp error where
		E is the worst-case ulp error outside the subnormal range.  So this
		is only useful if the goal is better than 1 ulp worst-case error.  */
		lo = scale - y + scale*tmp
		hi = float64(1) + y
		lo = float64(1) - hi + y + lo
		y = _eval_as_double(tls, hi+lo) - float64(1)
		/* Avoid -0.0 with downward rounding.  */
		if int32(m_WANT_ROUNDING) != 0 && y == float64(0) {
			y = float64(0)
		}
		/* The underflow exception needs to be signaled explicitly.  */
		_fp_force_eval(tls, _fp_barrier(tls, float64(2.2250738585072014e-308))*float64(2.2250738585072014e-308))
	}
	y = float64(2.2250738585072014e-308) * y
	return _eval_as_double(tls, y)
}

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top12(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x})))) >> int32(52))
}

func x_exp(tls *TLS, x float64) (r1 float64) {
	var abstop Tuint32_t
	var idx Tuint64_t
	var kd Tdouble_t
	var ki Tuint64_t
	var r Tdouble_t
	var r2 Tdouble_t
	var sbits Tuint64_t
	var scale Tdouble_t
	var tail Tdouble_t
	var tmp Tdouble_t
	var top Tuint64_t
	var z Tdouble_t
	abstop = _top12(tls, x) & uint32(0x7ff)
	if ___builtin_expect(tls, BoolInt32(abstop-_top12(tls, float64(5.551115123125783e-17)) >= _top12(tls, float64(512))-_top12(tls, float64(5.551115123125783e-17))), int32(0)) != 0 {
		if abstop-_top12(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			return float64(1) + x
		}
		if abstop >= _top12(tls, float64(1024)) {
			if *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x})))) == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(-___builtin_inff(tls))})))) {
				return float64(0)
			}
			if abstop >= _top12(tls, float64(___builtin_inff(tls))) {
				return float64(1) + x
			}
			if *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x}))))>>int32(63) != 0 {
				return x___math_uflow(tls, uint32(0))
			} else {
				return x___math_oflow(tls, uint32(0))
			}
		}
		/* Large x is special cased below.  */
		abstop = uint32(0)
	}
	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].  */
	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].  */
	z = x___exp_data.Finvln2N * x
	/* z - kd is in [-1, 1] in non-nearest rounding modes.  */
	kd = _eval_as_double(tls, z+x___exp_data.Fshift)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd}))))
	kd = kd - x___exp_data.Fshift
	r = x + kd*x___exp_data.Fnegln2hiN + kd*x___exp_data.Fnegln2loN
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP_TABLE_BITS)))
	top = ki << (Int32FromInt32(52) - Int32FromInt32(m_EXP_TABLE_BITS))
	tail = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx)*8))}))))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx+Uint64FromInt32(1))*8)) + top
	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.25/N ulp larger.  */
	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(5)-Int32FromInt32(m_EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(6)-Int32FromInt32(m_EXP_POLY_ORDER))*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(7)-Int32FromInt32(m_EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(8)-Int32FromInt32(m_EXP_POLY_ORDER))*8)))
	if ___builtin_expect(tls, BoolInt32(abstop == uint32(0)), int32(0)) != 0 {
		return _specialcase(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
	   is no spurious underflow here even without fma.  */
	return _eval_as_double(tls, scale+scale*tmp)
}

func x_exp10(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var y float64
	var _ /* n at bp+0 */ float64
	var _ /* u at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	y = x_modf(tls, x, bp)
	*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(bp))
	/* fabs(n) < 16 without raising invalid on nan */
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>int32(52)&uint64(0x7ff) < uint64(Int32FromInt32(0x3ff)+Int32FromInt32(4)) {
		if !(y != 0) {
			return _p10[int32(*(*float64)(unsafe.Pointer(bp)))+int32(15)]
		}
		y = x_exp2(tls, float64(3.321928094887362)*y)
		return y * _p10[int32(*(*float64)(unsafe.Pointer(bp)))+int32(15)]
	}
	return x_pow(tls, float64(10), x)
}

var _p10 = [31]float64{
	0:  float64(1e-15),
	1:  float64(1e-14),
	2:  float64(1e-13),
	3:  float64(1e-12),
	4:  float64(1e-11),
	5:  float64(1e-10),
	6:  float64(1e-09),
	7:  float64(1e-08),
	8:  float64(1e-07),
	9:  float64(1e-06),
	10: float64(1e-05),
	11: float64(0.0001),
	12: float64(0.001),
	13: float64(0.01),
	14: float64(0.1),
	15: Float64FromInt32(1),
	16: float64(10),
	17: float64(100),
	18: float64(1000),
	19: float64(10000),
	20: float64(100000),
	21: float64(1e+06),
	22: float64(1e+07),
	23: float64(1e+08),
	24: float64(1e+09),
	25: float64(1e+10),
	26: float64(1e+11),
	27: float64(1e+12),
	28: float64(1e+13),
	29: float64(1e+14),
	30: float64(1e+15)}

func x_exp10f(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var y float32
	var _ /* n at bp+0 */ float32
	var _ /* u at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	y = x_modff(tls, x, bp)
	*(*float32)(unsafe.Pointer(bp + 4)) = *(*float32)(unsafe.Pointer(bp))
	/* fabsf(n) < 8 without raising invalid on nan */
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4))>>int32(23)&uint32(0xff) < uint32(Int32FromInt32(0x7f)+Int32FromInt32(3)) {
		if !(y != 0) {
			return _p101[int32(*(*float32)(unsafe.Pointer(bp)))+int32(7)]
		}
		y = x_exp2f(tls, Float32FromFloat32(3.321928094887362)*y)
		return y * _p101[int32(*(*float32)(unsafe.Pointer(bp)))+int32(7)]
	}
	return float32(x_exp2(tls, float64(3.321928094887362)*float64(x)))
}

var _p101 = [15]float32{
	0:  Float32FromFloat32(1e-07),
	1:  Float32FromFloat32(1e-06),
	2:  Float32FromFloat32(1e-05),
	3:  Float32FromFloat32(0.0001),
	4:  Float32FromFloat32(0.001),
	5:  Float32FromFloat32(0.01),
	6:  Float32FromFloat32(0.1),
	7:  Float32FromInt32(1),
	8:  float32(10),
	9:  float32(100),
	10: float32(1000),
	11: float32(10000),
	12: float32(100000),
	13: float32(1e+06),
	14: float32(1e+07)}

func x_exp10l(tls *TLS, x float64) (r float64) {
	return x_exp10(tls, x)
}

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase1(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi Tdouble_t
	var lo Tdouble_t
	var scale Tdouble_t
	var y Tdouble_t
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by 1.  */
		sbits = sbits - Uint64FromUint64(1)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: sbits}))))
		y = Float64FromInt32(2) * (scale + scale*tmp)
		return _eval_as_double(tls, y)
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	y = scale + scale*tmp
	if y < float64(1) {
		/* Round y to the right precision before scaling it into the subnormal
		   range to avoid double rounding that can cause 0.5+E/2 ulp error where
		   E is the worst-case ulp error outside the subnormal range.  So this
		   is only useful if the goal is better than 1 ulp worst-case error.  */
		lo = scale - y + scale*tmp
		hi = float64(1) + y
		lo = float64(1) - hi + y + lo
		y = _eval_as_double(tls, hi+lo) - float64(1)
		/* Avoid -0.0 with downward rounding.  */
		if int32(m_WANT_ROUNDING) != 0 && y == float64(0) {
			y = float64(0)
		}
		/* The underflow exception needs to be signaled explicitly.  */
		_fp_force_eval(tls, _fp_barrier(tls, float64(2.2250738585072014e-308))*float64(2.2250738585072014e-308))
	}
	y = float64(2.2250738585072014e-308) * y
	return _eval_as_double(tls, y)
}

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top121(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x})))) >> int32(52))
}

func x_exp2(tls *TLS, x float64) (r1 float64) {
	var abstop Tuint32_t
	var idx Tuint64_t
	var kd Tdouble_t
	var ki Tuint64_t
	var r Tdouble_t
	var r2 Tdouble_t
	var sbits Tuint64_t
	var scale Tdouble_t
	var tail Tdouble_t
	var tmp Tdouble_t
	var top Tuint64_t
	abstop = _top121(tls, x) & uint32(0x7ff)
	if ___builtin_expect(tls, BoolInt32(abstop-_top121(tls, float64(5.551115123125783e-17)) >= _top121(tls, float64(512))-_top121(tls, float64(5.551115123125783e-17))), int32(0)) != 0 {
		if abstop-_top121(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			return float64(1) + x
		}
		if abstop >= _top121(tls, float64(1024)) {
			if *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x})))) == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(-___builtin_inff(tls))})))) {
				return float64(0)
			}
			if abstop >= _top121(tls, float64(___builtin_inff(tls))) {
				return float64(1) + x
			}
			if !(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x}))))>>Int32FromInt32(63) != 0) {
				return x___math_oflow(tls, uint32(0))
			} else {
				if *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
					F_i [0]Tuint64_t
					F_f float64
				}{F_f: x})))) >= *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
					F_i [0]Tuint64_t
					F_f float64
				}{F_f: -Float64FromFloat64(1075)})))) {
					return x___math_uflow(tls, uint32(0))
				}
			}
		}
		if uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) > uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: float64(928)})))) {
			/* Large x is special cased below.  */
			abstop = uint32(0)
		}
	}
	/* exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].  */
	/* x = k/N + r, with int k and r in [-1/2N, 1/2N].  */
	kd = _eval_as_double(tls, x+x___exp_data.Fexp2_shift)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd})))) /* k.  */
	kd = kd - x___exp_data.Fexp2_shift /* k/N for int k.  */
	r = x - kd
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP_TABLE_BITS)))
	top = ki << (Int32FromInt32(52) - Int32FromInt32(m_EXP_TABLE_BITS))
	tail = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx)*8))}))))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx+Uint64FromInt32(1))*8)) + top
	/* exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.5/N ulp larger.  */
	/* Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fexp2_poly)) + UintptrFromInt32(0)*8)) + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fexp2_poly)) + UintptrFromInt32(1)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fexp2_poly)) + UintptrFromInt32(2)*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fexp2_poly)) + UintptrFromInt32(3)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fexp2_poly)) + UintptrFromInt32(4)*8)))
	if ___builtin_expect(tls, BoolInt32(abstop == uint32(0)), int32(0)) != 0 {
		return _specialcase1(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	/* Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there
	   is no spurious underflow here even without fma.  */
	return _eval_as_double(tls, scale+scale*tmp)
}

const m_EXP2F_POLY_ORDER = 3
const m_EXP2F_TABLE_BITS = 5

func _top122(tls *TLS, x float32) (r Tuint32_t) {
	return *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: x})))) >> int32(20)
}

func x_exp2f(tls *TLS, x float32) (r1 float32) {
	var abstop Tuint32_t
	var kd Tdouble_t
	var ki Tuint64_t
	var r Tdouble_t
	var r2 Tdouble_t
	var s Tdouble_t
	var t Tuint64_t
	var xd Tdouble_t
	var y Tdouble_t
	var z Tdouble_t
	xd = float64(x)
	abstop = _top122(tls, x) & uint32(0x7ff)
	if ___builtin_expect(tls, BoolInt32(abstop >= _top122(tls, Float32FromFloat32(128))), int32(0)) != 0 {
		/* |x| >= 128 or x is nan.  */
		if *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x})))) == *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: -___builtin_inff(tls)})))) {
			return Float32FromFloat32(0)
		}
		if abstop >= _top122(tls, ___builtin_inff(tls)) {
			return x + x
		}
		if x > Float32FromFloat32(0) {
			return x___math_oflowf(tls, uint32(0))
		}
		if x <= -Float32FromFloat32(150) {
			return x___math_uflowf(tls, uint32(0))
		}
	}
	/* x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.  */
	kd = _eval_as_double(tls, xd+x___exp2f_data.Fshift_scaled)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd}))))
	kd = kd - x___exp2f_data.Fshift_scaled /* k/N for int k.  */
	r = xd - kd
	/* exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Ftab)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)))*8))
	t = t + ki<<(Int32FromInt32(52)-Int32FromInt32(m_EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: t}))))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(0)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(1)*8))
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(2)*8))*r + Float64FromInt32(1)
	y = z*r2 + y
	y = y * s
	return _eval_as_float(tls, float32(y))
}

type Texp2f_data = struct {
	Ftab           [32]Tuint64_t
	Fshift_scaled  float64
	Fpoly          [3]float64
	Fshift         float64
	Finvln2_scaled float64
	Fpoly_scaled   [3]float64
}

type Texp_data = struct {
	Finvln2N    float64
	Fshift      float64
	Fnegln2hiN  float64
	Fnegln2loN  float64
	Fpoly       [4]float64
	Fexp2_shift float64
	Fexp2_poly  [5]float64
	Ftab        [256]Tuint64_t
}

func _top123(tls *TLS, x float32) (r Tuint32_t) {
	return *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: x})))) >> int32(20)
}

func x_expf(tls *TLS, x float32) (r1 float32) {
	var abstop Tuint32_t
	var kd Tdouble_t
	var ki Tuint64_t
	var r Tdouble_t
	var r2 Tdouble_t
	var s Tdouble_t
	var t Tuint64_t
	var xd Tdouble_t
	var y Tdouble_t
	var z Tdouble_t
	xd = float64(x)
	abstop = _top123(tls, x) & uint32(0x7ff)
	if ___builtin_expect(tls, BoolInt32(abstop >= _top123(tls, Float32FromFloat32(88))), int32(0)) != 0 {
		/* |x| >= 88 or x is nan.  */
		if *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x})))) == *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: -___builtin_inff(tls)})))) {
			return Float32FromFloat32(0)
		}
		if abstop >= _top123(tls, ___builtin_inff(tls)) {
			return x + x
		}
		if x > Float32FromFloat32(88.72283172607422) { /* x > log(0x1p128) ~= 88.72 */
			return x___math_oflowf(tls, uint32(0))
		}
		if x < -Float32FromFloat32(103.97207641601562) { /* x < log(0x1p-150) ~= -103.97 */
			return x___math_uflowf(tls, uint32(0))
		}
	}
	/* x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.  */
	z = x___exp2f_data.Finvln2_scaled * xd
	/* Round and convert z to int, the result is in [-150*N, 128*N] and
	   ideally ties-to-even rule is used, otherwise the magnitude of r
	   can be bigger which gives larger approximation error.  */
	kd = _eval_as_double(tls, z+x___exp2f_data.Fshift)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd}))))
	kd = kd - x___exp2f_data.Fshift
	r = z - kd
	/* exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Ftab)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)))*8))
	t = t + ki<<(Int32FromInt32(52)-Int32FromInt32(m_EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: t}))))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly_scaled)) + UintptrFromInt32(0)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly_scaled)) + UintptrFromInt32(1)*8))
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly_scaled)) + UintptrFromInt32(2)*8))*r + Float64FromInt32(1)
	y = z*r2 + y
	y = y * s
	return _eval_as_float(tls, float32(y))
}

var _o_threshold = float64(709.782712893384)  /* 0x40862E42, 0xFEFA39EF */
var _ln2_hi = float64(0.6931471803691238)     /* 0x3fe62e42, 0xfee00000 */
var _ln2_lo = float64(1.9082149292705877e-10) /* 0x3dea39ef, 0x35793c76 */
var _invln2 = float64(1.4426950408889634)     /* 0x3ff71547, 0x652b82fe */
/* Scaled Q's: Qn_here = 2**n * Qn_above, for R(2*z) where z = hxs = x*x/2: */
var _Q1 = -Float64FromFloat64(0.03333333333333313)  /* BFA11111 111110F4 */
var _Q2 = float64(0.0015873015872548146)            /* 3F5A01A0 19FE5585 */
var _Q3 = -Float64FromFloat64(7.93650757867488e-05) /* BF14CE19 9EAADBB7 */
var _Q4 = float64(4.008217827329362e-06)            /* 3ED0CFCA 86E65239 */
var _Q5 = -Float64FromFloat64(2.0109921818362437e-07)

func x_expm1(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c Tdouble_t
	var e Tdouble_t
	var hfx Tdouble_t
	var hi Tdouble_t
	var hx Tuint32_t
	var hxs Tdouble_t
	var k int32
	var lo Tdouble_t
	var r1 Tdouble_t
	var sign int32
	var t Tdouble_t
	var twopk Tdouble_t
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 float64
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4043687A) {
		/* if |x|>=56*ln2 */
		if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			return x
		}
		if sign != 0 {
			return float64(-Int32FromInt32(1))
		}
		if x > _o_threshold {
			x = x * Float64FromFloat64(8.98846567431158e+307)
			return x
		}
	}
	/* argument reduction */
	if hx > uint32(0x3fd62e42) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3FF0A2B2) { /* and |x| < 1.5 ln2 */
			if !(sign != 0) {
				hi = x - _ln2_hi
				lo = _ln2_lo
				k = int32(1)
			} else {
				hi = x + _ln2_hi
				lo = -_ln2_lo
				k = -int32(1)
			}
		} else {
			if sign != 0 {
				v1 = -Float64FromFloat64(0.5)
			} else {
				v1 = float64(0.5)
			}
			k = int32(_invln2*x + v1)
			t = float64(k)
			hi = x - t*_ln2_hi /* t*ln2_hi is exact here */
			lo = t * _ln2_lo
		}
		x = hi - lo
		c = hi - x - lo
	} else {
		if hx < uint32(0x3c900000) { /* |x| < 2**-54, return x */
			if hx < uint32(0x00100000) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, float32(x))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(float32(x)))
						} else {
							_fp_force_evall(tls, float64(float32(x)))
						}
					}
				}
			}
			return x
		} else {
			k = int32(0)
		}
	}
	/* x is now in primary range */
	hfx = float64(0.5) * x
	hxs = x * hfx
	r1 = float64(1) + hxs*(_Q1+hxs*(_Q2+hxs*(_Q3+hxs*(_Q4+hxs*_Q5))))
	t = float64(3) - r1*hfx
	e = hxs * ((r1 - t) / (Float64FromFloat64(6) - x*t))
	if k == int32(0) { /* c is 0 */
		return x - (x*e - hxs)
	}
	e = x*(e-c) - c
	e = e - hxs
	/* exp(x) ~ 2^k (x_reduced - e + 1) */
	if k == -int32(1) {
		return float64(0.5)*(x-e) - float64(0.5)
	}
	if k == int32(1) {
		if x < -Float64FromFloat64(0.25) {
			return -Float64FromFloat64(2) * (e - (x + Float64FromFloat64(0.5)))
		}
		return float64(1) + float64(2)*(x-e)
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(Int32FromInt32(0x3ff)+k) << int32(52) /* 2^k */
	twopk = *(*float64)(unsafe.Pointer(bp))
	if k < int32(0) || k > int32(56) {
		/* suffice to return exp(x)-1 */
		y = x - e + float64(1)
		if k == int32(1024) {
			y = y * float64(2) * float64(8.98846567431158e+307)
		} else {
			y = y * twopk
		}
		return y - float64(1)
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(Int32FromInt32(0x3ff)-k) << int32(52) /* 2^-k */
	if k < int32(20) {
		y = (x - e + (Float64FromInt32(1) - *(*float64)(unsafe.Pointer(bp)))) * twopk
	} else {
		y = (x - (e + *(*float64)(unsafe.Pointer(bp))) + Float64FromInt32(1)) * twopk
	}
	return y
}

var _ln2_hi1 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo1 = float32(9.0580006145e-06) /* 0x3717f7d1 */
var _invln21 = float32(1.4426950216)     /* 0x3fb8aa3b */
/*
 * Domain [-0.34568, 0.34568], range ~[-6.694e-10, 6.696e-10]:
 * |6 / x * (1 + 2 * (1 / (exp(x) - 1) - 1 / x)) - q(x)| < 2**-30.04
 * Scaled coefficients: Qn_here = 2**n * Qn_for_q (see s_expm1.c):
 */
var _Q11 = float32(-Float64FromFloat64(0.033333212137)) /* -0x888868.0p-28 */
var _Q21 = float32(0.0015807170421)

func x_expm1f(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c Tfloat_t
	var e Tfloat_t
	var hfx Tfloat_t
	var hi Tfloat_t
	var hx Tuint32_t
	var hxs Tfloat_t
	var k int32
	var lo Tfloat_t
	var r1 Tfloat_t
	var sign int32
	var t Tfloat_t
	var twopk Tfloat_t
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v1 float32
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4195b844) {
		/* if |x|>=27*ln2 */
		if hx > uint32(0x7f800000) { /* NaN */
			return x
		}
		if sign != 0 {
			return float32(-Int32FromInt32(1))
		}
		if hx > uint32(0x42b17217) {
			/* x > log(FLT_MAX) */
			x = x * Float32FromFloat32(1.7014118346046923e+38)
			return x
		}
	}
	/* argument reduction */
	if hx > uint32(0x3eb17218) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3F851592) { /* and |x| < 1.5 ln2 */
			if !(sign != 0) {
				hi = x - _ln2_hi1
				lo = _ln2_lo1
				k = int32(1)
			} else {
				hi = x + _ln2_hi1
				lo = -_ln2_lo1
				k = -int32(1)
			}
		} else {
			if sign != 0 {
				v1 = -Float32FromFloat32(0.5)
			} else {
				v1 = Float32FromFloat32(0.5)
			}
			k = int32(_invln21*x + v1)
			t = float32(k)
			hi = x - t*_ln2_hi1 /* t*ln2_hi is exact here */
			lo = t * _ln2_lo1
		}
		x = hi - lo
		c = hi - x - lo
	} else {
		if hx < uint32(0x33000000) { /* when |x|<2**-25, return x */
			if hx < uint32(0x00800000) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, x*x)
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(x*x))
						} else {
							_fp_force_evall(tls, float64(x*x))
						}
					}
				}
			}
			return x
		} else {
			k = int32(0)
		}
	}
	/* x is now in primary range */
	hfx = Float32FromFloat32(0.5) * x
	hxs = x * hfx
	r1 = Float32FromFloat32(1) + hxs*(_Q11+hxs*_Q21)
	t = Float32FromFloat32(3) - r1*hfx
	e = hxs * ((r1 - t) / (Float32FromFloat32(6) - x*t))
	if k == int32(0) { /* c is 0 */
		return x - (x*e - hxs)
	}
	e = x*(e-c) - c
	e = e - hxs
	/* exp(x) ~ 2^k (x_reduced - e + 1) */
	if k == -int32(1) {
		return Float32FromFloat32(0.5)*(x-e) - Float32FromFloat32(0.5)
	}
	if k == int32(1) {
		if x < -Float32FromFloat32(0.25) {
			return -Float32FromFloat32(2) * (e - (x + Float32FromFloat32(0.5)))
		}
		return Float32FromFloat32(1) + Float32FromFloat32(2)*(x-e)
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32((int32(0x7f) + k) << int32(23)) /* 2^k */
	twopk = *(*float32)(unsafe.Pointer(bp))
	if k < int32(0) || k > int32(56) {
		/* suffice to return exp(x)-1 */
		y = x - e + Float32FromFloat32(1)
		if k == int32(128) {
			y = y * Float32FromFloat32(2) * Float32FromFloat32(1.7014118346046923e+38)
		} else {
			y = y * twopk
		}
		return y - Float32FromFloat32(1)
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32((int32(0x7f) - k) << int32(23)) /* 2^-k */
	if k < int32(23) {
		y = (x - e + (Float32FromInt32(1) - *(*float32)(unsafe.Pointer(bp)))) * twopk
	} else {
		y = (x - (e + *(*float32)(unsafe.Pointer(bp))) + Float32FromInt32(1)) * twopk
	}
	return y
}

func x_fabs(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	return *(*float64)(unsafe.Pointer(bp))
}

func x_fabsf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	return *(*float32)(unsafe.Pointer(bp))
}

func x_fdim(tls *TLS, x float64, y float64) (r float64) {
	var v1 float64
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	if BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	if x > y {
		v1 = x - y
	} else {
		v1 = Float64FromInt32(0)
	}
	return v1
}

func x_fdimf(tls *TLS, x float32, y float32) (r float32) {
	var v1 float32
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	if BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	if x > y {
		v1 = x - y
	} else {
		v1 = Float32FromInt32(0)
	}
	return v1
}

func x_fdiml(tls *TLS, x float64, y float64) (r float64) {
	return x_fdim(tls, x, y)
}

func x_finite(tls *TLS, x float64) (r int32) {
	return BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52))
}

func x_finitef(tls *TLS, x float32) (r int32) {
	return BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) < uint32(0x7f800000))
}

var _toint3 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func x_floor(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 int32
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) || x == Float64FromInt32(0) {
		return x
	}
	/* y = int(x) - x, where int(x) is an integer neighbor of x */
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y = x - _toint3 + _toint3 - x
	} else {
		y = x + _toint3 - _toint3 - x
	}
	/* special case because of non-nearest rounding modes */
	if e <= Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		{
			if uint64(8) == uint64(4) {
				_fp_force_evalf(tls, float32(y))
			} else {
				if uint64(8) == uint64(8) {
					_fp_force_eval(tls, y)
				} else {
					_fp_force_evall(tls, y)
				}
			}
		}
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			v1 = -int32(1)
		} else {
			v1 = int32(0)
		}
		return float64(v1)
	}
	if y > Float64FromInt32(0) {
		return x + y - Float64FromInt32(1)
	}
	return x + y
}

func x_floorf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var m Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	if e >= int32(23) {
		return x
	}
	if e >= int32(0) {
		m = uint32(int32(0x007fffff) >> e)
		if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
			return x
		}
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				} else {
					_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				}
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
			p1 = bp
			*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) + m
		}
		p2 = bp
		*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) & ^m
	} else {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				} else {
					_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
				}
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) == uint32(0) {
			*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32(0)
		} else {
			if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
				*(*float32)(unsafe.Pointer(bp)) = float32(-Float64FromFloat64(1))
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func x_fmal(tls *TLS, x float64, y float64, z float64) (r float64) {
	return x_fma(tls, x, y, z)
}

func x_fmax(tls *TLS, x float64, y float64) (r float64) {
	var v1 float64
	var v2 float64
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	if BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	if int32(___DOUBLE_BITS(tls, x)>>Int32FromInt32(63)) != int32(___DOUBLE_BITS(tls, y)>>Int32FromInt32(63)) {
		if int32(___DOUBLE_BITS(tls, x)>>Int32FromInt32(63)) != 0 {
			v1 = y
		} else {
			v1 = x
		}
		return v1
	}
	if x < y {
		v2 = y
	} else {
		v2 = x
	}
	return v2
}

func x_fmaxf(tls *TLS, x float32, y float32) (r float32) {
	var v1 float32
	var v2 float32
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	if BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	/* handle signed zeroes, see C99 Annex F.9.9.2 */
	if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != int32(___FLOAT_BITS(tls, y)>>Int32FromInt32(31)) {
		if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != 0 {
			v1 = y
		} else {
			v1 = x
		}
		return v1
	}
	if x < y {
		v2 = y
	} else {
		v2 = x
	}
	return v2
}

func x_fmaxl(tls *TLS, x float64, y float64) (r float64) {
	return x_fmax(tls, x, y)
}

func x_fmin(tls *TLS, x float64, y float64) (r float64) {
	var v1 float64
	var v2 float64
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	if BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	if int32(___DOUBLE_BITS(tls, x)>>Int32FromInt32(63)) != int32(___DOUBLE_BITS(tls, y)>>Int32FromInt32(63)) {
		if int32(___DOUBLE_BITS(tls, x)>>Int32FromInt32(63)) != 0 {
			v1 = x
		} else {
			v1 = y
		}
		return v1
	}
	if x < y {
		v2 = x
	} else {
		v2 = y
	}
	return v2
}

func x_fminf(tls *TLS, x float32, y float32) (r float32) {
	var v1 float32
	var v2 float32
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	if BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != int32(___FLOAT_BITS(tls, y)>>Int32FromInt32(31)) {
		if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != 0 {
			v1 = x
		} else {
			v1 = y
		}
		return v1
	}
	if x < y {
		v2 = x
	} else {
		v2 = y
	}
	return v2
}

func x_fminl(tls *TLS, x float64, y float64) (r float64) {
	return x_fmin(tls, x, y)
}

func x_fmod(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ex int32
	var ey int32
	var i Tuint64_t
	var sx int32
	var uxi Tuint64_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52) & uint64(0x7ff))
	sx = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* in the followings uxi should be ux.i, but then gcc wrongly adds */
	/* float load/store to inner loops ruining performance and code size */
	uxi = *(*Tuint64_t)(unsafe.Pointer(bp))
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8))<<int32(1) == uint64(0) || BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || ex == int32(0x7ff) {
		return x * y / (x * y)
	}
	if uxi<<int32(1) <= *(*Tuint64_t)(unsafe.Pointer(bp + 8))<<int32(1) {
		if uxi<<int32(1) == *(*Tuint64_t)(unsafe.Pointer(bp + 8))<<int32(1) {
			return Float64FromInt32(0) * x
		}
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		for i = uxi << int32(12); i>>int32(63) == uint64(0); {
			goto _1
		_1:
			ex--
			i = i << Uint64FromInt32(1)
		}
		uxi = uxi << uint64(-ex+Int32FromInt32(1))
	} else {
		uxi = uxi & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		uxi = uxi | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	if !(ey != 0) {
		for i = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) << int32(12); i>>int32(63) == uint64(0); {
			goto _2
		_2:
			ey--
			i = i << Uint64FromInt32(1)
		}
		p3 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) << uint64(-ey+Int32FromInt32(1))
	} else {
		p4 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p4)) = *(*Tuint64_t)(unsafe.Pointer(p4)) & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		p5 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p5)) = *(*Tuint64_t)(unsafe.Pointer(p5)) | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	/* x mod y */
	for ; ex > ey; ex-- {
		i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 8))
		if i>>int32(63) == uint64(0) {
			if i == uint64(0) {
				return Float64FromInt32(0) * x
			}
			uxi = i
		}
		uxi = uxi << Uint64FromInt32(1)
	}
	i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 8))
	if i>>int32(63) == uint64(0) {
		if i == uint64(0) {
			return Float64FromInt32(0) * x
		}
		uxi = i
	}
	for uxi>>int32(52) == uint64(0) {
		goto _6
	_6:
		uxi = uxi << Uint64FromInt32(1)
		ex--
	}
	/* scale result */
	if ex > int32(0) {
		uxi = uxi - Uint64FromUint64(1)<<Int32FromInt32(52)
		uxi = uxi | uint64(ex)<<Int32FromInt32(52)
	} else {
		uxi = uxi >> uint64(-ex+Int32FromInt32(1))
	}
	uxi = uxi | uint64(sx)<<Int32FromInt32(63)
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uxi
	return *(*float64)(unsafe.Pointer(bp))
}

func x_fmodf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ex int32
	var ey int32
	var i Tuint32_t
	var sx Tuint32_t
	var uxi Tuint32_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	ex = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	ey = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(23) & uint32(0xff))
	sx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x80000000)
	uxi = *(*Tuint32_t)(unsafe.Pointer(bp))
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4))<<int32(1) == uint32(0) || BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || ex == int32(0xff) {
		return x * y / (x * y)
	}
	if uxi<<int32(1) <= *(*Tuint32_t)(unsafe.Pointer(bp + 4))<<int32(1) {
		if uxi<<int32(1) == *(*Tuint32_t)(unsafe.Pointer(bp + 4))<<int32(1) {
			return Float32FromInt32(0) * x
		}
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		for i = uxi << int32(9); i>>int32(31) == uint32(0); {
			goto _1
		_1:
			ex--
			i = i << Uint32FromInt32(1)
		}
		uxi = uxi << uint32(-ex+Int32FromInt32(1))
	} else {
		uxi = uxi & (-Uint32FromUint32(1) >> Int32FromInt32(9))
		uxi = uxi | Uint32FromUint32(1)<<Int32FromInt32(23)
	}
	if !(ey != 0) {
		for i = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) << int32(9); i>>int32(31) == uint32(0); {
			goto _2
		_2:
			ey--
			i = i << Uint32FromInt32(1)
		}
		p3 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p3)) = *(*Tuint32_t)(unsafe.Pointer(p3)) << uint32(-ey+Int32FromInt32(1))
	} else {
		p4 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p4)) = *(*Tuint32_t)(unsafe.Pointer(p4)) & (-Uint32FromUint32(1) >> Int32FromInt32(9))
		p5 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p5)) = *(*Tuint32_t)(unsafe.Pointer(p5)) | Uint32FromUint32(1)<<Int32FromInt32(23)
	}
	/* x mod y */
	for ; ex > ey; ex-- {
		i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 4))
		if i>>int32(31) == uint32(0) {
			if i == uint32(0) {
				return Float32FromInt32(0) * x
			}
			uxi = i
		}
		uxi = uxi << Uint32FromInt32(1)
	}
	i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 4))
	if i>>int32(31) == uint32(0) {
		if i == uint32(0) {
			return Float32FromInt32(0) * x
		}
		uxi = i
	}
	for uxi>>int32(23) == uint32(0) {
		goto _6
	_6:
		uxi = uxi << Uint32FromInt32(1)
		ex--
	}
	/* scale result up */
	if ex > int32(0) {
		uxi = uxi - Uint32FromUint32(1)<<Int32FromInt32(23)
		uxi = uxi | uint32(ex)<<Int32FromInt32(23)
	} else {
		uxi = uxi >> uint32(-ex+Int32FromInt32(1))
	}
	uxi = uxi | sx
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uxi
	return *(*float32)(unsafe.Pointer(bp))
}

func x_frexp(tls *TLS, x float64, e uintptr) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ee int32
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint64_t
		Fd float64
	}
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	ee = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(ee != 0) {
		if x != 0 {
			x = x_frexp(tls, x*float64(1.8446744073709552e+19), e)
			p1 = e
			*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) - Int32FromInt32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = int32(0)
		}
		return x
	} else {
		if ee == int32(0x7ff) {
			return x
		}
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x3fe)
	p2 = bp
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) & Uint64FromUint64(0x800fffffffffffff)
	p3 = bp
	*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) | Uint64FromUint64(0x3fe0000000000000)
	return *(*float64)(unsafe.Pointer(bp))
}

func x_frexpf(tls *TLS, x float32, e uintptr) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ee int32
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	ee = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(ee != 0) {
		if x != 0 {
			x = x_frexpf(tls, float32(float64(x)*float64(1.8446744073709552e+19)), e)
			p1 = e
			*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) - Int32FromInt32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = int32(0)
		}
		return x
	} else {
		if ee == int32(0xff) {
			return x
		}
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x7e)
	p2 = bp
	*(*Tuint32_t)(unsafe.Pointer(p2)) = Tuint32_t(uint64(*(*Tuint32_t)(unsafe.Pointer(p2))) & Uint64FromUint64(0x807fffff))
	p3 = bp
	*(*Tuint32_t)(unsafe.Pointer(p3)) = Tuint32_t(uint64(*(*Tuint32_t)(unsafe.Pointer(p3))) | Uint64FromUint64(0x3f000000))
	return *(*float32)(unsafe.Pointer(bp))
}

func x_frexpl(tls *TLS, x float64, e uintptr) (r float64) {
	return x_frexp(tls, x, e)
}

func _sq(tls *TLS, hi uintptr, lo uintptr, x float64) {
	var xc Tdouble_t
	var xh Tdouble_t
	var xl Tdouble_t
	xc = x * (Float64FromFloat64(1.34217728e+08) + Float64FromInt32(1))
	xh = x - xc + xc
	xl = x - xh
	*(*Tdouble_t)(unsafe.Pointer(hi)) = x * x
	*(*Tdouble_t)(unsafe.Pointer(lo)) = xh*xh - *(*Tdouble_t)(unsafe.Pointer(hi)) + Float64FromInt32(2)*xh*xl + xl*xl
}

func x_hypot(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxValist 0 */
	defer tls.Free(48)
	var ex int32
	var ey int32
	var ut struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var z Tdouble_t
	var _ /* hx at bp+16 */ Tdouble_t
	var _ /* hy at bp+32 */ Tdouble_t
	var _ /* lx at bp+24 */ Tdouble_t
	var _ /* ly at bp+40 */ Tdouble_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	var p2 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	/* arrange |x| >= |y| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) >> Int32FromInt32(1))
	p2 = bp + 8
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) & (-Uint64FromUint64(1) >> Int32FromInt32(1))
	if *(*Tuint64_t)(unsafe.Pointer(bp)) < *(*Tuint64_t)(unsafe.Pointer(bp + 8)) {
		ut = *(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp))
		*(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp)) = *(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp + 8))
		*(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp + 8)) = ut
	}
	/* special cases */
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52))
	x = *(*float64)(unsafe.Pointer(bp))
	y = *(*float64)(unsafe.Pointer(bp + 8))
	/* note: hypot(inf,nan) == inf */
	if ey == int32(0x7ff) {
		return y
	}
	if ex == int32(0x7ff) || *(*Tuint64_t)(unsafe.Pointer(bp + 8)) == uint64(0) {
		return x
	}
	/* note: hypot(x,y) ~= x + y*y/x/2 with inexact for small y/x */
	/* 64 difference is enough for ld80 double_t */
	if ex-ey > int32(64) {
		return x + y
	}
	/* precise sqrt argument in nearest rounding mode without overflow */
	/* xh*xh must not overflow and xl*xl must not underflow in sq */
	z = Float64FromInt32(1)
	if ex > Int32FromInt32(0x3ff)+Int32FromInt32(510) {
		z = float64(5.260135901548374e+210)
		x = x * Float64FromFloat64(1.90109156629516e-211)
		y = y * Float64FromFloat64(1.90109156629516e-211)
	} else {
		if ey < Int32FromInt32(0x3ff)-Int32FromInt32(450) {
			z = float64(1.90109156629516e-211)
			x = x * Float64FromFloat64(5.260135901548374e+210)
			y = y * Float64FromFloat64(5.260135901548374e+210)
		}
	}
	_sq(tls, bp+16, bp+24, x)
	_sq(tls, bp+32, bp+40, y)
	return z * x_sqrt(tls, *(*Tdouble_t)(unsafe.Pointer(bp + 40))+*(*Tdouble_t)(unsafe.Pointer(bp + 24))+*(*Tdouble_t)(unsafe.Pointer(bp + 32))+*(*Tdouble_t)(unsafe.Pointer(bp + 16)))
}

func x_hypotf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ut struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var z Tfloat_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & (-Uint32FromUint32(1) >> Int32FromInt32(1))
	p2 = bp + 4
	*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) & (-Uint32FromUint32(1) >> Int32FromInt32(1))
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < *(*Tuint32_t)(unsafe.Pointer(bp + 4)) {
		ut = *(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp))
		*(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp)) = *(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp + 4))
		*(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp + 4)) = ut
	}
	x = *(*float32)(unsafe.Pointer(bp))
	y = *(*float32)(unsafe.Pointer(bp + 4))
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) == uint32(Int32FromInt32(0xff)<<Int32FromInt32(23)) {
		return y
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp)) >= uint32(Int32FromInt32(0xff)<<Int32FromInt32(23)) || *(*Tuint32_t)(unsafe.Pointer(bp + 4)) == uint32(0) || *(*Tuint32_t)(unsafe.Pointer(bp))-*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >= uint32(Int32FromInt32(25)<<Int32FromInt32(23)) {
		return x + y
	}
	z = Float32FromInt32(1)
	if *(*Tuint32_t)(unsafe.Pointer(bp)) >= uint32((Int32FromInt32(0x7f)+Int32FromInt32(60))<<Int32FromInt32(23)) {
		z = Float32FromFloat32(1.2379400392853803e+27)
		x = x * Float32FromFloat32(8.077935669463161e-28)
		y = y * Float32FromFloat32(8.077935669463161e-28)
	} else {
		if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) < uint32((Int32FromInt32(0x7f)-Int32FromInt32(60))<<Int32FromInt32(23)) {
			z = Float32FromFloat32(8.077935669463161e-28)
			x = x * Float32FromFloat32(1.2379400392853803e+27)
			y = y * Float32FromFloat32(1.2379400392853803e+27)
		}
	}
	return z * x_sqrtf(tls, float32(float64(x)*float64(x)+float64(y)*float64(y)))
}

func x_hypotl(tls *TLS, x float64, y float64) (r float64) {
	return x_hypot(tls, x, y)
}

const m_FP_ILOGB0 = 1

func x_ilogb(tls *TLS, x float64) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var i Tuint64_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v2 int32
	*(*float64)(unsafe.Pointer(bp)) = x
	i = *(*Tuint64_t)(unsafe.Pointer(bp))
	e = int32(i >> int32(52) & uint64(0x7ff))
	if !(e != 0) {
		i = i << Uint64FromInt32(12)
		if i == uint64(0) {
			{
				if uint64(4) == uint64(4) {
					_fp_force_evalf(tls, Float32FromInt32(0)/Float32FromFloat32(0))
				} else {
					if uint64(4) == uint64(8) {
						_fp_force_eval(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
					} else {
						_fp_force_evall(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
					}
				}
			}
			return -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		}
		/* subnormal x */
		for e = -int32(0x3ff); i>>int32(63) == uint64(0); {
			goto _1
		_1:
			e--
			i = i << Uint64FromInt32(1)
		}
		return e
	}
	if e == int32(0x7ff) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, Float32FromInt32(0)/Float32FromFloat32(0))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
				} else {
					_fp_force_evall(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
				}
			}
		}
		if i<<int32(12) != 0 {
			v2 = -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		} else {
			v2 = int32(m_INT_MAX)
		}
		return v2
	}
	return e - int32(0x3ff)
}

func x_ilogbf(tls *TLS, x float32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var i Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v2 int32
	*(*float32)(unsafe.Pointer(bp)) = x
	i = *(*Tuint32_t)(unsafe.Pointer(bp))
	e = int32(i >> int32(23) & uint32(0xff))
	if !(e != 0) {
		i = i << Uint32FromInt32(9)
		if i == uint32(0) {
			{
				if uint64(4) == uint64(4) {
					_fp_force_evalf(tls, Float32FromInt32(0)/Float32FromFloat32(0))
				} else {
					if uint64(4) == uint64(8) {
						_fp_force_eval(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
					} else {
						_fp_force_evall(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
					}
				}
			}
			return -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		}
		/* subnormal x */
		for e = -int32(0x7f); i>>int32(31) == uint32(0); {
			goto _1
		_1:
			e--
			i = i << Uint32FromInt32(1)
		}
		return e
	}
	if e == int32(0xff) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, Float32FromInt32(0)/Float32FromFloat32(0))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
				} else {
					_fp_force_evall(tls, float64(Float32FromInt32(0)/Float32FromFloat32(0)))
				}
			}
		}
		if i<<int32(9) != 0 {
			v2 = -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		} else {
			v2 = int32(m_INT_MAX)
		}
		return v2
	}
	return e - int32(0x7f)
}

func x_ilogbl(tls *TLS, x float64) (r int32) {
	return x_ilogb(tls, x)
}

var _invsqrtpi = float64(0.5641895835477563) /* 0x3FE20DD7, 0x50429B6D */
var _tpi = float64(0.6366197723675814)       /* 0x3FE45F30, 0x6DC9C883 */

// C documentation
//
//	/* common method when |x|>=2 */
func _common(tls *TLS, ix Tuint32_t, x float64, y0 int32) (r float64) {
	var c float64
	var cc float64
	var s float64
	var ss float64
	var z float64
	/*
	 * j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x-pi/4)-q0(x)*sin(x-pi/4))
	 * y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x-pi/4)+q0(x)*cos(x-pi/4))
	 *
	 * sin(x-pi/4) = (sin(x) - cos(x))/sqrt(2)
	 * cos(x-pi/4) = (sin(x) + cos(x))/sqrt(2)
	 * sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
	 */
	s = x_sin(tls, x)
	c = x_cos(tls, x)
	if y0 != 0 {
		c = -c
	}
	cc = s + c
	/* avoid overflow in 2*x, big ulp error when x>=0x1p1023 */
	if ix < uint32(0x7fe00000) {
		ss = s - c
		z = -x_cos(tls, Float64FromInt32(2)*x)
		if s*c < Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x48000000) {
			if y0 != 0 {
				ss = -ss
			}
			cc = _pzero(tls, x)*cc - _qzero(tls, x)*ss
		}
	}
	return _invsqrtpi * cc / x_sqrt(tls, x)
}

/* R0/S0 on [0, 2.00] */

var _R02 = float64(0.015624999999999995)               /* 0x3F8FFFFF, 0xFFFFFFFD */
var _R03 = -Float64FromFloat64(0.00018997929423885472) /* 0xBF28E6A5, 0xB61AC6E9 */
var _R04 = float64(1.8295404953270067e-06)             /* 0x3EBEB1D1, 0x0C503919 */
var _R05 = -Float64FromFloat64(4.618326885321032e-09)  /* 0xBE33D5E7, 0x73D63FCE */
var _S01 = float64(0.015619102946489001)               /* 0x3F8FFCE8, 0x82C8C2A4 */
var _S02 = float64(0.00011692678466333745)             /* 0x3F1EA6D2, 0xDD57DBF4 */
var _S03 = float64(5.135465502073181e-07)              /* 0x3EA13B54, 0xCE84D5A9 */
var _S04 = float64(1.1661400333379e-09)

func x_j0(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var r float64
	var s float64
	var z float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* j0(+-inf)=0, j0(nan)=nan */
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / (x * x)
	}
	x = x_fabs(tls, x)
	if ix >= uint32(0x40000000) {
		/* |x| >= 2 */
		/* large ulp error near zeros: 2.4, 5.52, 8.6537,.. */
		return _common(tls, ix, x, int32(0))
	}
	/* 1 - x*x/4 + x*x*R(x^2)/S(x^2) */
	if ix >= uint32(0x3f200000) {
		/* |x| >= 2**-13 */
		/* up to 4ulp error close to 2 */
		z = x * x
		r = z * (_R02 + z*(_R03+z*(_R04+z*_R05)))
		s = Float64FromInt32(1) + z*(_S01+z*(_S02+z*(_S03+z*_S04)))
		return (Float64FromInt32(1)+x/Float64FromInt32(2))*(Float64FromInt32(1)-x/Float64FromInt32(2)) + z*(r/s)
	}
	/* 1 - x*x/4 */
	/* prevent underflow */
	/* inexact should be raised when x!=0, this is not done correctly */
	if ix >= uint32(0x38000000) { /* |x| >= 2**-127 */
		x = float64(0.25) * x * x
	}
	return Float64FromInt32(1) - x
}

var _u00 = -Float64FromFloat64(0.07380429510868723)    /* 0xBFB2E4D6, 0x99CBD01F */
var _u01 = float64(0.17666645250918112)                /* 0x3FC69D01, 0x9DE9E3FC */
var _u02 = -Float64FromFloat64(0.01381856719455969)    /* 0xBF8C4CE8, 0xB16CFA97 */
var _u03 = float64(0.00034745343209368365)             /* 0x3F36C54D, 0x20B29B6B */
var _u04 = -Float64FromFloat64(3.8140705372436416e-06) /* 0xBECFFEA7, 0x73D25CAD */
var _u05 = float64(1.9559013703502292e-08)             /* 0x3E550057, 0x3B4EABD4 */
var _u06 = -Float64FromFloat64(3.982051941321034e-11)  /* 0xBDC5E43D, 0x693FB3C8 */
var _v01 = float64(0.01273048348341237)                /* 0x3F8A1270, 0x91C9C71A */
var _v02 = float64(7.600686273503533e-05)              /* 0x3F13ECBB, 0xF578C6C1 */
var _v03 = float64(2.591508518404578e-07)              /* 0x3E91642D, 0x7FF202FD */
var _v04 = float64(4.4111031133267547e-10)

func x_y0(tls *TLS, x float64) (r float64) {
	var __u Tuint64_t
	var ix Tuint32_t
	var lx Tuint32_t
	var u float64
	var v float64
	var z float64
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		ix = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	/* y0(nan)=nan, y0(<0)=nan, y0(0)=-inf, y0(inf)=0 */
	if ix<<int32(1)|lx == uint32(0) {
		return float64(-Int32FromInt32(1)) / Float64FromFloat64(0)
	}
	if ix>>int32(31) != 0 {
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) {
		/* x >= 2 */
		/* large ulp errors near zeros: 3.958, 7.086,.. */
		return _common(tls, ix, x, int32(1))
	}
	/* U(x^2)/V(x^2) + (2/pi)*j0(x)*log(x) */
	if ix >= uint32(0x3e400000) {
		/* x >= 2**-27 */
		/* large ulp error near the first zero, x ~= 0.89 */
		z = x * x
		u = _u00 + z*(_u01+z*(_u02+z*(_u03+z*(_u04+z*(_u05+z*_u06)))))
		v = float64(1) + z*(_v01+z*(_v02+z*(_v03+z*_v04)))
		return u/v + _tpi*(x_j0(tls, x)*x_log(tls, x))
	}
	return _u00 + _tpi*x_log(tls, x)
}

/* The asymptotic expansions of pzero is
 *      1 - 9/128 s^2 + 11025/98304 s^4 - ...,  where s = 1/x.
 * For x >= 2, We approximate pzero by
 *      pzero(x) = 1 + (R/S)
 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
 *        S = 1 + pS0*s^2 + ... + pS4*s^10
 * and
 *      | pzero(x)-1-R/S | <= 2  ** ( -60.26)
 */
var _pR8 = [6]float64{
	0: float64(0),
	1: -Float64FromFloat64(0.07031249999999004),
	2: -Float64FromFloat64(8.081670412753498),
	3: -Float64FromFloat64(257.06310567970485),
	4: -Float64FromFloat64(2485.216410094288),
	5: -Float64FromFloat64(5253.043804907295)}
var _pS8 = [5]float64{
	0: float64(116.53436461966818),
	1: float64(3833.7447536412183),
	2: float64(40597.857264847255),
	3: float64(116752.97256437592),
	4: float64(47627.728414673096)}

var _pR5 = [6]float64{
	0: -Float64FromFloat64(1.141254646918945e-11),
	1: -Float64FromFloat64(0.07031249408735993),
	2: -Float64FromFloat64(4.159610644705878),
	3: -Float64FromFloat64(67.67476522651673),
	4: -Float64FromFloat64(331.23129964917297),
	5: -Float64FromFloat64(346.4333883656049)}
var _pS52 = [5]float64{
	0: float64(60.753938269230034),
	1: float64(1051.2523059570458),
	2: float64(5978.970943338558),
	3: float64(9625.445143577745),
	4: float64(2406.058159229391)}

var _pR3 = [6]float64{
	0: -Float64FromFloat64(2.547046017719519e-09),
	1: -Float64FromFloat64(0.07031196163814817),
	2: -Float64FromFloat64(2.409032215495296),
	3: -Float64FromFloat64(21.96597747348831),
	4: -Float64FromFloat64(58.07917047017376),
	5: -Float64FromFloat64(31.44794705948885)}
var _pS32 = [5]float64{
	0: float64(35.85603380552097),
	1: float64(361.51398305030386),
	2: float64(1193.6078379211153),
	3: float64(1127.9967985690741),
	4: float64(173.58093081333575)}

var _pR2 = [6]float64{
	0: -Float64FromFloat64(8.875343330325264e-08),
	1: -Float64FromFloat64(0.07030309954836247),
	2: -Float64FromFloat64(1.4507384678095299),
	3: -Float64FromFloat64(7.635696138235278),
	4: -Float64FromFloat64(11.193166886035675),
	5: -Float64FromFloat64(3.2336457935133534)}
var _pS24 = [5]float64{
	0: float64(22.22029975320888),
	1: float64(136.2067942182152),
	2: float64(270.4702786580835),
	3: float64(153.87539420832033),
	4: float64(14.65761769482562)}

func _pzero(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tdouble_t
	var s Tdouble_t
	var z Tdouble_t
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_pR8))
		q = uintptr(unsafe.Pointer(&_pS8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_pR5))
			q = uintptr(unsafe.Pointer(&_pS52))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_pR3))
				q = uintptr(unsafe.Pointer(&_pS32))
			} else {
				p = uintptr(unsafe.Pointer(&_pR2))
				q = uintptr(unsafe.Pointer(&_pS24))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) + z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(p + UintptrFromInt32(5)*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(0)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(3)*8))+z**(*float64)(unsafe.Pointer(q + UintptrFromInt32(4)*8))))))
	return float64(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qzero is
 *      -1/8 s + 75/1024 s^3 - ..., where s = 1/x.
 * We approximate pzero by
 *      qzero(x) = s*(-1.25 + (R/S))
 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
 *        S = 1 + qS0*s^2 + ... + qS5*s^12
 * and
 *      | qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
 */
var _qR8 = [6]float64{
	0: float64(0),
	1: float64(0.0732421874999935),
	2: float64(11.76820646822527),
	3: float64(557.6733802564019),
	4: float64(8859.197207564686),
	5: float64(37014.62677768878)}
var _qS8 = [6]float64{
	0: float64(163.77602689568982),
	1: float64(8098.344946564498),
	2: float64(142538.29141912048),
	3: float64(803309.2571195144),
	4: float64(840501.5798190605),
	5: -Float64FromFloat64(343899.2935378666)}

var _qR5 = [6]float64{
	0: float64(1.8408596359451553e-11),
	1: float64(0.07324217666126848),
	2: float64(5.8356350896205695),
	3: float64(135.11157728644983),
	4: float64(1027.243765961641),
	5: float64(1989.9778586460538)}
var _qS5 = [6]float64{
	0: float64(82.77661022365378),
	1: float64(2077.81416421393),
	2: float64(18847.28877857181),
	3: float64(56751.11228949473),
	4: float64(35976.75384251145),
	5: -Float64FromFloat64(5354.342756019448)}

var _qR3 = [6]float64{
	0: float64(4.377410140897386e-09),
	1: float64(0.07324111800429114),
	2: float64(3.344231375161707),
	3: float64(42.621844074541265),
	4: float64(170.8080913405656),
	5: float64(166.73394869665117)}
var _qS32 = [6]float64{
	0: float64(48.75887297245872),
	1: float64(709.689221056606),
	2: float64(3704.1482262011136),
	3: float64(6460.425167525689),
	4: float64(2516.3336892036896),
	5: -Float64FromFloat64(149.2474518361564)}

var _qR2 = [6]float64{
	0: float64(1.5044444488698327e-07),
	1: float64(0.07322342659630793),
	2: float64(1.99819174093816),
	3: float64(14.495602934788574),
	4: float64(31.666231750478154),
	5: float64(16.252707571092927)}
var _qS22 = [6]float64{
	0: float64(30.36558483552192),
	1: float64(269.34811860804984),
	2: float64(844.7837575953201),
	3: float64(882.9358451124886),
	4: float64(212.66638851179883),
	5: -Float64FromFloat64(5.3109549388266695)}

func _qzero(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tdouble_t
	var s Tdouble_t
	var z Tdouble_t
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_qR8))
		q = uintptr(unsafe.Pointer(&_qS8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_qR5))
			q = uintptr(unsafe.Pointer(&_qS5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_qR3))
				q = uintptr(unsafe.Pointer(&_qS32))
			} else {
				p = uintptr(unsafe.Pointer(&_qR2))
				q = uintptr(unsafe.Pointer(&_qS22))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) + z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(p + UintptrFromInt32(5)*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(0)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(q + UintptrFromInt32(5)*8)))))))
	return (-Float64FromFloat64(0.125) + r/s) / x
}

var _invsqrtpi1 = float32(0.56418961287) /* 0x3f106ebb */
var _tpi1 = float32(0.63661974669)

func _common1(tls *TLS, ix Tuint32_t, x float32, y0 int32) (r float32) {
	var c float32
	var cc float32
	var s float32
	var ss float32
	var z float32
	/*
	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
	 */
	s = x_sinf(tls, x)
	c = x_cosf(tls, x)
	if y0 != 0 {
		c = -c
	}
	cc = s + c
	if ix < uint32(0x7f000000) {
		ss = s - c
		z = -x_cosf(tls, Float32FromInt32(2)*x)
		if s*c < Float32FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x58800000) {
			if y0 != 0 {
				ss = -ss
			}
			cc = _pzerof(tls, x)*cc - _qzerof(tls, x)*ss
		}
	}
	return _invsqrtpi1 * cc / x_sqrtf(tls, x)
}

/* R0/S0 on [0, 2.00] */

var _R021 = float32(0.015625)                              /* 0x3c800000 */
var _R031 = float32(-Float64FromFloat64(0.00018997929874)) /* 0xb947352e */
var _R041 = float32(1.8295404516e-06)                      /* 0x35f58e88 */
var _R051 = float32(-Float64FromFloat64(4.6183270541e-09)) /* 0xb19eaf3c */
var _S011 = float32(0.015619102865)                        /* 0x3c7fe744 */
var _S021 = float32(0.00011692678527)                      /* 0x38f53697 */
var _S031 = float32(5.1354652442e-07)                      /* 0x3509daa6 */
var _S041 = float32(1.1661400734e-09)

func x_j0f(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var r float32
	var s float32
	var z float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / (x * x)
	}
	x = x_fabsf(tls, x)
	if ix >= uint32(0x40000000) {
		/* |x| >= 2 */
		/* large ulp error near zeros */
		return _common1(tls, ix, x, int32(0))
	}
	if ix >= uint32(0x3a000000) {
		/* |x| >= 2**-11 */
		/* up to 4ulp error near 2 */
		z = x * x
		r = z * (_R021 + z*(_R031+z*(_R041+z*_R051)))
		s = Float32FromInt32(1) + z*(_S011+z*(_S021+z*(_S031+z*_S041)))
		return (Float32FromInt32(1)+x/Float32FromInt32(2))*(Float32FromInt32(1)-x/Float32FromInt32(2)) + z*(r/s)
	}
	if ix >= uint32(0x21800000) { /* |x| >= 2**-60 */
		x = Float32FromFloat32(0.25) * x * x
	}
	return Float32FromInt32(1) - x
}

var _u001 = float32(-Float64FromFloat64(0.073804296553))   /* 0xbd9726b5 */
var _u011 = float32(0.17666645348)                         /* 0x3e34e80d */
var _u021 = float32(-Float64FromFloat64(0.013818567619))   /* 0xbc626746 */
var _u031 = float32(0.00034745343146)                      /* 0x39b62a69 */
var _u041 = float32(-Float64FromFloat64(3.8140706238e-06)) /* 0xb67ff53c */
var _u051 = float32(1.9559013964e-08)                      /* 0x32a802ba */
var _u061 = float32(-Float64FromFloat64(3.982051841e-11))  /* 0xae2f21eb */
var _v011 = float32(0.012730483897)                        /* 0x3c509385 */
var _v021 = float32(7.6006865129e-05)                      /* 0x389f65e0 */
var _v031 = float32(2.5915085189e-07)                      /* 0x348b216c */
var _v041 = float32(4.4111031494e-10)

func x_y0f(tls *TLS, x float32) (r float32) {
	var ix Tuint32_t
	var u float32
	var v float32
	var z float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	if ix&uint32(0x7fffffff) == uint32(0) {
		return float32(-Int32FromInt32(1)) / Float32FromFloat32(0)
	}
	if ix>>int32(31) != 0 {
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) {
		/* |x| >= 2.0 */
		/* large ulp error near zeros */
		return _common1(tls, ix, x, int32(1))
	}
	if ix >= uint32(0x39000000) {
		/* x >= 2**-13 */
		/* large ulp error at x ~= 0.89 */
		z = x * x
		u = _u001 + z*(_u011+z*(_u021+z*(_u031+z*(_u041+z*(_u051+z*_u061)))))
		v = Float32FromInt32(1) + z*(_v011+z*(_v021+z*(_v031+z*_v041)))
		return u/v + _tpi1*(x_j0f(tls, x)*x_logf(tls, x))
	}
	return _u001 + _tpi1*x_logf(tls, x)
}

/* The asymptotic expansions of pzero is
 *      1 - 9/128 s^2 + 11025/98304 s^4 - ...,  where s = 1/x.
 * For x >= 2, We approximate pzero by
 *      pzero(x) = 1 + (R/S)
 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
 *        S = 1 + pS0*s^2 + ... + pS4*s^10
 * and
 *      | pzero(x)-1-R/S | <= 2  ** ( -60.26)
 */
var _pR81 = [6]float32{
	0: float32(0),
	1: float32(-Float64FromFloat64(0.0703125)),
	2: float32(-Float64FromFloat64(8.0816707611)),
	3: float32(-Float64FromFloat64(257.06311035)),
	4: float32(-Float64FromFloat64(2485.2163086)),
	5: float32(-Float64FromFloat64(5253.0439453))}
var _pS81 = [5]float32{
	0: float32(116.53436279),
	1: float32(3833.744873),
	2: float32(40597.855469),
	3: float32(116752.96875),
	4: float32(47627.726562)}
var _pR51 = [6]float32{
	0: float32(-Float64FromFloat64(1.1412546255e-11)),
	1: float32(-Float64FromFloat64(0.070312492549)),
	2: float32(-Float64FromFloat64(4.1596107483)),
	3: float32(-Float64FromFloat64(67.674766541)),
	4: float32(-Float64FromFloat64(331.23129272)),
	5: float32(-Float64FromFloat64(346.43338013))}
var _pS53 = [5]float32{
	0: float32(60.753936768),
	1: float32(1051.2523193),
	2: float32(5978.9707031),
	3: float32(9625.4453125),
	4: float32(2406.0581055)}

var _pR31 = [6]float32{
	0: float32(-Float64FromFloat64(2.5470459075e-09)),
	1: float32(-Float64FromFloat64(0.070311963558)),
	2: float32(-Float64FromFloat64(2.4090321064)),
	3: float32(-Float64FromFloat64(21.965976715)),
	4: float32(-Float64FromFloat64(58.079170227)),
	5: float32(-Float64FromFloat64(31.447946548))}
var _pS33 = [5]float32{
	0: float32(35.856033325),
	1: float32(361.51397705),
	2: float32(1193.6077881),
	3: float32(1127.9968262),
	4: float32(173.58093262)}

var _pR21 = [6]float32{
	0: float32(-Float64FromFloat64(8.8753431271e-08)),
	1: float32(-Float64FromFloat64(0.070303097367)),
	2: float32(-Float64FromFloat64(1.45073843)),
	3: float32(-Float64FromFloat64(7.6356959343)),
	4: float32(-Float64FromFloat64(11.193166733)),
	5: float32(-Float64FromFloat64(3.2336456776))}
var _pS25 = [5]float32{
	0: float32(22.220300674),
	1: float32(136.20678711),
	2: float32(270.47027588),
	3: float32(153.87539673),
	4: float32(14.657617569)}

func _pzerof(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tfloat_t
	var s Tfloat_t
	var z Tfloat_t
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_pR81))
		q = uintptr(unsafe.Pointer(&_pS81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_pR51))
			q = uintptr(unsafe.Pointer(&_pS53))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_pR31))
				q = uintptr(unsafe.Pointer(&_pS33))
			} else {
				p = uintptr(unsafe.Pointer(&_pR21))
				q = uintptr(unsafe.Pointer(&_pS25))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p + UintptrFromInt32(0)*4)) + z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(p + UintptrFromInt32(5)*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(0)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(3)*4))+z**(*float32)(unsafe.Pointer(q + UintptrFromInt32(4)*4))))))
	return Float32FromFloat32(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qzero is
 *      -1/8 s + 75/1024 s^3 - ..., where s = 1/x.
 * We approximate pzero by
 *      qzero(x) = s*(-1.25 + (R/S))
 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
 *        S = 1 + qS0*s^2 + ... + qS5*s^12
 * and
 *      | qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
 */
var _qR81 = [6]float32{
	0: float32(0),
	1: float32(0.0732421875),
	2: float32(11.768206596),
	3: float32(557.67340088),
	4: float32(8859.1972656),
	5: float32(37014.625)}
var _qS81 = [6]float32{
	0: float32(163.77603149),
	1: float32(8098.3447266),
	2: float32(142538.29688),
	3: float32(803309.25),
	4: float32(840501.5625),
	5: float32(-Float64FromFloat64(343899.28125))}

var _qR51 = [6]float32{
	0: float32(1.8408595828e-11),
	1: float32(0.073242180049),
	2: float32(5.8356351852),
	3: float32(135.11157227),
	4: float32(1027.2437744),
	5: float32(1989.9779053)}
var _qS51 = [6]float32{
	0: float32(82.776611328),
	1: float32(2077.814209),
	2: float32(18847.289062),
	3: float32(56751.113281),
	4: float32(35976.753906),
	5: float32(-Float64FromFloat64(5354.3427734))}

var _qR31 = [6]float32{
	0: float32(4.37740999e-09),
	1: float32(0.073241114616),
	2: float32(3.3442313671),
	3: float32(42.621845245),
	4: float32(170.80809021),
	5: float32(166.73394775)}
var _qS33 = [6]float32{
	0: float32(48.758872986),
	1: float32(709.68920898),
	2: float32(3704.1481934),
	3: float32(6460.425293),
	4: float32(2516.3337402),
	5: float32(-Float64FromFloat64(149.24745178))}

var _qR21 = [6]float32{
	0: float32(1.5044444979e-07),
	1: float32(0.073223426938),
	2: float32(1.9981917143),
	3: float32(14.495602608),
	4: float32(31.666231155),
	5: float32(16.252708435)}
var _qS23 = [6]float32{
	0: float32(30.365585327),
	1: float32(269.34811401),
	2: float32(844.78375244),
	3: float32(882.93585205),
	4: float32(212.66638184),
	5: float32(-Float64FromFloat64(5.3109550476))}

func _qzerof(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tfloat_t
	var s Tfloat_t
	var z Tfloat_t
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_qR81))
		q = uintptr(unsafe.Pointer(&_qS81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_qR51))
			q = uintptr(unsafe.Pointer(&_qS51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_qR31))
				q = uintptr(unsafe.Pointer(&_qS33))
			} else {
				p = uintptr(unsafe.Pointer(&_qR21))
				q = uintptr(unsafe.Pointer(&_qS23))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p + UintptrFromInt32(0)*4)) + z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(p + UintptrFromInt32(5)*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(0)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(q + UintptrFromInt32(5)*4)))))))
	return (-Float32FromFloat32(0.125) + r/s) / x
}

var _invsqrtpi2 = float64(0.5641895835477563) /* 0x3FE20DD7, 0x50429B6D */
var _tpi2 = float64(0.6366197723675814)

func _common2(tls *TLS, ix Tuint32_t, x float64, y1 int32, sign int32) (r float64) {
	var c float64
	var cc float64
	var s float64
	var ss float64
	var z float64
	/*
	 * j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x-3pi/4)-q1(x)*sin(x-3pi/4))
	 * y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x-3pi/4)+q1(x)*cos(x-3pi/4))
	 *
	 * sin(x-3pi/4) = -(sin(x) + cos(x))/sqrt(2)
	 * cos(x-3pi/4) = (sin(x) - cos(x))/sqrt(2)
	 * sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
	 */
	s = x_sin(tls, x)
	if y1 != 0 {
		s = -s
	}
	c = x_cos(tls, x)
	cc = s - c
	if ix < uint32(0x7fe00000) {
		/* avoid overflow in 2*x */
		ss = -s - c
		z = x_cos(tls, Float64FromInt32(2)*x)
		if s*c > Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x48000000) {
			if y1 != 0 {
				ss = -ss
			}
			cc = _pone(tls, x)*cc - _qone(tls, x)*ss
		}
	}
	if sign != 0 {
		cc = -cc
	}
	return _invsqrtpi2 * cc / x_sqrt(tls, x)
}

/* R0/S0 on [0,2] */

var _r00 = -Float64FromFloat64(0.0625)                /* 0xBFB00000, 0x00000000 */
var _r01 = float64(0.001407056669551897)              /* 0x3F570D9F, 0x98472C61 */
var _r02 = -Float64FromFloat64(1.599556310840356e-05) /* 0xBEF0C5C6, 0xBA169668 */
var _r03 = float64(4.9672799960958445e-08)            /* 0x3E6AAAFA, 0x46CA0BD9 */
var _s01 = float64(0.019153759953836346)              /* 0x3F939D0B, 0x12637E53 */
var _s02 = float64(0.00018594678558863092)            /* 0x3F285F56, 0xB9CDF664 */
var _s03 = float64(1.1771846404262368e-06)            /* 0x3EB3BFF8, 0x333F8498 */
var _s04 = float64(5.0463625707621704e-09)            /* 0x3E35AC88, 0xC97DFF2C */
var _s05 = float64(1.2354227442613791e-11)

func x_j1(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var r float64
	var s float64
	var sign int32
	var z float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / (x * x)
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		return _common2(tls, ix, x_fabs(tls, x), int32(0), sign)
	}
	if ix >= uint32(0x38000000) { /* |x| >= 2**-127 */
		z = x * x
		r = z * (_r00 + z*(_r01+z*(_r02+z*_r03)))
		s = Float64FromInt32(1) + z*(_s01+z*(_s02+z*(_s03+z*(_s04+z*_s05))))
		z = r / s
	} else {
		/* avoid underflow, raise inexact if x!=0 */
		z = x
	}
	return (float64(0.5) + z) * x
}

var _U0 = [5]float64{
	0: -Float64FromFloat64(0.19605709064623894),
	1: float64(0.05044387166398113),
	2: -Float64FromFloat64(0.0019125689587576355),
	3: float64(2.352526005616105e-05),
	4: -Float64FromFloat64(9.190991580398789e-08)}
var _V0 = [5]float64{
	0: float64(0.01991673182366499),
	1: float64(0.00020255258102513517),
	2: float64(1.3560880109751623e-06),
	3: float64(6.227414523646215e-09),
	4: float64(1.6655924620799208e-11)}

func x_y1(tls *TLS, x float64) (r float64) {
	var __u Tuint64_t
	var ix Tuint32_t
	var lx Tuint32_t
	var u float64
	var v float64
	var z float64
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		ix = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	/* y1(nan)=nan, y1(<0)=nan, y1(0)=-inf, y1(inf)=0 */
	if ix<<int32(1)|lx == uint32(0) {
		return float64(-Int32FromInt32(1)) / Float64FromFloat64(0)
	}
	if ix>>int32(31) != 0 {
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* x >= 2 */
		return _common2(tls, ix, x, int32(1), int32(0))
	}
	if ix < uint32(0x3c900000) { /* x < 2**-54 */
		return -_tpi2 / x
	}
	z = x * x
	u = _U0[int32(0)] + z*(_U0[int32(1)]+z*(_U0[int32(2)]+z*(_U0[int32(3)]+z*_U0[int32(4)])))
	v = Float64FromInt32(1) + z*(_V0[int32(0)]+z*(_V0[int32(1)]+z*(_V0[int32(2)]+z*(_V0[int32(3)]+z*_V0[int32(4)]))))
	return x*(u/v) + _tpi2*(x_j1(tls, x)*x_log(tls, x)-Float64FromInt32(1)/x)
}

/* For x >= 8, the asymptotic expansions of pone is
 *      1 + 15/128 s^2 - 4725/2^15 s^4 - ...,   where s = 1/x.
 * We approximate pone by
 *      pone(x) = 1 + (R/S)
 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
 *        S = 1 + ps0*s^2 + ... + ps4*s^10
 * and
 *      | pone(x)-1-R/S | <= 2  ** ( -60.06)
 */

var _pr8 = [6]float64{
	0: float64(0),
	1: float64(0.11718749999998865),
	2: float64(13.239480659307358),
	3: float64(412.05185430737856),
	4: float64(3874.7453891396053),
	5: float64(7914.479540318917)}
var _ps8 = [5]float64{
	0: float64(114.20737037567841),
	1: float64(3650.9308342085346),
	2: float64(36956.206026903346),
	3: float64(97602.79359349508),
	4: float64(30804.27206278888)}

var _pr5 = [6]float64{
	0: float64(1.3199051955624352e-11),
	1: float64(0.1171874931906141),
	2: float64(6.802751278684329),
	3: float64(108.30818299018911),
	4: float64(517.6361395331998),
	5: float64(528.7152013633375)}
var _ps5 = [5]float64{
	0: float64(59.28059872211313),
	1: float64(991.4014187336144),
	2: float64(5353.26695291488),
	3: float64(7844.690317495512),
	4: float64(1504.0468881036106)}

var _pr3 = [6]float64{
	0: float64(3.025039161373736e-09),
	1: float64(0.11718686556725359),
	2: float64(3.9329775003331564),
	3: float64(35.11940355916369),
	4: float64(91.05501107507813),
	5: float64(48.55906851973649)}
var _ps3 = [5]float64{
	0: float64(34.79130950012515),
	1: float64(336.76245874782575),
	2: float64(1046.8713997577513),
	3: float64(890.8113463982564),
	4: float64(103.78793243963928)}

var _pr2 = [6]float64{
	0: float64(1.0771083010687374e-07),
	1: float64(0.11717621946268335),
	2: float64(2.368514966676088),
	3: float64(12.242610914826123),
	4: float64(17.693971127168773),
	5: float64(5.073523125888185)}
var _ps2 = [5]float64{
	0: float64(21.43648593638214),
	1: float64(125.29022716840275),
	2: float64(232.2764690571628),
	3: float64(117.6793732871471),
	4: float64(8.364638933716183)}

func _pone(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tdouble_t
	var s Tdouble_t
	var z Tdouble_t
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_pr8))
		q = uintptr(unsafe.Pointer(&_ps8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_pr5))
			q = uintptr(unsafe.Pointer(&_ps5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_pr3))
				q = uintptr(unsafe.Pointer(&_ps3))
			} else {
				p = uintptr(unsafe.Pointer(&_pr2))
				q = uintptr(unsafe.Pointer(&_ps2))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) + z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(p + UintptrFromInt32(5)*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(0)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(3)*8))+z**(*float64)(unsafe.Pointer(q + UintptrFromInt32(4)*8))))))
	return float64(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qone is
 *      3/8 s - 105/1024 s^3 - ..., where s = 1/x.
 * We approximate pone by
 *      qone(x) = s*(0.375 + (R/S))
 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
 *        S = 1 + qs1*s^2 + ... + qs6*s^12
 * and
 *      | qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
 */

var _qr8 = [6]float64{
	0: float64(0),
	1: -Float64FromFloat64(0.10253906249999271),
	2: -Float64FromFloat64(16.271753454459),
	3: -Float64FromFloat64(759.6017225139501),
	4: -Float64FromFloat64(11849.806670242959),
	5: -Float64FromFloat64(48438.512428575035)}
var _qs8 = [6]float64{
	0: float64(161.3953697007229),
	1: float64(7825.385999233485),
	2: float64(133875.33628724958),
	3: float64(719657.7236832409),
	4: float64(666601.2326177764),
	5: -Float64FromFloat64(294490.26430383464)}

var _qr5 = [6]float64{
	0: -Float64FromFloat64(2.089799311417641e-11),
	1: -Float64FromFloat64(0.10253905024137543),
	2: -Float64FromFloat64(8.05644828123936),
	3: -Float64FromFloat64(183.66960747488838),
	4: -Float64FromFloat64(1373.1937606550816),
	5: -Float64FromFloat64(2612.4444045321566)}
var _qs5 = [6]float64{
	0: float64(81.27655013843358),
	1: float64(1991.7987346048596),
	2: float64(17468.48519249089),
	3: float64(49851.42709103523),
	4: float64(27948.075163891812),
	5: -Float64FromFloat64(4719.183547951285)}

var _qr3 = [6]float64{
	0: -Float64FromFloat64(5.078312264617666e-09),
	1: -Float64FromFloat64(0.10253782982083709),
	2: -Float64FromFloat64(4.610115811394734),
	3: -Float64FromFloat64(57.847221656278364),
	4: -Float64FromFloat64(228.2445407376317),
	5: -Float64FromFloat64(219.21012847890933)}
var _qs3 = [6]float64{
	0: float64(47.66515503237295),
	1: float64(673.8651126766997),
	2: float64(3380.1528667952634),
	3: float64(5547.729097207228),
	4: float64(1903.119193388108),
	5: -Float64FromFloat64(135.20119144430734)}

var _qr2 = [6]float64{
	0: -Float64FromFloat64(1.7838172751095887e-07),
	1: -Float64FromFloat64(0.10251704260798555),
	2: -Float64FromFloat64(2.7522056827818746),
	3: -Float64FromFloat64(19.663616264370372),
	4: -Float64FromFloat64(42.32531333728305),
	5: -Float64FromFloat64(21.371921170370406)}
var _qs2 = [6]float64{
	0: float64(29.533362906052385),
	1: float64(252.98154998219053),
	2: float64(757.5028348686454),
	3: float64(739.3932053204672),
	4: float64(155.94900333666612),
	5: -Float64FromFloat64(4.959498988226282)}

func _qone(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tdouble_t
	var s Tdouble_t
	var z Tdouble_t
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_qr8))
		q = uintptr(unsafe.Pointer(&_qs8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_qr5))
			q = uintptr(unsafe.Pointer(&_qs5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_qr3))
				q = uintptr(unsafe.Pointer(&_qs3))
			} else {
				p = uintptr(unsafe.Pointer(&_qr2))
				q = uintptr(unsafe.Pointer(&_qs2))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) + z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(p + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(p + UintptrFromInt32(5)*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(0)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(1)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(2)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(3)*8))+z*(*(*float64)(unsafe.Pointer(q + UintptrFromInt32(4)*8))+z**(*float64)(unsafe.Pointer(q + UintptrFromInt32(5)*8)))))))
	return (float64(0.375) + r/s) / x
}

var _invsqrtpi3 = float32(0.56418961287) /* 0x3f106ebb */
var _tpi3 = float32(0.63661974669)

func _common3(tls *TLS, ix Tuint32_t, x float32, y1 int32, sign int32) (r float32) {
	var c float64
	var cc float64
	var s float64
	var ss float64
	var z float64
	s = float64(x_sinf(tls, x))
	if y1 != 0 {
		s = -s
	}
	c = float64(x_cosf(tls, x))
	cc = s - c
	if ix < uint32(0x7f000000) {
		ss = -s - c
		z = float64(x_cosf(tls, Float32FromInt32(2)*x))
		if s*c > Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x58800000) {
			if y1 != 0 {
				ss = -ss
			}
			cc = float64(_ponef(tls, x))*cc - float64(_qonef(tls, x))*ss
		}
	}
	if sign != 0 {
		cc = -cc
	}
	return float32(float64(_invsqrtpi3) * cc / float64(x_sqrtf(tls, x)))
}

/* R0/S0 on [0,2] */

var _r001 = float32(-Float64FromFloat64(0.0625))           /* 0xbd800000 */
var _r011 = float32(0.0014070566976)                       /* 0x3ab86cfd */
var _r021 = float32(-Float64FromFloat64(1.5995563444e-05)) /* 0xb7862e36 */
var _r031 = float32(4.9672799207e-08)                      /* 0x335557d2 */
var _s011 = float32(0.019153760746)                        /* 0x3c9ce859 */
var _s021 = float32(0.00018594678841)                      /* 0x3942fab6 */
var _s031 = float32(1.1771846857e-06)                      /* 0x359dffc2 */
var _s041 = float32(5.046362439e-09)                       /* 0x31ad6446 */
var _s051 = float32(1.2354227016e-11)

func x_j1f(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var r float32
	var s float32
	var sign int32
	var z float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / (x * x)
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		return _common3(tls, ix, x_fabsf(tls, x), int32(0), sign)
	}
	if ix >= uint32(0x39000000) { /* |x| >= 2**-13 */
		z = x * x
		r = z * (_r001 + z*(_r011+z*(_r021+z*_r031)))
		s = Float32FromInt32(1) + z*(_s011+z*(_s021+z*(_s031+z*(_s041+z*_s051))))
		z = Float32FromFloat32(0.5) + r/s
	} else {
		z = Float32FromFloat32(0.5)
	}
	return z * x
}

var _U01 = [5]float32{
	0: float32(-Float64FromFloat64(0.19605709612)),
	1: float32(0.050443872809),
	2: float32(-Float64FromFloat64(0.0019125689287)),
	3: float32(2.3525259166e-05),
	4: float32(-Float64FromFloat64(9.1909917899e-08))}
var _V01 = [5]float32{
	0: float32(0.019916731864),
	1: float32(0.0002025525755),
	2: float32(1.3560879779e-06),
	3: float32(6.227414584e-09),
	4: float32(1.6655924903e-11)}

func x_y1f(tls *TLS, x float32) (r float32) {
	var ix Tuint32_t
	var u float32
	var v float32
	var z float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	if ix&uint32(0x7fffffff) == uint32(0) {
		return float32(-Int32FromInt32(1)) / Float32FromFloat32(0)
	}
	if ix>>int32(31) != 0 {
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2.0 */
		return _common3(tls, ix, x, int32(1), int32(0))
	}
	if ix < uint32(0x33000000) { /* x < 2**-25 */
		return -_tpi3 / x
	}
	z = x * x
	u = _U01[int32(0)] + z*(_U01[int32(1)]+z*(_U01[int32(2)]+z*(_U01[int32(3)]+z*_U01[int32(4)])))
	v = Float32FromFloat32(1) + z*(_V01[int32(0)]+z*(_V01[int32(1)]+z*(_V01[int32(2)]+z*(_V01[int32(3)]+z*_V01[int32(4)]))))
	return x*(u/v) + _tpi3*(x_j1f(tls, x)*x_logf(tls, x)-Float32FromFloat32(1)/x)
}

/* For x >= 8, the asymptotic expansions of pone is
 *      1 + 15/128 s^2 - 4725/2^15 s^4 - ...,   where s = 1/x.
 * We approximate pone by
 *      pone(x) = 1 + (R/S)
 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
 *        S = 1 + ps0*s^2 + ... + ps4*s^10
 * and
 *      | pone(x)-1-R/S | <= 2  ** ( -60.06)
 */

var _pr81 = [6]float32{
	0: float32(0),
	1: float32(0.1171875),
	2: float32(13.239480972),
	3: float32(412.05184937),
	4: float32(3874.7453613),
	5: float32(7914.4794922)}
var _ps81 = [5]float32{
	0: float32(114.20736694),
	1: float32(3650.9309082),
	2: float32(36956.207031),
	3: float32(97602.796875),
	4: float32(30804.271484)}

var _pr51 = [6]float32{
	0: float32(1.3199052094e-11),
	1: float32(0.11718749255),
	2: float32(6.8027510643),
	3: float32(108.30818176),
	4: float32(517.63616943),
	5: float32(528.71520996)}
var _ps51 = [5]float32{
	0: float32(59.280597687),
	1: float32(991.40142822),
	2: float32(5353.2670898),
	3: float32(7844.6904297),
	4: float32(1504.046875)}

var _pr31 = [6]float32{
	0: float32(3.0250391081e-09),
	1: float32(0.1171868667),
	2: float32(3.932977438),
	3: float32(35.119403839),
	4: float32(91.055007935),
	5: float32(48.559066772)}
var _ps31 = [5]float32{
	0: float32(34.791309357),
	1: float32(336.76245117),
	2: float32(1046.87146),
	3: float32(890.81134033),
	4: float32(103.78793335)}

var _pr21 = [6]float32{
	0: float32(1.0771083225e-07),
	1: float32(0.11717621982),
	2: float32(2.3685150146),
	3: float32(12.242610931),
	4: float32(17.693971634),
	5: float32(5.0735230446)}
var _ps21 = [5]float32{
	0: float32(21.436485291),
	1: float32(125.2902298),
	2: float32(232.276474),
	3: float32(117.67937469),
	4: float32(8.3646392822)}

func _ponef(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tfloat_t
	var s Tfloat_t
	var z Tfloat_t
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_pr81))
		q = uintptr(unsafe.Pointer(&_ps81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_pr51))
			q = uintptr(unsafe.Pointer(&_ps51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_pr31))
				q = uintptr(unsafe.Pointer(&_ps31))
			} else {
				p = uintptr(unsafe.Pointer(&_pr21))
				q = uintptr(unsafe.Pointer(&_ps21))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p + UintptrFromInt32(0)*4)) + z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(p + UintptrFromInt32(5)*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(0)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(3)*4))+z**(*float32)(unsafe.Pointer(q + UintptrFromInt32(4)*4))))))
	return Float32FromFloat32(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qone is
 *      3/8 s - 105/1024 s^3 - ..., where s = 1/x.
 * We approximate pone by
 *      qone(x) = s*(0.375 + (R/S))
 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
 *        S = 1 + qs1*s^2 + ... + qs6*s^12
 * and
 *      | qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
 */

var _qr81 = [6]float32{
	0: float32(0),
	1: float32(-Float64FromFloat64(0.1025390625)),
	2: float32(-Float64FromFloat64(16.271753311)),
	3: float32(-Float64FromFloat64(759.60174561)),
	4: float32(-Float64FromFloat64(11849.806641)),
	5: float32(-Float64FromFloat64(48438.511719))}
var _qs81 = [6]float32{
	0: float32(161.39537048),
	1: float32(7825.3862305),
	2: float32(133875.34375),
	3: float32(719657.75),
	4: float32(666601.25),
	5: float32(-Float64FromFloat64(294490.25))}

var _qr51 = [6]float32{
	0: float32(-Float64FromFloat64(2.0897993405e-11)),
	1: float32(-Float64FromFloat64(0.1025390476)),
	2: float32(-Float64FromFloat64(8.0564479828)),
	3: float32(-Float64FromFloat64(183.66960144)),
	4: float32(-Float64FromFloat64(1373.1937256)),
	5: float32(-Float64FromFloat64(2612.4443359))}
var _qs51 = [6]float32{
	0: float32(81.276550293),
	1: float32(1991.7987061),
	2: float32(17468.484375),
	3: float32(49851.425781),
	4: float32(27948.074219),
	5: float32(-Float64FromFloat64(4719.1835938))}

var _qr31 = [6]float32{
	0: float32(-Float64FromFloat64(5.0783124372e-09)),
	1: float32(-Float64FromFloat64(0.10253783315)),
	2: float32(-Float64FromFloat64(4.6101160049)),
	3: float32(-Float64FromFloat64(57.847221375)),
	4: float32(-Float64FromFloat64(228.24453735)),
	5: float32(-Float64FromFloat64(219.21012878))}
var _qs31 = [6]float32{
	0: float32(47.665153503),
	1: float32(673.8651123),
	2: float32(3380.152832),
	3: float32(5547.7290039),
	4: float32(1903.1191406),
	5: float32(-Float64FromFloat64(135.20118713))}

var _qr21 = [6]float32{
	0: float32(-Float64FromFloat64(1.7838172539e-07)),
	1: float32(-Float64FromFloat64(0.10251704603)),
	2: float32(-Float64FromFloat64(2.7522056103)),
	3: float32(-Float64FromFloat64(19.66361618)),
	4: float32(-Float64FromFloat64(42.325313568)),
	5: float32(-Float64FromFloat64(21.371921539))}
var _qs21 = [6]float32{
	0: float32(29.533363342),
	1: float32(252.98155212),
	2: float32(757.50280762),
	3: float32(739.39318848),
	4: float32(155.94900513),
	5: float32(-Float64FromFloat64(4.9594988823))}

func _qonef(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p uintptr
	var q uintptr
	var r Tfloat_t
	var s Tfloat_t
	var z Tfloat_t
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_qr81))
		q = uintptr(unsafe.Pointer(&_qs81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_qr51))
			q = uintptr(unsafe.Pointer(&_qs51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_qr31))
				q = uintptr(unsafe.Pointer(&_qs31))
			} else {
				p = uintptr(unsafe.Pointer(&_qr21))
				q = uintptr(unsafe.Pointer(&_qs21))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p + UintptrFromInt32(0)*4)) + z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(p + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(p + UintptrFromInt32(5)*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(0)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(1)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(2)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(3)*4))+z*(*(*float32)(unsafe.Pointer(q + UintptrFromInt32(4)*4))+z**(*float32)(unsafe.Pointer(q + UintptrFromInt32(5)*4)))))))
	return (Float32FromFloat32(0.375) + r/s) / x
}

var _invsqrtpi4 = float64(0.5641895835477563)

func x_jn(tls *TLS, n int32, x float64) (r float64) {
	var __u Tuint64_t
	var a float64
	var b float64
	var h float64
	var i int32
	var ix Tuint32_t
	var k int32
	var lx Tuint32_t
	var nf float64
	var nm1 int32
	var q0 float64
	var q1 float64
	var sign int32
	var t float64
	var temp float64
	var tmp float64
	var w float64
	var z float64
	var v1 float64
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		ix = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix|(lx|-lx)>>int32(31) > uint32(0x7ff00000) { /* nan */
		return x
	}
	/* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
	 * Thus, J(-n,x) = J(n,-x)
	 */
	/* nm1 = |n|-1 is used instead of |n| to handle n==INT_MIN */
	if n == int32(0) {
		return x_j0(tls, x)
	}
	if n < int32(0) {
		nm1 = -(n + int32(1))
		x = -x
		sign = sign ^ Int32FromInt32(1)
	} else {
		nm1 = n - int32(1)
	}
	if nm1 == int32(0) {
		return x_j1(tls, x)
	}
	sign = sign & n /* even n: 0, odd n: signbit(x) */
	x = x_fabs(tls, x)
	if ix|lx == uint32(0) || ix == uint32(0x7ff00000) { /* if x is 0 or inf */
		b = float64(0)
	} else {
		if float64(nm1) < x {
			/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
			if ix >= uint32(0x52d00000) { /* x > 2**302 */
				/* (x >> n**2)
				 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
				 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
				 *      Let s=sin(x), c=cos(x),
				 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
				 *
				 *             n    sin(xn)*sqt2    cos(xn)*sqt2
				 *          ----------------------------------
				 *             0     s-c             c+s
				 *             1    -s-c            -c+s
				 *             2    -s+c            -c-s
				 *             3     s+c             c-s
				 */
				switch nm1 & int32(3) {
				case int32(0):
					temp = -x_cos(tls, x) + x_sin(tls, x)
				case int32(1):
					temp = -x_cos(tls, x) - x_sin(tls, x)
				case int32(2):
					temp = x_cos(tls, x) - x_sin(tls, x)
				default:
					fallthrough
				case int32(3):
					temp = x_cos(tls, x) + x_sin(tls, x)
					break
				}
				b = _invsqrtpi4 * temp / x_sqrt(tls, x)
			} else {
				a = x_j0(tls, x)
				b = x_j1(tls, x)
				for i = int32(0); i < nm1; {
					i++
					temp = b
					b = b*(float64(2)*float64(i)/x) - a /* avoid underflow */
					a = temp
				}
			}
		} else {
			if ix < uint32(0x3e100000) { /* x < 2**-29 */
				/* x is tiny, return the first Taylor expansion of J(n,x)
				 * J(n,x) = 1/n!*(x/2)^n  - ...
				 */
				if nm1 > int32(32) { /* underflow */
					b = float64(0)
				} else {
					temp = x * float64(0.5)
					b = temp
					a = float64(1)
					for i = int32(2); i <= nm1+int32(1); i++ {
						a = a * float64(i) /* a = n! */
						b = b * temp
					}
					b = b / a
				}
			} else {
				/* use backward recurrence */
				/*                      x      x^2      x^2
				 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
				 *                      2n  - 2(n+1) - 2(n+2)
				 *
				 *                      1      1        1
				 *  (for large x)   =  ----  ------   ------   .....
				 *                      2n   2(n+1)   2(n+2)
				 *                      -- - ------ - ------ -
				 *                       x     x         x
				 *
				 * Let w = 2n/x and h=2/x, then the above quotient
				 * is equal to the continued fraction:
				 *                  1
				 *      = -----------------------
				 *                     1
				 *         w - -----------------
				 *                        1
				 *              w+h - ---------
				 *                     w+2h - ...
				 *
				 * To determine how many terms needed, let
				 * Q(0) = w, Q(1) = w(w+h) - 1,
				 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
				 * When Q(k) > 1e4      good for single
				 * When Q(k) > 1e9      good for double
				 * When Q(k) > 1e17     good for quadruple
				 */
				/* determine k */
				nf = float64(nm1) + float64(1)
				w = Float64FromInt32(2) * nf / x
				h = Float64FromInt32(2) / x
				z = w + h
				q0 = w
				q1 = w*z - float64(1)
				k = int32(1)
				for q1 < float64(1e+09) {
					k = k + Int32FromInt32(1)
					z = z + h
					tmp = z*q1 - q0
					q0 = q1
					q1 = tmp
				}
				t = float64(0)
				i = k
				for ; i >= int32(0); i-- {
					t = Float64FromInt32(1) / (Float64FromInt32(2)*(float64(i)+nf)/x - t)
				}
				a = t
				b = float64(1)
				/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
				 *  Hence, if n*(log(2n/x)) > ...
				 *  single 8.8722839355e+01
				 *  double 7.09782712893383973096e+02
				 *  long double 1.1356523406294143949491931077970765006170e+04
				 *  then recurrent value may overflow and the result is
				 *  likely underflow to zero
				 */
				tmp = nf * x_log(tls, x_fabs(tls, w))
				if tmp < float64(709.782712893384) {
					for i = nm1; i > int32(0); i-- {
						temp = b
						b = b*(float64(2)*float64(i))/x - a
						a = temp
					}
				} else {
					for i = nm1; i > int32(0); i-- {
						temp = b
						b = b*(float64(2)*float64(i))/x - a
						a = temp
						/* scale b to avoid spurious overflow */
						if b > float64(3.273390607896142e+150) {
							a = a / b
							t = t / b
							b = float64(1)
						}
					}
				}
				z = x_j0(tls, x)
				w = x_j1(tls, x)
				if x_fabs(tls, z) >= x_fabs(tls, w) {
					b = t * z / b
				} else {
					b = t * w / a
				}
			}
		}
	}
	if sign != 0 {
		v1 = -b
	} else {
		v1 = b
	}
	return v1
}

func x_yn(tls *TLS, n int32, x float64) (r float64) {
	var __u Tuint64_t
	var a float64
	var b float64
	var i int32
	var ib Tuint32_t
	var ix Tuint32_t
	var lx Tuint32_t
	var nm1 int32
	var sign int32
	var temp float64
	var v1 float64
	var v2 float64
	{
		__u = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x}))))
		ix = uint32(__u >> int32(32))
		lx = uint32(__u)
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix|(lx|-lx)>>int32(31) > uint32(0x7ff00000) { /* nan */
		return x
	}
	if sign != 0 && ix|lx != uint32(0) { /* x < 0 */
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix == uint32(0x7ff00000) {
		return float64(0)
	}
	if n == int32(0) {
		return x_y0(tls, x)
	}
	if n < int32(0) {
		nm1 = -(n + int32(1))
		sign = n & int32(1)
	} else {
		nm1 = n - int32(1)
		sign = int32(0)
	}
	if nm1 == int32(0) {
		if sign != 0 {
			v1 = -x_y1(tls, x)
		} else {
			v1 = x_y1(tls, x)
		}
		return v1
	}
	if ix >= uint32(0x52d00000) { /* x > 2**302 */
		/* (x >> n**2)
		 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Let s=sin(x), c=cos(x),
		 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
		 *
		 *             n    sin(xn)*sqt2    cos(xn)*sqt2
		 *          ----------------------------------
		 *             0     s-c             c+s
		 *             1    -s-c            -c+s
		 *             2    -s+c            -c-s
		 *             3     s+c             c-s
		 */
		switch nm1 & int32(3) {
		case int32(0):
			temp = -x_sin(tls, x) - x_cos(tls, x)
		case int32(1):
			temp = -x_sin(tls, x) + x_cos(tls, x)
		case int32(2):
			temp = x_sin(tls, x) + x_cos(tls, x)
		default:
			fallthrough
		case int32(3):
			temp = x_sin(tls, x) - x_cos(tls, x)
			break
		}
		b = _invsqrtpi4 * temp / x_sqrt(tls, x)
	} else {
		a = x_y0(tls, x)
		b = x_y1(tls, x)
		/* quit if b is -inf */
		{
			ib = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: b})))) >> int32(32))
		}
		for i = int32(0); i < nm1 && ib != uint32(0xfff00000); {
			i++
			temp = b
			b = float64(2)*float64(i)/x*b - a
			{
				ib = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
					F_i [0]Tuint64_t
					F_f float64
				}{F_f: b})))) >> int32(32))
			}
			a = temp
		}
	}
	if sign != 0 {
		v2 = -b
	} else {
		v2 = b
	}
	return v2
}

func x_jnf(tls *TLS, n int32, x float32) (r float32) {
	var a float32
	var b float32
	var h float32
	var i int32
	var ix Tuint32_t
	var k int32
	var nf float32
	var nm1 int32
	var q0 float32
	var q1 float32
	var sign int32
	var t float32
	var temp float32
	var tmp float32
	var w float32
	var z float32
	var v1 float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix > uint32(0x7f800000) { /* nan */
		return x
	}
	/* J(-n,x) = J(n,-x), use |n|-1 to avoid overflow in -n */
	if n == int32(0) {
		return x_j0f(tls, x)
	}
	if n < int32(0) {
		nm1 = -(n + int32(1))
		x = -x
		sign = sign ^ Int32FromInt32(1)
	} else {
		nm1 = n - int32(1)
	}
	if nm1 == int32(0) {
		return x_j1f(tls, x)
	}
	sign = sign & n /* even n: 0, odd n: signbit(x) */
	x = x_fabsf(tls, x)
	if ix == uint32(0) || ix == uint32(0x7f800000) { /* if x is 0 or inf */
		b = Float32FromFloat32(0)
	} else {
		if float32(nm1) < x {
			/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
			a = x_j0f(tls, x)
			b = x_j1f(tls, x)
			for i = int32(0); i < nm1; {
				i++
				temp = b
				b = b*(Float32FromFloat32(2)*float32(i)/x) - a
				a = temp
			}
		} else {
			if ix < uint32(0x35800000) { /* x < 2**-20 */
				/* x is tiny, return the first Taylor expansion of J(n,x)
				 * J(n,x) = 1/n!*(x/2)^n  - ...
				 */
				if nm1 > int32(8) { /* underflow */
					nm1 = int32(8)
				}
				temp = Float32FromFloat32(0.5) * x
				b = temp
				a = Float32FromFloat32(1)
				for i = int32(2); i <= nm1+int32(1); i++ {
					a = a * float32(i) /* a = n! */
					b = b * temp
				}
				b = b / a
			} else {
				/* use backward recurrence */
				/*                      x      x^2      x^2
				 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
				 *                      2n  - 2(n+1) - 2(n+2)
				 *
				 *                      1      1        1
				 *  (for large x)   =  ----  ------   ------   .....
				 *                      2n   2(n+1)   2(n+2)
				 *                      -- - ------ - ------ -
				 *                       x     x         x
				 *
				 * Let w = 2n/x and h=2/x, then the above quotient
				 * is equal to the continued fraction:
				 *                  1
				 *      = -----------------------
				 *                     1
				 *         w - -----------------
				 *                        1
				 *              w+h - ---------
				 *                     w+2h - ...
				 *
				 * To determine how many terms needed, let
				 * Q(0) = w, Q(1) = w(w+h) - 1,
				 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
				 * When Q(k) > 1e4      good for single
				 * When Q(k) > 1e9      good for double
				 * When Q(k) > 1e17     good for quadruple
				 */
				/* determine k */
				nf = float32(nm1) + Float32FromFloat32(1)
				w = Float32FromInt32(2) * nf / x
				h = Float32FromInt32(2) / x
				z = w + h
				q0 = w
				q1 = w*z - Float32FromFloat32(1)
				k = int32(1)
				for q1 < Float32FromFloat32(10000) {
					k = k + Int32FromInt32(1)
					z = z + h
					tmp = z*q1 - q0
					q0 = q1
					q1 = tmp
				}
				t = Float32FromFloat32(0)
				i = k
				for ; i >= int32(0); i-- {
					t = Float32FromFloat32(1) / (Float32FromInt32(2)*(float32(i)+nf)/x - t)
				}
				a = t
				b = Float32FromFloat32(1)
				/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
				 *  Hence, if n*(log(2n/x)) > ...
				 *  single 8.8722839355e+01
				 *  double 7.09782712893383973096e+02
				 *  long double 1.1356523406294143949491931077970765006170e+04
				 *  then recurrent value may overflow and the result is
				 *  likely underflow to zero
				 */
				tmp = nf * x_logf(tls, x_fabsf(tls, w))
				if tmp < Float32FromFloat32(88.721679688) {
					for i = nm1; i > int32(0); i-- {
						temp = b
						b = Float32FromFloat32(2)*float32(i)*b/x - a
						a = temp
					}
				} else {
					for i = nm1; i > int32(0); i-- {
						temp = b
						b = Float32FromFloat32(2)*float32(i)*b/x - a
						a = temp
						/* scale b to avoid spurious overflow */
						if b > Float32FromFloat32(1.152921504606847e+18) {
							a = a / b
							t = t / b
							b = Float32FromFloat32(1)
						}
					}
				}
				z = x_j0f(tls, x)
				w = x_j1f(tls, x)
				if x_fabsf(tls, z) >= x_fabsf(tls, w) {
					b = t * z / b
				} else {
					b = t * w / a
				}
			}
		}
	}
	if sign != 0 {
		v1 = -b
	} else {
		v1 = b
	}
	return v1
}

func x_ynf(tls *TLS, n int32, x float32) (r float32) {
	var a float32
	var b float32
	var i int32
	var ib Tuint32_t
	var ix Tuint32_t
	var nm1 int32
	var sign int32
	var temp float32
	var v1 float32
	var v2 float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix > uint32(0x7f800000) { /* nan */
		return x
	}
	if sign != 0 && ix != uint32(0) { /* x < 0 */
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix == uint32(0x7f800000) {
		return Float32FromFloat32(0)
	}
	if n == int32(0) {
		return x_y0f(tls, x)
	}
	if n < int32(0) {
		nm1 = -(n + int32(1))
		sign = n & int32(1)
	} else {
		nm1 = n - int32(1)
		sign = int32(0)
	}
	if nm1 == int32(0) {
		if sign != 0 {
			v1 = -x_y1f(tls, x)
		} else {
			v1 = x_y1f(tls, x)
		}
		return v1
	}
	a = x_y0f(tls, x)
	b = x_y1f(tls, x)
	/* quit if b is -inf */
	{
		ib = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: b}))))
	}
	for i = int32(0); i < nm1 && ib != uint32(0xff800000); {
		i++
		temp = b
		b = Float32FromFloat32(2)*float32(i)/x*b - a
		{
			ib = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint32_t
				F_f float32
			}{F_f: b}))))
		}
		a = temp
	}
	if sign != 0 {
		v2 = -b
	} else {
		v2 = b
	}
	return v2
}

func x_ldexp(tls *TLS, x float64, n int32) (r float64) {
	return x_scalbn(tls, x, n)
}

func x_ldexpf(tls *TLS, x float32, n int32) (r float32) {
	return x_scalbnf(tls, x, n)
}

func x_ldexpl(tls *TLS, x float64, n int32) (r float64) {
	return x_scalbnl(tls, x, n)
}

func x_lgamma(tls *TLS, x float64) (r float64) {
	return x___lgamma_r(tls, x, uintptr(unsafe.Pointer(&x___signgam)))
}

var _pi2 = float64(3.141592653589793)              /* 0x400921FB, 0x54442D18 */
var _a0 = float64(0.07721566490153287)             /* 0x3FB3C467, 0xE37DB0C8 */
var _a1 = float64(0.3224670334241136)              /* 0x3FD4A34C, 0xC4A60FAD */
var _a2 = float64(0.06735230105312927)             /* 0x3FB13E00, 0x1A5562A7 */
var _a3 = float64(0.020580808432516733)            /* 0x3F951322, 0xAC92547B */
var _a4 = float64(0.007385550860814029)            /* 0x3F7E404F, 0xB68FEFE8 */
var _a5 = float64(0.0028905138367341563)           /* 0x3F67ADD8, 0xCCB7926B */
var _a6 = float64(0.0011927076318336207)           /* 0x3F538A94, 0x116F3F5D */
var _a7 = float64(0.0005100697921535113)           /* 0x3F40B6C6, 0x89B99C00 */
var _a8 = float64(0.00022086279071390839)          /* 0x3F2CF2EC, 0xED10E54D */
var _a9 = float64(0.00010801156724758394)          /* 0x3F1C5088, 0x987DFB07 */
var _a10 = float64(2.5214456545125733e-05)         /* 0x3EFA7074, 0x428CFA52 */
var _a11 = float64(4.4864094961891516e-05)         /* 0x3F07858E, 0x90A45837 */
var _tc = float64(1.4616321449683622)              /* 0x3FF762D8, 0x6356BE3F */
var _tf = -Float64FromFloat64(0.12148629053584961) /* 0xBFBF19B9, 0xBCC38A42 */
/* tt = -(tail of tf) */
var _tt = -Float64FromFloat64(3.638676997039505e-18)   /* 0xBC50C7CA, 0xA48A971F */
var _t0 = float64(0.48383612272381005)                 /* 0x3FDEF72B, 0xC8EE38A2 */
var _t1 = -Float64FromFloat64(0.1475877229945939)      /* 0xBFC2E427, 0x8DC6C509 */
var _t2 = float64(0.06462494023913339)                 /* 0x3FB08B42, 0x94D5419B */
var _t3 = -Float64FromFloat64(0.032788541075985965)    /* 0xBFA0C9A8, 0xDF35B713 */
var _t4 = float64(0.01797067508118204)                 /* 0x3F9266E7, 0x970AF9EC */
var _t5 = -Float64FromFloat64(0.010314224129834144)    /* 0xBF851F9F, 0xBA91EC6A */
var _t6 = float64(0.006100538702462913)                /* 0x3F78FCE0, 0xE370E344 */
var _t7 = -Float64FromFloat64(0.0036845201678113826)   /* 0xBF6E2EFF, 0xB3E914D7 */
var _t8 = float64(0.0022596478090061247)               /* 0x3F6282D3, 0x2E15C915 */
var _t9 = -Float64FromFloat64(0.0014034646998923284)   /* 0xBF56FE8E, 0xBF2D1AF1 */
var _t10 = float64(0.000881081882437654)               /* 0x3F4CDF0C, 0xEF61A8E9 */
var _t11 = -Float64FromFloat64(0.0005385953053567405)  /* 0xBF41A610, 0x9C73E0EC */
var _t12 = float64(0.00031563207090362595)             /* 0x3F34AF6D, 0x6C0EBBF7 */
var _t13 = -Float64FromFloat64(0.00031275416837512086) /* 0xBF347F24, 0xECC38C38 */
var _t14 = float64(0.0003355291926355191)              /* 0x3F35FD3E, 0xE8C2D3F4 */
var _u0 = -Float64FromFloat64(0.07721566490153287)     /* 0xBFB3C467, 0xE37DB0C8 */
var _u1 = float64(0.6328270640250934)                  /* 0x3FE4401E, 0x8B005DFF */
var _u2 = float64(1.4549225013723477)                  /* 0x3FF7475C, 0xD119BD6F */
var _u3 = float64(0.9777175279633727)                  /* 0x3FEF4976, 0x44EA8450 */
var _u4 = float64(0.22896372806469245)                 /* 0x3FCD4EAE, 0xF6010924 */
var _u5 = float64(0.013381091853678766)                /* 0x3F8B678B, 0xBF2BAB09 */
var _v1 = float64(2.4559779371304113)                  /* 0x4003A5D7, 0xC2BD619C */
var _v2 = float64(2.128489763798934)                   /* 0x40010725, 0xA42B18F5 */
var _v3 = float64(0.7692851504566728)                  /* 0x3FE89DFB, 0xE45050AF */
var _v4 = float64(0.10422264559336913)                 /* 0x3FBAAE55, 0xD6537C88 */
var _v5 = float64(0.003217092422824239)                /* 0x3F6A5ABB, 0x57D0CF61 */
var _s0 = -Float64FromFloat64(0.07721566490153287)     /* 0xBFB3C467, 0xE37DB0C8 */
var _s1 = float64(0.21498241596060885)                 /* 0x3FCB848B, 0x36E20878 */
var _s2 = float64(0.325778796408931)                   /* 0x3FD4D98F, 0x4F139F59 */
var _s3 = float64(0.14635047265246445)                 /* 0x3FC2BB9C, 0xBEE5F2F7 */
var _s4 = float64(0.02664227030336386)                 /* 0x3F9B481C, 0x7E939961 */
var _s5 = float64(0.0018402845140733772)               /* 0x3F5E26B6, 0x7368F239 */
var _s6 = float64(3.194753265841009e-05)               /* 0x3F00BFEC, 0xDD17E945 */
var _r1 = float64(1.3920053346762105)                  /* 0x3FF645A7, 0x62C4AB74 */
var _r2 = float64(0.7219355475671381)                  /* 0x3FE71A18, 0x93D3DCDC */
var _r3 = float64(0.17193386563280308)                 /* 0x3FC601ED, 0xCCFBDF27 */
var _r4 = float64(0.01864591917156529)                 /* 0x3F9317EA, 0x742ED475 */
var _r5 = float64(0.0007779424963818936)               /* 0x3F497DDA, 0xCA41A95B */
var _r6 = float64(7.326684307446256e-06)               /* 0x3EDEBAF7, 0xA5B38140 */
var _w0 = float64(0.4189385332046727)                  /* 0x3FDACFE3, 0x90C97D69 */
var _w1 = float64(0.08333333333333297)                 /* 0x3FB55555, 0x5555553B */
var _w2 = -Float64FromFloat64(0.0027777777772877554)   /* 0xBF66C16C, 0x16B02E5C */
var _w3 = float64(0.0007936505586430196)               /* 0x3F4A019F, 0x98CF38B6 */
var _w4 = -Float64FromFloat64(0.00059518755745034)     /* 0xBF4380CB, 0x8C0FE741 */
var _w5 = float64(0.0008363399189962821)               /* 0x3F4B67BA, 0x4CDAD5D1 */
var _w6 = -Float64FromFloat64(0.0016309293409657527)   /* 0xBF5AB89D, 0x0B9E43E4 */

// C documentation
//
//	/* sin(pi*x) assuming x > 2^-100, if sin(pi*x)==0 the sign is arbitrary */
func _sin_pi(tls *TLS, x float64) (r float64) {
	var n int32
	/* spurious inexact if odd int */
	x = float64(2) * (x*float64(0.5) - x_floor(tls, x*float64(0.5))) /* x mod 2.0 */
	n = int32(x * Float64FromFloat64(4))
	n = (n + int32(1)) / int32(2)
	x = x - float64(float32(n)*Float32FromFloat32(0.5))
	x = x * _pi2
	switch n {
	default: /* case 4: */
		fallthrough
	case int32(0):
		return x___sin(tls, x, float64(0), int32(0))
	case int32(1):
		return x___cos(tls, x, float64(0))
	case int32(2):
		return x___sin(tls, -x, float64(0), int32(0))
	case int32(3):
		return -x___cos(tls, x, float64(0))
	}
	return r
}

func x___lgamma_r(tls *TLS, x float64, signgamp uintptr) (r1 float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var i int32
	var ix Tuint32_t
	var nadj Tdouble_t
	var p Tdouble_t
	var p1 Tdouble_t
	var p2 Tdouble_t
	var p3 Tdouble_t
	var q Tdouble_t
	var r Tdouble_t
	var sign int32
	var t Tdouble_t
	var w Tdouble_t
	var y Tdouble_t
	var z Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	/* purge off +-inf, NaN, +-0, tiny and negative arguments */
	*(*int32)(unsafe.Pointer(signgamp)) = int32(1)
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if ix >= uint32(0x7ff00000) {
		return x * x
	}
	if ix < uint32((Int32FromInt32(0x3ff)-Int32FromInt32(70))<<Int32FromInt32(20)) {
		/* |x|<2**-70, return -log(|x|) */
		if sign != 0 {
			x = -x
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		}
		return -x_log(tls, x)
	}
	if sign != 0 {
		x = -x
		t = _sin_pi(tls, x)
		if t == float64(0) { /* -integer */
			return float64(1) / (x - x)
		}
		if t > float64(0) {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		} else {
			t = -t
		}
		nadj = x_log(tls, _pi2/(t*x))
	}
	/* purge off 1 and 2 */
	if (ix == uint32(0x3ff00000) || ix == uint32(0x40000000)) && uint32(*(*Tuint64_t)(unsafe.Pointer(bp))) == uint32(0) {
		r = Float64FromInt32(0)
	} else {
		if ix < uint32(0x40000000) {
			if ix <= uint32(0x3feccccc) { /* lgamma(x) = lgamma(x+1)-log(x) */
				r = -x_log(tls, x)
				if ix >= uint32(0x3FE76944) {
					y = float64(1) - x
					i = int32(0)
				} else {
					if ix >= uint32(0x3FCDA661) {
						y = x - (_tc - float64(1))
						i = int32(1)
					} else {
						y = x
						i = int32(2)
					}
				}
			} else {
				r = float64(0)
				if ix >= uint32(0x3FFBB4C3) { /* [1.7316,2] */
					y = float64(2) - x
					i = int32(0)
				} else {
					if ix >= uint32(0x3FF3B4C4) { /* [1.23,1.73] */
						y = x - _tc
						i = int32(1)
					} else {
						y = x - float64(1)
						i = int32(2)
					}
				}
			}
			switch i {
			case int32(0):
				z = y * y
				p1 = _a0 + z*(_a2+z*(_a4+z*(_a6+z*(_a8+z*_a10))))
				p2 = z * (_a1 + z*(_a3+z*(_a5+z*(_a7+z*(_a9+z*_a11)))))
				p = y*p1 + p2
				r = r + (p - Float64FromFloat64(0.5)*y)
			case int32(1):
				z = y * y
				w = z * y
				p1 = _t0 + w*(_t3+w*(_t6+w*(_t9+w*_t12))) /* parallel comp */
				p2 = _t1 + w*(_t4+w*(_t7+w*(_t10+w*_t13)))
				p3 = _t2 + w*(_t5+w*(_t8+w*(_t11+w*_t14)))
				p = z*p1 - (_tt - w*(p2+y*p3))
				r = r + (_tf + p)
			case int32(2):
				p1 = y * (_u0 + y*(_u1+y*(_u2+y*(_u3+y*(_u4+y*_u5)))))
				p2 = float64(1) + y*(_v1+y*(_v2+y*(_v3+y*(_v4+y*_v5))))
				r = r + (-Float64FromFloat64(0.5)*y + p1/p2)
			}
		} else {
			if ix < uint32(0x40200000) { /* x < 8.0 */
				i = int32(x)
				y = x - float64(i)
				p = y * (_s0 + y*(_s1+y*(_s2+y*(_s3+y*(_s4+y*(_s5+y*_s6))))))
				q = float64(1) + y*(_r1+y*(_r2+y*(_r3+y*(_r4+y*(_r5+y*_r6)))))
				r = float64(0.5)*y + p/q
				z = float64(1) /* lgamma(1+s) = log(s) + lgamma(s) */
				switch i {
				case int32(7):
					z = z * (y + Float64FromFloat64(6)) /* FALLTHRU */
					fallthrough
				case int32(6):
					z = z * (y + Float64FromFloat64(5)) /* FALLTHRU */
					fallthrough
				case int32(5):
					z = z * (y + Float64FromFloat64(4)) /* FALLTHRU */
					fallthrough
				case int32(4):
					z = z * (y + Float64FromFloat64(3)) /* FALLTHRU */
					fallthrough
				case int32(3):
					z = z * (y + Float64FromFloat64(2)) /* FALLTHRU */
					r = r + x_log(tls, z)
					break
				}
			} else {
				if ix < uint32(0x43900000) { /* 8.0 <= x < 2**58 */
					t = x_log(tls, x)
					z = float64(1) / x
					y = z * z
					w = _w0 + z*(_w1+y*(_w2+y*(_w3+y*(_w4+y*(_w5+y*_w6)))))
					r = (x-float64(0.5))*(t-Float64FromFloat64(1)) + w
				} else { /* 2**58 <= x <= inf */
					r = x * (x_log(tls, x) - float64(1))
				}
			}
		}
	}
	if sign != 0 {
		r = nadj - r
	}
	return r
}

func x_lgammaf(tls *TLS, x float32) (r float32) {
	return x___lgammaf_r(tls, x, uintptr(unsafe.Pointer(&x___signgam)))
}

var _pi3 = float32(3.141592741)                        /* 0x40490fdb */
var _a01 = float32(0.077215664089)                     /* 0x3d9e233f */
var _a12 = float32(0.32246702909)                      /* 0x3ea51a66 */
var _a21 = float32(0.067352302372)                     /* 0x3d89f001 */
var _a31 = float32(0.020580807701)                     /* 0x3ca89915 */
var _a41 = float32(0.0073855509982)                    /* 0x3bf2027e */
var _a51 = float32(0.0028905137442)                    /* 0x3b3d6ec6 */
var _a61 = float32(0.0011927076848)                    /* 0x3a9c54a1 */
var _a71 = float32(0.00051006977446)                   /* 0x3a05b634 */
var _a81 = float32(0.00022086278477)                   /* 0x39679767 */
var _a91 = float32(0.00010801156895)                   /* 0x38e28445 */
var _a101 = float32(2.52144564e-05)                    /* 0x37d383a2 */
var _a111 = float32(4.4864096708e-05)                  /* 0x383c2c75 */
var _tc1 = float32(1.4616321325)                       /* 0x3fbb16c3 */
var _tf1 = float32(-Float64FromFloat64(0.12148628384)) /* 0xbdf8cdcd */
/* tt = -(tail of tf) */
var _tt1 = float32(6.6971006518e-09)                       /* 0x31e61c52 */
var _t01 = float32(0.48383611441)                          /* 0x3ef7b95e */
var _t15 = float32(-Float64FromFloat64(0.14758771658))     /* 0xbe17213c */
var _t21 = float32(0.064624942839)                         /* 0x3d845a15 */
var _t31 = float32(-Float64FromFloat64(0.032788541168))    /* 0xbd064d47 */
var _t41 = float32(0.017970675603)                         /* 0x3c93373d */
var _t51 = float32(-Float64FromFloat64(0.010314224288))    /* 0xbc28fcfe */
var _t61 = float32(0.0061005386524)                        /* 0x3bc7e707 */
var _t71 = float32(-Float64FromFloat64(0.0036845202558))   /* 0xbb7177fe */
var _t81 = float32(0.0022596477065)                        /* 0x3b141699 */
var _t91 = float32(-Float64FromFloat64(0.0014034647029))   /* 0xbab7f476 */
var _t101 = float32(0.00088108185446)                      /* 0x3a66f867 */
var _t111 = float32(-Float64FromFloat64(0.00053859531181)) /* 0xba0d3085 */
var _t121 = float32(0.00031563205994)                      /* 0x39a57b6b */
var _t131 = float32(-Float64FromFloat64(0.00031275415677)) /* 0xb9a3f927 */
var _t141 = float32(0.00033552918467)                      /* 0x39afe9f7 */
var _u07 = float32(-Float64FromFloat64(0.077215664089))    /* 0xbd9e233f */
var _u11 = float32(0.63282704353)                          /* 0x3f2200f4 */
var _u21 = float32(1.4549225569)                           /* 0x3fba3ae7 */
var _u31 = float32(0.97771751881)                          /* 0x3f7a4bb2 */
var _u41 = float32(0.22896373272)                          /* 0x3e6a7578 */
var _u51 = float32(0.013381091878)                         /* 0x3c5b3c5e */
var _v11 = float32(2.4559779167)                           /* 0x401d2ebe */
var _v21 = float32(2.1284897327)                           /* 0x4008392d */
var _v31 = float32(0.76928514242)                          /* 0x3f44efdf */
var _v41 = float32(0.10422264785)                          /* 0x3dd572af */
var _v51 = float32(0.0032170924824)                        /* 0x3b52d5db */
var _s06 = float32(-Float64FromFloat64(0.077215664089))    /* 0xbd9e233f */
var _s11 = float32(0.21498242021)                          /* 0x3e5c245a */
var _s21 = float32(0.32577878237)                          /* 0x3ea6cc7a */
var _s31 = float32(0.14635047317)                          /* 0x3e15dce6 */
var _s41 = float32(0.026642270386)                         /* 0x3cda40e4 */
var _s51 = float32(0.0018402845599)                        /* 0x3af135b4 */
var _s61 = float32(3.1947532989e-05)                       /* 0x3805ff67 */
var _r11 = float32(1.3920053244)                           /* 0x3fb22d3b */
var _r21 = float32(0.72193557024)                          /* 0x3f38d0c5 */
var _r31 = float32(0.17193385959)                          /* 0x3e300f6e */
var _r41 = float32(0.018645919859)                         /* 0x3c98bf54 */
var _r51 = float32(0.00077794247773)                       /* 0x3a4beed6 */
var _r61 = float32(7.3266842264e-06)                       /* 0x36f5d7bd */
var _w01 = float32(0.41893854737)                          /* 0x3ed67f1d */
var _w11 = float32(0.083333335817)                         /* 0x3daaaaab */
var _w21 = float32(-Float64FromFloat64(0.002777777845))    /* 0xbb360b61 */
var _w31 = float32(0.00079365057172)                       /* 0x3a500cfd */
var _w41 = float32(-Float64FromFloat64(0.00059518753551))  /* 0xba1c065c */
var _w51 = float32(0.00083633989561)                       /* 0x3a5b3dd2 */
var _w61 = float32(-Float64FromFloat64(0.0016309292987))   /* 0xbad5c4e8 */

// C documentation
//
//	/* sin(pi*x) assuming x > 2^-100, if sin(pi*x)==0 the sign is arbitrary */
func _sin_pi1(tls *TLS, x float32) (r float32) {
	var n int32
	var y Tdouble_t
	/* spurious inexact if odd int */
	x = Float32FromInt32(2) * (x*Float32FromFloat32(0.5) - x_floorf(tls, x*Float32FromFloat32(0.5))) /* x mod 2.0 */
	n = int32(x * Float32FromInt32(4))
	n = (n + int32(1)) / int32(2)
	y = float64(x - float32(n)*Float32FromFloat32(0.5))
	y = y * Float64FromFloat64(3.141592653589793)
	switch n {
	default: /* case 4: */
		fallthrough
	case int32(0):
		return x___sindf(tls, y)
	case int32(1):
		return x___cosdf(tls, y)
	case int32(2):
		return x___sindf(tls, -y)
	case int32(3):
		return -x___cosdf(tls, y)
	}
	return r
}

func x___lgammaf_r(tls *TLS, x float32, signgamp uintptr) (r1 float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var i int32
	var ix Tuint32_t
	var nadj float32
	var p float32
	var p1 float32
	var p2 float32
	var p3 float32
	var q float32
	var r float32
	var sign int32
	var t float32
	var w float32
	var y float32
	var z float32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	/* purge off +-inf, NaN, +-0, tiny and negative arguments */
	*(*int32)(unsafe.Pointer(signgamp)) = int32(1)
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	ix = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return x * x
	}
	if ix < uint32(0x35000000) {
		/* |x| < 2**-21, return -log(|x|) */
		if sign != 0 {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
			x = -x
		}
		return -x_logf(tls, x)
	}
	if sign != 0 {
		x = -x
		t = _sin_pi1(tls, x)
		if t == Float32FromFloat32(0) { /* -integer */
			return Float32FromFloat32(1) / (x - x)
		}
		if t > Float32FromFloat32(0) {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		} else {
			t = -t
		}
		nadj = x_logf(tls, _pi3/(t*x))
	}
	/* purge off 1 and 2 */
	if ix == uint32(0x3f800000) || ix == uint32(0x40000000) {
		r = Float32FromInt32(0)
	} else {
		if ix < uint32(0x40000000) {
			if ix <= uint32(0x3f666666) { /* lgamma(x) = lgamma(x+1)-log(x) */
				r = -x_logf(tls, x)
				if ix >= uint32(0x3f3b4a20) {
					y = Float32FromFloat32(1) - x
					i = int32(0)
				} else {
					if ix >= uint32(0x3e6d3308) {
						y = x - (_tc1 - Float32FromFloat32(1))
						i = int32(1)
					} else {
						y = x
						i = int32(2)
					}
				}
			} else {
				r = Float32FromFloat32(0)
				if ix >= uint32(0x3fdda618) { /* [1.7316,2] */
					y = Float32FromFloat32(2) - x
					i = int32(0)
				} else {
					if ix >= uint32(0x3F9da620) { /* [1.23,1.73] */
						y = x - _tc1
						i = int32(1)
					} else {
						y = x - Float32FromFloat32(1)
						i = int32(2)
					}
				}
			}
			switch i {
			case int32(0):
				z = y * y
				p1 = _a01 + z*(_a21+z*(_a41+z*(_a61+z*(_a81+z*_a101))))
				p2 = z * (_a12 + z*(_a31+z*(_a51+z*(_a71+z*(_a91+z*_a111)))))
				p = y*p1 + p2
				r = r + (p - Float32FromFloat32(0.5)*y)
			case int32(1):
				z = y * y
				w = z * y
				p1 = _t01 + w*(_t31+w*(_t61+w*(_t91+w*_t121))) /* parallel comp */
				p2 = _t15 + w*(_t41+w*(_t71+w*(_t101+w*_t131)))
				p3 = _t21 + w*(_t51+w*(_t81+w*(_t111+w*_t141)))
				p = z*p1 - (_tt1 - w*(p2+y*p3))
				r = r + (_tf1 + p)
			case int32(2):
				p1 = y * (_u07 + y*(_u11+y*(_u21+y*(_u31+y*(_u41+y*_u51)))))
				p2 = Float32FromFloat32(1) + y*(_v11+y*(_v21+y*(_v31+y*(_v41+y*_v51))))
				r = r + (-Float32FromFloat32(0.5)*y + p1/p2)
			}
		} else {
			if ix < uint32(0x41000000) { /* x < 8.0 */
				i = int32(x)
				y = x - float32(i)
				p = y * (_s06 + y*(_s11+y*(_s21+y*(_s31+y*(_s41+y*(_s51+y*_s61))))))
				q = Float32FromFloat32(1) + y*(_r11+y*(_r21+y*(_r31+y*(_r41+y*(_r51+y*_r61)))))
				r = Float32FromFloat32(0.5)*y + p/q
				z = Float32FromFloat32(1) /* lgamma(1+s) = log(s) + lgamma(s) */
				switch i {
				case int32(7):
					z = z * (y + Float32FromFloat32(6)) /* FALLTHRU */
					fallthrough
				case int32(6):
					z = z * (y + Float32FromFloat32(5)) /* FALLTHRU */
					fallthrough
				case int32(5):
					z = z * (y + Float32FromFloat32(4)) /* FALLTHRU */
					fallthrough
				case int32(4):
					z = z * (y + Float32FromFloat32(3)) /* FALLTHRU */
					fallthrough
				case int32(3):
					z = z * (y + Float32FromFloat32(2)) /* FALLTHRU */
					r = r + x_logf(tls, z)
					break
				}
			} else {
				if ix < uint32(0x5c800000) { /* 8.0 <= x < 2**58 */
					t = x_logf(tls, x)
					z = Float32FromFloat32(1) / x
					y = z * z
					w = _w01 + z*(_w11+y*(_w21+y*(_w31+y*(_w41+y*(_w51+y*_w61)))))
					r = (x-Float32FromFloat32(0.5))*(t-Float32FromFloat32(1)) + w
				} else { /* 2**58 <= x <= inf */
					r = x * (x_logf(tls, x) - Float32FromFloat32(1))
				}
			}
		}
	}
	if sign != 0 {
		r = nadj - r
	}
	return r
}

func x___lgammal_r(tls *TLS, x float64, sg uintptr) (r float64) {
	return x___lgamma_r(tls, x, sg)
}

func x_lgammal(tls *TLS, x float64) (r float64) {
	return x___lgammal_r(tls, x, uintptr(unsafe.Pointer(&x___signgam)))
}

func x_llround(tls *TLS, x float64) (r int64) {
	return int64(x_round(tls, x))
}

func x_llroundf(tls *TLS, x float32) (r int64) {
	return int64(x_roundf(tls, x))
}

func x_llroundl(tls *TLS, x float64) (r int64) {
	return int64(x_roundl(tls, x))
}

const m_LOG_POLY1_ORDER = 12
const m_LOG_POLY_ORDER = 6
const m_LOG_TABLE_BITS = 7
const m_OFF = 4604367669032910848

// C documentation
//
//	/* Top 16 bits of a double.  */
func _top16(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x})))) >> int32(48))
}

func x_log(tls *TLS, x float64) (r1 float64) {
	var hi Tdouble_t
	var i int32
	var invc Tdouble_t
	var ix Tuint64_t
	var iz Tuint64_t
	var k int32
	var kd Tdouble_t
	var lo Tdouble_t
	var logc Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var r3 Tdouble_t
	var rhi Tdouble_t
	var rlo Tdouble_t
	var tmp Tuint64_t
	var top Tuint32_t
	var w Tdouble_t
	var y Tdouble_t
	var z Tdouble_t
	ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x}))))
	top = _top16(tls, x)
	if ___builtin_expect(tls, BoolInt32(ix-*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) - Float64FromFloat64(0.0625)})))) < *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) + Float64FromFloat64(0.064697265625)}))))-*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) - Float64FromFloat64(0.0625)}))))), int32(0)) != 0 {
		/* Handle close to 1.0 inputs separately.  */
		/* Fix sign of zero with downward rounding when x==1.  */
		if int32(m_WANT_ROUNDING) != 0 && ___builtin_expect(tls, BoolInt32(ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: float64(1)}))))), int32(0)) != 0 {
			return Float64FromInt32(0)
		}
		r = x - float64(1)
		r2 = r * r
		r3 = r * r2
		y = r3 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(1)*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(2)*8)) + r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(3)*8)) + r3*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(4)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(5)*8))+r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(6)*8))+r3*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(7)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(8)*8))+r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(9)*8))+r3**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(10)*8)))))
		/* Worst-case error is around 0.507 ULP.  */
		w = r * float64(1.34217728e+08)
		rhi = r + w - w
		rlo = r - rhi
		w = rhi * rhi * *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(0)*8)) /* B[0] == -0.5.  */
		hi = r + w
		lo = r - hi + w
		lo = lo + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly1)) + UintptrFromInt32(0)*8))*rlo*(rhi+r)
		y = y + lo
		y = y + hi
		return _eval_as_double(tls, y)
	}
	if ___builtin_expect(tls, BoolInt32(top-uint32(0x0010) >= uint32(Int32FromInt32(0x7ff0)-Int32FromInt32(0x0010))), int32(0)) != 0 {
		/* x < 0x1p-1022 or inf or nan.  */
		if ix*uint64(2) == uint64(0) {
			return x___math_divzero(tls, uint32(1))
		}
		if ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: float64(___builtin_inff(tls))})))) { /* log(inf) == inf.  */
			return x
		}
		if top&uint32(0x8000) != 0 || top&uint32(0x7ff0) == uint32(0x7ff0) {
			return x___math_invalid(tls, x)
		}
		/* x is subnormal, normalize it.  */
		ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x * float64(4.503599627370496e+15)}))))
		ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(m_OFF)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(m_LOG_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(m_LOG_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Ftab)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Ftab)) + uintptr(i)*16))).Flogc
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: iz}))))
	/* log(x) = log1p(z/c-1) + log(c) + k*Ln2.  */
	/* r ~= z/c - 1, |r| < 1/(2*N).  */
	/* rounding error: 0x1p-55/N + 0x1p-66.  */
	r = (z - (*(*struct {
		Fchi float64
		Fclo float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Ftab2)) + uintptr(i)*16))).Fchi - (*(*struct {
		Fchi float64
		Fclo float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Ftab2)) + uintptr(i)*16))).Fclo) * invc
	kd = float64(k)
	/* hi + lo = r + log(c) + k*Ln2.  */
	w = kd*x___log_data.Fln2hi + logc
	hi = w + r
	lo = w - hi + r + kd*x___log_data.Fln2lo
	/* log(x) = lo + (log1p(r) - r) + hi.  */
	r2 = r * r /* rounding error: 0x1p-54/N^2.  */
	/* Worst case error if |y| > 0x1p-5:
	   0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)
	   Worst case error if |y| > 0x1p-4:
	   0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).  */
	y = lo + r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly)) + UintptrFromInt32(0)*8)) + r*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly)) + UintptrFromInt32(1)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly)) + UintptrFromInt32(2)*8))+r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly)) + UintptrFromInt32(3)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log_data.Fpoly)) + UintptrFromInt32(4)*8)))) + hi
	return _eval_as_double(tls, y)
}

var _ivln10hi = float64(0.4342944818781689)     /* 0x3fdbcb7b, 0x15200000 */
var _ivln10lo = float64(2.5082946711645275e-11) /* 0x3dbb9438, 0xca9aadd5 */
var _log10_2hi = float64(0.30102999566361177)   /* 0x3FD34413, 0x509F6000 */
var _log10_2lo = float64(3.694239077158931e-13) /* 0x3D59FEF3, 0x11F12B36 */
var _Lg1 = float64(0.6666666666666735)          /* 3FE55555 55555593 */
var _Lg2 = float64(0.3999999999940942)          /* 3FD99999 9997FA04 */
var _Lg3 = float64(0.2857142874366239)          /* 3FD24924 94229359 */
var _Lg4 = float64(0.22222198432149784)         /* 3FCC71C5 1D8E78AF */
var _Lg5 = float64(0.1818357216161805)          /* 3FC74664 96CB03DE */
var _Lg6 = float64(0.15313837699209373)         /* 3FC39A09 D078C69F */
var _Lg7 = float64(0.14798198605116586)

func x_log10(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var R Tdouble_t
	var dk Tdouble_t
	var f Tdouble_t
	var hfsq Tdouble_t
	var hi Tdouble_t
	var hx Tuint32_t
	var k int32
	var lo Tdouble_t
	var s Tdouble_t
	var t1 Tdouble_t
	var t2 Tdouble_t
	var val_hi Tdouble_t
	var val_lo Tdouble_t
	var w Tdouble_t
	var y Tdouble_t
	var z Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	k = int32(0)
	if hx < uint32(0x00100000) || hx>>int32(31) != 0 {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(1) == uint64(0) {
			return float64(-Int32FromInt32(1)) / (x * x)
		} /* log(+-0)=-inf */
		if hx>>int32(31) != 0 {
			return (x - x) / float64(0)
		} /* log(-#) = NaN */
		/* subnormal number, scale x up */
		k = k - Int32FromInt32(54)
		x = x * Float64FromFloat64(1.8014398509481984e+16)
		*(*float64)(unsafe.Pointer(bp)) = x
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	} else {
		if hx >= uint32(0x7ff00000) {
			return x
		} else {
			if hx == uint32(0x3ff00000) && *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(32) == uint64(0) {
				return Float64FromInt32(0)
			}
		}
	}
	/* reduce x into [sqrt(2)/2, sqrt(2)] */
	hx = hx + uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(0x3fe6a09e))
	k = k + (int32(hx>>Int32FromInt32(20)) - Int32FromInt32(0x3ff))
	hx = hx&uint32(0x000fffff) + uint32(0x3fe6a09e)
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(hx)<<int32(32) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(0xffffffff)
	x = *(*float64)(unsafe.Pointer(bp))
	f = x - float64(1)
	hfsq = float64(0.5) * f * f
	s = f / (Float64FromFloat64(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg2 + w*(_Lg4+w*_Lg6))
	t2 = z * (_Lg1 + w*(_Lg3+w*(_Lg5+w*_Lg7)))
	R = t2 + t1
	/* See log2.c for details. */
	/* hi+lo = f - hfsq + s*(hfsq+R) ~ log(1+f) */
	hi = f - hfsq
	*(*float64)(unsafe.Pointer(bp)) = hi
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) << Int32FromInt32(32))
	hi = *(*float64)(unsafe.Pointer(bp))
	lo = f - hi - hfsq + s*(hfsq+R)
	/* val_hi+val_lo ~ log10(1+f) + k*log10(2) */
	val_hi = hi * _ivln10hi
	dk = float64(k)
	y = dk * _log10_2hi
	val_lo = dk*_log10_2lo + (lo+hi)*_ivln10lo + lo*_ivln10hi
	/*
	 * Extra precision in for adding y is not strictly needed
	 * since there is no very large cancellation near x = sqrt(2) or
	 * x = 1/sqrt(2), but we do it anyway since it costs little on CPUs
	 * with some parallelism and it reduces the error for many args.
	 */
	w = y + val_hi
	val_lo = val_lo + (y - w + val_hi)
	val_hi = w
	return val_lo + val_hi
}

var _ivln10hi1 = float32(0.43432617188)                         /* 0x3ede6000 */
var _ivln10lo1 = float32(-Float64FromFloat64(3.1689971365e-05)) /* 0xb804ead9 */
var _log10_2hi1 = float32(0.30102920532)                        /* 0x3e9a2080 */
var _log10_2lo1 = float32(7.9034151668e-07)                     /* 0x355427db */
/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
var _Lg11 = float32(0.6666666269302368)  /* 0.66666662693 */
var _Lg21 = float32(0.40000972151756287) /* 0.40000972152 */
var _Lg31 = float32(0.2849878668785095)  /* 0.28498786688 */
var _Lg41 = float32(0.24279078841209412)

func x_log10f(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var R Tfloat_t
	var dk Tfloat_t
	var f Tfloat_t
	var hfsq Tfloat_t
	var hi Tfloat_t
	var ix Tuint32_t
	var k int32
	var lo Tfloat_t
	var s Tfloat_t
	var t1 Tfloat_t
	var t2 Tfloat_t
	var w Tfloat_t
	var z Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	k = int32(0)
	if ix < uint32(0x00800000) || ix>>int32(31) != 0 { /* x < 2**-126  */
		if ix<<int32(1) == uint32(0) {
			return float32(-Int32FromInt32(1)) / (x * x)
		} /* log(+-0)=-inf */
		if ix>>int32(31) != 0 {
			return (x - x) / Float32FromFloat32(0)
		} /* log(-#) = NaN */
		/* subnormal number, scale up x */
		k = k - Int32FromInt32(25)
		x = x * Float32FromFloat32(3.3554432e+07)
		*(*float32)(unsafe.Pointer(bp)) = x
		ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	} else {
		if ix >= uint32(0x7f800000) {
			return x
		} else {
			if ix == uint32(0x3f800000) {
				return Float32FromInt32(0)
			}
		}
	}
	/* reduce x into [sqrt(2)/2, sqrt(2)] */
	ix = ix + uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(0x3f3504f3))
	k = k + (int32(ix>>Int32FromInt32(23)) - Int32FromInt32(0x7f))
	ix = ix&uint32(0x007fffff) + uint32(0x3f3504f3)
	*(*Tuint32_t)(unsafe.Pointer(bp)) = ix
	x = *(*float32)(unsafe.Pointer(bp))
	f = x - Float32FromFloat32(1)
	s = f / (Float32FromFloat32(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg21 + w*_Lg41)
	t2 = z * (_Lg11 + w*_Lg31)
	R = t2 + t1
	hfsq = Float32FromFloat32(0.5) * f * f
	hi = f - hfsq
	*(*float32)(unsafe.Pointer(bp)) = hi
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromUint32(0xfffff000)
	hi = *(*float32)(unsafe.Pointer(bp))
	lo = f - hi - hfsq + s*(hfsq+R)
	dk = float32(k)
	return dk*_log10_2lo1 + (lo+hi)*_ivln10lo1 + lo*_ivln10hi1 + hi*_ivln10hi1 + dk*_log10_2hi1
}

var _ln2_hi2 = float64(0.6931471803691238)     /* 3fe62e42 fee00000 */
var _ln2_lo2 = float64(1.9082149292705877e-10) /* 3dea39ef 35793c76 */
var _Lg12 = float64(0.6666666666666735)        /* 3FE55555 55555593 */
var _Lg22 = float64(0.3999999999940942)        /* 3FD99999 9997FA04 */
var _Lg32 = float64(0.2857142874366239)        /* 3FD24924 94229359 */
var _Lg42 = float64(0.22222198432149784)       /* 3FCC71C5 1D8E78AF */
var _Lg51 = float64(0.1818357216161805)        /* 3FC74664 96CB03DE */
var _Lg61 = float64(0.15313837699209373)       /* 3FC39A09 D078C69F */
var _Lg71 = float64(0.14798198605116586)

func x_log1p(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var R Tdouble_t
	var c Tdouble_t
	var dk Tdouble_t
	var f Tdouble_t
	var hfsq Tdouble_t
	var hu Tuint32_t
	var hx Tuint32_t
	var k int32
	var s Tdouble_t
	var t1 Tdouble_t
	var t2 Tdouble_t
	var w Tdouble_t
	var z Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 float64
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	k = int32(1)
	if hx < uint32(0x3fda827a) || hx>>int32(31) != 0 { /* 1+x < sqrt(2)+ */
		if hx >= uint32(0xbff00000) {
			/* x <= -1.0 */
			if x == float64(-Int32FromInt32(1)) {
				return x / float64(0)
			} /* log1p(-1) = -inf */
			return (x - x) / float64(0) /* log1p(x<-1) = NaN */
		}
		if hx<<int32(1) < uint32(Int32FromInt32(0x3ca00000)<<Int32FromInt32(1)) {
			/* |x| < 2**-53 */
			/* underflow if subnormal */
			if hx&uint32(0x7ff00000) == uint32(0) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, float32(x))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(float32(x)))
						} else {
							_fp_force_evall(tls, float64(float32(x)))
						}
					}
				}
			}
			return x
		}
		if hx <= uint32(0xbfd2bec4) {
			/* sqrt(2)/2- <= 1+x < sqrt(2)+ */
			k = int32(0)
			c = Float64FromInt32(0)
			f = x
		}
	} else {
		if hx >= uint32(0x7ff00000) {
			return x
		}
	}
	if k != 0 {
		*(*float64)(unsafe.Pointer(bp)) = Float64FromInt32(1) + x
		hu = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
		hu = hu + uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(0x3fe6a09e))
		k = int32(hu>>Int32FromInt32(20)) - int32(0x3ff)
		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
		if k < int32(54) {
			if k >= int32(2) {
				v1 = Float64FromInt32(1) - (*(*float64)(unsafe.Pointer(bp)) - x)
			} else {
				v1 = x - (*(*float64)(unsafe.Pointer(bp)) - Float64FromInt32(1))
			}
			c = v1
			c = c / *(*float64)(unsafe.Pointer(bp))
		} else {
			c = Float64FromInt32(0)
		}
		/* reduce u into [sqrt(2)/2, sqrt(2)] */
		hu = hu&uint32(0x000fffff) + uint32(0x3fe6a09e)
		*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(hu)<<int32(32) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(0xffffffff)
		f = *(*float64)(unsafe.Pointer(bp)) - Float64FromInt32(1)
	}
	hfsq = float64(0.5) * f * f
	s = f / (Float64FromFloat64(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg22 + w*(_Lg42+w*_Lg61))
	t2 = z * (_Lg12 + w*(_Lg32+w*(_Lg51+w*_Lg71)))
	R = t2 + t1
	dk = float64(k)
	return s*(hfsq+R) + (dk*_ln2_lo2 + c) - hfsq + f + dk*_ln2_hi2
}

var _ln2_hi3 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo3 = float32(9.0580006145e-06) /* 0x3717f7d1 */
/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
var _Lg13 = float32(0.6666666269302368)  /* 0.66666662693 */
var _Lg23 = float32(0.40000972151756287) /* 0.40000972152 */
var _Lg33 = float32(0.2849878668785095)  /* 0.28498786688 */
var _Lg43 = float32(0.24279078841209412)

func x_log1pf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var R Tfloat_t
	var c Tfloat_t
	var dk Tfloat_t
	var f Tfloat_t
	var hfsq Tfloat_t
	var iu Tuint32_t
	var ix Tuint32_t
	var k int32
	var s Tfloat_t
	var t1 Tfloat_t
	var t2 Tfloat_t
	var w Tfloat_t
	var z Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v1 float32
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	k = int32(1)
	if ix < uint32(0x3ed413d0) || ix>>int32(31) != 0 { /* 1+x < sqrt(2)+  */
		if ix >= uint32(0xbf800000) {
			/* x <= -1.0 */
			if x == float32(-Int32FromInt32(1)) {
				return x / Float32FromFloat32(0)
			} /* log1p(-1)=+inf */
			return (x - x) / Float32FromFloat32(0) /* log1p(x<-1)=NaN */
		}
		if ix<<int32(1) < uint32(Int32FromInt32(0x33800000)<<Int32FromInt32(1)) {
			/* |x| < 2**-24 */
			/* underflow if subnormal */
			if ix&uint32(0x7f800000) == uint32(0) {
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, x*x)
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(x*x))
						} else {
							_fp_force_evall(tls, float64(x*x))
						}
					}
				}
			}
			return x
		}
		if ix <= uint32(0xbe95f619) {
			/* sqrt(2)/2- <= 1+x < sqrt(2)+ */
			k = int32(0)
			c = Float32FromInt32(0)
			f = x
		}
	} else {
		if ix >= uint32(0x7f800000) {
			return x
		}
	}
	if k != 0 {
		*(*float32)(unsafe.Pointer(bp)) = Float32FromInt32(1) + x
		iu = *(*Tuint32_t)(unsafe.Pointer(bp))
		iu = iu + uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(0x3f3504f3))
		k = int32(iu>>Int32FromInt32(23)) - int32(0x7f)
		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
		if k < int32(25) {
			if k >= int32(2) {
				v1 = Float32FromInt32(1) - (*(*float32)(unsafe.Pointer(bp)) - x)
			} else {
				v1 = x - (*(*float32)(unsafe.Pointer(bp)) - Float32FromInt32(1))
			}
			c = v1
			c = c / *(*float32)(unsafe.Pointer(bp))
		} else {
			c = Float32FromInt32(0)
		}
		/* reduce u into [sqrt(2)/2, sqrt(2)] */
		iu = iu&uint32(0x007fffff) + uint32(0x3f3504f3)
		*(*Tuint32_t)(unsafe.Pointer(bp)) = iu
		f = *(*float32)(unsafe.Pointer(bp)) - Float32FromInt32(1)
	}
	s = f / (Float32FromFloat32(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg23 + w*_Lg43)
	t2 = z * (_Lg13 + w*_Lg33)
	R = t2 + t1
	hfsq = Float32FromFloat32(0.5) * f * f
	dk = float32(k)
	return s*(hfsq+R) + (dk*_ln2_lo3 + c) - hfsq + f + dk*_ln2_hi3
}

const m_LOG2_POLY1_ORDER = 11
const m_LOG2_POLY_ORDER = 7
const m_LOG2_TABLE_BITS = 6

// C documentation
//
//	/* Top 16 bits of a double.  */
func _top161(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x})))) >> int32(48))
}

func x_log2(tls *TLS, x float64) (r1 float64) {
	var hi Tdouble_t
	var i int32
	var invc Tdouble_t
	var ix Tuint64_t
	var iz Tuint64_t
	var k int32
	var kd Tdouble_t
	var lo Tdouble_t
	var logc Tdouble_t
	var p Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var r4 Tdouble_t
	var rhi Tdouble_t
	var rhi1 Tdouble_t
	var rlo Tdouble_t
	var rlo1 Tdouble_t
	var t1 Tdouble_t
	var t2 Tdouble_t
	var t3 Tdouble_t
	var tmp Tuint64_t
	var top Tuint32_t
	var y Tdouble_t
	var z Tdouble_t
	ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x}))))
	top = _top161(tls, x)
	if ___builtin_expect(tls, BoolInt32(ix-*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) - Float64FromFloat64(0.04239702224731445)})))) < *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) + Float64FromFloat64(0.044274330139160156)}))))-*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: Float64FromFloat64(1) - Float64FromFloat64(0.04239702224731445)}))))), int32(0)) != 0 {
		/* Handle close to 1.0 inputs separately.  */
		/* Fix sign of zero with downward rounding when x==1.  */
		if int32(m_WANT_ROUNDING) != 0 && ___builtin_expect(tls, BoolInt32(ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: float64(1)}))))), int32(0)) != 0 {
			return Float64FromInt32(0)
		}
		r = x - float64(1)
		rhi = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: r})))) & (-Uint64FromUint64(1) << Int32FromInt32(32))}))))
		rlo = r - rhi
		hi = rhi * x___log2_data.Finvln2hi
		lo = rlo*x___log2_data.Finvln2hi + r*x___log2_data.Finvln2lo
		r2 = r * r /* rounding error: 0x1p-62.  */
		r4 = r2 * r2
		/* Worst-case error is less than 0.54 ULP (0.55 ULP without fma).  */
		p = r2 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(0)*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(1)*8)))
		y = hi + p
		lo = lo + (hi - y + p)
		lo = lo + r4*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(2)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(3)*8))+r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(4)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(5)*8)))+r4*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(6)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(7)*8))+r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(8)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly1)) + UintptrFromInt32(9)*8)))))
		y = y + lo
		return _eval_as_double(tls, y)
	}
	if ___builtin_expect(tls, BoolInt32(top-uint32(0x0010) >= uint32(Int32FromInt32(0x7ff0)-Int32FromInt32(0x0010))), int32(0)) != 0 {
		/* x < 0x1p-1022 or inf or nan.  */
		if ix*uint64(2) == uint64(0) {
			return x___math_divzero(tls, uint32(1))
		}
		if ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: float64(___builtin_inff(tls))})))) { /* log(inf) == inf.  */
			return x
		}
		if top&uint32(0x8000) != 0 || top&uint32(0x7ff0) == uint32(0x7ff0) {
			return x___math_invalid(tls, x)
		}
		/* x is subnormal, normalize it.  */
		ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x * float64(4.503599627370496e+15)}))))
		ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(m_OFF)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(m_LOG2_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(m_LOG2_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Ftab)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Ftab)) + uintptr(i)*16))).Flogc
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: iz}))))
	kd = float64(k)
	/* log2(x) = log2(z/c) + log2(c) + k.  */
	/* r ~= z/c - 1, |r| < 1/(2*N).  */
	/* rounding error: 0x1p-55/N + 0x1p-65.  */
	r = (z - (*(*struct {
		Fchi float64
		Fclo float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Ftab2)) + uintptr(i)*16))).Fchi - (*(*struct {
		Fchi float64
		Fclo float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Ftab2)) + uintptr(i)*16))).Fclo) * invc
	rhi1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: r})))) & (-Uint64FromUint64(1) << Int32FromInt32(32))}))))
	rlo1 = r - rhi1
	t1 = rhi1 * x___log2_data.Finvln2hi
	t2 = rlo1*x___log2_data.Finvln2hi + r*x___log2_data.Finvln2lo
	/* hi + lo = r/ln2 + log2(c) + k.  */
	t3 = kd + logc
	hi = t3 + t1
	lo = t3 - hi + t1 + t2
	/* log2(r+1) = r/ln2 + r^2*poly(r).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r /* rounding error: 0x1p-54/N^2.  */
	r4 = r2 * r2
	/* Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).
	   ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).  */
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(0)*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(1)*8)) + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(2)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(3)*8))) + r4*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(4)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2_data.Fpoly)) + UintptrFromInt32(5)*8)))
	y = lo + r2*p + hi
	return _eval_as_double(tls, y)
}

type Tlog2_data = struct {
	Finvln2hi float64
	Finvln2lo float64
	Fpoly     [6]float64
	Fpoly1    [10]float64
	Ftab      [64]struct {
		Finvc float64
		Flogc float64
	}
	Ftab2 [64]struct {
		Fchi float64
		Fclo float64
	}
}

const m_LOG2F_POLY_ORDER = 4
const m_LOG2F_TABLE_BITS = 4
const m_OFF1 = 1060306944

func x_log2f(tls *TLS, x float32) (r1 float32) {
	var i int32
	var invc Tdouble_t
	var ix Tuint32_t
	var iz Tuint32_t
	var k int32
	var logc Tdouble_t
	var p Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var tmp Tuint32_t
	var top Tuint32_t
	var y Tdouble_t
	var y0 Tdouble_t
	var z Tdouble_t
	ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: x}))))
	/* Fix sign of zero with downward rounding when x==1.  */
	if int32(m_WANT_ROUNDING) != 0 && ___builtin_expect(tls, BoolInt32(ix == uint32(0x3f800000)), int32(0)) != 0 {
		return Float32FromInt32(0)
	}
	if ___builtin_expect(tls, BoolInt32(ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000))), int32(0)) != 0 {
		/* x < 0x1p-126 or inf or nan.  */
		if ix*uint32(2) == uint32(0) {
			return x___math_divzerof(tls, uint32(1))
		}
		if ix == uint32(0x7f800000) { /* log2(inf) == inf.  */
			return x
		}
		if ix&uint32(0x80000000) != 0 || ix*uint32(2) >= uint32(0xff000000) {
			return x___math_invalidf(tls, x)
		}
		/* x is subnormal, normalize it.  */
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x * Float32FromFloat32(8.388608e+06)}))))
		ix = ix - uint32(Int32FromInt32(23)<<Int32FromInt32(23))
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(m_OFF1)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(m_LOG2F_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(m_LOG2F_TABLE_BITS)))
	top = tmp & uint32(0xff800000)
	iz = ix - top
	k = int32(tmp) >> int32(23) /* arithmetic shift */
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Ftab)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Ftab)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float32
		F_i Tuint32_t
	}{F_i: iz})))))
	/* log2(x) = log1p(z/c-1)/ln2 + log2(c) + k */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)
	/* Pipelined polynomial evaluation to approximate log1p(r)/ln2.  */
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Fpoly)) + UintptrFromInt32(1)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Fpoly)) + UintptrFromInt32(2)*8))
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Fpoly)) + UintptrFromInt32(0)*8))*r2 + y
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___log2f_data.Fpoly)) + UintptrFromInt32(3)*8))*r + y0
	y = y*r2 + p
	return _eval_as_float(tls, float32(y))
}

type Tlog2f_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fpoly [4]float64
}

type Tlog_data = struct {
	Fln2hi float64
	Fln2lo float64
	Fpoly  [5]float64
	Fpoly1 [11]float64
	Ftab   [128]struct {
		Finvc float64
		Flogc float64
	}
	Ftab2 [128]struct {
		Fchi float64
		Fclo float64
	}
}

func x_logb(tls *TLS, x float64) (r float64) {
	if !(BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		return x * x
	}
	if x == Float64FromInt32(0) {
		return float64(-Int32FromInt32(1)) / (x * x)
	}
	return float64(x_ilogb(tls, x))
}

func x_logbf(tls *TLS, x float32) (r float32) {
	if !(BoolInt32(___FLOAT_BITS(tls, x)&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		return x * x
	}
	if x == Float32FromInt32(0) {
		return float32(-Int32FromInt32(1)) / (x * x)
	}
	return float32(x_ilogbf(tls, x))
}

func x_logbl(tls *TLS, x float64) (r float64) {
	if !(BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		return x * x
	}
	if x == Float64FromInt32(0) {
		return float64(-Int32FromInt32(1)) / (x * x)
	}
	return float64(x_ilogbl(tls, x))
}

const m_LOGF_POLY_ORDER = 4
const m_LOGF_TABLE_BITS = 4

func x_logf(tls *TLS, x float32) (r1 float32) {
	var i int32
	var invc Tdouble_t
	var ix Tuint32_t
	var iz Tuint32_t
	var k int32
	var logc Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var tmp Tuint32_t
	var y Tdouble_t
	var y0 Tdouble_t
	var z Tdouble_t
	ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: x}))))
	/* Fix sign of zero with downward rounding when x==1.  */
	if int32(m_WANT_ROUNDING) != 0 && ___builtin_expect(tls, BoolInt32(ix == uint32(0x3f800000)), int32(0)) != 0 {
		return Float32FromInt32(0)
	}
	if ___builtin_expect(tls, BoolInt32(ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000))), int32(0)) != 0 {
		/* x < 0x1p-126 or inf or nan.  */
		if ix*uint32(2) == uint32(0) {
			return x___math_divzerof(tls, uint32(1))
		}
		if ix == uint32(0x7f800000) { /* log(inf) == inf.  */
			return x
		}
		if ix&uint32(0x80000000) != 0 || ix*uint32(2) >= uint32(0xff000000) {
			return x___math_invalidf(tls, x)
		}
		/* x is subnormal, normalize it.  */
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x * Float32FromFloat32(8.388608e+06)}))))
		ix = ix - uint32(Int32FromInt32(23)<<Int32FromInt32(23))
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(m_OFF1)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(m_LOGF_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(m_LOGF_TABLE_BITS)))
	k = int32(tmp) >> int32(23) /* arithmetic shift */
	iz = ix - tmp&uint32(0xff800000)
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___logf_data.Ftab)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___logf_data.Ftab)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float32
		F_i Tuint32_t
	}{F_i: iz})))))
	/* log(x) = log1p(z/c-1) + log(c) + k*Ln2 */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)*x___logf_data.Fln2
	/* Pipelined polynomial evaluation to approximate log1p(r).  */
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___logf_data.Fpoly)) + UintptrFromInt32(1)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___logf_data.Fpoly)) + UintptrFromInt32(2)*8))
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___logf_data.Fpoly)) + UintptrFromInt32(0)*8))*r2 + y
	y = y*r2 + (y0 + r)
	return _eval_as_float(tls, float32(y))
}

type Tlogf_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fln2  float64
	Fpoly [3]float64
}

func x_lround(tls *TLS, x float64) (r int64) {
	return int64(x_round(tls, x))
}

func x_lroundf(tls *TLS, x float32) (r int64) {
	return int64(x_roundf(tls, x))
}

func x_lroundl(tls *TLS, x float64) (r int64) {
	return int64(x_roundl(tls, x))
}

func x_modf(tls *TLS, x float64, iptr uintptr) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var mask Tuint64_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp))>>Int32FromInt32(52)&Uint64FromInt32(0x7ff)) - int32(0x3ff)
	/* no fractional part */
	if e >= int32(52) {
		*(*float64)(unsafe.Pointer(iptr)) = x
		if e == int32(0x400) && *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(12) != uint64(0) { /* nan */
			return x
		}
		p1 = bp
		*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		return *(*float64)(unsafe.Pointer(bp))
	}
	/* no integral part*/
	if e < int32(0) {
		p2 = bp
		*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
		return x
	}
	mask = -Uint64FromUint64(1) >> Int32FromInt32(12) >> e
	if *(*Tuint64_t)(unsafe.Pointer(bp))&mask == uint64(0) {
		*(*float64)(unsafe.Pointer(iptr)) = x
		p3 = bp
		*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		return *(*float64)(unsafe.Pointer(bp))
	}
	p4 = bp
	*(*Tuint64_t)(unsafe.Pointer(p4)) = *(*Tuint64_t)(unsafe.Pointer(p4)) & ^mask
	*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
	return x - *(*float64)(unsafe.Pointer(bp))
}

func x_modff(tls *TLS, x float32, iptr uintptr) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var mask Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	/* no fractional part */
	if e >= int32(23) {
		*(*float32)(unsafe.Pointer(iptr)) = x
		if e == int32(0x80) && *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(9) != uint32(0) {
			/* nan */
			return x
		}
		p1 = bp
		*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromUint32(0x80000000)
		return *(*float32)(unsafe.Pointer(bp))
	}
	/* no integral part */
	if e < int32(0) {
		p2 = bp
		*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) & Uint32FromUint32(0x80000000)
		*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp))
		return x
	}
	mask = uint32(int32(0x007fffff) >> e)
	if *(*Tuint32_t)(unsafe.Pointer(bp))&mask == uint32(0) {
		*(*float32)(unsafe.Pointer(iptr)) = x
		p3 = bp
		*(*Tuint32_t)(unsafe.Pointer(p3)) = *(*Tuint32_t)(unsafe.Pointer(p3)) & Uint32FromUint32(0x80000000)
		return *(*float32)(unsafe.Pointer(bp))
	}
	p4 = bp
	*(*Tuint32_t)(unsafe.Pointer(p4)) = *(*Tuint32_t)(unsafe.Pointer(p4)) & ^mask
	*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp))
	return x - *(*float32)(unsafe.Pointer(bp))
}

func x_modfl(tls *TLS, x float64, iptr uintptr) (r1 float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r float64
	var _ /* d at bp+0 */ float64
	r = x_modf(tls, x, bp)
	*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
	return r
}

func x_nan(tls *TLS, s uintptr) (r float64) {
	return float64(___builtin_nanf(tls, ts))
}

func x_nanf(tls *TLS, s uintptr) (r float32) {
	return ___builtin_nanf(tls, ts)
}

func x_nanl(tls *TLS, s uintptr) (r float64) {
	return float64(___builtin_nanf(tls, ts))
}

const m_FE_INEXACT = 32

func x_nearbyint(tls *TLS, x float64) (r float64) {
	var e int32
	e = _fetestexcept(tls, int32(m_FE_INEXACT))
	x = x_rint(tls, x)
	if !(e != 0) {
		_feclearexcept(tls, int32(m_FE_INEXACT))
	}
	return x
}

func x_nearbyintf(tls *TLS, x float32) (r float32) {
	var e int32
	e = _fetestexcept(tls, int32(m_FE_INEXACT))
	x = x_rintf(tls, x)
	if !(e != 0) {
		_feclearexcept(tls, int32(m_FE_INEXACT))
	}
	return x
}

func x_nearbyintl(tls *TLS, x float64) (r float64) {
	return x_nearbyint(tls, x)
}

func x_nextafter(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ax Tuint64_t
	var ay Tuint64_t
	var e int32
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x + y
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp)) == *(*Tuint64_t)(unsafe.Pointer(bp + 8)) {
		return y
	}
	ax = *(*Tuint64_t)(unsafe.Pointer(bp)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	ay = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	if ax == uint64(0) {
		if ay == uint64(0) {
			return y
		}
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8))&(Uint64FromUint64(1)<<Int32FromInt32(63)) | uint64(1)
	} else {
		if ax > ay || (*(*Tuint64_t)(unsafe.Pointer(bp))^*(*Tuint64_t)(unsafe.Pointer(bp + 8)))&(Uint64FromUint64(1)<<Int32FromInt32(63)) != 0 {
			*(*Tuint64_t)(unsafe.Pointer(bp))--
		} else {
			*(*Tuint64_t)(unsafe.Pointer(bp))++
		}
	}
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	/* raise overflow if ux.f is infinite and x is finite */
	if e == int32(0x7ff) {
		{
			if uint64(8) == uint64(4) {
				_fp_force_evalf(tls, float32(x+x))
			} else {
				if uint64(8) == uint64(8) {
					_fp_force_eval(tls, x+x)
				} else {
					_fp_force_evall(tls, x+x)
				}
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == int32(0) {
		{
			if uint64(8) == uint64(4) {
				_fp_force_evalf(tls, float32(x*x+*(*float64)(unsafe.Pointer(bp))**(*float64)(unsafe.Pointer(bp))))
			} else {
				if uint64(8) == uint64(8) {
					_fp_force_eval(tls, x*x+*(*float64)(unsafe.Pointer(bp))**(*float64)(unsafe.Pointer(bp)))
				} else {
					_fp_force_evall(tls, x*x+*(*float64)(unsafe.Pointer(bp))**(*float64)(unsafe.Pointer(bp)))
				}
			}
		}
	}
	return *(*float64)(unsafe.Pointer(bp))
}

func x_nextafterf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ax Tuint32_t
	var ay Tuint32_t
	var e Tuint32_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x + y
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp)) == *(*Tuint32_t)(unsafe.Pointer(bp + 4)) {
		return y
	}
	ax = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	ay = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) & uint32(0x7fffffff)
	if ax == uint32(0) {
		if ay == uint32(0) {
			return y
		}
		*(*Tuint32_t)(unsafe.Pointer(bp)) = *(*Tuint32_t)(unsafe.Pointer(bp + 4))&uint32(0x80000000) | uint32(1)
	} else {
		if ax > ay || (*(*Tuint32_t)(unsafe.Pointer(bp))^*(*Tuint32_t)(unsafe.Pointer(bp + 4)))&uint32(0x80000000) != 0 {
			*(*Tuint32_t)(unsafe.Pointer(bp))--
		} else {
			*(*Tuint32_t)(unsafe.Pointer(bp))++
		}
	}
	e = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7f800000)
	/* raise overflow if ux.f is infinite and x is finite */
	if e == uint32(0x7f800000) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+x)
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+x))
				} else {
					_fp_force_evall(tls, float64(x+x))
				}
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == uint32(0) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp)))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp))))
				} else {
					_fp_force_evall(tls, float64(x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp))))
				}
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func x_nextafterl(tls *TLS, x float64, y float64) (r float64) {
	return x_nextafter(tls, x, y)
}

func x_nexttoward(tls *TLS, x float64, y float64) (r float64) {
	return x_nextafter(tls, x, y)
}

func x_nexttowardf(tls *TLS, x float32, y float64) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e Tuint32_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return float32(float64(x) + y)
	}
	if float64(x) == y {
		return float32(y)
	}
	if x == Float32FromInt32(0) {
		*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32(1)
		if int32(___DOUBLE_BITS(tls, y)>>Int32FromInt32(63)) != 0 {
			p1 = bp
			*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) | Uint32FromUint32(0x80000000)
		}
	} else {
		if float64(x) < y {
			if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != 0 {
				*(*Tuint32_t)(unsafe.Pointer(bp))--
			} else {
				*(*Tuint32_t)(unsafe.Pointer(bp))++
			}
		} else {
			if int32(___FLOAT_BITS(tls, x)>>Int32FromInt32(31)) != 0 {
				*(*Tuint32_t)(unsafe.Pointer(bp))++
			} else {
				*(*Tuint32_t)(unsafe.Pointer(bp))--
			}
		}
	}
	e = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7f800000)
	/* raise overflow if ux.f is infinite and x is finite */
	if e == uint32(0x7f800000) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+x)
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+x))
				} else {
					_fp_force_evall(tls, float64(x+x))
				}
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == uint32(0) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp)))
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp))))
				} else {
					_fp_force_evall(tls, float64(x*x+*(*float32)(unsafe.Pointer(bp))**(*float32)(unsafe.Pointer(bp))))
				}
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func x_nexttowardl(tls *TLS, x float64, y float64) (r float64) {
	return x_nextafterl(tls, x, y)
}

const m_OFF2 = 4604531861337669632
const m_POW_LOG_POLY_ORDER = 8
const m_POW_LOG_TABLE_BITS = 7

/*
Worst-case error: 0.54 ULP (~= ulperr_exp + 1024*Ln2*relerr_log*2^53)
relerr_log: 1.3 * 2^-68 (Relative error of log, 1.5 * 2^-68 without fma)
ulperr_exp: 0.509 ULP (ULP error of exp, 0.511 ULP without fma)
*/

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top124(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x})))) >> int32(52))
}

// C documentation
//
//	/* Compute y+TAIL = log(x) where the rounded result is y and TAIL has about
//	   additional 15 bits precision.  IX is the bit representation of x, but
//	   normalized in the subnormal range using the sign bit for the exponent.  */
func _log_inline(tls *TLS, ix Tuint64_t, tail uintptr) (r1 Tdouble_t) {
	var ar Tdouble_t
	var ar2 Tdouble_t
	var ar3 Tdouble_t
	var arhi Tdouble_t
	var arhi2 Tdouble_t
	var hi Tdouble_t
	var i int32
	var invc Tdouble_t
	var iz Tuint64_t
	var k int32
	var kd Tdouble_t
	var lo Tdouble_t
	var lo1 Tdouble_t
	var lo2 Tdouble_t
	var lo3 Tdouble_t
	var lo4 Tdouble_t
	var logc Tdouble_t
	var logctail Tdouble_t
	var p Tdouble_t
	var r Tdouble_t
	var rhi Tdouble_t
	var rlo Tdouble_t
	var t1 Tdouble_t
	var t2 Tdouble_t
	var tmp Tuint64_t
	var y Tdouble_t
	var z Tdouble_t
	var zhi Tdouble_t
	var zlo Tdouble_t
	/* double_t for better performance on targets with FLT_EVAL_METHOD==2.  */
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(m_OFF2)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(m_POW_LOG_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(m_POW_LOG_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: iz}))))
	kd = float64(k)
	/* log(x) = k*Ln2 + log(c) + log1p(z/c-1).  */
	invc = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Ftab)) + uintptr(i)*32))).Finvc
	logc = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Ftab)) + uintptr(i)*32))).Flogc
	logctail = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Ftab)) + uintptr(i)*32))).Flogctail
	/* Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and
	   |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.  */
	/* Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.  */
	zhi = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: (iz + Uint64FromUint64(1)<<Int32FromInt32(31)) & (-Uint64FromUint64(1) << Int32FromInt32(32))}))))
	zlo = z - zhi
	rhi = zhi*invc - float64(1)
	rlo = zlo * invc
	r = rhi + rlo
	/* k*Ln2 + log(c) + r.  */
	t1 = kd*x___pow_log_data.Fln2hi + logc
	t2 = t1 + r
	lo1 = kd*x___pow_log_data.Fln2lo + logctail
	lo2 = t1 - t2 + r
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	ar = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(0)*8)) * r /* A[0] = -0.5.  */
	ar2 = r * ar
	ar3 = r * ar2
	/* k*Ln2 + log(c) + r + A[0]*r*r.  */
	arhi = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(0)*8)) * rhi
	arhi2 = rhi * arhi
	hi = t2 + arhi2
	lo3 = rlo * (ar + arhi)
	lo4 = t2 - hi + arhi2
	/* p = log1p(r) - r - A[0]*r*r.  */
	p = ar3 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(1)*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(2)*8)) + ar2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(3)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(4)*8))+ar2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(5)*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___pow_log_data.Fpoly)) + UintptrFromInt32(6)*8)))))
	lo = lo1 + lo2 + lo3 + lo4 + p
	y = hi + lo
	*(*Tdouble_t)(unsafe.Pointer(tail)) = hi - y + lo
	return y
}

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase2(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi Tdouble_t
	var lo Tdouble_t
	var one Tdouble_t
	var scale Tdouble_t
	var y Tdouble_t
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by <= 460.  */
		sbits = sbits - Uint64FromUint64(1009)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_f [0]float64
			F_i Tuint64_t
		}{F_i: sbits}))))
		y = float64(5.486124068793689e+303) * (scale + scale*tmp)
		return _eval_as_double(tls, y)
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	/* Note: sbits is signed scale.  */
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	y = scale + scale*tmp
	if x_fabs(tls, y) < float64(1) {
		/* Round y to the right precision before scaling it into the subnormal
		   range to avoid double rounding that can cause 0.5+E/2 ulp error where
		   E is the worst-case ulp error outside the subnormal range.  So this
		   is only useful if the goal is better than 1 ulp worst-case error.  */
		one = float64(1)
		if y < float64(0) {
			one = -Float64FromFloat64(1)
		}
		lo = scale - y + scale*tmp
		hi = one + y
		lo = one - hi + y + lo
		y = _eval_as_double(tls, hi+lo) - one
		/* Fix the sign of 0.  */
		if y == float64(0) {
			y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_f [0]float64
				F_i Tuint64_t
			}{F_i: sbits & uint64(0x8000000000000000)}))))
		}
		/* The underflow exception needs to be signaled explicitly.  */
		_fp_force_eval(tls, _fp_barrier(tls, float64(2.2250738585072014e-308))*float64(2.2250738585072014e-308))
	}
	y = float64(2.2250738585072014e-308) * y
	return _eval_as_double(tls, y)
}

// C documentation
//
//	/* Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.
//	   The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.  */
func _exp_inline(tls *TLS, x Tdouble_t, xtail Tdouble_t, sign_bias Tuint32_t) (r1 float64) {
	var abstop Tuint32_t
	var idx Tuint64_t
	var kd Tdouble_t
	var ki Tuint64_t
	var one Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var sbits Tuint64_t
	var scale Tdouble_t
	var tail Tdouble_t
	var tmp Tdouble_t
	var top Tuint64_t
	var z Tdouble_t
	var v1 Tdouble_t
	/* double_t for better performance on targets with FLT_EVAL_METHOD==2.  */
	abstop = _top124(tls, x) & uint32(0x7ff)
	if ___builtin_expect(tls, BoolInt32(abstop-_top124(tls, float64(5.551115123125783e-17)) >= _top124(tls, float64(512))-_top124(tls, float64(5.551115123125783e-17))), int32(0)) != 0 {
		if abstop-_top124(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			one = float64(1) + x
			if sign_bias != 0 {
				v1 = -one
			} else {
				v1 = one
			}
			return v1
		}
		if abstop >= _top124(tls, float64(1024)) {
			/* Note: inf and nan are already handled.  */
			if *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x}))))>>int32(63) != 0 {
				return x___math_uflow(tls, sign_bias)
			} else {
				return x___math_oflow(tls, sign_bias)
			}
		}
		/* Large x is special cased below.  */
		abstop = uint32(0)
	}
	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].  */
	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].  */
	z = x___exp_data.Finvln2N * x
	/* z - kd is in [-1, 1] in non-nearest rounding modes.  */
	kd = _eval_as_double(tls, z+x___exp_data.Fshift)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd}))))
	kd = kd - x___exp_data.Fshift
	r = x + kd*x___exp_data.Fnegln2hiN + kd*x___exp_data.Fnegln2loN
	/* The code assumes 2^-200 < |xtail| < 2^-8/N.  */
	r = r + xtail
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP_TABLE_BITS)))
	top = (ki + uint64(sign_bias)) << (Int32FromInt32(52) - Int32FromInt32(m_EXP_TABLE_BITS))
	tail = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx)*8))}))))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Ftab)) + uintptr(idx+Uint64FromInt32(1))*8)) + top
	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.25/N ulp larger.  */
	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(5)-Int32FromInt32(m_EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(6)-Int32FromInt32(m_EXP_POLY_ORDER))*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(7)-Int32FromInt32(m_EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp_data.Fpoly)) + uintptr(Int32FromInt32(8)-Int32FromInt32(m_EXP_POLY_ORDER))*8)))
	if ___builtin_expect(tls, BoolInt32(abstop == uint32(0)), int32(0)) != 0 {
		return _specialcase2(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: sbits}))))
	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
	   is no spurious underflow here even without fma.  */
	return _eval_as_double(tls, scale+scale*tmp)
}

// C documentation
//
//	/* Returns 0 if not int, 1 if odd int, 2 if even int.  The argument is
//	   the bit representation of a non-zero finite floating-point value.  */
func _checkint(tls *TLS, iy Tuint64_t) (r int32) {
	var e int32
	e = int32(iy >> int32(52) & uint64(0x7ff))
	if e < int32(0x3ff) {
		return int32(0)
	}
	if e > Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return int32(2)
	}
	if iy&(uint64(1)<<(Int32FromInt32(0x3ff)+Int32FromInt32(52)-e)-uint64(1)) != 0 {
		return int32(0)
	}
	if iy&(uint64(1)<<(Int32FromInt32(0x3ff)+Int32FromInt32(52)-e)) != 0 {
		return int32(1)
	}
	return int32(2)
}

// C documentation
//
//	/* Returns 1 if input is the bit representation of 0, infinity or nan.  */
func _zeroinfnan(tls *TLS, i Tuint64_t) (r int32) {
	return BoolInt32(uint64(2)*i-uint64(1) >= uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: float64(___builtin_inff(tls))}))))-uint64(1))
}

func x_pow(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ehi Tdouble_t
	var elo Tdouble_t
	var hi Tdouble_t
	var ix Tuint64_t
	var iy Tuint64_t
	var lhi Tdouble_t
	var llo Tdouble_t
	var sign_bias Tuint32_t
	var topx Tuint32_t
	var topy Tuint32_t
	var x2 Tdouble_t
	var yhi Tdouble_t
	var yint int32
	var ylo Tdouble_t
	var _ /* lo at bp+0 */ Tdouble_t
	var v1 float64
	var v2 float64
	var v3 float64
	sign_bias = uint32(0)
	ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: x}))))
	iy = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: y}))))
	topx = _top124(tls, x)
	topy = _top124(tls, y)
	if ___builtin_expect(tls, BoolInt32(topx-uint32(0x001) >= uint32(Int32FromInt32(0x7ff)-Int32FromInt32(0x001)) || topy&uint32(0x7ff)-uint32(0x3be) >= uint32(Int32FromInt32(0x43e)-Int32FromInt32(0x3be))), int32(0)) != 0 {
		/* Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0
		   and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.  */
		/* Special cases: (x < 0x1p-126 or inf or nan) or
		   (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).  */
		if ___builtin_expect(tls, _zeroinfnan(tls, iy), int32(0)) != 0 {
			if uint64(2)*iy == uint64(0) {
				return float64(1)
			}
			if ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(1)})))) {
				return float64(1)
			}
			if uint64(2)*ix > uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(___builtin_inff(tls))})))) || uint64(2)*iy > uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(___builtin_inff(tls))})))) {
				return x + y
			}
			if uint64(2)*ix == uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(1)})))) {
				return float64(1)
			}
			if BoolInt32(uint64(2)*ix < uint64(2)**(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(1)}))))) == BoolInt32(!(iy>>Int32FromInt32(63) != 0)) {
				return float64(0)
			} /* |x|<1 && y==inf or |x|>1 && y==-inf.  */
			return y * y
		}
		if ___builtin_expect(tls, _zeroinfnan(tls, ix), int32(0)) != 0 {
			x2 = x * x
			if ix>>int32(63) != 0 && _checkint(tls, iy) == int32(1) {
				x2 = -x2
			}
			/* Without the barrier some versions of clang hoist the 1/x2 and
			   thus division by zero exception can be signaled spuriously.  */
			if iy>>int32(63) != 0 {
				v1 = _fp_barrier(tls, Float64FromInt32(1)/x2)
			} else {
				v1 = x2
			}
			return v1
		}
		/* Here x and y are non-zero finite.  */
		if ix>>int32(63) != 0 {
			/* Finite x < 0.  */
			yint = _checkint(tls, iy)
			if yint == int32(0) {
				return x___math_invalid(tls, x)
			}
			if yint == int32(1) {
				sign_bias = uint32(Int32FromInt32(0x800) << Int32FromInt32(m_EXP_TABLE_BITS))
			}
			ix = ix & Uint64FromInt64(0x7fffffffffffffff)
			topx = topx & Uint32FromInt32(0x7ff)
		}
		if topy&uint32(0x7ff)-uint32(0x3be) >= uint32(Int32FromInt32(0x43e)-Int32FromInt32(0x3be)) {
			/* Note: sign_bias == 0 here because y is not odd.  */
			if ix == *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(1)})))) {
				return float64(1)
			}
			if topy&uint32(0x7ff) < uint32(0x3be) {
				/* |y| < 2^-65, x^y ~= 1 + y*log(x).  */
				if int32(m_WANT_ROUNDING) != 0 {
					if ix > *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
						F_i [0]Tuint64_t
						F_f float64
					}{F_f: float64(1)})))) {
						v2 = float64(1) + y
					} else {
						v2 = float64(1) - y
					}
					return v2
				} else {
					return float64(1)
				}
			}
			if BoolInt32(ix > *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: float64(1)}))))) == BoolInt32(topy < uint32(0x800)) {
				v3 = x___math_oflow(tls, uint32(0))
			} else {
				v3 = x___math_uflow(tls, uint32(0))
			}
			return v3
		}
		if topx == uint32(0) {
			/* Normalize subnormal x so exponent becomes negative.  */
			ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint64_t
				F_f float64
			}{F_f: x * float64(4.503599627370496e+15)}))))
			ix = ix & Uint64FromInt64(0x7fffffffffffffff)
			ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
		}
	}
	hi = _log_inline(tls, ix, bp)
	yhi = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: iy & (-Uint64FromUint64(1) << Int32FromInt32(27))}))))
	ylo = y - yhi
	lhi = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: hi})))) & (-Uint64FromUint64(1) << Int32FromInt32(27))}))))
	llo = hi - lhi + *(*Tdouble_t)(unsafe.Pointer(bp))
	ehi = yhi * lhi
	elo = ylo*lhi + y*llo /* |elo| < |ehi| * 2^-25.  */
	return _exp_inline(tls, ehi, elo, sign_bias)
}

type Tpow_log_data = struct {
	Fln2hi float64
	Fln2lo float64
	Fpoly  [7]float64
	Ftab   [128]struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	}
}

const m_OFF3 = 1060306944
const m_POWF_LOG2_POLY_ORDER = 5
const m_POWF_LOG2_TABLE_BITS = 4
const m_POWF_SCALE_BITS = 0

/*
POWF_LOG2_POLY_ORDER = 5
EXP2F_TABLE_BITS = 5

ULP error: 0.82 (~ 0.5 + relerr*2^24)
relerr: 1.27 * 2^-26 (Relative error ~= 128*Ln2*relerr_log2 + relerr_exp2)
relerr_log2: 1.83 * 2^-33 (Relative error of logx.)
relerr_exp2: 1.69 * 2^-34 (Relative error of exp2(ylogx).)
*/

// C documentation
//
//	/* Subnormal input is normalized so ix has negative biased exponent.
//	   Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.  */
func _log2_inline(tls *TLS, ix Tuint32_t) (r1 Tdouble_t) {
	var i int32
	var invc Tdouble_t
	var iz Tuint32_t
	var k int32
	var logc Tdouble_t
	var p Tdouble_t
	var q Tdouble_t
	var r Tdouble_t
	var r2 Tdouble_t
	var r4 Tdouble_t
	var tmp Tuint32_t
	var top Tuint32_t
	var y Tdouble_t
	var y0 Tdouble_t
	var z Tdouble_t
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(m_OFF3)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(m_POWF_LOG2_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(m_POWF_LOG2_TABLE_BITS)))
	top = tmp & uint32(0xff800000)
	iz = ix - top
	k = int32(top) >> (Int32FromInt32(23) - Int32FromInt32(m_POWF_SCALE_BITS)) /* arithmetic shift */
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Ftab)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Ftab)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float32
		F_i Tuint32_t
	}{F_i: iz})))))
	/* log2(x) = log1p(z/c-1)/ln2 + log2(c) + k */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)
	/* Pipelined polynomial evaluation to approximate log1p(r)/ln2.  */
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Fpoly)) + UintptrFromInt32(0)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Fpoly)) + UintptrFromInt32(1)*8))
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Fpoly)) + UintptrFromInt32(2)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Fpoly)) + UintptrFromInt32(3)*8))
	r4 = r2 * r2
	q = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___powf_log2_data.Fpoly)) + UintptrFromInt32(4)*8))*r + y0
	q = p*r2 + q
	y = y*r4 + q
	return y
}

// C documentation
//
//	/* The output of log2 and thus the input of exp2 is either scaled by N
//	   (in case of fast toint intrinsics) or not.  The unscaled xd must be
//	   in [-1021,1023], sign_bias sets the sign of the result.  */
func _exp2_inline(tls *TLS, xd Tdouble_t, sign_bias Tuint32_t) (r1 float32) {
	var kd Tdouble_t
	var ki Tuint64_t
	var r Tdouble_t
	var r2 Tdouble_t
	var s Tdouble_t
	var ski Tuint64_t
	var t Tuint64_t
	var y Tdouble_t
	var z Tdouble_t
	/* x = k/N + r with r in [-1/(2N), 1/(2N)] */
	kd = _eval_as_double(tls, xd+x___exp2f_data.Fshift_scaled)
	ki = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: kd}))))
	kd = kd - x___exp2f_data.Fshift_scaled /* k/N */
	r = xd - kd
	/* exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Ftab)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)))*8))
	ski = ki + uint64(sign_bias)
	t = t + ski<<(Int32FromInt32(52)-Int32FromInt32(m_EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_f [0]float64
		F_i Tuint64_t
	}{F_i: t}))))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(0)*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(1)*8))
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___exp2f_data.Fpoly)) + UintptrFromInt32(2)*8))*r + Float64FromInt32(1)
	y = z*r2 + y
	y = y * s
	return _eval_as_float(tls, float32(y))
}

// C documentation
//
//	/* Returns 0 if not int, 1 if odd int, 2 if even int.  The argument is
//	   the bit representation of a non-zero finite floating-point value.  */
func _checkint1(tls *TLS, iy Tuint32_t) (r int32) {
	var e int32
	e = int32(iy >> int32(23) & uint32(0xff))
	if e < int32(0x7f) {
		return int32(0)
	}
	if e > Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return int32(2)
	}
	if iy&uint32(Int32FromInt32(1)<<(Int32FromInt32(0x7f)+Int32FromInt32(23)-e)-Int32FromInt32(1)) != 0 {
		return int32(0)
	}
	if iy&uint32(Int32FromInt32(1)<<(Int32FromInt32(0x7f)+Int32FromInt32(23)-e)) != 0 {
		return int32(1)
	}
	return int32(2)
}

func _zeroinfnan1(tls *TLS, ix Tuint32_t) (r int32) {
	return BoolInt32(uint32(2)*ix-uint32(1) >= Uint32FromUint32(2)*Uint32FromInt32(0x7f800000)-Uint32FromInt32(1))
}

func x_powf(tls *TLS, x float32, y float32) (r float32) {
	var ix Tuint32_t
	var iy Tuint32_t
	var logx Tdouble_t
	var sign_bias Tuint32_t
	var x2 Tfloat_t
	var yint int32
	var ylogx Tdouble_t
	var v1 float32
	sign_bias = uint32(0)
	ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: x}))))
	iy = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint32_t
		F_f float32
	}{F_f: y}))))
	if ___builtin_expect(tls, BoolInt32(ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000)) || _zeroinfnan1(tls, iy) != 0), int32(0)) != 0 {
		/* Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).  */
		if ___builtin_expect(tls, _zeroinfnan1(tls, iy), int32(0)) != 0 {
			if uint32(2)*iy == uint32(0) {
				return Float32FromFloat32(1)
			}
			if ix == uint32(0x3f800000) {
				return Float32FromFloat32(1)
			}
			if uint32(2)*ix > Uint32FromUint32(2)*Uint32FromInt32(0x7f800000) || uint32(2)*iy > Uint32FromUint32(2)*Uint32FromInt32(0x7f800000) {
				return x + y
			}
			if uint32(2)*ix == uint32(Int32FromInt32(2)*Int32FromInt32(0x3f800000)) {
				return Float32FromFloat32(1)
			}
			if BoolInt32(uint32(2)*ix < uint32(Int32FromInt32(2)*Int32FromInt32(0x3f800000))) == BoolInt32(!(iy&Uint32FromUint32(0x80000000) != 0)) {
				return Float32FromFloat32(0)
			} /* |x|<1 && y==inf or |x|>1 && y==-inf.  */
			return y * y
		}
		if ___builtin_expect(tls, _zeroinfnan1(tls, ix), int32(0)) != 0 {
			x2 = x * x
			if ix&uint32(0x80000000) != 0 && _checkint1(tls, iy) == int32(1) {
				x2 = -x2
			}
			/* Without the barrier some versions of clang hoist the 1/x2 and
			   thus division by zero exception can be signaled spuriously.  */
			if iy&uint32(0x80000000) != 0 {
				v1 = _fp_barrierf(tls, Float32FromInt32(1)/x2)
			} else {
				v1 = x2
			}
			return v1
		}
		/* x and y are non-zero finite.  */
		if ix&uint32(0x80000000) != 0 {
			/* Finite x < 0.  */
			yint = _checkint1(tls, iy)
			if yint == int32(0) {
				return x___math_invalidf(tls, x)
			}
			if yint == int32(1) {
				sign_bias = uint32(Int32FromInt32(1) << (Int32FromInt32(m_EXP2F_TABLE_BITS) + Int32FromInt32(11)))
			}
			ix = ix & Uint32FromInt32(0x7fffffff)
		}
		if ix < uint32(0x00800000) {
			/* Normalize subnormal x so exponent becomes negative.  */
			ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
				F_i [0]Tuint32_t
				F_f float32
			}{F_f: x * Float32FromFloat32(8.388608e+06)}))))
			ix = ix & Uint32FromInt32(0x7fffffff)
			ix = ix - uint32(Int32FromInt32(23)<<Int32FromInt32(23))
		}
	}
	logx = _log2_inline(tls, ix)
	ylogx = float64(y) * logx /* cannot overflow, y is single prec.  */
	if ___builtin_expect(tls, BoolInt32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: ylogx}))))>>int32(47)&uint64(0xffff) >= *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		F_i [0]Tuint64_t
		F_f float64
	}{F_f: float64(126) * float64(Int32FromInt32(1)<<Int32FromInt32(0))}))))>>int32(47)), int32(0)) != 0 {
		/* |y*log(x)| >= 126.  */
		if ylogx > float64(127.99999995700433)*float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)) {
			return x___math_oflowf(tls, sign_bias)
		}
		if ylogx <= -Float64FromFloat64(150)*float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)) {
			return x___math_uflowf(tls, sign_bias)
		}
	}
	return _exp2_inline(tls, ylogx, sign_bias)
}

type Tpowf_log2_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fpoly [5]float64
}

func x_powl(tls *TLS, x float64, y float64) (r float64) {
	return x_pow(tls, x, y)
}

func x_remainder(tls *TLS, x float64, y float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* q at bp+0 */ int32
	return x_remquo(tls, x, y, bp)
}

func x_remainderf(tls *TLS, x float32, y float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* q at bp+0 */ int32
	return x_remquof(tls, x, y, bp)
}

func x_remquo(tls *TLS, x float64, y float64, quo uintptr) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ex int32
	var ey int32
	var i Tuint64_t
	var q Tuint32_t
	var sx int32
	var sy int32
	var uxi Tuint64_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v7 int32
	var v8 float64
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52) & uint64(0x7ff))
	sx = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	sy = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(63))
	uxi = *(*Tuint64_t)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(quo)) = int32(0)
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8))<<int32(1) == uint64(0) || BoolInt32(___DOUBLE_BITS(tls, y)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || ex == int32(0x7ff) {
		return x * y / (x * y)
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(1) == uint64(0) {
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		for i = uxi << int32(12); i>>int32(63) == uint64(0); {
			goto _1
		_1:
			ex--
			i = i << Uint64FromInt32(1)
		}
		uxi = uxi << uint64(-ex+Int32FromInt32(1))
	} else {
		uxi = uxi & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		uxi = uxi | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	if !(ey != 0) {
		for i = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) << int32(12); i>>int32(63) == uint64(0); {
			goto _2
		_2:
			ey--
			i = i << Uint64FromInt32(1)
		}
		p3 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) << uint64(-ey+Int32FromInt32(1))
	} else {
		p4 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p4)) = *(*Tuint64_t)(unsafe.Pointer(p4)) & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		p5 = bp + 8
		*(*Tuint64_t)(unsafe.Pointer(p5)) = *(*Tuint64_t)(unsafe.Pointer(p5)) | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	q = uint32(0)
	if ex < ey {
		if ex+int32(1) == ey {
			goto end
		}
		return x
	}
	/* x mod y */
	for ; ex > ey; ex-- {
		i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 8))
		if i>>int32(63) == uint64(0) {
			uxi = i
			q++
		}
		uxi = uxi << Uint64FromInt32(1)
		q = q << Uint32FromInt32(1)
	}
	i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 8))
	if i>>int32(63) == uint64(0) {
		uxi = i
		q++
	}
	if uxi == uint64(0) {
		ex = -int32(60)
	} else {
		for uxi>>int32(52) == uint64(0) {
			goto _6
		_6:
			uxi = uxi << Uint64FromInt32(1)
			ex--
		}
	}
end:
	/* scale result and decide between |x| and |x|-|y| */
	if ex > int32(0) {
		uxi = uxi - Uint64FromUint64(1)<<Int32FromInt32(52)
		uxi = uxi | uint64(ex)<<Int32FromInt32(52)
	} else {
		uxi = uxi >> uint64(-ex+Int32FromInt32(1))
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uxi
	x = *(*float64)(unsafe.Pointer(bp))
	if sy != 0 {
		y = -y
	}
	if ex == ey || ex+int32(1) == ey && (Float64FromInt32(2)*x > y || Float64FromInt32(2)*x == y && q%uint32(2) != 0) {
		x = x - y
		q++
	}
	q = q & Uint32FromInt32(0x7fffffff)
	if sx^sy != 0 {
		v7 = -int32(q)
	} else {
		v7 = int32(q)
	}
	*(*int32)(unsafe.Pointer(quo)) = v7
	if sx != 0 {
		v8 = -x
	} else {
		v8 = x
	}
	return v8
}

func x_remquof(tls *TLS, x float32, y float32, quo uintptr) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ex int32
	var ey int32
	var i Tuint32_t
	var q Tuint32_t
	var sx int32
	var sy int32
	var uxi Tuint32_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v7 int32
	var v8 float32
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	ex = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	ey = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(23) & uint32(0xff))
	sx = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	sy = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(31))
	uxi = *(*Tuint32_t)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(quo)) = int32(0)
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4))<<int32(1) == uint32(0) || BoolInt32(___FLOAT_BITS(tls, y)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || ex == int32(0xff) {
		return x * y / (x * y)
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) == uint32(0) {
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		for i = uxi << int32(9); i>>int32(31) == uint32(0); {
			goto _1
		_1:
			ex--
			i = i << Uint32FromInt32(1)
		}
		uxi = uxi << uint32(-ex+Int32FromInt32(1))
	} else {
		uxi = uxi & (-Uint32FromUint32(1) >> Int32FromInt32(9))
		uxi = uxi | Uint32FromUint32(1)<<Int32FromInt32(23)
	}
	if !(ey != 0) {
		for i = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) << int32(9); i>>int32(31) == uint32(0); {
			goto _2
		_2:
			ey--
			i = i << Uint32FromInt32(1)
		}
		p3 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p3)) = *(*Tuint32_t)(unsafe.Pointer(p3)) << uint32(-ey+Int32FromInt32(1))
	} else {
		p4 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p4)) = *(*Tuint32_t)(unsafe.Pointer(p4)) & (-Uint32FromUint32(1) >> Int32FromInt32(9))
		p5 = bp + 4
		*(*Tuint32_t)(unsafe.Pointer(p5)) = *(*Tuint32_t)(unsafe.Pointer(p5)) | Uint32FromUint32(1)<<Int32FromInt32(23)
	}
	q = uint32(0)
	if ex < ey {
		if ex+int32(1) == ey {
			goto end
		}
		return x
	}
	/* x mod y */
	for ; ex > ey; ex-- {
		i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 4))
		if i>>int32(31) == uint32(0) {
			uxi = i
			q++
		}
		uxi = uxi << Uint32FromInt32(1)
		q = q << Uint32FromInt32(1)
	}
	i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 4))
	if i>>int32(31) == uint32(0) {
		uxi = i
		q++
	}
	if uxi == uint32(0) {
		ex = -int32(30)
	} else {
		for uxi>>int32(23) == uint32(0) {
			goto _6
		_6:
			uxi = uxi << Uint32FromInt32(1)
			ex--
		}
	}
end:
	/* scale result and decide between |x| and |x|-|y| */
	if ex > int32(0) {
		uxi = uxi - Uint32FromUint32(1)<<Int32FromInt32(23)
		uxi = uxi | uint32(ex)<<Int32FromInt32(23)
	} else {
		uxi = uxi >> uint32(-ex+Int32FromInt32(1))
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uxi
	x = *(*float32)(unsafe.Pointer(bp))
	if sy != 0 {
		y = -y
	}
	if ex == ey || ex+int32(1) == ey && (Float32FromInt32(2)*x > y || Float32FromInt32(2)*x == y && q%uint32(2) != 0) {
		x = x - y
		q++
	}
	q = q & Uint32FromInt32(0x7fffffff)
	if sx^sy != 0 {
		v7 = -int32(q)
	} else {
		v7 = int32(q)
	}
	*(*int32)(unsafe.Pointer(quo)) = v7
	if sx != 0 {
		v8 = -x
	} else {
		v8 = x
	}
	return v8
}

var _toint4 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func x_rint(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var s int32
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 float64
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return x
	}
	if s != 0 {
		y = x - _toint4 + _toint4
	} else {
		y = x + _toint4 - _toint4
	}
	if y == Float64FromInt32(0) {
		if s != 0 {
			v1 = -Float64FromFloat64(0)
		} else {
			v1 = Float64FromInt32(0)
		}
		return v1
	}
	return y
}

var _toint5 = Float32FromInt32(1) / Float32FromFloat32(1.1920928955078125e-07)

func x_rintf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var s int32
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v1 float32
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	s = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	if e >= Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return x
	}
	if s != 0 {
		y = x - _toint5 + _toint5
	} else {
		y = x + _toint5 - _toint5
	}
	if y == Float32FromInt32(0) {
		if s != 0 {
			v1 = -Float32FromFloat32(0)
		} else {
			v1 = Float32FromFloat32(0)
		}
		return v1
	}
	return y
}

var _toint6 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func x_round(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return x
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		x = -x
	}
	if e < Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		/* raise inexact if x!=0 */
		{
			if uint64(8) == uint64(4) {
				_fp_force_evalf(tls, float32(x+_toint6))
			} else {
				if uint64(8) == uint64(8) {
					_fp_force_eval(tls, x+_toint6)
				} else {
					_fp_force_evall(tls, x+_toint6)
				}
			}
		}
		return Float64FromInt32(0) * *(*float64)(unsafe.Pointer(bp))
	}
	y = x + _toint6 - _toint6 - x
	if y > float64(0.5) {
		y = y + x - Float64FromInt32(1)
	} else {
		if y <= -Float64FromFloat64(0.5) {
			y = y + x + Float64FromInt32(1)
		} else {
			y = y + x
		}
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y = -y
	}
	return y
}

var _toint7 = Float32FromInt32(1) / Float32FromFloat32(1.1920928955078125e-07)

func x_roundf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if e >= Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return x
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		x = -x
	}
	if e < Int32FromInt32(0x7f)-Int32FromInt32(1) {
		{
			if uint64(4) == uint64(4) {
				_fp_force_evalf(tls, x+_toint7)
			} else {
				if uint64(4) == uint64(8) {
					_fp_force_eval(tls, float64(x+_toint7))
				} else {
					_fp_force_evall(tls, float64(x+_toint7))
				}
			}
		}
		return Float32FromInt32(0) * *(*float32)(unsafe.Pointer(bp))
	}
	y = x + _toint7 - _toint7 - x
	if y > Float32FromFloat32(0.5) {
		y = y + x - Float32FromInt32(1)
	} else {
		if y <= -Float32FromFloat32(0.5) {
			y = y + x + Float32FromInt32(1)
		} else {
			y = y + x
		}
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		y = -y
	}
	return y
}

func x_roundl(tls *TLS, x float64) (r float64) {
	return x_round(tls, x)
}

func x_scalb(tls *TLS, x float64, fn float64) (r float64) {
	if BoolInt32(___DOUBLE_BITS(tls, x)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || BoolInt32(___DOUBLE_BITS(tls, fn)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x * fn
	}
	if !(BoolInt32(___DOUBLE_BITS(tls, fn)&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		if fn > float64(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if x_rint(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > float64(65000) {
		return x_scalbn(tls, x, int32(65000))
	}
	if -fn > float64(65000) {
		return x_scalbn(tls, x, -int32(65000))
	}
	return x_scalbn(tls, x, int32(fn))
}

func x_scalbf(tls *TLS, x float32, fn float32) (r float32) {
	if BoolInt32(___FLOAT_BITS(tls, x)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || BoolInt32(___FLOAT_BITS(tls, fn)&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x * fn
	}
	if !(BoolInt32(___FLOAT_BITS(tls, fn)&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		if fn > Float32FromFloat32(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if x_rintf(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > Float32FromFloat32(65000) {
		return x_scalbnf(tls, x, int32(65000))
	}
	if -fn > Float32FromFloat32(65000) {
		return x_scalbnf(tls, x, -int32(65000))
	}
	return x_scalbnf(tls, x, int32(fn))
}

func x_scalbln(tls *TLS, x float64, n int64) (r float64) {
	if n > int64(m_INT_MAX) {
		n = int64(m_INT_MAX)
	} else {
		if n < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
			n = int64(-Int32FromInt32(1) - Int32FromInt32(0x7fffffff))
		}
	}
	return x_scalbn(tls, x, int32(n))
}

func x_scalblnf(tls *TLS, x float32, n int64) (r float32) {
	if n > int64(m_INT_MAX) {
		n = int64(m_INT_MAX)
	} else {
		if n < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
			n = int64(-Int32FromInt32(1) - Int32FromInt32(0x7fffffff))
		}
	}
	return x_scalbnf(tls, x, int32(n))
}

func x_scalblnl(tls *TLS, x float64, n int64) (r float64) {
	return x_scalbln(tls, x, n)
}

func x_scalbn(tls *TLS, x float64, n int32) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	y = x
	if n > int32(1023) {
		y = y * Float64FromFloat64(8.98846567431158e+307)
		n = n - Int32FromInt32(1023)
		if n > int32(1023) {
			y = y * Float64FromFloat64(8.98846567431158e+307)
			n = n - Int32FromInt32(1023)
			if n > int32(1023) {
				n = int32(1023)
			}
		}
	} else {
		if n < -int32(1022) {
			/* make sure final n < -53 to avoid double
			   rounding in the subnormal range */
			y = y * (Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(9.007199254740992e+15))
			n = n + (Int32FromInt32(1022) - Int32FromInt32(53))
			if n < -int32(1022) {
				y = y * (Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(9.007199254740992e+15))
				n = n + (Int32FromInt32(1022) - Int32FromInt32(53))
				if n < -int32(1022) {
					n = -int32(1022)
				}
			}
		}
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(Int32FromInt32(0x3ff)+n) << int32(52)
	x = y * *(*float64)(unsafe.Pointer(bp))
	return x
}

func x_scalbnf(tls *TLS, x float32, n int32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	y = x
	if n > int32(127) {
		y = y * Float32FromFloat32(1.7014118346046923e+38)
		n = n - Int32FromInt32(127)
		if n > int32(127) {
			y = y * Float32FromFloat32(1.7014118346046923e+38)
			n = n - Int32FromInt32(127)
			if n > int32(127) {
				n = int32(127)
			}
		}
	} else {
		if n < -int32(126) {
			y = y * (Float32FromFloat32(1.1754943508222875e-38) * Float32FromFloat32(1.6777216e+07))
			n = n + (Int32FromInt32(126) - Int32FromInt32(24))
			if n < -int32(126) {
				y = y * (Float32FromFloat32(1.1754943508222875e-38) * Float32FromFloat32(1.6777216e+07))
				n = n + (Int32FromInt32(126) - Int32FromInt32(24))
				if n < -int32(126) {
					n = -int32(126)
				}
			}
		}
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32(Int32FromInt32(0x7f)+n) << int32(23)
	x = y * *(*float32)(unsafe.Pointer(bp))
	return x
}

func x_scalbnl(tls *TLS, x float64, n int32) (r float64) {
	return x_scalbn(tls, x, n)
}

func x_significand(tls *TLS, x float64) (r float64) {
	return x_scalbn(tls, x, -x_ilogb(tls, x))
}

func x_significandf(tls *TLS, x float32) (r float32) {
	return x_scalbnf(tls, x, -x_ilogbf(tls, x))
}

func x_sin(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var _ /* y at bp+0 */ [2]float64
	var v1 float64
	var v2 float64
	var v3 float64
	/* High word of x. */
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e500000) {
			/* |x| < 2**-26 */
			/* raise inexact if x != 0 and underflow if subnormal*/
			{
				if uint64(8) == uint64(4) {
					if ix < uint32(0x00100000) {
						v1 = x / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float64FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, float32(v1))
				} else {
					if uint64(8) == uint64(8) {
						if ix < uint32(0x00100000) {
							v2 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, v2)
					} else {
						if ix < uint32(0x00100000) {
							v3 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, v3)
					}
				}
			}
			return x
		}
		return x___sin(tls, x, float64(0), int32(0))
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x - x
	}
	/* argument reduction needed */
	n = uint32(x___rem_pio2(tls, x, bp))
	switch n & uint32(3) {
	case uint32(0):
		return x___sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	case uint32(1):
		return x___cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	case uint32(2):
		return -x___sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	default:
		return -x___cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	}
	return r
}

func x_sincos(tls *TLS, x float64, sin uintptr, cos uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var c float64
	var ix Tuint32_t
	var n uint32
	var s float64
	var _ /* y at bp+0 */ [2]float64
	var v1 float64
	var v2 float64
	var v3 float64
	var v4 float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		/* if |x| < 2**-27 * sqrt(2) */
		if ix < uint32(0x3e46a09e) {
			/* raise inexact if x!=0 and underflow if subnormal */
			{
				if uint64(8) == uint64(4) {
					if ix < uint32(0x00100000) {
						v1 = x / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float64FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, float32(v1))
				} else {
					if uint64(8) == uint64(8) {
						if ix < uint32(0x00100000) {
							v2 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, v2)
					} else {
						if ix < uint32(0x00100000) {
							v3 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, v3)
					}
				}
			}
			*(*float64)(unsafe.Pointer(sin)) = x
			*(*float64)(unsafe.Pointer(cos)) = float64(1)
			return
		}
		*(*float64)(unsafe.Pointer(sin)) = x___sin(tls, x, float64(0), int32(0))
		*(*float64)(unsafe.Pointer(cos)) = x___cos(tls, x, float64(0))
		return
	}
	/* sincos(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		v4 = x - x
		*(*float64)(unsafe.Pointer(cos)) = v4
		*(*float64)(unsafe.Pointer(sin)) = v4
		return
	}
	/* argument reduction needed */
	n = uint32(x___rem_pio2(tls, x, bp))
	s = x___sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	c = x___cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	switch n & uint32(3) {
	case uint32(0):
		*(*float64)(unsafe.Pointer(sin)) = s
		*(*float64)(unsafe.Pointer(cos)) = c
	case uint32(1):
		*(*float64)(unsafe.Pointer(sin)) = c
		*(*float64)(unsafe.Pointer(cos)) = -s
	case uint32(2):
		*(*float64)(unsafe.Pointer(sin)) = -s
		*(*float64)(unsafe.Pointer(cos)) = -c
	case uint32(3):
		fallthrough
	default:
		*(*float64)(unsafe.Pointer(sin)) = -c
		*(*float64)(unsafe.Pointer(cos)) = s
		break
	}
}

/* Small multiples of pi/2 rounded to double precision. */

var _s1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _s2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _s3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _s4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966)

func x_sincosf(tls *TLS, x float32, sin uintptr, cos uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c Tfloat_t
	var ix Tuint32_t
	var n uint32
	var s Tfloat_t
	var sign uint32
	var _ /* y at bp+0 */ float64
	var v1 float32
	var v2 float32
	var v3 float32
	var v4 float64
	var v5 float64
	var v6 float64
	var v7 float64
	var v8 float32
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = ix >> int32(31)
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* |x| ~<= pi/4 */
	if ix <= uint32(0x3f490fda) {
		/* |x| < 2**-12 */
		if ix < uint32(0x39800000) {
			/* raise inexact if x!=0 and underflow if subnormal */
			{
				if uint64(4) == uint64(4) {
					if ix < uint32(0x00100000) {
						v1 = x / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float32FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, v1)
				} else {
					if uint64(4) == uint64(8) {
						if ix < uint32(0x00100000) {
							v2 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, float64(v2))
					} else {
						if ix < uint32(0x00100000) {
							v3 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, float64(v3))
					}
				}
			}
			*(*float32)(unsafe.Pointer(sin)) = x
			*(*float32)(unsafe.Pointer(cos)) = Float32FromFloat32(1)
			return
		}
		*(*float32)(unsafe.Pointer(sin)) = x___sindf(tls, float64(x))
		*(*float32)(unsafe.Pointer(cos)) = x___cosdf(tls, float64(x))
		return
	}
	/* |x| ~<= 5*pi/4 */
	if ix <= uint32(0x407b53d1) {
		if ix <= uint32(0x4016cbe3) {
			/* |x| ~<= 3pi/4 */
			if sign != 0 {
				*(*float32)(unsafe.Pointer(sin)) = -x___cosdf(tls, float64(x)+_s1pio2)
				*(*float32)(unsafe.Pointer(cos)) = x___sindf(tls, float64(x)+_s1pio2)
			} else {
				*(*float32)(unsafe.Pointer(sin)) = x___cosdf(tls, _s1pio2-float64(x))
				*(*float32)(unsafe.Pointer(cos)) = x___sindf(tls, _s1pio2-float64(x))
			}
			return
		}
		/* -sin(x+c) is not correct if x+c could be 0: -0 vs +0 */
		if sign != 0 {
			v4 = float64(x) + _s2pio2
		} else {
			v4 = float64(x) - _s2pio2
		}
		*(*float32)(unsafe.Pointer(sin)) = -x___sindf(tls, v4)
		if sign != 0 {
			v5 = float64(x) + _s2pio2
		} else {
			v5 = float64(x) - _s2pio2
		}
		*(*float32)(unsafe.Pointer(cos)) = -x___cosdf(tls, v5)
		return
	}
	/* |x| ~<= 9*pi/4 */
	if ix <= uint32(0x40e231d5) {
		if ix <= uint32(0x40afeddf) {
			/* |x| ~<= 7*pi/4 */
			if sign != 0 {
				*(*float32)(unsafe.Pointer(sin)) = x___cosdf(tls, float64(x)+_s3pio2)
				*(*float32)(unsafe.Pointer(cos)) = -x___sindf(tls, float64(x)+_s3pio2)
			} else {
				*(*float32)(unsafe.Pointer(sin)) = -x___cosdf(tls, float64(x)-_s3pio2)
				*(*float32)(unsafe.Pointer(cos)) = x___sindf(tls, float64(x)-_s3pio2)
			}
			return
		}
		if sign != 0 {
			v6 = float64(x) + _s4pio2
		} else {
			v6 = float64(x) - _s4pio2
		}
		*(*float32)(unsafe.Pointer(sin)) = x___sindf(tls, v6)
		if sign != 0 {
			v7 = float64(x) + _s4pio2
		} else {
			v7 = float64(x) - _s4pio2
		}
		*(*float32)(unsafe.Pointer(cos)) = x___cosdf(tls, v7)
		return
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		v8 = x - x
		*(*float32)(unsafe.Pointer(cos)) = v8
		*(*float32)(unsafe.Pointer(sin)) = v8
		return
	}
	/* general argument reduction needed */
	n = uint32(x___rem_pio2f(tls, x, bp))
	s = x___sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	c = x___cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	switch n & uint32(3) {
	case uint32(0):
		*(*float32)(unsafe.Pointer(sin)) = s
		*(*float32)(unsafe.Pointer(cos)) = c
	case uint32(1):
		*(*float32)(unsafe.Pointer(sin)) = c
		*(*float32)(unsafe.Pointer(cos)) = -s
	case uint32(2):
		*(*float32)(unsafe.Pointer(sin)) = -s
		*(*float32)(unsafe.Pointer(cos)) = -c
	case uint32(3):
		fallthrough
	default:
		*(*float32)(unsafe.Pointer(sin)) = -c
		*(*float32)(unsafe.Pointer(cos)) = s
		break
	}
}

func x_sincosl(tls *TLS, x float64, sin uintptr, cos uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* cosd at bp+8 */ float64
	var _ /* sind at bp+0 */ float64
	x_sincos(tls, x, bp, bp+8)
	*(*float64)(unsafe.Pointer(sin)) = *(*float64)(unsafe.Pointer(bp))
	*(*float64)(unsafe.Pointer(cos)) = *(*float64)(unsafe.Pointer(bp + 8))
}

/* Small multiples of pi/2 rounded to double precision. */

var _s1pio21 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _s2pio21 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _s3pio21 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _s4pio21 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966)

func x_sinf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ix Tuint32_t
	var n int32
	var sign int32
	var _ /* y at bp+0 */ float64
	var v1 float32
	var v2 float32
	var v3 float32
	var v4 float64
	var v5 float64
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = int32(ix >> int32(31))
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix <= uint32(0x3f490fda) {
		/* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) {
			/* |x| < 2**-12 */
			/* raise inexact if x!=0 and underflow if subnormal */
			{
				if uint64(4) == uint64(4) {
					if ix < uint32(0x00800000) {
						v1 = x / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float32FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, v1)
				} else {
					if uint64(4) == uint64(8) {
						if ix < uint32(0x00800000) {
							v2 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, float64(v2))
					} else {
						if ix < uint32(0x00800000) {
							v3 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, float64(v3))
					}
				}
			}
			return x
		}
		return x___sindf(tls, float64(x))
	}
	if ix <= uint32(0x407b53d1) {
		/* |x| ~<= 5*pi/4 */
		if ix <= uint32(0x4016cbe3) {
			/* |x| ~<= 3pi/4 */
			if sign != 0 {
				return -x___cosdf(tls, float64(x)+_s1pio21)
			} else {
				return x___cosdf(tls, float64(x)-_s1pio21)
			}
		}
		if sign != 0 {
			v4 = -(float64(x) + _s2pio21)
		} else {
			v4 = -(float64(x) - _s2pio21)
		}
		return x___sindf(tls, v4)
	}
	if ix <= uint32(0x40e231d5) {
		/* |x| ~<= 9*pi/4 */
		if ix <= uint32(0x40afeddf) {
			/* |x| ~<= 7*pi/4 */
			if sign != 0 {
				return x___cosdf(tls, float64(x)+_s3pio21)
			} else {
				return -x___cosdf(tls, float64(x)-_s3pio21)
			}
		}
		if sign != 0 {
			v5 = float64(x) + _s4pio21
		} else {
			v5 = float64(x) - _s4pio21
		}
		return x___sindf(tls, v5)
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x - x
	}
	/* general argument reduction needed */
	n = x___rem_pio2f(tls, x, bp)
	switch n & int32(3) {
	case int32(0):
		return x___sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	case int32(1):
		return x___cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	case int32(2):
		return x___sindf(tls, -*(*float64)(unsafe.Pointer(bp)))
	default:
		return -x___cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	}
	return r
}

// C documentation
//
//	/* sinh(x) = (exp(x) - 1/exp(x))/2
//	 *         = (exp(x)-1 + (exp(x)-1)/exp(x))/2
//	 *         = x + x^3/6 + o(x^5)
//	 */
func x_sinh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var absx float64
	var h float64
	var t float64
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	h = float64(0.5)
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		h = -h
	}
	/* |x| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) / Uint64FromInt32(2))
	absx = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	/* |x| < log(DBL_MAX) */
	if w < uint32(0x40862e42) {
		t = x_expm1(tls, absx)
		if w < uint32(0x3ff00000) {
			if w < uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(26)<<Int32FromInt32(20)) {
				/* note: inexact and underflow are raised by expm1 */
				/* note: this branch avoids spurious underflow */
				return x
			}
			return h * (Float64FromInt32(2)*t - t*t/(t+Float64FromInt32(1)))
		}
		/* note: |x|>log(0x1p26)+eps could be just h*exp(x) */
		return h * (t + t/(t+Float64FromInt32(1)))
	}
	/* |x| > log(DBL_MAX) or nan */
	/* note: the result is stored to handle overflow */
	t = x___expo2(tls, absx, Float64FromInt32(2)*h)
	return t
}

func x_sinhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var absx float32
	var h float32
	var t float32
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	h = float32(0.5)
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		h = -h
	}
	/* |x| */
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	absx = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	/* |x| < log(FLT_MAX) */
	if w < uint32(0x42b17217) {
		t = x_expm1f(tls, absx)
		if w < uint32(0x3f800000) {
			if w < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
				return x
			}
			return h * (Float32FromInt32(2)*t - t*t/(t+Float32FromInt32(1)))
		}
		return h * (t + t/(t+Float32FromInt32(1)))
	}
	/* |x| > logf(FLT_MAX) or nan */
	t = x___expo2f(tls, absx, Float32FromInt32(2)*h)
	return t
}

func x_sinhl(tls *TLS, x float64) (r float64) {
	return x_sinh(tls, x)
}

func x_sinl(tls *TLS, x float64) (r float64) {
	return x_sin(tls, x)
}

func x_tan(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var _ /* y at bp+0 */ [2]float64
	var v1 float64
	var v2 float64
	var v3 float64
	{
		ix = uint32(*(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint64_t
			F_f float64
		}{F_f: x})))) >> int32(32))
	}
	ix = ix & Uint32FromInt32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e400000) {
			/* |x| < 2**-27 */
			/* raise inexact if x!=0 and underflow if subnormal */
			{
				if uint64(8) == uint64(4) {
					if ix < uint32(0x00100000) {
						v1 = x / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float64FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, float32(v1))
				} else {
					if uint64(8) == uint64(8) {
						if ix < uint32(0x00100000) {
							v2 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, v2)
					} else {
						if ix < uint32(0x00100000) {
							v3 = x / Float64FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float64FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, v3)
					}
				}
			}
			return x
		}
		return x___tan(tls, x, float64(0), int32(0))
	}
	/* tan(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x - x
	}
	/* argument reduction */
	n = uint32(x___rem_pio2(tls, x, bp))
	return x___tan(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[int32(0)], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(n&uint32(1)))
}

/* Small multiples of pi/2 rounded to double precision. */

var _t1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _t2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _t3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _t4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966)

func x_tanf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ix Tuint32_t
	var n uint32
	var sign uint32
	var _ /* y at bp+0 */ float64
	var v1 float32
	var v2 float32
	var v3 float32
	var v4 float64
	var v5 float64
	var v6 float64
	var v7 float64
	{
		ix = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			F_i [0]Tuint32_t
			F_f float32
		}{F_f: x}))))
	}
	sign = ix >> int32(31)
	ix = ix & Uint32FromInt32(0x7fffffff)
	if ix <= uint32(0x3f490fda) {
		/* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) {
			/* |x| < 2**-12 */
			/* raise inexact if x!=0 and underflow if subnormal */
			{
				if uint64(4) == uint64(4) {
					if ix < uint32(0x00800000) {
						v1 = x / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v1 = x + Float32FromFloat32(1.329227995784916e+36)
					}
					_fp_force_evalf(tls, v1)
				} else {
					if uint64(4) == uint64(8) {
						if ix < uint32(0x00800000) {
							v2 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v2 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_eval(tls, float64(v2))
					} else {
						if ix < uint32(0x00800000) {
							v3 = x / Float32FromFloat32(1.329227995784916e+36)
						} else {
							v3 = x + Float32FromFloat32(1.329227995784916e+36)
						}
						_fp_force_evall(tls, float64(v3))
					}
				}
			}
			return x
		}
		return x___tandf(tls, float64(x), int32(0))
	}
	if ix <= uint32(0x407b53d1) {
		/* |x| ~<= 5*pi/4 */
		if ix <= uint32(0x4016cbe3) { /* |x| ~<= 3pi/4 */
			if sign != 0 {
				v4 = float64(x) + _t1pio2
			} else {
				v4 = float64(x) - _t1pio2
			}
			return x___tandf(tls, v4, int32(1))
		} else {
			if sign != 0 {
				v5 = float64(x) + _t2pio2
			} else {
				v5 = float64(x) - _t2pio2
			}
			return x___tandf(tls, v5, int32(0))
		}
	}
	if ix <= uint32(0x40e231d5) {
		/* |x| ~<= 9*pi/4 */
		if ix <= uint32(0x40afeddf) { /* |x| ~<= 7*pi/4 */
			if sign != 0 {
				v6 = float64(x) + _t3pio2
			} else {
				v6 = float64(x) - _t3pio2
			}
			return x___tandf(tls, v6, int32(1))
		} else {
			if sign != 0 {
				v7 = float64(x) + _t4pio2
			} else {
				v7 = float64(x) - _t4pio2
			}
			return x___tandf(tls, v7, int32(0))
		}
	}
	/* tan(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x - x
	}
	/* argument reduction */
	n = uint32(x___rem_pio2f(tls, x, bp))
	return x___tandf(tls, *(*float64)(unsafe.Pointer(bp)), int32(n&uint32(1)))
}

// C documentation
//
//	/* tanh(x) = (exp(x) - exp(-x))/(exp(x) + exp(-x))
//	 *         = (exp(2*x) - 1)/(exp(2*x) - 1 + 2)
//	 *         = (1 - exp(-2*x))/(exp(-2*x) - 1 + 2)
//	 */
func x_tanh(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var sign int32
	var t Tdouble_t
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v2 Tdouble_t
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	/* x = |x| */
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (uint64(-Int32FromInt32(1)) / Uint64FromInt32(2))
	x = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	if w > uint32(0x3fe193ea) {
		/* |x| > log(3)/2 ~= 0.5493 or nan */
		if w > uint32(0x40340000) {
			/* |x| > 20 or nan */
			/* note: this branch avoids raising overflow */
			t = Float64FromInt32(1) - Float64FromInt32(0)/x
		} else {
			t = x_expm1(tls, Float64FromInt32(2)*x)
			t = Float64FromInt32(1) - Float64FromInt32(2)/(t+Float64FromInt32(2))
		}
	} else {
		if w > uint32(0x3fd058ae) {
			/* |x| > log(5/3)/2 ~= 0.2554 */
			t = x_expm1(tls, Float64FromInt32(2)*x)
			t = t / (t + Float64FromInt32(2))
		} else {
			if w >= uint32(0x00100000) {
				/* |x| >= 0x1p-1022, up to 2ulp error in [0.1,0.2554] */
				t = x_expm1(tls, float64(-Int32FromInt32(2))*x)
				t = -t / (t + Float64FromInt32(2))
			} else {
				/* |x| is subnormal */
				/* note: the branch above would not raise underflow in [0x1p-1023,0x1p-1022) */
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, float32(x))
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(float32(x)))
						} else {
							_fp_force_evall(tls, float64(float32(x)))
						}
					}
				}
				t = x
			}
		}
	}
	if sign != 0 {
		v2 = -t
	} else {
		v2 = t
	}
	return v2
}

func x_tanhf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var sign int32
	var t float32
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var v2 float32
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	/* x = |x| */
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	x = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	if w > uint32(0x3f0c9f54) {
		/* |x| > log(3)/2 ~= 0.5493 or nan */
		if w > uint32(0x41200000) {
			/* |x| > 10 */
			t = Float32FromInt32(1) + Float32FromInt32(0)/x
		} else {
			t = x_expm1f(tls, Float32FromInt32(2)*x)
			t = Float32FromInt32(1) - Float32FromInt32(2)/(t+Float32FromInt32(2))
		}
	} else {
		if w > uint32(0x3e82c578) {
			/* |x| > log(5/3)/2 ~= 0.2554 */
			t = x_expm1f(tls, Float32FromInt32(2)*x)
			t = t / (t + Float32FromInt32(2))
		} else {
			if w >= uint32(0x00800000) {
				/* |x| >= 0x1p-126 */
				t = x_expm1f(tls, float32(-Int32FromInt32(2))*x)
				t = -t / (t + Float32FromInt32(2))
			} else {
				/* |x| is subnormal */
				{
					if uint64(4) == uint64(4) {
						_fp_force_evalf(tls, x*x)
					} else {
						if uint64(4) == uint64(8) {
							_fp_force_eval(tls, float64(x*x))
						} else {
							_fp_force_evall(tls, float64(x*x))
						}
					}
				}
				t = x
			}
		}
	}
	if sign != 0 {
		v2 = -t
	} else {
		v2 = t
	}
	return v2
}

func x_tanhl(tls *TLS, x float64) (r float64) {
	return x_tanh(tls, x)
}

func x_tanl(tls *TLS, x float64) (r float64) {
	return x_tan(tls, x)
}

const m_N = 12

var _pi4 = float64(3.141592653589793)

// C documentation
//
//	/* sin(pi x) with x > 0x1p-100, if sin(pi*x)==0 the sign is arbitrary */
func _sinpi(tls *TLS, x float64) (r float64) {
	var n int32
	/* argument reduction: x = |x| mod 2 */
	/* spurious inexact when x is odd int */
	x = x * float64(0.5)
	x = Float64FromInt32(2) * (x - x_floor(tls, x))
	/* reduce x into [-.25,.25] */
	n = int32(Float64FromInt32(4) * x)
	n = (n + int32(1)) / int32(2)
	x = x - float64(n)*Float64FromFloat64(0.5)
	x = x * _pi4
	switch n {
	default: /* case 4 */
		fallthrough
	case int32(0):
		return x___sin(tls, x, Float64FromInt32(0), int32(0))
	case int32(1):
		return x___cos(tls, x, Float64FromInt32(0))
	case int32(2):
		return x___sin(tls, -x, Float64FromInt32(0), int32(0))
	case int32(3):
		return -x___cos(tls, x, Float64FromInt32(0))
	}
	return r
}

// static const double g = 6.024680040776729583740234375;
var _gmhalf = float64(5.52468004077673)
var _Snum = [13]float64{
	0:  float64(2.353137688041076e+10),
	1:  float64(4.29198036426491e+10),
	2:  float64(3.571195923735567e+10),
	3:  float64(1.792103442603721e+10),
	4:  float64(6.039542586352028e+09),
	5:  float64(1.4397204073117216e+09),
	6:  float64(2.4887455786205417e+08),
	7:  float64(3.1426415585400194e+07),
	8:  float64(2.8763706289353725e+06),
	9:  float64(186056.26539522348),
	10: float64(8071.672002365816),
	11: float64(210.82427775157936),
	12: float64(2.5066282746310002)}
var _Sden = [13]float64{
	0:  Float64FromInt32(0),
	1:  Float64FromInt32(39916800),
	2:  Float64FromInt32(120543840),
	3:  Float64FromInt32(150917976),
	4:  Float64FromInt32(105258076),
	5:  Float64FromInt32(45995730),
	6:  Float64FromInt32(13339535),
	7:  Float64FromInt32(2637558),
	8:  Float64FromInt32(357423),
	9:  Float64FromInt32(32670),
	10: Float64FromInt32(1925),
	11: Float64FromInt32(66),
	12: Float64FromInt32(1)}

/* n! for small integer n */
var _fact = [23]float64{
	0:  Float64FromInt32(1),
	1:  Float64FromInt32(1),
	2:  Float64FromInt32(2),
	3:  Float64FromInt32(6),
	4:  Float64FromInt32(24),
	5:  Float64FromInt32(120),
	6:  Float64FromInt32(720),
	7:  float64(5040),
	8:  float64(40320),
	9:  float64(362880),
	10: float64(3.6288e+06),
	11: float64(3.99168e+07),
	12: float64(4.790016e+08),
	13: float64(6.2270208e+09),
	14: float64(8.71782912e+10),
	15: float64(1.307674368e+12),
	16: float64(2.0922789888e+13),
	17: float64(3.55687428096e+14),
	18: float64(6.402373705728e+15),
	19: float64(1.21645100408832e+17),
	20: float64(2.43290200817664e+18),
	21: float64(5.109094217170944e+19),
	22: float64(1.1240007277776077e+21)}

// C documentation
//
//	/* S(x) rational function for positive x */
func _S(tls *TLS, x float64) (r float64) {
	var den Tdouble_t
	var i int32
	var num Tdouble_t
	num = Float64FromInt32(0)
	den = Float64FromInt32(0)
	/* to avoid overflow handle large x differently */
	if x < Float64FromInt32(8) {
		for i = int32(m_N); i >= int32(0); i-- {
			num = num*x + _Snum[i]
			den = den*x + _Sden[i]
		}
	} else {
		for i = int32(0); i <= int32(m_N); i++ {
			num = num/x + _Snum[i]
			den = den/x + _Sden[i]
		}
	}
	return num / den
}

func x_tgamma(tls *TLS, x float64) (r1 float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var absx float64
	var dy Tdouble_t
	var ix Tuint32_t
	var r Tdouble_t
	var sign int32
	var y float64
	var z Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var v1 float64
	*(*float64)(unsafe.Pointer(bp)) = x
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* special cases */
	if ix >= uint32(0x7ff00000) {
		/* tgamma(nan)=nan, tgamma(inf)=inf, tgamma(-inf)=nan with invalid */
		return x + float64(___builtin_inff(tls))
	}
	if ix < uint32((Int32FromInt32(0x3ff)-Int32FromInt32(54))<<Int32FromInt32(20)) {
		/* |x| < 2^-54: tgamma(x) ~ 1/x, +-0 raises div-by-zero */
		return Float64FromInt32(1) / x
	}
	/* integer arguments */
	/* raise inexact when non-integer */
	if x == x_floor(tls, x) {
		if sign != 0 {
			return Float64FromInt32(0) / Float64FromFloat64(0)
		}
		if x <= float64(Uint64FromInt64(184)/Uint64FromInt64(8)) {
			return _fact[int32(x)-int32(1)]
		}
	}
	/* x >= 172: tgamma(x)=inf with overflow */
	/* x =< -184: tgamma(x)=+-0 with underflow */
	if ix >= uint32(0x40670000) {
		/* |x| >= 184 */
		if sign != 0 {
			{
				if uint64(4) == uint64(4) {
					_fp_force_evalf(tls, float32(Float64FromFloat64(1.1754943508222875e-38)/x))
				} else {
					if uint64(4) == uint64(8) {
						_fp_force_eval(tls, float64(float32(Float64FromFloat64(1.1754943508222875e-38)/x)))
					} else {
						_fp_force_evall(tls, float64(float32(Float64FromFloat64(1.1754943508222875e-38)/x)))
					}
				}
			}
			if x_floor(tls, x)*float64(0.5) == x_floor(tls, x*float64(0.5)) {
				return Float64FromInt32(0)
			}
			return -Float64FromFloat64(0)
		}
		x = x * Float64FromFloat64(8.98846567431158e+307)
		return x
	}
	if sign != 0 {
		v1 = -x
	} else {
		v1 = x
	}
	absx = v1
	/* handle the error of x + g - 0.5 */
	y = absx + _gmhalf
	if absx > _gmhalf {
		dy = y - absx
		dy = dy - _gmhalf
	} else {
		dy = y - _gmhalf
		dy = dy - absx
	}
	z = absx - float64(0.5)
	r = _S(tls, absx) * x_exp(tls, -y)
	if x < Float64FromInt32(0) {
		/* reflection formula for negative x */
		/* sinpi(absx) is not 0, integers are already handled */
		r = -_pi4 / (_sinpi(tls, absx) * absx * r)
		dy = -dy
		z = -z
	}
	r = r + dy*(_gmhalf+Float64FromFloat64(0.5))*r/y
	z = x_pow(tls, y, float64(0.5)*z)
	y = r * z * z
	return y
}

func x_tgammaf(tls *TLS, x float32) (r float32) {
	return float32(x_tgamma(tls, float64(x)))
}

func x_tgammal(tls *TLS, x float64) (r float64) {
	return x_tgamma(tls, x)
}

func x_trunc(tls *TLS, x float64) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var m Tuint64_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var p1 uintptr
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp))>>Int32FromInt32(52)&Uint64FromInt32(0x7ff)) - int32(0x3ff) + int32(12)
	if e >= Int32FromInt32(52)+Int32FromInt32(12) {
		return x
	}
	if e < int32(12) {
		e = int32(1)
	}
	m = -Uint64FromUint64(1) >> e
	if *(*Tuint64_t)(unsafe.Pointer(bp))&m == uint64(0) {
		return x
	}
	{
		if uint64(8) == uint64(4) {
			_fp_force_evalf(tls, float32(x+Float64FromFloat32(1.329227995784916e+36)))
		} else {
			if uint64(8) == uint64(8) {
				_fp_force_eval(tls, x+Float64FromFloat32(1.329227995784916e+36))
			} else {
				_fp_force_evall(tls, x+Float64FromFloat32(1.329227995784916e+36))
			}
		}
	}
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & ^m
	return *(*float64)(unsafe.Pointer(bp))
}

func x_truncf(tls *TLS, x float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var m Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var p1 uintptr
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f) + int32(9)
	if e >= Int32FromInt32(23)+Int32FromInt32(9) {
		return x
	}
	if e < int32(9) {
		e = int32(1)
	}
	m = -Uint32FromUint32(1) >> e
	if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
		return x
	}
	{
		if uint64(4) == uint64(4) {
			_fp_force_evalf(tls, x+Float32FromFloat32(1.329227995784916e+36))
		} else {
			if uint64(4) == uint64(8) {
				_fp_force_eval(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
			} else {
				_fp_force_evall(tls, float64(x+Float32FromFloat32(1.329227995784916e+36)))
			}
		}
	}
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = *(*Tuint32_t)(unsafe.Pointer(p1)) & ^m
	return *(*float32)(unsafe.Pointer(bp))
}

func x_fabsl(tls *TLS, x float64) (r float64) {
	// __asm__ ("fabs" : "+t"(x));
	___assert_fail(tls, ts+240, ts+845, 5, ts+853)
	return x
}

type Tnum = struct {
	Fm    Tuint64_t
	Fe    int32
	Fsign int32
}

func _normalize(tls *TLS, x float64) (r Tnum) {
	var e int32
	var ix Tuint64_t
	var sign int32
	var v1 int32
	ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
		Fi [0]Tuint64_t
		Ff float64
	}{Ff: x}))))
	e = int32(ix >> int32(52))
	sign = e & int32(0x800)
	e = e & Int32FromInt32(0x7ff)
	if !(e != 0) {
		ix = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&struct {
			Fi [0]Tuint64_t
			Ff float64
		}{Ff: x * float64(9.223372036854776e+18)}))))
		e = int32(ix >> int32(52) & uint64(0x7ff))
		if e != 0 {
			v1 = e - int32(63)
		} else {
			v1 = int32(0x800)
		}
		e = v1
	}
	ix = ix & (Uint64FromUint64(1)<<Int32FromInt32(52) - Uint64FromInt32(1))
	ix = ix | Uint64FromUint64(1)<<Int32FromInt32(52)
	ix = ix << Uint64FromInt32(1)
	e = e - (Int32FromInt32(0x3ff) + Int32FromInt32(52) + Int32FromInt32(1))
	return Tnum{Fm: ix, Fe: e, Fsign: sign}
}

func _mul(tls *TLS, hi uintptr, lo uintptr, x Tuint64_t, y Tuint64_t) {
	var t1 Tuint64_t
	var t2 Tuint64_t
	var t3 Tuint64_t
	var xhi Tuint64_t
	var xlo Tuint64_t
	var yhi Tuint64_t
	var ylo Tuint64_t
	xlo = uint64(uint32(x))
	xhi = x >> int32(32)
	ylo = uint64(uint32(y))
	yhi = y >> int32(32)
	t1 = xlo * ylo
	t2 = xlo*yhi + xhi*ylo
	t3 = xhi * yhi
	*(*Tuint64_t)(unsafe.Pointer(lo)) = t1 + t2<<Int32FromInt32(32)
	*(*Tuint64_t)(unsafe.Pointer(hi)) = t3 + t2>>Int32FromInt32(32) + BoolUint64(t1 > *(*Tuint64_t)(unsafe.Pointer(lo)))
}

func x_fma(tls *TLS, x float64, y float64, z float64) (r1 float64) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var c float64
	var d int32
	var e int32
	var fltmin float32
	var i Tint64_t
	var nonzero int32
	var nx Tnum
	var ny Tnum
	var nz Tnum
	var r float64
	var samesign int32
	var sign int32
	var t Tuint64_t
	var tiny Tdouble_t
	var zhi Tuint64_t
	var zlo Tuint64_t
	var _ /* rhi at bp+0 */ Tuint64_t
	var _ /* rlo at bp+8 */ Tuint64_t
	/* normalize so top 10bits and last bit are 0 */
	nx = _normalize(tls, x)
	ny = _normalize(tls, y)
	nz = _normalize(tls, z)
	if nx.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) || ny.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) {
		return x*y + z
	}
	if nz.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) {
		if nz.Fe > Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) { /* z==0 */
			return x*y + z
		}
		return z
	}
	/* mul: r = x*y */
	_mul(tls, bp, bp+8, nx.Fm, ny.Fm)
	/* either top 20 or 21 bits of rhi and last 2 bits of rlo are 0 */
	/* align exponents */
	e = nx.Fe + ny.Fe
	d = nz.Fe - e
	/* shift bits z<<=kz, r>>=kr, so kz+kr == d, set e = e+kr (== ez-kz) */
	if d > int32(0) {
		if d < int32(64) {
			zlo = nz.Fm << d
			zhi = nz.Fm >> (int32(64) - d)
		} else {
			zlo = uint64(0)
			zhi = nz.Fm
			e = nz.Fe - int32(64)
			d = d - Int32FromInt32(64)
			if d == int32(0) {
			} else {
				if d < int32(64) {
					*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = *(*Tuint64_t)(unsafe.Pointer(bp))<<(int32(64)-d) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>d | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8))<<(Int32FromInt32(64)-d) != 0))
					*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp)) >> d
				} else {
					*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uint64(1)
					*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(0)
				}
			}
		}
	} else {
		zhi = uint64(0)
		d = -d
		if d == int32(0) {
			zlo = nz.Fm
		} else {
			if d < int32(64) {
				zlo = nz.Fm>>d | BoolUint64(!!(nz.Fm<<(Int32FromInt32(64)-d) != 0))
			} else {
				zlo = uint64(1)
			}
		}
	}
	/* add */
	sign = nx.Fsign ^ ny.Fsign
	samesign = BoolInt32(!(sign^nz.Fsign != 0))
	nonzero = int32(1)
	if samesign != 0 {
		/* r += z */
		*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) + zlo
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp)) + (zhi + BoolUint64(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) < zlo))
	} else {
		/* r -= z */
		t = *(*Tuint64_t)(unsafe.Pointer(bp + 8))
		*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) - zlo
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp)) - zhi - BoolUint64(t < *(*Tuint64_t)(unsafe.Pointer(bp + 8)))
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = -*(*Tuint64_t)(unsafe.Pointer(bp + 8))
			*(*Tuint64_t)(unsafe.Pointer(bp)) = -*(*Tuint64_t)(unsafe.Pointer(bp)) - BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) != 0))
			sign = BoolInt32(!(sign != 0))
		}
		nonzero = BoolInt32(!!(*(*Tuint64_t)(unsafe.Pointer(bp)) != 0))
	}
	/* set rhi to top 63bit of the result (last bit is sticky) */
	if nonzero != 0 {
		e = e + Int32FromInt32(64)
		d = _a_clz_64(tls, *(*Tuint64_t)(unsafe.Pointer(bp))) - int32(1)
		/* note: d > 0 */
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp))<<d | *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>(int32(64)-d) | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8))<<d != 0))
	} else {
		if *(*Tuint64_t)(unsafe.Pointer(bp + 8)) != 0 {
			d = _a_clz_64(tls, *(*Tuint64_t)(unsafe.Pointer(bp + 8))) - int32(1)
			if d < int32(0) {
				*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>int32(1) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))&uint64(1)
			} else {
				*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) << d
			}
		} else {
			/* exact +-0 */
			return x*y + z
		}
	}
	e = e - d
	/* convert to double */
	i = int64(*(*Tuint64_t)(unsafe.Pointer(bp))) /* i is in [1<<62,(1<<63)-1] */
	if sign != 0 {
		i = -i
	}
	r = float64(i) /* |r| is in [0x1p62,0x1p63] */
	if e < -Int32FromInt32(1022)-Int32FromInt32(62) {
		/* result is subnormal before rounding */
		if e == -Int32FromInt32(1022)-Int32FromInt32(63) {
			c = float64(9.223372036854776e+18)
			if sign != 0 {
				c = -c
			}
			if r == c {
				/* min normal after rounding, underflow depends
				   on arch behaviour which can be imitated by
				   a double to float conversion */
				fltmin = float32(Float64FromFloat64(1.0842021401737618e-19) * Float64FromFloat32(1.1754943508222875e-38) * r)
				return Float64FromFloat64(2.2250738585072014e-308) / Float64FromFloat32(1.1754943508222875e-38) * float64(fltmin)
			}
			/* one bit is lost when scaled, add another top bit to
			   only round once at conversion if it is inexact */
			if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(53) != 0 {
				i = int64(*(*Tuint64_t)(unsafe.Pointer(bp))>>int32(1) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(1) | Uint64FromUint64(1)<<Int32FromInt32(62))
				if sign != 0 {
					i = -i
				}
				r = float64(i)
				r = Float64FromInt32(2)*r - c
				{
					/* remove top bit */
					/* raise underflow portably, such that it
					   cannot be optimized away */
					tiny = Float64FromFloat64(2.2250738585072014e-308) / Float64FromFloat32(1.1754943508222875e-38) * r
					r = r + tiny*tiny*(r-r)
				}
			}
		} else {
			/* only round once when scaled */
			d = int32(10)
			i = int64((*(*Tuint64_t)(unsafe.Pointer(bp))>>d | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp))<<(Int32FromInt32(64)-d) != 0))) << d)
			if sign != 0 {
				i = -i
			}
			r = float64(i)
		}
	}
	return x_scalbn(tls, r, e)
}

const m_FE_UNDERFLOW = 16

// C documentation
//
//	/*
//	 * Fused multiply-add: Compute x * y + z with a single rounding error.
//	 *
//	 * A double has more than twice as much precision than a float, so
//	 * direct double-precision arithmetic suffices, except where double
//	 * rounding occurs.
//	 */
func x_fmaf(tls *TLS, x float32, y float32, z float32) (r float32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var err float64
	var neg int32
	var result float64
	var vz float32
	var xy float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	xy = float64(x) * float64(y)
	result = xy + float64(z)
	*(*float64)(unsafe.Pointer(bp)) = result
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	/* Common case: The double precision result is fine. */
	if *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(0x1fffffff) != uint64(0x10000000) || e == int32(0x7ff) || result-xy == float64(z) && result-float64(z) == xy || _fegetround(tls) != int32(m_FE_TONEAREST) {
		/* not round-to-nearest */
		/*
			underflow may not be raised correctly, example:
			fmaf(0x1p-120f, 0x1p-120f, 0x1p-149f)
		*/
		if e < Int32FromInt32(0x3ff)-Int32FromInt32(126) && e >= Int32FromInt32(0x3ff)-Int32FromInt32(149) && _fetestexcept(tls, int32(m_FE_INEXACT)) != 0 {
			_feclearexcept(tls, int32(m_FE_INEXACT))
			/* TODO: gcc and clang bug workaround */
			vz = z
			result = xy + float64(vz)
			if _fetestexcept(tls, int32(m_FE_INEXACT)) != 0 {
				_feraiseexcept(tls, int32(m_FE_UNDERFLOW))
			} else {
				_feraiseexcept(tls, int32(m_FE_INEXACT))
			}
		}
		z = float32(result)
		return z
	}
	/*
	 * If result is inexact, and exactly halfway between two float values,
	 * we need to adjust the low-order bit in the direction of the error.
	 */
	neg = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	if neg == BoolInt32(float64(z) > xy) {
		err = xy - result + float64(z)
	} else {
		err = float64(z) - result + xy
	}
	if neg == BoolInt32(err < Float64FromInt32(0)) {
		*(*Tuint64_t)(unsafe.Pointer(bp))++
	} else {
		*(*Tuint64_t)(unsafe.Pointer(bp))--
	}
	z = float32(*(*float64)(unsafe.Pointer(bp)))
	return z
}

func x_fmodl(tls *TLS, x float64, y float64) (r float64) {
	var fpsr uint16
	for cond := true; cond; cond = int32(fpsr)&int32(0x400) != 0 {
		// __asm__ ("fprem; fnstsw %%ax" : "+t"(x), "=a"(fpsr) : "u"(y));
		___assert_fail(tls, ts+240, ts+859, 6, ts+867)
	}
	return x
}

func x_llrint(tls *TLS, x float64) (r1 int64) {
	var r int64
	// __asm__ ("cvtsd2si %1, %0" : "=r"(r) : "x"(x));
	___assert_fail(tls, ts+240, ts+873, 6, ts+882)
	return r
}

func x_llrintf(tls *TLS, x float32) (r1 int64) {
	var r int64
	// __asm__ ("cvtss2si %1, %0" : "=r"(r) : "x"(x));
	___assert_fail(tls, ts+240, ts+889, 6, ts+899)
	return r
}

func x_llrintl(tls *TLS, x float64) (r1 int64) {
	var r int64
	// __asm__ ("fistpll %0" : "=m"(r) : "t"(x) : "st");
	___assert_fail(tls, ts+240, ts+907, 6, ts+917)
	return r
}

func x_lrint(tls *TLS, x float64) (r1 int64) {
	var r int64
	// __asm__ ("cvtsd2si %1, %0" : "=r"(r) : "x"(x));
	___assert_fail(tls, ts+240, ts+925, 6, ts+933)
	return r
}

func x_lrintf(tls *TLS, x float32) (r1 int64) {
	var r int64
	// __asm__ ("cvtss2si %1, %0" : "=r"(r) : "x"(x));
	___assert_fail(tls, ts+240, ts+939, 6, ts+948)
	return r
}

func x_lrintl(tls *TLS, x float64) (r1 int64) {
	var r int64
	// __asm__ ("fistpll %0" : "=m"(r) : "t"(x) : "st");
	___assert_fail(tls, ts+240, ts+955, 6, ts+964)
	return r
}

func x_remainderl(tls *TLS, x float64, y float64) (r float64) {
	var fpsr uint16
	for cond := true; cond; cond = int32(fpsr)&int32(0x400) != 0 {
		// __asm__ ("fprem1; fnstsw %%ax" : "+t"(x), "=a"(fpsr) : "u"(y));
		___assert_fail(tls, ts+240, ts+971, 6, ts+984)
	}
	return x
}

func x_remquol(tls *TLS, x float64, y float64, quo uintptr) (r float64) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+995, int32(5), uintptr(unsafe.Pointer(&___func__18)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__18 = [8]int8{'r', 'e', 'm', 'q', 'u', 'o', 'l'}

func x_rintl(tls *TLS, x float64) (r float64) {
	// __asm__ ("frndint" : "+t"(x));
	___assert_fail(tls, ts+240, ts+1021, 5, ts+1029)
	return x
}

func x_sqrt(tls *TLS, x float64) (r float64) {
	// __asm__ ("sqrtsd %1, %0" : "=x"(x) : "x"(x));
	___assert_fail(tls, ts+240, ts+1035, 5, ts+1042)
	return x
}

func x_sqrtf(tls *TLS, x float32) (r float32) {
	// __asm__ ("sqrtss %1, %0" : "=x"(x) : "x"(x));
	___assert_fail(tls, ts+240, ts+1047, 5, ts+1055)
	return x
}

func x_sqrtl(tls *TLS, x float64) (r float64) {
	// __asm__ ("fsqrt" : "+t"(x));
	___assert_fail(tls, ts+240, ts+1061, 5, ts+1069)
	return x
}

var _digits = [65]int8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func x_a64l(tls *TLS, s uintptr) (r int64) {
	var d uintptr
	var e int32
	var x Tuint32_t
	x = uint32(0)
	for e = int32(0); e < int32(36) && *(*int8)(unsafe.Pointer(s)) != 0; {
		d = x_strchr(tls, uintptr(unsafe.Pointer(&_digits)), int32(*(*int8)(unsafe.Pointer(s))))
		if !(d != 0) {
			break
		}
		x = x | uint32(int64(d)-T__predefined_ptrdiff_t(uintptr(unsafe.Pointer(&_digits))))<<e
		goto _1
	_1:
		e = e + Int32FromInt32(6)
		s++
	}
	return int64(int32(x))
}

func x_l64a(tls *TLS, x0 int64) (r uintptr) {
	var p uintptr
	var x Tuint32_t
	x = uint32(x0)
	for p = uintptr(unsafe.Pointer(&_s)); x != 0; {
		*(*int8)(unsafe.Pointer(p)) = _digits[x&uint32(63)]
		goto _1
	_1:
		p++
		x = x >> Uint32FromInt32(6)
	}
	*(*int8)(unsafe.Pointer(p)) = int8(0)
	return uintptr(unsafe.Pointer(&_s))
}

var _s [7]int8

func x_basename(tls *TLS, s uintptr) (r uintptr) {
	var i Tsize_t
	if !(s != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) {
		return ts + 724
	}
	i = x_strlen(tls, s) - uint64(1)
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) == int32('/'); i-- {
		*(*int8)(unsafe.Pointer(s + uintptr(i))) = int8(0)
	}
	for ; i != 0 && int32(*(*int8)(unsafe.Pointer(s + uintptr(i-Uint64FromInt32(1))))) != int32('/'); i-- {
	}
	return s + uintptr(i)
}

func x_dirname(tls *TLS, s uintptr) (r uintptr) {
	var i Tsize_t
	if !(s != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) {
		return ts + 724
	}
	i = x_strlen(tls, s) - uint64(1)
	for ; int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) == int32('/'); i-- {
		if !(i != 0) {
			return ts + 553
		}
	}
	for ; int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) != int32('/'); i-- {
		if !(i != 0) {
			return ts + 724
		}
	}
	for ; int32(*(*int8)(unsafe.Pointer(s + uintptr(i)))) == int32('/'); i-- {
		if !(i != 0) {
			return ts + 553
		}
	}
	*(*int8)(unsafe.Pointer(s + uintptr(i+Uint64FromInt32(1)))) = int8(0)
	return s
}

func x_ffs(tls *TLS, i int32) (r int32) {
	var v1 int32
	if i != 0 {
		v1 = _a_ctz_l(tls, uint64(i)) + int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

func x_ffsl(tls *TLS, i int64) (r int32) {
	var v1 int32
	if i != 0 {
		v1 = _a_ctz_l(tls, uint64(i)) + int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

func x_ffsll(tls *TLS, i int64) (r int32) {
	var v1 int32
	if i != 0 {
		v1 = _a_ctz_64(tls, uint64(i)) + int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

const m_MM_CONSOLE = 512
const m_MM_ERROR = 2
const m_MM_HALT = 1
const m_MM_INFO = 4
const m_MM_NOCON = 4
const m_MM_NOMSG = 1
const m_MM_NULLSEV = 0
const m_MM_PRINT = 256
const m_MM_WARNING = 3
const m_PTHREAD_CANCEL_DISABLE = 1

// C documentation
//
//	/*
//	 * If lstr is the first part of bstr, check that the next char in bstr
//	 * is either \0 or :
//	 */
func __strcolcmp(tls *TLS, lstr uintptr, bstr uintptr) (r int32) {
	var i Tsize_t
	i = uint64(0)
	for *(*int8)(unsafe.Pointer(lstr + uintptr(i))) != 0 && *(*int8)(unsafe.Pointer(bstr + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(bstr + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(lstr + uintptr(i)))) {
		i++
	}
	if *(*int8)(unsafe.Pointer(lstr + uintptr(i))) != 0 || *(*int8)(unsafe.Pointer(bstr + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(bstr + uintptr(i)))) != int32(':') {
		return int32(1)
	}
	return int32(0)
}

func x_fmtmsg(tls *TLS, classification int64, label uintptr, severity int32, text uintptr, action uintptr, tag uintptr) (r int32) {
	bp := tls.Alloc(80) /* tlsAllocs 8 maxValist 8 */
	defer tls.Free(80)
	var cmsg uintptr
	var consolefd int32
	var errstring uintptr
	var i int32
	var msgs [6]uintptr
	var ret int32
	var verb int32
	var _ /* cs at bp+0 */ int32
	var v1 uintptr
	var v10 uintptr
	var v11 uintptr
	var v12 uintptr
	var v13 uintptr
	var v14 uintptr
	var v15 uintptr
	var v16 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	var v8 uintptr
	var v9 uintptr
	ret = int32(0)
	verb = int32(0)
	errstring = uintptr(m_MM_NULLSEV)
	cmsg = x_getenv(tls, ts+1075)
	msgs = [6]uintptr{
		0: ts + 1083,
		1: ts + 1089,
		2: ts + 1098,
		3: ts + 1103,
		4: ts + 1110,
		5: UintptrFromInt32(0)}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	if severity == int32(m_MM_HALT) {
		errstring = ts + 1114
	} else {
		if severity == int32(m_MM_ERROR) {
			errstring = ts + 1121
		} else {
			if severity == int32(m_MM_WARNING) {
				errstring = ts + 1129
			} else {
				if severity == int32(m_MM_INFO) {
					errstring = ts + 1139
				}
			}
		}
	}
	if classification&int64(m_MM_CONSOLE) != 0 {
		consolefd = x_open(tls, ts+1146, int32(m_O_WRONLY), 0)
		if consolefd < int32(0) {
			ret = int32(m_MM_NOCON)
		} else {
			if label != 0 {
				v1 = label
			} else {
				v1 = ts
			}
			if label != 0 {
				v2 = ts + 560
			} else {
				v2 = ts
			}
			if severity != 0 {
				v3 = errstring
			} else {
				v3 = ts
			}
			if text != 0 {
				v4 = text
			} else {
				v4 = ts
			}
			if action != 0 {
				v5 = ts + 1159
			} else {
				v5 = ts
			}
			if action != 0 {
				v6 = action
			} else {
				v6 = ts
			}
			if action != 0 {
				v7 = ts + 1169
			} else {
				v7 = ts
			}
			if tag != 0 {
				v8 = tag
			} else {
				v8 = ts
			}
			if x_dprintf(tls, consolefd, ts+1171, VaList(bp+16, v1, v2, v3, v4, v5, v6, v7, v8)) < int32(1) {
				ret = int32(m_MM_NOCON)
			}
			x_close(tls, consolefd)
		}
	}
	if classification&int64(m_MM_PRINT) != 0 {
		for cmsg != 0 && *(*int8)(unsafe.Pointer(cmsg + UintptrFromInt32(0))) != 0 {
			for i = int32(0); msgs[i] != 0; i++ {
				if !(__strcolcmp(tls, msgs[i], cmsg) != 0) {
					break
				}
			}
			if msgs[i] == UintptrFromInt32(0) {
				//ignore MSGVERB-unrecognized component
				verb = int32(0xFF)
				break
			} else {
				verb = verb | Int32FromInt32(1)<<i
				cmsg = x_strchr(tls, cmsg, int32(':'))
				if cmsg != 0 {
					cmsg++
				}
			}
		}
		if !(verb != 0) {
			verb = int32(0xFF)
		}
		if verb&int32(1) != 0 && label != 0 {
			v9 = label
		} else {
			v9 = ts
		}
		if verb&int32(1) != 0 && label != 0 {
			v10 = ts + 560
		} else {
			v10 = ts
		}
		if verb&int32(2) != 0 && severity != 0 {
			v11 = errstring
		} else {
			v11 = ts
		}
		if verb&int32(4) != 0 && text != 0 {
			v12 = text
		} else {
			v12 = ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v13 = ts + 1159
		} else {
			v13 = ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v14 = action
		} else {
			v14 = ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v15 = ts + 1169
		} else {
			v15 = ts
		}
		if verb&int32(16) != 0 && tag != 0 {
			v16 = tag
		} else {
			v16 = ts
		}
		if x_dprintf(tls, int32(2), ts+1171, VaList(bp+16, v9, v10, v11, v12, v13, v14, v15, v16)) < int32(1) {
			ret = ret | Int32FromInt32(m_MM_NOMSG)
		}
	}
	if ret&(Int32FromInt32(m_MM_NOCON)|Int32FromInt32(m_MM_NOMSG)) == Int32FromInt32(m_MM_NOCON)|Int32FromInt32(m_MM_NOMSG) {
		ret = -int32(1)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return ret
}

const m_UT_HOSTSIZE = 256
const m_UT_LINESIZE = 32

type Tlastlog = struct {
	Fll_time Ttime_t
	Fll_line [32]int8
	Fll_host [256]int8
}

func x_forkpty(tls *TLS, pm uintptr, name uintptr, tio uintptr, ws uintptr) (r int32) {
	bp := tls.Alloc(288) /* tlsAllocs 288 maxValist 0 */
	defer tls.Free(288)
	var pid Tpid_t
	var _ /* cs at bp+20 */ int32
	var _ /* ec at bp+8 */ int32
	var _ /* m at bp+0 */ int32
	var _ /* oldset at bp+152 */ Tsigset_t
	var _ /* p at bp+12 */ [2]int32
	var _ /* s at bp+4 */ int32
	var _ /* set at bp+24 */ Tsigset_t
	var _ /* status at bp+280 */ int32
	*(*int32)(unsafe.Pointer(bp + 8)) = int32(0)
	pid = -int32(1)
	if x_openpty(tls, bp, bp+4, name, tio, ws) < int32(0) {
		return -int32(1)
	}
	x_sigfillset(tls, bp+24)
	x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp+24, bp+152)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+20)
	if x_pipe2(tls, bp+12, int32(m_O_CLOEXEC)) != 0 {
		x_close(tls, *(*int32)(unsafe.Pointer(bp + 4)))
		goto out
	}
	pid = x_fork(tls)
	if !(pid != 0) {
		x_close(tls, *(*int32)(unsafe.Pointer(bp)))
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(0)])
		if x_login_tty(tls, *(*int32)(unsafe.Pointer(bp + 4))) != 0 {
			x_write(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(1)], x___errno_location(tls), uint64(4))
			x__exit(tls, int32(127))
		}
		x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(1)])
		x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 20)), uintptr(0))
		x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+152, uintptr(0))
		return int32(0)
	}
	x_close(tls, *(*int32)(unsafe.Pointer(bp + 4)))
	x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(1)])
	if x_read(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(0)], bp+8, uint64(4)) > int64(0) {
		x_waitpid(tls, pid, bp+280, int32(0))
		pid = -int32(1)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = *(*int32)(unsafe.Pointer(bp + 8))
	}
	x_close(tls, (*(*[2]int32)(unsafe.Pointer(bp + 12)))[int32(0)])
out:
	if pid > int32(0) {
		*(*int32)(unsafe.Pointer(pm)) = *(*int32)(unsafe.Pointer(bp))
	} else {
		x_close(tls, *(*int32)(unsafe.Pointer(bp)))
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 20)), uintptr(0))
	x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+152, uintptr(0))
	return pid
}

func x_get_current_dir_name(tls *TLS) (r uintptr) {
	bp := tls.Alloc(288) /* tlsAllocs 288 maxValist 0 */
	defer tls.Free(288)
	var res uintptr
	var _ /* a at bp+0 */ Tstat
	var _ /* b at bp+144 */ Tstat
	res = x_getenv(tls, ts+1189)
	if res != 0 && *(*int8)(unsafe.Pointer(res)) != 0 && !(x_stat(tls, res, bp) != 0) && !(x_stat(tls, ts+724, bp+144) != 0) && (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev == (*(*Tstat)(unsafe.Pointer(bp + 144))).Fst_dev && (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino == (*(*Tstat)(unsafe.Pointer(bp + 144))).Fst_ino {
		return x_strdup(tls, res)
	}
	return x_getcwd(tls, uintptr(0), uint64(0))
}

func x___getauxval(tls *TLS, item uint64) (r uint64) {
	var auxv uintptr
	auxv = x___libc.Fauxv
	if item == uint64(m_AT_SECURE) {
		return uint64(x___libc.Fsecure)
	}
	for *(*Tsize_t)(unsafe.Pointer(auxv)) != 0 {
		if *(*Tsize_t)(unsafe.Pointer(auxv)) == item {
			return *(*Tsize_t)(unsafe.Pointer(auxv + UintptrFromInt32(1)*8))
		}
		goto _1
	_1:
		auxv = auxv + UintptrFromInt32(2)*8
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOENT)
	return uint64(0)
}

type Tutsname = struct {
	Fsysname    [65]int8
	Fnodename   [65]int8
	Frelease    [65]int8
	Fversion    [65]int8
	Fmachine    [65]int8
	Fdomainname [65]int8
}

func x_getdomainname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	bp := tls.Alloc(392) /* tlsAllocs 392 maxValist 0 */
	defer tls.Free(392)
	var _ /* temp at bp+0 */ Tutsname
	x_uname(tls, bp)
	if !(len1 != 0) || x_strlen(tls, uintptr(unsafe.Pointer(&(*(*Tutsname)(unsafe.Pointer(bp))).Fdomainname))) >= len1 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	x_strcpy(tls, name, uintptr(unsafe.Pointer(&(*(*Tutsname)(unsafe.Pointer(bp))).Fdomainname)))
	return int32(0)
}

func x_getentropy(tls *TLS, buffer uintptr, len1 Tsize_t) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var pos uintptr
	var ret int32
	var _ /* cs at bp+0 */ int32
	ret = int32(0)
	pos = buffer
	if len1 > uint64(256) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EIO)
		return -int32(1)
	}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	for len1 != 0 {
		ret = int32(x_getrandom(tls, pos, len1, uint32(0)))
		if ret < int32(0) {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EINTR) {
				continue
			} else {
				break
			}
		}
		pos = pos + uintptr(ret)
		len1 = len1 - uint64(ret)
		ret = int32(0)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return ret
}

func x_gethostid(tls *TLS) (r int64) {
	return int64(0)
}

const m_MB_LEN_MAX = 4

type T__ucontext1 = Tucontext_t3

func x___getopt_msg(tls *TLS, a uintptr, b uintptr, c uintptr, l Tsize_t) {
	var __need_unlock int32
	var f uintptr
	var v1 int32
	f = uintptr(unsafe.Pointer(&x___stderr_FILE))
	b = x___lctrans_cur(tls, b)
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	_ = x_fputs(tls, a, f) >= int32(0) && x_fwrite(tls, b, x_strlen(tls, b), uint64(1), f) != 0 && x_fwrite(tls, c, uint64(1), l, f) == l && x_putc(tls, int32('\n'), f) != 0
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
}

func x_getopt(tls *TLS, argc int32, argv uintptr, optstring uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var i int32
	var k int32
	var l int32
	var optchar uintptr
	var _ /* c at bp+0 */ Twchar_t
	var _ /* d at bp+4 */ Twchar_t
	var v1 int32
	var v2 int32
	var v3 int32
	if !(x_optind != 0) || x___optreset != 0 {
		x___optreset = int32(0)
		x___optpos = int32(0)
		x_optind = int32(1)
	}
	if x_optind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) != 0) {
		return -int32(1)
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(0)))) != int32('-') {
		if int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32('-') {
			v1 = x_optind
			x_optind++
			x_optarg = *(*uintptr)(unsafe.Pointer(argv + uintptr(v1)*8))
			return int32(1)
		}
		return -int32(1)
	}
	if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1))) != 0) {
		return -int32(1)
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1)))) == int32('-') && !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(2))) != 0) {
		x_optind++
		return -Int32FromInt32(1)
	}
	if !(x___optpos != 0) {
		x___optpos++
	}
	v2 = x_mbtowc(tls, bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))+uintptr(x___optpos), uint64(m_MB_LEN_MAX))
	k = v2
	if v2 < int32(0) {
		k = int32(1)
		*(*Twchar_t)(unsafe.Pointer(bp)) = int32(0xfffd) /* replacement char */
	}
	optchar = *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(x___optpos)
	x___optpos = x___optpos + k
	if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(x___optpos))) != 0) {
		x_optind++
		x___optpos = int32(0)
	}
	if int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32('-') || int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32('+') {
		optstring++
	}
	i = int32(0)
	*(*Twchar_t)(unsafe.Pointer(bp + 4)) = int32(0)
	for cond := true; cond; cond = l != 0 && *(*Twchar_t)(unsafe.Pointer(bp + 4)) != *(*Twchar_t)(unsafe.Pointer(bp)) {
		l = x_mbtowc(tls, bp+4, optstring+uintptr(i), uint64(m_MB_LEN_MAX))
		if l > int32(0) {
			i = i + l
		} else {
			i++
		}
	}
	if *(*Twchar_t)(unsafe.Pointer(bp + 4)) != *(*Twchar_t)(unsafe.Pointer(bp)) || *(*Twchar_t)(unsafe.Pointer(bp)) == int32(':') {
		x_optopt = *(*Twchar_t)(unsafe.Pointer(bp))
		if int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) != int32(':') && x_opterr != 0 {
			x___getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)), ts+1193, optchar, uint64(k))
		}
		return int32('?')
	}
	if int32(*(*int8)(unsafe.Pointer(optstring + uintptr(i)))) == int32(':') {
		x_optarg = uintptr(0)
		if int32(*(*int8)(unsafe.Pointer(optstring + uintptr(i+Int32FromInt32(1))))) != int32(':') || x___optpos != 0 {
			v3 = x_optind
			x_optind++
			x_optarg = *(*uintptr)(unsafe.Pointer(argv + uintptr(v3)*8))
			if x___optpos != 0 {
				x_optarg = x_optarg + uintptr(x___optpos)
			}
			x___optpos = int32(0)
		}
		if x_optind > argc {
			x_optopt = *(*Twchar_t)(unsafe.Pointer(bp))
			if int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32(':') {
				return int32(':')
			}
			if x_opterr != 0 {
				x___getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)), ts+1217, optchar, uint64(k))
			}
			return int32('?')
		}
	}
	return *(*Twchar_t)(unsafe.Pointer(bp))
}

const m_required_argument = 1

type Toption = struct {
	Fname        uintptr
	Fhas_arg     int32
	Fflag        uintptr
	Fval         int32
	F__ccgo_pad4 [4]byte
}

func _permute(tls *TLS, argv uintptr, dest int32, src int32) {
	var av uintptr
	var i int32
	var tmp uintptr
	av = argv
	tmp = *(*uintptr)(unsafe.Pointer(av + uintptr(src)*8))
	for i = src; i > dest; i-- {
		*(*uintptr)(unsafe.Pointer(av + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer(av + uintptr(i-Int32FromInt32(1))*8))
	}
	*(*uintptr)(unsafe.Pointer(av + uintptr(dest)*8)) = tmp
}

func ___getopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr, longonly int32) (r int32) {
	var cnt int32
	var i int32
	var i1 int32
	var resumed int32
	var ret int32
	var skipped int32
	if !(x_optind != 0) || x___optreset != 0 {
		x___optreset = int32(0)
		x___optpos = int32(0)
		x_optind = int32(1)
	}
	if x_optind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) != 0) {
		return -int32(1)
	}
	skipped = x_optind
	if int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) != int32('+') && int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) != int32('-') {
		for i = x_optind; ; i++ {
			if i >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0) {
				return -int32(1)
			}
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) + UintptrFromInt32(0)))) == int32('-') && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) + UintptrFromInt32(1))) != 0 {
				break
			}
		}
		x_optind = i
	}
	resumed = x_optind
	ret = ___getopt_long_core(tls, argc, argv, optstring, longopts, idx, longonly)
	if resumed > skipped {
		cnt = x_optind - resumed
		for i1 = int32(0); i1 < cnt; i1++ {
			_permute(tls, argv, skipped, x_optind-int32(1))
		}
		x_optind = skipped + cnt
	}
	return ret
}

func ___getopt_long_core(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr, longonly int32) (r int32) {
	var arg uintptr
	var cnt int32
	var colon int32
	var i int32
	var j int32
	var l int32
	var match int32
	var name uintptr
	var opt uintptr
	var start uintptr
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	x_optarg = uintptr(0)
	if longopts != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(0)))) == int32('-') && (longonly != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1))) != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1)))) != int32('-') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1)))) == int32('-') && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(2))) != 0) {
		colon = BoolInt32(int32(*(*int8)(unsafe.Pointer(optstring + BoolUintptr(int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32('+') || int32(*(*int8)(unsafe.Pointer(optstring + UintptrFromInt32(0)))) == int32('-'))))) == int32(':'))
		start = *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + uintptr(1)
		v1 = Int32FromInt32(0)
		i = v1
		cnt = v1
		for ; (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname != 0; i++ {
			name = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname
			opt = start
			if int32(*(*int8)(unsafe.Pointer(opt))) == int32('-') {
				opt++
			}
			for *(*int8)(unsafe.Pointer(opt)) != 0 && int32(*(*int8)(unsafe.Pointer(opt))) != int32('=') && int32(*(*int8)(unsafe.Pointer(opt))) == int32(*(*int8)(unsafe.Pointer(name))) {
				name++
				opt++
			}
			if *(*int8)(unsafe.Pointer(opt)) != 0 && int32(*(*int8)(unsafe.Pointer(opt))) != int32('=') {
				continue
			}
			arg = opt
			match = i
			if !(*(*int8)(unsafe.Pointer(name)) != 0) {
				cnt = int32(1)
				break
			}
			cnt++
		}
		if cnt == int32(1) && longonly != 0 && int64(arg)-int64(start) == int64(x_mblen(tls, start, uint64(m_MB_LEN_MAX))) {
			l = int32(int64(arg) - int64(start))
			for i = int32(0); *(*int8)(unsafe.Pointer(optstring + uintptr(i))) != 0; i++ {
				for j = int32(0); j < l && int32(*(*int8)(unsafe.Pointer(start + uintptr(j)))) == int32(*(*int8)(unsafe.Pointer(optstring + uintptr(i+j)))); j++ {
				}
				if j == l {
					cnt++
					break
				}
			}
		}
		if cnt == int32(1) {
			i = match
			opt = arg
			x_optind++
			if int32(*(*int8)(unsafe.Pointer(opt))) == int32('=') {
				if !((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg != 0) {
					x_optopt = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
					if colon != 0 || !(x_opterr != 0) {
						return int32('?')
					}
					x___getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)), ts+1249, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname, x_strlen(tls, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname))
					return int32('?')
				}
				x_optarg = opt + uintptr(1)
			} else {
				if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg == int32(m_required_argument) {
					v2 = *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))
					x_optarg = v2
					if !(v2 != 0) {
						x_optopt = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
						if colon != 0 {
							return int32(':')
						}
						if !(x_opterr != 0) {
							return int32('?')
						}
						x___getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)), ts+1217, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname, x_strlen(tls, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname))
						return int32('?')
					}
					x_optind++
				}
			}
			if idx != 0 {
				*(*int32)(unsafe.Pointer(idx)) = i
			}
			if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag != 0 {
				*(*int32)(unsafe.Pointer((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag)) = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
				return int32(0)
			}
			return (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8)) + UintptrFromInt32(1)))) == int32('-') {
			x_optopt = int32(0)
			if !(colon != 0) && x_opterr != 0 {
				if cnt != 0 {
					v3 = ts + 1286
				} else {
					v3 = ts + 1193
				}
				x___getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv + UintptrFromInt32(0)*8)), v3, *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))+uintptr(2), x_strlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(x_optind)*8))+uintptr(2)))
			}
			x_optind++
			return int32('?')
		}
	}
	return x_getopt(tls, argc, argv, optstring)
}

func x_getopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, int32(0))
}

func x_getopt_long_only(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, int32(1))
}

func x_getpriority(tls *TLS, which int32, who Tid_t) (r int32) {
	var ret int32
	ret = int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(140), int64(which), int64(who)))))
	if ret < int32(0) {
		return ret
	}
	return int32(20) - ret
}

func x_getresgid(tls *TLS, rgid uintptr, egid uintptr, sgid uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(120), int64(rgid), int64(egid), int64(sgid)))))
}

func x_getresuid(tls *TLS, ruid uintptr, euid uintptr, suid uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(118), int64(ruid), int64(euid), int64(suid)))))
}

func x_getrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ret int32
	var _ /* k_rlim at bp+0 */ [2]uint64
	var v1 uint64
	var v2 uint64
	ret = int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(302), int64(Int32FromInt32(0)), int64(resource), int64(Int32FromInt32(0)), int64(rlim)))))
	if !(ret != 0) {
		{
			if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur >= ^Uint64FromUint64(0) {
				(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = ^Uint64FromUint64(0)
			}
		}
		{
			if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max >= ^Uint64FromUint64(0) {
				(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = ^Uint64FromUint64(0)
			}
		}
	}
	if !(ret != 0) || *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOSYS) {
		return ret
	}
	if x___syscall_ret(tls, uint64(___syscall2(tls, int64(97), int64(resource), int64(bp)))) < int64(0) {
		return -int32(1)
	}
	if (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(0)] == -Uint64FromUint64(1) {
		v1 = ^Uint64FromUint64(0)
	} else {
		v1 = (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(0)]
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = v1
	if (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(1)] == -Uint64FromUint64(1) {
		v2 = ^Uint64FromUint64(0)
	} else {
		v2 = (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(1)]
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = v2
	{
		if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = ^Uint64FromUint64(0)
		}
	}
	{
		if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = ^Uint64FromUint64(0)
		}
	}
	return int32(0)
}

func x_getrusage(tls *TLS, who int32, ru uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var dest uintptr
	var r int32
	var _ /* kru at bp+0 */ [4]int64
	dest = ru + 32 - uintptr(Uint64FromInt32(4)*Uint64FromInt64(8))
	r = int32(___syscall2(tls, int64(98), int64(who), int64(dest)))
	if !(r != 0) && uint64(8) > uint64(8) {
		x_memcpy(tls, bp, dest, Uint64FromInt32(4)*Uint64FromInt64(8))
		(*Trusage)(unsafe.Pointer(ru)).Fru_utime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(0)], Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)]}
		(*Trusage)(unsafe.Pointer(ru)).Fru_stime = Ttimeval{Ftv_sec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)], Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)]}
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_getsubopt(tls *TLS, opt uintptr, keys uintptr, val uintptr) (r int32) {
	var i int32
	var l Tsize_t
	var s uintptr
	var v1 uintptr
	var v2 uintptr
	s = *(*uintptr)(unsafe.Pointer(opt))
	*(*uintptr)(unsafe.Pointer(val)) = UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(opt)) = x_strchr(tls, s, int32(','))
	if *(*uintptr)(unsafe.Pointer(opt)) != 0 {
		v2 = opt
		v1 = *(*uintptr)(unsafe.Pointer(v2))
		*(*uintptr)(unsafe.Pointer(v2))++
		*(*int8)(unsafe.Pointer(v1)) = int8(0)
	} else {
		*(*uintptr)(unsafe.Pointer(opt)) = s + uintptr(x_strlen(tls, s))
	}
	for i = int32(0); *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)) != 0; i++ {
		l = x_strlen(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)))
		if x_strncmp(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)), s, l) != 0 {
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(s + uintptr(l)))) == int32('=') {
			*(*uintptr)(unsafe.Pointer(val)) = s + uintptr(l) + uintptr(1)
		} else {
			if *(*int8)(unsafe.Pointer(s + uintptr(l))) != 0 {
				continue
			}
		}
		return i
	}
	return -int32(1)
}

const m_NGROUPS_MAX = 32

type Tgroup1 = struct {
	Fgr_name   uintptr
	Fgr_passwd uintptr
	Fgr_gid    Tgid_t
	Fgr_mem    uintptr
}

func x_initgroups(tls *TLS, user uintptr, gid Tgid_t) (r int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxValist 0 */
	defer tls.Free(136)
	var _ /* count at bp+128 */ int32
	var _ /* groups at bp+0 */ [32]Tgid_t
	*(*int32)(unsafe.Pointer(bp + 128)) = int32(m_NGROUPS_MAX)
	if x_getgrouplist(tls, user, gid, bp, bp+128) < int32(0) {
		return -int32(1)
	}
	return x_setgroups(tls, uint64(*(*int32)(unsafe.Pointer(bp + 128))), bp)
}

const m_ENOTTY = 25
const m_R = 2
const m_SIOCGSTAMP = 35078
const m_SIOCGSTAMPNS = 35079
const m_SIOCGSTAMPNS_OLD = 35079
const m_SIOCGSTAMP_OLD = 35078
const m_W = 1
const m_WR = 3
const m__IOC_READ = 2
const m__IOC_WRITE = 2
const m___BIG_ENDIAN = 4321

type Tioctl_compat_map = struct {
	Fnew_req     int32
	Fold_req     int32
	Fold_size    uint8
	Fdir         uint8
	Fforce_align uint8
	Fnoffs       uint8
	Foffsets     [8]uint8
}

/* yields a type for a struct with original size n, with a misaligned
 * timeval/timespec expanded from 32- to 64-bit. for use with ioctl
 * number producing macros; only size of result is meaningful. */

type Tv4l2_event = struct {
	Fa           Tuint32_t
	Fb           [8]Tuint64_t
	Fc           [2]Tuint32_t
	Fts          [2]Tuint32_t
	Fd           [9]Tuint32_t
	F__ccgo_pad5 [4]byte
}

var _compat_map = [20]Tioctl_compat_map{
	0: {Fnew_req: int32(m_SIOCGSTAMP), Fold_req: int32(m_SIOCGSTAMP_OLD), Fold_size: uint8(8), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	1: {Fnew_req: int32(m_SIOCGSTAMPNS), Fold_req: int32(m_SIOCGSTAMPNS_OLD), Fold_size: uint8(8), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	2: {Fnew_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('T')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x14))) | Uint64FromInt64(96)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('T')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x14))) | Uint64FromInt64(4)<<Int32FromInt32(16)), Fold_size: uint8(88), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	3: {Fnew_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(128)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(108)<<Int32FromInt32(16)), Fold_size: uint8(108), Fdir: uint8(m_R), Fforce_align: uint8(1), Fnoffs: uint8(8), Foffsets: [8]uint8{
		0: uint8(4),
		1: uint8(8),
		2: uint8(12),
		3: uint8(16),
		4: uint8(52),
		5: uint8(56),
		6: uint8(60),
		7: uint8(64)}},
	4: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x24))) | Uint64FromInt64(128)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x24))) | Uint64FromInt64(108)<<Int32FromInt32(16)), Fold_size: uint8(108), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(8), Foffsets: [8]uint8{
		0: uint8(4),
		1: uint8(8),
		2: uint8(12),
		3: uint8(16),
		4: uint8(52),
		5: uint8(56),
		6: uint8(60),
		7: uint8(64)}},
	5: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('W')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(48)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('W')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(36)<<Int32FromInt32(16)), Fold_size: uint8(36), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(4),
		1: uint8(8)}},
	6: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x23))) | Uint64FromInt64(136)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x23))) | Uint64FromInt64(132)<<Int32FromInt32(16)), Fold_size: uint8(0), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(0)},
	7: {Fnew_req: int32(0), Fold_req: int32(0), Fold_size: uint8(4), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(0)},
	8: {Fnew_req: int32(0), Fold_req: int32(0), Fold_size: uint8(32), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(5), Foffsets: [8]uint8{
		0: uint8(8),
		1: uint8(12),
		2: uint8(16),
		3: uint8(24),
		4: uint8(28)}},
	9: {Fnew_req: int32(0), Fold_req: int32(0), Fold_size: uint8(4), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(0)},
	10: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(9))) | Uint64FromInt64(80)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(9))) | Uint64FromInt64(68)<<Int32FromInt32(16)), Fold_size: uint8(68), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(20),
		1: uint8(24)}},
	11: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(15))) | Uint64FromInt64(80)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(15))) | Uint64FromInt64(68)<<Int32FromInt32(16)), Fold_size: uint8(68), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(20),
		1: uint8(24)}},
	12: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(17))) | Uint64FromInt64(80)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(17))) | Uint64FromInt64(68)<<Int32FromInt32(16)), Fold_size: uint8(68), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(20),
		1: uint8(24)}},
	13: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(93))) | Uint64FromInt64(80)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(93))) | Uint64FromInt64(68)<<Int32FromInt32(16)), Fold_size: uint8(68), Fdir: uint8(m_WR), Fforce_align: uint8(1), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(20),
		1: uint8(24)}},
	14: {Fnew_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(89))) | Uint64FromInt64(136)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(89))) | Uint64FromInt64(128)<<Int32FromInt32(16)), Fold_size: uint8(128), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(uint64(UintptrFromInt32(0) + 80 + UintptrFromInt32(0)*4)),
		1: uint8(uint64(UintptrFromInt32(0) + 80 + UintptrFromInt32(1)*4))}},
	15: {Fnew_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(192)+Int32FromInt32(6))) | Uint64FromInt64(32)<<Int32FromInt32(16)), Fold_req: int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(192)+Int32FromInt32(6))) | Uint64FromInt64(24)<<Int32FromInt32(16)), Fold_size: uint8(22), Fdir: uint8(m_WR), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	16: {Fnew_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('t')<<Int32FromInt32(8))|uint32(Int32FromInt32(63))) | Uint64FromInt64(16)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('t')<<Int32FromInt32(8))|uint32(Int32FromInt32(63))) | Uint64FromInt64(8)<<Int32FromInt32(16)), Fold_size: uint8(8), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	17: {Fnew_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x95))) | Uint64FromInt64(16)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x95))) | Uint64FromInt64(8)<<Int32FromInt32(16)), Fold_size: uint8(8), Fdir: uint8(m_R), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	18: {Fnew_req: int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x96))) | Uint64FromInt64(16)<<Int32FromInt32(16)), Fold_req: int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x96))) | Uint64FromInt64(8)<<Int32FromInt32(16)), Fold_size: uint8(8), Fdir: uint8(m_W), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}},
	19: {Fnew_req: int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromInt32(0x6)<<Int32FromInt32(8))|uint32(Int32FromInt32(0xf))) | Uint64FromInt64(16)<<Int32FromInt32(16)), Fold_req: int32(0x060f), Fold_size: uint8(8), Fdir: uint8(m_W), Fforce_align: uint8(0), Fnoffs: uint8(2), Foffsets: [8]uint8{
		0: uint8(0),
		1: uint8(4)}}}

func _convert_ioctl_struct(tls *TLS, map1 uintptr, old uintptr, new1 uintptr, dir int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var adj int32
	var align int32
	var i int32
	var len1 int32
	var new_offset int32
	var old_offset int32
	var old_size int32
	var ts_offset int32
	var _ /* new_ts at bp+0 */ int64
	var _ /* old_ts at bp+8 */ int64
	var v1 uint64
	new_offset = int32(0)
	old_offset = int32(0)
	old_size = int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fold_size)
	if !(dir&int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fdir) != 0) {
		return
	}
	if !((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fold_size != 0) {
		/* offsets hard-coded for SNDRV_PCM_IOCTL_SYNC_PTR;
		 * if another exception appears this needs changing. */
		_convert_ioctl_struct(tls, map1+uintptr(1)*20, old, new1, dir)
		_convert_ioctl_struct(tls, map1+uintptr(2)*20, old+uintptr(4), new1+uintptr(8), dir)
		/* snd_pcm_mmap_control, special-cased due to kernel
		 * type definition having been botched. */
		adj = int32(0)
		_convert_ioctl_struct(tls, map1+uintptr(3)*20, old+uintptr(68), new1+uintptr(72)+uintptr(adj), dir)
		_convert_ioctl_struct(tls, map1+uintptr(3)*20, old+uintptr(72), new1+uintptr(76)+uintptr(int32(3)*adj), dir)
		return
	}
	i = int32(0)
	for ; i < int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fnoffs); i++ {
		ts_offset = int32(*(*uint8)(unsafe.Pointer(map1 + 12 + uintptr(i))))
		len1 = ts_offset - old_offset
		if dir == int32(m_W) {
			x_memcpy(tls, old+uintptr(old_offset), new1+uintptr(new_offset), uint64(len1))
		} else {
			x_memcpy(tls, new1+uintptr(new_offset), old+uintptr(old_offset), uint64(len1))
		}
		new_offset = new_offset + len1
		old_offset = old_offset + len1
		if (*Tioctl_compat_map)(unsafe.Pointer(map1)).Fforce_align != 0 {
			v1 = uint64(8)
		} else {
			v1 = uint64(UintptrFromInt32(0) + 8)
		}
		align = int32(v1)
		new_offset = new_offset + (align-Int32FromInt32(1))&-new_offset
		if dir == int32(m_W) {
			x_memcpy(tls, bp, new1+uintptr(new_offset), uint64(8))
			*(*int64)(unsafe.Pointer(bp + 8)) = *(*int64)(unsafe.Pointer(bp))
			x_memcpy(tls, old+uintptr(old_offset), bp+8, uint64(8))
		} else {
			x_memcpy(tls, bp+8, old+uintptr(old_offset), uint64(8))
			*(*int64)(unsafe.Pointer(bp)) = *(*int64)(unsafe.Pointer(bp + 8))
			x_memcpy(tls, new1+uintptr(new_offset), bp, uint64(8))
		}
		new_offset = int32(uint64(new_offset) + Uint64FromInt64(8))
		old_offset = int32(uint64(old_offset) + Uint64FromInt64(8))
	}
	if dir == int32(m_W) {
		x_memcpy(tls, old+uintptr(old_offset), new1+uintptr(new_offset), uint64(old_size-old_offset))
	} else {
		x_memcpy(tls, new1+uintptr(new_offset), old+uintptr(old_offset), uint64(old_size-old_offset))
	}
}

func x_ioctl(tls *TLS, fd int32, req int32, va uintptr) (r1 int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var ap Tva_list
	var arg uintptr
	var i int32
	var r int32
	var _ /* u at bp+0 */ struct {
		Fbuf         [0][256]int8
		Falign       int64
		F__ccgo_pad2 [248]byte
	}
	ap = va
	arg = VaUintptr(&ap)
	_ = ap
	r = int32(___syscall3(tls, int64(16), int64(fd), int64(req), int64(arg)))
	if int32(m_SIOCGSTAMP) != int32(m_SIOCGSTAMP_OLD) && req != 0 && r == -int32(m_ENOTTY) {
		i = int32(0)
		for ; uint64(i) < Uint64FromInt64(400)/Uint64FromInt64(20); i++ {
			if _compat_map[i].Fnew_req != req {
				continue
			}
			_convert_ioctl_struct(tls, uintptr(unsafe.Pointer(&_compat_map))+uintptr(i)*20, bp, arg, int32(m_W))
			r = int32(___syscall3(tls, int64(16), int64(fd), int64(_compat_map[i].Fold_req), int64(bp)))
			if r < int32(0) {
				break
			}
			_convert_ioctl_struct(tls, uintptr(unsafe.Pointer(&_compat_map))+uintptr(i)*20, bp, arg, int32(m_R))
			break
		}
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_issetugid(tls *TLS) (r int32) {
	return int32(x___libc.Fsecure)
}

const m_EACCES = 13
const m_F_LOCK = 1
const m_F_RDLCK = 0
const m_F_TEST = 3
const m_F_TLOCK = 2
const m_F_ULOCK = 0
const m_F_UNLCK = 2
const m_F_WRLCK = 1

func x_lockf(tls *TLS, fd int32, op int32, size Toff_t) (r int32) {
	bp := tls.Alloc(48) /* tlsAllocs 32 maxValist 1 */
	defer tls.Free(48)
	var _ /* l at bp+0 */ Tflock
	*(*Tflock)(unsafe.Pointer(bp)) = Tflock{Fl_type: int16(m_F_WRLCK), Fl_whence: int16(m_SEEK_CUR), Fl_len: size}
	switch op {
	case int32(m_F_TEST):
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = int16(m_F_RDLCK)
		if x_fcntl(tls, fd, int32(m_F_GETLK), VaList(bp+40, bp)) < int32(0) {
			return -int32(1)
		}
		if int32((*(*Tflock)(unsafe.Pointer(bp))).Fl_type) == int32(m_F_UNLCK) || (*(*Tflock)(unsafe.Pointer(bp))).Fl_pid == x_getpid(tls) {
			return int32(0)
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EACCES)
		return -int32(1)
	case int32(m_F_ULOCK):
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = int16(m_F_UNLCK)
		fallthrough
	case int32(m_F_TLOCK):
		return x_fcntl(tls, fd, int32(m_F_SETLK), VaList(bp+40, bp))
	case int32(m_F_LOCK):
		return x_fcntl(tls, fd, int32(m_F_SETLKW), VaList(bp+40, bp))
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
	return -int32(1)
}

const m_TIOCSCTTY = 21518

func x_login_tty(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	x_setsid(tls)
	if x_ioctl(tls, fd, int32(m_TIOCSCTTY), VaList(bp+8, UintptrFromInt32(0))) != 0 {
		return -int32(1)
	}
	x_dup2(tls, fd, int32(0))
	x_dup2(tls, fd, int32(1))
	x_dup2(tls, fd, int32(2))
	if fd > int32(2) {
		x_close(tls, fd)
	}
	return int32(0)
}

const m_SEEK_END = 2

type Tmntent = struct {
	Fmnt_fsname uintptr
	Fmnt_dir    uintptr
	Fmnt_type   uintptr
	Fmnt_opts   uintptr
	Fmnt_freq   int32
	Fmnt_passno int32
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _internal_buf uintptr
var _internal_bufsize Tsize_t

func x_setmntent(tls *TLS, name uintptr, mode uintptr) (r uintptr) {
	return x_fopen(tls, name, mode)
}

func x_endmntent(tls *TLS, f uintptr) (r int32) {
	if f != 0 {
		x_fclose(tls, f)
	}
	return int32(1)
}

func x_getmntent_r(tls *TLS, f uintptr, mnt uintptr, linebuf uintptr, buflen int32) (r uintptr) {
	bp := tls.Alloc(120) /* tlsAllocs 32 maxValist 10 */
	defer tls.Free(120)
	var i Tsize_t
	var len1 Tsize_t
	var use_internal int32
	var _ /* n at bp+0 */ [8]int32
	use_internal = BoolInt32(linebuf == uintptr(unsafe.Pointer(&_internal_buf)))
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_freq = int32(0)
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_passno = int32(0)
	for cond := true; cond; cond = int32(*(*int8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(0)])))) == int32('#') || uint64((*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)]) == len1 {
		if use_internal != 0 {
			x_getline(tls, uintptr(unsafe.Pointer(&_internal_buf)), uintptr(unsafe.Pointer(&_internal_bufsize)), f)
			linebuf = _internal_buf
		} else {
			x_fgets(tls, linebuf, buflen, f)
		}
		if x_feof(tls, f) != 0 || x_ferror(tls, f) != 0 {
			return uintptr(0)
		}
		if !(x_strchr(tls, linebuf, int32('\n')) != 0) {
			x_fscanf(tls, f, ts+1310, 0)
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ERANGE)
			return uintptr(0)
		}
		len1 = x_strlen(tls, linebuf)
		if len1 > uint64(m_INT_MAX) {
			continue
		}
		for i = uint64(0); i < Uint64FromInt64(32)/Uint64FromInt64(4); i++ {
			(*(*[8]int32)(unsafe.Pointer(bp)))[i] = int32(len1)
		}
		x_sscanf(tls, linebuf, ts+1322, VaList(bp+40, bp, bp+uintptr(1)*4, bp+uintptr(2)*4, bp+uintptr(3)*4, bp+uintptr(4)*4, bp+uintptr(5)*4, bp+uintptr(6)*4, bp+uintptr(7)*4, mnt+32, mnt+36))
	}
	*(*int8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)]))) = int8(0)
	*(*int8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(3)]))) = int8(0)
	*(*int8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(5)]))) = int8(0)
	*(*int8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(7)]))) = int8(0)
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_fsname = linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(0)])
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_dir = linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)])
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_type = linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)])
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts = linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)])
	return mnt
}

func x_getmntent(tls *TLS, f uintptr) (r uintptr) {
	return x_getmntent_r(tls, f, uintptr(unsafe.Pointer(&_mnt)), uintptr(unsafe.Pointer(&_internal_buf)), int32(0))
}

var _mnt Tmntent

func x_addmntent(tls *TLS, f uintptr, mnt uintptr) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 0 maxValist 6 */
	defer tls.Free(56)
	if x_fseek(tls, f, int64(0), int32(m_SEEK_END)) != 0 {
		return int32(1)
	}
	return BoolInt32(x_fprintf(tls, f, ts+1361, VaList(bp+8, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_fsname, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_dir, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_type, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_freq, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_passno)) < int32(0))
}

func x_hasmntopt(tls *TLS, mnt uintptr, opt uintptr) (r uintptr) {
	return x_strstr(tls, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, opt)
}

const m_ENAMETOOLONG = 36
const m_FTW_D = 2
const m_FTW_DEPTH = 8
const m_FTW_DNR = 3
const m_FTW_DP = 6
const m_FTW_F = 1
const m_FTW_MOUNT = 2
const m_FTW_NS = 4
const m_FTW_SL = 5
const m_FTW_SLN = 7
const m_S_IFLNK = 40960

type Thistory = struct {
	Fchain uintptr
	Fdev   Tdev_t
	Fino   Tino_t
	Flevel int32
	Fbase  int32
}

func _do_nftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32, h uintptr) (r1 int32) {
	bp := tls.Alloc(184) /* tlsAllocs 184 maxValist 0 */
	defer tls.Free(184)
	var d uintptr
	var de uintptr
	var dfd int32
	var err int32
	var j Tsize_t
	var k Tsize_t
	var l Tsize_t
	var r int32
	var type1 int32
	var _ /* lev at bp+176 */ TFTW
	var _ /* new at bp+144 */ Thistory
	var _ /* st at bp+0 */ Tstat
	var v1 uint64
	var v10 bool
	var v2 Tino_t
	var v3 int32
	var v4 int32
	var v5 int32
	var v6 bool
	var v7 uintptr
	var v8 int32
	var v9 int32
	l = x_strlen(tls, path)
	if l != 0 && int32(*(*int8)(unsafe.Pointer(path + uintptr(l-Uint64FromInt32(1))))) == int32('/') {
		v1 = l - uint64(1)
	} else {
		v1 = l
	}
	j = v1
	v2 = Uint64FromInt32(0)
	(*(*Tstat)(unsafe.Pointer(bp))).Fst_ino = v2
	(*(*Tstat)(unsafe.Pointer(bp))).Fst_dev = v2
	if flags&int32(m_FTW_PHYS) != 0 {
		v3 = x_lstat(tls, path, bp)
	} else {
		v3 = BoolInt32(x_stat(tls, path, bp) < int32(0))
	}
	if v3 != 0 {
		if !(flags&Int32FromInt32(m_FTW_PHYS) != 0) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOENT) && !(x_lstat(tls, path, bp) != 0) {
			type1 = int32(m_FTW_SLN)
		} else {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EACCES) {
				return -int32(1)
			} else {
				type1 = int32(m_FTW_NS)
			}
		}
	} else {
		if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFDIR) {
			if flags&int32(m_FTW_DEPTH) != 0 {
				type1 = int32(m_FTW_DP)
			} else {
				type1 = int32(m_FTW_D)
			}
		} else {
			if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFLNK) {
				if flags&int32(m_FTW_PHYS) != 0 {
					type1 = int32(m_FTW_SL)
				} else {
					type1 = int32(m_FTW_SLN)
				}
			} else {
				type1 = int32(m_FTW_F)
			}
		}
	}
	if flags&int32(m_FTW_MOUNT) != 0 && h != 0 && type1 != int32(m_FTW_NS) && (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev != (*Thistory)(unsafe.Pointer(h)).Fdev {
		return int32(0)
	}
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fchain = h
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fdev = (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fino = (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino
	if h != 0 {
		v4 = (*Thistory)(unsafe.Pointer(h)).Flevel + int32(1)
	} else {
		v4 = int32(0)
	}
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Flevel = v4
	(*(*Thistory)(unsafe.Pointer(bp + 144))).Fbase = int32(j + uint64(1))
	(*(*TFTW)(unsafe.Pointer(bp + 176))).Flevel = (*(*Thistory)(unsafe.Pointer(bp + 144))).Flevel
	if h != 0 {
		(*(*TFTW)(unsafe.Pointer(bp + 176))).Fbase = (*Thistory)(unsafe.Pointer(h)).Fbase
	} else {
		for k = j; k != 0 && int32(*(*int8)(unsafe.Pointer(path + uintptr(k)))) == int32('/'); k-- {
		}
		for ; k != 0 && int32(*(*int8)(unsafe.Pointer(path + uintptr(k-Uint64FromInt32(1))))) != int32('/'); k-- {
		}
		(*(*TFTW)(unsafe.Pointer(bp + 176))).Fbase = int32(k)
	}
	if type1 == int32(m_FTW_D) || type1 == int32(m_FTW_DP) {
		dfd = x_open(tls, path, int32(m_O_RDONLY), 0)
		err = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		if dfd < int32(0) && err == int32(m_EACCES) {
			type1 = int32(m_FTW_DNR)
		}
		if !(fd_limit != 0) {
			x_close(tls, dfd)
		}
	}
	if v6 = !(flags&Int32FromInt32(m_FTW_DEPTH) != 0); v6 {
		v5 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+176)
		r = v5
	}
	if v6 && v5 != 0 {
		return r
	}
	for ; h != 0; h = (*Thistory)(unsafe.Pointer(h)).Fchain {
		if (*Thistory)(unsafe.Pointer(h)).Fdev == (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev && (*Thistory)(unsafe.Pointer(h)).Fino == (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino {
			return int32(0)
		}
	}
	if (type1 == int32(m_FTW_D) || type1 == int32(m_FTW_DP)) && fd_limit != 0 {
		if dfd < int32(0) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = err
			return -int32(1)
		}
		d = x_fdopendir(tls, dfd)
		if d != 0 {
			for {
				v7 = x_readdir(tls, d)
				de = v7
				if !(v7 != 0) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(de + 19 + UintptrFromInt32(0)))) == int32('.') && (!(*(*int8)(unsafe.Pointer(de + 19 + UintptrFromInt32(1))) != 0) || int32(*(*int8)(unsafe.Pointer(de + 19 + UintptrFromInt32(1)))) == int32('.') && !(*(*int8)(unsafe.Pointer(de + 19 + UintptrFromInt32(2))) != 0)) {
					continue
				}
				if x_strlen(tls, de+19) >= uint64(m_PATH_MAX)-l {
					*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENAMETOOLONG)
					x_closedir(tls, d)
					return -int32(1)
				}
				*(*int8)(unsafe.Pointer(path + uintptr(j))) = int8('/')
				x_strcpy(tls, path+uintptr(j)+uintptr(1), de+19)
				v8 = _do_nftw(tls, path, fn, fd_limit-int32(1), flags, bp+144)
				r = v8
				if v8 != 0 {
					x_closedir(tls, d)
					return r
				}
			}
			x_closedir(tls, d)
		} else {
			x_close(tls, dfd)
			return -int32(1)
		}
	}
	*(*int8)(unsafe.Pointer(path + uintptr(l))) = int8(0)
	if v10 = flags&int32(m_FTW_DEPTH) != 0; v10 {
		v9 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+176)
		r = v9
	}
	if v10 && v9 != 0 {
		return r
	}
	return int32(0)
}

func x_nftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32) (r1 int32) {
	bp := tls.Alloc(4104) /* tlsAllocs 4104 maxValist 0 */
	defer tls.Free(4104)
	var l Tsize_t
	var r int32
	var _ /* cs at bp+0 */ int32
	var _ /* pathbuf at bp+4 */ [4097]int8
	if fd_limit <= int32(0) {
		return int32(0)
	}
	l = x_strlen(tls, path)
	if l > uint64(m_PATH_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENAMETOOLONG)
		return -int32(1)
	}
	x_memcpy(tls, bp+4, path, l+uint64(1))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	r = _do_nftw(tls, bp+4, fn, fd_limit, flags, UintptrFromInt32(0))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return r
}

const m_TCSANOW = 0
const m_TIOCGPTN = 2147767344
const m_TIOCSPTLCK = 1074025521
const m_TIOCSWINSZ = 21524

func x_openpty(tls *TLS, pm uintptr, ps uintptr, name uintptr, tio uintptr, ws uintptr) (r int32) {
	bp := tls.Alloc(48) /* tlsAllocs 32 maxValist 1 */
	defer tls.Free(48)
	var m int32
	var s int32
	var _ /* buf at bp+8 */ [20]int8
	var _ /* cs at bp+4 */ int32
	var _ /* n at bp+0 */ int32
	var v1 int32
	*(*int32)(unsafe.Pointer(bp)) = int32(0)
	m = x_open(tls, ts+1380, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOCTTY), 0)
	if m < int32(0) {
		return -int32(1)
	}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+4)
	if x_ioctl(tls, m, int32(m_TIOCSPTLCK), VaList(bp+40, bp)) != 0 || x_ioctl(tls, m, Int32FromUint32(m_TIOCGPTN), VaList(bp+40, bp)) != 0 {
		goto fail
	}
	if !(name != 0) {
		name = bp + 8
	}
	x_snprintf(tls, name, uint64(20), ts+1390, VaList(bp+40, *(*int32)(unsafe.Pointer(bp))))
	v1 = x_open(tls, name, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOCTTY), 0)
	s = v1
	if v1 < int32(0) {
		goto fail
	}
	if tio != 0 {
		x_tcsetattr(tls, s, int32(m_TCSANOW), tio)
	}
	if ws != 0 {
		x_ioctl(tls, s, int32(m_TIOCSWINSZ), VaList(bp+40, ws))
	}
	*(*int32)(unsafe.Pointer(pm)) = m
	*(*int32)(unsafe.Pointer(ps)) = s
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
	return int32(0)
fail:
	x_close(tls, m)
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
	return -int32(1)
}

func x_ptsname(tls *TLS, fd int32) (r uintptr) {
	var err int32
	err = x___ptsname_r(tls, fd, uintptr(unsafe.Pointer(&_buf2)), uint64(22))
	if err != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = err
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_buf2))
}

var _buf2 [22]int8

const m_ENOSPC = 28

func x_posix_openpt(tls *TLS, flags int32) (r1 int32) {
	var r int32
	r = x_open(tls, ts+1380, flags, 0)
	if r < int32(0) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOSPC) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
	}
	return r
}

func x_grantpt(tls *TLS, fd int32) (r int32) {
	return int32(0)
}

func x_unlockpt(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var _ /* unlock at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = int32(0)
	return x_ioctl(tls, fd, int32(m_TIOCSPTLCK), VaList(bp+16, bp))
}

func x___ptsname_r(tls *TLS, fd int32, buf uintptr, len1 Tsize_t) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var err int32
	var _ /* pty at bp+0 */ int32
	var v1 int32
	if !(buf != 0) {
		len1 = uint64(0)
	}
	v1 = int32(___syscall3(tls, int64(16), int64(fd), int64(Uint32FromUint32(0x80045430)), int64(bp)))
	err = v1
	if v1 != 0 {
		return -err
	}
	if uint64(x_snprintf(tls, buf, len1, ts+1390, VaList(bp+16, *(*int32)(unsafe.Pointer(bp))))) >= len1 {
		return int32(m_ERANGE)
	}
	return int32(0)
}

func x_realpath(tls *TLS, filename uintptr, resolved uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1402, int32(5), uintptr(unsafe.Pointer(&___func__19)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__19 = [9]int8{'r', 'e', 'a', 'l', 'p', 'a', 't', 'h'}

func x_setdomainname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(171), int64(name), int64(len1)))))
}

func x_setpriority(tls *TLS, which int32, who Tid_t, prio int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(141), int64(which), int64(who), int64(prio)))))
}

type Tctx1 = struct {
	Flim [2]uint64
	Fres int32
	Ferr int32
}

func _do_setrlimit(tls *TLS, p uintptr) {
	var c uintptr
	c = p
	if (*Tctx1)(unsafe.Pointer(c)).Ferr > int32(0) {
		return
	}
	(*Tctx1)(unsafe.Pointer(c)).Ferr = int32(-___syscall2(tls, int64(160), int64((*Tctx1)(unsafe.Pointer(c)).Fres), int64(c)))
}

func x_setrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxValist 0 */
	defer tls.Free(40)
	var ret int32
	var _ /* c at bp+16 */ Tctx1
	var _ /* tmp at bp+0 */ Trlimit
	var v1 uint64
	var v2 uint64
	if ^Uint64FromUint64(0) != ^Uint64FromUint64(0) {
		*(*Trlimit)(unsafe.Pointer(bp)) = *(*Trlimit)(unsafe.Pointer(rlim))
		{
			if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur >= ^Uint64FromUint64(0) {
				(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = ^Uint64FromUint64(0)
			}
		}
		{
			if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max >= ^Uint64FromUint64(0) {
				(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max = ^Uint64FromUint64(0)
			}
		}
		rlim = bp
	}
	ret = int32(___syscall4(tls, int64(302), int64(Int32FromInt32(0)), int64(resource), int64(rlim), int64(Int32FromInt32(0))))
	if ret != -int32(m_ENOSYS) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur < ^Uint64FromUint64(0) {
		v1 = (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur
	} else {
		v1 = ^Uint64FromUint64(0)
	}
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max < ^Uint64FromUint64(0) {
		v2 = (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max
	} else {
		v2 = ^Uint64FromUint64(0)
	}
	*(*Tctx1)(unsafe.Pointer(bp + 16)) = Tctx1{Flim: [2]uint64{
		0: v1,
		1: v2}, Fres: resource, Ferr: -int32(1)}
	x___synccall(tls, __ccgo_fp(_do_setrlimit), bp+16)
	if (*(*Tctx1)(unsafe.Pointer(bp + 16))).Ferr != 0 {
		if (*(*Tctx1)(unsafe.Pointer(bp + 16))).Ferr > int32(0) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = (*(*Tctx1)(unsafe.Pointer(bp + 16))).Ferr
		}
		return -int32(1)
	}
	return int32(0)
}

func x_syscall(tls *TLS, n int64, va uintptr) (r int64) {
	var a Tsyscall_arg_t
	var ap Tva_list
	var b Tsyscall_arg_t
	var c Tsyscall_arg_t
	var d Tsyscall_arg_t
	var e Tsyscall_arg_t
	var f Tsyscall_arg_t
	ap = va
	a = VaInt64(&ap)
	b = VaInt64(&ap)
	c = VaInt64(&ap)
	d = VaInt64(&ap)
	e = VaInt64(&ap)
	f = VaInt64(&ap)
	_ = ap
	return x___syscall_ret(tls, uint64(___syscall6(tls, n, a, b, c, d, e, f)))
}

const m_ECONNREFUSED = 111
const m_ECONNRESET = 104
const m_ENOTCONN = 107
const m_EPIPE = 32
const m_LOG_CONS = 2
const m_LOG_FACMASK = 1016
const m_LOG_NDELAY = 8
const m_LOG_PERROR = 32
const m_LOG_PID = 1
const m_PF_LOCAL = 1
const m_SOCK_CLOEXEC = 524288
const m_SOCK_DGRAM = 2

type Tsocklen_t = uint32

type Tsa_family_t = uint16

type Tmsghdr = struct {
	Fmsg_name       uintptr
	Fmsg_namelen    Tsocklen_t
	Fmsg_iov        uintptr
	Fmsg_iovlen     int32
	F__pad1         int32
	Fmsg_control    uintptr
	Fmsg_controllen Tsocklen_t
	F__pad2         int32
	Fmsg_flags      int32
	F__ccgo_pad9    [4]byte
}

type Tcmsghdr = struct {
	Fcmsg_len   Tsocklen_t
	F__pad1     int32
	Fcmsg_level int32
	Fcmsg_type  int32
}

type Tlinger = struct {
	Fl_onoff  int32
	Fl_linger int32
}

type Tsockaddr = struct {
	Fsa_family Tsa_family_t
	Fsa_data   [14]int8
}

type Tsockaddr_storage = struct {
	Fss_family    Tsa_family_t
	F__ss_padding [118]int8
	F__ss_align   uint64
}

type T__ucontext2 = Tucontext_t2

var _lock4 [1]int32
var _log_ident [32]int8
var _log_opt int32
var _log_facility = Int32FromInt32(1) << Int32FromInt32(3)
var _log_mask = int32(0xff)
var _log_fd = -int32(1)

func x_setlogmask(tls *TLS, maskpri int32) (r int32) {
	var ret int32
	x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	ret = _log_mask
	if maskpri != 0 {
		_log_mask = maskpri
	}
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	return ret
}

var _log_addr = struct {
	Fsun_family  int16
	Fsun_path    [9]int8
	F__ccgo_pad2 [1]byte
}{Fsun_family: int16(m_PF_LOCAL), Fsun_path: [9]int8{'/', 'd', 'e', 'v', '/', 'l', 'o', 'g'}}

func x_closelog(tls *TLS) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* cs at bp+0 */ int32
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	x_close(tls, _log_fd)
	_log_fd = -int32(1)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func ___openlog(tls *TLS) {
	_log_fd = x_socket(tls, int32(m_PF_LOCAL), Int32FromInt32(m_SOCK_DGRAM)|Int32FromInt32(m_SOCK_CLOEXEC), int32(0))
	if _log_fd >= int32(0) {
		x_connect(tls, _log_fd, uintptr(unsafe.Pointer(&_log_addr)), uint32(12))
	}
}

func x_openlog(tls *TLS, ident uintptr, opt int32, facility int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var n Tsize_t
	var _ /* cs at bp+0 */ int32
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	if ident != 0 {
		n = x_strnlen(tls, ident, Uint64FromInt64(32)-Uint64FromInt32(1))
		x_memcpy(tls, uintptr(unsafe.Pointer(&_log_ident)), ident, n)
		_log_ident[n] = int8(0)
	} else {
		_log_ident[int32(0)] = int8(0)
	}
	_log_opt = opt
	_log_facility = facility
	if opt&int32(m_LOG_NDELAY) != 0 && _log_fd < int32(0) {
		___openlog(tls)
	}
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func _is_lost_conn(tls *TLS, e int32) (r int32) {
	return BoolInt32(e == int32(m_ECONNREFUSED) || e == int32(m_ECONNRESET) || e == int32(m_ENOTCONN) || e == int32(m_EPIPE))
}

func __vsyslog(tls *TLS, priority int32, message uintptr, ap Tva_list) {
	bp := tls.Alloc(1176) /* tlsAllocs 1112 maxValist 7 */
	defer tls.Free(1176)
	var errno_save int32
	var fd int32
	var l int32
	var l2 int32
	var pid int32
	var _ /* buf at bp+80 */ [1024]int8
	var _ /* hlen at bp+1104 */ int32
	var _ /* now at bp+16 */ Ttime_t
	var _ /* timebuf at bp+0 */ [16]int8
	var _ /* tm at bp+24 */ Ttm
	var v1 int32
	var v2 int32
	errno_save = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if _log_fd < int32(0) {
		___openlog(tls)
	}
	if !(priority&Int32FromInt32(m_LOG_FACMASK) != 0) {
		priority = priority | _log_facility
	}
	*(*Ttime_t)(unsafe.Pointer(bp + 16)) = x_time(tls, UintptrFromInt32(0))
	x___gmtime_r(tls, bp+16, bp+24)
	x_strftime(tls, bp, uint64(16), ts+1422, bp+24)
	if _log_opt&int32(m_LOG_PID) != 0 {
		v1 = x_getpid(tls)
	} else {
		v1 = int32(0)
	}
	pid = v1
	l = x_snprintf(tls, bp+80, uint64(1024), ts+1431, VaList(bp+1120, priority, bp, bp+1104, uintptr(unsafe.Pointer(&_log_ident)), ts+1453+BoolUintptr(!(pid != 0)), pid, ts+1455+BoolUintptr(!(pid != 0))))
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = errno_save
	l2 = x_vsnprintf(tls, bp+80+uintptr(l), uint64(1024)-uint64(l), message, ap)
	if l2 >= int32(0) {
		if uint64(l2) >= uint64(1024)-uint64(l) {
			l = int32(Uint64FromInt64(1024) - Uint64FromInt32(1))
		} else {
			l = l + l2
		}
		if int32((*(*[1024]int8)(unsafe.Pointer(bp + 80)))[l-int32(1)]) != int32('\n') {
			v2 = l
			l++
			(*(*[1024]int8)(unsafe.Pointer(bp + 80)))[v2] = int8('\n')
		}
		if x_send(tls, _log_fd, bp+80, uint64(l), int32(0)) < int64(0) && (!(_is_lost_conn(tls, *(*int32)(unsafe.Pointer(x___errno_location(tls)))) != 0) || x_connect(tls, _log_fd, uintptr(unsafe.Pointer(&_log_addr)), uint32(12)) < int32(0) || x_send(tls, _log_fd, bp+80, uint64(l), int32(0)) < int64(0)) && _log_opt&int32(m_LOG_CONS) != 0 {
			fd = x_open(tls, ts+1146, Int32FromInt32(m_O_WRONLY)|Int32FromInt32(m_O_NOCTTY)|Int32FromInt32(m_O_CLOEXEC), 0)
			if fd >= int32(0) {
				x_dprintf(tls, fd, ts+1457, VaList(bp+1120, l-*(*int32)(unsafe.Pointer(bp + 1104)), bp+80+uintptr(*(*int32)(unsafe.Pointer(bp + 1104)))))
				x_close(tls, fd)
			}
		}
		if _log_opt&int32(m_LOG_PERROR) != 0 {
			x_dprintf(tls, int32(2), ts+1457, VaList(bp+1120, l-*(*int32)(unsafe.Pointer(bp + 1104)), bp+80+uintptr(*(*int32)(unsafe.Pointer(bp + 1104)))))
		}
	}
}

func ___vsyslog(tls *TLS, priority int32, message uintptr, ap Tva_list) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* cs at bp+0 */ int32
	if !(_log_mask&(Int32FromInt32(1)<<(priority&Int32FromInt32(7))) != 0) || priority & ^Int32FromInt32(0x3ff) != 0 {
		return
	}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	x___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	__vsyslog(tls, priority, message, ap)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func x_syslog(tls *TLS, priority int32, message uintptr, va uintptr) {
	var ap Tva_list
	ap = va
	___vsyslog(tls, priority, message, ap)
	_ = ap
}

type Tutsname1 = struct {
	Fsysname      [65]int8
	Fnodename     [65]int8
	Frelease      [65]int8
	Fversion      [65]int8
	Fmachine      [65]int8
	F__domainname [65]int8
}

func x_uname(tls *TLS, uts uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(63), int64(uts)))))
}

type Twordexp_t = struct {
	Fwe_wordc Tsize_t
	Fwe_wordv uintptr
	Fwe_offs  Tsize_t
}

type Tucontext_t4 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

func x_wordexp(tls *TLS, s uintptr, we uintptr, flags int32) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1462, int32(17), uintptr(unsafe.Pointer(&___func__20)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__20 = [8]int8{'w', 'o', 'r', 'd', 'e', 'x', 'p'}

func x_wordfree(tls *TLS, we uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1462, int32(22), uintptr(unsafe.Pointer(&___func__21)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__21 = [9]int8{'w', 'o', 'r', 'd', 'f', 'r', 'e', 'e'}

func x___madvise(tls *TLS, addr uintptr, len1 Tsize_t, advice int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(28), int64(addr), int64(len1), int64(advice)))))
}

func x_mincore(tls *TLS, addr uintptr, len1 Tsize_t, vec uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(27), int64(addr), int64(len1), int64(vec)))))
}

func x_mlock(tls *TLS, addr uintptr, len1 Tsize_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(149), int64(addr), int64(len1)))))
}

func x_mlockall(tls *TLS, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(151), int64(flags)))))
}

const m_EPERM = 1
const m_SYSCALL_MMAP2_UNIT = 4096
const m_UNIT1 = 1

func _dummy8(tls *TLS) {
}

func x___mmap(tls *TLS, start uintptr, len1 Tsize_t, prot int32, flags int32, fd int32, off Toff_t) (r uintptr) {
	var ret int64
	if uint64(off)&(-Uint64FromUint64(0x2000)<<(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1))|(Uint64FromUint64(4096)-Uint64FromInt32(1))) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(-Int32FromInt32(1))
	}
	if len1 >= uint64(Int64FromInt64(0x7fffffffffffffff)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(-Int32FromInt32(1))
	}
	if flags&int32(m_MAP_FIXED) != 0 {
		x___vm_wait(tls)
	}
	ret = ___syscall6(tls, int64(9), int64(start), int64(len1), int64(prot), int64(flags), int64(fd), off)
	/* Fixup incorrect EPERM from kernel. */
	if ret == int64(-int32(m_EPERM)) && !(start != 0) && flags&int32(m_MAP_ANON) != 0 && !(flags&Int32FromInt32(m_MAP_FIXED) != 0) {
		ret = int64(-int32(m_ENOMEM))
	}
	return uintptr(x___syscall_ret(tls, uint64(ret)))
}

func x___mprotect(tls *TLS, addr uintptr, len1 Tsize_t, prot int32) (r int32) {
	var end Tsize_t
	var start Tsize_t
	start = uint64(addr) & uint64(-Int32FromInt32(m_PAGESIZE))
	end = uint64(addr+uintptr(len1)+UintptrFromInt32(m_PAGESIZE)-UintptrFromInt32(1)) & uint64(-Int32FromInt32(m_PAGESIZE))
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(10), int64(start), int64(end-start), int64(prot)))))
}

const m_MREMAP_FIXED = 2

func _dummy9(tls *TLS) {
}

func x___mremap(tls *TLS, old_addr uintptr, old_len Tsize_t, new_len Tsize_t, flags int32, va uintptr) (r uintptr) {
	var ap Tva_list
	var new_addr uintptr
	new_addr = uintptr(0)
	if new_len >= uint64(Int64FromInt64(0x7fffffffffffffff)) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
		return uintptr(-Int32FromInt32(1))
	}
	if flags&int32(m_MREMAP_FIXED) != 0 {
		x___vm_wait(tls)
		ap = va
		new_addr = VaUintptr(&ap)
		_ = ap
	}
	return uintptr(x___syscall_ret(tls, uint64(___syscall5(tls, int64(25), int64(old_addr), int64(old_len), int64(new_len), int64(flags), int64(new_addr)))))
}

func x_msync(tls *TLS, start uintptr, len1 Tsize_t, flags int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(26), int64(start), int64(len1), int64(flags), int64(0), int64(0), int64(0)))))
}

func x_munlock(tls *TLS, addr uintptr, len1 Tsize_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(150), int64(addr), int64(len1)))))
}

func x_munlockall(tls *TLS) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall0(tls, int64(152)))))
}

func _dummy10(tls *TLS) {
}

func x___munmap(tls *TLS, start uintptr, len1 Tsize_t) (r int32) {
	x___vm_wait(tls)
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(11), int64(start), int64(len1)))))
}

const m_MADV_DONTNEED = 4

func x_posix_madvise(tls *TLS, addr uintptr, len1 Tsize_t, advice int32) (r int32) {
	if advice == int32(m_MADV_DONTNEED) {
		return int32(0)
	}
	return int32(-___syscall3(tls, int64(28), int64(addr), int64(len1), int64(advice)))
}

const m_O_NOFOLLOW = 131072

func x___shm_mapname(tls *TLS, name uintptr, buf uintptr) (r uintptr) {
	var p uintptr
	var v1 uintptr
	for int32(*(*int8)(unsafe.Pointer(name))) == int32('/') {
		name++
	}
	v1 = x___strchrnul(tls, name, int32('/'))
	p = v1
	if *(*int8)(unsafe.Pointer(v1)) != 0 || p == name || int64(p)-int64(name) <= int64(2) && int32(*(*int8)(unsafe.Pointer(name + UintptrFromInt32(0)))) == int32('.') && int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))))) == int32('.') {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	if int64(p)-int64(name) > int64(m_NAME_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENAMETOOLONG)
		return uintptr(0)
	}
	x_memcpy(tls, buf, ts+1481, uint64(9))
	x_memcpy(tls, buf+uintptr(9), name, uint64(int64(p)-int64(name)+int64(1)))
	return buf
}

func x_shm_open(tls *TLS, name uintptr, flag int32, mode Tmode_t) (r int32) {
	bp := tls.Alloc(288) /* tlsAllocs 272 maxValist 1 */
	defer tls.Free(288)
	var fd int32
	var _ /* buf at bp+4 */ [265]int8
	var _ /* cs at bp+0 */ int32
	var v1 uintptr
	v1 = x___shm_mapname(tls, name, bp+4)
	name = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	fd = x_open(tls, name, flag|int32(m_O_NOFOLLOW)|int32(m_O_CLOEXEC)|int32(m_O_NONBLOCK), VaList(bp+280, mode))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return fd
}

func x_shm_unlink(tls *TLS, name uintptr) (r int32) {
	bp := tls.Alloc(272) /* tlsAllocs 272 maxValist 0 */
	defer tls.Free(272)
	var _ /* buf at bp+0 */ [265]int8
	var v1 uintptr
	v1 = x___shm_mapname(tls, name, bp)
	name = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	return x_unlink(tls, name)
}

type Tmqd_t = int32

type Tmq_attr = struct {
	Fmq_flags   int64
	Fmq_maxmsg  int64
	Fmq_msgsize int64
	Fmq_curmsgs int64
	F__unused   [4]int64
}

func x_mq_close(tls *TLS, mqd Tmqd_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(3), int64(mqd)))))
}

func x_mq_getattr(tls *TLS, mqd Tmqd_t, attr uintptr) (r int32) {
	return x_mq_setattr(tls, mqd, uintptr(0), attr)
}

const m_MSG_NOSIGNAL = 16384
const m_MSG_WAITALL = 256
const m_PF_NETLINK = 16
const m_PTHREAD_CREATE_JOINABLE = 0
const m_SOCK_RAW = 3

type Targs = struct {
	Fsem  Tsem_t
	Fsock int32
	Fmqd  Tmqd_t
	Ferr  int32
	Fsev  uintptr
}

func _start(tls *TLS, p uintptr) (r uintptr) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxValist 0 */
	defer tls.Free(96)
	var args uintptr
	var err int32
	var func1 uintptr
	var n Tssize_t
	var s int32
	var val Tsigval
	var _ /* buf at bp+0 */ [32]int8
	var _ /* sev2 at bp+32 */ Tsigevent
	var v1 int32
	args = p
	s = (*Targs)(unsafe.Pointer(args)).Fsock
	func1 = (*(*struct {
		Fsigev_notify_function   uintptr
		Fsigev_notify_attributes uintptr
	})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer((*Targs)(unsafe.Pointer(args)).Fsev)).F__sev_fields))).Fsigev_notify_function
	val = (*Tsigevent)(unsafe.Pointer((*Targs)(unsafe.Pointer(args)).Fsev)).Fsigev_value
	(*(*Tsigevent)(unsafe.Pointer(bp + 32))).Fsigev_notify = int32(m_SIGEV_THREAD)
	(*(*Tsigevent)(unsafe.Pointer(bp + 32))).Fsigev_signo = s
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigevent)(unsafe.Pointer(bp + 32))).Fsigev_value)))) = uintptr(unsafe.Pointer(&_zeros))
	v1 = int32(-___syscall2(tls, int64(244), int64((*Targs)(unsafe.Pointer(args)).Fmqd), int64(bp+32)))
	err = v1
	(*Targs)(unsafe.Pointer(args)).Ferr = v1
	x_sem_post(tls, args)
	if err != 0 {
		return uintptr(0)
	}
	___pthread_detach(tls, ___pthread_self_internal(tls))
	n = x_recv(tls, s, bp, uint64(32), Int32FromInt32(m_MSG_NOSIGNAL)|Int32FromInt32(m_MSG_WAITALL))
	x_close(tls, s)
	if uint64(n) == uint64(32) && int32((*(*[32]int8)(unsafe.Pointer(bp)))[Uint64FromInt64(32)-Uint64FromInt32(1)]) == int32(1) {
		(*(*func(*TLS, Tsigval))(unsafe.Pointer(&struct{ uintptr }{func1})))(tls, val)
	}
	return uintptr(0)
}

var _zeros [32]int8

func x_mq_notify(tls *TLS, mqd Tmqd_t, sev uintptr) (r int32) {
	bp := tls.Alloc(384) /* tlsAllocs 384 maxValist 0 */
	defer tls.Free(384)
	var s int32
	var _ /* allmask at bp+128 */ Tsigset_t
	var _ /* args at bp+0 */ Targs
	var _ /* attr at bp+56 */ Tpthread_attr_t
	var _ /* cs at bp+120 */ int32
	var _ /* origmask at bp+256 */ Tsigset_t
	var _ /* td at bp+112 */ Tpthread_t
	*(*Targs)(unsafe.Pointer(bp)) = Targs{Fsev: sev}
	if !(sev != 0) || (*Tsigevent)(unsafe.Pointer(sev)).Fsigev_notify != int32(m_SIGEV_THREAD) {
		return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(244), int64(mqd), int64(sev)))))
	}
	s = x_socket(tls, int32(m_PF_NETLINK), Int32FromInt32(m_SOCK_RAW)|Int32FromInt32(m_SOCK_CLOEXEC), int32(0))
	if s < int32(0) {
		return -int32(1)
	}
	(*(*Targs)(unsafe.Pointer(bp))).Fsock = s
	(*(*Targs)(unsafe.Pointer(bp))).Fmqd = mqd
	if (*(*struct {
		Fsigev_notify_function   uintptr
		Fsigev_notify_attributes uintptr
	})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer(sev)).F__sev_fields))).Fsigev_notify_attributes != 0 {
		*(*Tpthread_attr_t)(unsafe.Pointer(bp + 56)) = *(*Tpthread_attr_t)(unsafe.Pointer((*(*struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		})(unsafe.Pointer(&(*Tsigevent)(unsafe.Pointer(sev)).F__sev_fields))).Fsigev_notify_attributes))
	} else {
		x_pthread_attr_init(tls, bp+56)
	}
	x_pthread_attr_setdetachstate(tls, bp+56, int32(m_PTHREAD_CREATE_JOINABLE))
	x_sem_init(tls, uintptr(unsafe.Pointer(&(*(*Targs)(unsafe.Pointer(bp))).Fsem)), int32(0), uint32(0))
	x_sigfillset(tls, bp+128)
	x_pthread_sigmask(tls, int32(m_SIG_BLOCK), bp+128, bp+256)
	if x___pthread_create(tls, bp+112, bp+56, __ccgo_fp(_start), bp) != 0 {
		___syscall1(tls, int64(3), int64(s))
		x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+256, uintptr(0))
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
		return -int32(1)
	}
	x_pthread_sigmask(tls, int32(m_SIG_SETMASK), bp+256, uintptr(0))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+120)
	x_sem_wait(tls, uintptr(unsafe.Pointer(&(*(*Targs)(unsafe.Pointer(bp))).Fsem)))
	x_sem_destroy(tls, uintptr(unsafe.Pointer(&(*(*Targs)(unsafe.Pointer(bp))).Fsem)))
	if (*(*Targs)(unsafe.Pointer(bp))).Ferr != 0 {
		___syscall1(tls, int64(3), int64(s))
		x___pthread_join(tls, *(*Tpthread_t)(unsafe.Pointer(bp + 112)), uintptr(0))
		x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 120)), uintptr(0))
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = (*(*Targs)(unsafe.Pointer(bp))).Ferr
		return -int32(1)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 120)), uintptr(0))
	return int32(0)
}

func x_mq_open(tls *TLS, name uintptr, flags int32, va uintptr) (r Tmqd_t) {
	var ap Tva_list
	var attr uintptr
	var mode Tmode_t
	mode = uint32(0)
	attr = uintptr(0)
	if int32(*(*int8)(unsafe.Pointer(name))) == int32('/') {
		name++
	}
	if flags&int32(m_O_CREAT) != 0 {
		ap = va
		mode = VaUint32(&ap)
		attr = VaUintptr(&ap)
		_ = ap
	}
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(240), int64(name), int64(flags), int64(mode), int64(attr)))))
}

func x_mq_receive(tls *TLS, mqd Tmqd_t, msg uintptr, len1 Tsize_t, prio uintptr) (r Tssize_t) {
	return x_mq_timedreceive(tls, mqd, msg, len1, prio, uintptr(0))
}

func x_mq_send(tls *TLS, mqd Tmqd_t, msg uintptr, len1 Tsize_t, prio uint32) (r int32) {
	return x_mq_timedsend(tls, mqd, msg, len1, prio, uintptr(0))
}

func x_mq_setattr(tls *TLS, mqd Tmqd_t, new1 uintptr, old uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(245), int64(mqd), int64(new1), int64(old)))))
}

func x_mq_timedreceive(tls *TLS, mqd Tmqd_t, msg uintptr, len1 Tsize_t, prio uintptr, at uintptr) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(243), int64(mqd), int64(msg), int64(len1), int64(prio), int64(at), int64(0))))
}

func x_mq_timedsend(tls *TLS, mqd Tmqd_t, msg uintptr, len1 Tsize_t, prio uint32, at uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(242), int64(mqd), int64(msg), int64(len1), int64(prio), int64(at), int64(0)))))
}

func x_mq_unlink(tls *TLS, name uintptr) (r int32) {
	var ret int32
	if int32(*(*int8)(unsafe.Pointer(name))) == int32('/') {
		name++
	}
	ret = int32(___syscall1(tls, int64(241), int64(name)))
	if ret < int32(0) {
		if ret == -int32(m_EPERM) {
			ret = -int32(m_EACCES)
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = -ret
		return -int32(1)
	}
	return ret
}

const m_WEOF = 4294967295

func x_btowc(tls *TLS, c int32) (r Twint_t) {
	var b int32
	var v1 uint32
	var v2 uint32
	var v3 int32
	b = int32(uint8(c))
	if uint32(b) < uint32(128) {
		v1 = uint32(b)
	} else {
		if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
			v3 = int32(4)
		} else {
			v3 = int32(1)
		}
		if v3 == int32(1) && c != -int32(1) {
			v2 = uint32(Int32FromInt32(0xdfff) & int32(int8(c)))
		} else {
			v2 = uint32(0xffffffff)
		}
		v1 = v2
	}
	return v1
}

const m_EILSEQ = 84

type Tchar16_t = uint16

type Tchar32_t = uint32

func x_c16rtomb(tls *TLS, s uintptr, c16 Tchar16_t, ps uintptr) (r Tsize_t) {
	var wc Twchar_t
	var x uintptr
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state))
	}
	x = ps
	if !(s != 0) {
		if *(*uint32)(unsafe.Pointer(x)) != 0 {
			goto ilseq
		}
		return uint64(1)
	}
	if !(*(*uint32)(unsafe.Pointer(x)) != 0) && uint32(c16)-uint32(0xd800) < uint32(0x400) {
		*(*uint32)(unsafe.Pointer(x)) = uint32((int32(c16) - int32(0xd7c0)) << int32(10))
		return uint64(0)
	}
	if *(*uint32)(unsafe.Pointer(x)) != 0 {
		if uint32(c16)-uint32(0xdc00) >= uint32(0x400) {
			goto ilseq
		} else {
			wc = int32(*(*uint32)(unsafe.Pointer(x)) + uint32(c16) - uint32(0xdc00))
		}
		*(*uint32)(unsafe.Pointer(x)) = uint32(0)
	} else {
		wc = int32(c16)
	}
	return x_wcrtomb(tls, s, wc, uintptr(0))
ilseq:
	*(*uint32)(unsafe.Pointer(x)) = uint32(0)
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

var _internal_state uint32

func x_c32rtomb(tls *TLS, s uintptr, c32 Tchar32_t, ps uintptr) (r Tsize_t) {
	return x_wcrtomb(tls, s, int32(c32), ps)
}

func x_mblen(tls *TLS, s uintptr, n Tsize_t) (r int32) {
	return x_mbtowc(tls, uintptr(0), s, n)
}

func x_mbrlen(tls *TLS, s uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	var v1 uintptr
	if st != 0 {
		v1 = st
	} else {
		v1 = uintptr(unsafe.Pointer(&_internal))
	}
	return x_mbrtowc(tls, uintptr(0), s, n, v1)
}

var _internal uint32

func x_mbrtoc16(tls *TLS, pc16 uintptr, s uintptr, n Tsize_t, ps uintptr) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var pending uintptr
	var ret Tsize_t
	var _ /* wc at bp+0 */ Twchar_t
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state1))
	}
	pending = ps
	if !(s != 0) {
		return x_mbrtoc16(tls, uintptr(0), ts, uint64(1), ps)
	}
	/* mbrtowc states for partial UTF-8 characters have the high bit set;
	 * we use nonzero states without high bit for pending surrogates. */
	if int32(*(*uint32)(unsafe.Pointer(pending))) > int32(0) {
		if pc16 != 0 {
			*(*Tchar16_t)(unsafe.Pointer(pc16)) = uint16(*(*uint32)(unsafe.Pointer(pending)))
		}
		*(*uint32)(unsafe.Pointer(pending)) = uint32(0)
		return uint64(-Int32FromInt32(3))
	}
	ret = x_mbrtowc(tls, bp, s, n, ps)
	if ret <= uint64(4) {
		if *(*Twchar_t)(unsafe.Pointer(bp)) >= int32(0x10000) {
			*(*uint32)(unsafe.Pointer(pending)) = uint32(*(*Twchar_t)(unsafe.Pointer(bp))&int32(0x3ff) + int32(0xdc00))
			*(*Twchar_t)(unsafe.Pointer(bp)) = int32(0xd7c0) + *(*Twchar_t)(unsafe.Pointer(bp))>>Int32FromInt32(10)
		}
		if pc16 != 0 {
			*(*Tchar16_t)(unsafe.Pointer(pc16)) = uint16(*(*Twchar_t)(unsafe.Pointer(bp)))
		}
	}
	return ret
}

var _internal_state1 uint32

func x_mbrtoc32(tls *TLS, pc32 uintptr, s uintptr, n Tsize_t, ps uintptr) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var ret Tsize_t
	var _ /* wc at bp+0 */ Twchar_t
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state2))
	}
	if !(s != 0) {
		return x_mbrtoc32(tls, uintptr(0), ts, uint64(1), ps)
	}
	ret = x_mbrtowc(tls, bp, s, n, ps)
	if ret <= uint64(4) && pc32 != 0 {
		*(*Tchar32_t)(unsafe.Pointer(pc32)) = uint32(*(*Twchar_t)(unsafe.Pointer(bp)))
	}
	return ret
}

var _internal_state2 uint32

const m_SA = 194
const m_SB = 244

func x_mbrtowc(tls *TLS, wc uintptr, src uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var N uint32
	var c uint32
	var s uintptr
	var _ /* dummy at bp+0 */ Twchar_t
	var v1 Twchar_t
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	s = src
	N = uint32(n)
	if !(st != 0) {
		st = uintptr(unsafe.Pointer(&_internal_state3))
	}
	c = *(*uint32)(unsafe.Pointer(st))
	if !(s != 0) {
		if c != 0 {
			goto ilseq
		}
		return uint64(0)
	} else {
		if !(wc != 0) {
			wc = bp
		}
	}
	if !(n != 0) {
		return uint64(-Int32FromInt32(2))
	}
	if !(c != 0) {
		if int32(*(*uint8)(unsafe.Pointer(s))) < int32(0x80) {
			v1 = int32(*(*uint8)(unsafe.Pointer(s)))
			*(*Twchar_t)(unsafe.Pointer(wc)) = v1
			return BoolUint64(!!(v1 != 0))
		}
		if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
			v2 = int32(4)
		} else {
			v2 = int32(1)
		}
		if v2 == int32(1) {
			*(*Twchar_t)(unsafe.Pointer(wc)) = Int32FromInt32(0xdfff) & int32(int8(*(*uint8)(unsafe.Pointer(s))))
			return Uint64FromInt32(1)
		}
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
			goto ilseq
		}
		v3 = s
		s++
		c = x___fsmu8[uint32(*(*uint8)(unsafe.Pointer(v3)))-uint32(0xc2)]
		n--
	}
	if n != 0 {
		if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
			goto ilseq
		}
	loop:
		v4 = s
		s++
		c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v4)))-int32(0x80))
		n--
		if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
			*(*uint32)(unsafe.Pointer(st)) = uint32(0)
			*(*Twchar_t)(unsafe.Pointer(wc)) = int32(c)
			return uint64(N) - n
		}
		if n != 0 {
			if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
				goto ilseq
			}
			goto loop
		}
	}
	*(*uint32)(unsafe.Pointer(st)) = c
	return uint64(-Int32FromInt32(2))
ilseq:
	*(*uint32)(unsafe.Pointer(st)) = uint32(0)
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

var _internal_state3 uint32

func x_mbsinit(tls *TLS, st uintptr) (r int32) {
	return BoolInt32(!(st != 0) || !(*(*uint32)(unsafe.Pointer(st)) != 0))
}

func x_mbsnrtowcs(tls *TLS, wcs uintptr, src uintptr, n Tsize_t, wn Tsize_t, st uintptr) (r Tsize_t) {
	bp := tls.Alloc(1032) /* tlsAllocs 1032 maxValist 0 */
	defer tls.Free(1032)
	var cnt Tsize_t
	var l Tsize_t
	var n2 Tsize_t
	var tmp_s uintptr
	var ws uintptr
	var _ /* s at bp+1024 */ uintptr
	var _ /* wbuf at bp+0 */ [256]Twchar_t
	var v1 Tsize_t
	var v2 bool
	var v3 uint64
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 1024)) = *(*uintptr)(unsafe.Pointer(src))
	if !(wcs != 0) {
		ws = bp
		wn = Uint64FromInt64(1024) / Uint64FromInt64(4)
	} else {
		ws = wcs
	}
	/* making sure output buffer size is at most n/4 will ensure
	 * that mbsrtowcs never reads more than n input bytes. thus
	 * we can use mbsrtowcs as long as it's practical.. */
	for {
		if v2 = *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 && wn != 0; v2 {
			v1 = n / Uint64FromInt32(4)
			n2 = v1
		}
		if !(v2 && (v1 >= wn || n2 > uint64(32))) {
			break
		}
		if n2 >= wn {
			n2 = wn
		}
		tmp_s = *(*uintptr)(unsafe.Pointer(bp + 1024))
		l = x_mbsrtowcs(tls, ws, bp+1024, n2, st)
		if !(l+Uint64FromInt32(1) != 0) {
			cnt = l
			wn = uint64(0)
			break
		}
		if ws != bp {
			ws = ws + uintptr(l)*4
			wn = wn - l
		}
		if *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 {
			v3 = n - uint64(int64(*(*uintptr)(unsafe.Pointer(bp + 1024)))-int64(tmp_s))
		} else {
			v3 = uint64(0)
		}
		n = v3
		cnt = cnt + l
	}
	if *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 {
		for wn != 0 && n != 0 {
			l = x_mbrtowc(tls, ws, *(*uintptr)(unsafe.Pointer(bp + 1024)), n, st)
			if l+uint64(2) <= uint64(2) {
				if !(l+Uint64FromInt32(1) != 0) {
					cnt = l
					break
				}
				if !(l != 0) {
					*(*uintptr)(unsafe.Pointer(bp + 1024)) = uintptr(0)
					break
				}
				/* have to roll back partial character */
				*(*uint32)(unsafe.Pointer(st)) = uint32(0)
				break
			}
			*(*uintptr)(unsafe.Pointer(bp + 1024)) = *(*uintptr)(unsafe.Pointer(bp + 1024)) + uintptr(l)
			n = n - l
			/* safe - this loop runs fewer than sizeof(wbuf)/8 times */
			ws += 4
			wn--
			cnt++
		}
	}
	if wcs != 0 {
		*(*uintptr)(unsafe.Pointer(src)) = *(*uintptr)(unsafe.Pointer(bp + 1024))
	}
	return cnt
}

func x_mbsrtowcs(tls *TLS, ws uintptr, src uintptr, wn Tsize_t, st uintptr) (r Tsize_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1491, int32(11), uintptr(unsafe.Pointer(&___func__22)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__22 = [10]int8{'m', 'b', 's', 'r', 't', 'o', 'w', 'c', 's'}

func x_mbstowcs(tls *TLS, ws uintptr, _s uintptr, wn Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _s
	return x_mbsrtowcs(tls, ws, bp, wn, uintptr(0))
}

func x_mbtowc(tls *TLS, wc uintptr, src uintptr, n Tsize_t) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c uint32
	var s uintptr
	var _ /* dummy at bp+0 */ Twchar_t
	var v1 Twchar_t
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	s = src
	if !(s != 0) {
		return int32(0)
	}
	if !(n != 0) {
		goto ilseq
	}
	if !(wc != 0) {
		wc = bp
	}
	if int32(*(*uint8)(unsafe.Pointer(s))) < int32(0x80) {
		v1 = int32(*(*uint8)(unsafe.Pointer(s)))
		*(*Twchar_t)(unsafe.Pointer(wc)) = v1
		return BoolInt32(!!(v1 != 0))
	}
	if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
		v2 = int32(4)
	} else {
		v2 = int32(1)
	}
	if v2 == int32(1) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = Int32FromInt32(0xdfff) & int32(int8(*(*uint8)(unsafe.Pointer(s))))
		return Int32FromInt32(1)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
		goto ilseq
	}
	v3 = s
	s++
	c = x___fsmu8[uint32(*(*uint8)(unsafe.Pointer(v3)))-uint32(0xc2)]
	/* Avoid excessive checks against n: If shifting the state n-1
	 * times does not clear the high bit, then the value of n is
	 * insufficient to read a character */
	if n < uint64(4) && c<<(uint64(6)*n-uint64(6))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0 {
		goto ilseq
	}
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		goto ilseq
	}
	v4 = s
	s++
	c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v4)))-int32(0x80))
	if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = int32(c)
		return int32(2)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v5 = s
	s++
	c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v5)))-int32(0x80))
	if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = int32(c)
		return int32(3)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v6 = s
	s++
	*(*Twchar_t)(unsafe.Pointer(wc)) = int32(c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v6)))-int32(0x80)))
	return int32(4)
ilseq:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return -int32(1)
}

func x_wcrtomb(tls *TLS, s uintptr, wc Twchar_t, st uintptr) (r Tsize_t) {
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	if !(s != 0) {
		return uint64(1)
	}
	if uint32(wc) < uint32(0x80) {
		*(*int8)(unsafe.Pointer(s)) = int8(wc)
		return uint64(1)
	} else {
		if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
			v1 = int32(4)
		} else {
			v1 = int32(1)
		}
		if v1 == int32(1) {
			if !(uint32(wc)-Uint32FromInt32(0xdf80) < Uint32FromInt32(0x80)) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
				return uint64(-Int32FromInt32(1))
			}
			*(*int8)(unsafe.Pointer(s)) = int8(wc)
			return uint64(1)
		} else {
			if uint32(wc) < uint32(0x800) {
				v2 = s
				s++
				*(*int8)(unsafe.Pointer(v2)) = int8(int32(0xc0) | wc>>Int32FromInt32(6))
				*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
				return uint64(2)
			} else {
				if uint32(wc) < uint32(0xd800) || uint32(wc)-uint32(0xe000) < uint32(0x2000) {
					v3 = s
					s++
					*(*int8)(unsafe.Pointer(v3)) = int8(int32(0xe0) | wc>>Int32FromInt32(12))
					v4 = s
					s++
					*(*int8)(unsafe.Pointer(v4)) = int8(int32(0x80) | wc>>Int32FromInt32(6)&int32(0x3f))
					*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
					return uint64(3)
				} else {
					if uint32(wc)-uint32(0x10000) < uint32(0x100000) {
						v5 = s
						s++
						*(*int8)(unsafe.Pointer(v5)) = int8(int32(0xf0) | wc>>Int32FromInt32(18))
						v6 = s
						s++
						*(*int8)(unsafe.Pointer(v6)) = int8(int32(0x80) | wc>>Int32FromInt32(12)&int32(0x3f))
						v7 = s
						s++
						*(*int8)(unsafe.Pointer(v7)) = int8(int32(0x80) | wc>>Int32FromInt32(6)&int32(0x3f))
						*(*int8)(unsafe.Pointer(s)) = int8(int32(0x80) | wc&int32(0x3f))
						return uint64(4)
					}
				}
			}
		}
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
	return uint64(-Int32FromInt32(1))
}

func x_wcsnrtombs(tls *TLS, dst uintptr, wcs uintptr, wn Tsize_t, n Tsize_t, st uintptr) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var cnt Tsize_t
	var l Tsize_t
	var ws uintptr
	var _ /* tmp at bp+0 */ [4]int8
	var v1 uintptr
	ws = *(*uintptr)(unsafe.Pointer(wcs))
	cnt = uint64(0)
	if !(dst != 0) {
		n = uint64(0)
	}
	for ws != 0 && wn != 0 {
		if n < uint64(m_MB_LEN_MAX) {
			v1 = bp
		} else {
			v1 = dst
		}
		l = x_wcrtomb(tls, v1, *(*Twchar_t)(unsafe.Pointer(ws)), uintptr(0))
		if l == uint64(-Int32FromInt32(1)) {
			cnt = uint64(-Int32FromInt32(1))
			break
		}
		if dst != 0 {
			if n < uint64(m_MB_LEN_MAX) {
				if l > n {
					break
				}
				x_memcpy(tls, dst, bp, l)
			}
			dst = dst + uintptr(l)
			n = n - l
		}
		if !(*(*Twchar_t)(unsafe.Pointer(ws)) != 0) {
			ws = uintptr(0)
			break
		}
		ws += 4
		wn--
		cnt = cnt + l
	}
	if dst != 0 {
		*(*uintptr)(unsafe.Pointer(wcs)) = ws
	}
	return cnt
}

func x_wcsrtombs(tls *TLS, s uintptr, ws uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var N Tsize_t
	var l Tsize_t
	var ws2 uintptr
	var _ /* buf at bp+0 */ [4]int8
	var v1 uintptr
	var v2 uintptr
	N = n
	if !(s != 0) {
		n = uint64(0)
		ws2 = *(*uintptr)(unsafe.Pointer(ws))
		for ; *(*Twchar_t)(unsafe.Pointer(ws2)) != 0; ws2 += 4 {
			if uint32(*(*Twchar_t)(unsafe.Pointer(ws2))) >= uint32(0x80) {
				l = x_wcrtomb(tls, bp, *(*Twchar_t)(unsafe.Pointer(ws2)), uintptr(0))
				if !(l+Uint64FromInt32(1) != 0) {
					return uint64(-Int32FromInt32(1))
				}
				n = n + l
			} else {
				n++
			}
		}
		return n
	}
	for n >= uint64(4) {
		if uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))-uint32(1) >= uint32(0x7f) {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0) {
				*(*int8)(unsafe.Pointer(s)) = int8(0)
				*(*uintptr)(unsafe.Pointer(ws)) = uintptr(0)
				return N - n
			}
			l = x_wcrtomb(tls, s, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			s = s + uintptr(l)
			n = n - l
		} else {
			v1 = s
			s++
			*(*int8)(unsafe.Pointer(v1)) = int8(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	for n != 0 {
		if uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))-uint32(1) >= uint32(0x7f) {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0) {
				*(*int8)(unsafe.Pointer(s)) = int8(0)
				*(*uintptr)(unsafe.Pointer(ws)) = uintptr(0)
				return N - n
			}
			l = x_wcrtomb(tls, bp, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			if l > n {
				return N - n
			}
			x_wcrtomb(tls, s, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			s = s + uintptr(l)
			n = n - l
		} else {
			v2 = s
			s++
			*(*int8)(unsafe.Pointer(v2)) = int8(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	return N
}

func x_wcstombs(tls *TLS, s uintptr, ws uintptr, n Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = ws
	return x_wcsrtombs(tls, s, bp, n, uintptr(0))
}

func x_wctob(tls *TLS, c Twint_t) (r int32) {
	var v1 int32
	if c < uint32(128) {
		return int32(c)
	}
	if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
		v1 = int32(4)
	} else {
		v1 = int32(1)
	}
	if v1 == int32(1) && c-uint32(0xdf80) < uint32(0x80) {
		return int32(uint8(c))
	}
	return -int32(1)
}

func x_wctomb(tls *TLS, s uintptr, wc Twchar_t) (r int32) {
	if !(s != 0) {
		return int32(0)
	}
	return int32(x_wcrtomb(tls, s, wc, uintptr(0)))
}

const m_SYS_accept = 43
const m___SC_accept = 5

func x_accept(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_accept), int32(m___SC_accept), int32(1), int64(fd), int64(addr), int64(len1), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

const m_SOCK_NONBLOCK = 2048
const m_SYS_accept4 = 288
const m___SC_accept4 = 18

type Tucred = struct {
	Fpid Tpid_t
	Fuid Tuid_t
	Fgid Tgid_t
}

type Tmmsghdr = struct {
	Fmsg_hdr     Tmsghdr
	Fmsg_len     uint32
	F__ccgo_pad2 [4]byte
}

func x_accept4(tls *TLS, fd int32, addr uintptr, len1 uintptr, flg int32) (r int32) {
	var ret int32
	if !(flg != 0) {
		return x_accept(tls, fd, addr, len1)
	}
	ret = int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_accept4), int32(m___SC_accept4), int32(1), int64(fd), int64(addr), int64(len1), int64(flg), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
	if ret >= int32(0) || *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOSYS) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EINVAL) {
		return ret
	}
	if flg & ^(Int32FromInt32(m_SOCK_CLOEXEC)|Int32FromInt32(m_SOCK_NONBLOCK)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	ret = x_accept(tls, fd, addr, len1)
	if ret < int32(0) {
		return ret
	}
	if flg&int32(m_SOCK_CLOEXEC) != 0 {
		___syscall3(tls, int64(72), int64(ret), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	if flg&int32(m_SOCK_NONBLOCK) != 0 {
		___syscall3(tls, int64(72), int64(ret), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
	}
	return ret
}

const m_SYS_bind = 49
const m___SC_bind = 2

func x_bind(tls *TLS, fd int32, addr uintptr, len1 Tsocklen_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_bind), int32(m___SC_bind), int32(0), int64(fd), int64(addr), int64(len1), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

const m_SYS_connect = 42
const m___SC_connect = 3

func x_connect(tls *TLS, fd int32, addr uintptr, len1 Tsocklen_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_connect), int32(m___SC_connect), int32(1), int64(fd), int64(addr), int64(len1), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

const m_MAXDNSRCH = 6
const m_MAXNS = 3
const m_MAXRESOLVSORT = 10
const m_NS_MAXDNAME = 1025
const m_NS_PACKETSZ = 512

type Tns_sect = int32

type ___ns_sect = int32

const _ns_s_qd = 0
const _ns_s_zn = 0
const _ns_s_an = 1
const _ns_s_pr = 1
const _ns_s_ns = 2
const _ns_s_ud = 2
const _ns_s_ar = 3
const _ns_s_max = 4

type Tns_msg = struct {
	F_msg      uintptr
	F_eom      uintptr
	F_id       Tuint16_t
	F_flags    Tuint16_t
	F_counts   [4]Tuint16_t
	F_sections [4]uintptr
	F_sect     Tns_sect
	F_rrnum    int32
	F_msg_ptr  uintptr
}

type T__ns_msg = Tns_msg

type T_ns_flagdata = struct {
	Fmask  int32
	Fshift int32
}

type Tns_rr = struct {
	Fname     [1025]int8
	Ftype1    Tuint16_t
	Frr_class Tuint16_t
	Fttl      Tuint32_t
	Frdlength Tuint16_t
	Frdata    uintptr
}

type T__ns_rr = Tns_rr

type Tns_flag = int32

type ___ns_flag = int32

const _ns_f_qr = 0
const _ns_f_opcode = 1
const _ns_f_aa = 2
const _ns_f_tc = 3
const _ns_f_rd = 4
const _ns_f_ra = 5
const _ns_f_z = 6
const _ns_f_ad = 7
const _ns_f_cd = 8
const _ns_f_rcode = 9
const _ns_f_max = 10

type Tns_opcode = int32

type ___ns_opcode = int32

const _ns_o_query = 0
const _ns_o_iquery = 1
const _ns_o_status = 2
const _ns_o_notify = 4
const _ns_o_update = 5
const _ns_o_max = 6

type Tns_rcode = int32

type ___ns_rcode = int32

const _ns_r_noerror = 0
const _ns_r_formerr = 1
const _ns_r_servfail = 2
const _ns_r_nxdomain = 3
const _ns_r_notimpl = 4
const _ns_r_refused = 5
const _ns_r_yxdomain = 6
const _ns_r_yxrrset = 7
const _ns_r_nxrrset = 8
const _ns_r_notauth = 9
const _ns_r_notzone = 10
const _ns_r_max = 11
const _ns_r_badvers = 16
const _ns_r_badsig = 16
const _ns_r_badkey = 17
const _ns_r_badtime = 18

type Tns_update_operation = int32

type ___ns_update_operation = int32

const _ns_uop_delete = 0
const _ns_uop_add = 1
const _ns_uop_max = 2

type Tns_tsig_key1 = struct {
	Fname        [1025]int8
	Falg         [1025]int8
	Fdata        uintptr
	Flen1        int32
	F__ccgo_pad4 [4]byte
}

type Tns_tsig_key = struct {
	Fname        [1025]int8
	Falg         [1025]int8
	Fdata        uintptr
	Flen1        int32
	F__ccgo_pad4 [4]byte
}

type Tns_tcp_tsig_state1 = struct {
	Fcounter     int32
	Fkey         uintptr
	Fctx         uintptr
	Fsig         [512]uint8
	Fsiglen      int32
	F__ccgo_pad5 [4]byte
}

type Tns_tcp_tsig_state = struct {
	Fcounter     int32
	Fkey         uintptr
	Fctx         uintptr
	Fsig         [512]uint8
	Fsiglen      int32
	F__ccgo_pad5 [4]byte
}

type Tns_type = int32

type ___ns_type = int32

const _ns_t_invalid = 0
const _ns_t_a = 1
const _ns_t_ns = 2
const _ns_t_md = 3
const _ns_t_mf = 4
const _ns_t_cname = 5
const _ns_t_soa = 6
const _ns_t_mb = 7
const _ns_t_mg = 8
const _ns_t_mr = 9
const _ns_t_null = 10
const _ns_t_wks = 11
const _ns_t_ptr = 12
const _ns_t_hinfo = 13
const _ns_t_minfo = 14
const _ns_t_mx = 15
const _ns_t_txt = 16
const _ns_t_rp = 17
const _ns_t_afsdb = 18
const _ns_t_x25 = 19
const _ns_t_isdn = 20
const _ns_t_rt = 21
const _ns_t_nsap = 22
const _ns_t_nsap_ptr = 23
const _ns_t_sig = 24
const _ns_t_key = 25
const _ns_t_px = 26
const _ns_t_gpos = 27
const _ns_t_aaaa = 28
const _ns_t_loc = 29
const _ns_t_nxt = 30
const _ns_t_eid = 31
const _ns_t_nimloc = 32
const _ns_t_srv = 33
const _ns_t_atma = 34
const _ns_t_naptr = 35
const _ns_t_kx = 36
const _ns_t_cert = 37
const _ns_t_a6 = 38
const _ns_t_dname = 39
const _ns_t_sink = 40
const _ns_t_opt = 41
const _ns_t_apl = 42
const _ns_t_ds = 43
const _ns_t_sshfp = 44
const _ns_t_ipseckey = 45
const _ns_t_rrsig = 46
const _ns_t_nsec = 47
const _ns_t_dnskey = 48
const _ns_t_dhcid = 49
const _ns_t_nsec3 = 50
const _ns_t_nsec3param = 51
const _ns_t_tlsa = 52
const _ns_t_smimea = 53
const _ns_t_hip = 55
const _ns_t_ninfo = 56
const _ns_t_rkey = 57
const _ns_t_talink = 58
const _ns_t_cds = 59
const _ns_t_cdnskey = 60
const _ns_t_openpgpkey = 61
const _ns_t_csync = 62
const _ns_t_spf = 99
const _ns_t_uinfo = 100
const _ns_t_uid = 101
const _ns_t_gid = 102
const _ns_t_unspec = 103
const _ns_t_nid = 104
const _ns_t_l32 = 105
const _ns_t_l64 = 106
const _ns_t_lp = 107
const _ns_t_eui48 = 108
const _ns_t_eui64 = 109
const _ns_t_tkey = 249
const _ns_t_tsig = 250
const _ns_t_ixfr = 251
const _ns_t_axfr = 252
const _ns_t_mailb = 253
const _ns_t_maila = 254
const _ns_t_any = 255
const _ns_t_zxfr = 256
const _ns_t_uri = 256
const _ns_t_caa = 257
const _ns_t_avc = 258
const _ns_t_ta = 32768
const _ns_t_dlv = 32769
const _ns_t_max = 65536

type Tns_class = int32

type ___ns_class = int32

const _ns_c_invalid = 0
const _ns_c_in = 1
const _ns_c_2 = 2
const _ns_c_chaos = 3
const _ns_c_hs = 4
const _ns_c_none = 254
const _ns_c_any = 255
const _ns_c_max = 65536

type Tns_key_types = int32

type ___ns_key_types = int32

const _ns_kt_rsa = 1
const _ns_kt_dh = 2
const _ns_kt_dsa = 3
const _ns_kt_private = 254

type Tns_cert_types = int32

type ___ns_cert_types = int32

const _cert_t_pkix = 1
const _cert_t_spki = 2
const _cert_t_pgp = 3
const _cert_t_url = 253
const _cert_t_oid = 254

type THEADER = struct {
	F__ccgo0 uint32
	F__ccgo4 uint32
	F__ccgo8 uint32
}

type Timaxdiv_t = struct {
	Fquot Tintmax_t
	Frem  Tintmax_t
}

type Tin_port_t = uint16

type Tin_addr_t = uint32

type Tin_addr = struct {
	Fs_addr Tin_addr_t
}

type Tsockaddr_in = struct {
	Fsin_family Tsa_family_t
	Fsin_port   Tin_port_t
	Fsin_addr   Tin_addr
	Fsin_zero   [8]Tuint8_t
}

type Tin6_addr = struct {
	F__in6_union struct {
		F__s6_addr16 [0][8]Tuint16_t
		F__s6_addr32 [0][4]Tuint32_t
		F__s6_addr   [16]Tuint8_t
	}
}

type Tsockaddr_in6 = struct {
	Fsin6_family   Tsa_family_t
	Fsin6_port     Tin_port_t
	Fsin6_flowinfo Tuint32_t
	Fsin6_addr     Tin6_addr
	Fsin6_scope_id Tuint32_t
}

type Tipv6_mreq = struct {
	Fipv6mr_multiaddr Tin6_addr
	Fipv6mr_interface uint32
}

type Tip_opts = struct {
	Fip_dst  Tin_addr
	Fip_opts [40]int8
}

type Tres_state = uintptr

type T__res_state = struct {
	Fretrans     int32
	Fretry       int32
	Foptions     uint64
	Fnscount     int32
	Fnsaddr_list [3]Tsockaddr_in
	Fid          uint16
	Fdnsrch      [7]uintptr
	Fdefdname    [256]int8
	Fpfcode      uint64
	F__ccgo392   uint32
	Fsort_list   [10]struct {
		Faddr Tin_addr
		Fmask Tuint32_t
	}
	Fqhook       uintptr
	Frhook       uintptr
	Fres_h_errno int32
	F_vcsock     int32
	F_flags      uint32
	F_u          struct {
		F_ext [0]struct {
			Fnscount    Tuint16_t
			Fnsmap      [3]Tuint16_t
			Fnssocks    [3]int32
			Fnscount6   Tuint16_t
			Fnsinit     Tuint16_t
			Fnsaddrs    [3]uintptr
			F_initstamp [2]uint32
		}
		Fpad         [52]int8
		F__ccgo_pad2 [4]byte
	}
}

type Tres_sym = struct {
	Fnumber    int32
	Fname      uintptr
	Fhumanname uintptr
}

/* RFC 1035 message compression */

// C documentation
//
//	/* label start offsets of a compressed domain name s */
func _getoffs(tls *TLS, offs uintptr, base uintptr, s uintptr) (r int32) {
	var i int32
	var v1 int32
	i = int32(0)
	for {
		for int32(*(*uint8)(unsafe.Pointer(s)))&int32(0xc0) != 0 {
			if int32(*(*uint8)(unsafe.Pointer(s)))&int32(0xc0) != int32(0xc0) {
				return int32(0)
			}
			s = base + uintptr(int32(*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(0))))&Int32FromInt32(0x3f)<<Int32FromInt32(8)|int32(*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(1)))))
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			return i
		}
		if int64(s)-int64(base) >= int64(0x4000) {
			return int32(0)
		}
		v1 = i
		i++
		*(*int16)(unsafe.Pointer(offs + uintptr(v1)*2)) = int16(int64(s) - int64(base))
		s = s + uintptr(int32(*(*uint8)(unsafe.Pointer(s)))+Int32FromInt32(1))
	}
	return r
}

// C documentation
//
//	/* label lengths of an ascii domain name s */
func _getlens(tls *TLS, lens uintptr, s uintptr, l int32) (r int32) {
	var i int32
	var j int32
	var k int32
	var v1 int32
	var v2 int32
	i = int32(0)
	j = int32(0)
	k = int32(0)
	for {
		for ; j < l && int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) != int32('.'); j++ {
		}
		if uint32(j-k)-uint32(1) > uint32(62) {
			return int32(0)
		}
		v1 = i
		i++
		*(*uint8)(unsafe.Pointer(lens + uintptr(v1))) = uint8(j - k)
		if j == l {
			return i
		}
		j++
		v2 = j
		k = v2
	}
	return r
}

// C documentation
//
//	/* longest suffix match of an ascii domain with a compressed domain name dn */
func _match(tls *TLS, offset uintptr, base uintptr, dn uintptr, end uintptr, lens uintptr, nlen int32) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var l int32
	var m int32
	var noff int32
	var o int32
	var _ /* offs at bp+0 */ [128]int16
	var v1 int32
	var v2 int32
	m = int32(0)
	noff = _getoffs(tls, bp, base, dn)
	if !(noff != 0) {
		return int32(0)
	}
	for {
		nlen--
		v1 = nlen
		l = int32(*(*uint8)(unsafe.Pointer(lens + uintptr(v1))))
		noff--
		v2 = noff
		o = int32((*(*[128]int16)(unsafe.Pointer(bp)))[v2])
		end = end - uintptr(l)
		if l != int32(*(*uint8)(unsafe.Pointer(base + uintptr(o)))) || x_memcmp(tls, base+uintptr(o)+uintptr(1), end, uint64(l)) != 0 {
			return m
		}
		*(*int32)(unsafe.Pointer(offset)) = o
		m = m + l
		if nlen != 0 {
			m++
		}
		if !(nlen != 0) || !(noff != 0) {
			return m
		}
		end--
	}
	return r
}

func x_dn_comp(tls *TLS, src uintptr, dst uintptr, space int32, dnptrs uintptr, lastdnptr uintptr) (r int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxValist 0 */
	defer tls.Free(136)
	var bestlen int32
	var bestoff int32
	var end uintptr
	var i int32
	var j int32
	var l Tsize_t
	var m int32
	var n int32
	var p uintptr
	var _ /* lens at bp+4 */ [127]uint8
	var _ /* offset at bp+0 */ int32
	var v1 int32
	var v2 int32
	var v4 int32
	var v5 int32
	var v6 int32
	var v7 uintptr
	m = int32(0)
	bestlen = int32(0)
	l = x_strnlen(tls, src, uint64(255))
	if l != 0 && int32(*(*int8)(unsafe.Pointer(src + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		l--
	}
	if l > uint64(253) || space <= int32(0) {
		return -int32(1)
	}
	if !(l != 0) {
		*(*uint8)(unsafe.Pointer(dst)) = uint8(0)
		return int32(1)
	}
	end = src + uintptr(l)
	n = _getlens(tls, bp+4, src, int32(l))
	if !(n != 0) {
		return -int32(1)
	}
	p = dnptrs
	if p != 0 && *(*uintptr)(unsafe.Pointer(p)) != 0 {
		for p += 8; *(*uintptr)(unsafe.Pointer(p)) != 0; p += 8 {
			m = _match(tls, bp, *(*uintptr)(unsafe.Pointer(dnptrs)), *(*uintptr)(unsafe.Pointer(p)), end, bp+4, n)
			if m > bestlen {
				bestlen = m
				bestoff = *(*int32)(unsafe.Pointer(bp))
				if uint64(m) == l {
					break
				}
			}
		}
	}
	/* encode unmatched part */
	if uint64(space) < l-uint64(bestlen)+uint64(2)+BoolUint64(uint64(bestlen-Int32FromInt32(1)) < l-Uint64FromInt32(1)) {
		return -int32(1)
	}
	x_memcpy(tls, dst+uintptr(1), src, l-uint64(bestlen))
	v1 = Int32FromInt32(0)
	j = v1
	i = v1
	for uint64(i) < l-uint64(bestlen) {
		*(*uint8)(unsafe.Pointer(dst + uintptr(i))) = (*(*[127]uint8)(unsafe.Pointer(bp + 4)))[j]
		goto _3
	_3:
		v2 = j
		j++
		i = i + (int32((*(*[127]uint8)(unsafe.Pointer(bp + 4)))[v2]) + Int32FromInt32(1))
	}
	/* add tail */
	if bestlen != 0 {
		v4 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v4))) = uint8(int32(0xc0) | bestoff>>int32(8))
		v5 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v5))) = uint8(bestoff)
	} else {
		v6 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v6))) = uint8(0)
	}
	/* save dst pointer */
	if i > int32(2) && lastdnptr != 0 && dnptrs != 0 && *(*uintptr)(unsafe.Pointer(dnptrs)) != 0 {
		for *(*uintptr)(unsafe.Pointer(p)) != 0 {
			p += 8
		}
		if p+uintptr(1)*8 < lastdnptr {
			v7 = p
			p += 8
			*(*uintptr)(unsafe.Pointer(v7)) = dst
			*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
		}
	}
	return i
}

func x___dn_expand(tls *TLS, base uintptr, end uintptr, src uintptr, dest uintptr, space int32) (r int32) {
	var dbegin uintptr
	var dend uintptr
	var i int32
	var j int32
	var len1 int32
	var p uintptr
	var v1 int32
	var v3 uintptr
	var v4 uintptr
	var v5 int32
	var v6 uintptr
	var v7 uintptr
	p = src
	dbegin = dest
	len1 = -int32(1)
	if p == end || space <= int32(0) {
		return -int32(1)
	}
	if space > int32(254) {
		v1 = int32(254)
	} else {
		v1 = space
	}
	dend = dest + uintptr(v1)
	/* detect reference loop using an iteration counter */
	for i = int32(0); int64(i) < int64(end)-int64(base); {
		/* loop invariants: p<end, dest<dend */
		if int32(*(*uint8)(unsafe.Pointer(p)))&int32(0xc0) != 0 {
			if p+uintptr(1) == end {
				return -int32(1)
			}
			j = int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(0))))&int32(0x3f)<<int32(8) | int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1))))
			if len1 < int32(0) {
				len1 = int32(int64(p+uintptr(2)) - int64(src))
			}
			if int64(j) >= int64(end)-int64(base) {
				return -int32(1)
			}
			p = base + uintptr(j)
		} else {
			if *(*uint8)(unsafe.Pointer(p)) != 0 {
				if dest != dbegin {
					v3 = dest
					dest++
					*(*int8)(unsafe.Pointer(v3)) = int8('.')
				}
				v4 = p
				p++
				j = int32(*(*uint8)(unsafe.Pointer(v4)))
				if int64(j) >= int64(end)-int64(p) || int64(j) >= int64(dend)-int64(dest) {
					return -int32(1)
				}
				for {
					v5 = j
					j--
					if !(v5 != 0) {
						break
					}
					v6 = dest
					dest++
					v7 = p
					p++
					*(*int8)(unsafe.Pointer(v6)) = int8(*(*uint8)(unsafe.Pointer(v7)))
				}
			} else {
				*(*int8)(unsafe.Pointer(dest)) = int8(0)
				if len1 < int32(0) {
					len1 = int32(int64(p+uintptr(1)) - int64(src))
				}
				return len1
			}
		}
		goto _2
	_2:
		i = i + Int32FromInt32(2)
	}
	return -int32(1)
}

func x_dn_skipname(tls *TLS, s uintptr, end uintptr) (r int32) {
	var p uintptr
	p = s
	for p < end {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			return int32(int64(p) - int64(s) + int64(1))
		} else {
			if int32(*(*uint8)(unsafe.Pointer(p))) >= int32(192) {
				if p+uintptr(1) < end {
					return int32(int64(p) - int64(s) + int64(2))
				} else {
					break
				}
			} else {
				if int64(end)-int64(p) < int64(int32(*(*uint8)(unsafe.Pointer(p)))+int32(1)) {
					break
				} else {
					p = p + uintptr(int32(*(*uint8)(unsafe.Pointer(p)))+Int32FromInt32(1))
				}
			}
		}
	}
	return -int32(1)
}

const m_MAXADDRS = 48
const m_MAXSERVS = 2

type Taddrinfo = struct {
	Fai_flags     int32
	Fai_family    int32
	Fai_socktype  int32
	Fai_protocol  int32
	Fai_addrlen   Tsocklen_t
	Fai_addr      uintptr
	Fai_canonname uintptr
	Fai_next      uintptr
}

type Tnetent = struct {
	Fn_name     uintptr
	Fn_aliases  uintptr
	Fn_addrtype int32
	Fn_net      Tuint32_t
}

type Thostent = struct {
	Fh_name      uintptr
	Fh_aliases   uintptr
	Fh_addrtype  int32
	Fh_length    int32
	Fh_addr_list uintptr
}

type Tservent = struct {
	Fs_name    uintptr
	Fs_aliases uintptr
	Fs_port    int32
	Fs_proto   uintptr
}

type Tprotoent = struct {
	Fp_name      uintptr
	Fp_aliases   uintptr
	Fp_proto     int32
	F__ccgo_pad3 [4]byte
}

type Taibuf = struct {
	Fai          Taddrinfo
	Fsa          Tsa
	Flock        [1]int32
	Fslot        int16
	Fref         int16
	F__ccgo_pad5 [4]byte
}

type Taddress = struct {
	Ffamily  int32
	Fscopeid uint32
	Faddr    [16]Tuint8_t
	Fsortkey int32
}

type Tservice = struct {
	Fport     Tuint16_t
	Fproto    uint8
	Fsocktype uint8
}

type Tresolvconf = struct {
	Fns       [3]Taddress
	Fnns      uint32
	Fattempts uint32
	Fndots    uint32
	Ftimeout  uint32
}

func x___dns_parse(tls *TLS, r uintptr, rlen int32, callback uintptr, ctx uintptr) (r1 int32) {
	var ancount int32
	var len1 int32
	var p uintptr
	var qdcount int32
	var v1 int32
	var v2 int32
	if rlen < int32(12) {
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(r + UintptrFromInt32(3))))&int32(15) != 0 {
		return int32(0)
	}
	p = r + uintptr(12)
	qdcount = int32(*(*uint8)(unsafe.Pointer(r + UintptrFromInt32(4))))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + UintptrFromInt32(5))))
	ancount = int32(*(*uint8)(unsafe.Pointer(r + UintptrFromInt32(6))))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + UintptrFromInt32(7))))
	if qdcount+ancount > int32(64) {
		return -int32(1)
	}
	for {
		v1 = qdcount
		qdcount--
		if !(v1 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(rlen) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if p > r+uintptr(rlen)-uintptr(6) || int32(*(*uint8)(unsafe.Pointer(p))) > int32(193) || int32(*(*uint8)(unsafe.Pointer(p))) == int32(193) && int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))) > int32(254) {
			return -int32(1)
		}
		p = p + uintptr(Int32FromInt32(5)+BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
	}
	for {
		v2 = ancount
		ancount--
		if !(v2 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(rlen) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if p > r+uintptr(rlen)-uintptr(12) || int32(*(*uint8)(unsafe.Pointer(p))) > int32(193) || int32(*(*uint8)(unsafe.Pointer(p))) == int32(193) && int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))) > int32(254) {
			return -int32(1)
		}
		p = p + uintptr(Int32FromInt32(1)+BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
		len1 = int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(8))))*int32(256) + int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(9))))
		if int64(len1+int32(10)) > int64(r+uintptr(rlen))-int64(p) {
			return -int32(1)
		}
		if (*(*func(*TLS, uintptr, int32, uintptr, int32, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{callback})))(tls, ctx, int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))), p+uintptr(10), len1, r, rlen) < int32(0) {
			return -int32(1)
		}
		p = p + uintptr(Int32FromInt32(10)+len1)
	}
	return int32(0)
}

type Tsa = struct {
	Fsin6        [0]Tsockaddr_in6
	Fsin         Tsockaddr_in
	F__ccgo_pad2 [12]byte
}

func x_sethostent(tls *TLS, x int32) {
}

func x_gethostent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

func x_getnetent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

func x_endhostent(tls *TLS) {
}

const m_ETH_ALEN = 6
const m_MAX_ADDR_LEN = 7

type Tethhdr = struct {
	Fh_dest   [6]Tuint8_t
	Fh_source [6]Tuint8_t
	Fh_proto  Tuint16_t
}

type Tether_addr = struct {
	Fether_addr_octet [6]Tuint8_t
}

type Tether_header = struct {
	Fether_dhost [6]Tuint8_t
	Fether_shost [6]Tuint8_t
	Fether_type  Tuint16_t
}

type Tarphdr = struct {
	Far_hrd Tuint16_t
	Far_pro Tuint16_t
	Far_hln Tuint8_t
	Far_pln Tuint8_t
	Far_op  Tuint16_t
}

type Tarpreq = struct {
	Farp_pa      Tsockaddr
	Farp_ha      Tsockaddr
	Farp_flags   int32
	Farp_netmask Tsockaddr
	Farp_dev     [16]int8
}

type Tarpreq_old = struct {
	Farp_pa      Tsockaddr
	Farp_ha      Tsockaddr
	Farp_flags   int32
	Farp_netmask Tsockaddr
}

type Tarpd_request = struct {
	Freq         uint16
	Fip          Tuint32_t
	Fdev         uint64
	Fstamp       uint64
	Fupdated     uint64
	Fha          [7]uint8
	F__ccgo_pad6 [1]byte
}

type Tether_arp = struct {
	Fea_hdr  Tarphdr
	Farp_sha [6]Tuint8_t
	Farp_spa [4]Tuint8_t
	Farp_tha [6]Tuint8_t
	Farp_tpa [4]Tuint8_t
}

func x_ether_aton_r(tls *TLS, x uintptr, p_a uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var ii int32
	var n uint64
	var _ /* a at bp+0 */ Tether_addr
	var _ /* y at bp+8 */ uintptr
	ii = int32(0)
	for ; ii < int32(6); ii++ {
		if ii != int32(0) {
			if int32(*(*int8)(unsafe.Pointer(x + UintptrFromInt32(0)))) != int32(':') {
				return uintptr(0)
			} else {
				x++
			}
		}
		n = x_strtoul(tls, x, bp+8, int32(16))
		x = *(*uintptr)(unsafe.Pointer(bp + 8))
		if n > uint64(0xFF) {
			return uintptr(0)
		} /* bad byte */
		*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tether_addr)(unsafe.Pointer(bp))).Fether_addr_octet)) + uintptr(ii))) = uint8(n)
	}
	if int32(*(*int8)(unsafe.Pointer(x + UintptrFromInt32(0)))) != int32(0) {
		return uintptr(0)
	} /* bad format */
	*(*Tether_addr)(unsafe.Pointer(p_a)) = *(*Tether_addr)(unsafe.Pointer(bp))
	return p_a
}

func x_ether_aton(tls *TLS, x uintptr) (r uintptr) {
	return x_ether_aton_r(tls, x, uintptr(unsafe.Pointer(&_a)))
}

var _a Tether_addr

func x_ether_ntoa_r(tls *TLS, p_a uintptr, x uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	var ii int32
	var y uintptr
	var v1 uintptr
	y = x
	ii = int32(0)
	for ; ii < int32(6); ii++ {
		if ii == int32(0) {
			v1 = ts + 1517
		} else {
			v1 = ts + 1522
		}
		x = x + uintptr(x_sprintf(tls, x, v1, VaList(bp+8, int32(*(*Tuint8_t)(unsafe.Pointer(p_a + uintptr(ii)))))))
	}
	return y
}

func x_ether_ntoa(tls *TLS, p_a uintptr) (r uintptr) {
	return x_ether_ntoa_r(tls, p_a, uintptr(unsafe.Pointer(&_x)))
}

var _x [18]int8

func x_ether_line(tls *TLS, l uintptr, e uintptr, hostname uintptr) (r int32) {
	return -int32(1)
}

func x_ether_ntohost(tls *TLS, hostname uintptr, e uintptr) (r int32) {
	return -int32(1)
}

func x_ether_hostton(tls *TLS, hostname uintptr, e uintptr) (r int32) {
	return -int32(1)
}

func x_freeaddrinfo(tls *TLS, p uintptr) {
	var b uintptr
	var cnt Tsize_t
	var p2 uintptr
	for cnt = uint64(1); (*Taddrinfo)(unsafe.Pointer(p)).Fai_next != 0; {
		goto _1
	_1:
		cnt++
		p = (*Taddrinfo)(unsafe.Pointer(p)).Fai_next
	}
	b = p - uintptr(uint64(UintptrFromInt32(0)))
	b = b - uintptr((*Taibuf)(unsafe.Pointer(b)).Fslot)*88
	x___lock(tls, b+76)
	p2 = b + 82
	*(*int16)(unsafe.Pointer(p2)) = int16(uint64(*(*int16)(unsafe.Pointer(p2))) - cnt)
	if !(*(*int16)(unsafe.Pointer(p2)) != 0) {
		x_free(tls, b)
	} else {
		x___unlock(tls, b+76)
	}
}

var _msgs = [252]int8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'f', 'l', 'a', 'g', 's', 0, 'N', 'a', 'm', 'e', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r', 'e', 's', 'o', 'l', 'v', 'e', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'a', 'm', 'e', ' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'o', 'r', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'e', 'n', 'g', 't', 'h', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'S', 'y', 's', 't', 'e', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func x_gai_strerror(tls *TLS, ecode int32) (r uintptr) {
	var s uintptr
	s = uintptr(unsafe.Pointer(&_msgs))
	ecode++
	for ecode != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
		goto _1
	_1:
		ecode++
		s++
	}
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	return x___lctrans_cur(tls, s)
}

const m_AI_ADDRCONFIG = 32
const m_AI_ALL = 16
const m_AI_CANONNAME = 2
const m_AI_NUMERICHOST = 4
const m_AI_NUMERICSERV = 1024
const m_AI_PASSIVE = 1
const m_AI_V4MAPPED = 8
const m_EADDRNOTAVAIL = 99
const m_EAFNOSUPPORT = 97
const m_EHOSTUNREACH = 113
const m_ENETDOWN = 100
const m_ENETUNREACH = 101
const m_IPPROTO_UDP = 17
const m_PF_INET = 2
const m_PF_INET6 = 10
const m_PF_UNSPEC = 0

func x_getaddrinfo(tls *TLS, host uintptr, serv uintptr, hint uintptr, res uintptr) (r1 int32) {
	bp := tls.Alloc(1616) /* tlsAllocs 1616 maxValist 0 */
	defer tls.Free(1616)
	var canon_len int32
	var family int32
	var flags int32
	var i int32
	var j int32
	var k int32
	var mask int32
	var naddrs int32
	var nais int32
	var no_family int32
	var nservs int32
	var out uintptr
	var outcanon uintptr
	var proto int32
	var r int32
	var s int32
	var saved_errno int32
	var socktype int32
	var ta [2]uintptr
	var tf [2]int32
	var tl [2]Tsocklen_t
	var _ /* addrs at bp+8 */ [48]Taddress
	var _ /* canon at bp+1352 */ [256]int8
	var _ /* cs at bp+1608 */ int32
	var _ /* ports at bp+0 */ [2]Tservice
	var v1 int32
	var v3 uint64
	family = int32(m_PF_UNSPEC)
	flags = int32(0)
	proto = int32(0)
	socktype = int32(0)
	no_family = int32(0)
	if !(host != 0) && !(serv != 0) {
		return -int32(2)
	}
	if hint != 0 {
		family = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_family
		flags = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_flags
		proto = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_protocol
		socktype = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_socktype
		mask = Int32FromInt32(m_AI_PASSIVE) | Int32FromInt32(m_AI_CANONNAME) | Int32FromInt32(m_AI_NUMERICHOST) | Int32FromInt32(m_AI_V4MAPPED) | Int32FromInt32(m_AI_ALL) | Int32FromInt32(m_AI_ADDRCONFIG) | Int32FromInt32(m_AI_NUMERICSERV)
		if flags&mask != flags {
			return -int32(1)
		}
		switch family {
		case int32(m_PF_INET):
			fallthrough
		case int32(m_PF_INET6):
			fallthrough
		case int32(m_PF_UNSPEC):
		default:
			return -int32(6)
		}
	}
	if flags&int32(m_AI_ADDRCONFIG) != 0 {
		tf = [2]int32{
			0: int32(m_PF_INET),
			1: int32(m_PF_INET6)}
		ta = [2]uintptr{
			0: uintptr(unsafe.Pointer(&_lo4)),
			1: uintptr(unsafe.Pointer(&_lo6))}
		tl = [2]Tsocklen_t{
			0: uint32(16),
			1: uint32(28)}
		for i = int32(0); i < int32(2); i++ {
			if family == tf[int32(1)-i] {
				continue
			}
			s = x_socket(tls, tf[i], Int32FromInt32(m_SOCK_CLOEXEC)|Int32FromInt32(m_SOCK_DGRAM), int32(m_IPPROTO_UDP))
			if s >= int32(0) {
				x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+1608)
				r = x_connect(tls, s, ta[i], tl[i])
				saved_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
				x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 1608)), uintptr(0))
				x_close(tls, s)
				if !(r != 0) {
					continue
				}
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = saved_errno
			}
			switch *(*int32)(unsafe.Pointer(x___errno_location(tls))) {
			case int32(m_EADDRNOTAVAIL):
				fallthrough
			case int32(m_EAFNOSUPPORT):
				fallthrough
			case int32(m_EHOSTUNREACH):
				fallthrough
			case int32(m_ENETDOWN):
				fallthrough
			case int32(m_ENETUNREACH):
			default:
				return -int32(11)
			}
			if family == tf[i] {
				no_family = int32(1)
			}
			family = tf[int32(1)-i]
		}
	}
	nservs = x___lookup_serv(tls, bp, serv, proto, socktype, flags)
	if nservs < int32(0) {
		return nservs
	}
	naddrs = x___lookup_name(tls, bp+8, bp+1352, host, family, flags)
	if naddrs < int32(0) {
		return naddrs
	}
	if no_family != 0 {
		return -int32(5)
	}
	nais = nservs * naddrs
	canon_len = int32(x_strlen(tls, bp+1352))
	out = x_calloc(tls, uint64(1), uint64(nais)*uint64(88)+uint64(canon_len)+uint64(1))
	if !(out != 0) {
		return -int32(10)
	}
	if canon_len != 0 {
		outcanon = out + uintptr(nais)*88
		x_memcpy(tls, outcanon, bp+1352, uint64(canon_len+int32(1)))
	} else {
		outcanon = uintptr(0)
	}
	v1 = Int32FromInt32(0)
	i = v1
	k = v1
	for ; i < naddrs; i++ {
		for j = int32(0); j < nservs; {
			(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fslot = int16(k)
			if (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily == int32(m_PF_INET) {
				v3 = uint64(16)
			} else {
				v3 = uint64(28)
			}
			(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fai = Taddrinfo{Fai_family: (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily, Fai_socktype: int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fsocktype), Fai_protocol: int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fproto), Fai_addrlen: uint32(v3), Fai_addr: uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa)), Fai_canonname: outcanon}
			if k != 0 {
				(*(*Taibuf)(unsafe.Pointer(out + uintptr(k-Int32FromInt32(1))*88))).Fai.Fai_next = uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fai))
			}
			switch (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily {
			case int32(m_PF_INET):
				(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa.Fsin.Fsin_family = uint16(m_PF_INET)
				(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa.Fsin.Fsin_port = x_htons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fport)
				x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa.Fsin.Fsin_addr)), uintptr(unsafe.Pointer(&(*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Faddr)), uint64(4))
			case int32(m_PF_INET6):
				(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa))))).Fsin6_family = uint16(m_PF_INET6)
				(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa))))).Fsin6_port = x_htons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fport)
				(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa))))).Fsin6_scope_id = (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Fscopeid
				x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fsa))))).Fsin6_addr)), uintptr(unsafe.Pointer(&(*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Faddr)), uint64(16))
				break
			}
			goto _2
		_2:
			j++
			k++
		}
	}
	(*(*Taibuf)(unsafe.Pointer(out + UintptrFromInt32(0)*88))).Fref = int16(nais)
	*(*uintptr)(unsafe.Pointer(res)) = out
	return int32(0)
}

/* Define the "an address is configured" condition for address
 * families via ability to create a socket for the family plus
 * routability of the loopback address for the family. */
var _lo4 = Tsockaddr_in{Fsin_family: uint16(m_PF_INET), Fsin_port: uint16(65535), Fsin_addr: Tin_addr{Fs_addr: uint32(0x0100007f)}}

var _lo6 = Tsockaddr_in6{Fsin6_family: uint16(m_PF_INET6), Fsin6_port: uint16(65535), Fsin6_addr: Tin6_addr{F__in6_union: *(*struct {
	F__s6_addr16 [0][8]Tuint16_t
	F__s6_addr32 [0][4]Tuint32_t
	F__s6_addr   [16]Tuint8_t
})(unsafe.Pointer(&[16]Tuint8_t{
	0:  uint8(0),
	1:  uint8(0),
	2:  uint8(0),
	3:  uint8(0),
	4:  uint8(0),
	5:  uint8(0),
	6:  uint8(0),
	7:  uint8(0),
	8:  uint8(0),
	9:  uint8(0),
	10: uint8(0),
	11: uint8(0),
	12: uint8(0),
	13: uint8(0),
	14: uint8(0),
	15: uint8(1)}))}}

const m_NO_RECOVERY = 3

type Tip_mreq = struct {
	Fimr_multiaddr Tin_addr
	Fimr_interface Tin_addr
}

type Tip_mreqn = struct {
	Fimr_multiaddr Tin_addr
	Fimr_address   Tin_addr
	Fimr_ifindex   int32
}

type Tip_mreq_source = struct {
	Fimr_multiaddr  Tin_addr
	Fimr_interface  Tin_addr
	Fimr_sourceaddr Tin_addr
}

type Tip_msfilter = struct {
	Fimsf_multiaddr Tin_addr
	Fimsf_interface Tin_addr
	Fimsf_fmode     Tuint32_t
	Fimsf_numsrc    Tuint32_t
	Fimsf_slist     [1]Tin_addr
}

type Tgroup_req = struct {
	Fgr_interface Tuint32_t
	Fgr_group     Tsockaddr_storage
}

type Tgroup_source_req = struct {
	Fgsr_interface Tuint32_t
	Fgsr_group     Tsockaddr_storage
	Fgsr_source    Tsockaddr_storage
}

type Tgroup_filter = struct {
	Fgf_interface Tuint32_t
	Fgf_group     Tsockaddr_storage
	Fgf_fmode     Tuint32_t
	Fgf_numsrc    Tuint32_t
	Fgf_slist     [1]Tsockaddr_storage
}

type Tin_pktinfo = struct {
	Fipi_ifindex  int32
	Fipi_spec_dst Tin_addr
	Fipi_addr     Tin_addr
}

type Tin6_pktinfo = struct {
	Fipi6_addr    Tin6_addr
	Fipi6_ifindex uint32
}

type Tip6_mtuinfo = struct {
	Fip6m_addr Tsockaddr_in6
	Fip6m_mtu  Tuint32_t
}

func x_gethostbyaddr(tls *TLS, a uintptr, l Tsocklen_t, af int32) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var err int32
	var size Tsize_t
	var _ /* res at bp+0 */ uintptr
	size = uint64(63)
	for cond := true; cond; cond = err == int32(m_ERANGE) {
		x_free(tls, _h)
		size = size + (size + Uint64FromInt32(1))
		_h = _default_malloc(tls, size)
		if !(_h != 0) {
			*(*int32)(unsafe.Pointer(x___h_errno_location(tls))) = int32(m_NO_RECOVERY)
			return uintptr(0)
		}
		err = x_gethostbyaddr_r(tls, a, l, af, _h, _h+UintptrFromInt32(1)*32, size-uint64(32), bp, x___h_errno_location(tls))
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _h uintptr

const m_EBADMSG = 74
const m_TRY_AGAIN = 2

func x_gethostbyaddr_r(tls *TLS, a uintptr, l Tsocklen_t, af int32, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var i int32
	var sl Tsocklen_t
	var _ /* sa at bp+0 */ struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	var v1 uint64
	*(*Tsa_family_t)(unsafe.Pointer(bp)) = uint16(af)
	if af == int32(m_PF_INET6) {
		v1 = uint64(28)
	} else {
		v1 = uint64(16)
	}
	sl = uint32(v1)
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Load address argument into sockaddr structure */
	if af == int32(m_PF_INET6) && l == uint32(16) {
		x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp))).Fsin6_addr)), a, uint64(16))
	} else {
		if af == int32(m_PF_INET) && l == uint32(4) {
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp))).Fsin.Fsin_addr)), a, uint64(4))
		} else {
			*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
			return int32(m_EINVAL)
		}
	}
	/* Align buffer and check for space for pointers and ip address */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen <= Uint64FromInt32(5)*Uint64FromInt64(8)-uint64(i)+uint64(l) {
		return int32(m_ERANGE)
	}
	buf = buf + uintptr(Uint64FromInt64(8)-uint64(i))
	buflen = buflen - (Uint64FromInt32(5)*Uint64FromInt64(8) - uint64(i) + uint64(l))
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf = buf + uintptr(Uint64FromInt32(2)*Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf = buf + uintptr(Uint64FromInt32(2)*Uint64FromInt64(8))
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + UintptrFromInt32(0)*8)) = buf
	x_memcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + UintptrFromInt32(0)*8)), a, uint64(l))
	buf = buf + uintptr(l)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + UintptrFromInt32(1)*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(0)*8)) = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(1)*8)) = uintptr(0)
	switch x_getnameinfo(tls, bp, sl, buf, uint32(buflen), uintptr(0), uint32(0), int32(0)) {
	case -int32(3):
		*(*int32)(unsafe.Pointer(err)) = int32(m_TRY_AGAIN)
		return int32(m_EAGAIN)
	case -int32(12):
		return int32(m_ERANGE)
	default:
		fallthrough
	case -int32(4):
		*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
		return int32(m_EBADMSG)
	case -int32(11):
		*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	case int32(0):
		break
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	(*Thostent)(unsafe.Pointer(h)).Fh_length = int32(l)
	(*Thostent)(unsafe.Pointer(h)).Fh_name = *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(0)*8))
	*(*uintptr)(unsafe.Pointer(res)) = h
	return int32(0)
}

func x_gethostbyname(tls *TLS, name uintptr) (r uintptr) {
	return x_gethostbyname2(tls, name, int32(m_PF_INET))
}

func x_gethostbyname2(tls *TLS, name uintptr, af int32) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var err int32
	var size Tsize_t
	var _ /* res at bp+0 */ uintptr
	size = uint64(63)
	for cond := true; cond; cond = err == int32(m_ERANGE) {
		x_free(tls, _h1)
		size = size + (size + Uint64FromInt32(1))
		_h1 = _default_malloc(tls, size)
		if !(_h1 != 0) {
			*(*int32)(unsafe.Pointer(x___h_errno_location(tls))) = int32(m_NO_RECOVERY)
			return uintptr(0)
		}
		err = x_gethostbyname2_r(tls, name, af, _h1, _h1+UintptrFromInt32(1)*32, size-uint64(32), bp, x___h_errno_location(tls))
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _h1 uintptr

const m_HOST_NOT_FOUND = 1
const m_NO_DATA = 4

func x_gethostbyname2_r(tls *TLS, name uintptr, af int32, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	bp := tls.Alloc(1600) /* tlsAllocs 1600 maxValist 0 */
	defer tls.Free(1600)
	var align Tsize_t
	var cnt int32
	var i int32
	var need Tsize_t
	var _ /* addrs at bp+0 */ [48]Taddress
	var _ /* canon at bp+1344 */ [256]int8
	var v1 int32
	var v2 uintptr
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	cnt = x___lookup_name(tls, bp, bp+1344, name, af, int32(m_AI_CANONNAME))
	if cnt < int32(0) {
		switch cnt {
		case -int32(2):
			*(*int32)(unsafe.Pointer(err)) = int32(m_HOST_NOT_FOUND)
			return int32(0)
		case -int32(5):
			*(*int32)(unsafe.Pointer(err)) = int32(m_NO_DATA)
			return int32(0)
		case -int32(3):
			*(*int32)(unsafe.Pointer(err)) = int32(m_TRY_AGAIN)
			return int32(m_EAGAIN)
		default:
			fallthrough
		case -int32(4):
			*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
			return int32(m_EBADMSG)
		case -int32(11):
			*(*int32)(unsafe.Pointer(err)) = int32(m_NO_RECOVERY)
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	if af == int32(m_PF_INET6) {
		v1 = int32(16)
	} else {
		v1 = int32(4)
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_length = v1
	/* Align buffer */
	align = -uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1))
	need = Uint64FromInt32(4) * Uint64FromInt64(8)
	need = need + uint64(cnt+Int32FromInt32(1))*(Uint64FromInt64(8)+uint64((*Thostent)(unsafe.Pointer(h)).Fh_length))
	need = need + (x_strlen(tls, name) + Uint64FromInt32(1))
	need = need + (x_strlen(tls, bp+1344) + Uint64FromInt32(1))
	need = need + align
	if need > buflen {
		return int32(m_ERANGE)
	}
	buf = buf + uintptr(align)
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf = buf + uintptr(Uint64FromInt32(3)*Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf = buf + uintptr(uint64(cnt+Int32FromInt32(1))*Uint64FromInt64(8))
	for i = int32(0); i < cnt; i++ {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = buf
		buf = buf + uintptr((*Thostent)(unsafe.Pointer(h)).Fh_length)
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)), uintptr(unsafe.Pointer(&(*(*[48]Taddress)(unsafe.Pointer(bp)))[i].Faddr)), uint64((*Thostent)(unsafe.Pointer(h)).Fh_length))
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = uintptr(0)
	v2 = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(0)*8)) = v2
	(*Thostent)(unsafe.Pointer(h)).Fh_name = v2
	x_strcpy(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, bp+1344)
	buf = buf + uintptr(x_strlen(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name)+Uint64FromInt32(1))
	if x_strcmp(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, name) != 0 {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(1)*8)) = buf
		x_strcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(1)*8)), name)
		buf = buf + uintptr(x_strlen(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(1)*8)))+Uint64FromInt32(1))
	} else {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(1)*8)) = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + UintptrFromInt32(2)*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(res)) = h
	return int32(0)
}

func x_gethostbyname_r(tls *TLS, name uintptr, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	return x_gethostbyname2_r(tls, name, int32(m_PF_INET), h, buf, buflen, res, err)
}

const m_IFADDRS_HASH_SIZE = 64
const m_IFA_ADDRESS = 1
const m_IFA_BROADCAST = 4
const m_IFA_LABEL = 3
const m_IFA_LOCAL = 2
const m_IFLA_ADDRESS = 1
const m_IFLA_BROADCAST = 2
const m_IFLA_IFNAME = 3
const m_IFLA_STATS = 7
const m_IF_NAMESIZE = 16
const m_PF_PACKET = 17
const m_RTM_NEWLINK = 16

type Tifaddrs = struct {
	Fifa_next    uintptr
	Fifa_name    uintptr
	Fifa_flags   uint32
	Fifa_addr    uintptr
	Fifa_netmask uintptr
	Fifa_ifu     struct {
		Fifu_dstaddr   [0]uintptr
		Fifu_broadaddr uintptr
	}
	Fifa_data uintptr
}

type Tif_nameindex = struct {
	Fif_index uint32
	Fif_name  uintptr
}

type Tifaddr = struct {
	Fifa_addr Tsockaddr
	Fifa_ifu  struct {
		Fifu_dstaddr   [0]Tsockaddr
		Fifu_broadaddr Tsockaddr
	}
	Fifa_ifp  uintptr
	Fifa_next uintptr
}

type Tifmap = struct {
	Fmem_start   uint64
	Fmem_end     uint64
	Fbase_addr   uint16
	Firq         uint8
	Fdma         uint8
	Fport        uint8
	F__ccgo_pad6 [3]byte
}

type Tifreq = struct {
	Fifr_ifrn struct {
		Fifrn_name [16]int8
	}
	Fifr_ifru struct {
		Fifru_dstaddr   [0]Tsockaddr
		Fifru_broadaddr [0]Tsockaddr
		Fifru_netmask   [0]Tsockaddr
		Fifru_hwaddr    [0]Tsockaddr
		Fifru_flags     [0]int16
		Fifru_ivalue    [0]int32
		Fifru_mtu       [0]int32
		Fifru_map       [0]Tifmap
		Fifru_slave     [0][16]int8
		Fifru_newname   [0][16]int8
		Fifru_data      [0]uintptr
		Fifru_addr      Tsockaddr
		F__ccgo_pad12   [8]byte
	}
}

type Tifconf = struct {
	Fifc_len  int32
	Fifc_ifcu struct {
		Fifcu_req [0]uintptr
		Fifcu_buf uintptr
	}
}

type Tnlmsghdr = struct {
	Fnlmsg_len   Tuint32_t
	Fnlmsg_type  Tuint16_t
	Fnlmsg_flags Tuint16_t
	Fnlmsg_seq   Tuint32_t
	Fnlmsg_pid   Tuint32_t
}

type Trtattr = struct {
	Frta_len  uint16
	Frta_type uint16
}

type Trtgenmsg = struct {
	Frtgen_family uint8
}

type Tifinfomsg = struct {
	Fifi_family uint8
	F__ifi_pad  uint8
	Fifi_type   uint16
	Fifi_index  int32
	Fifi_flags  uint32
	Fifi_change uint32
}

type Tifaddrmsg = struct {
	Fifa_family    Tuint8_t
	Fifa_prefixlen Tuint8_t
	Fifa_flags     Tuint8_t
	Fifa_scope     Tuint8_t
	Fifa_index     Tuint32_t
}

/* getifaddrs() reports hardware addresses with PF_PACKET that implies
 * struct sockaddr_ll.  But e.g. Infiniband socket address length is
 * longer than sockaddr_ll.ssl_addr[8] can hold. Use this hack struct
 * to extend ssl_addr - callers should be able to still use it. */
type Tsockaddr_ll_hack = struct {
	Fsll_family   uint16
	Fsll_protocol uint16
	Fsll_ifindex  int32
	Fsll_hatype   uint16
	Fsll_pkttype  uint8
	Fsll_halen    uint8
	Fsll_addr     [24]uint8
}

type Tsockany = struct {
	Fll          [0]Tsockaddr_ll_hack
	Fv4          [0]Tsockaddr_in
	Fv6          [0]Tsockaddr_in6
	Fsa          Tsockaddr
	F__ccgo_pad4 [20]byte
}

type Tifaddrs_storage = struct {
	Fifa         Tifaddrs
	Fhash_next   uintptr
	Faddr        Tsockany
	Fnetmask     Tsockany
	Fifu         Tsockany
	Findex       uint32
	Fname        [17]int8
	F__ccgo_pad7 [7]byte
}

type Tifaddrs_ctx = struct {
	Ffirst uintptr
	Flast  uintptr
	Fhash  [64]uintptr
}

func x_freeifaddrs(tls *TLS, ifp uintptr) {
	var n uintptr
	for ifp != 0 {
		n = (*Tifaddrs)(unsafe.Pointer(ifp)).Fifa_next
		x_free(tls, ifp)
		ifp = n
	}
}

func _copy_addr(tls *TLS, r uintptr, af int32, sa uintptr, addr uintptr, addrlen Tsize_t, ifindex int32) {
	var dst uintptr
	var len1 int32
	switch af {
	case int32(m_PF_INET):
		dst = uintptr(unsafe.Pointer(&(*(*Tsockaddr_in)(unsafe.Pointer(sa))).Fsin_addr))
		len1 = int32(4)
	case int32(m_PF_INET6):
		dst = uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(sa))).Fsin6_addr))
		len1 = int32(16)
		if int32(*(*Tuint8_t)(unsafe.Pointer(addr + UintptrFromInt32(0)))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(addr + UintptrFromInt32(1))))&int32(0xc0) == int32(0x80) || int32(*(*Tuint8_t)(unsafe.Pointer(addr + UintptrFromInt32(0)))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(addr + UintptrFromInt32(1))))&int32(0xf) == int32(0x2) {
			(*(*Tsockaddr_in6)(unsafe.Pointer(sa))).Fsin6_scope_id = uint32(ifindex)
		}
	default:
		return
	}
	if addrlen < uint64(len1) {
		return
	}
	(*Tsockany)(unsafe.Pointer(sa)).Fsa.Fsa_family = uint16(af)
	x_memcpy(tls, dst, addr, uint64(len1))
	*(*uintptr)(unsafe.Pointer(r)) = sa
}

func _gen_netmask(tls *TLS, r uintptr, af int32, sa uintptr, prefixlen int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var i int32
	var _ /* addr at bp+0 */ [16]Tuint8_t
	var v1 int32
	*(*[16]Tuint8_t)(unsafe.Pointer(bp)) = [16]Tuint8_t{}
	if uint64(prefixlen) > Uint64FromInt32(8)*Uint64FromInt64(16) {
		prefixlen = int32(Uint64FromInt32(8) * Uint64FromInt64(16))
	}
	i = prefixlen / int32(8)
	x_memset(tls, bp, int32(0xff), uint64(i))
	if uint64(i) < uint64(16) {
		v1 = i
		i++
		(*(*[16]Tuint8_t)(unsafe.Pointer(bp)))[v1] = uint8(int32(0xff) << (int32(8) - prefixlen%int32(8)))
	}
	_copy_addr(tls, r, af, sa, bp, uint64(16), int32(0))
}

func _copy_lladdr(tls *TLS, r uintptr, sa uintptr, addr uintptr, addrlen Tsize_t, ifindex int32, hatype uint16) {
	if addrlen > uint64(24) {
		return
	}
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_family = uint16(m_PF_PACKET)
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_ifindex = ifindex
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_hatype = hatype
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_halen = uint8(addrlen)
	x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_addr)), addr, addrlen)
	*(*uintptr)(unsafe.Pointer(r)) = sa
}

func _netlink_msg_to_ifaddr(tls *TLS, pctx uintptr, h uintptr) (r int32) {
	var bucket uint32
	var ctx uintptr
	var ifa uintptr
	var ifi uintptr
	var ifs uintptr
	var ifs0 uintptr
	var rta uintptr
	var stats_len int32
	ctx = pctx
	ifi = h + UintptrFromInt64(16)
	ifa = h + UintptrFromInt64(16)
	stats_len = int32(0)
	if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(m_RTM_NEWLINK) {
		for rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(16)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3))); uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4); rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3)) {
			if int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) != int32(m_IFLA_STATS) {
				continue
			}
			stats_len = int32(uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len) - Uint64FromInt64(4))
			break
		}
	} else {
		for ifs0 = *(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index%Uint32FromInt32(m_IFADDRS_HASH_SIZE))*8)); ifs0 != 0; ifs0 = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fhash_next {
			if (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Findex == (*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index {
				break
			}
		}
		if !(ifs0 != 0) {
			return int32(0)
		}
	}
	ifs = x_calloc(tls, uint64(1), uint64(200)+uint64(stats_len))
	if ifs == uintptr(0) {
		return -int32(1)
	}
	if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(m_RTM_NEWLINK) {
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Findex = uint32((*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index)
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_flags = (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_flags
		for rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(16)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3))); uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4); rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3)) {
			switch int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) {
			case int32(m_IFLA_IFNAME):
				if uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-uint64(4) < uint64(17) {
					x_memcpy(tls, ifs+176, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = ifs + 176
				}
			case int32(m_IFLA_ADDRESS):
				_copy_lladdr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr)), ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index, (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_type)
			case int32(m_IFLA_BROADCAST):
				_copy_lladdr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_ifu.Fifu_broadaddr)), ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index, (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_type)
			case int32(m_IFLA_STATS):
				(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_data = ifs + UintptrFromInt32(1)*200
				x_memcpy(tls, (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_data, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
				break
			}
		}
		if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name != 0 {
			bucket = (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Findex % uint32(m_IFADDRS_HASH_SIZE)
			(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fhash_next = *(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr(bucket)*8))
			*(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr(bucket)*8)) = ifs
		}
	} else {
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fifa.Fifa_name
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_flags = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fifa.Fifa_flags
		for rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(8)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3))); uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4); rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3)) {
			switch int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) {
			case int32(m_IFA_ADDRESS):
				/* If ifa_addr is already set we, received an IFA_LOCAL before
				 * so treat this as destination address */
				if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
					_copy_addr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_ifu)), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
				} else {
					_copy_addr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr)), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
				}
			case int32(m_IFA_BROADCAST):
				_copy_addr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_ifu.Fifu_broadaddr)), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
			case int32(m_IFA_LOCAL):
				/* If ifa_addr is set and we get IFA_LOCAL, assume we have
				 * a point-to-point network. Move address to correct field. */
				if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifu = (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Faddr
					*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_ifu)))) = uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifu.Fsa))
					x_memset(tls, ifs+64, int32(0), uint64(36))
				}
				_copy_addr(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr)), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
			case int32(m_IFA_LABEL):
				if uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-uint64(4) < uint64(17) {
					x_memcpy(tls, ifs+176, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = ifs + 176
				}
				break
			}
		}
		if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
			_gen_netmask(tls, uintptr(unsafe.Pointer(&(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_netmask)), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+100, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_prefixlen))
		}
	}
	if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name != 0 {
		if !((*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst != 0) {
			(*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst = ifs
		}
		if (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast != 0 {
			(*Tifaddrs)(unsafe.Pointer((*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast)).Fifa_next = ifs
		}
		(*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast = ifs
	} else {
		x_free(tls, ifs)
	}
	return int32(0)
}

func x_getifaddrs(tls *TLS, ifap uintptr) (r1 int32) {
	bp := tls.Alloc(528) /* tlsAllocs 528 maxValist 0 */
	defer tls.Free(528)
	var ctx uintptr
	var r int32
	var _ /* _ctx at bp+0 */ Tifaddrs_ctx
	ctx = bp
	x_memset(tls, ctx, int32(0), uint64(528))
	r = x___rtnetlink_enumerate(tls, int32(m_PF_UNSPEC), int32(m_PF_UNSPEC), __ccgo_fp(_netlink_msg_to_ifaddr), ctx)
	if r == int32(0) {
		*(*uintptr)(unsafe.Pointer(ifap)) = (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst
	} else {
		x_freeifaddrs(tls, (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst)
	}
	return r
}

const m_NI_DGRAM = 16
const m_NI_NAMEREQD = 8
const m_NI_NUMERICHOST = 1
const m_NI_NUMERICSCOPE = 256
const m_NI_NUMERICSERV = 2
const m_RR_PTR = 12

func _itoa(tls *TLS, p uintptr, x uint32) (r uintptr) {
	var v1 uintptr
	var v2 uintptr
	p = p + uintptr(Uint64FromInt32(3)*Uint64FromInt64(4))
	p--
	v1 = p
	*(*int8)(unsafe.Pointer(v1)) = int8(0)
	for cond := true; cond; cond = x != 0 {
		p--
		v2 = p
		*(*int8)(unsafe.Pointer(v2)) = int8(uint32('0') + x%uint32(10))
		x = x / Uint32FromInt32(10)
	}
	return p
}

func _mkptr4(tls *TLS, s uintptr, ip uintptr) {
	bp := tls.Alloc(40) /* tlsAllocs 0 maxValist 4 */
	defer tls.Free(40)
	x_sprintf(tls, s, ts+1528, VaList(bp+8, int32(*(*uint8)(unsafe.Pointer(ip + UintptrFromInt32(3)))), int32(*(*uint8)(unsafe.Pointer(ip + UintptrFromInt32(2)))), int32(*(*uint8)(unsafe.Pointer(ip + UintptrFromInt32(1)))), int32(*(*uint8)(unsafe.Pointer(ip + UintptrFromInt32(0))))))
}

func _mkptr6(tls *TLS, s uintptr, ip uintptr) {
	var i int32
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	for i = int32(15); i >= int32(0); i-- {
		v1 = s
		s++
		*(*int8)(unsafe.Pointer(v1)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))&int32(15)]
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v2)) = int8('.')
		v3 = s
		s++
		*(*int8)(unsafe.Pointer(v3)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))>>int32(4)]
		v4 = s
		s++
		*(*int8)(unsafe.Pointer(v4)) = int8('.')
	}
	x_strcpy(tls, s, ts+1553)
}

var _xdigits = [17]int8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}

func _reverse_hosts(tls *TLS, buf uintptr, a uintptr, scopeid uint32, family int32) {
	bp := tls.Alloc(1824) /* tlsAllocs 1824 maxValist 0 */
	defer tls.Free(1824)
	var f uintptr
	var p uintptr
	var z uintptr
	var _ /* _buf at bp+512 */ [1032]uint8
	var _ /* _f at bp+1592 */ TFILE
	var _ /* atmp at bp+1544 */ [16]uint8
	var _ /* iplit at bp+1560 */ Taddress
	var _ /* line at bp+0 */ [512]int8
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	f = x___fopen_rb_ca(tls, ts+1562, bp+1592, bp+512, uint64(1032))
	if !(f != 0) {
		return
	}
	if family == int32(m_PF_INET) {
		x_memcpy(tls, bp+1544+uintptr(12), a, uint64(4))
		x_memcpy(tls, bp+1544, ts+1573, uint64(12))
		a = bp + 1544
	}
	for x_fgets(tls, bp, int32(512), f) != 0 {
		v1 = x_strchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*int8)(unsafe.Pointer(v2)) = int8('\n')
			*(*int8)(unsafe.Pointer(p)) = Int8FromInt32(0)
		}
		for p = bp; *(*int8)(unsafe.Pointer(p)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		if !(*(*int8)(unsafe.Pointer(p)) != 0) {
			continue
		}
		v3 = p
		p++
		*(*int8)(unsafe.Pointer(v3)) = int8(0)
		if x___lookup_ipliteral(tls, bp+1560, bp, int32(m_PF_UNSPEC)) <= int32(0) {
			continue
		}
		if (*(*Taddress)(unsafe.Pointer(bp + 1560))).Ffamily == int32(m_PF_INET) {
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(bp + 1560))).Faddr))+uintptr(12), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(bp + 1560))).Faddr)), uint64(4))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(bp + 1560))).Faddr)), ts+1573, uint64(12))
			(*(*Taddress)(unsafe.Pointer(bp + 1560))).Fscopeid = uint32(0)
		}
		if x_memcmp(tls, a, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(bp + 1560))).Faddr)), uint64(16)) != 0 || (*(*Taddress)(unsafe.Pointer(bp + 1560))).Fscopeid != scopeid {
			continue
		}
		for ; *(*int8)(unsafe.Pointer(p)) != 0 && ___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		for z = p; *(*int8)(unsafe.Pointer(z)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(z)))) != 0); z++ {
		}
		*(*int8)(unsafe.Pointer(z)) = int8(0)
		if int64(z)-int64(p) < int64(256) {
			x_memcpy(tls, buf, p, uint64(int64(z)-int64(p)+int64(1)))
			break
		}
	}
	x___fclose_ca(tls, f)
}

func _reverse_services(tls *TLS, buf uintptr, port int32, dgram int32) {
	bp := tls.Alloc(1400) /* tlsAllocs 1400 maxValist 0 */
	defer tls.Free(1400)
	var f uintptr
	var p uintptr
	var svport uint64
	var _ /* _buf at bp+136 */ [1032]uint8
	var _ /* _f at bp+1168 */ TFILE
	var _ /* line at bp+0 */ [128]int8
	var _ /* z at bp+128 */ uintptr
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	f = x___fopen_rb_ca(tls, ts+1586, bp+1168, bp+136, uint64(1032))
	if !(f != 0) {
		return
	}
	for x_fgets(tls, bp, int32(128), f) != 0 {
		v1 = x_strchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*int8)(unsafe.Pointer(v2)) = int8('\n')
			*(*int8)(unsafe.Pointer(p)) = Int8FromInt32(0)
		}
		for p = bp; *(*int8)(unsafe.Pointer(p)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		if !(*(*int8)(unsafe.Pointer(p)) != 0) {
			continue
		}
		v3 = p
		p++
		*(*int8)(unsafe.Pointer(v3)) = int8(0)
		svport = x_strtoul(tls, p, bp+128, int32(10))
		if svport != uint64(port) || *(*uintptr)(unsafe.Pointer(bp + 128)) == p {
			continue
		}
		if dgram != 0 && x_strncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+1600, uint64(4)) != 0 {
			continue
		}
		if !(dgram != 0) && x_strncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+1605, uint64(4)) != 0 {
			continue
		}
		if int64(p)-Tptrdiff_t(bp) > int64(32) {
			continue
		}
		x_memcpy(tls, buf, bp, uint64(int64(p)-Tptrdiff_t(bp)))
		break
	}
	x___fclose_ca(tls, f)
}

func _dns_parse_callback(tls *TLS, c uintptr, rr int32, data uintptr, len1 int32, packet uintptr, plen int32) (r int32) {
	if rr != int32(m_RR_PTR) {
		return int32(0)
	}
	if x___dn_expand(tls, packet, packet+uintptr(plen), data, c, int32(256)) <= int32(0) {
		*(*int8)(unsafe.Pointer(c)) = int8(0)
	}
	return int32(0)
}

func x_getnameinfo(tls *TLS, sa uintptr, sl Tsocklen_t, node uintptr, nodelen Tsocklen_t, serv uintptr, servlen Tsocklen_t, flags int32) (r int32) {
	bp := tls.Alloc(976) /* tlsAllocs 976 maxValist 0 */
	defer tls.Free(976)
	var a uintptr
	var af int32
	var p uintptr
	var p1 uintptr
	var port int32
	var qlen int32
	var rlen int32
	var scopeid uint32
	var _ /* buf at bp+78 */ [256]int8
	var _ /* num at bp+334 */ [13]int8
	var _ /* ptr at bp+0 */ [78]int8
	var _ /* query at bp+347 */ [96]uint8
	var _ /* reply at bp+443 */ [512]uint8
	var _ /* tmp at bp+955 */ [17]int8
	var v1 uintptr
	af = int32((*Tsockaddr)(unsafe.Pointer(sa)).Fsa_family)
	switch af {
	case int32(m_PF_INET):
		a = sa + 4
		if uint64(sl) < uint64(16) {
			return -int32(6)
		}
		_mkptr4(tls, bp, a)
		scopeid = uint32(0)
	case int32(m_PF_INET6):
		a = sa + 8
		if uint64(sl) < uint64(28) {
			return -int32(6)
		}
		if x_memcmp(tls, a, ts+1573, uint64(12)) != 0 {
			_mkptr6(tls, bp, a)
		} else {
			_mkptr4(tls, bp, a+uintptr(12))
		}
		scopeid = (*Tsockaddr_in6)(unsafe.Pointer(sa)).Fsin6_scope_id
	default:
		return -int32(6)
	}
	if node != 0 && nodelen != 0 {
		(*(*[256]int8)(unsafe.Pointer(bp + 78)))[int32(0)] = int8(0)
		if !(flags&Int32FromInt32(m_NI_NUMERICHOST) != 0) {
			_reverse_hosts(tls, bp+78, a, scopeid, af)
		}
		if !(*(*int8)(unsafe.Pointer(bp + 78)) != 0) && !(flags&Int32FromInt32(m_NI_NUMERICHOST) != 0) {
			qlen = x___res_mkquery(tls, int32(0), bp, int32(1), int32(m_RR_PTR), uintptr(0), int32(0), uintptr(0), bp+347, int32(96))
			(*(*[96]uint8)(unsafe.Pointer(bp + 347)))[int32(3)] = uint8(0) /* don't need AD flag */
			rlen = x___res_send(tls, bp+347, qlen, bp+443, int32(512))
			(*(*[256]int8)(unsafe.Pointer(bp + 78)))[int32(0)] = int8(0)
			if rlen > int32(0) {
				x___dns_parse(tls, bp+443, rlen, __ccgo_fp(_dns_parse_callback), bp+78)
			}
		}
		if !(*(*int8)(unsafe.Pointer(bp + 78)) != 0) {
			if flags&int32(m_NI_NAMEREQD) != 0 {
				return -int32(2)
			}
			x_inet_ntop(tls, af, a, bp+78, uint32(256))
			if scopeid != 0 {
				p = uintptr(0)
				if !(flags&Int32FromInt32(m_NI_NUMERICSCOPE) != 0) && (int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(0)))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(1))))&int32(0xc0) == int32(0x80) || int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(0)))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(1))))&int32(0xf) == int32(0x2)) {
					p = x_if_indextoname(tls, scopeid, bp+955+uintptr(1))
				}
				if !(p != 0) {
					p = _itoa(tls, bp+334, scopeid)
				}
				p--
				v1 = p
				*(*int8)(unsafe.Pointer(v1)) = int8('%')
				x_strcat(tls, bp+78, p)
			}
		}
		if x_strlen(tls, bp+78) >= uint64(nodelen) {
			return -int32(12)
		}
		x_strcpy(tls, node, bp+78)
	}
	if serv != 0 && servlen != 0 {
		p1 = bp + 78
		port = int32(x_ntohs(tls, (*Tsockaddr_in)(unsafe.Pointer(sa)).Fsin_port))
		(*(*[256]int8)(unsafe.Pointer(bp + 78)))[int32(0)] = int8(0)
		if !(flags&Int32FromInt32(m_NI_NUMERICSERV) != 0) {
			_reverse_services(tls, bp+78, port, flags&int32(m_NI_DGRAM))
		}
		if !(*(*int8)(unsafe.Pointer(p1)) != 0) {
			p1 = _itoa(tls, bp+334, uint32(port))
		}
		if x_strlen(tls, p1) >= uint64(servlen) {
			return -int32(12)
		}
		x_strcpy(tls, serv, p1)
	}
	return int32(0)
}

const m_SYS_getpeername = 52
const m___SC_getpeername = 7

func x_getpeername(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_getpeername), int32(m___SC_getpeername), int32(0), int64(fd), int64(addr), int64(len1), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

func x_getservbyname(tls *TLS, name uintptr, prots uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_getservbyname_r(tls, name, prots, uintptr(unsafe.Pointer(&_se)), uintptr(unsafe.Pointer(&_buf3)), uint64(16), bp) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_se))
}

var _se Tservent

var _buf3 [2]uintptr

const m_IPPROTO_TCP = 6

func x_getservbyname_r(tls *TLS, name uintptr, prots uintptr, se uintptr, buf uintptr, buflen Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var align int32
	var cnt int32
	var proto int32
	var _ /* end at bp+8 */ uintptr
	var _ /* servs at bp+0 */ [2]Tservice
	var v1 uintptr
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Don't treat numeric port number strings as service records. */
	*(*uintptr)(unsafe.Pointer(bp + 8)) = ts
	x_strtoul(tls, name, bp+8, int32(10))
	if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0) {
		return int32(m_ENOENT)
	}
	/* Align buffer */
	align = int32(-uint64(buf) & (Uint64FromInt64(16) - Uint64FromInt64(8) - Uint64FromInt32(1)))
	if buflen < Uint64FromInt32(2)*Uint64FromInt64(8)+uint64(align) {
		return int32(m_ERANGE)
	}
	buf = buf + uintptr(align)
	if !(prots != 0) {
		proto = int32(0)
	} else {
		if !(x_strcmp(tls, prots, ts+1610) != 0) {
			proto = int32(m_IPPROTO_TCP)
		} else {
			if !(x_strcmp(tls, prots, ts+1614) != 0) {
				proto = int32(m_IPPROTO_UDP)
			} else {
				return int32(m_EINVAL)
			}
		}
	}
	cnt = x___lookup_serv(tls, bp, name, proto, int32(0), int32(0))
	if cnt < int32(0) {
		switch cnt {
		case -int32(10):
			fallthrough
		case -int32(11):
			return int32(m_ENOMEM)
		default:
			return int32(m_ENOENT)
		}
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_name = name
	(*Tservent)(unsafe.Pointer(se)).Fs_aliases = buf
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + UintptrFromInt32(0)*8)) = (*Tservent)(unsafe.Pointer(se)).Fs_name
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + UintptrFromInt32(1)*8)) = uintptr(0)
	(*Tservent)(unsafe.Pointer(se)).Fs_port = int32(x_htons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[int32(0)].Fport))
	if int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[int32(0)].Fproto) == int32(m_IPPROTO_TCP) {
		v1 = ts + 1610
	} else {
		v1 = ts + 1614
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_proto = v1
	*(*uintptr)(unsafe.Pointer(res)) = se
	return int32(0)
}

func x_getservbyport(tls *TLS, port int32, prots uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if x_getservbyport_r(tls, port, prots, uintptr(unsafe.Pointer(&_se1)), uintptr(unsafe.Pointer(&_buf4)), uint64(32), bp) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_se1))
}

var _se1 Tservent

var _buf4 [4]int64

func x_getservbyport_r(tls *TLS, port int32, prots uintptr, se uintptr, buf uintptr, buflen Tsize_t, res uintptr) (r1 int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var i int32
	var r int32
	var _ /* sin at bp+0 */ Tsockaddr_in
	var v1 uintptr
	var v2 int32
	*(*Tsockaddr_in)(unsafe.Pointer(bp)) = Tsockaddr_in{Fsin_family: uint16(m_PF_INET), Fsin_port: uint16(port)}
	if !(prots != 0) {
		r = x_getservbyport_r(tls, port, ts+1610, se, buf, buflen, res)
		if r != 0 {
			r = x_getservbyport_r(tls, port, ts+1614, se, buf, buflen, res)
		}
		return r
	}
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Align buffer */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen <= Uint64FromInt32(3)*Uint64FromInt64(8)-uint64(i) {
		return int32(m_ERANGE)
	}
	buf = buf + uintptr(Uint64FromInt64(8)-uint64(i))
	buflen = buflen - (Uint64FromInt64(8) - uint64(i))
	if x_strcmp(tls, prots, ts+1610) != 0 && x_strcmp(tls, prots, ts+1614) != 0 {
		return int32(m_EINVAL)
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_port = port
	(*Tservent)(unsafe.Pointer(se)).Fs_proto = prots
	(*Tservent)(unsafe.Pointer(se)).Fs_aliases = buf
	buf = buf + uintptr(Uint64FromInt32(2)*Uint64FromInt64(8))
	buflen = buflen - Uint64FromInt32(2)*Uint64FromInt64(8)
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + UintptrFromInt32(1)*8)) = uintptr(0)
	v1 = buf
	(*Tservent)(unsafe.Pointer(se)).Fs_name = v1
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + UintptrFromInt32(0)*8)) = v1
	if x_strcmp(tls, prots, ts+1614) != 0 {
		v2 = int32(0)
	} else {
		v2 = int32(m_NI_DGRAM)
	}
	switch x_getnameinfo(tls, bp, uint32(16), uintptr(0), uint32(0), buf, uint32(buflen), v2) {
	case -int32(10):
		fallthrough
	case -int32(11):
		return int32(m_ENOMEM)
	case -int32(12):
		return int32(m_ERANGE)
	default:
		return int32(m_ENOENT)
	case int32(0):
		break
	}
	/* A numeric port string is not a service record. */
	if x_strtol(tls, buf, uintptr(0), int32(10)) == int64(x_ntohs(tls, uint16(port))) {
		return int32(m_ENOENT)
	}
	*(*uintptr)(unsafe.Pointer(res)) = se
	return int32(0)
}

const m_SYS_getsockname = 51
const m___SC_getsockname = 6

func x_getsockname(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_getsockname), int32(m___SC_getsockname), int32(0), int64(fd), int64(addr), int64(len1), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

func x_getsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1618, int32(9), uintptr(unsafe.Pointer(&___func__23)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__23 = [11]int8{'g', 'e', 't', 's', 'o', 'c', 'k', 'o', 'p', 't'}

func x___h_errno_location(tls *TLS) (r uintptr) {
	if !((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Fstack != 0) {
		return uintptr(unsafe.Pointer(&x_h_errno))
	}
	return ___get_tp(tls) + 160
}

func x_herror(tls *TLS, msg uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 0 maxValist 3 */
	defer tls.Free(32)
	var v1 uintptr
	var v2 uintptr
	if msg != 0 {
		v1 = msg
	} else {
		v1 = ts
	}
	if msg != 0 {
		v2 = ts + 560
	} else {
		v2 = ts
	}
	x_fprintf(tls, uintptr(unsafe.Pointer(&x___stderr_FILE)), ts+1643, VaList(bp+8, v1, v2, x_hstrerror(tls, *(*int32)(unsafe.Pointer(x___h_errno_location(tls))))))
}

type Tucontext_t5 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     Tstack_t
	Fuc_mcontext  Tmcontext_t1
	Fuc_sigmask   Tsigset_t
	F__fpregs_mem [64]uint64
}

var _msgs1 = [84]int8{'H', 'o', 's', 't', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func x_hstrerror(tls *TLS, ecode int32) (r uintptr) {
	var s uintptr
	s = uintptr(unsafe.Pointer(&_msgs1))
	ecode--
	for ecode != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
		goto _1
	_1:
		ecode--
		s++
	}
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	return x___lctrans_cur(tls, s)
}

func x_htonl(tls *TLS, n Tuint32_t) (r Tuint32_t) {
	var u struct {
		Fc [0]int8
		Fi int32
	}
	var v1 uint32
	u = struct {
		Fc [0]int8
		Fi int32
	}{Fi: int32(1)}
	if *(*int8)(unsafe.Pointer(&u)) != 0 {
		v1 = ___bswap_32(tls, n)
	} else {
		v1 = n
	}
	return v1
}

func x_htons(tls *TLS, n Tuint16_t) (r Tuint16_t) {
	var u struct {
		Fc [0]int8
		Fi int32
	}
	var v1 int32
	u = struct {
		Fc [0]int8
		Fi int32
	}{Fi: int32(1)}
	if *(*int8)(unsafe.Pointer(&u)) != 0 {
		v1 = int32(___bswap_16(tls, n))
	} else {
		v1 = int32(n)
	}
	return uint16(v1)
}

func x_if_freenameindex(tls *TLS, idx uintptr) {
	x_free(tls, idx)
}

const m_ENODEV = 19
const m_ENXIO = 6
const m_SIOCGIFNAME = 35088

func x_if_indextoname(tls *TLS, index uint32, name uintptr) (r1 uintptr) {
	bp := tls.Alloc(56) /* tlsAllocs 40 maxValist 1 */
	defer tls.Free(56)
	var fd int32
	var r int32
	var _ /* ifr at bp+0 */ Tifreq
	var v1 int32
	v1 = x_socket(tls, int32(m_PF_LOCAL), Int32FromInt32(m_SOCK_DGRAM)|Int32FromInt32(m_SOCK_CLOEXEC), int32(0))
	fd = v1
	if v1 < int32(0) {
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(&(*(*Tifreq)(unsafe.Pointer(bp))).Fifr_ifru)) = int32(index)
	r = x_ioctl(tls, fd, int32(m_SIOCGIFNAME), VaList(bp+48, bp))
	___syscall1(tls, int64(3), int64(fd))
	if r < int32(0) {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENODEV) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENXIO)
		}
		return uintptr(0)
	}
	return x_strncpy(tls, name, uintptr(unsafe.Pointer(&(*(*Tifreq)(unsafe.Pointer(bp))).Fifr_ifrn.Fifrn_name)), uint64(m_IF_NAMESIZE))
}

type Tifnamemap = struct {
	Fhash_next   uint32
	Findex       uint32
	Fnamelen     uint8
	Fname        [16]int8
	F__ccgo_pad4 [3]byte
}

type Tifnameindexctx = struct {
	Fnum       uint32
	Fallocated uint32
	Fstr_bytes uint32
	Flist      uintptr
	Fhash      [64]uint32
}

func x_if_nameindex(tls *TLS) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1651, int32(29), uintptr(unsafe.Pointer(&___func__24)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__24 = [13]int8{'i', 'f', '_', 'n', 'a', 'm', 'e', 'i', 'n', 'd', 'e', 'x'}

const m_SIOCGIFINDEX = 35123

func x_if_nametoindex(tls *TLS, name uintptr) (r1 uint32) {
	bp := tls.Alloc(56) /* tlsAllocs 40 maxValist 1 */
	defer tls.Free(56)
	var fd int32
	var r int32
	var _ /* ifr at bp+0 */ Tifreq
	var v1 int32
	var v2 int32
	v1 = x_socket(tls, int32(m_PF_LOCAL), Int32FromInt32(m_SOCK_DGRAM)|Int32FromInt32(m_SOCK_CLOEXEC), int32(0))
	fd = v1
	if v1 < int32(0) {
		return uint32(0)
	}
	x_strncpy(tls, uintptr(unsafe.Pointer(&(*(*Tifreq)(unsafe.Pointer(bp))).Fifr_ifrn.Fifrn_name)), name, uint64(16))
	r = x_ioctl(tls, fd, int32(m_SIOCGIFINDEX), VaList(bp+48, bp))
	___syscall1(tls, int64(3), int64(fd))
	if r < int32(0) {
		v2 = int32(0)
	} else {
		v2 = *(*int32)(unsafe.Pointer(&(*(*Tifreq)(unsafe.Pointer(bp))).Fifr_ifru))
	}
	return uint32(v2)
}

func x_inet_addr(tls *TLS, p uintptr) (r Tin_addr_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* a at bp+0 */ Tin_addr
	if !(x___inet_aton(tls, p, bp) != 0) {
		return uint32(-Int32FromInt32(1))
	}
	return (*(*Tin_addr)(unsafe.Pointer(bp))).Fs_addr
}

func x___inet_aton(tls *TLS, s0 uintptr, dest uintptr) (r int32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxValist 0 */
	defer tls.Free(40)
	var d uintptr
	var i int32
	var s uintptr
	var _ /* a at bp+0 */ [4]uint64
	var _ /* z at bp+32 */ uintptr
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	s = s0
	d = dest
	*(*[4]uint64)(unsafe.Pointer(bp)) = [4]uint64{}
	for i = int32(0); i < int32(4); i++ {
		(*(*[4]uint64)(unsafe.Pointer(bp)))[i] = x_strtoul(tls, s, bp+32, int32(0))
		if *(*uintptr)(unsafe.Pointer(bp + 32)) == s || *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != int32('.') || !(BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return int32(0)
		}
		if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) != 0) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(bp + 32)) + uintptr(1)
	}
	if i == int32(4) {
		return int32(0)
	}
	switch i {
	case int32(0):
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(1)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[int32(0)] & uint64(0xffffff)
		p1 = bp + UintptrFromInt32(0)*8
		*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) >> Uint64FromInt32(24)
		fallthrough
	case int32(1):
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(2)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[int32(1)] & uint64(0xffff)
		p2 = bp + UintptrFromInt32(1)*8
		*(*uint64)(unsafe.Pointer(p2)) = *(*uint64)(unsafe.Pointer(p2)) >> Uint64FromInt32(16)
		fallthrough
	case int32(2):
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(3)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[int32(2)] & uint64(0xff)
		p3 = bp + UintptrFromInt32(2)*8
		*(*uint64)(unsafe.Pointer(p3)) = *(*uint64)(unsafe.Pointer(p3)) >> Uint64FromInt32(8)
	}
	for i = int32(0); i < int32(4); i++ {
		if (*(*[4]uint64)(unsafe.Pointer(bp)))[i] > uint64(255) {
			return int32(0)
		}
		*(*uint8)(unsafe.Pointer(d + uintptr(i))) = uint8((*(*[4]uint64)(unsafe.Pointer(bp)))[i])
	}
	return int32(1)
}

func x_inet_network(tls *TLS, p uintptr) (r Tin_addr_t) {
	return x_ntohl(tls, x_inet_addr(tls, p))
}

func x_inet_makeaddr(tls *TLS, n Tin_addr_t, h Tin_addr_t) (r Tin_addr) {
	if n < uint32(256) {
		h = h | n<<Int32FromInt32(24)
	} else {
		if n < uint32(65536) {
			h = h | n<<Int32FromInt32(16)
		} else {
			h = h | n<<Int32FromInt32(8)
		}
	}
	return Tin_addr{Fs_addr: h}
}

func x_inet_lnaof(tls *TLS, in Tin_addr) (r Tin_addr_t) {
	var h Tuint32_t
	h = in.Fs_addr
	if h>>int32(24) < uint32(128) {
		return h & uint32(0xffffff)
	}
	if h>>int32(24) < uint32(192) {
		return h & uint32(0xffff)
	}
	return h & uint32(0xff)
}

func x_inet_netof(tls *TLS, in Tin_addr) (r Tin_addr_t) {
	var h Tuint32_t
	h = in.Fs_addr
	if h>>int32(24) < uint32(128) {
		return h >> int32(24)
	}
	if h>>int32(24) < uint32(192) {
		return h >> int32(16)
	}
	return h >> int32(8)
}

func x_inet_ntoa(tls *TLS, _in Tin_addr) (r uintptr) {
	bp := tls.Alloc(48) /* tlsAllocs 8 maxValist 4 */
	defer tls.Free(48)
	*(*Tin_addr)(unsafe.Pointer(bp)) = _in
	var a uintptr
	a = bp
	x_snprintf(tls, uintptr(unsafe.Pointer(&_buf5)), uint64(16), ts+1678, VaList(bp+16, int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(0)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(1)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(2)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(3))))))
	return uintptr(unsafe.Pointer(&_buf5))
}

var _buf5 [16]int8

func x_inet_ntop(tls *TLS, af int32, a0 uintptr, s uintptr, l Tsocklen_t) (r uintptr) {
	bp := tls.Alloc(192) /* tlsAllocs 104 maxValist 10 */
	defer tls.Free(192)
	var a uintptr
	var best int32
	var i int32
	var j int32
	var max int32
	var _ /* buf at bp+0 */ [100]int8
	var v1 int32
	var v2 int8
	a = a0
	switch af {
	case int32(m_PF_INET):
		if uint32(x_snprintf(tls, s, uint64(l), ts+1678, VaList(bp+112, int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(0)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(1)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(2)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(3))))))) < l {
			return s
		}
	case int32(m_PF_INET6):
		if x_memcmp(tls, a, ts+1573, uint64(12)) != 0 {
			x_snprintf(tls, bp, uint64(100), ts+1690, VaList(bp+112, int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(0))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(1)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(2))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(3)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(4))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(5)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(6))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(7)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(8))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(9)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(10))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(11)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(12))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(13)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(14))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(15))))))
		} else {
			x_snprintf(tls, bp, uint64(100), ts+1714, VaList(bp+112, int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(0))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(1)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(2))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(3)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(4))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(5)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(6))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(7)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(8))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(9)))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(10))))+int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(11)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(12)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(13)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(14)))), int32(*(*uint8)(unsafe.Pointer(a + UintptrFromInt32(15))))))
		}
		/* Replace longest /(^0|:)[:0]{2,}/ with "::" */
		v1 = Int32FromInt32(0)
		best = v1
		i = v1
		max = Int32FromInt32(2)
		for ; (*(*[100]int8)(unsafe.Pointer(bp)))[i] != 0; i++ {
			if i != 0 && int32((*(*[100]int8)(unsafe.Pointer(bp)))[i]) != int32(':') {
				continue
			}
			j = int32(x_strspn(tls, bp+uintptr(i), ts+1744))
			if j > max {
				best = i
				max = j
			}
		}
		if max > int32(3) {
			v2 = Int8FromUint8(':')
			(*(*[100]int8)(unsafe.Pointer(bp)))[best+int32(1)] = v2
			(*(*[100]int8)(unsafe.Pointer(bp)))[best] = v2
			x_memmove(tls, bp+uintptr(best)+uintptr(2), bp+uintptr(best)+uintptr(max), uint64(i-best-max+int32(1)))
		}
		if x_strlen(tls, bp) < uint64(l) {
			x_strcpy(tls, s, bp)
			return s
		}
	default:
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAFNOSUPPORT)
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOSPC)
	return uintptr(0)
}

func _hexval(tls *TLS, c uint32) (r int32) {
	if c-uint32('0') < uint32(10) {
		return int32(c - uint32('0'))
	}
	c = c | Uint32FromInt32(32)
	if c-uint32('a') < uint32(6) {
		return int32(c - uint32('a') + uint32(10))
	}
	return -int32(1)
}

func x_inet_pton(tls *TLS, af int32, s uintptr, a0 uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var a uintptr
	var brk int32
	var d int32
	var i int32
	var j int32
	var need_v4 int32
	var v int32
	var _ /* ip at bp+0 */ [8]Tuint16_t
	var v1 int32
	var v2 uintptr
	var v3 bool
	var v4 uintptr
	var v5 int32
	var v6 int32
	var v7 bool
	var v8 uintptr
	var v9 uintptr
	a = a0
	brk = -int32(1)
	need_v4 = int32(0)
	if af == int32(m_PF_INET) {
		for i = int32(0); i < int32(4); i++ {
			v1 = Int32FromInt32(0)
			j = v1
			v = v1
			for ; j < int32(3) && BoolInt32(uint32(*(*int8)(unsafe.Pointer(s + uintptr(j))))-uint32('0') < uint32(10)) != 0; j++ {
				v = int32(10)*v + int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) - int32('0')
			}
			if j == int32(0) || j > int32(1) && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(0)))) == int32('0') || v > int32(255) {
				return int32(0)
			}
			*(*uint8)(unsafe.Pointer(a + uintptr(i))) = uint8(v)
			if int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) == int32(0) && i == int32(3) {
				return int32(1)
			}
			if int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) != int32('.') {
				return int32(0)
			}
			s = s + uintptr(j+Int32FromInt32(1))
		}
		return int32(0)
	} else {
		if af != int32(m_PF_INET6) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAFNOSUPPORT)
			return -int32(1)
		}
	}
	if v3 = int32(*(*int8)(unsafe.Pointer(s))) == int32(':'); v3 {
		s++
		v2 = s
	}
	if v3 && int32(*(*int8)(unsafe.Pointer(v2))) != int32(':') {
		return int32(0)
	}
	for i = int32(0); ; i++ {
		if int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(0)))) == int32(':') && brk < int32(0) {
			brk = i
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(0)
			s++
			v4 = s
			if !(*(*int8)(unsafe.Pointer(v4)) != 0) {
				break
			}
			if i == int32(7) {
				return int32(0)
			}
			continue
		}
		v5 = Int32FromInt32(0)
		j = v5
		v = v5
		for ; ; j++ {
			if v7 = j < int32(4); v7 {
				v6 = _hexval(tls, uint32(*(*int8)(unsafe.Pointer(s + uintptr(j)))))
				d = v6
			}
			if !(v7 && v6 >= int32(0)) {
				break
			}
			v = int32(16)*v + d
		}
		if j == int32(0) {
			return int32(0)
		}
		(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(v)
		if !(*(*int8)(unsafe.Pointer(s + uintptr(j))) != 0) && (brk >= int32(0) || i == int32(7)) {
			break
		}
		if i == int32(7) {
			return int32(0)
		}
		if int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) != int32(':') {
			if int32(*(*int8)(unsafe.Pointer(s + uintptr(j)))) != int32('.') || i < int32(6) && brk < int32(0) {
				return int32(0)
			}
			need_v4 = int32(1)
			i++
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(0)
			break
		}
		s = s + uintptr(j+Int32FromInt32(1))
	}
	if brk >= int32(0) {
		x_memmove(tls, bp+uintptr(brk)*2+uintptr(7)*2-uintptr(i)*2, bp+uintptr(brk)*2, uint64(int32(2)*(i+int32(1)-brk)))
		for j = int32(0); j < int32(7)-i; j++ {
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[brk+j] = uint16(0)
		}
	}
	for j = int32(0); j < int32(8); j++ {
		v8 = a
		a++
		*(*uint8)(unsafe.Pointer(v8)) = uint8(int32((*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[j]) >> int32(8))
		v9 = a
		a++
		*(*uint8)(unsafe.Pointer(v9)) = uint8((*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[j])
	}
	if need_v4 != 0 && x_inet_pton(tls, int32(m_PF_INET), s, a-uintptr(4)) <= int32(0) {
		return int32(0)
	}
	return int32(1)
}

const m_SYS_listen = 50
const m___SC_listen = 4

func x_listen(tls *TLS, fd int32, backlog int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_listen), int32(m___SC_listen), int32(0), int64(fd), int64(backlog), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

func x___lookup_ipliteral(tls *TLS, buf uintptr, name uintptr, family int32) (r int32) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxValist 0 */
	defer tls.Free(96)
	var p uintptr
	var scopeid uint64
	var _ /* a4 at bp+0 */ Tin_addr
	var _ /* a6 at bp+4 */ Tin6_addr
	var _ /* tmp at bp+20 */ [64]int8
	var _ /* z at bp+88 */ uintptr
	var v1 uintptr
	if x___inet_aton(tls, name, bp) > int32(0) {
		if family == int32(m_PF_INET6) { /* wrong family */
			return -int32(5)
		}
		x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Faddr)), bp, uint64(4))
		(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Ffamily = int32(m_PF_INET)
		(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Fscopeid = uint32(0)
		return int32(1)
	}
	p = x_strchr(tls, name, int32('%'))
	scopeid = uint64(0)
	if p != 0 && int64(p)-int64(name) < int64(64) {
		x_memcpy(tls, bp+20, name, uint64(int64(p)-int64(name)))
		(*(*[64]int8)(unsafe.Pointer(bp + 20)))[int64(p)-int64(name)] = int8(0)
		name = bp + 20
	}
	if x_inet_pton(tls, int32(m_PF_INET6), name, bp+4) <= int32(0) {
		return int32(0)
	}
	if family == int32(m_PF_INET) { /* wrong family */
		return -int32(5)
	}
	x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Faddr)), bp+4, uint64(16))
	(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Ffamily = int32(m_PF_INET6)
	if p != 0 {
		p++
		v1 = p
		if BoolInt32(uint32(*(*int8)(unsafe.Pointer(v1)))-uint32('0') < uint32(10)) != 0 {
			scopeid = x_strtoull(tls, p, bp+88, int32(10))
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 88)) = p - uintptr(1)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)))) != 0 {
			if !(int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + UintptrFromInt32(0)))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + UintptrFromInt32(1))))&int32(0xc0) == int32(0x80)) && !(int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + UintptrFromInt32(0)))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + UintptrFromInt32(1))))&int32(0xf) == int32(0x2)) {
				return -int32(2)
			}
			scopeid = uint64(x_if_nametoindex(tls, p))
			if !(scopeid != 0) {
				return -int32(2)
			}
		}
		if scopeid > uint64(0xffffffff) {
			return -int32(2)
		}
	}
	(*(*Taddress)(unsafe.Pointer(buf + UintptrFromInt32(0)*28))).Fscopeid = uint32(scopeid)
	return int32(1)
}

const m_ABUF_SIZE = 768
const m_DAS_MATCHINGLABEL = 268435456
const m_DAS_MATCHINGSCOPE = 536870912
const m_DAS_ORDER_SHIFT = 0
const m_DAS_PREC_SHIFT = 20
const m_DAS_PREFIX_SHIFT = 8
const m_DAS_SCOPE_SHIFT = 16
const m_DAS_USABLE = 1073741824
const m_RR_A = 1
const m_RR_AAAA = 28
const m_RR_CNAME = 5

func _is_valid_hostname(tls *TLS, host uintptr) (r int32) {
	var s uintptr
	if x_strnlen(tls, host, uint64(255))-uint64(1) >= uint64(254) || x_mbstowcs(tls, uintptr(0), host, uint64(0)) == uint64(-Int32FromInt32(1)) {
		return int32(0)
	}
	for s = host; int32(*(*uint8)(unsafe.Pointer(s))) >= int32(0x80) || int32(*(*uint8)(unsafe.Pointer(s))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') || x_isalnum(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0; s++ {
	}
	return BoolInt32(!(*(*uint8)(unsafe.Pointer(s)) != 0))
}

func _name_from_null(tls *TLS, buf uintptr, name uintptr, family int32, flags int32) (r int32) {
	var cnt int32
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 int32
	cnt = int32(0)
	if name != 0 {
		return int32(0)
	}
	if flags&int32(m_AI_PASSIVE) != 0 {
		if family != int32(m_PF_INET6) {
			v1 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v1)*28)) = Taddress{Ffamily: int32(m_PF_INET)}
		}
		if family != int32(m_PF_INET) {
			v2 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v2)*28)) = Taddress{Ffamily: int32(m_PF_INET6)}
		}
	} else {
		if family != int32(m_PF_INET6) {
			v3 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v3)*28)) = Taddress{Ffamily: int32(m_PF_INET), Faddr: [16]Tuint8_t{
				0: uint8(127),
				1: uint8(0),
				2: uint8(0),
				3: uint8(1)}}
		}
		if family != int32(m_PF_INET) {
			v4 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v4)*28)) = Taddress{Ffamily: int32(m_PF_INET6), Faddr: [16]Tuint8_t{
				15: uint8(1)}}
		}
	}
	return cnt
}

func _name_from_numeric(tls *TLS, buf uintptr, name uintptr, family int32) (r int32) {
	return x___lookup_ipliteral(tls, buf, name, family)
}

func _name_from_hosts(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) (r int32) {
	bp := tls.Alloc(1776) /* tlsAllocs 1776 maxValist 0 */
	defer tls.Free(1776)
	var badfam int32
	var cnt int32
	var f uintptr
	var have_canon int32
	var l Tsize_t
	var p uintptr
	var z uintptr
	var _ /* _buf at bp+512 */ [1032]uint8
	var _ /* _f at bp+1544 */ TFILE
	var _ /* line at bp+0 */ [512]int8
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	var v5 int32
	l = x_strlen(tls, name)
	cnt = int32(0)
	badfam = int32(0)
	have_canon = int32(0)
	f = x___fopen_rb_ca(tls, ts+1562, bp+1544, bp+512, uint64(1032))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(x___errno_location(tls))) {
		case int32(m_ENOENT):
			fallthrough
		case int32(m_ENOTDIR):
			fallthrough
		case int32(m_EACCES):
			return int32(0)
		default:
			return -int32(11)
		}
	}
	for x_fgets(tls, bp, int32(512), f) != 0 && cnt < int32(m_MAXADDRS) {
		v1 = x_strchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*int8)(unsafe.Pointer(v2)) = int8('\n')
			*(*int8)(unsafe.Pointer(p)) = Int8FromInt32(0)
		}
		for p = bp + uintptr(1); ; p++ {
			v3 = x_strstr(tls, p, name)
			p = v3
			if !(v3 != 0 && (!(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))) != 0) || !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(l))))) != 0))) {
				break
			}
		}
		if !(p != 0) {
			continue
		}
		/* Isolate IP address to parse */
		for p = bp; *(*int8)(unsafe.Pointer(p)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		v4 = p
		p++
		*(*int8)(unsafe.Pointer(v4)) = int8(0)
		switch _name_from_numeric(tls, buf+uintptr(cnt)*28, bp, family) {
		case int32(1):
			cnt++
		case int32(0):
			continue
			fallthrough
		default:
			badfam = -int32(5)
			break
		}
		if have_canon != 0 {
			continue
		}
		/* Extract first name as canonical name */
		for ; *(*int8)(unsafe.Pointer(p)) != 0 && ___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		for z = p; *(*int8)(unsafe.Pointer(z)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(z)))) != 0); z++ {
		}
		*(*int8)(unsafe.Pointer(z)) = int8(0)
		if _is_valid_hostname(tls, p) != 0 {
			have_canon = int32(1)
			x_memcpy(tls, canon, p, uint64(int64(z)-int64(p)+int64(1)))
		}
	}
	x___fclose_ca(tls, f)
	if cnt != 0 {
		v5 = cnt
	} else {
		v5 = badfam
	}
	return v5
}

type Tdpc_ctx = struct {
	Faddrs  uintptr
	Fcanon  uintptr
	Fcnt    int32
	Frrtype int32
}

func _dns_parse_callback1(tls *TLS, c uintptr, rr int32, data uintptr, len1 int32, packet uintptr, plen int32) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var ctx uintptr
	var family int32
	var _ /* tmp at bp+0 */ [256]int8
	var v1 int32
	var v2 uintptr
	ctx = c
	if rr == int32(m_RR_CNAME) {
		if x___dn_expand(tls, packet, packet+uintptr(plen), data, bp, int32(256)) > int32(0) && _is_valid_hostname(tls, bp) != 0 {
			x_strcpy(tls, (*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcanon, bp)
		}
		return int32(0)
	}
	if (*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt >= int32(m_MAXADDRS) {
		return int32(0)
	}
	if rr != (*Tdpc_ctx)(unsafe.Pointer(ctx)).Frrtype {
		return int32(0)
	}
	switch rr {
	case int32(m_RR_A):
		if len1 != int32(4) {
			return -int32(1)
		}
		family = int32(m_PF_INET)
	case int32(m_RR_AAAA):
		if len1 != int32(16) {
			return -int32(1)
		}
		family = int32(m_PF_INET6)
		break
	}
	(*(*Taddress)(unsafe.Pointer((*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs + uintptr((*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt)*28))).Ffamily = family
	(*(*Taddress)(unsafe.Pointer((*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs + uintptr((*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt)*28))).Fscopeid = uint32(0)
	v2 = ctx + 16
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer((*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs + uintptr(v1)*28))).Faddr)), data, uint64(len1))
	return int32(0)
}

func _name_from_dns(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32, conf uintptr) (r int32) {
	bp := tls.Alloc(2168) /* tlsAllocs 2168 maxValist 0 */
	defer tls.Free(2168)
	var i int32
	var nq int32
	var qtypes [2]int32
	var _ /* abuf at bp+560 */ [2][768]uint8
	var _ /* alens at bp+2136 */ [2]int32
	var _ /* ap at bp+2112 */ [2]uintptr
	var _ /* ctx at bp+2144 */ Tdpc_ctx
	var _ /* qbuf at bp+0 */ [2][280]uint8
	var _ /* qlens at bp+2128 */ [2]int32
	var _ /* qp at bp+2096 */ [2]uintptr
	*(*[2]uintptr)(unsafe.Pointer(bp + 2096)) = [2]uintptr{
		0: bp + UintptrFromInt32(0)*280,
		1: bp + UintptrFromInt32(1)*280}
	*(*[2]uintptr)(unsafe.Pointer(bp + 2112)) = [2]uintptr{
		0: bp + 560 + UintptrFromInt32(0)*768,
		1: bp + 560 + UintptrFromInt32(1)*768}
	nq = int32(0)
	*(*Tdpc_ctx)(unsafe.Pointer(bp + 2144)) = Tdpc_ctx{Faddrs: buf, Fcanon: canon}
	for i = int32(0); i < int32(2); i++ {
		if family != _afrr[i].Faf {
			(*(*[2]int32)(unsafe.Pointer(bp + 2128)))[nq] = x___res_mkquery(tls, int32(0), name, int32(1), _afrr[i].Frr, uintptr(0), int32(0), uintptr(0), bp+uintptr(nq)*280, int32(280))
			if (*(*[2]int32)(unsafe.Pointer(bp + 2128)))[nq] == -int32(1) {
				return int32(0)
			}
			qtypes[nq] = _afrr[i].Frr
			*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280 + UintptrFromInt32(3))) = uint8(0) /* don't need AD flag */
			/* Ensure query IDs are distinct. */
			if nq != 0 && int32(*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280 + UintptrFromInt32(0)))) == int32(*(*uint8)(unsafe.Pointer(bp + UintptrFromInt32(0)*280 + UintptrFromInt32(0)))) {
				*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280 + UintptrFromInt32(0)))++
			}
			nq++
		}
	}
	if x___res_msend_rc(tls, nq, bp+2096, bp+2128, bp+2112, bp+2136, int32(768), conf) < int32(0) {
		return -int32(11)
	}
	for i = int32(0); i < nq; i++ {
		if (*(*[2]int32)(unsafe.Pointer(bp + 2136)))[i] < int32(4) || int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*768 + UintptrFromInt32(3))))&int32(15) == int32(2) {
			return -int32(3)
		}
		if int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*768 + UintptrFromInt32(3))))&int32(15) == int32(3) {
			return int32(0)
		}
		if int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*768 + UintptrFromInt32(3))))&int32(15) != int32(0) {
			return -int32(4)
		}
	}
	for i = nq - int32(1); i >= int32(0); i-- {
		(*(*Tdpc_ctx)(unsafe.Pointer(bp + 2144))).Frrtype = qtypes[i]
		if uint64((*(*[2]int32)(unsafe.Pointer(bp + 2136)))[i]) > uint64(768) {
			(*(*[2]int32)(unsafe.Pointer(bp + 2136)))[i] = int32(768)
		}
		x___dns_parse(tls, bp+560+uintptr(i)*768, (*(*[2]int32)(unsafe.Pointer(bp + 2136)))[i], __ccgo_fp(_dns_parse_callback1), bp+2144)
	}
	if (*(*Tdpc_ctx)(unsafe.Pointer(bp + 2144))).Fcnt != 0 {
		return (*(*Tdpc_ctx)(unsafe.Pointer(bp + 2144))).Fcnt
	}
	return -int32(5)
}

var _afrr = [2]struct {
	Faf int32
	Frr int32
}{
	0: {Faf: int32(m_PF_INET6), Frr: int32(m_RR_A)},
	1: {Faf: int32(m_PF_INET), Frr: int32(m_RR_AAAA)}}

func _name_from_dns_search(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) (r int32) {
	bp := tls.Alloc(360) /* tlsAllocs 360 maxValist 0 */
	defer tls.Free(360)
	var cnt int32
	var dots Tsize_t
	var l Tsize_t
	var p uintptr
	var z uintptr
	var _ /* conf at bp+256 */ Tresolvconf
	var _ /* search at bp+0 */ [256]int8
	var v1 Tsize_t
	if x___get_resolv_conf(tls, bp+256, bp, uint64(256)) < int32(0) {
		return -int32(1)
	}
	/* Count dots, suppress search when >=ndots or name ends in
	 * a dot, which is an explicit request for global scope. */
	v1 = Uint64FromInt32(0)
	l = v1
	dots = v1
	for ; *(*int8)(unsafe.Pointer(name + uintptr(l))) != 0; l++ {
		if int32(*(*int8)(unsafe.Pointer(name + uintptr(l)))) == int32('.') {
			dots++
		}
	}
	if dots >= uint64((*(*Tresolvconf)(unsafe.Pointer(bp + 256))).Fndots) || int32(*(*int8)(unsafe.Pointer(name + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		*(*int8)(unsafe.Pointer(bp)) = int8(0)
	}
	/* Strip final dot for canon, fail if multiple trailing dots. */
	if int32(*(*int8)(unsafe.Pointer(name + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		l--
	}
	if !(l != 0) || int32(*(*int8)(unsafe.Pointer(name + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		return -int32(2)
	}
	/* This can never happen; the caller already checked length. */
	if l >= uint64(256) {
		return -int32(2)
	}
	/* Name with search domain appended is setup in canon[]. This both
	 * provides the desired default canonical name (if the requested
	 * name is not a CNAME record) and serves as a buffer for passing
	 * the full requested name to name_from_dns. */
	x_memcpy(tls, canon, name, l)
	*(*int8)(unsafe.Pointer(canon + uintptr(l))) = int8('.')
	for p = bp; *(*int8)(unsafe.Pointer(p)) != 0; p = z {
		for ; ___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		for z = p; *(*int8)(unsafe.Pointer(z)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(z)))) != 0); z++ {
		}
		if z == p {
			break
		}
		if uint64(int64(z)-int64(p)) < uint64(256)-l-uint64(1) {
			x_memcpy(tls, canon+uintptr(l)+uintptr(1), p, uint64(int64(z)-int64(p)))
			*(*int8)(unsafe.Pointer(canon + uintptr(uint64(int64(z)-int64(p)+Int64FromInt32(1))+l))) = int8(0)
			cnt = _name_from_dns(tls, buf, canon, canon, family, bp+256)
			if cnt != 0 {
				return cnt
			}
		}
	}
	*(*int8)(unsafe.Pointer(canon + uintptr(l))) = int8(0)
	return _name_from_dns(tls, buf, canon, name, family, bp+256)
}

type Tpolicy = struct {
	Faddr  [16]uint8
	Flen1  uint8
	Fmask  uint8
	Fprec  uint8
	Flabel uint8
}

var _defpolicy = [6]Tpolicy{
	0: {Faddr: [16]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}, Flen1: uint8(15), Fmask: uint8(0xff), Fprec: uint8(50), Flabel: uint8(0)},
	1: {Faddr: [16]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255}, Flen1: uint8(11), Fmask: uint8(0xff), Fprec: uint8(35), Flabel: uint8(4)},
	2: {Faddr: [16]uint8{' ', 2}, Flen1: uint8(1), Fmask: uint8(0xff), Fprec: uint8(30), Flabel: uint8(2)},
	3: {Faddr: [16]uint8{' ', 1}, Flen1: uint8(3), Fmask: uint8(0xff), Fprec: uint8(5), Flabel: uint8(5)},
	4: {Faddr: [16]uint8{252}, Flen1: uint8(0), Fmask: uint8(0xfe), Fprec: uint8(3), Flabel: uint8(13)},
	5: {Faddr: [16]uint8{}, Flen1: uint8(0), Fmask: uint8(0), Fprec: uint8(40), Flabel: uint8(1)}}

func _policyof(tls *TLS, a uintptr) (r uintptr) {
	var i int32
	for i = int32(0); ; i++ {
		if x_memcmp(tls, uintptr(unsafe.Pointer(&(*Tin6_addr)(unsafe.Pointer(a)).F__in6_union.F__s6_addr)), uintptr(unsafe.Pointer(&_defpolicy[i].Faddr)), uint64(_defpolicy[i].Flen1)) != 0 {
			continue
		}
		if int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tin6_addr)(unsafe.Pointer(a)).F__in6_union.F__s6_addr)) + uintptr(_defpolicy[i].Flen1))))&int32(_defpolicy[i].Fmask) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_defpolicy[i].Faddr)) + uintptr(_defpolicy[i].Flen1)))) {
			continue
		}
		return uintptr(unsafe.Pointer(&_defpolicy)) + uintptr(i)*20
	}
	return r
}

func _labelof(tls *TLS, a uintptr) (r int32) {
	return int32((*Tpolicy)(unsafe.Pointer(_policyof(tls, a))).Flabel)
}

func _scopeof(tls *TLS, a uintptr) (r int32) {
	if int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(0)))) == int32(0xff) {
		return int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tin6_addr)(unsafe.Pointer(a)).F__in6_union.F__s6_addr)) + UintptrFromInt32(1)))) & int32(15)
	}
	if int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(0)))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(1))))&int32(0xc0) == int32(0x80) {
		return int32(2)
	}
	if *(*Tuint32_t)(unsafe.Pointer(a + UintptrFromInt32(0)*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(a + UintptrFromInt32(1)*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(a + UintptrFromInt32(2)*4)) == uint32(0) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(12)))) == int32(0) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(13)))) == int32(0) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(14)))) == int32(0) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(15)))) == int32(1) {
		return int32(2)
	}
	if int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(0)))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + UintptrFromInt32(1))))&int32(0xc0) == int32(0xc0) {
		return int32(5)
	}
	return int32(14)
}

func _prefixmatch(tls *TLS, s uintptr, d uintptr) (r int32) {
	var i uint32
	/* FIXME: The common prefix length should be limited to no greater
	 * than the nominal length of the prefix portion of the source
	 * address. However the definition of the source prefix length is
	 * not clear and thus this limiting is not yet implemented. */
	for i = uint32(0); i < uint32(128) && !((int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tin6_addr)(unsafe.Pointer(s)).F__in6_union.F__s6_addr)) + uintptr(i/Uint32FromInt32(8)))))^int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tin6_addr)(unsafe.Pointer(d)).F__in6_union.F__s6_addr)) + uintptr(i/Uint32FromInt32(8))))))&(Int32FromInt32(128)>>(i%Uint32FromInt32(8))) != 0); i++ {
	}
	return int32(i)
}

func _addrcmp(tls *TLS, _a uintptr, _b uintptr) (r int32) {
	var a uintptr
	var b uintptr
	a = _a
	b = _b
	return (*Taddress)(unsafe.Pointer(b)).Fsortkey - (*Taddress)(unsafe.Pointer(a)).Fsortkey
}

func x___lookup_name(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32, flags int32) (r int32) {
	bp := tls.Alloc(96) /* tlsAllocs 96 maxValist 0 */
	defer tls.Free(96)
	var cnt int32
	var da uintptr
	var dalen Tsocklen_t
	var dlabel int32
	var dpolicy uintptr
	var dprec int32
	var dscope int32
	var family1 int32
	var fd int32
	var i int32
	var j int32
	var key int32
	var l Tsize_t
	var prefixlen int32
	var sa uintptr
	var _ /* cs at bp+0 */ int32
	var _ /* da4 at bp+76 */ Tsockaddr_in
	var _ /* da6 at bp+32 */ Tsockaddr_in6
	var _ /* sa4 at bp+60 */ Tsockaddr_in
	var _ /* sa6 at bp+4 */ Tsockaddr_in6
	var _ /* salen at bp+92 */ Tsocklen_t
	var v1 int32
	var v2 int32
	var v3 int32
	cnt = int32(0)
	*(*int8)(unsafe.Pointer(canon)) = int8(0)
	if name != 0 {
		/* reject empty name and check len so it fits into temp bufs */
		l = x_strnlen(tls, name, uint64(255))
		if l-uint64(1) >= uint64(254) {
			return -int32(2)
		}
		x_memcpy(tls, canon, name, l+uint64(1))
	}
	/* Procedurally, a request for v6 addresses with the v4-mapped
	 * flag set is like a request for unspecified family, followed
	 * by filtering of the results. */
	if flags&int32(m_AI_V4MAPPED) != 0 {
		if family == int32(m_PF_INET6) {
			family = int32(m_PF_UNSPEC)
		} else {
			flags = flags - Int32FromInt32(m_AI_V4MAPPED)
		}
	}
	/* Try each backend until there's at least one result. */
	cnt = _name_from_null(tls, buf, name, family, flags)
	if !(cnt != 0) {
		cnt = _name_from_numeric(tls, buf, name, family)
	}
	if !(cnt != 0) && !(flags&Int32FromInt32(m_AI_NUMERICHOST) != 0) {
		cnt = _name_from_hosts(tls, buf, canon, name, family)
		if !(cnt != 0) {
			cnt = _name_from_dns_search(tls, buf, canon, name, family)
		}
	}
	if cnt <= int32(0) {
		if cnt != 0 {
			v1 = cnt
		} else {
			v1 = -int32(2)
		}
		return v1
	}
	/* Filter/transform results for v4-mapped lookup, if requested. */
	if flags&int32(m_AI_V4MAPPED) != 0 {
		if !(flags&Int32FromInt32(m_AI_ALL) != 0) {
			/* If any v6 results exist, remove v4 results. */
			for i = int32(0); i < cnt && (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(m_PF_INET6); i++ {
			}
			if i < cnt {
				for j = int32(0); i < cnt; i++ {
					if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily == int32(m_PF_INET6) {
						v2 = j
						j++
						*(*Taddress)(unsafe.Pointer(buf + uintptr(v2)*28)) = *(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))
					}
				}
				v3 = j
				i = v3
				cnt = v3
			}
		}
		/* Translate any remaining v4 results to v6 */
		for i = int32(0); i < cnt; i++ {
			if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(m_PF_INET) {
				continue
			}
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr))+uintptr(12), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), uint64(4))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), ts+1573, uint64(12))
			(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily = int32(m_PF_INET6)
		}
	}
	/* No further processing is needed if there are fewer than 2
	 * results or if there are only IPv4 results. */
	if cnt < int32(2) || family == int32(m_PF_INET) {
		return cnt
	}
	for i = int32(0); i < cnt; i++ {
		if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(m_PF_INET) {
			break
		}
	}
	if i == cnt {
		return cnt
	}
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	/* The following implements a subset of RFC 3484/6724 destination
	 * address selection by generating a single 31-bit sort key for
	 * each address. Rules 3, 4, and 7 are omitted for having
	 * excessive runtime and code size cost and dubious benefit.
	 * So far the label/precedence table cannot be customized. */
	for i = int32(0); i < cnt; i++ {
		family1 = (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily
		key = int32(0)
		*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4)) = Tsockaddr_in6{}
		*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32)) = Tsockaddr_in6{Fsin6_family: uint16(m_PF_INET6), Fsin6_port: uint16(65535), Fsin6_scope_id: (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Fscopeid}
		*(*Tsockaddr_in)(unsafe.Pointer(bp + 60)) = Tsockaddr_in{}
		*(*Tsockaddr_in)(unsafe.Pointer(bp + 76)) = Tsockaddr_in{Fsin_family: uint16(m_PF_INET), Fsin_port: uint16(65535)}
		if family1 == int32(m_PF_INET6) {
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr.F__in6_union.F__s6_addr)), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), uint64(16))
			da = bp + 32
			dalen = uint32(28)
			sa = bp + 4
			*(*Tsocklen_t)(unsafe.Pointer(bp + 92)) = uint32(28)
		} else {
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4))).Fsin6_addr.F__in6_union.F__s6_addr)), ts+1573, uint64(12))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr.F__in6_union.F__s6_addr))+uintptr(12), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), uint64(4))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr.F__in6_union.F__s6_addr)), ts+1573, uint64(12))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr.F__in6_union.F__s6_addr))+uintptr(12), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), uint64(4))
			x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in)(unsafe.Pointer(bp + 76))).Fsin_addr)), uintptr(unsafe.Pointer(&(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Faddr)), uint64(4))
			da = bp + 76
			dalen = uint32(16)
			sa = bp + 60
			*(*Tsocklen_t)(unsafe.Pointer(bp + 92)) = uint32(16)
		}
		dpolicy = _policyof(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr)))
		dscope = _scopeof(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr)))
		dlabel = int32((*Tpolicy)(unsafe.Pointer(dpolicy)).Flabel)
		dprec = int32((*Tpolicy)(unsafe.Pointer(dpolicy)).Fprec)
		prefixlen = int32(0)
		fd = x_socket(tls, family1, Int32FromInt32(m_SOCK_DGRAM)|Int32FromInt32(m_SOCK_CLOEXEC), int32(m_IPPROTO_UDP))
		if fd >= int32(0) {
			if !(x_connect(tls, fd, da, dalen) != 0) {
				key = key | Int32FromInt32(m_DAS_USABLE)
				if !(x_getsockname(tls, fd, sa, bp+92) != 0) {
					if family1 == int32(m_PF_INET) {
						x_memcpy(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4))).Fsin6_addr.F__in6_union.F__s6_addr))+uintptr(12), uintptr(unsafe.Pointer(&(*(*Tsockaddr_in)(unsafe.Pointer(bp + 60))).Fsin_addr)), uint64(4))
					}
					if dscope == _scopeof(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4))).Fsin6_addr))) {
						key = key | Int32FromInt32(m_DAS_MATCHINGSCOPE)
					}
					if dlabel == _labelof(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4))).Fsin6_addr))) {
						key = key | Int32FromInt32(m_DAS_MATCHINGLABEL)
					}
					prefixlen = _prefixmatch(tls, uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4))).Fsin6_addr)), uintptr(unsafe.Pointer(&(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32))).Fsin6_addr)))
				}
			}
			x_close(tls, fd)
		}
		key = key | dprec<<Int32FromInt32(m_DAS_PREC_SHIFT)
		key = key | (Int32FromInt32(15)-dscope)<<Int32FromInt32(m_DAS_SCOPE_SHIFT)
		key = key | prefixlen<<Int32FromInt32(m_DAS_PREFIX_SHIFT)
		key = key | (Int32FromInt32(m_MAXADDRS)-i)<<Int32FromInt32(m_DAS_ORDER_SHIFT)
		(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Fsortkey = key
	}
	x_qsort(tls, buf, uint64(cnt), uint64(28), __ccgo_fp(_addrcmp))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return cnt
}

const m_SOCK_STREAM = 1

func x___lookup_serv(tls *TLS, buf uintptr, name uintptr, proto int32, socktype int32, flags int32) (r int32) {
	bp := tls.Alloc(1400) /* tlsAllocs 1400 maxValist 0 */
	defer tls.Free(1400)
	var cnt int32
	var f uintptr
	var l Tsize_t
	var p uintptr
	var port uint64
	var _ /* _buf at bp+136 */ [1032]uint8
	var _ /* _f at bp+1168 */ TFILE
	var _ /* line at bp+0 */ [128]int8
	var _ /* z at bp+128 */ uintptr
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 int32
	var v7 int32
	var v8 int32
	cnt = int32(0)
	*(*uintptr)(unsafe.Pointer(bp + 128)) = ts
	port = uint64(0)
	switch socktype {
	case int32(m_SOCK_STREAM):
		switch proto {
		case int32(0):
			proto = int32(m_IPPROTO_TCP)
			fallthrough
		case int32(m_IPPROTO_TCP):
		default:
			return -int32(8)
		}
	case int32(m_SOCK_DGRAM):
		switch proto {
		case int32(0):
			proto = int32(m_IPPROTO_UDP)
			fallthrough
		case int32(m_IPPROTO_UDP):
		default:
			return -int32(8)
		}
		fallthrough
	case int32(0):
	default:
		if name != 0 {
			return -int32(8)
		}
		(*(*Tservice)(unsafe.Pointer(buf + UintptrFromInt32(0)*4))).Fport = uint16(0)
		(*(*Tservice)(unsafe.Pointer(buf + UintptrFromInt32(0)*4))).Fproto = uint8(proto)
		(*(*Tservice)(unsafe.Pointer(buf + UintptrFromInt32(0)*4))).Fsocktype = uint8(socktype)
		return int32(1)
	}
	if name != 0 {
		if !(*(*int8)(unsafe.Pointer(name)) != 0) {
			return -int32(8)
		}
		port = x_strtoul(tls, name, bp+128, int32(10))
	}
	if !(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))) != 0) {
		if port > uint64(65535) {
			return -int32(8)
		}
		if proto != int32(m_IPPROTO_UDP) {
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(m_SOCK_STREAM)
			v1 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v1)*4))).Fproto = uint8(m_IPPROTO_TCP)
		}
		if proto != int32(m_IPPROTO_TCP) {
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(m_SOCK_DGRAM)
			v2 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v2)*4))).Fproto = uint8(m_IPPROTO_UDP)
		}
		return cnt
	}
	if flags&int32(m_AI_NUMERICSERV) != 0 {
		return -int32(2)
	}
	l = x_strlen(tls, name)
	f = x___fopen_rb_ca(tls, ts+1586, bp+1168, bp+136, uint64(1032))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(x___errno_location(tls))) {
		case int32(m_ENOENT):
			fallthrough
		case int32(m_ENOTDIR):
			fallthrough
		case int32(m_EACCES):
			return -int32(8)
		default:
			return -int32(11)
		}
	}
	for x_fgets(tls, bp, int32(128), f) != 0 && cnt < int32(m_MAXSERVS) {
		v3 = x_strchr(tls, bp, int32('#'))
		p = v3
		if v3 != 0 {
			v4 = p
			p++
			*(*int8)(unsafe.Pointer(v4)) = int8('\n')
			*(*int8)(unsafe.Pointer(p)) = Int8FromInt32(0)
		}
		/* Find service name */
		for p = bp; ; p++ {
			v5 = x_strstr(tls, p, name)
			p = v5
			if !(v5 != 0) {
				break
			}
			if p > bp && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))) != 0) {
				continue
			}
			if *(*int8)(unsafe.Pointer(p + uintptr(l))) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p + uintptr(l))))) != 0) {
				continue
			}
			break
		}
		if !(p != 0) {
			continue
		}
		/* Skip past canonical name at beginning of line */
		for p = bp; *(*int8)(unsafe.Pointer(p)) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		port = x_strtoul(tls, p, bp+128, int32(10))
		if port > uint64(65535) || *(*uintptr)(unsafe.Pointer(bp + 128)) == p {
			continue
		}
		if !(x_strncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+1600, uint64(4)) != 0) {
			if proto == int32(m_IPPROTO_TCP) {
				continue
			}
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(m_SOCK_DGRAM)
			v6 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v6)*4))).Fproto = uint8(m_IPPROTO_UDP)
		}
		if !(x_strncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+1605, uint64(4)) != 0) {
			if proto == int32(m_IPPROTO_UDP) {
				continue
			}
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(m_SOCK_STREAM)
			v7 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v7)*4))).Fproto = uint8(m_IPPROTO_TCP)
		}
	}
	x___fclose_ca(tls, f)
	if cnt > int32(0) {
		v8 = cnt
	} else {
		v8 = -int32(8)
	}
	return v8
}

const m_MSG_DONTWAIT = 64
const m_NETLINK_ROUTE = 0
const m_NLMSG_DONE = 3
const m_NLMSG_ERROR = 2
const m_NLM_F_MATCH = 512
const m_NLM_F_REQUEST = 1
const m_NLM_F_ROOT = 256
const m_RTM_GETADDR = 22
const m_RTM_GETLINK = 18

func ___netlink_enumerate(tls *TLS, fd int32, seq uint32, type1 int32, af int32, cb uintptr, ctx uintptr) (r1 int32) {
	bp := tls.Alloc(8192) /* tlsAllocs 8192 maxValist 0 */
	defer tls.Free(8192)
	var h uintptr
	var r int32
	var ret int32
	var _ /* u at bp+0 */ struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	}
	x_memset(tls, bp, int32(0), uint64(20))
	(*(*struct {
		Fnlh         Tnlmsghdr
		Fg           Trtgenmsg
		F__ccgo_pad2 [3]byte
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_len = uint32(20)
	(*(*struct {
		Fnlh         Tnlmsghdr
		Fg           Trtgenmsg
		F__ccgo_pad2 [3]byte
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_type = uint16(type1)
	(*(*struct {
		Fnlh         Tnlmsghdr
		Fg           Trtgenmsg
		F__ccgo_pad2 [3]byte
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_flags = uint16(Int32FromInt32(m_NLM_F_ROOT) | Int32FromInt32(m_NLM_F_MATCH) | Int32FromInt32(m_NLM_F_REQUEST))
	(*(*struct {
		Fnlh         Tnlmsghdr
		Fg           Trtgenmsg
		F__ccgo_pad2 [3]byte
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_seq = seq
	(*(*struct {
		Fnlh         Tnlmsghdr
		Fg           Trtgenmsg
		F__ccgo_pad2 [3]byte
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh         Tnlmsghdr
			Fg           Trtgenmsg
			F__ccgo_pad2 [3]byte
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fg.Frtgen_family = uint8(af)
	r = int32(x_send(tls, fd, bp, uint64(20), int32(0)))
	if r < int32(0) {
		return r
	}
	for int32(1) != 0 {
		r = int32(x_recv(tls, fd, uintptr(unsafe.Pointer(&(*(*struct {
			Freq [0]struct {
				Fnlh         Tnlmsghdr
				Fg           Trtgenmsg
				F__ccgo_pad2 [3]byte
			}
			Freply [0]Tnlmsghdr
			Fbuf   [8192]Tuint8_t
		})(unsafe.Pointer(bp))).Fbuf)), uint64(8192), int32(m_MSG_DONTWAIT)))
		if r <= int32(0) {
			return -int32(1)
		}
		for h = bp; uint64(int64(uintptr(unsafe.Pointer(&(*(*struct {
			Freq [0]struct {
				Fnlh         Tnlmsghdr
				Fg           Trtgenmsg
				F__ccgo_pad2 [3]byte
			}
			Freply [0]Tnlmsghdr
			Fbuf   [8192]Tuint8_t
		})(unsafe.Pointer(bp))).Fbuf))+uintptr(r))-int64(h)) >= uint64(16); h = h + uintptr(((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len+Uint32FromInt32(3))&uint32(^Int32FromInt32(3))) {
			if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(m_NLMSG_DONE) {
				return int32(0)
			}
			if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(m_NLMSG_ERROR) {
				return -int32(1)
			}
			ret = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cb})))(tls, ctx, h)
			if ret != 0 {
				return ret
			}
		}
	}
	return r1
}

func x___rtnetlink_enumerate(tls *TLS, link_af int32, addr_af int32, cb uintptr, ctx uintptr) (r1 int32) {
	var fd int32
	var r int32
	fd = x_socket(tls, int32(m_PF_NETLINK), Int32FromInt32(m_SOCK_RAW)|Int32FromInt32(m_SOCK_CLOEXEC), int32(m_NETLINK_ROUTE))
	if fd < int32(0) {
		return -int32(1)
	}
	r = ___netlink_enumerate(tls, fd, uint32(1), int32(m_RTM_GETLINK), link_af, cb, ctx)
	if !(r != 0) {
		r = ___netlink_enumerate(tls, fd, uint32(2), int32(m_RTM_GETADDR), addr_af, cb, ctx)
	}
	___syscall1(tls, int64(3), int64(fd))
	return r
}

func x_getnetbyaddr(tls *TLS, net Tuint32_t, type1 int32) (r uintptr) {
	return uintptr(0)
}

func x_getnetbyname(tls *TLS, name uintptr) (r uintptr) {
	return uintptr(0)
}

const m_EMSGSIZE = 90
const m_NS_INT16SZ = 2
const m_NS_INT32SZ = 4

func x_ns_get16(tls *TLS, cp uintptr) (r uint32) {
	return uint32(int32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(0))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(1)))))
}

func x_ns_get32(tls *TLS, cp uintptr) (r uint64) {
	return uint64(uint32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(2))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(cp + UintptrFromInt32(3)))))
}

func x_ns_put16(tls *TLS, s uint32, cp uintptr) {
	var v1 uintptr
	var v2 uintptr
	v1 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v1)) = uint8(s >> int32(8))
	v2 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v2)) = uint8(s)
}

func x_ns_put32(tls *TLS, l uint64, cp uintptr) {
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v4 uintptr
	v1 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v1)) = uint8(l >> int32(24))
	v2 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v2)) = uint8(l >> int32(16))
	v3 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v3)) = uint8(l >> int32(8))
	v4 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v4)) = uint8(l)
}

func x_ns_initparse(tls *TLS, msg uintptr, msglen int32, handle uintptr) (r1 int32) {
	var i int32
	var r int32
	(*Tns_msg)(unsafe.Pointer(handle)).F_msg = msg
	(*Tns_msg)(unsafe.Pointer(handle)).F_eom = msg + uintptr(msglen)
	if msglen < (Int32FromInt32(2)+int32(_ns_s_max))*Int32FromInt32(m_NS_INT16SZ) {
		goto bad
	}
	msg = msg + UintptrFromInt32(2)
	(*Tns_msg)(unsafe.Pointer(handle)).F_id = uint16(x_ns_get16(tls, msg-uintptr(2)))
	msg = msg + UintptrFromInt32(2)
	(*Tns_msg)(unsafe.Pointer(handle)).F_flags = uint16(x_ns_get16(tls, msg-uintptr(2)))
	for i = int32(0); i < int32(_ns_s_max); i++ {
		msg = msg + UintptrFromInt32(2)
		*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2)) = uint16(x_ns_get16(tls, msg-uintptr(2)))
	}
	for i = int32(0); i < int32(_ns_s_max); i++ {
		if *(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2)) != 0 {
			*(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(i)*8)) = msg
			r = x_ns_skiprr(tls, msg, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, i, int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2))))
			if r < int32(0) {
				return -int32(1)
			}
			msg = msg + uintptr(r)
		} else {
			*(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(i)*8)) = UintptrFromInt32(0)
		}
	}
	if msg != (*Tns_msg)(unsafe.Pointer(handle)).F_eom {
		goto bad
	}
	(*Tns_msg)(unsafe.Pointer(handle)).F_sect = int32(_ns_s_max)
	(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = -int32(1)
	(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = UintptrFromInt32(0)
	return int32(0)
bad:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EMSGSIZE)
	return -int32(1)
}

func x_ns_skiprr(tls *TLS, ptr uintptr, eom uintptr, section Tns_sect, count int32) (r1 int32) {
	var p uintptr
	var r int32
	var v1 int32
	p = ptr
	for {
		v1 = count
		count--
		if !(v1 != 0) {
			break
		}
		r = x_dn_skipname(tls, p, eom)
		if r < int32(0) {
			goto bad
		}
		if int64(r+Int32FromInt32(2)*Int32FromInt32(m_NS_INT16SZ)) > int64(eom)-int64(p) {
			goto bad
		}
		p = p + uintptr(r+Int32FromInt32(2)*Int32FromInt32(m_NS_INT16SZ))
		if section != int32(_ns_s_qd) {
			if int64(Int32FromInt32(m_NS_INT32SZ)+Int32FromInt32(m_NS_INT16SZ)) > int64(eom)-int64(p) {
				goto bad
			}
			p = p + UintptrFromInt32(m_NS_INT32SZ)
			p = p + UintptrFromInt32(2)
			r = int32(x_ns_get16(tls, p-uintptr(2)))
			if int64(r) > int64(eom)-int64(p) {
				goto bad
			}
			p = p + uintptr(r)
		}
	}
	return int32(int64(p) - int64(ptr))
bad:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EMSGSIZE)
	return -int32(1)
}

func x_ns_parserr(tls *TLS, handle uintptr, section Tns_sect, rrnum int32, rr uintptr) (r1 int32) {
	var r int32
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	if section < int32(0) || section >= int32(_ns_s_max) {
		goto bad
	}
	if section != (*Tns_msg)(unsafe.Pointer(handle)).F_sect {
		(*Tns_msg)(unsafe.Pointer(handle)).F_sect = section
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = int32(0)
		(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = *(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(section)*8))
	}
	if rrnum == -int32(1) {
		rrnum = (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum
	}
	if rrnum < int32(0) || rrnum >= int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(section)*2))) {
		goto bad
	}
	if rrnum < (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum {
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = int32(0)
		(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = *(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(section)*8))
	}
	if rrnum > (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum {
		r = x_ns_skiprr(tls, (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, section, rrnum-(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum)
		if r < int32(0) {
			return -int32(1)
		}
		p1 = handle + 72
		*(*uintptr)(unsafe.Pointer(p1)) = *(*uintptr)(unsafe.Pointer(p1)) + uintptr(r)
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = rrnum
	}
	r = x_ns_name_uncompress(tls, (*Tns_msg)(unsafe.Pointer(handle)).F_msg, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr, rr, uint64(m_NS_MAXDNAME))
	if r < int32(0) {
		return -int32(1)
	}
	p2 = handle + 72
	*(*uintptr)(unsafe.Pointer(p2)) = *(*uintptr)(unsafe.Pointer(p2)) + uintptr(r)
	if int64(Int32FromInt32(2)*Int32FromInt32(m_NS_INT16SZ)) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
		goto size
	}
	p3 = handle + 72
	*(*uintptr)(unsafe.Pointer(p3)) = *(*uintptr)(unsafe.Pointer(p3)) + UintptrFromInt32(2)
	(*Tns_rr)(unsafe.Pointer(rr)).Ftype1 = uint16(x_ns_get16(tls, *(*uintptr)(unsafe.Pointer(p3))-uintptr(2)))
	p4 = handle + 72
	*(*uintptr)(unsafe.Pointer(p4)) = *(*uintptr)(unsafe.Pointer(p4)) + UintptrFromInt32(2)
	(*Tns_rr)(unsafe.Pointer(rr)).Frr_class = uint16(x_ns_get16(tls, *(*uintptr)(unsafe.Pointer(p4))-uintptr(2)))
	if section != int32(_ns_s_qd) {
		if int64(Int32FromInt32(m_NS_INT32SZ)+Int32FromInt32(m_NS_INT16SZ)) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
			goto size
		}
		p5 = handle + 72
		*(*uintptr)(unsafe.Pointer(p5)) = *(*uintptr)(unsafe.Pointer(p5)) + UintptrFromInt32(4)
		(*Tns_rr)(unsafe.Pointer(rr)).Fttl = uint32(x_ns_get32(tls, *(*uintptr)(unsafe.Pointer(p5))-uintptr(4)))
		p6 = handle + 72
		*(*uintptr)(unsafe.Pointer(p6)) = *(*uintptr)(unsafe.Pointer(p6)) + UintptrFromInt32(2)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdlength = uint16(x_ns_get16(tls, *(*uintptr)(unsafe.Pointer(p6))-uintptr(2)))
		if int64((*Tns_rr)(unsafe.Pointer(rr)).Frdlength) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
			goto size
		}
		(*Tns_rr)(unsafe.Pointer(rr)).Frdata = (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr
		p7 = handle + 72
		*(*uintptr)(unsafe.Pointer(p7)) = *(*uintptr)(unsafe.Pointer(p7)) + uintptr((*Tns_rr)(unsafe.Pointer(rr)).Frdlength)
	} else {
		(*Tns_rr)(unsafe.Pointer(rr)).Fttl = uint32(0)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdlength = uint16(0)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdata = UintptrFromInt32(0)
	}
	(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum++
	if (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum > int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(section)*2))) {
		(*Tns_msg)(unsafe.Pointer(handle)).F_sect = section + int32(1)
		if (*Tns_msg)(unsafe.Pointer(handle)).F_sect == int32(_ns_s_max) {
			(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = -int32(1)
			(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = UintptrFromInt32(0)
		} else {
			(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = int32(0)
		}
	}
	return int32(0)
bad:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENODEV)
	return -int32(1)
size:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EMSGSIZE)
	return -int32(1)
}

func x_ns_name_uncompress(tls *TLS, msg uintptr, eom uintptr, src uintptr, dst uintptr, dstsiz Tsize_t) (r1 int32) {
	var r int32
	r = x___dn_expand(tls, msg, eom, src, dst, int32(dstsiz))
	if r < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EMSGSIZE)
	}
	return r
}

func x_ntohl(tls *TLS, n Tuint32_t) (r Tuint32_t) {
	var u struct {
		Fc [0]int8
		Fi int32
	}
	var v1 uint32
	u = struct {
		Fc [0]int8
		Fi int32
	}{Fi: int32(1)}
	if *(*int8)(unsafe.Pointer(&u)) != 0 {
		v1 = ___bswap_32(tls, n)
	} else {
		v1 = n
	}
	return v1
}

func x_ntohs(tls *TLS, n Tuint16_t) (r Tuint16_t) {
	var u struct {
		Fc [0]int8
		Fi int32
	}
	var v1 int32
	u = struct {
		Fc [0]int8
		Fi int32
	}{Fi: int32(1)}
	if *(*int8)(unsafe.Pointer(&u)) != 0 {
		v1 = int32(___bswap_16(tls, n))
	} else {
		v1 = int32(n)
	}
	return uint16(v1)
}

/* do we really need all these?? */

var _idx int32
var _protos = [1]uint8{
	0: uint8(ts + 1747)}

func x_endprotoent(tls *TLS) {
	_idx = int32(0)
}

func x_setprotoent(tls *TLS, stayopen int32) {
	_idx = int32(0)
}

func x_getprotoent(tls *TLS) (r uintptr) {
	if uint64(_idx) >= uint64(1) {
		return UintptrFromInt32(0)
	}
	_p.Fp_proto = int32(_protos[_idx])
	_p.Fp_name = uintptr(unsafe.Pointer(&_protos)) + uintptr(_idx+Int32FromInt32(1))
	_p.Fp_aliases = uintptr(unsafe.Pointer(&_aliases))
	_idx = int32(uint64(_idx) + (x_strlen(tls, _p.Fp_name) + Uint64FromInt32(2)))
	return uintptr(unsafe.Pointer(&_p))
}

var _p Tprotoent

var _aliases uintptr

func x_getprotobyname(tls *TLS, name uintptr) (r uintptr) {
	var p uintptr
	x_endprotoent(tls)
	for cond := true; cond; cond = p != 0 && x_strcmp(tls, name, (*Tprotoent)(unsafe.Pointer(p)).Fp_name) != 0 {
		p = x_getprotoent(tls)
	}
	return p
}

func x_getprotobynumber(tls *TLS, num int32) (r uintptr) {
	var p uintptr
	x_endprotoent(tls)
	for cond := true; cond; cond = p != 0 && (*Tprotoent)(unsafe.Pointer(p)).Fp_proto != num {
		p = x_getprotoent(tls)
	}
	return p
}

func x_recv(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32) (r Tssize_t) {
	return x_recvfrom(tls, fd, buf, len1, flags, uintptr(0), uintptr(0))
}

const m_SYS_recvfrom = 45
const m___SC_recvfrom = 12

func x_recvfrom(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32, addr uintptr, alen uintptr) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_recvfrom), int32(m___SC_recvfrom), int32(1), int64(fd), int64(buf), int64(len1), int64(flags), int64(addr), int64(alen))))
}

func x_recvmmsg(tls *TLS, fd int32, msgvec uintptr, vlen uint32, flags uint32, timeout uintptr) (r int32) {
	var i uint32
	var mh uintptr
	var v2 int32
	mh = msgvec
	for i = vlen; i != 0; {
		v2 = Int32FromInt32(0)
		(*Tmmsghdr)(unsafe.Pointer(mh)).Fmsg_hdr.F__pad2 = v2
		(*Tmmsghdr)(unsafe.Pointer(mh)).Fmsg_hdr.F__pad1 = v2
		goto _1
	_1:
		i--
		mh += 64
	}
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(299), int64(fd), int64(msgvec), int64(vlen), int64(flags), int64(timeout), int64(0)))))
}

const m_MSG_CTRUNC = 8
const m_SOL_SOCKET = 1
const m_SO_TIMESTAMP = 29
const m_SO_TIMESTAMPNS = 35
const m_SO_TIMESTAMPNS_OLD = 35
const m_SO_TIMESTAMP_OLD = 29
const m_SYS_recvmsg = 47
const m___SC_recvmsg = 17

func x___convert_scm_timestamps(tls *TLS, msg uintptr, csize Tsocklen_t) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var cmsg uintptr
	var last uintptr
	var type1 int32
	var _ /* tmp at bp+0 */ int64
	var _ /* tvts at bp+8 */ [2]int64
	var v1 uintptr
	var v2 uintptr
	var v9 uintptr
	var p7 uintptr
	var p8 uintptr
	if int32(m_SO_TIMESTAMP) == int32(m_SO_TIMESTAMP_OLD) {
		return
	}
	if !((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control != 0) || !((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen != 0) {
		return
	}
	last = uintptr(0)
	type1 = int32(0)
	if uint64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen) >= uint64(16) {
		v1 = (*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control
	} else {
		v1 = UintptrFromInt32(0)
	}
	cmsg = v1
	for cmsg != 0 {
		if (*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_level == int32(m_SOL_SOCKET) {
			switch (*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_type {
			case int32(m_SO_TIMESTAMP_OLD):
				goto _4
			case int32(m_SO_TIMESTAMPNS_OLD):
				goto _5
			}
			goto _6
		_4:
			if type1 != 0 {
				goto _6
			}
			type1 = int32(m_SO_TIMESTAMP)
			goto common
		_5:
			type1 = int32(m_SO_TIMESTAMPNS)
		common:
			x_memcpy(tls, bp, cmsg+UintptrFromInt32(1)*16, uint64(8))
			(*(*[2]int64)(unsafe.Pointer(bp + 8)))[int32(0)] = *(*int64)(unsafe.Pointer(bp))
			x_memcpy(tls, bp, cmsg+UintptrFromInt32(1)*16+uintptr(8), uint64(8))
			(*(*[2]int64)(unsafe.Pointer(bp + 8)))[int32(1)] = *(*int64)(unsafe.Pointer(bp))
			goto _6
		_6:
		}
		last = cmsg
		goto _3
	_3:
		if uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen))-int64(cmsg)) {
			v2 = uintptr(0)
		} else {
			v2 = cmsg + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
		}
		cmsg = v2
	}
	if !(last != 0) || !(type1 != 0) {
		return
	}
	if (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) > uint64(csize-(*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen) {
		p7 = msg + 48
		*(*int32)(unsafe.Pointer(p7)) = *(*int32)(unsafe.Pointer(p7)) | Int32FromInt32(m_MSG_CTRUNC)
		return
	}
	p8 = msg + 40
	*(*Tsocklen_t)(unsafe.Pointer(p8)) = Tsocklen_t(uint64(*(*Tsocklen_t)(unsafe.Pointer(p8))) + ((Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1))))
	if uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen))-int64(last)) {
		v9 = uintptr(0)
	} else {
		v9 = last + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
	}
	cmsg = v9
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_level = int32(m_SOL_SOCKET)
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_type = type1
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len = uint32((Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + Uint64FromInt64(16))
	x_memcpy(tls, cmsg+UintptrFromInt32(1)*16, bp+8, uint64(16))
}

func x_recvmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r1 Tssize_t) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxValist 0 */
	defer tls.Free(56)
	var orig uintptr
	var orig_controllen Tsocklen_t
	var r Tssize_t
	var _ /* h at bp+0 */ Tmsghdr
	var v1 int32
	orig_controllen = (*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen
	orig = msg
	if msg != 0 {
		*(*Tmsghdr)(unsafe.Pointer(bp)) = *(*Tmsghdr)(unsafe.Pointer(msg))
		v1 = Int32FromInt32(0)
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad2 = v1
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad1 = v1
		msg = bp
	}
	r = x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_recvmsg), int32(m___SC_recvmsg), int32(1), int64(fd), int64(msg), int64(flags), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)))))
	if r >= int64(0) {
		x___convert_scm_timestamps(tls, msg, orig_controllen)
	}
	if orig != 0 {
		*(*Tmsghdr)(unsafe.Pointer(orig)) = *(*Tmsghdr)(unsafe.Pointer(bp))
	}
	return r
}

func x_res_init(tls *TLS) (r int32) {
	return int32(0)
}

func x___res_mkquery(tls *TLS, op int32, dname uintptr, class int32, type1 int32, data uintptr, datalen int32, newrr uintptr, buf uintptr, buflen int32) (r int32) {
	bp := tls.Alloc(296) /* tlsAllocs 296 maxValist 0 */
	defer tls.Free(296)
	var i int32
	var id int32
	var j int32
	var l Tsize_t
	var n int32
	var _ /* q at bp+0 */ [280]uint8
	var _ /* ts at bp+280 */ Ttimespec
	l = x_strnlen(tls, dname, uint64(255))
	if l != 0 && int32(*(*int8)(unsafe.Pointer(dname + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		l--
	}
	if l != 0 && int32(*(*int8)(unsafe.Pointer(dname + uintptr(l-Uint64FromInt32(1))))) == int32('.') {
		return -int32(1)
	}
	n = int32(uint64(17) + l + BoolUint64(!!(l != 0)))
	if l > uint64(253) || buflen < n || uint32(op) > uint32(15) || uint32(class) > uint32(255) || uint32(type1) > uint32(255) {
		return -int32(1)
	}
	/* Construct query template - ID will be filled later */
	x_memset(tls, bp, int32(0), uint64(n))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(2)] = uint8(op*int32(8) + int32(1))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(3)] = uint8(32) /* AD */
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(5)] = uint8(1)
	x_memcpy(tls, bp+uintptr(13), dname, l)
	for i = int32(13); (*(*[280]uint8)(unsafe.Pointer(bp)))[i] != 0; i = j + int32(1) {
		for j = i; (*(*[280]uint8)(unsafe.Pointer(bp)))[j] != 0 && int32((*(*[280]uint8)(unsafe.Pointer(bp)))[j]) != int32('.'); j++ {
		}
		if uint32(j-i)-uint32(1) > uint32(62) {
			return -int32(1)
		}
		(*(*[280]uint8)(unsafe.Pointer(bp)))[i-int32(1)] = uint8(j - i)
	}
	(*(*[280]uint8)(unsafe.Pointer(bp)))[i+int32(1)] = uint8(type1)
	(*(*[280]uint8)(unsafe.Pointer(bp)))[i+int32(3)] = uint8(class)
	/* Make a reasonably unpredictable id */
	x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp+280)
	id = int32((uint64((*(*Ttimespec)(unsafe.Pointer(bp + 280))).Ftv_nsec) + uint64((*(*Ttimespec)(unsafe.Pointer(bp + 280))).Ftv_nsec)/uint64(65536)) & uint64(0xffff))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(0)] = uint8(id / int32(256))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(id)
	x_memcpy(tls, buf, bp, uint64(n))
	return n
}

const _TCP_NLA_PAD = 0
const _TCP_NLA_BUSY = 1
const _TCP_NLA_RWND_LIMITED = 2
const _TCP_NLA_SNDBUF_LIMITED = 3
const _TCP_NLA_DATA_SEGS_OUT = 4
const _TCP_NLA_TOTAL_RETRANS = 5
const _TCP_NLA_PACING_RATE = 6
const _TCP_NLA_DELIVERY_RATE = 7
const _TCP_NLA_SND_CWND = 8
const _TCP_NLA_REORDERING = 9
const _TCP_NLA_MIN_RTT = 10
const _TCP_NLA_RECUR_RETRANS = 11
const _TCP_NLA_DELIVERY_RATE_APP_LMT = 12
const _TCP_NLA_SNDQ_SIZE = 13
const _TCP_NLA_CA_STATE = 14
const _TCP_NLA_SND_SSTHRESH = 15
const _TCP_NLA_DELIVERED = 16
const _TCP_NLA_DELIVERED_CE = 17
const _TCP_NLA_BYTES_SENT = 18
const _TCP_NLA_BYTES_RETRANS = 19
const _TCP_NLA_DSACK_DUPS = 20
const _TCP_NLA_REORD_SEEN = 21
const _TCP_NLA_SRTT = 22
const _TCP_NLA_TIMEOUT_REHASH = 23
const _TCP_NLA_BYTES_NOTSENT = 24
const _TCP_NLA_EDT = 25
const _TCP_NLA_TTL = 26

func x___res_msend_rc(tls *TLS, nqueries int32, queries uintptr, qlens uintptr, answers uintptr, alens uintptr, asize int32, conf uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1986, int32(23), uintptr(unsafe.Pointer(&___func__25)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__25 = [15]int8{'_', '_', 'r', 'e', 's', '_', 'm', 's', 'e', 'n', 'd', '_', 'r', 'c'}

func x___res_msend(tls *TLS, nqueries int32, queries uintptr, qlens uintptr, answers uintptr, alens uintptr, asize int32) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+1986, int32(29), uintptr(unsafe.Pointer(&___func__26)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__26 = [12]int8{'_', '_', 'r', 'e', 's', '_', 'm', 's', 'e', 'n', 'd'}

func x_res_query(tls *TLS, name uintptr, class int32, type1 int32, dest uintptr, len1 int32) (r1 int32) {
	bp := tls.Alloc(280) /* tlsAllocs 280 maxValist 0 */
	defer tls.Free(280)
	var ql int32
	var r int32
	var _ /* q at bp+0 */ [280]uint8
	ql = x___res_mkquery(tls, int32(0), name, class, type1, uintptr(0), int32(0), uintptr(0), bp, int32(280))
	if ql < int32(0) {
		return ql
	}
	r = x___res_send(tls, bp, ql, dest, len1)
	if r < int32(12) {
		*(*int32)(unsafe.Pointer(x___h_errno_location(tls))) = int32(m_TRY_AGAIN)
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(dest + UintptrFromInt32(3))))&int32(15) == int32(3) {
		*(*int32)(unsafe.Pointer(x___h_errno_location(tls))) = int32(m_HOST_NOT_FOUND)
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(dest + UintptrFromInt32(3))))&int32(15) == int32(0) && !(*(*uint8)(unsafe.Pointer(dest + UintptrFromInt32(6))) != 0) && !(*(*uint8)(unsafe.Pointer(dest + UintptrFromInt32(7))) != 0) {
		*(*int32)(unsafe.Pointer(x___h_errno_location(tls))) = int32(m_NO_DATA)
		return -int32(1)
	}
	return r
}

func x_res_querydomain(tls *TLS, name uintptr, domain uintptr, class int32, type1 int32, dest uintptr, len1 int32) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var dl Tsize_t
	var nl Tsize_t
	var _ /* tmp at bp+0 */ [255]int8
	nl = x_strnlen(tls, name, uint64(255))
	dl = x_strnlen(tls, domain, uint64(255))
	if nl+dl+uint64(1) > uint64(254) {
		return -int32(1)
	}
	x_memcpy(tls, bp, name, nl)
	(*(*[255]int8)(unsafe.Pointer(bp)))[nl] = int8('.')
	x_memcpy(tls, bp+uintptr(nl)+uintptr(1), domain, dl+uint64(1))
	return x_res_query(tls, bp, class, type1, dest, len1)
}

func x___res_send(tls *TLS, _msg uintptr, _msglen int32, _answer uintptr, _anslen int32) (r1 int32) {
	bp := tls.Alloc(544) /* tlsAllocs 544 maxValist 0 */
	defer tls.Free(544)
	*(*uintptr)(unsafe.Pointer(bp)) = _msg
	*(*int32)(unsafe.Pointer(bp + 8)) = _msglen
	*(*uintptr)(unsafe.Pointer(bp + 16)) = _answer
	*(*int32)(unsafe.Pointer(bp + 24)) = _anslen
	var r int32
	var _ /* buf at bp+28 */ [512]uint8
	var v1 int32
	var v2 int32
	if *(*int32)(unsafe.Pointer(bp + 24)) < int32(512) {
		r = x___res_send(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 8)), bp+28, int32(512))
		if r >= int32(0) {
			if r < *(*int32)(unsafe.Pointer(bp + 24)) {
				v1 = r
			} else {
				v1 = *(*int32)(unsafe.Pointer(bp + 24))
			}
			x_memcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), bp+28, uint64(v1))
		}
		return r
	}
	r = x___res_msend(tls, int32(1), bp, bp+8, bp+16, bp+24, *(*int32)(unsafe.Pointer(bp + 24)))
	if r < int32(0) || !(*(*int32)(unsafe.Pointer(bp + 24)) != 0) {
		v2 = -int32(1)
	} else {
		v2 = *(*int32)(unsafe.Pointer(bp + 24))
	}
	return v2
}

func x___res_state(tls *TLS) (r uintptr) {
	return uintptr(unsafe.Pointer(&_res))
}

var _res T__res_state

const m_F_EOF = 16

func x___get_resolv_conf(tls *TLS, conf uintptr, search uintptr, search_sz Tsize_t) (r int32) {
	bp := tls.Alloc(752) /* tlsAllocs 752 maxValist 0 */
	defer tls.Free(752)
	var c int32
	var f uintptr
	var l Tsize_t
	var nns int32
	var p uintptr
	var x uint64
	var x1 uint64
	var x2 uint64
	var _ /* _buf at bp+256 */ [256]uint8
	var _ /* _f at bp+512 */ TFILE
	var _ /* line at bp+0 */ [256]int8
	var _ /* z at bp+744 */ uintptr
	var v1 uint64
	var v2 uint64
	var v3 uint64
	nns = int32(0)
	(*Tresolvconf)(unsafe.Pointer(conf)).Fndots = uint32(1)
	(*Tresolvconf)(unsafe.Pointer(conf)).Ftimeout = uint32(5)
	(*Tresolvconf)(unsafe.Pointer(conf)).Fattempts = uint32(2)
	if search != 0 {
		*(*int8)(unsafe.Pointer(search)) = int8(0)
	}
	f = x___fopen_rb_ca(tls, ts+2010, bp+512, bp+256, uint64(256))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(x___errno_location(tls))) {
		case int32(m_ENOENT):
			fallthrough
		case int32(m_ENOTDIR):
			fallthrough
		case int32(m_EACCES):
			goto no_resolv_conf
		default:
			return -int32(1)
		}
	}
	for x_fgets(tls, bp, int32(256), f) != 0 {
		if !(x_strchr(tls, bp, int32('\n')) != 0) && !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0) {
			/* Ignore lines that get truncated rather than
			 * potentially misinterpreting them. */
			for cond := true; cond; cond = c != int32('\n') && c != -int32(1) {
				c = x_getc(tls, f)
			}
			continue
		}
		if !(x_strncmp(tls, bp, ts+2027, uint64(7)) != 0) && ___isspace(tls, int32((*(*[256]int8)(unsafe.Pointer(bp)))[int32(7)])) != 0 {
			p = x_strstr(tls, bp, ts+2035)
			if p != 0 && BoolInt32(uint32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(6))))-uint32('0') < uint32(10)) != 0 {
				p = p + UintptrFromInt32(6)
				x = x_strtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x > uint64(15) {
						v1 = uint64(15)
					} else {
						v1 = x
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Fndots = uint32(v1)
				}
			}
			p = x_strstr(tls, bp, ts+2042)
			if p != 0 && BoolInt32(uint32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(9))))-uint32('0') < uint32(10)) != 0 {
				p = p + UintptrFromInt32(9)
				x1 = x_strtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x1 > uint64(10) {
						v2 = uint64(10)
					} else {
						v2 = x1
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Fattempts = uint32(v2)
				}
			}
			p = x_strstr(tls, bp, ts+2052)
			if p != 0 && (BoolInt32(uint32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(8))))-uint32('0') < uint32(10)) != 0 || int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(8)))) == int32('.')) {
				p = p + UintptrFromInt32(8)
				x2 = x_strtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x2 > uint64(60) {
						v3 = uint64(60)
					} else {
						v3 = x2
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Ftimeout = uint32(v3)
				}
			}
			continue
		}
		if !(x_strncmp(tls, bp, ts+2061, uint64(10)) != 0) && ___isspace(tls, int32((*(*[256]int8)(unsafe.Pointer(bp)))[int32(10)])) != 0 {
			if nns >= int32(m_MAXNS) {
				continue
			}
			for p = bp + uintptr(11); ___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
			}
			for *(*uintptr)(unsafe.Pointer(bp + 744)) = p; *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))) != 0 && !(___isspace(tls, int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))))) != 0); *(*uintptr)(unsafe.Pointer(bp + 744))++ {
			}
			*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))) = int8(0)
			if x___lookup_ipliteral(tls, conf+uintptr(nns)*28, p, int32(m_PF_UNSPEC)) > int32(0) {
				nns++
			}
			continue
		}
		if !(search != 0) {
			continue
		}
		if x_strncmp(tls, bp, ts+2072, uint64(6)) != 0 && x_strncmp(tls, bp, ts+2079, uint64(6)) != 0 || !(___isspace(tls, int32((*(*[256]int8)(unsafe.Pointer(bp)))[int32(6)])) != 0) {
			continue
		}
		for p = bp + uintptr(7); ___isspace(tls, int32(*(*int8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		l = x_strlen(tls, p)
		/* This can never happen anyway with chosen buffer sizes. */
		if l >= search_sz {
			continue
		}
		x_memcpy(tls, search, p, l+uint64(1))
	}
	x___fclose_ca(tls, f)
no_resolv_conf:
	if !(nns != 0) {
		x___lookup_ipliteral(tls, conf, ts+2086, int32(m_PF_UNSPEC))
		nns = int32(1)
	}
	(*Tresolvconf)(unsafe.Pointer(conf)).Fnns = uint32(nns)
	return int32(0)
}

func x_send(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32) (r Tssize_t) {
	return x_sendto(tls, fd, buf, len1, flags, uintptr(0), uint32(0))
}

func x_sendmmsg(tls *TLS, fd int32, msgvec uintptr, vlen uint32, flags uint32) (r1 int32) {
	var i int32
	var r Tssize_t
	var v1 int32
	/* Can't use the syscall directly because the kernel has the wrong
	 * idea for the types of msg_iovlen, msg_controllen, and cmsg_len,
	 * and the cmsg blocks cannot be modified in-place. */
	if vlen > uint32(m_IOV_MAX) {
		vlen = uint32(m_IOV_MAX)
	} /* This matches the kernel. */
	if !(vlen != 0) {
		return int32(0)
	}
	for i = int32(0); uint32(i) < vlen; i++ {
		/* As an unfortunate inconsistency, the sendmmsg API uses
		 * unsigned int for the resulting msg_len, despite sendmsg
		 * returning ssize_t. However Linux limits the total bytes
		 * sent by sendmsg to INT_MAX, so the assignment is safe. */
		r = x_sendmsg(tls, fd, uintptr(unsafe.Pointer(&(*(*Tmmsghdr)(unsafe.Pointer(msgvec + uintptr(i)*64))).Fmsg_hdr)), int32(flags))
		if r < int64(0) {
			goto error
		}
		(*(*Tmmsghdr)(unsafe.Pointer(msgvec + uintptr(i)*64))).Fmsg_len = uint32(r)
	}
error:
	if i != 0 {
		v1 = i
	} else {
		v1 = -int32(1)
	}
	return v1
	return r1
}

const m_SYS_sendmsg = 46
const m___SC_sendmsg = 16

func x_sendmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r Tssize_t) {
	bp := tls.Alloc(1112) /* tlsAllocs 1112 maxValist 0 */
	defer tls.Free(1112)
	var c uintptr
	var _ /* chbuf at bp+56 */ [66]Tcmsghdr
	var _ /* h at bp+0 */ Tmsghdr
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	/* Kernels before 2.6.38 set SCM_MAX_FD to 255, allocate enough
	 * space to support an SCM_RIGHTS ancillary message with 255 fds.
	 * Kernels since 2.6.38 set SCM_MAX_FD to 253. */
	if msg != 0 {
		*(*Tmsghdr)(unsafe.Pointer(bp)) = *(*Tmsghdr)(unsafe.Pointer(msg))
		v1 = Int32FromInt32(0)
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad2 = v1
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad1 = v1
		msg = bp
		if (*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen != 0 {
			if uint64((*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen) > uint64(1056) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
				return int64(-int32(1))
			}
			x_memcpy(tls, bp+56, (*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_control, uint64((*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen))
			(*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_control = bp + 56
			if uint64((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_controllen) >= uint64(16) {
				v2 = (*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_control
			} else {
				v2 = UintptrFromInt32(0)
			}
			c = v2
			for c != 0 {
				(*Tcmsghdr)(unsafe.Pointer(c)).F__pad1 = int32(0)
				goto _4
			_4:
				if uint64((*Tcmsghdr)(unsafe.Pointer(c)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(c)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_controllen))-int64(c)) {
					v3 = uintptr(0)
				} else {
					v3 = c + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(c)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
				}
				c = v3
			}
		}
	}
	return x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_sendmsg), int32(m___SC_sendmsg), int32(1), int64(fd), int64(msg), int64(flags), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)))))
}

const m_SYS_sendto = 44
const m___SC_sendto = 11

func x_sendto(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32, addr uintptr, alen Tsocklen_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_sendto), int32(m___SC_sendto), int32(1), int64(fd), int64(buf), int64(len1), int64(flags), int64(addr), int64(alen))))
}

func x_endservent(tls *TLS) {
}

func x_setservent(tls *TLS, stayopen int32) {
}

func x_getservent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

func x_setsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen Tsocklen_t) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2096, int32(12), uintptr(unsafe.Pointer(&___func__27)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__27 = [11]int8{'s', 'e', 't', 's', 'o', 'c', 'k', 'o', 'p', 't'}

const m_SYS_shutdown = 48
const m___SC_shutdown = 13

func x_shutdown(tls *TLS, fd int32, how int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_shutdown), int32(m___SC_shutdown), int32(0), int64(fd), int64(how), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
}

const m_SIOCATMARK = 35077

func x_sockatmark(tls *TLS, s int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var _ /* ret at bp+0 */ int32
	if x_ioctl(tls, s, int32(m_SIOCATMARK), VaList(bp+16, bp)) < int32(0) {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

const m_EPROTONOSUPPORT = 93
const m_SYS_socket = 41
const m___SC_socket = 1

func x_socket(tls *TLS, domain int32, type1 int32, protocol int32) (r int32) {
	var s int32
	s = int32(___alt_socketcall(tls, int32(m_SYS_socket), int32(m___SC_socket), int32(0), int64(domain), int64(type1), int64(protocol), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
	if (s == -int32(m_EINVAL) || s == -int32(m_EPROTONOSUPPORT)) && type1&(Int32FromInt32(m_SOCK_CLOEXEC)|Int32FromInt32(m_SOCK_NONBLOCK)) != 0 {
		s = int32(___alt_socketcall(tls, int32(m_SYS_socket), int32(m___SC_socket), int32(0), int64(domain), int64(type1 & ^(Int32FromInt32(02000000)|Int32FromInt32(04000))), int64(protocol), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
		if s < int32(0) {
			return int32(x___syscall_ret(tls, uint64(s)))
		}
		if type1&int32(m_SOCK_CLOEXEC) != 0 {
			___syscall3(tls, int64(72), int64(s), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		}
		if type1&int32(m_SOCK_NONBLOCK) != 0 {
			___syscall3(tls, int64(72), int64(s), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
		}
	}
	return int32(x___syscall_ret(tls, uint64(s)))
}

const m_SYS_socketpair = 53
const m___SC_socketpair = 8

func x_socketpair(tls *TLS, domain int32, type1 int32, protocol int32, fd uintptr) (r1 int32) {
	var r int32
	r = int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_socketpair), int32(m___SC_socketpair), int32(0), int64(domain), int64(type1), int64(protocol), int64(fd), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
	if r < int32(0) && (*(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EINVAL) || *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EPROTONOSUPPORT)) && type1&(Int32FromInt32(m_SOCK_CLOEXEC)|Int32FromInt32(m_SOCK_NONBLOCK)) != 0 {
		r = int32(x___syscall_ret(tls, uint64(___alt_socketcall(tls, int32(m_SYS_socketpair), int32(m___SC_socketpair), int32(0), int64(domain), int64(type1 & ^(Int32FromInt32(02000000)|Int32FromInt32(04000))), int64(protocol), int64(fd), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))))
		if r < int32(0) {
			return r
		}
		if type1&int32(m_SOCK_CLOEXEC) != 0 {
			___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(0)*4))), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
			___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(1)*4))), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		}
		if type1&int32(m_SOCK_NONBLOCK) != 0 {
			___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(0)*4))), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
			___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(1)*4))), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
		}
	}
	return r
}

type Tspwd = struct {
	Fsp_namp   uintptr
	Fsp_pwdp   uintptr
	Fsp_lstchg int64
	Fsp_min    int64
	Fsp_max    int64
	Fsp_warn   int64
	Fsp_inact  int64
	Fsp_expire int64
	Fsp_flag   uint64
}

func x_fgetgrent(tls *TLS, f uintptr) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	x___getgrent_a(tls, f, uintptr(unsafe.Pointer(&_gr)), uintptr(unsafe.Pointer(&_line1)), bp+8, uintptr(unsafe.Pointer(&_mem)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _line1 uintptr

var _mem uintptr

var _gr Tgroup1

func x_fgetpwent(tls *TLS, f uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* res at bp+8 */ uintptr
	var _ /* size at bp+0 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp)) = uint64(0)
	x___getpwent_a(tls, f, uintptr(unsafe.Pointer(&_pw)), uintptr(unsafe.Pointer(&_line2)), bp, bp+8)
	return *(*uintptr)(unsafe.Pointer(bp + 8))
}

var _line2 uintptr

var _pw Tpasswd

func x_fgetspent(tls *TLS, f uintptr) (r uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var res uintptr
	var _ /* cs at bp+8 */ int32
	var _ /* size at bp+0 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp)) = uint64(0)
	res = uintptr(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+8)
	if x_getline(tls, uintptr(unsafe.Pointer(&_line3)), bp, f) >= int64(0) && x___parsespent(tls, _line3, uintptr(unsafe.Pointer(&_sp))) >= int32(0) {
		res = uintptr(unsafe.Pointer(&_sp))
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 8)), uintptr(0))
	return res
}

var _line3 uintptr

var _sp Tspwd

const m_GETGRBYGID = 3
const m_GETGRBYNAME = 2
const m_GRFOUND = 1
const m_GRGID = 4
const m_GRMEMCNT = 5
const m_GRNAMELEN = 2
const m_GRPASSWDLEN = 3
const m_GR_LEN = 6

func _itoa1(tls *TLS, p uintptr, x Tuint32_t) (r uintptr) {
	var v1 uintptr
	var v2 uintptr
	// number of digits in a uint32_t + NUL
	p = p + UintptrFromInt32(11)
	p--
	v1 = p
	*(*int8)(unsafe.Pointer(v1)) = int8(0)
	for cond := true; cond; cond = x != 0 {
		p--
		v2 = p
		*(*int8)(unsafe.Pointer(v2)) = int8(uint32('0') + x%uint32(10))
		x = x / Uint32FromInt32(10)
	}
	return p
}

func x___getgr_a(tls *TLS, name uintptr, gid Tgid_t, gr uintptr, buf uintptr, size uintptr, mem uintptr, nmem uintptr, res uintptr) (r int32) {
	bp := tls.Alloc(48) /* tlsAllocs 48 maxValist 0 */
	defer tls.Free(48)
	var f uintptr
	var grlist_len Tsize_t
	var i Tint32_t
	var key uintptr
	var len1 Tsize_t
	var ptr uintptr
	var req Tint32_t
	var rv int32
	var tmp uintptr
	var tmp1 uintptr
	var _ /* cs at bp+0 */ int32
	var _ /* gidbuf at bp+28 */ [11]int8
	var _ /* groupbuf at bp+4 */ [6]Tint32_t
	var _ /* name_len at bp+44 */ Tuint32_t
	var _ /* swap at bp+40 */ int32
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 int32
	var v5 Tint32_t
	rv = int32(0)
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	f = x_fopen(tls, ts+2121, ts+586)
	if !(f != 0) {
		rv = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		goto done
	}
	for {
		v1 = x___getgrent_a(tls, f, gr, buf, size, mem, nmem, res)
		rv = v1
		if !(!(v1 != 0) && *(*uintptr)(unsafe.Pointer(res)) != 0) {
			break
		}
		if name != 0 && !(x_strcmp(tls, name, (*Tgroup1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fgr_name) != 0) || !(name != 0) && (*Tgroup1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fgr_gid == gid {
			break
		}
	}
	x_fclose(tls, f)
	if !(*(*uintptr)(unsafe.Pointer(res)) != 0) && (rv == int32(0) || rv == int32(m_ENOENT) || rv == int32(m_ENOTDIR)) {
		if name != 0 {
			v2 = int32(m_GETGRBYNAME)
		} else {
			v2 = int32(m_GETGRBYGID)
		}
		req = v2
		*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)) = [6]Tint32_t{}
		len1 = uint64(0)
		grlist_len = uint64(0)
		*(*[11]int8)(unsafe.Pointer(bp + 28)) = [11]int8{}
		*(*int32)(unsafe.Pointer(bp + 40)) = int32(0)
		if name != 0 {
			key = name
		} else {
			if gid < uint32(0) || gid > uint32(0xffffffff) {
				rv = int32(0)
				goto done
			}
			key = _itoa1(tls, bp+28, gid)
		}
		f = x___nscd_query(tls, req, key, bp+4, uint64(24), bp+40)
		if !(f != 0) {
			rv = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
			goto done
		}
		if !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRFOUND)] != 0) {
			rv = int32(0)
			goto cleanup_f
		}
		if !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRNAMELEN)] != 0) || !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRPASSWDLEN)] != 0) {
			rv = int32(m_EIO)
			goto cleanup_f
		}
		if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRNAMELEN)]) > uint64(0xffffffffffffffff)-uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRPASSWDLEN)]) {
			rv = int32(m_ENOMEM)
			goto cleanup_f
		}
		len1 = uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRNAMELEN)] + (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRPASSWDLEN)])
		for i = int32(0); i < (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)]; i++ {
			if x_fread(tls, bp+44, uint64(4), uint64(1), f) < uint64(1) {
				if x_ferror(tls, f) != 0 {
					v3 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
				} else {
					v3 = int32(m_EIO)
				}
				rv = v3
				goto cleanup_f
			}
			if *(*int32)(unsafe.Pointer(bp + 40)) != 0 {
				*(*Tuint32_t)(unsafe.Pointer(bp + 44)) = ___bswap_32(tls, *(*Tuint32_t)(unsafe.Pointer(bp + 44)))
			}
			if uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44))) > uint64(0xffffffffffffffff)-grlist_len || uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44))) > uint64(0xffffffffffffffff)-len1 {
				rv = int32(m_ENOMEM)
				goto cleanup_f
			}
			len1 = len1 + uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44)))
			grlist_len = grlist_len + uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44)))
		}
		if len1 > *(*Tsize_t)(unsafe.Pointer(size)) || !(*(*uintptr)(unsafe.Pointer(buf)) != 0) {
			tmp = x_realloc(tls, *(*uintptr)(unsafe.Pointer(buf)), len1)
			if !(tmp != 0) {
				rv = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
				goto cleanup_f
			}
			*(*uintptr)(unsafe.Pointer(buf)) = tmp
			*(*Tsize_t)(unsafe.Pointer(size)) = len1
		}
		if !(x_fread(tls, *(*uintptr)(unsafe.Pointer(buf)), len1, uint64(1), f) != 0) {
			if x_ferror(tls, f) != 0 {
				v4 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
			} else {
				v4 = int32(m_EIO)
			}
			rv = v4
			goto cleanup_f
		}
		if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)]+int32(1)) > *(*Tsize_t)(unsafe.Pointer(nmem)) {
			if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)]+int32(1)) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(8) {
				rv = int32(m_ENOMEM)
				goto cleanup_f
			}
			tmp1 = x_realloc(tls, *(*uintptr)(unsafe.Pointer(mem)), uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)]+Int32FromInt32(1))*uint64(8))
			if !(tmp1 != 0) {
				rv = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
				goto cleanup_f
			}
			*(*uintptr)(unsafe.Pointer(mem)) = tmp1
			*(*Tsize_t)(unsafe.Pointer(nmem)) = uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)] + int32(1))
		}
		if (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)] != 0 {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8)) = *(*uintptr)(unsafe.Pointer(buf)) + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRNAMELEN)]) + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRPASSWDLEN)])
			ptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8))
			i = Int32FromInt32(0)
			for ; ptr != *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8))+uintptr(grlist_len); ptr++ {
				if !(*(*int8)(unsafe.Pointer(ptr)) != 0) {
					i++
					v5 = i
					*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + uintptr(v5)*8)) = ptr + uintptr(1)
				}
			}
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + uintptr(i)*8)) = uintptr(0)
			if i != (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRMEMCNT)] {
				rv = int32(m_EIO)
				goto cleanup_f
			}
		} else {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8)) = uintptr(0)
		}
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_name = *(*uintptr)(unsafe.Pointer(buf))
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd = (*Tgroup1)(unsafe.Pointer(gr)).Fgr_name + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRNAMELEN)])
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_gid = uint32((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRGID)])
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem = *(*uintptr)(unsafe.Pointer(mem))
		if *(*int8)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd + uintptr(-Int32FromInt32(1)))) != 0 || *(*int8)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(m_GRPASSWDLEN)]-Int32FromInt32(1)))) != 0 {
			rv = int32(m_EIO)
			goto cleanup_f
		}
		if name != 0 && x_strcmp(tls, name, (*Tgroup1)(unsafe.Pointer(gr)).Fgr_name) != 0 || !(name != 0) && gid != (*Tgroup1)(unsafe.Pointer(gr)).Fgr_gid {
			rv = int32(m_EIO)
			goto cleanup_f
		}
		*(*uintptr)(unsafe.Pointer(res)) = gr
	cleanup_f:
		x_fclose(tls, f)
		goto done
	}
done:
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
	}
	return rv
}

func _getgr_r(tls *TLS, name uintptr, gid Tgid_t, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxValist 0 */
	defer tls.Free(40)
	var i Tsize_t
	var rv int32
	var _ /* cs at bp+32 */ int32
	var _ /* len at bp+8 */ Tsize_t
	var _ /* line at bp+0 */ uintptr
	var _ /* mem at bp+16 */ uintptr
	var _ /* nmem at bp+24 */ Tsize_t
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 24)) = uint64(0)
	rv = int32(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+32)
	rv = x___getgr_a(tls, name, gid, gr, bp, bp+8, bp+16, bp+24, res)
	if *(*uintptr)(unsafe.Pointer(res)) != 0 && size < *(*Tsize_t)(unsafe.Pointer(bp + 8))+(*(*Tsize_t)(unsafe.Pointer(bp + 24))+uint64(1))*uint64(8)+uint64(32) {
		*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
		rv = int32(m_ERANGE)
	}
	if *(*uintptr)(unsafe.Pointer(res)) != 0 {
		buf = buf + uintptr((Uint64FromInt32(16)-uint64(buf))%Uint64FromInt32(16))
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem = buf
		buf = buf + uintptr((*(*Tsize_t)(unsafe.Pointer(bp + 24))+Uint64FromInt32(1))*Uint64FromInt64(8))
		x_memcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*Tsize_t)(unsafe.Pointer(bp + 8)))
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_name = uintptr(int64((*Tgroup1)(unsafe.Pointer(gr)).Fgr_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd = uintptr(int64((*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		for i = uint64(0); *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)) != 0; i++ {
			*(*uintptr)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(int64(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)))-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		}
		*(*uintptr)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(0)
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 32)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
	}
	return rv
}

func x_getgrnam_r(tls *TLS, name uintptr, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	return _getgr_r(tls, name, uint32(0), gr, buf, size, res)
}

func x_getgrgid_r(tls *TLS, gid Tgid_t, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	return _getgr_r(tls, uintptr(0), gid, gr, buf, size, res)
}

var _f1 uintptr
var _line4 uintptr
var _mem1 uintptr
var _gr1 Tgroup1

func x_setgrent(tls *TLS) {
	if _f1 != 0 {
		x_fclose(tls, _f1)
	}
	_f1 = uintptr(0)
}

func x_getgrent(tls *TLS) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	if !(_f1 != 0) {
		_f1 = x_fopen(tls, ts+2121, ts+586)
	}
	if !(_f1 != 0) {
		return uintptr(0)
	}
	x___getgrent_a(tls, _f1, uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line4)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func x_getgrgid(tls *TLS, gid Tgid_t) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	x___getgr_a(tls, uintptr(0), gid, uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line4)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func x_getgrnam(tls *TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	x___getgr_a(tls, name, uint32(0), uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line4)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func _atou(tls *TLS, s uintptr) (r uint32) {
	var x uint32
	for x = uint32(0); uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(s))++ {
		x = uint32(10)*x + uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0'))
	}
	return x
}

func x___getgrent_a(tls *TLS, f uintptr, gr uintptr, line uintptr, size uintptr, mem uintptr, nmem uintptr, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var i Tsize_t
	var l Tssize_t
	var mems uintptr
	var rv int32
	var _ /* cs at bp+8 */ int32
	var _ /* s at bp+0 */ uintptr
	var v1 Tssize_t
	var v10 Tsize_t
	var v11 Tsize_t
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	var v8 uintptr
	var v9 uintptr
	rv = int32(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+8)
	for {
		v1 = x_getline(tls, line, size, f)
		l = v1
		if v1 < int64(0) {
			if x_ferror(tls, f) != 0 {
				v2 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
			} else {
				v2 = int32(0)
			}
			rv = v2
			x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			gr = uintptr(0)
			goto end
		}
		*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line + UintptrFromInt32(0)*8)) + uintptr(l-Int64FromInt32(1)))) = int8(0)
		*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(line + UintptrFromInt32(0)*8))
		v3 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_name = v3
		v4 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v4
		if !(v4 != 0) {
			continue
		}
		v5 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v5)) = int8(0)
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd = *(*uintptr)(unsafe.Pointer(bp))
		v6 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v6
		if !(v6 != 0) {
			continue
		}
		v7 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v7)) = int8(0)
		(*Tgroup1)(unsafe.Pointer(gr)).Fgr_gid = _atou(tls, bp)
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			continue
		}
		v8 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v8)) = int8(0)
		mems = *(*uintptr)(unsafe.Pointer(bp))
		break
	}
	for *(*Tsize_t)(unsafe.Pointer(nmem)) = BoolUint64(!!(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0)); *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0; *(*uintptr)(unsafe.Pointer(bp))++ {
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32(',') {
			*(*Tsize_t)(unsafe.Pointer(nmem))++
		}
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(mem)))
	*(*uintptr)(unsafe.Pointer(mem)) = x_calloc(tls, uint64(8), *(*Tsize_t)(unsafe.Pointer(nmem))+uint64(1))
	if !(*(*uintptr)(unsafe.Pointer(mem)) != 0) {
		rv = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
		*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
		gr = uintptr(0)
		goto end
	}
	if *(*int8)(unsafe.Pointer(mems)) != 0 {
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8)) = mems
		*(*uintptr)(unsafe.Pointer(bp)) = mems
		i = Uint64FromInt32(0)
		for ; *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0; *(*uintptr)(unsafe.Pointer(bp))++ {
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32(',') {
				v9 = *(*uintptr)(unsafe.Pointer(bp))
				*(*uintptr)(unsafe.Pointer(bp))++
				*(*int8)(unsafe.Pointer(v9)) = int8(0)
				i++
				v10 = i
				*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + uintptr(v10)*8)) = *(*uintptr)(unsafe.Pointer(bp))
			}
		}
		i++
		v11 = i
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + uintptr(v11)*8)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem + UintptrFromInt32(0)*8)) + UintptrFromInt32(0)*8)) = uintptr(0)
	}
	(*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem = *(*uintptr)(unsafe.Pointer(mem))
end:
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 8)), uintptr(0))
	*(*uintptr)(unsafe.Pointer(res)) = gr
	if rv != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
	}
	return rv
}

const m_GETINITGR = 15
const m_INITGRFOUND = 1
const m_INITGRNGRPS = 2
const m_INITGR_LEN = 3

func x_getgrouplist(tls *TLS, user uintptr, gid Tgid_t, groups uintptr, ngroups uintptr) (r int32) {
	bp := tls.Alloc(88) /* tlsAllocs 88 maxValist 0 */
	defer tls.Free(88)
	var f uintptr
	var i Tssize_t
	var n Tssize_t
	var nbytes Tsize_t
	var nlim int32
	var nscdbuf uintptr
	var ret int32
	var rv int32
	var _ /* buf at bp+56 */ uintptr
	var _ /* gr at bp+0 */ Tgroup1
	var _ /* mem at bp+64 */ uintptr
	var _ /* nmem at bp+72 */ Tsize_t
	var _ /* res at bp+32 */ uintptr
	var _ /* resp at bp+44 */ [3]Tint32_t
	var _ /* size at bp+80 */ Tsize_t
	var _ /* swap at bp+40 */ int32
	var v1 uintptr
	var v2 int32
	var v3 Tssize_t
	var v4 uintptr
	var v5 Tssize_t
	var v6 uintptr
	var v7 int64
	ret = -int32(1)
	n = int64(1)
	*(*int32)(unsafe.Pointer(bp + 40)) = int32(0)
	nscdbuf = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 64)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 72)) = uint64(0)
	nlim = *(*int32)(unsafe.Pointer(ngroups))
	if nlim >= int32(1) {
		v1 = groups
		groups += 4
		*(*Tgid_t)(unsafe.Pointer(v1)) = gid
	}
	f = x___nscd_query(tls, int32(m_GETINITGR), user, bp+44, uint64(12), bp+40)
	if !(f != 0) {
		goto cleanup
	}
	if (*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRFOUND)] != 0 {
		nscdbuf = x_calloc(tls, uint64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRNGRPS)]), uint64(4))
		if !(nscdbuf != 0) {
			goto cleanup
		}
		nbytes = uint64(4) * uint64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRNGRPS)])
		if nbytes != 0 && !(x_fread(tls, nscdbuf, nbytes, uint64(1), f) != 0) {
			if !(x_ferror(tls, f) != 0) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EIO)
			}
			goto cleanup
		}
		if *(*int32)(unsafe.Pointer(bp + 40)) != 0 {
			for i = int64(0); i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRNGRPS)]); i++ {
				*(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) = ___bswap_32(tls, *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)))
			}
		}
	}
	x_fclose(tls, f)
	f = x_fopen(tls, ts+2121, ts+586)
	if !(f != 0) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOENT) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOTDIR) {
		goto cleanup
	}
	if f != 0 {
		for {
			v2 = x___getgrent_a(tls, f, bp, bp+56, bp+80, bp+64, bp+72, bp+32)
			rv = v2
			if !(!(v2 != 0) && *(*uintptr)(unsafe.Pointer(bp + 32)) != 0) {
				break
			}
			if nscdbuf != 0 {
				for i = int64(0); i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRNGRPS)]); i++ {
					if *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) == (*(*Tgroup1)(unsafe.Pointer(bp))).Fgr_gid {
						*(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) = gid
					}
				}
			}
			for i = int64(0); *(*uintptr)(unsafe.Pointer((*(*Tgroup1)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8)) != 0 && x_strcmp(tls, user, *(*uintptr)(unsafe.Pointer((*(*Tgroup1)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8))) != 0; i++ {
			}
			if !(*(*uintptr)(unsafe.Pointer((*(*Tgroup1)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8)) != 0) {
				continue
			}
			n++
			v3 = n
			if v3 <= int64(nlim) {
				v4 = groups
				groups += 4
				*(*Tgid_t)(unsafe.Pointer(v4)) = (*(*Tgroup1)(unsafe.Pointer(bp))).Fgr_gid
			}
		}
		if rv != 0 {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
			goto cleanup
		}
	}
	if nscdbuf != 0 {
		for i = int64(0); i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(m_INITGRNGRPS)]); i++ {
			if *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) != gid {
				n++
				v5 = n
				if v5 <= int64(nlim) {
					v6 = groups
					groups += 4
					*(*Tgid_t)(unsafe.Pointer(v6)) = *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4))
				}
			}
		}
	}
	if n > int64(nlim) {
		v7 = int64(-int32(1))
	} else {
		v7 = n
	}
	ret = int32(v7)
	*(*int32)(unsafe.Pointer(ngroups)) = int32(n)
cleanup:
	if f != 0 {
		x_fclose(tls, f)
	}
	x_free(tls, nscdbuf)
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))
	return ret
}

func x___getpw_a(tls *TLS, name uintptr, uid Tuid_t, pw uintptr, buf uintptr, size uintptr, res uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2132, int32(11), uintptr(unsafe.Pointer(&___func__28)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__28 = [10]int8{'_', '_', 'g', 'e', 't', 'p', 'w', '_', 'a'}

func _getpw_r(tls *TLS, name uintptr, uid Tuid_t, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var rv int32
	var _ /* cs at bp+16 */ int32
	var _ /* len at bp+8 */ Tsize_t
	var _ /* line at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	rv = int32(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+16)
	rv = x___getpw_a(tls, name, uid, pw, bp, bp+8, res)
	if *(*uintptr)(unsafe.Pointer(res)) != 0 && size < *(*Tsize_t)(unsafe.Pointer(bp + 8)) {
		*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
		rv = int32(m_ERANGE)
	}
	if *(*uintptr)(unsafe.Pointer(res)) != 0 {
		x_memcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*Tsize_t)(unsafe.Pointer(bp + 8)))
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
	}
	x_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 16)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
	}
	return rv
}

func x_getpwnam_r(tls *TLS, name uintptr, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	return _getpw_r(tls, name, uint32(0), pw, buf, size, res)
}

func x_getpwuid_r(tls *TLS, uid Tuid_t, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	return _getpw_r(tls, uintptr(0), uid, pw, buf, size, res)
}

var _f2 uintptr
var _line5 uintptr
var _pw1 Tpasswd
var _size Tsize_t

func x_setpwent(tls *TLS) {
	if _f2 != 0 {
		x_fclose(tls, _f2)
	}
	_f2 = uintptr(0)
}

func x_getpwent(tls *TLS) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	if !(_f2 != 0) {
		_f2 = x_fopen(tls, ts+2153, ts+586)
	}
	if !(_f2 != 0) {
		return uintptr(0)
	}
	x___getpwent_a(tls, _f2, uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line5)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func x_getpwuid(tls *TLS, uid Tuid_t) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	x___getpw_a(tls, uintptr(0), uid, uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line5)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func x_getpwnam(tls *TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* res at bp+0 */ uintptr
	x___getpw_a(tls, name, uint32(0), uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line5)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func _atou1(tls *TLS, s uintptr) (r uint32) {
	var x uint32
	for x = uint32(0); uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(s))++ {
		x = uint32(10)*x + uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0'))
	}
	return x
}

func x___getpwent_a(tls *TLS, f uintptr, pw uintptr, line uintptr, size uintptr, res uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var l Tssize_t
	var rv int32
	var _ /* cs at bp+8 */ int32
	var _ /* s at bp+0 */ uintptr
	var v1 Tssize_t
	var v10 uintptr
	var v11 uintptr
	var v12 uintptr
	var v13 uintptr
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 uintptr
	var v8 uintptr
	var v9 uintptr
	rv = int32(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+8)
	for {
		v1 = x_getline(tls, line, size, f)
		l = v1
		if v1 < int64(0) {
			if x_ferror(tls, f) != 0 {
				v2 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
			} else {
				v2 = int32(0)
			}
			rv = v2
			x_free(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			pw = uintptr(0)
			break
		}
		*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line + UintptrFromInt32(0)*8)) + uintptr(l-Int64FromInt32(1)))) = int8(0)
		*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(line + UintptrFromInt32(0)*8))
		v3 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = v3
		v4 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v4
		if !(v4 != 0) {
			continue
		}
		v5 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v5)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = *(*uintptr)(unsafe.Pointer(bp))
		v6 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v6
		if !(v6 != 0) {
			continue
		}
		v7 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v7)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid = _atou1(tls, bp)
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			continue
		}
		v8 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v8)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid = _atou1(tls, bp)
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			continue
		}
		v9 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v9)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = *(*uintptr)(unsafe.Pointer(bp))
		v10 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v10
		if !(v10 != 0) {
			continue
		}
		v11 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v11)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = *(*uintptr)(unsafe.Pointer(bp))
		v12 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v12
		if !(v12 != 0) {
			continue
		}
		v13 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int8)(unsafe.Pointer(v13)) = int8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = *(*uintptr)(unsafe.Pointer(bp))
		break
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 8)), uintptr(0))
	*(*uintptr)(unsafe.Pointer(res)) = pw
	if rv != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = rv
	}
	return rv
}

func x_setspent(tls *TLS) {
}

func x_endspent(tls *TLS) {
}

func x_getspent(tls *TLS) (r uintptr) {
	return uintptr(0)
}

const m_LINE_LIM = 256

func x_getspnam(tls *TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var orig_errno int32
	var _ /* res at bp+0 */ uintptr
	var v1 int32
	orig_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if !(_line6 != 0) {
		_line6 = _default_malloc(tls, uint64(m_LINE_LIM))
	}
	if !(_line6 != 0) {
		return uintptr(0)
	}
	e = x_getspnam_r(tls, name, uintptr(unsafe.Pointer(&_sp1)), _line6, uint64(m_LINE_LIM), bp)
	if e != 0 {
		v1 = e
	} else {
		v1 = orig_errno
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v1
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _sp1 Tspwd

var _line6 uintptr

const m_S_IFREG = 32768

func _xatol(tls *TLS, s uintptr) (r int64) {
	var x int64
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32(':') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) == int32('\n') {
		return int64(-int32(1))
	}
	for x = int64(0); uint32(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0')) < uint32(10); *(*uintptr)(unsafe.Pointer(s))++ {
		x = int64(10)*x + int64(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0'))
	}
	return x
}

func x___parsespent(tls *TLS, _s uintptr, sp uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = _s
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_namp = *(*uintptr)(unsafe.Pointer(bp))
	v1 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
	*(*uintptr)(unsafe.Pointer(bp)) = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) = int8(0)
	*(*uintptr)(unsafe.Pointer(bp))++
	v2 = *(*uintptr)(unsafe.Pointer(bp))
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp = v2
	v3 = x_strchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
	*(*uintptr)(unsafe.Pointer(bp)) = v3
	if !(v3 != 0) {
		return -int32(1)
	}
	*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) = int8(0)
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_min = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_max = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_warn = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_inact = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_expire = _xatol(tls, bp)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp))++
	(*Tspwd)(unsafe.Pointer(sp)).Fsp_flag = uint64(_xatol(tls, bp))
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('\n') {
		return -int32(1)
	}
	return int32(0)
}

func _cleanup1(tls *TLS, p uintptr) {
	x_fclose(tls, p)
}

func x_getspnam_r(tls *TLS, name uintptr, sp uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(464) /* tlsAllocs 448 maxValist 1 */
	defer tls.Free(464)
	var f uintptr
	var fd int32
	var k Tsize_t
	var l Tsize_t
	var orig_errno int32
	var rv int32
	var skip int32
	var _ /* __cb at bp+424 */ T__ptcb
	var _ /* cs at bp+276 */ int32
	var _ /* path at bp+0 */ [275]int8
	var _ /* st at bp+280 */ Tstat
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 uintptr
	var v5 bool
	var v6 Tsize_t
	var v7 bool
	var v8 int32
	f = uintptr(0)
	rv = int32(0)
	l = x_strlen(tls, name)
	skip = int32(0)
	orig_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Disallow potentially-malicious user names */
	if int32(*(*int8)(unsafe.Pointer(name))) == int32('.') || x_strchr(tls, name, int32('/')) != 0 || !(l != 0) {
		v1 = Int32FromInt32(m_EINVAL)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v1
		return v1
	}
	/* Buffer size must at least be able to hold name, plus some.. */
	if size < l+uint64(100) {
		v2 = Int32FromInt32(m_ERANGE)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v2
		return v2
	}
	/* Protect against truncation */
	if uint64(x_snprintf(tls, bp, uint64(275), ts+2165, VaList(bp+456, name))) >= uint64(275) {
		v3 = Int32FromInt32(m_EINVAL)
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v3
		return v3
	}
	fd = x_open(tls, bp, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_NOFOLLOW)|Int32FromInt32(m_O_NONBLOCK)|Int32FromInt32(m_O_CLOEXEC), 0)
	if fd >= int32(0) {
		*(*Tstat)(unsafe.Pointer(bp + 280)) = Tstat{}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		if v5 = x___fstat(tls, fd, bp+280) != 0 || !((*(*Tstat)(unsafe.Pointer(bp + 280))).Fst_mode&Uint32FromInt32(m_S_IFMT) == Uint32FromInt32(m_S_IFREG)); !v5 {
			v4 = x___fdopen(tls, fd, ts+590)
			f = v4
		}
		if v5 || !(v4 != 0) {
			x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+276)
			x_close(tls, fd)
			x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 276)), uintptr(0))
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
	} else {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOENT) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOTDIR) {
			return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		}
		f = x_fopen(tls, ts+2184, ts+586)
		if !(f != 0) {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOENT) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOTDIR) {
				return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
			}
			return int32(0)
		}
	}
	{
		x__pthread_cleanup_push(tls, bp+424, __ccgo_fp(_cleanup1), f)
		for {
			if v7 = x_fgets(tls, buf, int32(size), f) != 0; v7 {
				v6 = x_strlen(tls, buf)
				k = v6
			}
			if !(v7 && v6 > uint64(0)) {
				break
			}
			if skip != 0 || x_strncmp(tls, name, buf, l) != 0 || int32(*(*int8)(unsafe.Pointer(buf + uintptr(l)))) != int32(':') {
				skip = BoolInt32(int32(*(*int8)(unsafe.Pointer(buf + uintptr(k-Uint64FromInt32(1))))) != int32('\n'))
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(buf + uintptr(k-Uint64FromInt32(1))))) != int32('\n') {
				rv = int32(m_ERANGE)
				break
			}
			if x___parsespent(tls, buf, sp) < int32(0) {
				continue
			}
			*(*uintptr)(unsafe.Pointer(res)) = sp
			break
		}
		x__pthread_cleanup_pop(tls, bp+424, int32(1))
	}
	if rv != 0 {
		v8 = rv
	} else {
		v8 = orig_errno
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = v8
	return rv
}

func x_lckpwdf(tls *TLS) (r int32) {
	return int32(0)
}

func x_ulckpwdf(tls *TLS) (r int32) {
	return int32(0)
}

func x___nscd_query(tls *TLS, req Tint32_t, key uintptr, buf uintptr, len1 Tsize_t, swap uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2196, int32(13), uintptr(unsafe.Pointer(&___func__29)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__29 = [13]int8{'_', '_', 'n', 's', 'c', 'd', '_', 'q', 'u', 'e', 'r', 'y'}

func x_putgrent(tls *TLS, gr uintptr, f uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 0 maxValist 3 */
	defer tls.Free(32)
	var i Tsize_t
	var r int32
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 int32
	x_flockfile(tls, f)
	v1 = x_fprintf(tls, f, ts+2220, VaList(bp+8, (*Tgroup1)(unsafe.Pointer(gr)).Fgr_name, (*Tgroup1)(unsafe.Pointer(gr)).Fgr_passwd, (*Tgroup1)(unsafe.Pointer(gr)).Fgr_gid))
	r = v1
	if v1 < int32(0) {
		goto done
	}
	if (*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem != 0 {
		for i = uint64(0); *(*uintptr)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) != 0; i++ {
			if i != 0 {
				v3 = ts + 2230
			} else {
				v3 = ts
			}
			v2 = x_fprintf(tls, f, ts+2232, VaList(bp+8, v3, *(*uintptr)(unsafe.Pointer((*Tgroup1)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8))))
			r = v2
			if v2 < int32(0) {
				goto done
			}
		}
	}
	r = x_fputc(tls, int32('\n'), f)
done:
	x_funlockfile(tls, f)
	if r < int32(0) {
		v4 = -int32(1)
	} else {
		v4 = int32(0)
	}
	return v4
}

func x_putpwent(tls *TLS, pw uintptr, f uintptr) (r int32) {
	bp := tls.Alloc(64) /* tlsAllocs 0 maxValist 7 */
	defer tls.Free(64)
	var v1 int32
	if x_fprintf(tls, f, ts+2237, VaList(bp+8, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell)) < int32(0) {
		v1 = -int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

func x_putspent(tls *TLS, sp uintptr, f uintptr) (r int32) {
	bp := tls.Alloc(136) /* tlsAllocs 0 maxValist 16 */
	defer tls.Free(136)
	var v1 int32
	var v10 int32
	var v11 int64
	var v12 int32
	var v13 int64
	var v14 int32
	var v15 int64
	var v16 int32
	var v17 uint64
	var v2 uintptr
	var v3 uintptr
	var v4 int32
	var v5 int64
	var v6 int32
	var v7 int64
	var v8 int32
	var v9 int64
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_namp != 0 {
		v2 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_namp
	} else {
		v2 = ts
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp != 0 {
		v3 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp
	} else {
		v3 = ts
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg == int64(-int32(1)) {
		v4 = int32(0)
	} else {
		v4 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg == int64(-int32(1)) {
		v5 = int64(0)
	} else {
		v5 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_min == int64(-int32(1)) {
		v6 = int32(0)
	} else {
		v6 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_min == int64(-int32(1)) {
		v7 = int64(0)
	} else {
		v7 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_min
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_max == int64(-int32(1)) {
		v8 = int32(0)
	} else {
		v8 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_max == int64(-int32(1)) {
		v9 = int64(0)
	} else {
		v9 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_max
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn == int64(-int32(1)) {
		v10 = int32(0)
	} else {
		v10 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn == int64(-int32(1)) {
		v11 = int64(0)
	} else {
		v11 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact == int64(-int32(1)) {
		v12 = int32(0)
	} else {
		v12 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact == int64(-int32(1)) {
		v13 = int64(0)
	} else {
		v13 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire == int64(-int32(1)) {
		v14 = int32(0)
	} else {
		v14 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire == int64(-int32(1)) {
		v15 = int64(0)
	} else {
		v15 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag == uint64(-Int32FromInt32(1)) {
		v16 = int32(0)
	} else {
		v16 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag == uint64(-Int32FromInt32(1)) {
		v17 = uint64(0)
	} else {
		v17 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag
	}
	if x_fprintf(tls, f, ts+2259, VaList(bp+8, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)) < int32(0) {
		v1 = -int32(1)
	} else {
		v1 = int32(0)
	}
	return v1
}

func x___rand48_step(tls *TLS, xi uintptr, lc uintptr) (r Tuint64_t) {
	var a Tuint64_t
	var x Tuint64_t
	x = uint64(uint32(*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(0)*2)))|(uint32(*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(1)*2)))+uint32(0))<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(2)*2)))+uint64(0))<<int32(32)
	a = uint64(uint32(*(*uint16)(unsafe.Pointer(lc + UintptrFromInt32(0)*2)))|(uint32(*(*uint16)(unsafe.Pointer(lc + UintptrFromInt32(1)*2)))+uint32(0))<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(lc + UintptrFromInt32(2)*2)))+uint64(0))<<int32(32)
	x = a*x + uint64(*(*uint16)(unsafe.Pointer(lc + UintptrFromInt32(3)*2)))
	*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(0)*2)) = uint16(x)
	*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(1)*2)) = uint16(x >> int32(16))
	*(*uint16)(unsafe.Pointer(xi + UintptrFromInt32(2)*2)) = uint16(x >> int32(32))
	return x & uint64(0xffffffffffff)
}

func x_erand48(tls *TLS, s uintptr) (r float64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* x at bp+0 */ struct {
		Ff [0]float64
		Fu Tuint64_t
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(0x3ff0000000000000) | x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2)<<int32(4)
	return *(*float64)(unsafe.Pointer(bp)) - float64(1)
}

func x_drand48(tls *TLS) (r float64) {
	return x_erand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

func x_lcong48(tls *TLS, p uintptr) {
	x_memcpy(tls, uintptr(unsafe.Pointer(&x___seed48)), p, uint64(14))
}

func x_nrand48(tls *TLS, s uintptr) (r int64) {
	return int64(x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2) >> int32(17))
}

func x_lrand48(tls *TLS) (r int64) {
	return x_nrand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

func x_jrand48(tls *TLS, s uintptr) (r int64) {
	return int64(int32(x___rand48_step(tls, s, uintptr(unsafe.Pointer(&x___seed48))+uintptr(3)*2) >> Int32FromInt32(16)))
}

func x_mrand48(tls *TLS) (r int64) {
	return x_jrand48(tls, uintptr(unsafe.Pointer(&x___seed48)))
}

var _seed Tuint64_t

func x_srand(tls *TLS, s uint32) {
	_seed = uint64(s - uint32(1))
}

func x_rand(tls *TLS) (r int32) {
	_seed = uint64(6364136223846793005)*_seed + uint64(1)
	return int32(_seed >> int32(33))
}

func _temper(tls *TLS, x uint32) (r uint32) {
	x = x ^ x>>Int32FromInt32(11)
	x = x ^ x<<Int32FromInt32(7)&Uint32FromUint32(0x9D2C5680)
	x = x ^ x<<Int32FromInt32(15)&Uint32FromUint32(0xEFC60000)
	x = x ^ x>>Int32FromInt32(18)
	return x
}

func x_rand_r(tls *TLS, seed uintptr) (r int32) {
	var v1 uint32
	v1 = *(*uint32)(unsafe.Pointer(seed))*Uint32FromInt32(1103515245) + Uint32FromInt32(12345)
	*(*uint32)(unsafe.Pointer(seed)) = v1
	return int32(_temper(tls, v1) / uint32(2))
}

/*
this code uses the same lagged fibonacci generator as the
original bsd random implementation except for the seeding
which was broken in the original
*/

var _init = [32]Tuint32_t{
	0:  uint32(0x00000000),
	1:  uint32(0x5851f42d),
	2:  uint32(0xc0b18ccf),
	3:  uint32(0xcbb5f646),
	4:  uint32(0xc7033129),
	5:  uint32(0x30705b04),
	6:  uint32(0x20fd5db4),
	7:  uint32(0x9a8b7f78),
	8:  uint32(0x502959d8),
	9:  uint32(0xab894868),
	10: uint32(0x6c0356a7),
	11: uint32(0x88cdb7ff),
	12: uint32(0xb477d43f),
	13: uint32(0x70a3a52b),
	14: uint32(0xa8e4baf1),
	15: uint32(0xfd8341fc),
	16: uint32(0x8ae16fd9),
	17: uint32(0x742d2f7a),
	18: uint32(0x0d1f0796),
	19: uint32(0x76035e09),
	20: uint32(0x40f7702c),
	21: uint32(0x6fa72ca5),
	22: uint32(0xaaa84157),
	23: uint32(0x58a0df74),
	24: uint32(0xc74a0364),
	25: uint32(0xae533cc4),
	26: uint32(0x04185faf),
	27: uint32(0x6de3b115),
	28: uint32(0x0cab8628),
	29: uint32(0xf043bfa4),
	30: uint32(0x398150e9),
	31: uint32(0x37521657)}

var _n = int32(31)
var _i = int32(3)
var _j = int32(0)
var _x1 = uintptr(unsafe.Pointer(&_init)) + uintptr(1)*4
var _lock5 [1]int32

func _lcg31(tls *TLS, x Tuint32_t) (r Tuint32_t) {
	return (uint32(1103515245)*x + uint32(12345)) & uint32(0x7fffffff)
}

func _lcg64(tls *TLS, x Tuint64_t) (r Tuint64_t) {
	return uint64(6364136223846793005)*x + uint64(1)
}

func _savestate(tls *TLS) (r uintptr) {
	*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) = uint32(_n<<int32(16) | _i<<int32(8) | _j)
	return _x1 - uintptr(1)*4
}

func _loadstate(tls *TLS, state uintptr) {
	_x1 = state + uintptr(1)*4
	_n = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) >> int32(16))
	_i = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) >> Int32FromInt32(8) & uint32(0xff))
	_j = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) & uint32(0xff))
}

func ___srandom(tls *TLS, seed uint32) {
	var k int32
	var s Tuint64_t
	var v1 int32
	var p2 uintptr
	s = uint64(seed)
	if _n == int32(0) {
		*(*Tuint32_t)(unsafe.Pointer(_x1 + UintptrFromInt32(0)*4)) = uint32(s)
		return
	}
	if _n == int32(31) || _n == int32(7) {
		v1 = int32(3)
	} else {
		v1 = int32(1)
	}
	_i = v1
	_j = int32(0)
	for k = int32(0); k < _n; k++ {
		s = _lcg64(tls, s)
		*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(k)*4)) = uint32(s >> int32(32))
	}
	/* make sure x contains at least one odd number */
	p2 = _x1 + UintptrFromInt32(0)*4
	*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) | Uint32FromInt32(1)
}

func x_srandom(tls *TLS, seed uint32) {
	x___lock(tls, uintptr(unsafe.Pointer(&_lock5)))
	___srandom(tls, seed)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock5)))
}

func x_initstate(tls *TLS, seed uint32, state uintptr, size Tsize_t) (r uintptr) {
	var old uintptr
	if size < uint64(8) {
		return uintptr(0)
	}
	x___lock(tls, uintptr(unsafe.Pointer(&_lock5)))
	old = _savestate(tls)
	if size < uint64(32) {
		_n = int32(0)
	} else {
		if size < uint64(64) {
			_n = int32(7)
		} else {
			if size < uint64(128) {
				_n = int32(15)
			} else {
				if size < uint64(256) {
					_n = int32(31)
				} else {
					_n = int32(63)
				}
			}
		}
	}
	_x1 = state + uintptr(1)*4
	___srandom(tls, seed)
	_savestate(tls)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock5)))
	return old
}

func x_setstate(tls *TLS, state uintptr) (r uintptr) {
	var old uintptr
	x___lock(tls, uintptr(unsafe.Pointer(&_lock5)))
	old = _savestate(tls)
	_loadstate(tls, state)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock5)))
	return old
}

func x_random(tls *TLS) (r int64) {
	var k int64
	var v1 Tuint32_t
	var v3 int32
	var v4 int32
	var p2 uintptr
	x___lock(tls, uintptr(unsafe.Pointer(&_lock5)))
	if _n == int32(0) {
		v1 = _lcg31(tls, *(*Tuint32_t)(unsafe.Pointer(_x1 + UintptrFromInt32(0)*4)))
		*(*Tuint32_t)(unsafe.Pointer(_x1 + UintptrFromInt32(0)*4)) = v1
		k = int64(v1)
		goto end
	}
	p2 = _x1 + uintptr(_i)*4
	*(*Tuint32_t)(unsafe.Pointer(p2)) = *(*Tuint32_t)(unsafe.Pointer(p2)) + *(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(_j)*4))
	k = int64(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(_i)*4)) >> int32(1))
	_i++
	v3 = _i
	if v3 == _n {
		_i = int32(0)
	}
	_j++
	v4 = _j
	if v4 == _n {
		_j = int32(0)
	}
end:
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock5)))
	return k
}

func x_seed48(tls *TLS, s uintptr) (r uintptr) {
	x_memcpy(tls, uintptr(unsafe.Pointer(&_p1)), uintptr(unsafe.Pointer(&x___seed48)), uint64(6))
	x_memcpy(tls, uintptr(unsafe.Pointer(&x___seed48)), s, uint64(6))
	return uintptr(unsafe.Pointer(&_p1))
}

var _p1 [3]uint16

func x_srand48(tls *TLS, seed int64) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2308, int32(6), uintptr(unsafe.Pointer(&___func__30)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__30 = [8]int8{'s', 'r', 'a', 'n', 'd', '4', '8'}

func _dummy11(tls *TLS, x int32) {
}

func x__Fork(tls *TLS) (r Tpid_t) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var ret Tpid_t
	var self Tpthread_t
	var _ /* set at bp+0 */ Tsigset_t
	var v1 uintptr
	x___block_all_sigs(tls, bp)
	x___lock(tls, uintptr(unsafe.Pointer(&x___abort_lock)))
	ret = int32(___syscall0(tls, int64(57)))
	if !(ret != 0) {
		self = ___get_tp(tls)
		(*T__pthread)(unsafe.Pointer(self)).Ftid = int32(___syscall0(tls, int64(186)))
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Foff = int64(0)
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
		v1 = self
		(*T__pthread)(unsafe.Pointer(self)).Fprev = v1
		(*T__pthread)(unsafe.Pointer(self)).Fnext = v1
		x___thread_list_lock = int32(0)
		x___libc.Fthreads_minus_1 = int32(0)
		if x___libc.Fneed_locks != 0 {
			x___libc.Fneed_locks = int8(-int32(1))
		}
	}
	x___unlock(tls, uintptr(unsafe.Pointer(&x___abort_lock)))
	if !(ret != 0) {
		x___aio_atfork(tls, int32(1))
	}
	x___restore_sigs(tls, bp)
	return int32(x___syscall_ret(tls, uint64(ret)))
}

func x_execl(tls *TLS, path uintptr, argv0 uintptr, va uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2327, int32(7), uintptr(unsafe.Pointer(&___func__31)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__31 = [6]int8{'e', 'x', 'e', 'c', 'l'}

func x_execle(tls *TLS, path uintptr, argv0 uintptr, va uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2347, int32(7), uintptr(unsafe.Pointer(&___func__32)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__32 = [7]int8{'e', 'x', 'e', 'c', 'l', 'e'}

func x_execlp(tls *TLS, file uintptr, argv0 uintptr, va uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2368, int32(7), uintptr(unsafe.Pointer(&___func__33)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__33 = [7]int8{'e', 'x', 'e', 'c', 'l', 'p'}

func x_execv(tls *TLS, path uintptr, argv uintptr) (r int32) {
	return x_execve(tls, path, argv, x___environ)
}

func x_execve(tls *TLS, path uintptr, argv uintptr, envp uintptr) (r int32) {
	/* do we need to use environ if envp is null? */
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(59), int64(path), int64(argv), int64(envp)))))
}

func x___execvpe(tls *TLS, file uintptr, argv uintptr, envp uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2389, int32(12), uintptr(unsafe.Pointer(&___func__34)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__34 = [10]int8{'_', '_', 'e', 'x', 'e', 'c', 'v', 'p', 'e'}

func x_execvp(tls *TLS, file uintptr, argv uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2389, int32(17), uintptr(unsafe.Pointer(&___func__35)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__35 = [7]int8{'e', 'x', 'e', 'c', 'v', 'p'}

func x_fexecve(tls *TLS, fd int32, argv uintptr, envp uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var r int32
	var _ /* buf at bp+0 */ [27]int8
	r = int32(___syscall5(tls, int64(322), int64(fd), int64(ts), int64(argv), int64(envp), int64(Int32FromInt32(0x1000))))
	if r != -int32(m_ENOSYS) {
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	x___procfdname(tls, bp, uint32(fd))
	x_execve(tls, bp, argv, envp)
	if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOENT) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EBADF)
	}
	return -int32(1)
}

var _dummy_lockptr = uintptr(0)

var _atfork_locks = [10]uintptr{
	0: uintptr(unsafe.Pointer(&x___at_quick_exit_lockptr)),
	1: uintptr(unsafe.Pointer(&x___atexit_lockptr)),
	2: uintptr(unsafe.Pointer(&x___gettext_lockptr)),
	3: uintptr(unsafe.Pointer(&x___locale_lockptr)),
	4: uintptr(unsafe.Pointer(&x___random_lockptr)),
	5: uintptr(unsafe.Pointer(&x___sem_open_lockptr)),
	6: uintptr(unsafe.Pointer(&x___stdio_ofl_lockptr)),
	7: uintptr(unsafe.Pointer(&x___syslog_lockptr)),
	8: uintptr(unsafe.Pointer(&x___timezone_lockptr)),
	9: uintptr(unsafe.Pointer(&x___bump_lockptr))}

func _dummy12(tls *TLS, x int32) {
}

func _dummy_01(tls *TLS) {
}

func x_fork(tls *TLS) (r Tpid_t) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var errno_save int32
	var i int32
	var i1 int32
	var need_locks int32
	var next Tpthread_t
	var ret Tpid_t
	var self Tpthread_t
	var td Tpthread_t
	var _ /* set at bp+0 */ Tsigset_t
	x___fork_handler(tls, -int32(1))
	x___block_app_sigs(tls, bp)
	need_locks = BoolInt32(int32(x___libc.Fneed_locks) > int32(0))
	if need_locks != 0 {
		x___ldso_atfork(tls, -int32(1))
		x___pthread_key_atfork(tls, -int32(1))
		x___aio_atfork(tls, -int32(1))
		x___inhibit_ptc(tls)
		i = int32(0)
		for ; uint64(i) < Uint64FromInt64(80)/Uint64FromInt64(8); i++ {
			if *(*uintptr)(unsafe.Pointer(_atfork_locks[i])) != 0 {
				x___lock(tls, *(*uintptr)(unsafe.Pointer(_atfork_locks[i])))
			}
		}
		x___malloc_atfork(tls, -int32(1))
		x___tl_lock(tls)
	}
	self = ___get_tp(tls)
	next = (*T__pthread)(unsafe.Pointer(self)).Fnext
	ret = x__Fork(tls)
	errno_save = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if need_locks != 0 {
		if !(ret != 0) {
			td = next
			for ; td != self; td = (*T__pthread)(unsafe.Pointer(td)).Fnext {
				(*T__pthread)(unsafe.Pointer(td)).Ftid = -int32(1)
			}
			if x___vmlock_lockptr != 0 {
				*(*int32)(unsafe.Pointer(x___vmlock_lockptr + UintptrFromInt32(0)*4)) = int32(0)
				*(*int32)(unsafe.Pointer(x___vmlock_lockptr + UintptrFromInt32(1)*4)) = int32(0)
			}
		}
		x___tl_unlock(tls)
		x___malloc_atfork(tls, BoolInt32(!(ret != 0)))
		i1 = int32(0)
		for ; uint64(i1) < Uint64FromInt64(80)/Uint64FromInt64(8); i1++ {
			if *(*uintptr)(unsafe.Pointer(_atfork_locks[i1])) != 0 {
				if ret != 0 {
					x___unlock(tls, *(*uintptr)(unsafe.Pointer(_atfork_locks[i1])))
				} else {
					*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(_atfork_locks[i1])))) = int32(0)
				}
			}
		}
		x___release_ptc(tls)
		if ret != 0 {
			x___aio_atfork(tls, int32(0))
		}
		x___pthread_key_atfork(tls, BoolInt32(!(ret != 0)))
		x___ldso_atfork(tls, BoolInt32(!(ret != 0)))
	}
	x___restore_sigs(tls, bp)
	x___fork_handler(tls, BoolInt32(!(ret != 0)))
	if ret < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = errno_save
	}
	return ret
}

type Tsched_param1 = struct {
	Fsched_priority int32
	F__reserved1    int32
	F__reserved2    [2]struct {
		F__reserved1 Ttime_t
		F__reserved2 int64
	}
	F__reserved3 int32
}

type Tposix_spawnattr_t = struct {
	F__flags int32
	F__pgrp  Tpid_t
	F__def   Tsigset_t
	F__mask  Tsigset_t
	F__prio  int32
	F__pol   int32
	F__fn    uintptr
	F__pad   [56]int8
}

type Tposix_spawn_file_actions_t = struct {
	F__pad0    [2]int32
	F__actions uintptr
	F__pad     [16]int32
}

type Tfdop = struct {
	Fnext        uintptr
	Fprev        uintptr
	Fcmd         int32
	Ffd          int32
	Fsrcfd       int32
	Foflag       int32
	Fmode        Tmode_t
	F__ccgo_pad8 [4]byte
}

type Targs1 = struct {
	Fp       [2]int32
	Foldmask Tsigset_t
	Fpath    uintptr
	Ffa      uintptr
	Fattr    uintptr
	Fargv    uintptr
	Fenvp    uintptr
}

func x_posix_spawn(tls *TLS, res uintptr, path uintptr, fa uintptr, attr uintptr, argv uintptr, envp uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2410, int32(28), uintptr(unsafe.Pointer(&___func__36)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__36 = [12]int8{'p', 'o', 's', 'i', 'x', '_', 's', 'p', 'a', 'w', 'n'}

const m_FDOP_CHDIR = 4

func x_posix_spawn_file_actions_addchdir_np(tls *TLS, fa uintptr, path uintptr) (r int32) {
	var op uintptr
	var v1 uintptr
	op = x___libc_malloc(tls, uint64(40)+x_strlen(tls, path)+uint64(1))
	if !(op != 0) {
		return int32(m_ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(m_FDOP_CHDIR)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = -int32(1)
	x_strcpy(tls, op+36, path)
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return int32(0)
}

const m_FDOP_CLOSE = 1

func x_posix_spawn_file_actions_addclose(tls *TLS, fa uintptr, fd int32) (r int32) {
	var op uintptr
	var v1 uintptr
	if fd < int32(0) {
		return int32(m_EBADF)
	}
	op = x___libc_malloc(tls, uint64(40))
	if !(op != 0) {
		return int32(m_ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(m_FDOP_CLOSE)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return int32(0)
}

const m_FDOP_DUP2 = 2

func x_posix_spawn_file_actions_adddup2(tls *TLS, fa uintptr, srcfd int32, fd int32) (r int32) {
	var op uintptr
	var v1 uintptr
	if srcfd < int32(0) || fd < int32(0) {
		return int32(m_EBADF)
	}
	op = x___libc_malloc(tls, uint64(40))
	if !(op != 0) {
		return int32(m_ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(m_FDOP_DUP2)
	(*Tfdop)(unsafe.Pointer(op)).Fsrcfd = srcfd
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return int32(0)
}

const m_FDOP_FCHDIR = 5

func x_posix_spawn_file_actions_addfchdir_np(tls *TLS, fa uintptr, fd int32) (r int32) {
	var op uintptr
	var v1 uintptr
	if fd < int32(0) {
		return int32(m_EBADF)
	}
	op = x___libc_malloc(tls, uint64(40))
	if !(op != 0) {
		return int32(m_ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(m_FDOP_FCHDIR)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return int32(0)
}

const m_FDOP_OPEN = 3

func x_posix_spawn_file_actions_addopen(tls *TLS, fa uintptr, fd int32, path uintptr, flags int32, mode Tmode_t) (r int32) {
	var op uintptr
	var v1 uintptr
	if fd < int32(0) {
		return int32(m_EBADF)
	}
	op = x___libc_malloc(tls, uint64(40)+x_strlen(tls, path)+uint64(1))
	if !(op != 0) {
		return int32(m_ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(m_FDOP_OPEN)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	(*Tfdop)(unsafe.Pointer(op)).Foflag = flags
	(*Tfdop)(unsafe.Pointer(op)).Fmode = mode
	x_strcpy(tls, op+36, path)
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return int32(0)
}

func x_posix_spawn_file_actions_destroy(tls *TLS, fa uintptr) (r int32) {
	var next uintptr
	var op uintptr
	op = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	for op != 0 {
		next = (*Tfdop)(unsafe.Pointer(op)).Fnext
		x___libc_free(tls, op)
		op = next
	}
	return int32(0)
}

func x_posix_spawn_file_actions_init(tls *TLS, fa uintptr) (r int32) {
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = uintptr(0)
	return int32(0)
}

func x_posix_spawnattr_destroy(tls *TLS, attr uintptr) (r int32) {
	return int32(0)
}

func x_posix_spawnattr_getflags(tls *TLS, attr uintptr, flags uintptr) (r int32) {
	*(*int16)(unsafe.Pointer(flags)) = int16((*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__flags)
	return int32(0)
}

func x_posix_spawnattr_getpgroup(tls *TLS, attr uintptr, pgrp uintptr) (r int32) {
	*(*Tpid_t)(unsafe.Pointer(pgrp)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__pgrp
	return int32(0)
}

func x_posix_spawnattr_getsigdefault(tls *TLS, attr uintptr, def uintptr) (r int32) {
	*(*Tsigset_t)(unsafe.Pointer(def)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__def
	return int32(0)
}

func x_posix_spawnattr_getsigmask(tls *TLS, attr uintptr, mask uintptr) (r int32) {
	*(*Tsigset_t)(unsafe.Pointer(mask)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__mask
	return int32(0)
}

func x_posix_spawnattr_init(tls *TLS, attr uintptr) (r int32) {
	*(*Tposix_spawnattr_t)(unsafe.Pointer(attr)) = Tposix_spawnattr_t{}
	return int32(0)
}

func x_posix_spawnattr_getschedparam(tls *TLS, attr uintptr, schedparam uintptr) (r int32) {
	return int32(m_ENOSYS)
}

func x_posix_spawnattr_setschedparam(tls *TLS, attr uintptr, schedparam uintptr) (r int32) {
	return int32(m_ENOSYS)
}

func x_posix_spawnattr_getschedpolicy(tls *TLS, attr uintptr, policy uintptr) (r int32) {
	return int32(m_ENOSYS)
}

func x_posix_spawnattr_setschedpolicy(tls *TLS, attr uintptr, policy int32) (r int32) {
	return int32(m_ENOSYS)
}

const m_POSIX_SPAWN_RESETIDS = 1
const m_POSIX_SPAWN_SETPGROUP = 2
const m_POSIX_SPAWN_SETSCHEDPARAM = 16
const m_POSIX_SPAWN_SETSCHEDULER = 32
const m_POSIX_SPAWN_SETSID = 128
const m_POSIX_SPAWN_SETSIGDEF = 4
const m_POSIX_SPAWN_SETSIGMASK = 8
const m_POSIX_SPAWN_USEVFORK = 64

func x_posix_spawnattr_setflags(tls *TLS, attr uintptr, flags int16) (r int32) {
	var all_flags uint32
	all_flags = uint32(Int32FromInt32(m_POSIX_SPAWN_RESETIDS) | Int32FromInt32(m_POSIX_SPAWN_SETPGROUP) | Int32FromInt32(m_POSIX_SPAWN_SETSIGDEF) | Int32FromInt32(m_POSIX_SPAWN_SETSIGMASK) | Int32FromInt32(m_POSIX_SPAWN_SETSCHEDPARAM) | Int32FromInt32(m_POSIX_SPAWN_SETSCHEDULER) | Int32FromInt32(m_POSIX_SPAWN_USEVFORK) | Int32FromInt32(m_POSIX_SPAWN_SETSID))
	if uint32(flags) & ^all_flags != 0 {
		return int32(m_EINVAL)
	}
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__flags = int32(flags)
	return int32(0)
}

func x_posix_spawnattr_setpgroup(tls *TLS, attr uintptr, pgrp Tpid_t) (r int32) {
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__pgrp = pgrp
	return int32(0)
}

func x_posix_spawnattr_setsigdefault(tls *TLS, attr uintptr, def uintptr) (r int32) {
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__def = *(*Tsigset_t)(unsafe.Pointer(def))
	return int32(0)
}

func x_posix_spawnattr_setsigmask(tls *TLS, attr uintptr, mask uintptr) (r int32) {
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__mask = *(*Tsigset_t)(unsafe.Pointer(mask))
	return int32(0)
}

func x_posix_spawnp(tls *TLS, res uintptr, file uintptr, fa uintptr, attr uintptr, argv uintptr, envp uintptr) (r int32) {
	bp := tls.Alloc(336) /* tlsAllocs 336 maxValist 0 */
	defer tls.Free(336)
	var _ /* spawnp_attr at bp+0 */ Tposix_spawnattr_t
	*(*Tposix_spawnattr_t)(unsafe.Pointer(bp)) = Tposix_spawnattr_t{}
	if attr != 0 {
		*(*Tposix_spawnattr_t)(unsafe.Pointer(bp)) = *(*Tposix_spawnattr_t)(unsafe.Pointer(attr))
	}
	(*(*Tposix_spawnattr_t)(unsafe.Pointer(bp))).F__fn = __ccgo_fp(x___execvpe)
	return x_posix_spawn(tls, res, file, fa, bp, argv, envp)
}

func x_system(tls *TLS, cmd uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2436, int32(14), uintptr(unsafe.Pointer(&___func__37)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__37 = [7]int8{'s', 'y', 's', 't', 'e', 'm'}

func x_wait(tls *TLS, status uintptr) (r Tpid_t) {
	return x_waitpid(tls, -Int32FromInt32(1), status, int32(0))
}

func x_waitid(tls *TLS, type1 Tidtype_t, id Tid_t, info uintptr, options int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(247), int64(type1), int64(id), int64(info), int64(options), int64(Int32FromInt32(0)), int64(0)))))
}

func x_waitpid(tls *TLS, pid Tpid_t, status uintptr, options int32) (r Tpid_t) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(61), int64(pid), int64(status), int64(options), int64(Int32FromInt32(0)), int64(0), int64(0)))))
}

const m_END = 0
const m_FNM_CASEFOLD = 16
const m_FNM_LEADING_DIR = 8
const m_FNM_NOESCAPE = 2
const m_FNM_NOMATCH = 1
const m_FNM_PATHNAME = 1
const m_FNM_PERIOD = 4

func _str_next(tls *TLS, str uintptr, n Tsize_t, step uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var k int32
	var _ /* wc at bp+0 */ Twchar_t
	if !(n != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
		return int32(0)
	}
	if uint32(*(*int8)(unsafe.Pointer(str + UintptrFromInt32(0)))) >= uint32(128) {
		k = x_mbtowc(tls, bp, str, n)
		if k < int32(0) {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
			return -int32(1)
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(k)
		return *(*Twchar_t)(unsafe.Pointer(bp))
	}
	*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
	return int32(*(*int8)(unsafe.Pointer(str + UintptrFromInt32(0))))
}

func _pat_next(tls *TLS, pat uintptr, m Tsize_t, step uintptr, flags int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var esc int32
	var k Tsize_t
	var k1 int32
	var z int32
	var _ /* wc at bp+0 */ Twchar_t
	esc = int32(0)
	if !(m != 0) || !(*(*int8)(unsafe.Pointer(pat)) != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
		return int32(m_END)
	}
	*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
	if int32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0)))) == int32('\\') && *(*int8)(unsafe.Pointer(pat + UintptrFromInt32(1))) != 0 && !(flags&Int32FromInt32(m_FNM_NOESCAPE) != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(2)
		pat++
		esc = int32(1)
		goto escaped
	}
	if int32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0)))) == int32('[') {
		k = uint64(1)
		if k < m {
			if int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) == int32('^') || int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) == int32('!') {
				k++
			}
		}
		if k < m {
			if int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) == int32(']') {
				k++
			}
		}
		for ; k < m && *(*int8)(unsafe.Pointer(pat + uintptr(k))) != 0 && int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) != int32(']'); k++ {
			if k+uint64(1) < m && *(*int8)(unsafe.Pointer(pat + uintptr(k+Uint64FromInt32(1)))) != 0 && int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) == int32('[') && (int32(*(*int8)(unsafe.Pointer(pat + uintptr(k+Uint64FromInt32(1))))) == int32(':') || int32(*(*int8)(unsafe.Pointer(pat + uintptr(k+Uint64FromInt32(1))))) == int32('.') || int32(*(*int8)(unsafe.Pointer(pat + uintptr(k+Uint64FromInt32(1))))) == int32('=')) {
				z = int32(*(*int8)(unsafe.Pointer(pat + uintptr(k+Uint64FromInt32(1)))))
				k = k + Uint64FromInt32(2)
				if k < m && *(*int8)(unsafe.Pointer(pat + uintptr(k))) != 0 {
					k++
				}
				for k < m && *(*int8)(unsafe.Pointer(pat + uintptr(k))) != 0 && (int32(*(*int8)(unsafe.Pointer(pat + uintptr(k-Uint64FromInt32(1))))) != z || int32(*(*int8)(unsafe.Pointer(pat + uintptr(k)))) != int32(']')) {
					k++
				}
				if k == m || !(*(*int8)(unsafe.Pointer(pat + uintptr(k))) != 0) {
					break
				}
			}
		}
		if k == m || !(*(*int8)(unsafe.Pointer(pat + uintptr(k))) != 0) {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
			return int32('[')
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = k + uint64(1)
		return -int32(3)
	}
	if int32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0)))) == int32('*') {
		return -int32(5)
	}
	if int32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0)))) == int32('?') {
		return -int32(4)
	}
escaped:
	if uint32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0)))) >= uint32(128) {
		k1 = x_mbtowc(tls, bp, pat, m)
		if k1 < int32(0) {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
			return -int32(2)
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(k1 + esc)
		return *(*Twchar_t)(unsafe.Pointer(bp))
	}
	return int32(*(*int8)(unsafe.Pointer(pat + UintptrFromInt32(0))))
}

func _casefold(tls *TLS, k int32) (r int32) {
	var c int32
	var v1 uint32
	c = int32(x_towupper(tls, uint32(k)))
	if c == k {
		v1 = x_towlower(tls, uint32(k))
	} else {
		v1 = uint32(c)
	}
	return int32(v1)
}

func _match_bracket(tls *TLS, p uintptr, k int32, kfold int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var inv int32
	var l int32
	var l1 int32
	var p0 uintptr
	var z int32
	var _ /* buf at bp+8 */ [16]int8
	var _ /* wc at bp+0 */ Twchar_t
	var _ /* wc2 at bp+4 */ Twchar_t
	inv = int32(0)
	p++
	if int32(*(*int8)(unsafe.Pointer(p))) == int32('^') || int32(*(*int8)(unsafe.Pointer(p))) == int32('!') {
		inv = int32(1)
		p++
	}
	if int32(*(*int8)(unsafe.Pointer(p))) == int32(']') {
		if k == int32(']') {
			return BoolInt32(!(inv != 0))
		}
		p++
	} else {
		if int32(*(*int8)(unsafe.Pointer(p))) == int32('-') {
			if k == int32('-') {
				return BoolInt32(!(inv != 0))
			}
			p++
		}
	}
	*(*Twchar_t)(unsafe.Pointer(bp)) = int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))
	for ; int32(*(*int8)(unsafe.Pointer(p))) != int32(']'); p++ {
		if int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(0)))) == int32('-') && int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(1)))) != int32(']') {
			l = x_mbtowc(tls, bp+4, p+uintptr(1), uint64(4))
			if l < int32(0) {
				return int32(0)
			}
			if *(*Twchar_t)(unsafe.Pointer(bp)) <= *(*Twchar_t)(unsafe.Pointer(bp + 4)) {
				if uint32(k)-uint32(*(*Twchar_t)(unsafe.Pointer(bp))) <= uint32(*(*Twchar_t)(unsafe.Pointer(bp + 4))-*(*Twchar_t)(unsafe.Pointer(bp))) || uint32(kfold)-uint32(*(*Twchar_t)(unsafe.Pointer(bp))) <= uint32(*(*Twchar_t)(unsafe.Pointer(bp + 4))-*(*Twchar_t)(unsafe.Pointer(bp))) {
					return BoolInt32(!(inv != 0))
				}
			}
			p = p + uintptr(l-Int32FromInt32(1))
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(0)))) == int32('[') && (int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(1)))) == int32(':') || int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(1)))) == int32('.') || int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(1)))) == int32('=')) {
			p0 = p + uintptr(2)
			z = int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(1))))
			p = p + UintptrFromInt32(3)
			for int32(*(*int8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))))) != z || int32(*(*int8)(unsafe.Pointer(p + UintptrFromInt32(0)))) != int32(']') {
				p++
			}
			if z == int32(':') && int64(p-uintptr(1))-int64(p0) < int64(16) {
				x_memcpy(tls, bp+8, p0, uint64(int64(p-uintptr(1))-int64(p0)))
				(*(*[16]int8)(unsafe.Pointer(bp + 8)))[int64(p-uintptr(1))-int64(p0)] = int8(0)
				if x_iswctype(tls, uint32(k), x_wctype(tls, bp+8)) != 0 || x_iswctype(tls, uint32(kfold), x_wctype(tls, bp+8)) != 0 {
					return BoolInt32(!(inv != 0))
				}
			}
			continue
		}
		if uint32(*(*int8)(unsafe.Pointer(p))) < uint32(128) {
			*(*Twchar_t)(unsafe.Pointer(bp)) = int32(uint8(*(*int8)(unsafe.Pointer(p))))
		} else {
			l1 = x_mbtowc(tls, bp, p, uint64(4))
			if l1 < int32(0) {
				return int32(0)
			}
			p = p + uintptr(l1-Int32FromInt32(1))
		}
		if *(*Twchar_t)(unsafe.Pointer(bp)) == k || *(*Twchar_t)(unsafe.Pointer(bp)) == kfold {
			return BoolInt32(!(inv != 0))
		}
	}
	return inv
}

func _fnmatch_internal(tls *TLS, pat uintptr, m Tsize_t, str uintptr, n Tsize_t, flags int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var c int32
	var endpat uintptr
	var endstr uintptr
	var k int32
	var kfold int32
	var p uintptr
	var ptail uintptr
	var s uintptr
	var stail uintptr
	var tailcnt Tsize_t
	var _ /* pinc at bp+0 */ Tsize_t
	var _ /* sinc at bp+8 */ Tsize_t
	var v1 int32
	var v10 int32
	var v11 int32
	var v2 int32
	var v3 int32
	var v4 uintptr
	var v6 int32
	var v7 bool
	var v8 uintptr
	var v9 int32
	tailcnt = uint64(0)
	if flags&int32(m_FNM_PERIOD) != 0 {
		if int32(*(*int8)(unsafe.Pointer(str))) == int32('.') && int32(*(*int8)(unsafe.Pointer(pat))) != int32('.') {
			return int32(m_FNM_NOMATCH)
		}
	}
	for {
		v1 = _pat_next(tls, pat, m, bp, flags)
		c = v1
		switch v1 {
		case -int32(2):
			return int32(m_FNM_NOMATCH)
		case -int32(5):
			pat++
			m--
		default:
			k = _str_next(tls, str, n, bp+8)
			if k <= int32(0) {
				if c == int32(m_END) {
					v2 = int32(0)
				} else {
					v2 = int32(m_FNM_NOMATCH)
				}
				return v2
			}
			str = str + uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
			n = n - *(*Tsize_t)(unsafe.Pointer(bp + 8))
			if flags&int32(m_FNM_CASEFOLD) != 0 {
				v3 = _casefold(tls, k)
			} else {
				v3 = k
			}
			kfold = v3
			if c == -int32(3) {
				if !(_match_bracket(tls, pat, k, kfold) != 0) {
					return int32(m_FNM_NOMATCH)
				}
			} else {
				if c != -int32(4) && k != c && kfold != c {
					return int32(m_FNM_NOMATCH)
				}
			}
			pat = pat + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			m = m - *(*Tsize_t)(unsafe.Pointer(bp))
			continue
		}
		break
	}
	/* Compute real pat length if it was initially unknown/-1 */
	m = x_strnlen(tls, pat, m)
	endpat = pat + uintptr(m)
	/* Find the last * in pat and count chars needed after it */
	v4 = pat
	ptail = v4
	p = v4
	for p < endpat {
		switch _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags) {
		case -int32(2):
			return int32(m_FNM_NOMATCH)
		case -int32(5):
			tailcnt = uint64(0)
			ptail = p + uintptr(1)
		default:
			tailcnt++
			break
		}
		goto _5
	_5:
		p = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
	}
	/* Past this point we need not check for UNMATCHABLE in pat,
	 * because all of pat has already been parsed once. */
	/* Compute real str length if it was initially unknown/-1 */
	n = x_strnlen(tls, str, n)
	endstr = str + uintptr(n)
	if n < tailcnt {
		return int32(m_FNM_NOMATCH)
	}
	/* Find the final tailcnt chars of str, accounting for UTF-8.
	 * On illegal sequences we may get it wrong, but in that case
	 * we necessarily have a matching failure anyway. */
	for s = endstr; s > str && tailcnt != 0; tailcnt-- {
		if v7 = uint32(*(*int8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1))))) < uint32(128); !v7 {
			if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
				v6 = int32(4)
			} else {
				v6 = int32(1)
			}
		}
		if v7 || v6 == int32(1) {
			s--
		} else {
			for {
				s--
				v8 = s
				if !(uint32(uint8(*(*int8)(unsafe.Pointer(v8))))-uint32(0x80) < uint32(0x40) && s > str) {
					break
				}
			}
		}
	}
	if tailcnt != 0 {
		return int32(m_FNM_NOMATCH)
	}
	stail = s
	/* Check that the pat and str tails match */
	p = ptail
	for {
		c = _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags)
		p = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
		v9 = _str_next(tls, s, uint64(int64(endstr)-int64(s)), bp+8)
		k = v9
		if v9 <= int32(0) {
			if c != int32(m_END) {
				return int32(m_FNM_NOMATCH)
			}
			break
		}
		s = s + uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
		if flags&int32(m_FNM_CASEFOLD) != 0 {
			v10 = _casefold(tls, k)
		} else {
			v10 = k
		}
		kfold = v10
		if c == -int32(3) {
			if !(_match_bracket(tls, p-uintptr(*(*Tsize_t)(unsafe.Pointer(bp))), k, kfold) != 0) {
				return int32(m_FNM_NOMATCH)
			}
		} else {
			if c != -int32(4) && k != c && kfold != c {
				return int32(m_FNM_NOMATCH)
			}
		}
	}
	/* We're all done with the tails now, so throw them out */
	endstr = stail
	endpat = ptail
	/* Match pattern components until there are none left */
	for pat < endpat {
		p = pat
		s = str
		for {
			c = _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags)
			p = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			/* Encountering * completes/commits a component */
			if c == -int32(5) {
				pat = p
				str = s
				break
			}
			k = _str_next(tls, s, uint64(int64(endstr)-int64(s)), bp+8)
			if !(k != 0) {
				return int32(m_FNM_NOMATCH)
			}
			if flags&int32(m_FNM_CASEFOLD) != 0 {
				v11 = _casefold(tls, k)
			} else {
				v11 = k
			}
			kfold = v11
			if c == -int32(3) {
				if !(_match_bracket(tls, p-uintptr(*(*Tsize_t)(unsafe.Pointer(bp))), k, kfold) != 0) {
					break
				}
			} else {
				if c != -int32(4) && k != c && kfold != c {
					break
				}
			}
			s = s + uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
		}
		if c == -int32(5) {
			continue
		}
		/* If we failed, advance str, by 1 char if it's a valid
		 * char, or past all invalid bytes otherwise. */
		k = _str_next(tls, str, uint64(int64(endstr)-int64(str)), bp+8)
		if k > int32(0) {
			str = str + uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
		} else {
			for str++; _str_next(tls, str, uint64(int64(endstr)-int64(str)), bp+8) < int32(0); str++ {
			}
		}
	}
	return int32(0)
}

func x_fnmatch(tls *TLS, pat uintptr, str uintptr, flags int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c int32
	var p uintptr
	var s uintptr
	var _ /* inc at bp+0 */ Tsize_t
	var v1 int32
	if flags&int32(m_FNM_PATHNAME) != 0 {
		for {
			for s = str; *(*int8)(unsafe.Pointer(s)) != 0 && int32(*(*int8)(unsafe.Pointer(s))) != int32('/'); s++ {
			}
			for p = pat; ; {
				v1 = _pat_next(tls, p, uint64(-Int32FromInt32(1)), bp, flags)
				c = v1
				if !(v1 != int32(m_END) && c != int32('/')) {
					break
				}
				goto _2
			_2:
				p = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			}
			if c != int32(*(*int8)(unsafe.Pointer(s))) && (!(*(*int8)(unsafe.Pointer(s)) != 0) || !(flags&Int32FromInt32(m_FNM_LEADING_DIR) != 0)) {
				return int32(m_FNM_NOMATCH)
			}
			if _fnmatch_internal(tls, pat, uint64(int64(p)-int64(pat)), str, uint64(int64(s)-int64(str)), flags) != 0 {
				return int32(m_FNM_NOMATCH)
			}
			if !(c != 0) {
				return int32(0)
			}
			str = s + uintptr(1)
			pat = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
		}
	} else {
		if flags&int32(m_FNM_LEADING_DIR) != 0 {
			for s = str; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
				if int32(*(*int8)(unsafe.Pointer(s))) != int32('/') {
					continue
				}
				if !(_fnmatch_internal(tls, pat, uint64(-Int32FromInt32(1)), str, uint64(int64(s)-int64(str)), flags) != 0) {
					return int32(0)
				}
			}
		}
	}
	return _fnmatch_internal(tls, pat, uint64(-Int32FromInt32(1)), str, uint64(-Int32FromInt32(1)), flags)
}

type Tglob_t = struct {
	Fgl_pathc Tsize_t
	Fgl_pathv uintptr
	Fgl_offs  Tsize_t
	F__dummy1 int32
	F__dummy2 [5]uintptr
}

type Tmatch = struct {
	Fnext uintptr
}

func x_glob(tls *TLS, pat uintptr, flags int32, errfunc uintptr, g uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2457, int32(23), uintptr(unsafe.Pointer(&___func__38)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__38 = [5]int8{'g', 'l', 'o', 'b'}

func x_globfree(tls *TLS, g uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+2457, int32(28), uintptr(unsafe.Pointer(&___func__39)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__39 = [9]int8{'g', 'l', 'o', 'b', 'f', 'r', 'e', 'e'}

const m_ASSERT_AT_BOL = 1
const m_ASSERT_AT_BOW = 16
const m_ASSERT_AT_EOL = 2
const m_ASSERT_AT_EOW = 32
const m_ASSERT_AT_WB = 64
const m_ASSERT_AT_WB_NEG = 128
const m_ASSERT_BACKREF = 256
const m_ASSERT_CHAR_CLASS = 4
const m_ASSERT_CHAR_CLASS_NEG = 8
const m_CHARCLASS_NAME_MAX = 14
const m_COPY_MAXIMIZE_FIRST_TAG = 2
const m_COPY_REMOVE_TAGS = 1
const m_MAX_NEG_CLASSES = 64
const m_REG_BADBR = 10
const m_REG_BADPAT = 2
const m_REG_BADRPT = 13
const m_REG_EBRACE = 9
const m_REG_EBRACK = 7
const m_REG_ECOLLATE = 3
const m_REG_ECTYPE = 4
const m_REG_EESCAPE = 5
const m_REG_EPAREN = 8
const m_REG_ERANGE = 11
const m_REG_ESPACE = 12
const m_REG_EXTENDED = 1
const m_REG_ICASE = 2
const m_REG_NEWLINE = 4
const m_REG_NOSUB = 8
const m_REG_OK = 0
const m_TRE_CHAR_MAX = 1114111
const m_tre_mem_alloc_impl = 0
const m_tre_mem_new_impl = 0

type Tregoff_t = int64

type Tregex_t = struct {
	Fre_nsub     Tsize_t
	F__opaque    uintptr
	F__padding   [4]uintptr
	F__nsub2     Tsize_t
	F__padding2  int8
	F__ccgo_pad5 [7]byte
}

type Tre_pattern_buffer = Tregex_t

type Tregmatch_t = struct {
	Frm_so Tregoff_t
	Frm_eo Tregoff_t
}

type Treg_errcode_t = int32

type Ttre_char_t = int32

type Ttre_cint_t = uint32

type Ttre_ctype_t = uint64

type Ttre_tnfa_transition_t = struct {
	Fcode_min   Ttre_cint_t
	Fcode_max   Ttre_cint_t
	Fstate      uintptr
	Fstate_id   int32
	Ftags       uintptr
	Fassertions int32
	Fu          struct {
		Fbackref [0]int32
		Fclass   Ttre_ctype_t
	}
	Fneg_classes uintptr
}

type Ttnfa_transition = Ttre_tnfa_transition_t

type Ttre_tag_direction_t = int32

const _TRE_TAG_MINIMIZE = 0
const _TRE_TAG_MAXIMIZE = 1

type Ttre_submatch_data = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_submatch_data_t = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_tnfa_t = struct {
	Ftransitions     uintptr
	Fnum_transitions uint32
	Finitial         uintptr
	Ffinal           uintptr
	Fsubmatch_data   uintptr
	Ffirstpos_chars  uintptr
	Ffirst_char      int32
	Fnum_submatches  uint32
	Ftag_directions  uintptr
	Fminimal_tags    uintptr
	Fnum_tags        int32
	Fnum_minimals    int32
	Fend_tag         int32
	Fnum_states      int32
	Fcflags          int32
	Fhave_backrefs   int32
	Fhave_approx     int32
}

type Ttnfa = Ttre_tnfa_t

type Ttre_list_t = struct {
	Fdata uintptr
	Fnext uintptr
}

type Ttre_list = Ttre_list_t

type Ttre_mem_t = uintptr

type Ttre_mem_struct = struct {
	Fblocks   uintptr
	Fcurrent  uintptr
	Fptr      uintptr
	Fn        Tsize_t
	Ffailed   int32
	Fprovided uintptr
}

/***********************************************************************
 from tre-compile.h
***********************************************************************/

type Ttre_pos_and_tags_t = struct {
	Fposition    int32
	Fcode_min    int32
	Fcode_max    int32
	Ftags        uintptr
	Fassertions  int32
	Fclass       Ttre_ctype_t
	Fneg_classes uintptr
	Fbackref     int32
	F__ccgo_pad8 [4]byte
}

/***********************************************************************
 from tre-ast.c and tre-ast.h
***********************************************************************/

/* The different AST node types. */

type Ttre_ast_type_t = int32

const _LITERAL = 0
const _CATENATION = 1
const _ITERATION = 2
const _UNION = 3

/* Special subtypes of TRE_LITERAL. */

/* A generic AST node.  All AST nodes consist of this node on the top
   level with `obj' pointing to the actual content. */

type Ttre_ast_node_t = struct {
	Ftype1          Ttre_ast_type_t
	Fobj            uintptr
	Fnullable       int32
	Fsubmatch_id    int32
	Fnum_submatches int32
	Fnum_tags       int32
	Ffirstpos       uintptr
	Flastpos        uintptr
}

/* A "literal" node.  These are created for assertions, back references,
   tags, matching parameter settings, and all expressions that match one
   character. */

type Ttre_literal_t = struct {
	Fcode_min    int64
	Fcode_max    int64
	Fposition    int32
	Fclass       Ttre_ctype_t
	Fneg_classes uintptr
}

/* A "catenation" node.	 These are created when two regexps are concatenated.
   If there are more than one subexpressions in sequence, the `left' part
   holds all but the last, and `right' part holds the last subexpression
   (catenation is left associative). */

type Ttre_catenation_t = struct {
	Fleft  uintptr
	Fright uintptr
}

/* An "iteration" node.	 These are created for the "*", "+", "?", and "{m,n}"
   operators. */

type Ttre_iteration_t = struct {
	Farg         uintptr
	Fmin         int32
	Fmax         int32
	F__ccgo16    uint8
	F__ccgo_pad4 [7]byte
}

/* An "union" node.  These are created for the "|" operator. */

type Ttre_union_t = struct {
	Fleft  uintptr
	Fright uintptr
}

func _tre_ast_new_node(tls *TLS, mem Ttre_mem_t, type1 int32, obj uintptr) (r uintptr) {
	var node uintptr
	node = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(48))
	if !(node != 0) || !(obj != 0) {
		return uintptr(0)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = obj
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = type1
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id = -int32(1)
	return node
}

func _tre_ast_new_literal(tls *TLS, mem Ttre_mem_t, code_min int32, code_max int32, position int32) (r uintptr) {
	var lit uintptr
	var node uintptr
	lit = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(40))
	node = _tre_ast_new_node(tls, mem, int32(_LITERAL), lit)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(code_min)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(code_max)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = position
	return node
}

func _tre_ast_new_iter(tls *TLS, mem Ttre_mem_t, arg uintptr, min int32, max int32, minimal int32) (r uintptr) {
	var iter uintptr
	var node uintptr
	iter = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(24))
	node = _tre_ast_new_node(tls, mem, int32(_ITERATION), iter)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg = arg
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin = min
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax = max
	SetBitFieldPtr8Uint32(iter+16, uint32(minimal), 0, 0x1)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(arg)).Fnum_submatches
	return node
}

func _tre_ast_new_union(tls *TLS, mem Ttre_mem_t, left uintptr, right uintptr) (r uintptr) {
	var node uintptr
	var un uintptr
	if !(left != 0) {
		return right
	}
	un = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(16))
	node = _tre_ast_new_node(tls, mem, int32(_UNION), un)
	if !(node != 0) || !(right != 0) {
		return uintptr(0)
	}
	(*Ttre_union_t)(unsafe.Pointer(un)).Fleft = left
	(*Ttre_union_t)(unsafe.Pointer(un)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

func _tre_ast_new_catenation(tls *TLS, mem Ttre_mem_t, left uintptr, right uintptr) (r uintptr) {
	var cat uintptr
	var node uintptr
	if !(left != 0) {
		return right
	}
	cat = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(16))
	node = _tre_ast_new_node(tls, mem, int32(_CATENATION), cat)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft = left
	(*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

/***********************************************************************
 from tre-stack.c and tre-stack.h
***********************************************************************/

type Ttre_stack_t = struct {
	Fsize      int32
	Fmax_size  int32
	Fincrement int32
	Fptr       int32
	Fstack     uintptr
}

type Ttre_stack_rec = Ttre_stack_t

/* Creates a new stack object.	`size' is initial size in bytes, `max_size'
   is maximum size, and `increment' specifies how much more space will be
   allocated with realloc() if all space gets used up.	Returns the stack
   object or NULL if out of memory. */

/* Frees the stack object. */

/* Returns the current number of objects in the stack. */

/* Each tre_stack_push_*(tre_stack_t *s, <type> value) function pushes
   `value' on top of stack `s'.  Returns REG_ESPACE if out of memory.
   This tries to realloc() more space before failing if maximum size
   has not yet been reached.  Returns REG_OK if successful. */

/* Each tre_stack_pop_*(tre_stack_t *s) function pops the topmost
   element off of stack `s' and returns it.  The stack must not be
   empty. */

/* Just to save some typing. */

type Ttre_stack_item = struct {
	Fint_value     [0]int32
	Fvoidptr_value uintptr
}

func _tre_stack_new(tls *TLS, size int32, max_size int32, increment int32) (r uintptr) {
	var s uintptr
	s = _default_malloc(tls, uint64(24))
	if s != UintptrFromInt32(0) {
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = _default_malloc(tls, uint64(8)*uint64(size))
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack == UintptrFromInt32(0) {
			x_free(tls, s)
			return UintptrFromInt32(0)
		}
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size = max_size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement = increment
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr = int32(0)
	}
	return s
}

func _tre_stack_destroy(tls *TLS, s uintptr) {
	x_free(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack)
	x_free(tls, s)
}

func _tre_stack_num_objects(tls *TLS, s uintptr) (r int32) {
	return (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr
}

func _tre_stack_push(tls *TLS, s uintptr, value Ttre_stack_item) (r Treg_errcode_t) {
	var new_buffer uintptr
	var new_size int32
	var v1 bool
	if (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr < (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize {
		*(*Ttre_stack_item)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr((*Ttre_stack_t)(unsafe.Pointer(s)).Fptr)*8)) = value
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr++
	} else {
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize >= (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
			return int32(m_REG_ESPACE)
		} else {
			new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize + (*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement
			if new_size > (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
				new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size
			}
			new_buffer = x_realloc(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack, uint64(8)*uint64(new_size))
			if new_buffer == UintptrFromInt32(0) {
				return int32(m_REG_ESPACE)
			}
			if v1 = new_size > (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize; !v1 {
				___assert_fail(tls, ts+2474, ts+2493, int32(362), uintptr(unsafe.Pointer(&___func__40)))
			}
			_ = v1 || Int32FromInt32(0) != 0
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = new_size
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = new_buffer
			_tre_stack_push(tls, s, value)
		}
	}
	return int32(m_REG_OK)
}

var ___func__40 = [15]int8{'t', 'r', 'e', '_', 's', 't', 'a', 'c', 'k', '_', 'p', 'u', 's', 'h'}

func _tre_stack_push_int(tls *TLS, s uintptr, value int32) (r Treg_errcode_t) {
	var item Ttre_stack_item
	*(*int32)(unsafe.Pointer(&item)) = value
	return _tre_stack_push(tls, s, item)
}

func _tre_stack_push_voidptr(tls *TLS, s uintptr, value uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* item at bp+0 */ Ttre_stack_item
	*(*uintptr)(unsafe.Pointer(bp)) = value
	return _tre_stack_push(tls, s, *(*Ttre_stack_item)(unsafe.Pointer(bp)))
}

func _tre_stack_pop_int(tls *TLS, s uintptr) (r int32) {
	var v1 int32
	var v2 uintptr
	v2 = s + 12
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	return *(*int32)(unsafe.Pointer(&*(*Ttre_stack_item)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr(v1)*8))))
}

func _tre_stack_pop_voidptr(tls *TLS, s uintptr) (r uintptr) {
	var v1 int32
	var v2 uintptr
	v2 = s + 12
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	return *(*uintptr)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr(v1)*8))
}

/***********************************************************************
 from tre-parse.c and tre-parse.h
***********************************************************************/

/* Parse context. */

type Ttre_parse_ctx_t = struct {
	Fmem         Ttre_mem_t
	Fstack       uintptr
	Fn           uintptr
	Fs           uintptr
	Fstart       uintptr
	Fsubmatch_id int32
	Fposition    int32
	Fmax_backref int32
	Fcflags      int32
}

/* Some macros for expanding \w, \s, etc. */
var _tre_macros = [13]struct {
	Fc         int8
	Fexpansion uintptr
}{
	0:  {Fc: int8('t'), Fexpansion: ts + 2513},
	1:  {Fc: int8('n'), Fexpansion: ts + 572},
	2:  {Fc: int8('r'), Fexpansion: ts + 2515},
	3:  {Fc: int8('f'), Fexpansion: ts + 2517},
	4:  {Fc: int8('a'), Fexpansion: ts + 2519},
	5:  {Fc: int8('e'), Fexpansion: ts + 2521},
	6:  {Fc: int8('w'), Fexpansion: ts + 2523},
	7:  {Fc: int8('W'), Fexpansion: ts + 2536},
	8:  {Fc: int8('s'), Fexpansion: ts + 2550},
	9:  {Fc: int8('S'), Fexpansion: ts + 2562},
	10: {Fc: int8('d'), Fexpansion: ts + 2575},
	11: {Fc: int8('D'), Fexpansion: ts + 2587},
	12: {}}

// C documentation
//
//	/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
//	   must have at least `len' items.  Sets buf[0] to zero if the there
//	   is no match in `tre_macros'. */
func _tre_expand_macro(tls *TLS, s uintptr) (r uintptr) {
	var i int32
	for i = int32(0); _tre_macros[i].Fc != 0 && int32(_tre_macros[i].Fc) != int32(*(*int8)(unsafe.Pointer(s))); i++ {
	}
	return _tre_macros[i].Fexpansion
}

func _tre_compare_lit(tls *TLS, a uintptr, b uintptr) (r int32) {
	var la uintptr
	var lb uintptr
	la = a
	lb = b
	/* assumes the range of valid code_min is < INT_MAX */
	return int32((*Ttre_literal_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(la + UintptrFromInt32(0)*8)))).Fcode_min - (*Ttre_literal_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lb + UintptrFromInt32(0)*8)))).Fcode_min)
}

type Tliterals = struct {
	Fmem  Ttre_mem_t
	Fa    uintptr
	Flen1 int32
	Fcap1 int32
}

func _tre_new_lit(tls *TLS, p uintptr) (r uintptr) {
	var a uintptr
	var v2 int32
	var v3 uintptr
	var p1 uintptr
	if (*Tliterals)(unsafe.Pointer(p)).Flen1 >= (*Tliterals)(unsafe.Pointer(p)).Fcap1 {
		if (*Tliterals)(unsafe.Pointer(p)).Fcap1 >= Int32FromInt32(1)<<Int32FromInt32(15) {
			return uintptr(0)
		}
		p1 = p + 20
		*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) * Int32FromInt32(2)
		a = x_realloc(tls, (*Tliterals)(unsafe.Pointer(p)).Fa, uint64((*Tliterals)(unsafe.Pointer(p)).Fcap1)*uint64(8))
		if !(a != 0) {
			return uintptr(0)
		}
		(*Tliterals)(unsafe.Pointer(p)).Fa = a
	}
	v3 = p + 16
	v2 = *(*int32)(unsafe.Pointer(v3))
	*(*int32)(unsafe.Pointer(v3))++
	a = (*Tliterals)(unsafe.Pointer(p)).Fa + uintptr(v2)*8
	*(*uintptr)(unsafe.Pointer(a)) = x___tre_mem_alloc_impl(tls, (*Tliterals)(unsafe.Pointer(p)).Fmem, int32(0), UintptrFromInt32(0), int32(1), uint64(40))
	return *(*uintptr)(unsafe.Pointer(a))
}

func _add_icase_literals(tls *TLS, ls uintptr, min int32, max int32) (r int32) {
	var b int32
	var c int32
	var e int32
	var lit uintptr
	var v1 int32
	var v3 int32
	for c = min; c <= max; {
		/* assumes islower(c) and isupper(c) are exclusive
		   and toupper(c)!=c if islower(c).
		   multiple opposite case characters are not supported */
		if x_iswlower(tls, uint32(c)) != 0 {
			v1 = int32(x_towupper(tls, uint32(c)))
			e = v1
			b = v1
			c++
			e++
			for c <= max {
				if x_towupper(tls, uint32(c)) != uint32(e) {
					break
				}
				goto _2
			_2:
				c++
				e++
			}
		} else {
			if x_iswupper(tls, uint32(c)) != 0 {
				v3 = int32(x_towlower(tls, uint32(c)))
				e = v3
				b = v3
				c++
				e++
				for c <= max {
					if x_towlower(tls, uint32(c)) != uint32(e) {
						break
					}
					goto _4
				_4:
					c++
					e++
				}
			} else {
				c++
				continue
			}
		}
		lit = _tre_new_lit(tls, ls)
		if !(lit != 0) {
			return -int32(1)
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(b)
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(e - int32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
	}
	return int32(0)
}

/* Maximum number of character classes in a negated bracket expression. */

type Tneg = struct {
	Fnegate int32
	Flen1   int32
	Fa      [64]Ttre_ctype_t
}

func _parse_bracket_terms(tls *TLS, ctx uintptr, s uintptr, ls uintptr, neg uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var class Ttre_ctype_t
	var len1 int32
	var lit uintptr
	var max int32
	var min int32
	var start uintptr
	var _ /* tmp at bp+4 */ [15]int8
	var _ /* wc at bp+0 */ Twchar_t
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 uintptr
	start = s
	for {
		class = uint64(0)
		len1 = x_mbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
		if len1 <= int32(0) {
			if *(*int8)(unsafe.Pointer(s)) != 0 {
				v1 = int32(m_REG_BADPAT)
			} else {
				v1 = int32(m_REG_EBRACK)
			}
			return v1
		}
		if int32(*(*int8)(unsafe.Pointer(s))) == int32(']') && s != start {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s + uintptr(1)
			return int32(m_REG_OK)
		}
		if int32(*(*int8)(unsafe.Pointer(s))) == int32('-') && s != start && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32(']') && (int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32('-') || int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(2)))) == int32(']')) {
			return int32(m_REG_ERANGE)
		}
		if int32(*(*int8)(unsafe.Pointer(s))) == int32('[') && (int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32('.') || int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32('=')) {
			/* collating symbols and equivalence classes are not supported */
			return int32(m_REG_ECOLLATE)
		}
		if int32(*(*int8)(unsafe.Pointer(s))) == int32('[') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32(':') {
			s = s + UintptrFromInt32(2)
			for len1 = int32(0); len1 < int32(m_CHARCLASS_NAME_MAX) && *(*int8)(unsafe.Pointer(s + uintptr(len1))) != 0; len1++ {
				if int32(*(*int8)(unsafe.Pointer(s + uintptr(len1)))) == int32(':') {
					x_memcpy(tls, bp+4, s, uint64(len1))
					(*(*[15]int8)(unsafe.Pointer(bp + 4)))[len1] = int8(0)
					class = x_wctype(tls, bp+4)
					break
				}
			}
			if !(class != 0) || int32(*(*int8)(unsafe.Pointer(s + uintptr(len1+Int32FromInt32(1))))) != int32(']') {
				return int32(m_REG_ECTYPE)
			}
			min = int32(0)
			max = int32(m_TRE_CHAR_MAX)
			s = s + uintptr(len1+Int32FromInt32(2))
		} else {
			v2 = *(*Twchar_t)(unsafe.Pointer(bp))
			max = v2
			min = v2
			s = s + uintptr(len1)
			if int32(*(*int8)(unsafe.Pointer(s))) == int32('-') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32(']') {
				s++
				len1 = x_mbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
				max = *(*Twchar_t)(unsafe.Pointer(bp))
				/* XXX - Should use collation order instead of
				   encoding values in character ranges. */
				if len1 <= int32(0) || min > max {
					return int32(m_REG_ERANGE)
				}
				s = s + uintptr(len1)
			}
		}
		if class != 0 && (*Tneg)(unsafe.Pointer(neg)).Fnegate != 0 {
			if (*Tneg)(unsafe.Pointer(neg)).Flen1 >= int32(m_MAX_NEG_CLASSES) {
				return int32(m_REG_ESPACE)
			}
			v4 = neg + 4
			v3 = *(*int32)(unsafe.Pointer(v4))
			*(*int32)(unsafe.Pointer(v4))++
			*(*Ttre_ctype_t)(unsafe.Pointer(neg + 8 + uintptr(v3)*8)) = class
		} else {
			lit = _tre_new_lit(tls, ls)
			if !(lit != 0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(min)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(max)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass = class
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
			/* Add opposite-case codepoints if REG_ICASE is present.
			   It seems that POSIX requires that bracket negation
			   should happen before case-folding, but most practical
			   implementations do it the other way around. Changing
			   the order would need efficient representation of
			   case-fold ranges and bracket range sets even with
			   simple patterns so this is ok for now. */
			if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_ICASE) != 0 && !(class != 0) {
				if _add_icase_literals(tls, ls, min, max) != 0 {
					return int32(m_REG_ESPACE)
				}
			}
		}
	}
	return r
}

func _parse_bracket(tls *TLS, ctx uintptr, s uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(544) /* tlsAllocs 544 maxValist 0 */
	defer tls.Free(544)
	var err Treg_errcode_t
	var i int32
	var lit uintptr
	var max int32
	var min int32
	var n uintptr
	var nc uintptr
	var negmax int32
	var negmin int32
	var node uintptr
	var _ /* ls at bp+0 */ Tliterals
	var _ /* neg at bp+24 */ Tneg
	var v1 int32
	var v2 int32
	node = uintptr(0)
	nc = uintptr(0)
	(*(*Tliterals)(unsafe.Pointer(bp))).Fmem = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem
	(*(*Tliterals)(unsafe.Pointer(bp))).Flen1 = int32(0)
	(*(*Tliterals)(unsafe.Pointer(bp))).Fcap1 = int32(32)
	(*(*Tliterals)(unsafe.Pointer(bp))).Fa = _default_malloc(tls, uint64((*(*Tliterals)(unsafe.Pointer(bp))).Fcap1)*uint64(8))
	if !((*(*Tliterals)(unsafe.Pointer(bp))).Fa != 0) {
		return int32(m_REG_ESPACE)
	}
	(*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1 = int32(0)
	(*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate = BoolInt32(int32(*(*int8)(unsafe.Pointer(s))) == int32('^'))
	if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
		s++
	}
	err = _parse_bracket_terms(tls, ctx, s, bp, bp+24)
	if err != int32(m_REG_OK) {
		goto parse_bracket_done
	}
	if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
		/*
		 * With REG_NEWLINE, POSIX requires that newlines are not matched by
		 * any form of a non-matching list.
		 */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_NEWLINE) != 0 {
			lit = _tre_new_lit(tls, bp)
			if !(lit != 0) {
				err = int32(m_REG_ESPACE)
				goto parse_bracket_done
			}
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64('\n')
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64('\n')
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
		}
		/* Sort the array if we need to negate it. */
		x_qsort(tls, (*(*Tliterals)(unsafe.Pointer(bp))).Fa, uint64((*(*Tliterals)(unsafe.Pointer(bp))).Flen1), uint64(8), __ccgo_fp(_tre_compare_lit))
		/* extra lit for the last negated range */
		lit = _tre_new_lit(tls, bp)
		if !(lit != 0) {
			err = int32(m_REG_ESPACE)
			goto parse_bracket_done
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(Int32FromInt32(m_TRE_CHAR_MAX) + Int32FromInt32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(Int32FromInt32(m_TRE_CHAR_MAX) + Int32FromInt32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
		/* negated classes */
		if (*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1 != 0 {
			nc = x___tre_mem_alloc_impl(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(0), UintptrFromInt32(0), int32(0), uint64((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1+Int32FromInt32(1))*uint64(8))
			if !(nc != 0) {
				err = int32(m_REG_ESPACE)
				goto parse_bracket_done
			}
			x_memcpy(tls, nc, uintptr(unsafe.Pointer(&(*(*Tneg)(unsafe.Pointer(bp + 24))).Fa)), uint64((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1)*uint64(8))
			*(*Ttre_ctype_t)(unsafe.Pointer(nc + uintptr((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1)*8)) = uint64(0)
		}
	}
	/* Build a union of the items in the array, negated if necessary. */
	v1 = Int32FromInt32(0)
	negmin = v1
	negmax = v1
	for i = int32(0); i < (*(*Tliterals)(unsafe.Pointer(bp))).Flen1; i++ {
		lit = *(*uintptr)(unsafe.Pointer((*(*Tliterals)(unsafe.Pointer(bp))).Fa + uintptr(i)*8))
		min = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min)
		max = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
		if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
			if min <= negmin {
				/* Overlap. */
				if max+int32(1) >= negmin {
					v2 = max + int32(1)
				} else {
					v2 = negmin
				}
				negmin = v2
				continue
			}
			negmax = min - int32(1)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(negmin)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(negmax)
			negmin = max + int32(1)
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes = nc
		n = _tre_ast_new_node(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(_LITERAL), lit)
		node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, node, n)
		if !(node != 0) {
			err = int32(m_REG_ESPACE)
			break
		}
	}
parse_bracket_done:
	x_free(tls, (*(*Tliterals)(unsafe.Pointer(bp))).Fa)
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	return err
}

func _parse_dup_count(tls *TLS, s uintptr, n uintptr) (r uintptr) {
	*(*int32)(unsafe.Pointer(n)) = -int32(1)
	if !(BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
		return s
	}
	*(*int32)(unsafe.Pointer(n)) = int32(0)
	for {
		*(*int32)(unsafe.Pointer(n)) = int32(10)**(*int32)(unsafe.Pointer(n)) + (int32(*(*int8)(unsafe.Pointer(s))) - int32('0'))
		s++
		if !(BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) || *(*int32)(unsafe.Pointer(n)) > int32(m_RE_DUP_MAX) {
			break
		}
	}
	return s
}

func _parse_dup(tls *TLS, s uintptr, ere int32, pmin uintptr, pmax uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* max at bp+4 */ int32
	var _ /* min at bp+0 */ int32
	var v1 uintptr
	var v2 bool
	var v3 bool
	var v4 uintptr
	var v5 bool
	s = _parse_dup_count(tls, s, bp)
	if int32(*(*int8)(unsafe.Pointer(s))) == int32(',') {
		s = _parse_dup_count(tls, s+uintptr(1), bp+4)
	} else {
		*(*int32)(unsafe.Pointer(bp + 4)) = *(*int32)(unsafe.Pointer(bp))
	}
	if v3 = *(*int32)(unsafe.Pointer(bp + 4)) < *(*int32)(unsafe.Pointer(bp)) && *(*int32)(unsafe.Pointer(bp + 4)) >= int32(0) || *(*int32)(unsafe.Pointer(bp + 4)) > int32(m_RE_DUP_MAX) || *(*int32)(unsafe.Pointer(bp)) > int32(m_RE_DUP_MAX) || *(*int32)(unsafe.Pointer(bp)) < int32(0); !v3 {
		if v2 = !(ere != 0); v2 {
			v1 = s
			s++
		}
	}
	if v5 = v3 || v2 && int32(*(*int8)(unsafe.Pointer(v1))) != int32('\\'); !v5 {
		v4 = s
		s++
	}
	if v5 || int32(*(*int8)(unsafe.Pointer(v4))) != int32('}') {
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(pmin)) = *(*int32)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(pmax)) = *(*int32)(unsafe.Pointer(bp + 4))
	return s
}

func _hexval1(tls *TLS, c uint32) (r int32) {
	if c-uint32('0') < uint32(10) {
		return int32(c - uint32('0'))
	}
	c = c | Uint32FromInt32(32)
	if c-uint32('a') < uint32(6) {
		return int32(c - uint32('a') + uint32(10))
	}
	return -int32(1)
}

func _marksub(tls *TLS, ctx uintptr, node uintptr, subid int32) (r Treg_errcode_t) {
	var n uintptr
	if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= int32(0) {
		n = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
		if !(n != 0) {
			return int32(m_REG_ESPACE)
		}
		n = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, n, node)
		if !(n != 0) {
			return int32(m_REG_ESPACE)
		}
		(*Ttre_ast_node_t)(unsafe.Pointer(n)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches
		node = n
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id = subid
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches++
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	return int32(m_REG_OK)
}

func _parse_atom(tls *TLS, ctx uintptr, s uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c int32
	var ere int32
	var err Treg_errcode_t
	var i int32
	var len1 int32
	var node uintptr
	var p uintptr
	var tmp1 uintptr
	var tmp11 uintptr
	var tmp2 uintptr
	var tmp21 uintptr
	var v int32
	var val int32
	var _ /* wc at bp+0 */ Twchar_t
	var v14 uintptr
	var v15 int32
	var v16 uintptr
	var v17 int32
	var v18 uintptr
	var v19 int32
	var v20 int32
	var v21 uintptr
	var v22 int32
	var v23 uintptr
	var v24 int32
	var v25 uintptr
	ere = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags & int32(m_REG_EXTENDED)
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('['):
		goto _1
	case int32('\\'):
		goto _2
	case int32('.'):
		goto _3
	case int32('^'):
		goto _4
	case int32('$'):
		goto _5
	case int32('?'):
		goto _6
	case int32('+'):
		goto _7
	case int32('{'):
		goto _8
	case int32('*'):
		goto _9
	case int32('|'):
		goto _10
	case int32(0):
		goto _11
	default:
		goto _12
	}
	goto _13
_1:
	return _parse_bracket(tls, ctx, s+uintptr(1))
_2:
	p = _tre_expand_macro(tls, s+uintptr(1))
	if p != 0 {
		/* assume \X expansion is a single atom */
		err = _parse_atom(tls, ctx, p)
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s + uintptr(2)
		return err
	}
	/* extensions: \b, \B, \<, \>, \xHH \x{HHHH} */
	s++
	v14 = s
	switch int32(*(*int8)(unsafe.Pointer(v14))) {
	case int32(0):
		return int32(m_REG_EESCAPE)
	case int32('b'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_WB), -int32(1))
	case int32('B'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_WB_NEG), -int32(1))
	case int32('<'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_BOW), -int32(1))
	case int32('>'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_EOW), -int32(1))
	case int32('x'):
		s++
		v = int32(0)
		len1 = int32(2)
		if int32(*(*int8)(unsafe.Pointer(s))) == int32('{') {
			len1 = int32(8)
			s++
		}
		for i = int32(0); i < len1 && v < int32(0x110000); i++ {
			c = _hexval1(tls, uint32(*(*int8)(unsafe.Pointer(s + uintptr(i)))))
			if c < int32(0) {
				break
			}
			v = int32(16)*v + c
		}
		s = s + uintptr(i)
		if len1 == int32(8) {
			if int32(*(*int8)(unsafe.Pointer(s))) != int32('}') {
				return int32(m_REG_EBRACE)
			}
			s++
		}
		v16 = ctx + 44
		v15 = *(*int32)(unsafe.Pointer(v16))
		*(*int32)(unsafe.Pointer(v16))++
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, v, v, v15)
		s--
	case int32('{'):
		fallthrough
	case int32('+'):
		fallthrough
	case int32('?'):
		/* extension: treat \+, \? as repetitions in BRE */
		/* reject repetitions after empty expression in BRE */
		if !(ere != 0) {
			return int32(m_REG_BADRPT)
		}
		fallthrough
	case int32('|'):
		/* extension: treat \| as alternation in BRE */
		if !(ere != 0) {
			node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			s--
			goto end
		}
		/* fallthrough */
		fallthrough
	default:
		if !(ere != 0) && uint32(*(*int8)(unsafe.Pointer(s)))-uint32('1') < uint32(9) {
			/* back reference */
			val = int32(*(*int8)(unsafe.Pointer(s))) - int32('0')
			v18 = ctx + 44
			v17 = *(*int32)(unsafe.Pointer(v18))
			*(*int32)(unsafe.Pointer(v18))++
			node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(4), val, v17)
			if val >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref {
				v19 = val
			} else {
				v19 = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref
			}
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref = v19
		} else {
			/* extension: accept unknown escaped char
			   as a literal */
			goto parse_literal
		}
	}
	s++
	goto _13
_3:
	if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_NEWLINE) != 0 {
		v21 = ctx + 44
		v20 = *(*int32)(unsafe.Pointer(v21))
		*(*int32)(unsafe.Pointer(v21))++
		tmp1 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(0), Int32FromUint8('\n')-Int32FromInt32(1), v20)
		v23 = ctx + 44
		v22 = *(*int32)(unsafe.Pointer(v23))
		*(*int32)(unsafe.Pointer(v23))++
		tmp2 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, Int32FromUint8('\n')+Int32FromInt32(1), int32(m_TRE_CHAR_MAX), v22)
		if tmp1 != 0 && tmp2 != 0 {
			node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp1, tmp2)
		} else {
			node = uintptr(0)
		}
	} else {
		v25 = ctx + 44
		v24 = *(*int32)(unsafe.Pointer(v25))
		*(*int32)(unsafe.Pointer(v25))++
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(0), int32(m_TRE_CHAR_MAX), v24)
	}
	s++
	goto _13
_4:
	/* '^' has a special meaning everywhere in EREs, and at beginning of BRE. */
	if !(ere != 0) && s != (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart {
		goto parse_literal
	}
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_BOL), -int32(1))
	s++
	goto _13
_5:
	/* '$' is special everywhere in EREs, and at the end of a BRE subexpression. */
	if !(ere != 0) && *(*int8)(unsafe.Pointer(s + UintptrFromInt32(1))) != 0 && (int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32('\\') || int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(2)))) != int32(')') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(2)))) != int32('|')) {
		goto parse_literal
	}
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(m_ASSERT_AT_EOL), -int32(1))
	s++
	goto _13
_9:
_8:
_7:
_6:
	/* reject repetitions after empty expression in ERE */
	if ere != 0 {
		return int32(m_REG_BADRPT)
	}
_10:
	if !(ere != 0) {
		goto parse_literal
	}
_11:
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
	goto _13
_12:
parse_literal:
	len1 = x_mbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
	if len1 < int32(0) {
		return int32(m_REG_BADPAT)
	}
	if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(m_REG_ICASE) != 0 && (x_iswupper(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp)))) != 0 || x_iswlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp)))) != 0) {
		/* multiple opposite case characters are not supported */
		tmp11 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(x_towupper(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp))))), int32(x_towupper(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp))))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
		tmp21 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp))))), int32(x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(bp))))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
		if tmp11 != 0 && tmp21 != 0 {
			node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp11, tmp21)
		} else {
			node = uintptr(0)
		}
	} else {
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, *(*Twchar_t)(unsafe.Pointer(bp)), *(*Twchar_t)(unsafe.Pointer(bp)), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
	}
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
	s = s + uintptr(len1)
	goto _13
_13:
end:
	if !(node != 0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s
	return int32(m_REG_OK)
}

func _tre_parse(tls *TLS, ctx uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c int32
	var depth int32
	var ere int32
	var err Treg_errcode_t
	var nbranch uintptr
	var nunion uintptr
	var s uintptr
	var stack uintptr
	var subid int32
	var _ /* max at bp+4 */ int32
	var _ /* min at bp+0 */ int32
	var v1 Treg_errcode_t
	var v2 int32
	var v3 Treg_errcode_t
	var v4 Treg_errcode_t
	var v5 Treg_errcode_t
	var v6 int32
	var v7 uintptr
	nbranch = uintptr(0)
	nunion = uintptr(0)
	ere = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags & int32(m_REG_EXTENDED)
	s = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart
	subid = int32(0)
	depth = int32(0)
	stack = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstack
	{
		v2 = subid
		subid++
		v1 = _tre_stack_push_int(tls, stack, v2)
		err = v1
		if v1 != int32(m_REG_OK) {
			return err
		}
	}
	for {
		if !(ere != 0) && int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32('(') || ere != 0 && int32(*(*int8)(unsafe.Pointer(s))) == int32('(') {
			{
				v3 = _tre_stack_push_voidptr(tls, stack, nunion)
				err = v3
				if v3 != int32(m_REG_OK) {
					return err
				}
			}
			{
				v4 = _tre_stack_push_voidptr(tls, stack, nbranch)
				err = v4
				if v4 != int32(m_REG_OK) {
					return err
				}
			}
			{
				v6 = subid
				subid++
				v5 = _tre_stack_push_int(tls, stack, v6)
				err = v5
				if v5 != int32(m_REG_OK) {
					return err
				}
			}
			s++
			if !(ere != 0) {
				s++
			}
			depth++
			v7 = UintptrFromInt32(0)
			nunion = v7
			nbranch = v7
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
			continue
		}
		if !(ere != 0) && int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32(')') || ere != 0 && int32(*(*int8)(unsafe.Pointer(s))) == int32(')') && depth != 0 {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn != 0) {
				return int32(m_REG_ESPACE)
			}
		} else {
			err = _parse_atom(tls, ctx, s)
			if err != int32(m_REG_OK) {
				return err
			}
			s = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs
		}
	parse_iter:
		for {
			if int32(*(*int8)(unsafe.Pointer(s))) != int32('\\') && int32(*(*int8)(unsafe.Pointer(s))) != int32('*') {
				if !(ere != 0) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(s))) != int32('+') && int32(*(*int8)(unsafe.Pointer(s))) != int32('?') && int32(*(*int8)(unsafe.Pointer(s))) != int32('{') {
					break
				}
			}
			if int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && ere != 0 {
				break
			}
			/* extension: treat \+, \? as repetitions in BRE */
			if int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32('+') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32('?') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) != int32('{') {
				break
			}
			if int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') {
				s++
			}
			/* handle ^* at the start of a BRE. */
			if !(ere != 0) && s == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart+uintptr(1) && int32(*(*int8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1))))) == int32('^') {
				break
			}
			/* extension: multiple consecutive *+?{,} is unspecified,
			   but (a+)+ has to be supported so accepting a++ makes
			   sense, note however that the RE_DUP_MAX limit can be
			   circumvented: (a{255}){255} uses a lot of memory.. */
			if int32(*(*int8)(unsafe.Pointer(s))) == int32('{') {
				s = _parse_dup(tls, s+uintptr(1), ere, bp, bp+4)
				if !(s != 0) {
					return int32(m_REG_BADBR)
				}
			} else {
				*(*int32)(unsafe.Pointer(bp)) = int32(0)
				*(*int32)(unsafe.Pointer(bp + 4)) = -int32(1)
				if int32(*(*int8)(unsafe.Pointer(s))) == int32('+') {
					*(*int32)(unsafe.Pointer(bp)) = int32(1)
				}
				if int32(*(*int8)(unsafe.Pointer(s))) == int32('?') {
					*(*int32)(unsafe.Pointer(bp + 4)) = int32(1)
				}
				s++
			}
			if *(*int32)(unsafe.Pointer(bp + 4)) == int32(0) {
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			} else {
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_iter(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)), int32(0))
			}
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn != 0) {
				return int32(m_REG_ESPACE)
			}
		}
		nbranch = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, nbranch, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn)
		if ere != 0 && int32(*(*int8)(unsafe.Pointer(s))) == int32('|') || ere != 0 && int32(*(*int8)(unsafe.Pointer(s))) == int32(')') && depth != 0 || !(ere != 0) && int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32(')') || !(ere != 0) && int32(*(*int8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32('|') || !(*(*int8)(unsafe.Pointer(s)) != 0) {
			/* extension: empty branch is unspecified (), (|a), (a|)
			   here they are not rejected but match on empty string */
			c = int32(*(*int8)(unsafe.Pointer(s)))
			nunion = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, nunion, nbranch)
			nbranch = uintptr(0)
			if c == int32('\\') && int32(*(*int8)(unsafe.Pointer(s + UintptrFromInt32(1)))) == int32('|') {
				s = s + UintptrFromInt32(2)
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
			} else {
				if c == int32('|') {
					s++
					(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
				} else {
					if c == int32('\\') {
						if !(depth != 0) {
							return int32(m_REG_EPAREN)
						}
						s = s + UintptrFromInt32(2)
					} else {
						if c == int32(')') {
							s++
						}
					}
					depth--
					err = _marksub(tls, ctx, nunion, _tre_stack_pop_int(tls, stack))
					if err != int32(m_REG_OK) {
						return err
					}
					if !(c != 0) && depth < int32(0) {
						(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id = subid
						return int32(m_REG_OK)
					}
					if !(c != 0) || depth < int32(0) {
						return int32(m_REG_EPAREN)
					}
					nbranch = _tre_stack_pop_voidptr(tls, stack)
					nunion = _tre_stack_pop_voidptr(tls, stack)
					goto parse_iter
				}
			}
		}
	}
	return r
}

/***********************************************************************
 from tre-compile.c
***********************************************************************/

/*
  TODO:
   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
     function calls.
*/

/*
  Algorithms to setup tags so that submatch addressing can be done.
*/

// C documentation
//
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the left child a new tag with number `tag_id' to `node' is added,
//	   and the right child is the old root. */
func _tre_add_tag_left(tls *TLS, mem Ttre_mem_t, node uintptr, tag_id int32) (r Treg_errcode_t) {
	var c uintptr
	c = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(16))
	if c == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = _tre_ast_new_literal(tls, mem, -int32(3), tag_id, -int32(1))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(48))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fright == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fsubmatch_id = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Ffirstpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Flastpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnum_tags = int32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnum_submatches = int32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = c
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = int32(_CATENATION)
	return int32(m_REG_OK)
}

// C documentation
//
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the right child a new tag with number `tag_id' to `node' is added,
//	   and the left child is the old root. */
func _tre_add_tag_right(tls *TLS, mem Ttre_mem_t, node uintptr, tag_id int32) (r Treg_errcode_t) {
	var c uintptr
	c = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(16))
	if c == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = _tre_ast_new_literal(tls, mem, -int32(3), tag_id, -int32(1))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fright == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(48))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fsubmatch_id = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Ffirstpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Flastpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnum_tags = int32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnum_submatches = int32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = c
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = int32(_CATENATION)
	return int32(m_REG_OK)
}

type Ttre_addtags_symbol_t = int32

const _ADDTAGS_RECURSE = 0
const _ADDTAGS_AFTER_ITERATION = 1
const _ADDTAGS_AFTER_UNION_LEFT = 2
const _ADDTAGS_AFTER_UNION_RIGHT = 3
const _ADDTAGS_AFTER_CAT_LEFT = 4
const _ADDTAGS_AFTER_CAT_RIGHT = 5
const _ADDTAGS_SET_SUBMATCH_END = 6

type Ttre_tag_states_t = struct {
	Ftag      int32
	Fnext_tag int32
}

// C documentation
//
//	/* Go through `regset' and set submatch data for submatches that are
//	   using this tag. */
func _tre_purge_regset(tls *TLS, regset uintptr, tnfa uintptr, tag int32) {
	var i int32
	var id int32
	var start int32
	for i = int32(0); *(*int32)(unsafe.Pointer(regset + uintptr(i)*4)) >= int32(0); i++ {
		id = *(*int32)(unsafe.Pointer(regset + uintptr(i)*4)) / int32(2)
		start = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i)*4))%Int32FromInt32(2) != 0))
		if start != 0 {
			(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id)*16))).Fso_tag = tag
		} else {
			(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id)*16))).Feo_tag = tag
		}
	}
	*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) = -int32(1)
}

// C documentation
//
//	/* Adds tags to appropriate locations in the parse tree in `tree', so that
//	   subexpressions marked for submatch addressing can be traced. */
func _tre_add_tags(tls *TLS, mem Ttre_mem_t, stack uintptr, tree uintptr, tnfa uintptr) (r Treg_errcode_t) {
	var added_tags int32
	var bottom int32
	var cat uintptr
	var direction Ttre_tag_direction_t
	var enter_tag int32
	var first_pass int32
	var i uint32
	var i1 int32
	var i2 int32
	var i3 int32
	var i4 int32
	var i5 int32
	var i6 int32
	var i7 int32
	var id int32
	var id1 int32
	var iter uintptr
	var left uintptr
	var left1 uintptr
	var left2 uintptr
	var left_tag int32
	var lit uintptr
	var minimal int32
	var minimal_tag int32
	var new_tag int32
	var next_tag int32
	var node uintptr
	var num_minimals int32
	var num_tags int32
	var orig_regset uintptr
	var p uintptr
	var parents uintptr
	var regset uintptr
	var reserved_tag int32
	var right uintptr
	var right1 uintptr
	var right2 uintptr
	var right_tag int32
	var saved_states uintptr
	var status Treg_errcode_t
	var symbol Ttre_addtags_symbol_t
	var tag int32
	var tag_left int32
	var tag_right int32
	var uni uintptr
	var v10 bool
	var v11 bool
	var v14 int32
	var v15 bool
	var v16 bool
	status = int32(m_REG_OK)
	node = tree /* Tree node we are currently looking at. */
	bottom = _tre_stack_num_objects(tls, stack)
	/* True for first pass (counting number of needed tags) */
	first_pass = BoolInt32(mem == UintptrFromInt32(0) || tnfa == UintptrFromInt32(0))
	num_tags = int32(0)     /* Total number of tags. */
	num_minimals = int32(0) /* Number of special minimal tags. */
	tag = int32(0)          /* The tag that is to be added next. */
	next_tag = int32(1)     /* Next tag to use after this one. */
	/* Stack of submatches the current submatch is
	   contained in. */
	minimal_tag = -int32(1) /* Tag that marks the beginning of a minimal match. */
	direction = int32(_TRE_TAG_MINIMIZE)
	if !(first_pass != 0) {
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = int32(0)
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + UintptrFromInt32(0)*4)) = -int32(1)
	}
	regset = _default_malloc(tls, uint64(4)*uint64(((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1))*Uint32FromInt32(2)))
	if regset == UintptrFromInt32(0) {
		return int32(m_REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) = -int32(1)
	orig_regset = regset
	parents = _default_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if parents == UintptrFromInt32(0) {
		x_free(tls, regset)
		return int32(m_REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(parents + UintptrFromInt32(0)*4)) = -int32(1)
	saved_states = _default_malloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if saved_states == UintptrFromInt32(0) {
		x_free(tls, regset)
		x_free(tls, parents)
		return int32(m_REG_ESPACE)
	} else {
		for i = uint32(0); i <= (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches; i++ {
			(*(*Ttre_tag_states_t)(unsafe.Pointer(saved_states + uintptr(i)*8))).Ftag = -int32(1)
		}
	}
	{
		status = _tre_stack_push_voidptr(tls, stack, node)
	}
	{
		status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
	}
	for _tre_stack_num_objects(tls, stack) > bottom {
		if status != int32(m_REG_OK) {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		switch symbol {
		case int32(_ADDTAGS_SET_SUBMATCH_END):
			goto _1
		case int32(_ADDTAGS_RECURSE):
			goto _2
		case int32(_ADDTAGS_AFTER_ITERATION):
			goto _3
		case int32(_ADDTAGS_AFTER_CAT_LEFT):
			goto _4
		case int32(_ADDTAGS_AFTER_CAT_RIGHT):
			goto _5
		case int32(_ADDTAGS_AFTER_UNION_LEFT):
			goto _6
		case int32(_ADDTAGS_AFTER_UNION_RIGHT):
			goto _7
		default:
			goto _8
		}
		goto _9
	_1:
		id = _tre_stack_pop_int(tls, stack)
		/* Add end of this submatch to regset. */
		for i1 = int32(0); *(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) >= int32(0); i1++ {
		}
		*(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) = id*int32(2) + int32(1)
		*(*int32)(unsafe.Pointer(regset + uintptr(i1+Int32FromInt32(1))*4)) = -int32(1)
		/* Pop this submatch from the parents stack. */
		for i1 = int32(0); *(*int32)(unsafe.Pointer(parents + uintptr(i1)*4)) >= int32(0); i1++ {
		}
		*(*int32)(unsafe.Pointer(parents + uintptr(i1-Int32FromInt32(1))*4)) = -int32(1)
		goto _9
	_2:
		node = _tre_stack_pop_voidptr(tls, stack)
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= int32(0) {
			id1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			/* Add start of this submatch to regset. */
			for i2 = int32(0); *(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) >= int32(0); i2++ {
			}
			*(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) = id1 * int32(2)
			*(*int32)(unsafe.Pointer(regset + uintptr(i2+Int32FromInt32(1))*4)) = -int32(1)
			if !(first_pass != 0) {
				for i2 = int32(0); *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= int32(0); i2++ {
				}
				(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = UintptrFromInt32(0)
				if i2 > int32(0) {
					p = _default_malloc(tls, uint64(4)*uint64(i2+Int32FromInt32(1)))
					if p == UintptrFromInt32(0) {
						status = int32(m_REG_ESPACE)
						goto _9
					}
					if v10 = (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents == UintptrFromInt32(0); !v10 {
						___assert_fail(tls, ts+2600, ts+2493, int32(1311), uintptr(unsafe.Pointer(&___func__41)))
					}
					_ = v10 || Int32FromInt32(0) != 0
					(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = p
					for i2 = int32(0); *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= int32(0); i2++ {
						*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4))
					}
					*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = -int32(1)
				}
			}
			{
				/* Add end of this submatch to regset after processing this
				node. */
				status = _tre_stack_push_int(tls, stack, (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id)
				if status != int32(m_REG_OK) {
					goto _9
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_SET_SUBMATCH_END))
				if status != int32(m_REG_OK) {
					goto _9
				}
			}
		}
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
				if *(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0) {
					/* Regset is not empty, so add a tag before the
					   literal or backref. */
					if !(first_pass != 0) {
						status = _tre_add_tag_left(tls, mem, node, tag)
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
						if minimal_tag >= int32(0) {
							for i3 = int32(0); *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3)*4)) >= int32(0); i3++ {
							}
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3)*4)) = tag
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3+Int32FromInt32(1))*4)) = minimal_tag
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3+Int32FromInt32(2))*4)) = -int32(1)
							minimal_tag = -int32(1)
							num_minimals++
						}
						_tre_purge_regset(tls, regset, tnfa, tag)
					} else {
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = int32(1)
					}
					*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) = -int32(1)
					tag = next_tag
					num_tags++
					next_tag++
				}
			} else {
				if v11 = !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-Int32FromInt32(3))); !v11 {
					___assert_fail(tls, ts+2640, ts+2493, int32(1366), uintptr(unsafe.Pointer(&___func__41)))
				}
				_ = v11 || Int32FromInt32(0) != 0
			}
		case int32(_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft
			right = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright
			reserved_tag = -int32(1)
			{
				/* After processing right child. */
				status = _tre_stack_push_voidptr(tls, stack, node)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_CAT_RIGHT))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* Process right child. */
				status = _tre_stack_push_voidptr(tls, stack, right)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* After processing left child. */
				status = _tre_stack_push_int(tls, stack, next_tag+(*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags)
				if status != int32(m_REG_OK) {
					break
				}
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags > int32(0) && (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_tags > int32(0) {
				/* Reserve the next tag to the right child. */
				reserved_tag = next_tag
				next_tag++
			}
			{
				status = _tre_stack_push_int(tls, stack, reserved_tag)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_CAT_LEFT))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* Process left child. */
				status = _tre_stack_push_voidptr(tls, stack, left)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
				if status != int32(m_REG_OK) {
					break
				}
			}
		case int32(_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if first_pass != 0 {
				{
					status = _tre_stack_push_int(tls, stack, BoolInt32(*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0) || int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0))
					if status != int32(m_REG_OK) {
						break
					}
				}
			} else {
				{
					status = _tre_stack_push_int(tls, stack, tag)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)))
					if status != int32(m_REG_OK) {
						break
					}
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, node)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_ITERATION))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
				if status != int32(m_REG_OK) {
					break
				}
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0) || int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0 {
				if !(first_pass != 0) {
					status = _tre_add_tag_left(tls, mem, node, tag)
					if int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0 {
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = int32(_TRE_TAG_MAXIMIZE)
					} else {
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					}
					if minimal_tag >= int32(0) {
						for i4 = int32(0); *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4)*4)) >= int32(0); i4++ {
						}
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4)*4)) = tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4+Int32FromInt32(1))*4)) = minimal_tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4+Int32FromInt32(2))*4)) = -int32(1)
						minimal_tag = -int32(1)
						num_minimals++
					}
					_tre_purge_regset(tls, regset, tnfa, tag)
				}
				*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			direction = int32(_TRE_TAG_MINIMIZE)
		case int32(_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft
			right1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fright
			if *(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0) {
				left_tag = next_tag
				right_tag = next_tag + int32(1)
			} else {
				left_tag = tag
				right_tag = next_tag
			}
			{
				/* After processing right child. */
				status = _tre_stack_push_int(tls, stack, right_tag)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, left_tag)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, regset)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, BoolInt32(*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0)))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, node)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, right1)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, left1)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_UNION_RIGHT))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* Process right child. */
				status = _tre_stack_push_voidptr(tls, stack, right1)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* After processing left child. */
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_UNION_LEFT))
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				/* Process left child. */
				status = _tre_stack_push_voidptr(tls, stack, left1)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
				if status != int32(m_REG_OK) {
					break
				}
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) >= int32(0) {
				if !(first_pass != 0) {
					status = _tre_add_tag_left(tls, mem, node, tag)
					*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					if minimal_tag >= int32(0) {
						for i5 = int32(0); *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5)*4)) >= int32(0); i5++ {
						}
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5)*4)) = tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5+Int32FromInt32(1))*4)) = minimal_tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5+Int32FromInt32(2))*4)) = -int32(1)
						minimal_tag = -int32(1)
						num_minimals++
					}
					_tre_purge_regset(tls, regset, tnfa, tag)
				}
				*(*int32)(unsafe.Pointer(regset + UintptrFromInt32(0)*4)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > int32(0) {
				/* The next two tags are reserved for markers. */
				next_tag++
				tag = next_tag
				next_tag++
			}
			break
		}
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= int32(0) {
			/* Push this submatch on the parents stack. */
			for i6 = int32(0); *(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) >= int32(0); i6++ {
			}
			*(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			*(*int32)(unsafe.Pointer(parents + uintptr(i6+Int32FromInt32(1))*4)) = -int32(1)
		}
		goto _9 /* end case: ADDTAGS_RECURSE */
	_3:
		minimal = int32(0)
		node = _tre_stack_pop_voidptr(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)).Fnum_tags + _tre_stack_pop_int(tls, stack)
			minimal_tag = -int32(1)
		} else {
			minimal = _tre_stack_pop_int(tls, stack)
			enter_tag = _tre_stack_pop_int(tls, stack)
			if minimal != 0 {
				minimal_tag = enter_tag
			}
		}
		if !(first_pass != 0) {
			if minimal != 0 {
				direction = int32(_TRE_TAG_MINIMIZE)
			} else {
				direction = int32(_TRE_TAG_MAXIMIZE)
			}
		}
		goto _9
	_4:
		new_tag = _tre_stack_pop_int(tls, stack)
		next_tag = _tre_stack_pop_int(tls, stack)
		if new_tag >= int32(0) {
			tag = new_tag
		}
		goto _9
	_5:
		node = _tre_stack_pop_voidptr(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags
		}
		goto _9
	_6:
		/* Lift the bottom of the `regset' array so that when processing
		   the right operand the items currently in the array are
		   invisible.	 The original bottom was saved at ADDTAGS_UNION and
		   will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
	_13:
		if !(*(*int32)(unsafe.Pointer(regset)) >= int32(0)) {
			goto _12
		}
		regset += 4
		goto _13
	_12:
		goto _9
	_7:
		left2 = _tre_stack_pop_voidptr(tls, stack)
		right2 = _tre_stack_pop_voidptr(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		added_tags = _tre_stack_pop_int(tls, stack)
		if first_pass != 0 {
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > int32(0) {
				v14 = int32(2)
			} else {
				v14 = int32(0)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags + added_tags + v14
		}
		regset = _tre_stack_pop_voidptr(tls, stack)
		tag_left = _tre_stack_pop_int(tls, stack)
		tag_right = _tre_stack_pop_int(tls, stack)
		/* Add tags after both children, the left child gets a smaller
		   tag than the right child.  This guarantees that we prefer
		   the left child over the right child. */
		/* XXX - This is not always necessary (if the children have
		   tags which must be seen for every match of that child). */
		/* XXX - Check if this is the only place where tre_add_tag_right
		   is used.	 If so, use tre_add_tag_left (putting the tag before
		   the child as opposed after the child) and throw away
		   tre_add_tag_right. */
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > int32(0) {
			if !(first_pass != 0) {
				status = _tre_add_tag_right(tls, mem, left2, tag_left)
				*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag_left)*4)) = int32(_TRE_TAG_MAXIMIZE)
				if status == int32(m_REG_OK) {
					status = _tre_add_tag_right(tls, mem, right2, tag_right)
				}
				*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag_right)*4)) = int32(_TRE_TAG_MAXIMIZE)
			}
			num_tags = num_tags + Int32FromInt32(2)
		}
		direction = int32(_TRE_TAG_MAXIMIZE)
		goto _9
	_8:
		if v15 = int32(0) != 0; !v15 {
			___assert_fail(tls, ts+207, ts+2493, int32(1641), uintptr(unsafe.Pointer(&___func__41)))
		}
		_ = v15 || Int32FromInt32(0) != 0
		goto _9
	_9: /* end switch(symbol) */
	} /* end while(tre_stack_num_objects(stack) > bottom) */
	if !(first_pass != 0) {
		_tre_purge_regset(tls, regset, tnfa, tag)
	}
	if !(first_pass != 0) && minimal_tag >= int32(0) {
		for i7 = int32(0); *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7)*4)) >= int32(0); i7++ {
		}
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7)*4)) = tag
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7+Int32FromInt32(1))*4)) = minimal_tag
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7+Int32FromInt32(2))*4)) = -int32(1)
		minimal_tag = -int32(1)
		num_minimals++
	}
	if v16 = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Fnum_tags == num_tags; !v16 {
		___assert_fail(tls, ts+2653, ts+2493, int32(1661), uintptr(unsafe.Pointer(&___func__41)))
	}
	_ = v16 || Int32FromInt32(0) != 0
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = num_tags
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags = num_tags
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_minimals = num_minimals
	x_free(tls, orig_regset)
	x_free(tls, parents)
	x_free(tls, saved_states)
	return status
}

var ___func__41 = [13]int8{'t', 'r', 'e', '_', 'a', 'd', 'd', '_', 't', 'a', 'g', 's'}

/*
  AST to TNFA compilation routines.
*/

type Ttre_copyast_symbol_t = int32

const _COPY_RECURSE = 0
const _COPY_SET_RESULT_PTR = 1

func _tre_copy_ast(tls *TLS, mem Ttre_mem_t, stack uintptr, ast uintptr, flags int32, pos_add uintptr, tag_directions uintptr, copy1 uintptr, max_pos uintptr) (r Treg_errcode_t) {
	var bottom int32
	var cat uintptr
	var first_tag int32
	var iter uintptr
	var lit uintptr
	var max int32
	var min int32
	var node uintptr
	var num_copied int32
	var p uintptr
	var pos int32
	var result uintptr
	var status Treg_errcode_t
	var symbol Ttre_copyast_symbol_t
	var tmp uintptr
	var tmp1 uintptr
	var uni uintptr
	var v1 int32
	var v2 bool
	var p3 uintptr
	status = int32(m_REG_OK)
	bottom = _tre_stack_num_objects(tls, stack)
	num_copied = int32(0)
	first_tag = int32(1)
	result = copy1
	{
		status = _tre_stack_push_voidptr(tls, stack, ast)
	}
	{
		status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
	}
	for status == int32(m_REG_OK) && _tre_stack_num_objects(tls, stack) > bottom {
		if status != int32(m_REG_OK) {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		switch symbol {
		case int32(_COPY_SET_RESULT_PTR):
			result = _tre_stack_pop_voidptr(tls, stack)
		case int32(_COPY_RECURSE):
			node = _tre_stack_pop_voidptr(tls, stack)
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				pos = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
				min = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min)
				max = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* XXX - e.g. [ab] has only one position but two
					   nodes, so we are creating holes in the state space
					   here.  Not fatal, just wastes memory. */
					pos = pos + *(*int32)(unsafe.Pointer(pos_add))
					num_copied++
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(m_COPY_REMOVE_TAGS) != 0 {
						/* Change this tag to empty. */
						min = -int32(1)
						v1 = -Int32FromInt32(1)
						pos = v1
						max = v1
					} else {
						if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(m_COPY_MAXIMIZE_FIRST_TAG) != 0 && first_tag != 0 {
							/* Maximize the first tag. */
							*(*Ttre_tag_direction_t)(unsafe.Pointer(tag_directions + uintptr(max)*4)) = int32(_TRE_TAG_MAXIMIZE)
							first_tag = int32(0)
						}
					}
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_literal(tls, mem, min, max, pos)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
				} else {
					p = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
					(*Ttre_literal_t)(unsafe.Pointer(p)).Fclass = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass
					(*Ttre_literal_t)(unsafe.Pointer(p)).Fneg_classes = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes
				}
				if pos > *(*int32)(unsafe.Pointer(max_pos)) {
					*(*int32)(unsafe.Pointer(max_pos)) = pos
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_union(tls, mem, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				tmp = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = tmp
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, tmp+8)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_SET_RESULT_PTR))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_catenation(tls, mem, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				tmp1 = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				(*Ttre_catenation_t)(unsafe.Pointer(tmp1)).Fleft = UintptrFromInt32(0)
				(*Ttre_catenation_t)(unsafe.Pointer(tmp1)).Fright = UintptrFromInt32(0)
				result = tmp1
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, tmp1+8)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_SET_RESULT_PTR))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_iter(tls, mem, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax, int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)))
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(m_REG_ESPACE)
					break
				}
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = iter
			default:
				if v2 = int32(0) != 0; !v2 {
					___assert_fail(tls, ts+207, ts+2493, int32(1817), uintptr(unsafe.Pointer(&___func__42)))
				}
				_ = v2 || Int32FromInt32(0) != 0
				break
			}
			break
		}
	}
	p3 = pos_add
	*(*int32)(unsafe.Pointer(p3)) = *(*int32)(unsafe.Pointer(p3)) + num_copied
	return status
}

var ___func__42 = [13]int8{'t', 'r', 'e', '_', 'c', 'o', 'p', 'y', '_', 'a', 's', 't'}

type Ttre_expand_ast_symbol_t = int32

const _EXPAND_RECURSE = 0
const _EXPAND_AFTER_ITER = 1

// C documentation
//
//	/* Expands each iteration node that has a finite nonzero minimum or maximum
//	   iteration count to a catenated sequence of copies of the node. */
func _tre_expand_ast(tls *TLS, mem Ttre_mem_t, stack uintptr, ast uintptr, position uintptr, tag_directions uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var _status Treg_errcode_t
	var _status1 Treg_errcode_t
	var bottom int32
	var cat uintptr
	var flags int32
	var iter uintptr
	var iter1 uintptr
	var iter_depth int32
	var j int32
	var lit uintptr
	var node uintptr
	var pos_add_last int32
	var pos_add_save int32
	var pos_add_total int32
	var seq1 uintptr
	var status Treg_errcode_t
	var symbol Ttre_expand_ast_symbol_t
	var tmp uintptr
	var uni uintptr
	var _ /* copy at bp+16 */ uintptr
	var _ /* copy at bp+24 */ uintptr
	var _ /* max_pos at bp+4 */ int32
	var _ /* pos_add at bp+0 */ int32
	var _ /* seq2 at bp+8 */ uintptr
	var v2 bool
	var v3 int32
	var v4 bool
	var p1 uintptr
	var p5 uintptr
	status = int32(m_REG_OK)
	bottom = _tre_stack_num_objects(tls, stack)
	*(*int32)(unsafe.Pointer(bp)) = int32(0)
	pos_add_total = int32(0)
	*(*int32)(unsafe.Pointer(bp + 4)) = int32(0)
	iter_depth = int32(0)
	{
		_status = _tre_stack_push_voidptr(tls, stack, ast)
		if _status != int32(m_REG_OK) {
			return _status
		}
	}
	{
		_status1 = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
		if _status1 != int32(m_REG_OK) {
			return _status1
		}
	}
	for status == int32(m_REG_OK) && _tre_stack_num_objects(tls, stack) > bottom {
		if status != int32(m_REG_OK) {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		switch symbol {
		case int32(_EXPAND_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					p1 = lit + 16
					*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) + *(*int32)(unsafe.Pointer(bp))
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition > *(*int32)(unsafe.Pointer(bp + 4)) {
						*(*int32)(unsafe.Pointer(bp + 4)) = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
					}
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				{
					status = _tre_stack_push_int(tls, stack, *(*int32)(unsafe.Pointer(bp)))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, node)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_AFTER_ITER))
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
					if status != int32(m_REG_OK) {
						break
					}
				}
				{
					status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
					if status != int32(m_REG_OK) {
						break
					}
				}
				/* If we are going to expand this node at EXPAND_AFTER_ITER
				   then don't increase the `pos' fields of the nodes now, it
				   will get done when expanding. */
				if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax > int32(1) {
					*(*int32)(unsafe.Pointer(bp)) = int32(0)
				}
				iter_depth++
			default:
				if v2 = int32(0) != 0; !v2 {
					___assert_fail(tls, ts+207, ts+2493, int32(1908), uintptr(unsafe.Pointer(&___func__43)))
				}
				_ = v2 || Int32FromInt32(0) != 0
				break
			}
		case int32(_EXPAND_AFTER_ITER):
			iter1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			*(*int32)(unsafe.Pointer(bp)) = _tre_stack_pop_int(tls, stack)
			pos_add_last = *(*int32)(unsafe.Pointer(bp))
			if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax > int32(1) {
				seq1 = UintptrFromInt32(0)
				*(*uintptr)(unsafe.Pointer(bp + 8)) = UintptrFromInt32(0)
				pos_add_save = *(*int32)(unsafe.Pointer(bp))
				/* Create a catenated sequence of copies of the node. */
				for j = int32(0); j < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin; j++ {
					/* Remove tags from all but the last copy. */
					if j+int32(1) < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin {
						v3 = int32(m_COPY_REMOVE_TAGS)
					} else {
						v3 = int32(m_COPY_MAXIMIZE_FIRST_TAG)
					}
					flags = v3
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, flags, bp, tag_directions, bp+16, bp+4)
					if status != int32(m_REG_OK) {
						return status
					}
					if seq1 != UintptrFromInt32(0) {
						seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 16)))
					} else {
						seq1 = *(*uintptr)(unsafe.Pointer(bp + 16))
					}
					if seq1 == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
				}
				if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax == -int32(1) {
					/* No upper limit. */
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, int32(0), bp, UintptrFromInt32(0), bp+8, bp+4)
					if status != int32(m_REG_OK) {
						return status
					}
					*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_iter(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 8)), int32(0), -int32(1), int32(0))
					if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
				} else {
					for j = (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin; j < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax; j++ {
						pos_add_save = *(*int32)(unsafe.Pointer(bp))
						status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, int32(0), bp, UintptrFromInt32(0), bp+24, bp+4)
						if status != int32(m_REG_OK) {
							return status
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_catenation(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 24)), *(*uintptr)(unsafe.Pointer(bp + 8)))
						} else {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 24))
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
						tmp = _tre_ast_new_literal(tls, mem, -int32(1), -int32(1), -int32(1))
						if tmp == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
						*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_union(tls, mem, tmp, *(*uintptr)(unsafe.Pointer(bp + 8)))
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(m_REG_ESPACE)
						}
					}
				}
				*(*int32)(unsafe.Pointer(bp)) = pos_add_save
				if seq1 == UintptrFromInt32(0) {
					seq1 = *(*uintptr)(unsafe.Pointer(bp + 8))
				} else {
					if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
						seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 8)))
					}
				}
				if seq1 == UintptrFromInt32(0) {
					return int32(m_REG_ESPACE)
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Fobj
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Ftype1
			}
			iter_depth--
			pos_add_total = pos_add_total + (*(*int32)(unsafe.Pointer(bp)) - pos_add_last)
			if iter_depth == int32(0) {
				*(*int32)(unsafe.Pointer(bp)) = pos_add_total
			}
		default:
			if v4 = int32(0) != 0; !v4 {
				___assert_fail(tls, ts+207, ts+2493, int32(2002), uintptr(unsafe.Pointer(&___func__43)))
			}
			_ = v4 || Int32FromInt32(0) != 0
			break
		}
	}
	p5 = position
	*(*int32)(unsafe.Pointer(p5)) = *(*int32)(unsafe.Pointer(p5)) + pos_add_total
	/* `max_pos' should never be larger than `*position' if the above
	   code works, but just an extra safeguard let's make sure
	   `*position' is set large enough so enough memory will be
	   allocated for the transition table. */
	if *(*int32)(unsafe.Pointer(bp + 4)) > *(*int32)(unsafe.Pointer(position)) {
		*(*int32)(unsafe.Pointer(position)) = *(*int32)(unsafe.Pointer(bp + 4))
	}
	return status
}

var ___func__43 = [15]int8{'t', 'r', 'e', '_', 'e', 'x', 'p', 'a', 'n', 'd', '_', 'a', 's', 't'}

func _tre_set_empty(tls *TLS, mem Ttre_mem_t) (r uintptr) {
	var new_set uintptr
	new_set = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(56))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_one(tls *TLS, mem Ttre_mem_t, position int32, code_min int32, code_max int32, class Ttre_ctype_t, neg_classes uintptr, backref int32) (r uintptr) {
	var new_set uintptr
	new_set = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), Uint64FromInt64(56)*Uint64FromInt32(2))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fposition = position
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fcode_min = code_min
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fcode_max = code_max
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fclass = class
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fneg_classes = neg_classes
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(0)*56))).Fbackref = backref
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(1)*56))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(1)*56))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + UintptrFromInt32(1)*56))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_union(tls *TLS, mem Ttre_mem_t, set1 uintptr, set2 uintptr, tags uintptr, assertions int32) (r uintptr) {
	var i int32
	var j int32
	var new_set uintptr
	var new_tags uintptr
	var num_tags int32
	var s1 int32
	var s2 int32
	for num_tags = int32(0); tags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer(tags + uintptr(num_tags)*4)) >= int32(0); num_tags++ {
	}
	for s1 = int32(0); (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition >= int32(0); s1++ {
	}
	for s2 = int32(0); (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition >= int32(0); s2++ {
	}
	new_set = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(1), uint64(56)*uint64(s1+s2+Int32FromInt32(1)))
	if !(new_set != 0) {
		return UintptrFromInt32(0)
	}
	for s1 = int32(0); (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition >= int32(0); s1++ {
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fcode_max
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fassertions | assertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags == UintptrFromInt32(0) && tags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Ftags = UintptrFromInt32(0)
		} else {
			for i = int32(0); (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags + uintptr(i)*4)) >= int32(0); i++ {
			}
			new_tags = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), Uint64FromInt64(4)*uint64(i+num_tags+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			for j = int32(0); j < i; j++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags + uintptr(j)*4))
			}
			for i = int32(0); i < num_tags; i++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i)*4))
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Ftags = new_tags
		}
	}
	for s2 = int32(0); (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition >= int32(0); s2++ {
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fcode_max
		/* XXX - why not | assertions here as well? */
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fassertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Ftags = UintptrFromInt32(0)
		} else {
			for i = int32(0); *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags + uintptr(i)*4)) >= int32(0); i++ {
			}
			new_tags = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(4)*uint64(i+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			for j = int32(0); j < i; j++ {
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags + uintptr(j)*4))
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Ftags = new_tags
		}
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fposition = -int32(1)
	return new_set
}

// C documentation
//
//	/* Finds the empty path through `node' which is the one that should be
//	   taken according to POSIX.2 rules, and adds the tags on that path to
//	   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
//	   set to the number of tags seen on the path. */
func _tre_match_empty(tls *TLS, stack uintptr, node uintptr, tags uintptr, assertions uintptr, num_tags_seen uintptr) (r Treg_errcode_t) {
	var bottom int32
	var cat uintptr
	var i int32
	var iter uintptr
	var lit uintptr
	var status Treg_errcode_t
	var uni uintptr
	var v1 bool
	var v3 bool
	var v4 bool
	var v5 bool
	var v6 bool
	var v7 bool
	var p2 uintptr
	bottom = _tre_stack_num_objects(tls, stack)
	status = int32(m_REG_OK)
	if num_tags_seen != 0 {
		*(*int32)(unsafe.Pointer(num_tags_seen)) = int32(0)
	}
	status = _tre_stack_push_voidptr(tls, stack, node)
	/* Walk through the tree recursively. */
	for status == int32(m_REG_OK) && _tre_stack_num_objects(tls, stack) > bottom {
		node = _tre_stack_pop_voidptr(tls, stack)
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			switch (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min {
			case int64(-int32(3)):
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max >= int64(0) {
					if tags != UintptrFromInt32(0) {
						/* Add the tag to `tags'. */
						for i = int32(0); *(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) >= int32(0); i++ {
							if int64(*(*int32)(unsafe.Pointer(tags + uintptr(i)*4))) == (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max {
								break
							}
						}
						if *(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) < int32(0) {
							*(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
							*(*int32)(unsafe.Pointer(tags + uintptr(i+Int32FromInt32(1))*4)) = -int32(1)
						}
					}
					if num_tags_seen != 0 {
						*(*int32)(unsafe.Pointer(num_tags_seen))++
					}
				}
			case int64(-int32(2)):
				if v1 = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max >= int64(1) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max <= int64(256); !v1 {
					___assert_fail(tls, ts+2680, ts+2493, int32(2180), uintptr(unsafe.Pointer(&___func__44)))
				}
				_ = v1 || Int32FromInt32(0) != 0
				if assertions != UintptrFromInt32(0) {
					p2 = assertions
					*(*int32)(unsafe.Pointer(p2)) = int32(int64(*(*int32)(unsafe.Pointer(p2))) | (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				}
			case int64(-int32(1)):
			default:
				if v3 = int32(0) != 0; !v3 {
					___assert_fail(tls, ts+207, ts+2493, int32(2188), uintptr(unsafe.Pointer(&___func__44)))
				}
				_ = v3 || Int32FromInt32(0) != 0
				break
			}
			break
			fallthrough
		case int32(_UNION):
			/* Subexpressions starting earlier take priority over ones
			   starting later, so we prefer the left subexpression over the
			   right subexpression. */
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 {
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
				if status != int32(m_REG_OK) {
					break
				}
			} else {
				if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0 {
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != int32(m_REG_OK) {
						break
					}
				} else {
					if v4 = int32(0) != 0; !v4 {
						___assert_fail(tls, ts+207, ts+2493, int32(2203), uintptr(unsafe.Pointer(&___func__44)))
					}
					_ = v4 || Int32FromInt32(0) != 0
				}
			}
			break
			fallthrough
		case int32(_CATENATION):
			/* The path must go through both children. */
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if v5 = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0; !v5 {
				___assert_fail(tls, ts+2731, ts+2493, int32(2209), uintptr(unsafe.Pointer(&___func__44)))
			}
			_ = v5 || Int32FromInt32(0) != 0
			if v6 = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0; !v6 {
				___assert_fail(tls, ts+2751, ts+2493, int32(2210), uintptr(unsafe.Pointer(&___func__44)))
			}
			_ = v6 || Int32FromInt32(0) != 0
			{
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
				if status != int32(m_REG_OK) {
					break
				}
			}
			{
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if status != int32(m_REG_OK) {
					break
				}
			}
			break
			fallthrough
		case int32(_ITERATION):
			/* A match with an empty string is preferred over no match at
			   all, so we go through the argument if possible. */
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != int32(m_REG_OK) {
					break
				}
			}
			break
			fallthrough
		default:
			if v7 = int32(0) != 0; !v7 {
				___assert_fail(tls, ts+207, ts+2493, int32(2224), uintptr(unsafe.Pointer(&___func__44)))
			}
			_ = v7 || Int32FromInt32(0) != 0
			break
		}
	}
	return status
}

var ___func__44 = [16]int8{'t', 'r', 'e', '_', 'm', 'a', 't', 'c', 'h', '_', 'e', 'm', 'p', 't', 'y'}

type Ttre_nfl_stack_symbol_t = int32

const _NFL_RECURSE = 0
const _NFL_POST_UNION = 1
const _NFL_POST_CATENATION = 2
const _NFL_POST_ITERATION = 3

// C documentation
//
//	/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
//	   the nodes of the AST `tree'. */
func _tre_compute_nfl(tls *TLS, mem Ttre_mem_t, stack uintptr, tree uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _status Treg_errcode_t
	var _status1 Treg_errcode_t
	var _status10 Treg_errcode_t
	var _status11 Treg_errcode_t
	var _status12 Treg_errcode_t
	var _status13 Treg_errcode_t
	var _status14 Treg_errcode_t
	var _status15 Treg_errcode_t
	var _status16 Treg_errcode_t
	var _status17 Treg_errcode_t
	var _status2 Treg_errcode_t
	var _status3 Treg_errcode_t
	var _status4 Treg_errcode_t
	var _status5 Treg_errcode_t
	var _status6 Treg_errcode_t
	var _status7 Treg_errcode_t
	var _status8 Treg_errcode_t
	var _status9 Treg_errcode_t
	var bottom int32
	var cat uintptr
	var iter uintptr
	var lit uintptr
	var node uintptr
	var status Treg_errcode_t
	var symbol Ttre_nfl_stack_symbol_t
	var tags uintptr
	var uni uintptr
	var _ /* assertions at bp+4 */ int32
	var _ /* num_tags at bp+0 */ int32
	var v1 bool
	bottom = _tre_stack_num_objects(tls, stack)
	{
		_status = _tre_stack_push_voidptr(tls, stack, tree)
		if _status != int32(m_REG_OK) {
			return _status
		}
	}
	{
		_status1 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
		if _status1 != int32(m_REG_OK) {
			return _status1
		}
	}
	for _tre_stack_num_objects(tls, stack) > bottom {
		symbol = _tre_stack_pop_int(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		switch symbol {
		case int32(_NFL_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* Back references: nullable = false, firstpos = {i},
					   lastpos = {i}. */
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(0)
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32(0), int32(m_TRE_CHAR_MAX), uint64(0), UintptrFromInt32(0), -int32(1))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
						return int32(m_REG_ESPACE)
					}
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32(0), int32(m_TRE_CHAR_MAX), uint64(0), UintptrFromInt32(0), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
						return int32(m_REG_ESPACE)
					}
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < int64(0) {
						/* Tags, empty strings, params, and zero width assertions:
						   nullable = true, firstpos = {}, and lastpos = {}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(m_REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(m_REG_ESPACE)
						}
					} else {
						/* Literal at position i: nullable = false, firstpos = {i},
						   lastpos = {i}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(0)
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), uint64(0), UintptrFromInt32(0), -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(m_REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), (*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes, -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(m_REG_ESPACE)
						}
					}
				}
				break
				fallthrough
			case int32(_UNION):
				_status2 = _tre_stack_push_voidptr(tls, stack, node)
				if _status2 != int32(m_REG_OK) {
					return _status2
				}
				{
					_status3 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_UNION))
					if _status3 != int32(m_REG_OK) {
						return _status3
					}
				}
				{
					_status4 = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
					if _status4 != int32(m_REG_OK) {
						return _status4
					}
				}
				{
					_status5 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
					if _status5 != int32(m_REG_OK) {
						return _status5
					}
				}
				{
					_status6 = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
					if _status6 != int32(m_REG_OK) {
						return _status6
					}
				}
				{
					_status7 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
					if _status7 != int32(m_REG_OK) {
						return _status7
					}
				}
				break
				fallthrough
			case int32(_CATENATION):
				_status8 = _tre_stack_push_voidptr(tls, stack, node)
				if _status8 != int32(m_REG_OK) {
					return _status8
				}
				{
					_status9 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_CATENATION))
					if _status9 != int32(m_REG_OK) {
						return _status9
					}
				}
				{
					_status10 = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
					if _status10 != int32(m_REG_OK) {
						return _status10
					}
				}
				{
					_status11 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
					if _status11 != int32(m_REG_OK) {
						return _status11
					}
				}
				{
					_status12 = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
					if _status12 != int32(m_REG_OK) {
						return _status12
					}
				}
				{
					_status13 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
					if _status13 != int32(m_REG_OK) {
						return _status13
					}
				}
				break
				fallthrough
			case int32(_ITERATION):
				_status14 = _tre_stack_push_voidptr(tls, stack, node)
				if _status14 != int32(m_REG_OK) {
					return _status14
				}
				{
					_status15 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_ITERATION))
					if _status15 != int32(m_REG_OK) {
						return _status15
					}
				}
				{
					_status16 = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)
					if _status16 != int32(m_REG_OK) {
						return _status16
					}
				}
				{
					_status17 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
					if _status17 != int32(m_REG_OK) {
						return _status17
					}
				}
				break
			}
			break /* end case: NFL_RECURSE */
			fallthrough
		case int32(_NFL_POST_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0)
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Ffirstpos, UintptrFromInt32(0), int32(0))
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
				return int32(m_REG_ESPACE)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Flastpos, UintptrFromInt32(0), int32(0))
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
				return int32(m_REG_ESPACE)
			}
			break
			fallthrough
		case int32(_NFL_POST_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == int32(0) || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(0)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos
			break
			fallthrough
		case int32(_NFL_POST_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 && (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0)
			/* Compute firstpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 {
				/* The left side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags and
				   parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status != int32(m_REG_OK) {
					return status
				}
				/* Allocate arrays for the tags and parameters. */
				tags = _default_malloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(m_REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags + UintptrFromInt32(0)*4)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = int32(0)
				/* Second pass with tre_mach_empty() to get the list of
				   tags and parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, tags, bp+4, UintptrFromInt32(0))
				if status != int32(m_REG_OK) {
					x_free(tls, tags)
					return status
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				x_free(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
					return int32(m_REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos
			}
			/* Compute lastpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0 {
				/* The right side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags and
				   parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status != int32(m_REG_OK) {
					return status
				}
				/* Allocate arrays for the tags and parameters. */
				tags = _default_malloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(m_REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags + UintptrFromInt32(0)*4)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = int32(0)
				/* Second pass with tre_mach_empty() to get the list of
				   tags and parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, tags, bp+4, UintptrFromInt32(0))
				if status != int32(m_REG_OK) {
					x_free(tls, tags)
					return status
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				x_free(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
					return int32(m_REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos
			}
			break
			fallthrough
		default:
			if v1 = int32(0) != 0; !v1 {
				___assert_fail(tls, ts+207, ts+2493, int32(2459), uintptr(unsafe.Pointer(&___func__45)))
			}
			_ = v1 || Int32FromInt32(0) != 0
			break
		}
	}
	return int32(m_REG_OK)
}

var ___func__45 = [16]int8{'t', 'r', 'e', '_', 'c', 'o', 'm', 'p', 'u', 't', 'e', '_', 'n', 'f', 'l'}

// C documentation
//
//	/* Adds a transition from each position in `p1' to each position in `p2'. */
func _tre_make_trans(tls *TLS, p1 uintptr, p2 uintptr, transitions uintptr, counts uintptr, offs uintptr) (r Treg_errcode_t) {
	var dup int32
	var i int32
	var j int32
	var k int32
	var l int32
	var orig_p2 uintptr
	var prev_p2_pos int32
	var trans uintptr
	var v1 int32
	var v2 int32
	var v3 bool
	var v4 bool
	var v6 int32
	var p5 uintptr
	orig_p2 = p2
	if transitions != UintptrFromInt32(0) {
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= int32(0) {
			p2 = orig_p2
			prev_p2_pos = -int32(1)
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= int32(0) {
				/* Optimization: if this position was already handled, skip it. */
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition == prev_p2_pos {
					p2 += 56
					continue
				}
				prev_p2_pos = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				/* Set `trans' to point to the next unused transition from
				   position `p1->position'. */
				trans = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4)))*56
				for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != UintptrFromInt32(0) {
					trans += 56
				}
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate == UintptrFromInt32(0) {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans + UintptrFromInt32(1)*56)).Fstate = UintptrFromInt32(0)
				}
				/* Use the character ranges, assertions, etc. from `p1' for
				   the transition from `p1' to `p2'. */
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_min = uint32((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_min)
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_max = uint32((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_max)
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition)*4)))*56
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass != 0 {
					v1 = int32(m_ASSERT_CHAR_CLASS)
				} else {
					v1 = int32(0)
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					v2 = int32(m_ASSERT_CHAR_CLASS_NEG)
				} else {
					v2 = int32(0)
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fassertions | (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fassertions | v1 | v2
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref >= int32(0) {
					if v3 = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fassertions&int32(4) == int32(0); !v3 {
						___assert_fail(tls, ts+2772, ts+2493, int32(2530), uintptr(unsafe.Pointer(&___func__46)))
					}
					_ = v3 || Int32FromInt32(0) != 0
					if v4 = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fbackref < int32(0); !v4 {
						___assert_fail(tls, ts+2817, ts+2493, int32(2531), uintptr(unsafe.Pointer(&___func__46)))
					}
					_ = v4 || Int32FromInt32(0) != 0
					*(*int32)(unsafe.Pointer(&(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fu)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref
					p5 = trans + 32
					*(*int32)(unsafe.Pointer(p5)) = *(*int32)(unsafe.Pointer(p5)) | Int32FromInt32(m_ASSERT_BACKREF)
				} else {
					*(*Ttre_ctype_t)(unsafe.Pointer(trans + 40)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					for i = int32(0); *(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8)) != Uint64FromInt32(0); i++ {
					}
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = _default_malloc(tls, uint64(8)*uint64(i+Int32FromInt32(1)))
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes == UintptrFromInt32(0) {
						return int32(m_REG_ESPACE)
					}
					for i = int32(0); *(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8)) != Uint64FromInt32(0); i++ {
						*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*8)) = *(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8))
					}
					*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*8)) = Uint64FromInt32(0)
				} else {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = UintptrFromInt32(0)
				}
				/* Find out how many tags this transition has. */
				i = int32(0)
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= int32(0) {
						i++
					}
				}
				j = int32(0)
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= int32(0) {
						j++
					}
				}
				/* If we are overwriting a transition, free the old tag array. */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != UintptrFromInt32(0) {
					x_free(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = UintptrFromInt32(0)
				/* If there were any tags, allocate an array and fill it. */
				if i+j > int32(0) {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = _default_malloc(tls, uint64(4)*uint64(i+j+Int32FromInt32(1)))
					if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0) {
						return int32(m_REG_ESPACE)
					}
					i = int32(0)
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= int32(0) {
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4))
							i++
						}
					}
					l = i
					j = int32(0)
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= int32(0) {
							/* Don't add duplicates. */
							dup = int32(0)
							for k = int32(0); k < i; k++ {
								if *(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(k)*4)) == *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) {
									dup = int32(1)
									break
								}
							}
							if !(dup != 0) {
								v6 = l
								l++
								*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(v6)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4))
							}
							j++
						}
					}
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(l)*4)) = -int32(1)
				}
				p2 += 56
			}
			p1 += 56
		}
	} else {
		/* Compute a maximum limit for the number of transitions leaving
		   from each state. */
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= int32(0) {
			p2 = orig_p2
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= int32(0) {
				*(*int32)(unsafe.Pointer(counts + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4))++
				p2 += 56
			}
			p1 += 56
		}
	}
	return int32(m_REG_OK)
}

var ___func__46 = [15]int8{'t', 'r', 'e', '_', 'm', 'a', 'k', 'e', '_', 't', 'r', 'a', 'n', 's'}

// C documentation
//
//	/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
//	   labelled with one character range (there are no transitions on empty
//	   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
//	   the regexp. */
func _tre_ast_to_tnfa(tls *TLS, node uintptr, transitions uintptr, counts uintptr, offs uintptr) (r Treg_errcode_t) {
	var cat uintptr
	var errcode Treg_errcode_t
	var iter uintptr
	var uni uintptr
	var v1 bool
	var v2 bool
	errcode = int32(m_REG_OK)
	/* XXX - recurse using a stack!. */
	switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
	case int32(_LITERAL):
	case int32(_UNION):
		uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, transitions, counts, offs)
		if errcode != int32(m_REG_OK) {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright, transitions, counts, offs)
		break
		fallthrough
	case int32(_CATENATION):
		cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		/* Add a transition from each position in cat->left->lastpos
		to each position in cat->right->firstpos. */
		errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, transitions, counts, offs)
		if errcode != int32(m_REG_OK) {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, transitions, counts, offs)
		if errcode != int32(m_REG_OK) {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, transitions, counts, offs)
		break
		fallthrough
	case int32(_ITERATION):
		iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		if v1 = (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == -int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == int32(1); !v1 {
			___assert_fail(tls, ts+2833, ts+2493, int32(2661), uintptr(unsafe.Pointer(&___func__47)))
		}
		_ = v1 || Int32FromInt32(0) != 0
		if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == -int32(1) {
			if v2 = (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == int32(0) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == int32(1); !v2 {
				___assert_fail(tls, ts+2867, ts+2493, int32(2665), uintptr(unsafe.Pointer(&___func__47)))
			}
			_ = v2 || Int32FromInt32(0) != 0
			/* Add a transition from each last position in the iterated
			   expression to each first position. */
			errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos, transitions, counts, offs)
			if errcode != int32(m_REG_OK) {
				return errcode
			}
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, transitions, counts, offs)
		break
	}
	return errcode
}

var ___func__47 = [16]int8{'t', 'r', 'e', '_', 'a', 's', 't', '_', 't', 'o', '_', 't', 'n', 'f', 'a'}

func x_regcomp(tls *TLS, preg uintptr, regex uintptr, cflags int32) (r int32) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxValist 0 */
	defer tls.Free(56)
	var add int32
	var counts uintptr
	var errcode Treg_errcode_t
	var i int32
	var initial uintptr
	var j int32
	var mem Ttre_mem_t
	var offs uintptr
	var p uintptr
	var stack uintptr
	var submatch_data uintptr
	var tag_directions uintptr
	var tmp_ast_l uintptr
	var tmp_ast_r uintptr
	var tnfa uintptr
	var transitions uintptr
	var tree uintptr
	var _ /* parse_ctx at bp+0 */ Ttre_parse_ctx_t
	var v1 int32
	var v2 uintptr
	counts = UintptrFromInt32(0)
	offs = UintptrFromInt32(0)
	add = int32(0)
	tnfa = UintptrFromInt32(0)
	tag_directions = UintptrFromInt32(0)
	/* Parse context. */
	/* Allocate a stack used throughout the compilation process for various
	   purposes. */
	stack = _tre_stack_new(tls, int32(512), int32(1024000), int32(128))
	if !(stack != 0) {
		return int32(m_REG_ESPACE)
	}
	/* Allocate a fast memory allocator. */
	mem = x___tre_mem_new_impl(tls, int32(0), UintptrFromInt32(0))
	if !(mem != 0) {
		_tre_stack_destroy(tls, stack)
		return int32(m_REG_ESPACE)
	}
	/* Parse the regexp. */
	x_memset(tls, bp, int32(0), uint64(56))
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmem = mem
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fstack = stack
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fstart = regex
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fcflags = cflags
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref = -int32(1)
	errcode = _tre_parse(tls, bp)
	if errcode != int32(m_REG_OK) {
		{
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	(*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub = uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id - int32(1))
	tree = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fn
	/* Referring to nonexistent subexpressions is illegal. */
	if (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref > int32((*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub) {
		{
			errcode = int32(6)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	/* Allocate the TNFA struct. */
	tnfa = x_calloc(tls, uint64(1), uint64(104))
	if tnfa == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs = BoolInt32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref >= int32(0))
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_approx = int32(0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches = uint32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id)
	/* Set up tags for submatch addressing.  If REG_NOSUB is set and the
	   regexp does not have back references, this can be skipped. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 || !(cflags&Int32FromInt32(m_REG_NOSUB) != 0) {
		/* Figure out how many tags we will need. */
		errcode = _tre_add_tags(tls, UintptrFromInt32(0), stack, tree, tnfa)
		if errcode != int32(m_REG_OK) {
			{
				errcode = errcode
				if int32(1) != 0 {
					goto error_exit
				}
			}
		}
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > int32(0) {
			tag_directions = _default_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
			if tag_directions == UintptrFromInt32(0) {
				{
					errcode = int32(12)
					if int32(1) != 0 {
						goto error_exit
					}
				}
			}
			(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions = tag_directions
			x_memset(tls, tag_directions, -int32(1), uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
		}
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags = x_calloc(tls, uint64(uint32((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags)*uint32(2)+uint32(1)), uint64(4))
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags == UintptrFromInt32(0) {
			{
				errcode = int32(12)
				if int32(1) != 0 {
					goto error_exit
				}
			}
		}
		submatch_data = x_calloc(tls, uint64(uint32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id)), uint64(16))
		if submatch_data == UintptrFromInt32(0) {
			{
				errcode = int32(12)
				if int32(1) != 0 {
					goto error_exit
				}
			}
		}
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data = submatch_data
		errcode = _tre_add_tags(tls, mem, stack, tree, tnfa)
		if errcode != int32(m_REG_OK) {
			{
				errcode = errcode
				if int32(1) != 0 {
					goto error_exit
				}
			}
		}
	}
	/* Expand iteration nodes. */
	errcode = _tre_expand_ast(tls, mem, stack, tree, uintptr(unsafe.Pointer(&(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition)), tag_directions)
	if errcode != int32(m_REG_OK) {
		{
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	/* Add a dummy node for the final state.
	     XXX - For certain patterns this dummy node can be optimized away,
		   for example "a*" or "ab*".	Figure out a simple way to detect
		   this possibility. */
	tmp_ast_l = tree
	v2 = uintptr(unsafe.Pointer(&(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	tmp_ast_r = _tre_ast_new_literal(tls, mem, int32(0), int32(0), v1)
	if tmp_ast_r == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	tree = _tre_ast_new_catenation(tls, mem, tmp_ast_l, tmp_ast_r)
	if tree == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	errcode = _tre_compute_nfl(tls, mem, stack, tree)
	if errcode != int32(m_REG_OK) {
		{
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	counts = _default_malloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if counts == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	offs = _default_malloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if offs == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	for i = int32(0); i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition; i++ {
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = int32(0)
	}
	_tre_ast_to_tnfa(tls, tree, UintptrFromInt32(0), counts, UintptrFromInt32(0))
	add = int32(0)
	for i = int32(0); i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition; i++ {
		*(*int32)(unsafe.Pointer(offs + uintptr(i)*4)) = add
		add = add + (*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) + Int32FromInt32(1))
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = int32(0)
	}
	transitions = x_calloc(tls, uint64(uint32(add)+uint32(1)), uint64(56))
	if transitions == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions = transitions
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	errcode = _tre_ast_to_tnfa(tls, tree, transitions, counts, offs)
	if errcode != int32(m_REG_OK) {
		{
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars = UintptrFromInt32(0)
	p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos
	i = int32(0)
	for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= int32(0) {
		i++
		p += 56
	}
	initial = x_calloc(tls, uint64(uint32(i)+uint32(1)), uint64(56))
	if initial == UintptrFromInt32(0) {
		{
			errcode = int32(12)
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial = initial
	i = int32(0)
	for p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos; (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= int32(0); p += 56 {
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition)*4)))*56
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags = UintptrFromInt32(0)
		/* Copy the arrays p->tags, and p->params, they are allocated
		from a tre_mem object. */
		if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags != 0 {
			for j = int32(0); *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags + uintptr(j)*4)) >= int32(0); j++ {
			}
			(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags = _default_malloc(tls, uint64(4)*uint64(j+Int32FromInt32(1)))
			if !((*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags != 0) {
				{
					errcode = int32(12)
					if int32(1) != 0 {
						goto error_exit
					}
				}
			}
			x_memcpy(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags, (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags, uint64(4)*uint64(j+Int32FromInt32(1)))
		}
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fassertions
		i++
	}
	(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate = UintptrFromInt32(0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*(*Ttre_pos_and_tags_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(tree)).Flastpos + UintptrFromInt32(0)*56))).Fposition)*4)))*56
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags = cflags
	x___tre_mem_destroy(tls, mem)
	_tre_stack_destroy(tls, stack)
	x_free(tls, counts)
	x_free(tls, offs)
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	return int32(m_REG_OK)
error_exit:
	/* Free everything that was allocated and return the error code. */
	x___tre_mem_destroy(tls, mem)
	if stack != UintptrFromInt32(0) {
		_tre_stack_destroy(tls, stack)
	}
	if counts != UintptrFromInt32(0) {
		x_free(tls, counts)
	}
	if offs != UintptrFromInt32(0) {
		x_free(tls, offs)
	}
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	x_regfree(tls, preg)
	return errcode
}

func x_regfree(tls *TLS, preg uintptr) {
	var i uint32
	var tnfa uintptr
	var trans uintptr
	tnfa = (*Tregex_t)(unsafe.Pointer(preg)).F__opaque
	if !(tnfa != 0) {
		return
	}
	for i = uint32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions; i++ {
		if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fstate != 0 {
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Ftags != 0 {
				x_free(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Ftags)
			}
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fneg_classes != 0 {
				x_free(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fneg_classes)
			}
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial != 0 {
		for trans = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != 0; trans += 56 {
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0 {
				x_free(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
			}
		}
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data != 0 {
		for i = uint32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches; i++ {
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents != 0 {
				x_free(tls, (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents)
			}
		}
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags != 0 {
		x_free(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags)
	}
	x_free(tls, tnfa)
}

/* Error message strings for error codes listed in `regex.h'.  This list
   needs to be in sync with the codes listed there, naturally. */

/* Converted to single string by Rich Felker to remove the need for
 * data relocations at runtime, 27 Feb 2006. */

var _messages = [1]int8{
	0: int8(ts + 2900)}

func x_regerror(tls *TLS, e int32, preg uintptr, buf uintptr, size Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	var s uintptr
	for s = uintptr(unsafe.Pointer(&_messages)); e != 0 && *(*int8)(unsafe.Pointer(s)) != 0; {
		goto _1
	_1:
		e--
		s = s + uintptr(x_strlen(tls, s)+Uint64FromInt32(1))
	}
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	s = x___lctrans_cur(tls, s)
	return uint64(int32(1) + x_snprintf(tls, buf, size, ts+15, VaList(bp+8, s)))
}

const m_REG_NOMATCH = 1
const m_REG_NOTBOL = 1
const m_REG_NOTEOL = 2
const m_tre_bt_mem_destroy = 0

/***********************************************************************
 from tre-match-utils.h
***********************************************************************/

// C documentation
//
//	/* Returns 1 if `t1' wins `t2', 0 otherwise. */
func _tre_tag_order(tls *TLS, num_tags int32, tag_directions uintptr, t1 uintptr, t2 uintptr) (r int32) {
	var i int32
	for i = int32(0); i < num_tags; i++ {
		if *(*Ttre_tag_direction_t)(unsafe.Pointer(tag_directions + uintptr(i)*4)) == int32(_TRE_TAG_MINIMIZE) {
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) < *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(1)
			}
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) > *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(0)
			}
		} else {
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) > *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(1)
			}
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) < *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(0)
			}
		}
	}
	/*  assert(0);*/
	return int32(0)
}

func _tre_neg_char_classes_match(tls *TLS, classes uintptr, wc Ttre_cint_t, icase int32) (r int32) {
	for *(*Ttre_ctype_t)(unsafe.Pointer(classes)) != Uint64FromInt32(0) {
		if !(icase != 0) && x_iswctype(tls, wc, *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0 || icase != 0 && (x_iswctype(tls, x_towupper(tls, wc), *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0 || x_iswctype(tls, x_towlower(tls, wc), *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0) {
			return int32(1)
		} else {
			classes += 8
		}
	}
	return int32(0) /* No match. */
}

/***********************************************************************
 from tre-match-parallel.c
***********************************************************************/

/*
  This algorithm searches for matches basically by reading characters
  in the searched string one by one, starting at the beginning.	 All
  matching paths in the TNFA are traversed in parallel.	 When two or
  more paths reach the same state, exactly one is chosen according to
  tag ordering rules; if returning submatches is not required it does
  not matter which path is chosen.

  The worst case time required for finding the leftmost and longest
  match, or determining that there is no match, is always linearly
  dependent on the length of the text being searched.

  This algorithm cannot handle TNFAs with back referencing nodes.
  See `tre-match-backtrack.c'.
*/

type Ttre_tnfa_reach_t = struct {
	Fstate uintptr
	Ftags  uintptr
}

type Ttre_reach_pos_t = struct {
	Fpos  Tregoff_t
	Ftags uintptr
}

func _tre_tnfa_run_parallel(tls *TLS, tnfa uintptr, string1 uintptr, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var buf uintptr
	var end int32
	var i int32
	var match_eo Tregoff_t
	var new_match int32
	var num_tags int32
	var pbytes Tsize_t
	var pos Tregoff_t
	var pos_add_next Tregoff_t
	var prev_c Ttre_char_t
	var rbytes Tsize_t
	var reach uintptr
	var reach_i uintptr
	var reach_next uintptr
	var reach_next_i uintptr
	var reach_pos uintptr
	var reg_newline int32
	var reg_notbol int32
	var reg_noteol int32
	var ret Treg_errcode_t
	var skip int32
	var start int32
	var str_byte uintptr
	var tag_i uintptr
	var tbytes Tsize_t
	var tmp_buf uintptr
	var tmp_iptr uintptr
	var tmp_tags uintptr
	var total_bytes Tsize_t
	var trans_i uintptr
	var xbytes Tsize_t
	var _ /* next_c at bp+0 */ Ttre_char_t
	var v1 uint64
	var v2 uint64
	var v3 uint64
	var v4 uint64
	var v5 Tregoff_t
	var v6 Tregoff_t
	var v8 bool
	var v9 int32
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = int32(0)
	*(*Ttre_char_t)(unsafe.Pointer(bp)) = int32(0)
	str_byte = string1
	pos = int64(-int32(1))
	pos_add_next = int64(1)
	reg_notbol = eflags & int32(m_REG_NOTBOL)
	reg_noteol = eflags & int32(m_REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(m_REG_NEWLINE)
	match_eo = int64(-int32(1)) /* end offset of match (-1 if no match found yet) */
	new_match = int32(0)
	tmp_tags = UintptrFromInt32(0)
	if !(match_tags != 0) {
		num_tags = int32(0)
	} else {
		num_tags = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags
	}
	{
		/* Allocate memory for temporary data required for matching.	This needs to
		   be done for every matching operation to be thread safe.  This allocates
		   everything in a single large block with calloc(). */
		/* Ensure that tbytes and xbytes*num_states cannot overflow, and that
		 * they don't contribute more than 1/8 of SIZE_MAX to total_bytes. */
		if uint64(num_tags) > uint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states)) {
			return int32(m_REG_ESPACE)
		}
		/* Likewise check rbytes. */
		if uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states+int32(1)) > Uint64FromUint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(16)) {
			return int32(m_REG_ESPACE)
		}
		/* Likewise check pbytes. */
		if uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states) > Uint64FromUint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(16)) {
			return int32(m_REG_ESPACE)
		}
		/* Compute the length of the block we need. */
		tbytes = uint64(8) * uint64(num_tags)
		rbytes = uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states+Int32FromInt32(1))
		pbytes = uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states)
		xbytes = uint64(8) * uint64(num_tags)
		total_bytes = (Uint64FromInt64(8)-Uint64FromInt32(1))*Uint64FromInt32(4) + (rbytes+xbytes*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))*uint64(2) + tbytes + pbytes
		/* Allocate the memory. */
		buf = x_calloc(tls, total_bytes, uint64(1))
		if buf == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
		/* Get the various pointers within tmp_buf (properly aligned). */
		tmp_tags = buf
		tmp_buf = buf + uintptr(tbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v1 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v1 = uint64(0)
		}
		tmp_buf = tmp_buf + uintptr(v1)
		reach_next = tmp_buf
		tmp_buf = tmp_buf + uintptr(rbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v2 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v2 = uint64(0)
		}
		tmp_buf = tmp_buf + uintptr(v2)
		reach = tmp_buf
		tmp_buf = tmp_buf + uintptr(rbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v3 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v3 = uint64(0)
		}
		tmp_buf = tmp_buf + uintptr(v3)
		reach_pos = tmp_buf
		tmp_buf = tmp_buf + uintptr(pbytes)
		if uint64(int64(tmp_buf))%uint64(8) != 0 {
			v4 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
		} else {
			v4 = uint64(0)
		}
		tmp_buf = tmp_buf + uintptr(v4)
		for i = int32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
			(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach + uintptr(i)*16))).Ftags = tmp_buf
			tmp_buf = tmp_buf + uintptr(xbytes)
			(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next + uintptr(i)*16))).Ftags = tmp_buf
			tmp_buf = tmp_buf + uintptr(xbytes)
		}
	}
	for i = int32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
		(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr(i)*16))).Fpos = int64(-int32(1))
	}
	{
		prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
		pos = pos + pos_add_next
		v5 = int64(x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX)))
		pos_add_next = v5
		if v5 <= int64(0) {
			if pos_add_next < int64(0) {
				ret = int32(m_REG_NOMATCH)
				goto error_exit
			} else {
				pos_add_next++
			}
		}
		str_byte = str_byte + uintptr(pos_add_next)
	}
	pos = int64(0)
	reach_next_i = reach_next
	for int32(1) != 0 {
		/* If no match found yet, add the initial states to `reach_next'. */
		if match_eo < int64(0) {
			trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial
			for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != UintptrFromInt32(0) {
				if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > int64(0) || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOW) != 0 && (prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOW) != 0 && (!(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB) != 0 && (pos != int64(0) && *(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') && BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB_NEG) != 0 && (pos == int64(0) || *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') || BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0))) {
						trans_i += 56
						continue
					}
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
					for i = int32(0); i < num_tags; i++ {
						*(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8)) = int64(-int32(1))
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != 0 {
						for *(*int32)(unsafe.Pointer(tag_i)) >= int32(0) {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*8)) = pos
							}
							tag_i += 4
						}
					}
					if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
						match_eo = pos
						new_match = int32(1)
						for i = int32(0); i < num_tags; i++ {
							*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8))
						}
					}
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
					reach_next_i += 16
				}
				trans_i += 56
			}
			(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
		} else {
			if num_tags == int32(0) || reach_next_i == reach_next {
				/* We have found a match. */
				break
			}
		}
		/* Check for end of string. */
		if !(*(*Ttre_char_t)(unsafe.Pointer(bp)) != 0) {
			break
		}
		{
			prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
			pos = pos + pos_add_next
			v6 = int64(x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX)))
			pos_add_next = v6
			if v6 <= int64(0) {
				if pos_add_next < int64(0) {
					ret = int32(m_REG_NOMATCH)
					goto error_exit
				} else {
					pos_add_next++
				}
			}
			str_byte = str_byte + uintptr(pos_add_next)
		}
		/* Swap `reach' and `reach_next'. */
		reach_i = reach
		reach = reach_next
		reach_next = reach_i
		/* For each state in `reach', weed out states that don't fulfill the
		minimal matching conditions. */
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_minimals != 0 && new_match != 0 {
			new_match = int32(0)
			reach_next_i = reach_next
			for reach_i = reach; (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate != 0; reach_i += 16 {
				skip = int32(0)
				for i = int32(0); *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i)*4)) >= int32(0); {
					end = *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i)*4))
					start = *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i+Int32FromInt32(1))*4))
					if end >= num_tags {
						skip = int32(1)
						break
					} else {
						if *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(start)*8)) == *(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(start)*8)) && *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(end)*8)) < *(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(end)*8)) {
							skip = int32(1)
							break
						}
					}
					goto _7
				_7:
					i = i + Int32FromInt32(2)
				}
				if !(skip != 0) {
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate
					tmp_iptr = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags = tmp_iptr
					reach_next_i += 16
				}
			}
			(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
			/* Swap `reach' and `reach_next'. */
			reach_i = reach
			reach = reach_next
			reach_next = reach_i
		}
		/* For each state in `reach' see if there is a transition leaving with
		the current input symbol to a state not yet in `reach_next', and
		add the destination states to `reach_next'. */
		reach_next_i = reach_next
		for reach_i = reach; (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate != 0; reach_i += 16 {
			for trans_i = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0; trans_i += 56 {
				/* Does this transition match the input symbol? */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_min <= uint32(prev_c) && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_max >= uint32(prev_c) {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > int64(0) || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOW) != 0 && (prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOW) != 0 && (!(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB) != 0 && (pos != int64(0) && *(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') && BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB_NEG) != 0 && (pos == int64(0) || *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') || BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && !((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&Int32FromInt32(m_REG_ICASE) != 0) && !(x_iswctype(tls, uint32(prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE) != 0 && !(x_iswctype(tls, x_towlower(tls, uint32(prev_c)), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) && !(x_iswctype(tls, x_towupper(tls, uint32(prev_c)), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fneg_classes, uint32(prev_c), (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE)) != 0)) {
						continue
					}
					/* Compute the tags after this transition. */
					for i = int32(0); i < num_tags; i++ {
						*(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(i)*8))
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer(tag_i)) >= int32(0) {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*8)) = pos
							}
							tag_i += 4
						}
					}
					if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
						/* Found an unvisited node. */
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
						tmp_iptr = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags = tmp_tags
						tmp_tags = tmp_iptr
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
						if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal && (match_eo == int64(-int32(1)) || num_tags > int32(0) && *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + UintptrFromInt32(0)*8)) <= *(*Tregoff_t)(unsafe.Pointer(match_tags + UintptrFromInt32(0)*8))) {
							match_eo = pos
							new_match = int32(1)
							for i = int32(0); i < num_tags; i++ {
								*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8))
							}
						}
						reach_next_i += 16
					} else {
						if v8 = (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos == pos; !v8 {
							___assert_fail(tls, ts+3186, ts+3226, int32(429), uintptr(unsafe.Pointer(&___func__48)))
						}
						_ = v8 || Int32FromInt32(0) != 0
						/* Another path has also reached this state.  We choose
						the winner by examining the tag values for both
						paths. */
						if _tre_tag_order(tls, num_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tmp_tags, *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))) != 0 {
							/* The new path wins. */
							tmp_iptr = *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))
							*(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags)) = tmp_tags
							if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
								match_eo = pos
								new_match = int32(1)
								for i = int32(0); i < num_tags; i++ {
									*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(i)*8))
								}
							}
							tmp_tags = tmp_iptr
						}
					}
				}
			}
		}
		(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
	}
	*(*Tregoff_t)(unsafe.Pointer(match_end_ofs)) = match_eo
	if match_eo >= int64(0) {
		v9 = int32(m_REG_OK)
	} else {
		v9 = int32(m_REG_NOMATCH)
	}
	ret = v9
error_exit:
	x_free(tls, buf)
	return ret
}

var ___func__48 = [22]int8{'t', 'r', 'e', '_', 't', 'n', 'f', 'a', '_', 'r', 'u', 'n', '_', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l'}

/***********************************************************************
 from tre-match-backtrack.c
***********************************************************************/

/*
  This matcher is for regexps that use back referencing.  Regexp matching
  with back referencing is an NP-complete problem on the number of back
  references.  The easiest way to match them is to use a backtracking
  routine which basically goes through all possible paths in the TNFA
  and chooses the one which results in the best (leftmost and longest)
  match.  This can be spectacularly expensive and may run out of stack
  space, but there really is no better known generic algorithm.	 Quoting
  Henry Spencer from comp.compilers:
  <URL: http://compilers.iecc.com/comparch/article/93-03-102>

    POSIX.2 REs require longest match, which is really exciting to
    implement since the obsolete ("basic") variant also includes
    \<digit>.  I haven't found a better way of tackling this than doing
    a preliminary match using a DFA (or simulation) on a modified RE
    that just replicates subREs for \<digit>, and then doing a
    backtracking match to determine whether the subRE matches were
    right.  This can be rather slow, but I console myself with the
    thought that people who use \<digit> deserve very slow execution.
    (Pun unintentional but very appropriate.)

*/

type Ttre_backtrack_item_t = struct {
	Fpos      Tregoff_t
	Fstr_byte uintptr
	Fstate    uintptr
	Fstate_id int32
	Fnext_c   int32
	Ftags     uintptr
}

type Ttre_backtrack_t = uintptr

type Ttre_backtrack_struct = struct {
	Fitem Ttre_backtrack_item_t
	Fprev uintptr
	Fnext uintptr
}

func _tre_tnfa_run_backtrack(tls *TLS, tnfa uintptr, string1 uintptr, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var bt int32
	var bt_len Tregoff_t
	var empty_br_match int32
	var eo Tregoff_t
	var i int32
	var i1 int32
	var i2 int32
	var i3 int32
	var i4 int32
	var match_eo Tregoff_t
	var mem Ttre_mem_t
	var next_c_start int32
	var next_state uintptr
	var next_tags uintptr
	var pmatch uintptr
	var pos Tregoff_t
	var pos_add_next Tregoff_t
	var pos_start Tregoff_t
	var prev_c Ttre_char_t
	var reg_newline int32
	var reg_notbol int32
	var reg_noteol int32
	var result int32
	var ret int32
	var s Ttre_backtrack_t
	var s1 Ttre_backtrack_t
	var so Tregoff_t
	var stack Ttre_backtrack_t
	var state uintptr
	var states_seen uintptr
	var str_byte uintptr
	var str_byte_start uintptr
	var tags uintptr
	var tmp uintptr
	var tmp1 uintptr
	var trans_i uintptr
	var _ /* next_c at bp+0 */ Ttre_char_t
	var v1 Tregoff_t
	var v10 bool
	var v11 int32
	var v2 uintptr
	var v5 Tregoff_t
	var v6 Tregoff_t
	var v9 uintptr
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = int32(0)
	*(*Ttre_char_t)(unsafe.Pointer(bp)) = int32(0)
	str_byte = string1
	pos = int64(0)
	pos_add_next = int64(1)
	reg_notbol = eflags & int32(m_REG_NOTBOL)
	reg_noteol = eflags & int32(m_REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(m_REG_NEWLINE)
	/* These are used to remember the necessary values of the above
	   variables to return to the position where the current search
	   started from. */
	pos_start = int64(-int32(1))
	/* End offset of best match so far, or -1 if no match found yet. */
	match_eo = int64(-int32(1))
	/* Tag arrays. */
	tags = UintptrFromInt32(0)
	/* Current TNFA state. */
	states_seen = UintptrFromInt32(0)
	/* Memory allocator to for allocating the backtracking stack. */
	mem = x___tre_mem_new_impl(tls, int32(0), UintptrFromInt32(0))
	/* The backtracking stack. */
	pmatch = UintptrFromInt32(0)
	if !(mem != 0) {
		return int32(m_REG_ESPACE)
	}
	stack = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(56))
	if !(stack != 0) {
		ret = int32(m_REG_ESPACE)
		goto error_exit
	}
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev = UintptrFromInt32(0)
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = UintptrFromInt32(0)
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags != 0 {
		tags = _default_malloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
		if !(tags != 0) {
			ret = int32(m_REG_ESPACE)
			goto error_exit
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches != 0 {
		pmatch = _default_malloc(tls, uint64(16)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches))
		if !(pmatch != 0) {
			ret = int32(m_REG_ESPACE)
			goto error_exit
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states != 0 {
		states_seen = _default_malloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))
		if !(states_seen != 0) {
			ret = int32(m_REG_ESPACE)
			goto error_exit
		}
	}
retry:
	{
		for i = int32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i++ {
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i)*8)) = int64(-int32(1))
			if match_tags != 0 {
				*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = int64(-int32(1))
			}
		}
		for i = int32(0); i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states; i++ {
			*(*int32)(unsafe.Pointer(states_seen + uintptr(i)*4)) = int32(0)
		}
	}
	state = UintptrFromInt32(0)
	pos = pos_start
	{
		prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
		pos = pos + pos_add_next
		v1 = int64(x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX)))
		pos_add_next = v1
		if v1 <= int64(0) {
			if pos_add_next < int64(0) {
				ret = int32(m_REG_NOMATCH)
				goto error_exit
			} else {
				pos_add_next++
			}
		}
		str_byte = str_byte + uintptr(pos_add_next)
	}
	pos_start = pos
	next_c_start = *(*Ttre_char_t)(unsafe.Pointer(bp))
	str_byte_start = str_byte
	/* Handle initial states. */
	next_tags = UintptrFromInt32(0)
	for trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0; trans_i += 56 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > int64(0) || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOW) != 0 && (prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOW) != 0 && (!(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB) != 0 && (pos != int64(0) && *(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') && BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB_NEG) != 0 && (pos == int64(0) || *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') || BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0))) {
			continue
		}
		if state == UintptrFromInt32(0) {
			/* Start from this state. */
			state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
			next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
		} else {
			/* Backtrack to this state. */
			{
				if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
					s = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(56))
					if !(s != 0) {
						x___tre_mem_destroy(tls, mem)
						if tags != 0 {
							x_free(tls, tags)
						}
						if pmatch != 0 {
							x_free(tls, pmatch)
						}
						if states_seen != 0 {
							x_free(tls, states_seen)
						}
						return int32(m_REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fprev = stack
					(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fnext = UintptrFromInt32(0)
					(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
					if !((*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags != 0) {
						x___tre_mem_destroy(tls, mem)
						if tags != 0 {
							x_free(tls, tags)
						}
						if pmatch != 0 {
							x_free(tls, pmatch)
						}
						if states_seen != 0 {
							x_free(tls, states_seen)
						}
						return int32(m_REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s
					stack = s
				} else {
					stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
				for i1 = int32(0); i1 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i1++ {
					*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i1)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i1)*8))
				}
			}
			{
				tmp = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
				if tmp != 0 {
					for *(*int32)(unsafe.Pointer(tmp)) >= int32(0) {
						v2 = tmp
						tmp += 4
						*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(v2)))*8)) = pos
					}
				}
			}
		}
	}
	if next_tags != 0 {
		for ; *(*int32)(unsafe.Pointer(next_tags)) >= int32(0); next_tags += 4 {
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(next_tags)))*8)) = pos
		}
	}
	if state == UintptrFromInt32(0) {
		goto backtrack
	}
_4:
	if !(int32(1) != 0) {
		goto _3
	}
	if state == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
		if match_eo < pos || match_eo == pos && match_tags != 0 && _tre_tag_order(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tags, match_tags) != 0 {
			/* This match wins the previous match. */
			match_eo = pos
			if match_tags != 0 {
				for i2 = int32(0); i2 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i2++ {
					*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i2)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i2)*8))
				}
			}
		}
		/* Our TNFAs never have transitions leaving from the final state,
		   so we jump right to backtracking. */
		goto backtrack
	}
	/* Go to the next character in the input string. */
	empty_br_match = int32(0)
	trans_i = state
	if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0 && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_BACKREF) != 0 {
		/* This is a back reference state.  All transitions leaving from
		   this state have the same back reference "assertion".  Instead
		   of reading the next character, we match the back reference. */
		bt = *(*int32)(unsafe.Pointer(&(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fu))
		/* Get the substring we need to match against.  Remember to
		   turn off REG_NOSUB temporarily. */
		_tre_fill_pmatch(tls, uint64(bt+int32(1)), pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & ^Int32FromInt32(m_REG_NOSUB), tnfa, tags, pos)
		so = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_so
		eo = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_eo
		bt_len = eo - so
		result = x_strncmp(tls, string1+uintptr(so), str_byte-uintptr(1), uint64(bt_len))
		if result == int32(0) {
			/* Back reference matched.  Check for infinite loop. */
			if bt_len == int64(0) {
				empty_br_match = int32(1)
			}
			if empty_br_match != 0 && *(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*4)) != 0 {
				goto backtrack
			}
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*4)) = empty_br_match
			/* Advance in input string and resync `prev_c', `next_c'
			and pos. */
			str_byte = str_byte + uintptr(bt_len-Int64FromInt32(1))
			pos = pos + (bt_len - Int64FromInt32(1))
			{
				prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
				pos = pos + pos_add_next
				v5 = int64(x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX)))
				pos_add_next = v5
				if v5 <= int64(0) {
					if pos_add_next < int64(0) {
						ret = int32(m_REG_NOMATCH)
						goto error_exit
					} else {
						pos_add_next++
					}
				}
				str_byte = str_byte + uintptr(pos_add_next)
			}
		} else {
			goto backtrack
		}
	} else {
		/* Check for end of string. */
		if *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') {
			goto backtrack
		}
		/* Read the next character. */
		{
			prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
			pos = pos + pos_add_next
			v6 = int64(x_mbtowc(tls, bp, str_byte, uint64(m_MB_LEN_MAX)))
			pos_add_next = v6
			if v6 <= int64(0) {
				if pos_add_next < int64(0) {
					ret = int32(m_REG_NOMATCH)
					goto error_exit
				} else {
					pos_add_next++
				}
			}
			str_byte = str_byte + uintptr(pos_add_next)
		}
	}
	next_state = UintptrFromInt32(0)
	for trans_i = state; (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0; trans_i += 56 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_min <= uint32(prev_c) && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_max >= uint32(prev_c) {
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOL) != 0 && (pos > int64(0) || reg_notbol != 0) && (prev_c != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_BOW) != 0 && (prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_EOW) != 0 && (!(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB) != 0 && (pos != int64(0) && *(*Ttre_char_t)(unsafe.Pointer(bp)) != int32('\000') && BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_AT_WB_NEG) != 0 && (pos == int64(0) || *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') || BoolInt32(prev_c == int32('_') || x_iswalnum(tls, uint32(prev_c)) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('_') || x_iswalnum(tls, uint32(*(*Ttre_char_t)(unsafe.Pointer(bp)))) != 0)) || ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && !((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&Int32FromInt32(m_REG_ICASE) != 0) && !(x_iswctype(tls, uint32(prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS) != 0 && (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE) != 0 && !(x_iswctype(tls, x_towlower(tls, uint32(prev_c)), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) && !(x_iswctype(tls, x_towupper(tls, uint32(prev_c)), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(m_ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fneg_classes, uint32(prev_c), (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_ICASE)) != 0)) {
				continue
			}
			if next_state == UintptrFromInt32(0) {
				/* First matching transition. */
				next_state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
				next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
			} else {
				/* Second matching transition.  We may need to backtrack here
				   to take this transition instead of the first one, so we
				   push this transition in the backtracking stack so we can
				   jump back here if needed. */
				{
					if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
						s1 = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(56))
						if !(s1 != 0) {
							x___tre_mem_destroy(tls, mem)
							if tags != 0 {
								x_free(tls, tags)
							}
							if pmatch != 0 {
								x_free(tls, pmatch)
							}
							if states_seen != 0 {
								x_free(tls, states_seen)
							}
							return int32(m_REG_ESPACE)
						}
						(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fprev = stack
						(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fnext = UintptrFromInt32(0)
						(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags = x___tre_mem_alloc_impl(tls, mem, int32(0), UintptrFromInt32(0), int32(0), uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
						if !((*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags != 0) {
							x___tre_mem_destroy(tls, mem)
							if tags != 0 {
								x_free(tls, tags)
							}
							if pmatch != 0 {
								x_free(tls, pmatch)
							}
							if states_seen != 0 {
								x_free(tls, states_seen)
							}
							return int32(m_REG_ESPACE)
						}
						(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s1
						stack = s1
					} else {
						stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
					for i3 = int32(0); i3 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i3++ {
						*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i3)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i3)*8))
					}
				}
				{
					for tmp1 = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags; tmp1 != 0 && *(*int32)(unsafe.Pointer(tmp1)) >= int32(0); tmp1 += 4 {
						*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(tmp1)))*8)) = pos
					}
				}
			}
		}
	}
	if !(next_state != UintptrFromInt32(0)) {
		goto _7
	}
	/* Matching transitions were found.  Take the first one. */
	state = next_state
	/* Update the tag values. */
	if next_tags != 0 {
		for *(*int32)(unsafe.Pointer(next_tags)) >= int32(0) {
			v9 = next_tags
			next_tags += 4
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(v9)))*8)) = pos
		}
	}
	goto _8
_7:
backtrack:
	/* A matching transition was not found.  Try to backtrack. */
	if (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev != 0 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate)).Fassertions&int32(m_ASSERT_BACKREF) != 0 {
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id)*4)) = int32(0)
		}
		{
			if v10 = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev != 0; !v10 {
				___assert_fail(tls, ts+3246, ts+3226, int32(882), uintptr(unsafe.Pointer(&___func__49)))
			}
			_ = v10 || Int32FromInt32(0) != 0
			pos = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos
			str_byte = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte
			state = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate
			*(*Ttre_char_t)(unsafe.Pointer(bp)) = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c
			for i4 = int32(0); i4 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags; i4++ {
				*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i4)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i4)*8))
			}
			stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev
		}
	} else {
		if match_eo < int64(0) {
			/* Try starting from a later position in the input string. */
			/* Check for end of string. */
			if *(*Ttre_char_t)(unsafe.Pointer(bp)) == int32('\000') {
				goto _3
			}
			*(*Ttre_char_t)(unsafe.Pointer(bp)) = next_c_start
			str_byte = str_byte_start
			goto retry
		} else {
			goto _3
		}
	}
_8:
	goto _4
_3:
	if match_eo >= int64(0) {
		v11 = int32(m_REG_OK)
	} else {
		v11 = int32(m_REG_NOMATCH)
	}
	ret = v11
	*(*Tregoff_t)(unsafe.Pointer(match_end_ofs)) = match_eo
error_exit:
	x___tre_mem_destroy(tls, mem)
	if tags != 0 {
		x_free(tls, tags)
	}
	if pmatch != 0 {
		x_free(tls, pmatch)
	}
	if states_seen != 0 {
		x_free(tls, states_seen)
	}
	return ret
}

var ___func__49 = [23]int8{'t', 'r', 'e', '_', 't', 'n', 'f', 'a', '_', 'r', 'u', 'n', '_', 'b', 'a', 'c', 'k', 't', 'r', 'a', 'c', 'k'}

/***********************************************************************
 from regexec.c
***********************************************************************/

// C documentation
//
//	/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
//	   endpoint values. */
func _tre_fill_pmatch(tls *TLS, nmatch Tsize_t, pmatch uintptr, cflags int32, tnfa uintptr, tags uintptr, match_eo Tregoff_t) {
	var i uint32
	var j uint32
	var parents uintptr
	var submatch_data uintptr
	var v1 Tregoff_t
	var v2 bool
	var v3 bool
	var v4 Tregoff_t
	i = uint32(0)
	if match_eo >= int64(0) && !(cflags&Int32FromInt32(m_REG_NOSUB) != 0) {
		/* Construct submatch offsets from the tags. */
		submatch_data = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = match_eo
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag)*8))
			}
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = match_eo
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag)*8))
			}
			/* If either of the endpoints were not used, this submatch
			   was not part of the match. */
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so == int64(-int32(1)) || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
				v1 = int64(-Int32FromInt32(1))
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v1
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v1
			}
			i++
		}
		/* Reset all submatches that are not within all of their parent
		submatches. */
		i = uint32(0)
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
				if v2 = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so == int64(-int32(1)); !v2 {
					___assert_fail(tls, ts+3258, ts+3226, int32(967), uintptr(unsafe.Pointer(&___func__50)))
				}
				_ = v2 || Int32FromInt32(0) != 0
			}
			if v3 = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so <= (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo; !v3 {
				___assert_fail(tls, ts+3280, ts+3226, int32(968), uintptr(unsafe.Pointer(&___func__50)))
			}
			_ = v3 || Int32FromInt32(0) != 0
			parents = (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fparents
			if parents != UintptrFromInt32(0) {
				for j = uint32(0); *(*int32)(unsafe.Pointer(parents + uintptr(j)*4)) >= int32(0); j++ {
					if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so < (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_so || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo > (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_eo {
						v4 = int64(-Int32FromInt32(1))
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v4
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v4
					}
				}
			}
			i++
		}
	}
	for uint64(i) < nmatch {
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = int64(-int32(1))
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = int64(-int32(1))
		i++
	}
}

var ___func__50 = [16]int8{'t', 'r', 'e', '_', 'f', 'i', 'l', 'l', '_', 'p', 'm', 'a', 't', 'c', 'h'}

func x_regexec(tls *TLS, preg uintptr, string1 uintptr, nmatch Tsize_t, pmatch uintptr, eflags int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var status Treg_errcode_t
	var tags uintptr
	var tnfa uintptr
	var _ /* eo at bp+0 */ Tregoff_t
	tnfa = (*Tregex_t)(unsafe.Pointer(preg)).F__opaque
	tags = UintptrFromInt32(0)
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(m_REG_NOSUB) != 0 {
		nmatch = uint64(0)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > int32(0) && nmatch > uint64(0) {
		tags = _default_malloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
		if tags == UintptrFromInt32(0) {
			return int32(m_REG_ESPACE)
		}
	}
	/* Dispatch to the appropriate matcher. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 {
		/* The regex has back references, use the backtracking matcher. */
		status = _tre_tnfa_run_backtrack(tls, tnfa, string1, tags, eflags, bp)
	} else {
		/* Exact matching, no back references, use the parallel matcher. */
		status = _tre_tnfa_run_parallel(tls, tnfa, string1, tags, eflags, bp)
	}
	if status == int32(m_REG_OK) {
		/* A match was found, so fill the submatch registers. */
		_tre_fill_pmatch(tls, nmatch, pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags, tnfa, tags, *(*Tregoff_t)(unsafe.Pointer(bp)))
	}
	if tags != 0 {
		x_free(tls, tags)
	}
	return status
}

const m_TRE_MEM_BLOCK_SIZE = 1024

/*
  This memory allocator is for allocating small memory blocks efficiently
  in terms of memory overhead and execution speed.  The allocated blocks
  cannot be freed individually, only all at once.  There can be multiple
  allocators, though.
*/

// C documentation
//
//	/* Returns a new memory allocator or NULL if out of memory. */
func x___tre_mem_new_impl(tls *TLS, provided int32, provided_block uintptr) (r Ttre_mem_t) {
	var mem Ttre_mem_t
	if provided != 0 {
		mem = provided_block
		x_memset(tls, mem, int32(0), uint64(48))
	} else {
		mem = x_calloc(tls, uint64(1), uint64(48))
	}
	if mem == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	return mem
}

// C documentation
//
//	/* Frees the memory allocator and all memory allocated with it. */
func x___tre_mem_destroy(tls *TLS, mem Ttre_mem_t) {
	var l uintptr
	var tmp uintptr
	l = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks
	for l != UintptrFromInt32(0) {
		x_free(tls, (*Ttre_list_t)(unsafe.Pointer(l)).Fdata)
		tmp = (*Ttre_list_t)(unsafe.Pointer(l)).Fnext
		x_free(tls, l)
		l = tmp
	}
	x_free(tls, mem)
}

// C documentation
//
//	/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
//	   allocated block or NULL if an underlying malloc() failed. */
func x___tre_mem_alloc_impl(tls *TLS, mem Ttre_mem_t, provided int32, provided_block uintptr, zero int32, size Tsize_t) (r uintptr) {
	var block_size int32
	var l uintptr
	var ptr uintptr
	var v1 uint64
	var p2 uintptr
	var p3 uintptr
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed != 0 {
		return UintptrFromInt32(0)
	}
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn < size {
		/* We need more memory than is available in the current block.
		Allocate a new block. */
		if provided != 0 {
			if provided_block == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = provided_block
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(m_TRE_MEM_BLOCK_SIZE)
		} else {
			if size*uint64(8) > uint64(m_TRE_MEM_BLOCK_SIZE) {
				block_size = int32(size * uint64(8))
			} else {
				block_size = int32(m_TRE_MEM_BLOCK_SIZE)
			}
			l = _default_malloc(tls, uint64(16))
			if l == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fdata = _default_malloc(tls, uint64(block_size))
			if (*Ttre_list_t)(unsafe.Pointer(l)).Fdata == UintptrFromInt32(0) {
				x_free(tls, l)
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fnext = UintptrFromInt32(0)
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent != UintptrFromInt32(0) {
				(*Ttre_list_t)(unsafe.Pointer((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent)).Fnext = l
			}
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks = l
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent = l
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = (*Ttre_list_t)(unsafe.Pointer(l)).Fdata
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(block_size)
		}
	}
	/* Make sure the next pointer will be aligned. */
	if (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8) != 0 {
		v1 = uint64(8) - (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8)
	} else {
		v1 = uint64(0)
	}
	size = size + v1
	/* Allocate from current block. */
	ptr = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr
	p2 = mem + 16
	*(*uintptr)(unsafe.Pointer(p2)) = *(*uintptr)(unsafe.Pointer(p2)) + uintptr(size)
	p3 = mem + 24
	*(*Tsize_t)(unsafe.Pointer(p3)) = *(*Tsize_t)(unsafe.Pointer(p3)) - size
	/* Set to zero if needed. */
	if zero != 0 {
		x_memset(tls, ptr, int32(0), size)
	}
	return ptr
}

func x_sched_setaffinity(tls *TLS, tid Tpid_t, size Tsize_t, set uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(203), int64(tid), int64(size), int64(set)))))
}

func x_pthread_setaffinity_np(tls *TLS, td Tpthread_t, size Tsize_t, set uintptr) (r int32) {
	return int32(-___syscall3(tls, int64(203), int64((*T__pthread)(unsafe.Pointer(td)).Ftid), int64(size), int64(set)))
}

func _do_getaffinity(tls *TLS, tid Tpid_t, size Tsize_t, set uintptr) (r int32) {
	var ret int64
	ret = ___syscall3(tls, int64(204), int64(tid), int64(size), int64(set))
	if ret < int64(0) {
		return int32(ret)
	}
	if uint64(ret) < size {
		x_memset(tls, set+uintptr(ret), int32(0), size-uint64(ret))
	}
	return int32(0)
}

func x_sched_getaffinity(tls *TLS, tid Tpid_t, size Tsize_t, set uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(_do_getaffinity(tls, tid, size, set))))
}

func x_pthread_getaffinity_np(tls *TLS, td Tpthread_t, size Tsize_t, set uintptr) (r int32) {
	return -_do_getaffinity(tls, (*T__pthread)(unsafe.Pointer(td)).Ftid, size, set)
}

func x___sched_cpucount(tls *TLS, size Tsize_t, set uintptr) (r int32) {
	var cnt Tsize_t
	var i Tsize_t
	var j Tsize_t
	var p uintptr
	cnt = uint64(0)
	p = set
	for i = uint64(0); i < size; i++ {
		for j = uint64(0); j < uint64(8); j++ {
			if int32(*(*uint8)(unsafe.Pointer(p + uintptr(i))))&(int32(1)<<j) != 0 {
				cnt++
			}
		}
	}
	return int32(cnt)
}

func x_sched_get_priority_max(tls *TLS, policy int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(146), int64(policy)))))
}

func x_sched_get_priority_min(tls *TLS, policy int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(147), int64(policy)))))
}

const m_VDSO_GETCPU_SYM = "__vdso_getcpu"
const m_VDSO_GETCPU_VER = "LINUX_2.6"

type Tgetcpu_f = uintptr

func _getcpu_init(tls *TLS, cpu uintptr, node uintptr, unused uintptr) (r int64) {
	var f Tgetcpu_f
	var p uintptr
	var v1 int64
	p = x___vdsosym(tls, ts+3315, ts+3325)
	f = p
	_a_cas_p(tls, uintptr(unsafe.Pointer(&_vdso_func)), __ccgo_fp(_getcpu_init), p)
	if f != 0 {
		v1 = (*(*func(*TLS, uintptr, uintptr, uintptr) int64)(unsafe.Pointer(&struct{ uintptr }{f})))(tls, cpu, node, unused)
	} else {
		v1 = int64(-int32(m_ENOSYS))
	}
	return v1
}

var _vdso_func = uintptr(0)

func init() {
	p := unsafe.Pointer(&_vdso_func)
	*(*uintptr)(unsafe.Add(p, 0)) = __ccgo_fp(_getcpu_init)
}

func x_sched_getcpu(tls *TLS) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var f Tgetcpu_f
	var r int32
	var _ /* cpu at bp+0 */ uint32
	f = _vdso_func
	if f != 0 {
		r = int32((*(*func(*TLS, uintptr, uintptr, uintptr) int64)(unsafe.Pointer(&struct{ uintptr }{f})))(tls, bp, uintptr(0), uintptr(0)))
		if !(r != 0) {
			return int32(*(*uint32)(unsafe.Pointer(bp)))
		}
		if r != -int32(m_ENOSYS) {
			return int32(x___syscall_ret(tls, uint64(r)))
		}
	}
	r = int32(___syscall3(tls, int64(309), int64(bp), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
	if !(r != 0) {
		return int32(*(*uint32)(unsafe.Pointer(bp)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_sched_getparam(tls *TLS, pid Tpid_t, param uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOSYS))))
}

func x_sched_getscheduler(tls *TLS, pid Tpid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOSYS))))
}

func x_sched_rr_get_interval(tls *TLS, pid Tpid_t, ts uintptr) (r int32) {
	/* If reaching this point, it's a 64-bit arch or time64-only
	 * 32-bit arch and we can get result directly into timespec. */
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(148), int64(pid), int64(ts)))))
}

func x_sched_setparam(tls *TLS, pid Tpid_t, param uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOSYS))))
}

func x_sched_setscheduler(tls *TLS, pid Tpid_t, sched int32, param uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOSYS))))
}

func x_sched_yield(tls *TLS) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall0(tls, int64(24)))))
}

const m_MINSIZE = 8

type TACTION = int32

const _FIND = 0
const _ENTER = 1

type TVISIT = int32

const _preorder = 0
const _postorder = 1
const _endorder = 2
const _leaf = 3

type TENTRY = struct {
	Fkey  uintptr
	Fdata uintptr
}

type Tentry = TENTRY

type Thsearch_data = struct {
	F__tab     uintptr
	F__unused1 uint32
	F__unused2 uint32
}

type Tqelem = struct {
	Fq_forw      uintptr
	Fq_back      uintptr
	Fq_data      [1]int8
	F__ccgo_pad3 [7]byte
}

/*
open addressing hash table with 2^n table size
quadratic probing is used in case of hash collision
tab indices and hash are size_t
after resize fails with ENOMEM the state of tab is still usable

with the posix api items cannot be iterated and length cannot be queried
*/

type T__tab = struct {
	Fentries uintptr
	Fmask    Tsize_t
	Fused    Tsize_t
}

var _htab Thsearch_data

func _keyhash(tls *TLS, k uintptr) (r Tsize_t) {
	var h Tsize_t
	var p uintptr
	var v1 uintptr
	p = k
	h = uint64(0)
	for *(*uint8)(unsafe.Pointer(p)) != 0 {
		v1 = p
		p++
		h = uint64(31)*h + uint64(*(*uint8)(unsafe.Pointer(v1)))
	}
	return h
}

func _resize(tls *TLS, nel Tsize_t, htab uintptr) (r int32) {
	var e uintptr
	var i Tsize_t
	var j Tsize_t
	var newe uintptr
	var newsize Tsize_t
	var oldsize Tsize_t
	var oldtab uintptr
	var v2 Tsize_t
	oldsize = (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask + uint64(1)
	oldtab = (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries
	if nel > uint64(-Int32FromInt32(1))/Uint64FromInt32(2)+Uint64FromInt32(1) {
		nel = uint64(-Int32FromInt32(1))/Uint64FromInt32(2) + Uint64FromInt32(1)
	}
	for newsize = uint64(m_MINSIZE); newsize < nel; {
		goto _1
	_1:
		newsize = newsize * Uint64FromInt32(2)
	}
	(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries = x_calloc(tls, newsize, uint64(16))
	if !((*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries != 0) {
		(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries = oldtab
		return int32(0)
	}
	(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask = newsize - uint64(1)
	if !(oldtab != 0) {
		return int32(1)
	}
	for e = oldtab; e < oldtab+uintptr(oldsize)*16; e += 16 {
		if (*TENTRY)(unsafe.Pointer(e)).Fkey != 0 {
			i = _keyhash(tls, (*TENTRY)(unsafe.Pointer(e)).Fkey)
			j = Uint64FromInt32(1)
			for {
				newe = (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries + uintptr(i&(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask)*16
				if !((*TENTRY)(unsafe.Pointer(newe)).Fkey != 0) {
					break
				}
				goto _3
			_3:
				v2 = j
				j++
				i = i + v2
			}
			*(*TENTRY)(unsafe.Pointer(newe)) = *(*TENTRY)(unsafe.Pointer(e))
		}
	}
	x_free(tls, oldtab)
	return int32(1)
}

func x_hcreate(tls *TLS, nel Tsize_t) (r int32) {
	return ___hcreate_r(tls, nel, uintptr(unsafe.Pointer(&_htab)))
}

func x_hdestroy(tls *TLS) {
	___hdestroy_r(tls, uintptr(unsafe.Pointer(&_htab)))
}

func _lookup(tls *TLS, key uintptr, hash Tsize_t, htab uintptr) (r uintptr) {
	var e uintptr
	var i Tsize_t
	var j Tsize_t
	var v1 Tsize_t
	i = hash
	j = Uint64FromInt32(1)
	for {
		e = (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries + uintptr(i&(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask)*16
		if !((*TENTRY)(unsafe.Pointer(e)).Fkey != 0) || x_strcmp(tls, (*TENTRY)(unsafe.Pointer(e)).Fkey, key) == int32(0) {
			break
		}
		goto _2
	_2:
		v1 = j
		j++
		i = i + v1
	}
	return e
}

func x_hsearch(tls *TLS, item TENTRY, action TACTION) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* e at bp+0 */ uintptr
	___hsearch_r(tls, item, action, bp, uintptr(unsafe.Pointer(&_htab)))
	return *(*uintptr)(unsafe.Pointer(bp))
}

func ___hcreate_r(tls *TLS, nel Tsize_t, htab uintptr) (r1 int32) {
	var r int32
	(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = x_calloc(tls, uint64(1), uint64(24))
	if !((*Thsearch_data)(unsafe.Pointer(htab)).F__tab != 0) {
		return int32(0)
	}
	r = _resize(tls, nel, htab)
	if r == int32(0) {
		x_free(tls, (*Thsearch_data)(unsafe.Pointer(htab)).F__tab)
		(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = uintptr(0)
	}
	return r
}

func ___hdestroy_r(tls *TLS, htab uintptr) {
	if (*Thsearch_data)(unsafe.Pointer(htab)).F__tab != 0 {
		x_free(tls, (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries)
	}
	x_free(tls, (*Thsearch_data)(unsafe.Pointer(htab)).F__tab)
	(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = uintptr(0)
}

func ___hsearch_r(tls *TLS, item TENTRY, action TACTION, retval uintptr, htab uintptr) (r int32) {
	var e uintptr
	var hash Tsize_t
	var v1 Tsize_t
	var v2 uintptr
	hash = _keyhash(tls, item.Fkey)
	e = _lookup(tls, item.Fkey, hash, htab)
	if (*TENTRY)(unsafe.Pointer(e)).Fkey != 0 {
		*(*uintptr)(unsafe.Pointer(retval)) = e
		return int32(1)
	}
	if action == int32(_FIND) {
		*(*uintptr)(unsafe.Pointer(retval)) = uintptr(0)
		return int32(0)
	}
	*(*TENTRY)(unsafe.Pointer(e)) = item
	v2 = (*Thsearch_data)(unsafe.Pointer(htab)).F__tab + 16
	*(*Tsize_t)(unsafe.Pointer(v2))++
	v1 = *(*Tsize_t)(unsafe.Pointer(v2))
	if v1 > (*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask-(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask/uint64(4) {
		if !(_resize(tls, uint64(2)*(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fused, htab) != 0) {
			(*T__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fused--
			(*TENTRY)(unsafe.Pointer(e)).Fkey = uintptr(0)
			*(*uintptr)(unsafe.Pointer(retval)) = uintptr(0)
			return int32(0)
		}
		e = _lookup(tls, item.Fkey, hash, htab)
	}
	*(*uintptr)(unsafe.Pointer(retval)) = e
	return int32(1)
}

type Tnode = struct {
	Fnext uintptr
	Fprev uintptr
}

func x_insque(tls *TLS, element uintptr, pred uintptr) {
	var e uintptr
	var p uintptr
	var v1 uintptr
	e = element
	p = pred
	if !(p != 0) {
		v1 = UintptrFromInt32(0)
		(*Tnode)(unsafe.Pointer(e)).Fprev = v1
		(*Tnode)(unsafe.Pointer(e)).Fnext = v1
		return
	}
	(*Tnode)(unsafe.Pointer(e)).Fnext = (*Tnode)(unsafe.Pointer(p)).Fnext
	(*Tnode)(unsafe.Pointer(e)).Fprev = p
	(*Tnode)(unsafe.Pointer(p)).Fnext = e
	if (*Tnode)(unsafe.Pointer(e)).Fnext != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fnext)).Fprev = e
	}
}

func x_remque(tls *TLS, element uintptr) {
	var e uintptr
	e = element
	if (*Tnode)(unsafe.Pointer(e)).Fnext != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fnext)).Fprev = (*Tnode)(unsafe.Pointer(e)).Fprev
	}
	if (*Tnode)(unsafe.Pointer(e)).Fprev != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fprev)).Fnext = (*Tnode)(unsafe.Pointer(e)).Fnext
	}
}

func x_lsearch(tls *TLS, key uintptr, base uintptr, nelp uintptr, width Tsize_t, compar uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3339, int32(8), uintptr(unsafe.Pointer(&___func__51)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__51 = [8]int8{'l', 's', 'e', 'a', 'r', 'c', 'h'}

func x_lfind(tls *TLS, key uintptr, base uintptr, nelp uintptr, width Tsize_t, compar uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3339, int32(14), uintptr(unsafe.Pointer(&___func__52)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__52 = [6]int8{'l', 'f', 'i', 'n', 'd'}

type Tnode1 = struct {
	Fkey         uintptr
	Fa           [2]uintptr
	Fh           int32
	F__ccgo_pad3 [4]byte
}

func x_tdelete(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r uintptr) {
	var a [97]uintptr
	var c int32
	var child uintptr
	var deleted uintptr
	var i int32
	var n uintptr
	var parent uintptr
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 int32
	var v5 int32
	var v6 int32
	var v7 int32
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	i = int32(0)
	/* *a[0] is an arbitrary non-null pointer that is returned when
	   the root node is deleted.  */
	v1 = i
	i++
	a[v1] = rootp
	v2 = i
	i++
	a[v2] = rootp
	for {
		if !(n != 0) {
			return uintptr(0)
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			break
		}
		v3 = i
		i++
		a[v3] = n + 8 + BoolUintptr(c > Int32FromInt32(0))*8
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > Int32FromInt32(0))*8))
	}
	parent = *(*uintptr)(unsafe.Pointer(a[i-int32(2)]))
	if *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(0)*8)) != 0 {
		/* free the preceding node instead of the deleted one.  */
		deleted = n
		v4 = i
		i++
		a[v4] = n + 8 + UintptrFromInt32(0)*8
		n = *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(0)*8))
		for *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(1)*8)) != 0 {
			v5 = i
			i++
			a[v5] = n + 8 + UintptrFromInt32(1)*8
			n = *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(1)*8))
		}
		(*Tnode1)(unsafe.Pointer(deleted)).Fkey = (*Tnode1)(unsafe.Pointer(n)).Fkey
		child = *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(0)*8))
	} else {
		child = *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(1)*8))
	}
	/* freed node has at most one child, move it up and rebalance.  */
	x_free(tls, n)
	i--
	v6 = i
	*(*uintptr)(unsafe.Pointer(a[v6])) = child
	for {
		i--
		v7 = i
		if !(v7 != 0 && x___tsearch_balance(tls, a[i]) != 0) {
			break
		}
	}
	return parent
}

func x_tdestroy(tls *TLS, root uintptr, freekey uintptr) {
	var r uintptr
	r = root
	if r == uintptr(0) {
		return
	}
	x_tdestroy(tls, *(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(0)*8)), freekey)
	x_tdestroy(tls, *(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(1)*8)), freekey)
	if freekey != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{freekey})))(tls, (*Tnode1)(unsafe.Pointer(r)).Fkey)
	}
	x_free(tls, r)
}

func x_tfind(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r uintptr) {
	var c int32
	var n uintptr
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	for {
		if !(n != 0) {
			break
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			break
		}
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > Int32FromInt32(0))*8))
	}
	return n
}

func _height(tls *TLS, n uintptr) (r int32) {
	var v1 int32
	if n != 0 {
		v1 = (*Tnode1)(unsafe.Pointer(n)).Fh
	} else {
		v1 = int32(0)
	}
	return v1
}

func _rot(tls *TLS, p uintptr, x uintptr, dir int32) (r int32) {
	var hx int32
	var hz int32
	var y uintptr
	var z uintptr
	y = *(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8))
	z = *(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8))
	hx = (*Tnode1)(unsafe.Pointer(x)).Fh
	hz = _height(tls, z)
	if hz > _height(tls, *(*uintptr)(unsafe.Pointer(y + 8 + uintptr(dir)*8))) {
		/*
		 *   x
		 *  / \ dir          z
		 * A   y            / 		 *    / \   -->    x   y
		 *   z   D        /|   |		 *  / \          A B   C D
		 * B   C
		 */
		*(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8)) = *(*uintptr)(unsafe.Pointer(z + 8 + BoolUintptr(!(dir != 0))*8))
		*(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8)) = *(*uintptr)(unsafe.Pointer(z + 8 + uintptr(dir)*8))
		*(*uintptr)(unsafe.Pointer(z + 8 + BoolUintptr(!(dir != 0))*8)) = x
		*(*uintptr)(unsafe.Pointer(z + 8 + uintptr(dir)*8)) = y
		(*Tnode1)(unsafe.Pointer(x)).Fh = hz
		(*Tnode1)(unsafe.Pointer(y)).Fh = hz
		(*Tnode1)(unsafe.Pointer(z)).Fh = hz + int32(1)
	} else {
		/*
		 *   x               y
		 *  / \             / 		 * A   y    -->    x   D
		 *    / \         / 		 *   z   D       A   z
		 */
		*(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8)) = z
		*(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8)) = x
		(*Tnode1)(unsafe.Pointer(x)).Fh = hz + int32(1)
		(*Tnode1)(unsafe.Pointer(y)).Fh = hz + int32(2)
		z = y
	}
	*(*uintptr)(unsafe.Pointer(p)) = z
	return (*Tnode1)(unsafe.Pointer(z)).Fh - hx
}

// C documentation
//
//	/* balance *p, return 0 if height is unchanged.  */
func x___tsearch_balance(tls *TLS, p uintptr) (r int32) {
	var h0 int32
	var h1 int32
	var n uintptr
	var old int32
	var v1 int32
	n = *(*uintptr)(unsafe.Pointer(p))
	h0 = _height(tls, *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(0)*8)))
	h1 = _height(tls, *(*uintptr)(unsafe.Pointer(n + 8 + UintptrFromInt32(1)*8)))
	if uint32(h0-h1)+uint32(1) < uint32(3) {
		old = (*Tnode1)(unsafe.Pointer(n)).Fh
		if h0 < h1 {
			v1 = h1 + int32(1)
		} else {
			v1 = h0 + int32(1)
		}
		(*Tnode1)(unsafe.Pointer(n)).Fh = v1
		return (*Tnode1)(unsafe.Pointer(n)).Fh - old
	}
	return _rot(tls, p, n, BoolInt32(h0 < h1))
}

func x_tsearch(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r1 uintptr) {
	var a [96]uintptr
	var c int32
	var i int32
	var n uintptr
	var r uintptr
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 int32
	var v5 int32
	var v6 bool
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	i = int32(0)
	v1 = i
	i++
	a[v1] = rootp
	for {
		if !(n != 0) {
			break
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			return n
		}
		v2 = i
		i++
		a[v2] = n + 8 + BoolUintptr(c > Int32FromInt32(0))*8
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > Int32FromInt32(0))*8))
	}
	r = _default_malloc(tls, uint64(32))
	if !(r != 0) {
		return uintptr(0)
	}
	(*Tnode1)(unsafe.Pointer(r)).Fkey = key
	v3 = UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(1)*8)) = v3
	*(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(0)*8)) = v3
	(*Tnode1)(unsafe.Pointer(r)).Fh = int32(1)
	/* insert new node, rebalance ancestors.  */
	i--
	v4 = i
	*(*uintptr)(unsafe.Pointer(a[v4])) = r
	for {
		if v6 = i != 0; v6 {
			i--
			v5 = i
		}
		if !(v6 && x___tsearch_balance(tls, a[v5]) != 0) {
			break
		}
	}
	return r
}

func _walk(tls *TLS, r uintptr, action uintptr, d int32) {
	if !(r != 0) {
		return
	}
	if (*Tnode1)(unsafe.Pointer(r)).Fh == int32(1) {
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, int32(_leaf), d)
	} else {
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, int32(_preorder), d)
		_walk(tls, *(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(0)*8)), action, d+int32(1))
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, int32(_postorder), d)
		_walk(tls, *(*uintptr)(unsafe.Pointer(r + 8 + UintptrFromInt32(1)*8)), action, d+int32(1))
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, int32(_endorder), d)
	}
}

func x_twalk(tls *TLS, root uintptr, action uintptr) {
	_walk(tls, root, action, int32(0))
}

func x_poll(tls *TLS, fds uintptr, n Tnfds_t, timeout int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(7), int64(fds), int64(n), int64(timeout), int64(0), int64(0), int64(0)))))
}

func x_pselect(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, ts uintptr, mask uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3360, int32(13), uintptr(unsafe.Pointer(&___func__53)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__53 = [8]int8{'p', 's', 'e', 'l', 'e', 'c', 't'}

func x_select(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, tv uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3381, int32(13), uintptr(unsafe.Pointer(&___func__54)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__54 = [7]int8{'s', 'e', 'l', 'e', 'c', 't'}

var _all_mask = [1]uint64{
	0: -Uint64FromUint64(1)}

var _app_mask = [1]uint64{
	0: uint64(0xfffffffc7fffffff)}

func x___block_all_sigs(tls *TLS, set uintptr) {
	___syscall4(tls, int64(14), int64(Int32FromInt32(0)), int64(uintptr(unsafe.Pointer(&_all_mask))), int64(set), int64(Int32FromInt32(65)/Int32FromInt32(8)))
}

func x___block_app_sigs(tls *TLS, set uintptr) {
	___syscall4(tls, int64(14), int64(Int32FromInt32(0)), int64(uintptr(unsafe.Pointer(&_app_mask))), int64(set), int64(Int32FromInt32(65)/Int32FromInt32(8)))
}

func x___restore_sigs(tls *TLS, set uintptr) {
	___syscall4(tls, int64(14), int64(Int32FromInt32(2)), int64(set), int64(Int32FromInt32(0)), int64(Int32FromInt32(65)/Int32FromInt32(8)))
}

func x_getitimer(tls *TLS, which int32, old uintptr) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var r int32
	var _ /* old32 at bp+0 */ [4]int64
	if uint64(8) > uint64(8) {
		r = int32(___syscall2(tls, int64(36), int64(which), int64(bp)))
		if !(r != 0) {
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(0)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)]
		}
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(36), int64(which), int64(old)))))
}

func x_kill(tls *TLS, pid Tpid_t, sig int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(62), int64(pid), int64(sig)))))
}

func x_killpg(tls *TLS, pgid Tpid_t, sig int32) (r int32) {
	if pgid < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return x_kill(tls, -pgid, sig)
}

func x_psiginfo(tls *TLS, si uintptr, msg uintptr) {
	x_psignal(tls, (*Tsiginfo_t)(unsafe.Pointer(si)).Fsi_signo, msg)
}

func x_psignal(tls *TLS, sig int32, msg uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 0 maxValist 3 */
	defer tls.Free(32)
	var __need_unlock int32
	var f uintptr
	var old_errno int32
	var old_locale uintptr
	var old_mode int32
	var s uintptr
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	f = uintptr(unsafe.Pointer(&x___stderr_FILE))
	s = x_strsignal(tls, sig)
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	/* Save stderr's orientation and encoding rule, since psignal is not
	 * permitted to change them. Save errno and restore it if there is no
	 * error since fprintf might change it even on success but psignal is
	 * not permitted to do so. */
	old_locale = (*TFILE)(unsafe.Pointer(f)).Flocale
	old_mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	old_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	if msg != 0 {
		v2 = msg
	} else {
		v2 = ts
	}
	if msg != 0 {
		v3 = ts + 560
	} else {
		v3 = ts
	}
	if x_fprintf(tls, f, ts+1643, VaList(bp+8, v2, v3, s)) >= int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = old_errno
	}
	(*TFILE)(unsafe.Pointer(f)).Fmode = old_mode
	(*TFILE)(unsafe.Pointer(f)).Flocale = old_locale
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
}

func x_raise(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var ret int32
	var _ /* set at bp+0 */ Tsigset_t
	x___block_app_sigs(tls, bp)
	ret = int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid), int64(sig)))))
	x___restore_sigs(tls, bp)
	return ret
}

func x_setitimer(tls *TLS, which int32, new1 uintptr, old uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3401, int32(10), uintptr(unsafe.Pointer(&___func__55)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__55 = [10]int8{'s', 'e', 't', 'i', 't', 'i', 'm', 'e', 'r'}

func x___get_handler_set(tls *TLS, set uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3424, int32(13), uintptr(unsafe.Pointer(&___func__56)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__56 = [18]int8{'_', '_', 'g', 'e', 't', '_', 'h', 'a', 'n', 'd', 'l', 'e', 'r', '_', 's', 'e', 't'}

func x___libc_sigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3424, int32(20), uintptr(unsafe.Pointer(&___func__57)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__57 = [17]int8{'_', '_', 'l', 'i', 'b', 'c', '_', 's', 'i', 'g', 'a', 'c', 't', 'i', 'o', 'n'}

func x___sigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3424, int32(25), uintptr(unsafe.Pointer(&___func__58)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__58 = [12]int8{'_', '_', 's', 'i', 'g', 'a', 'c', 't', 'i', 'o', 'n'}

func x_sigaddset(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	var p1 uintptr
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(m__NSIG)-Int32FromInt32(1)) || uint32(sig)-uint32(32) < uint32(3) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	p1 = set + uintptr(uint64(s/Uint32FromInt32(8))/Uint64FromInt64(8))*8
	*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) | Uint64FromUint64(1)<<(uint64(s)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))
	return int32(0)
}

const m_SS_DISABLE = 2
const m_SS_ONSTACK = 1

func x_sigaltstack(tls *TLS, ss uintptr, old uintptr) (r int32) {
	if ss != 0 {
		if !((*Tstack_t)(unsafe.Pointer(ss)).Fss_flags&Int32FromInt32(m_SS_DISABLE) != 0) && (*Tstack_t)(unsafe.Pointer(ss)).Fss_size < uint64(m_MINSIGSTKSZ) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
			return -int32(1)
		}
		if (*Tstack_t)(unsafe.Pointer(ss)).Fss_flags&int32(m_SS_ONSTACK) != 0 {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
			return -int32(1)
		}
	}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(131), int64(ss), int64(old)))))
}

func x_sigandset(tls *TLS, dest uintptr, left uintptr, right uintptr) (r1 int32) {
	var d uintptr
	var i uint64
	var l uintptr
	var r uintptr
	i = uint64(0)
	d = dest
	l = left
	r = right
	for ; i < uint64(Int32FromInt32(m__NSIG)/Int32FromInt32(8))/Uint64FromInt64(8); i++ {
		*(*uint64)(unsafe.Pointer(d + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(l + uintptr(i)*8)) & *(*uint64)(unsafe.Pointer(r + uintptr(i)*8))
	}
	return int32(0)
}

func x_sigdelset(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	var p1 uintptr
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(m__NSIG)-Int32FromInt32(1)) || uint32(sig)-uint32(32) < uint32(3) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	p1 = set + uintptr(uint64(s/Uint32FromInt32(8))/Uint64FromInt64(8))*8
	*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & ^(Uint64FromUint64(1) << (uint64(s) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1))))
	return int32(0)
}

func x_sigemptyset(tls *TLS, set uintptr) (r int32) {
	*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(0)*8)) = uint64(0)
	if uint64(8) == uint64(4) || int32(m__NSIG) > int32(65) {
		*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(1)*8)) = uint64(0)
	}
	if uint64(8) == uint64(4) && int32(m__NSIG) > int32(65) {
		*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(2)*8)) = uint64(0)
		*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(3)*8)) = uint64(0)
	}
	return int32(0)
}

func x_sigfillset(tls *TLS, set uintptr) (r int32) {
	*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(0)*8)) = uint64(0xfffffffc7fffffff)
	if int32(m__NSIG) > int32(65) {
		*(*uint64)(unsafe.Pointer(set + UintptrFromInt32(1)*8)) = uint64(0xffffffffffffffff)
	}
	return int32(0)
}

func x_sighold(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	x_sigemptyset(tls, bp)
	if x_sigaddset(tls, bp, sig) < int32(0) {
		return -int32(1)
	}
	return x_sigprocmask(tls, int32(m_SIG_BLOCK), bp, uintptr(0))
}

func x_sigignore(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxValist 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	x_sigemptyset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = UintptrFromInt32(1)
	(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags = int32(0)
	return x___sigaction(tls, sig, bp, uintptr(0))
}

func x_siginterrupt(tls *TLS, sig int32, flag int32) (r int32) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxValist 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	var p1 uintptr
	var p2 uintptr
	x___sigaction(tls, sig, uintptr(0), bp)
	if flag != 0 {
		p1 = uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags))
		*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) & ^Int32FromInt32(m_SA_RESTART)
	} else {
		p2 = uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags))
		*(*int32)(unsafe.Pointer(p2)) = *(*int32)(unsafe.Pointer(p2)) | Int32FromInt32(m_SA_RESTART)
	}
	return x___sigaction(tls, sig, bp, uintptr(0))
}

func x_sigisemptyset(tls *TLS, set uintptr) (r int32) {
	var i Tsize_t
	i = uint64(0)
	for ; i < uint64(Int32FromInt32(m__NSIG)/Int32FromInt32(8))/Uint64FromInt64(8); i++ {
		if *(*uint64)(unsafe.Pointer(set + uintptr(i)*8)) != 0 {
			return int32(0)
		}
	}
	return int32(1)
}

func x_sigismember(tls *TLS, set uintptr, sig int32) (r int32) {
	var s uint32
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(m__NSIG)-Int32FromInt32(1)) {
		return int32(0)
	}
	return BoolInt32(!!(*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/Uint32FromInt32(8))/Uint64FromInt64(8))*8))&(Uint64FromUint64(1)<<(uint64(s)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))) != 0))
}

type T__jmp_buf = [8]uint64

type Tjmp_buf = [1]T__jmp_buf_tag

type T__jmp_buf_tag = struct {
	F__jb T__jmp_buf
	F__fl uint64
	F__ss [16]uint64
}

type Tsigjmp_buf = [1]T__jmp_buf_tag

func x_siglongjmp(tls *TLS, buf uintptr, ret int32) {
	_longjmp(tls, buf, ret)
}

func x_signal(tls *TLS, sig int32, func1 uintptr) (r uintptr) {
	bp := tls.Alloc(304) /* tlsAllocs 304 maxValist 0 */
	defer tls.Free(304)
	var _ /* sa at bp+152 */ Tsigaction
	var _ /* sa_old at bp+0 */ Tsigaction
	*(*Tsigaction)(unsafe.Pointer(bp + 152)) = Tsigaction{F__sa_handler: struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	}{Fsa_handler: func1}, Fsa_flags: int32(m_SA_RESTART)}
	if x___sigaction(tls, sig, bp+152, bp) < int32(0) {
		return uintptr(-Int32FromInt32(1))
	}
	return *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler))))
}

func x_sigorset(tls *TLS, dest uintptr, left uintptr, right uintptr) (r1 int32) {
	var d uintptr
	var i uint64
	var l uintptr
	var r uintptr
	i = uint64(0)
	d = dest
	l = left
	r = right
	for ; i < uint64(Int32FromInt32(m__NSIG)/Int32FromInt32(8))/Uint64FromInt64(8); i++ {
		*(*uint64)(unsafe.Pointer(d + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(l + uintptr(i)*8)) | *(*uint64)(unsafe.Pointer(r + uintptr(i)*8))
	}
	return int32(0)
}

func x_sigpause(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	x_sigprocmask(tls, int32(0), uintptr(0), bp)
	x_sigdelset(tls, bp, sig)
	return x_sigsuspend(tls, bp)
}

func x_sigpending(tls *TLS, set uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(127), int64(set), int64(Int32FromInt32(65)/Int32FromInt32(8))))))
}

func x_sigprocmask(tls *TLS, how int32, set uintptr, old uintptr) (r1 int32) {
	var r int32
	r = x_pthread_sigmask(tls, how, set, old)
	if !(r != 0) {
		return r
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = r
	return -int32(1)
}

func x_sigqueue(tls *TLS, pid Tpid_t, sig int32, value Tsigval) (r1 int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var r int32
	var _ /* set at bp+128 */ Tsigset_t
	var _ /* si at bp+0 */ Tsiginfo_t
	x_memset(tls, bp, int32(0), uint64(128))
	(*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo = sig
	(*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_code = -int32(1)
	(*(*struct {
		F__first struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		}
		F__second struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}
	})(unsafe.Pointer(&(*(*Tsiginfo_t)(unsafe.Pointer(bp))).F__si_fields))).F__second.Fsi_value = value
	(*(*struct {
		Fsi_pid Tpid_t
		Fsi_uid Tuid_t
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		F__first struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		}
		F__second struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}
	})(unsafe.Pointer(&(*(*Tsiginfo_t)(unsafe.Pointer(bp))).F__si_fields))).F__first))))).Fsi_uid = x_getuid(tls)
	x___block_app_sigs(tls, bp+128)
	(*(*struct {
		Fsi_pid Tpid_t
		Fsi_uid Tuid_t
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*struct {
		F__first struct {
			F__timer [0]struct {
				Fsi_timerid int32
				Fsi_overrun int32
			}
			F__piduid struct {
				Fsi_pid Tpid_t
				Fsi_uid Tuid_t
			}
		}
		F__second struct {
			F__sigchld [0]struct {
				Fsi_status int32
				Fsi_utime  Tclock_t
				Fsi_stime  Tclock_t
			}
			Fsi_value    Tsigval
			F__ccgo_pad2 [16]byte
		}
	})(unsafe.Pointer(&(*(*Tsiginfo_t)(unsafe.Pointer(bp))).F__si_fields))).F__first))))).Fsi_pid = x_getpid(tls)
	r = int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(129), int64(pid), int64(sig), int64(bp)))))
	x___restore_sigs(tls, bp+128)
	return r
}

const m_SIG_UNBLOCK = 1

func x_sigrelse(tls *TLS, sig int32) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var _ /* mask at bp+0 */ Tsigset_t
	x_sigemptyset(tls, bp)
	if x_sigaddset(tls, bp, sig) < int32(0) {
		return -int32(1)
	}
	return x_sigprocmask(tls, int32(m_SIG_UNBLOCK), bp, uintptr(0))
}

func x___libc_current_sigrtmax(tls *TLS) (r int32) {
	return Int32FromInt32(m__NSIG) - Int32FromInt32(1)
}

func x___libc_current_sigrtmin(tls *TLS) (r int32) {
	return int32(35)
}

func x_sigset(tls *TLS, sig int32, handler uintptr) (r uintptr) {
	bp := tls.Alloc(560) /* tlsAllocs 560 maxValist 0 */
	defer tls.Free(560)
	var _ /* mask at bp+304 */ Tsigset_t
	var _ /* mask_old at bp+432 */ Tsigset_t
	var _ /* sa at bp+0 */ Tsigaction
	var _ /* sa_old at bp+152 */ Tsigaction
	var v1 uintptr
	x_sigemptyset(tls, bp+304)
	if x_sigaddset(tls, bp+304, sig) < int32(0) {
		return uintptr(-Int32FromInt32(1))
	}
	if handler == UintptrFromInt32(2) {
		if x___sigaction(tls, sig, uintptr(0), bp+152) < int32(0) {
			return uintptr(-Int32FromInt32(1))
		}
		if x_sigprocmask(tls, int32(m_SIG_BLOCK), bp+304, bp+432) < int32(0) {
			return uintptr(-Int32FromInt32(1))
		}
	} else {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).F__sa_handler)))) = handler
		(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_flags = int32(0)
		x_sigemptyset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)))
		if x___sigaction(tls, sig, bp, bp+152) < int32(0) {
			return uintptr(-Int32FromInt32(1))
		}
		if x_sigprocmask(tls, int32(m_SIG_UNBLOCK), bp+304, bp+432) < int32(0) {
			return uintptr(-Int32FromInt32(1))
		}
	}
	if x_sigismember(tls, bp+432, sig) != 0 {
		v1 = UintptrFromInt32(2)
	} else {
		v1 = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 152))).F__sa_handler))))
	}
	return v1
}

func x___sigsetjmp_tail(tls *TLS, jb uintptr, ret int32) (r int32) {
	var p uintptr
	var v1 uintptr
	var v2 uintptr
	p = jb + 72
	if ret != 0 {
		v1 = p
	} else {
		v1 = uintptr(0)
	}
	if ret != 0 {
		v2 = uintptr(0)
	} else {
		v2 = p
	}
	___syscall4(tls, int64(14), int64(Int32FromInt32(2)), int64(v1), int64(v2), int64(Int32FromInt32(65)/Int32FromInt32(8)))
	return ret
}

func x_sigsuspend(tls *TLS, mask uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(130), int64(mask), int64(Int32FromInt32(65)/Int32FromInt32(8)), int64(0), int64(0), int64(0), int64(0)))))
}

func _do_sigtimedwait(tls *TLS, mask uintptr, si uintptr, ts uintptr) (r int32) {
	return int32(x___syscall_cp(tls, int64(128), int64(mask), int64(si), int64(ts), int64(Int32FromInt32(65)/Int32FromInt32(8)), int64(0), int64(0)))
}

func x_sigtimedwait(tls *TLS, mask uintptr, si uintptr, timeout uintptr) (r int32) {
	var ret int32
	for cond := true; cond; cond = ret == -int32(m_EINTR) {
		ret = _do_sigtimedwait(tls, mask, si, timeout)
	}
	return int32(x___syscall_ret(tls, uint64(ret)))
}

func x_sigwait(tls *TLS, mask uintptr, sig uintptr) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var _ /* si at bp+0 */ Tsiginfo_t
	if x_sigtimedwait(tls, mask, bp, uintptr(0)) < int32(0) {
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(sig)) = (*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo
	return int32(0)
}

func x_sigwaitinfo(tls *TLS, mask uintptr, si uintptr) (r int32) {
	return x_sigtimedwait(tls, mask, si, uintptr(0))
}

func x___fxstat(tls *TLS, ver int32, fd int32, buf uintptr) (r int32) {
	return x___fstat(tls, fd, buf)
}

func x___fxstatat(tls *TLS, ver int32, fd int32, path uintptr, buf uintptr, flag int32) (r int32) {
	return x___fstatat(tls, fd, path, buf, flag)
}

func x___lxstat(tls *TLS, ver int32, path uintptr, buf uintptr) (r int32) {
	return x_lstat(tls, path, buf)
}

func x___xstat(tls *TLS, ver int32, path uintptr, buf uintptr) (r int32) {
	return x_stat(tls, path, buf)
}

func x___xmknod(tls *TLS, ver int32, path uintptr, mode Tmode_t, dev uintptr) (r int32) {
	return x_mknod(tls, path, mode, *(*Tdev_t)(unsafe.Pointer(dev)))
}

func x___xmknodat(tls *TLS, ver int32, fd int32, path uintptr, mode Tmode_t, dev uintptr) (r int32) {
	return x_mknodat(tls, fd, path, mode, *(*Tdev_t)(unsafe.Pointer(dev)))
}

func x_chmod(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(90), int64(path), int64(mode)))))
}

func x_fchmod(tls *TLS, fd int32, mode Tmode_t) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]int8
	ret = int32(___syscall2(tls, int64(91), int64(fd), int64(mode)))
	if ret != -int32(m_EBADF) || ___syscall2(tls, int64(72), int64(fd), int64(Int32FromInt32(1))) < int64(0) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	x___procfdname(tls, bp, uint32(fd))
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(90), int64(bp), int64(mode)))))
}

const m_ELOOP = 40

func x_fchmodat(tls *TLS, fd int32, path uintptr, mode Tmode_t, flag int32) (r int32) {
	bp := tls.Alloc(176) /* tlsAllocs 176 maxValist 0 */
	defer tls.Free(176)
	var fd2 int32
	var ret int32
	var _ /* proc at bp+144 */ [27]int8
	var _ /* st at bp+0 */ Tstat
	var v1 int32
	if !(flag != 0) {
		return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(268), int64(fd), int64(path), int64(mode), int64(flag)))))
	}
	if flag != int32(m_AT_SYMLINK_NOFOLLOW) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	if x___fstatat(tls, fd, path, bp, flag) != 0 {
		return -int32(1)
	}
	if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFLNK) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EOPNOTSUPP))))
	}
	v1 = int32(___syscall3(tls, int64(257), int64(fd), int64(path), int64(Int32FromInt32(00)|Int32FromInt32(010000000)|Int32FromInt32(0400000)|Int32FromInt32(0400)|Int32FromInt32(02000000))))
	fd2 = v1
	if v1 < int32(0) {
		if fd2 == -int32(m_ELOOP) {
			return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EOPNOTSUPP))))
		}
		return int32(x___syscall_ret(tls, uint64(fd2)))
	}
	x___procfdname(tls, bp+144, uint32(fd2))
	ret = x_stat(tls, bp+144, bp)
	if !(ret != 0) {
		if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(m_S_IFMT) == uint32(m_S_IFLNK) {
			ret = int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EOPNOTSUPP))))
		} else {
			ret = int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(268), int64(-Int32FromInt32(100)), int64(bp+144), int64(mode)))))
		}
	}
	___syscall1(tls, int64(3), int64(fd2))
	return ret
}

const m_AT_EMPTY_PATH = 4096

func x___fstat(tls *TLS, fd int32, st uintptr) (r int32) {
	if fd < int32(0) {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EBADF))))
	}
	return x___fstatat(tls, fd, ts, st, int32(m_AT_EMPTY_PATH))
}

type Tstatx = struct {
	Fstx_mask            Tuint32_t
	Fstx_blksize         Tuint32_t
	Fstx_attributes      Tuint64_t
	Fstx_nlink           Tuint32_t
	Fstx_uid             Tuint32_t
	Fstx_gid             Tuint32_t
	Fstx_mode            Tuint16_t
	Fpad1                Tuint16_t
	Fstx_ino             Tuint64_t
	Fstx_size            Tuint64_t
	Fstx_blocks          Tuint64_t
	Fstx_attributes_mask Tuint64_t
	Fstx_atime           struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_btime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_ctime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_mtime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_rdev_major Tuint32_t
	Fstx_rdev_minor Tuint32_t
	Fstx_dev_major  Tuint32_t
	Fstx_dev_minor  Tuint32_t
	Fspare          [14]Tuint64_t
}

func _fstatat_statx(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var ret int32
	var _ /* stx at bp+0 */ Tstatx
	ret = int32(___syscall5(tls, int64(332), int64(fd), int64(path), int64(flag), int64(Int32FromInt32(0x7ff)), int64(bp)))
	if ret != 0 {
		return ret
	}
	*(*Tstat)(unsafe.Pointer(st)) = Tstat{Fst_dev: uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_dev_major)&Uint64FromUint64(0xfffff000)<<Int32FromInt32(32) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_dev_major)&Uint64FromUint64(0x00000fff)<<Int32FromInt32(8) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_dev_minor)&Uint64FromUint64(0xffffff00)<<Int32FromInt32(12) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_dev_minor)&Uint64FromUint64(0x000000ff), Fst_ino: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_ino, Fst_nlink: uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_nlink), Fst_mode: uint32((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_mode), Fst_uid: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_uid, Fst_gid: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_gid, Fst_rdev: uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_rdev_major)&Uint64FromUint64(0xfffff000)<<Int32FromInt32(32) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_rdev_major)&Uint64FromUint64(0x00000fff)<<Int32FromInt32(8) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_rdev_minor)&Uint64FromUint64(0xffffff00)<<Int32FromInt32(12) | uint64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_rdev_minor)&Uint64FromUint64(0x000000ff), Fst_size: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_size), Fst_blksize: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_blksize), Fst_blocks: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_blocks), Fst_atim: Ttimespec{Ftv_sec: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_atime.Ftv_sec, Ftv_nsec: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_atime.Ftv_nsec)}, Fst_mtim: Ttimespec{Ftv_sec: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_mtime.Ftv_sec, Ftv_nsec: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_mtime.Ftv_nsec)}, Fst_ctim: Ttimespec{Ftv_sec: (*(*Tstatx)(unsafe.Pointer(bp))).Fstx_ctime.Ftv_sec, Ftv_nsec: int64((*(*Tstatx)(unsafe.Pointer(bp))).Fstx_ctime.Ftv_nsec)}}
	return int32(0)
}

type Tkstat = struct {
	Fst_dev        Tdev_t
	Fst_ino        Tino_t
	Fst_nlink      Tnlink_t
	Fst_mode       Tmode_t
	Fst_uid        Tuid_t
	Fst_gid        Tgid_t
	F__pad0        uint32
	Fst_rdev       Tdev_t
	Fst_size       Toff_t
	Fst_blksize    Tblksize_t
	Fst_blocks     Tblkcnt_t
	Fst_atime_sec  int64
	Fst_atime_nsec int64
	Fst_mtime_sec  int64
	Fst_mtime_nsec int64
	Fst_ctime_sec  int64
	Fst_ctime_nsec int64
	F__unused      [3]int64
}

func _fstatat_kstat(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	bp := tls.Alloc(176) /* tlsAllocs 176 maxValist 0 */
	defer tls.Free(176)
	var ret int32
	var _ /* buf at bp+144 */ [27]int8
	var _ /* kst at bp+0 */ Tkstat
	if flag == int32(m_AT_EMPTY_PATH) && fd >= int32(0) && !(*(*int8)(unsafe.Pointer(path)) != 0) {
		ret = int32(___syscall2(tls, int64(5), int64(fd), int64(bp)))
		if ret == -int32(m_EBADF) && ___syscall2(tls, int64(72), int64(fd), int64(Int32FromInt32(1))) >= int64(0) {
			ret = int32(___syscall4(tls, int64(262), int64(fd), int64(path), int64(bp), int64(flag)))
			if ret == -int32(m_EINVAL) {
				x___procfdname(tls, bp+144, uint32(fd))
				ret = int32(___syscall2(tls, int64(4), int64(bp+144), int64(bp)))
			}
		}
	} else {
		if (fd == -int32(100) || int32(*(*int8)(unsafe.Pointer(path))) == int32('/')) && flag == int32(m_AT_SYMLINK_NOFOLLOW) {
			ret = int32(___syscall2(tls, int64(6), int64(path), int64(bp)))
		} else {
			if (fd == -int32(100) || int32(*(*int8)(unsafe.Pointer(path))) == int32('/')) && !(flag != 0) {
				ret = int32(___syscall2(tls, int64(4), int64(path), int64(bp)))
			} else {
				ret = int32(___syscall4(tls, int64(262), int64(fd), int64(path), int64(bp), int64(flag)))
			}
		}
	}
	if ret != 0 {
		return ret
	}
	*(*Tstat)(unsafe.Pointer(st)) = Tstat{Fst_dev: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_dev, Fst_ino: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ino, Fst_nlink: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_nlink, Fst_mode: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mode, Fst_uid: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_uid, Fst_gid: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_gid, Fst_rdev: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_rdev, Fst_size: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_size, Fst_blksize: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_blksize, Fst_blocks: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_blocks, Fst_atim: Ttimespec{Ftv_sec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_atime_sec, Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_atime_nsec}, Fst_mtim: Ttimespec{Ftv_sec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mtime_sec, Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mtime_nsec}, Fst_ctim: Ttimespec{Ftv_sec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ctime_sec, Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ctime_nsec}}
	return int32(0)
}

func x___fstatat(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	var ret int32
	if uint64(8) < uint64(8) {
		ret = _fstatat_statx(tls, fd, path, st, flag)
		if ret != -int32(m_ENOSYS) {
			return int32(x___syscall_ret(tls, uint64(ret)))
		}
	}
	ret = _fstatat_kstat(tls, fd, path, st, flag)
	return int32(x___syscall_ret(tls, uint64(ret)))
}

func x_futimens(tls *TLS, fd int32, times uintptr) (r int32) {
	return x_utimensat(tls, fd, uintptr(0), times, int32(0))
}

func x___futimesat(tls *TLS, dirfd int32, pathname uintptr, times uintptr) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var i int32
	var _ /* ts at bp+0 */ [2]Ttimespec
	var v1 uintptr
	if times != 0 {
		for i = int32(0); i < int32(2); i++ {
			if uint64((*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_usec) >= uint64(1000000) {
				return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
			}
			(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[i].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_sec
			(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[i].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_usec * int64(1000)
		}
	}
	if times != 0 {
		v1 = bp
	} else {
		v1 = uintptr(0)
	}
	return x_utimensat(tls, dirfd, pathname, v1, int32(0))
}

func x_lchmod(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	return x_fchmodat(tls, -int32(100), path, mode, int32(m_AT_SYMLINK_NOFOLLOW))
}

func x_lstat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	return x___fstatat(tls, -int32(100), path, buf, int32(m_AT_SYMLINK_NOFOLLOW))
}

func x_mkdir(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(83), int64(path), int64(mode)))))
}

func x_mkdirat(tls *TLS, fd int32, path uintptr, mode Tmode_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(258), int64(fd), int64(path), int64(mode)))))
}

const m_S_IFIFO = 4096

func x_mkfifo(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	return x_mknod(tls, path, mode|uint32(m_S_IFIFO), uint64(0))
}

func x_mkfifoat(tls *TLS, fd int32, path uintptr, mode Tmode_t) (r int32) {
	return x_mknodat(tls, fd, path, mode|uint32(m_S_IFIFO), uint64(0))
}

func x_mknod(tls *TLS, path uintptr, mode Tmode_t, dev Tdev_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(133), int64(path), int64(mode), int64(dev)))))
}

func x_mknodat(tls *TLS, fd int32, path uintptr, mode Tmode_t, dev Tdev_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(259), int64(fd), int64(path), int64(mode), int64(dev)))))
}

func x_stat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	return x___fstatat(tls, -int32(100), path, buf, int32(0))
}

func ___statfs(tls *TLS, path uintptr, buf uintptr) (r int32) {
	*(*Tstatfs)(unsafe.Pointer(buf)) = Tstatfs{}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(137), int64(path), int64(buf)))))
}

func ___fstatfs(tls *TLS, fd int32, buf uintptr) (r int32) {
	*(*Tstatfs)(unsafe.Pointer(buf)) = Tstatfs{}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(138), int64(fd), int64(buf)))))
}

func _fixup(tls *TLS, out uintptr, in uintptr) {
	var v1 uint64
	*(*Tstatvfs)(unsafe.Pointer(out)) = Tstatvfs{}
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bsize = (*Tstatfs)(unsafe.Pointer(in)).Ff_bsize
	if (*Tstatfs)(unsafe.Pointer(in)).Ff_frsize != 0 {
		v1 = (*Tstatfs)(unsafe.Pointer(in)).Ff_frsize
	} else {
		v1 = (*Tstatfs)(unsafe.Pointer(in)).Ff_bsize
	}
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_frsize = v1
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_blocks = (*Tstatfs)(unsafe.Pointer(in)).Ff_blocks
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bfree = (*Tstatfs)(unsafe.Pointer(in)).Ff_bfree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bavail = (*Tstatfs)(unsafe.Pointer(in)).Ff_bavail
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_files = (*Tstatfs)(unsafe.Pointer(in)).Ff_files
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_ffree = (*Tstatfs)(unsafe.Pointer(in)).Ff_ffree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_favail = (*Tstatfs)(unsafe.Pointer(in)).Ff_ffree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_fsid = uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tstatfs)(unsafe.Pointer(in)).Ff_fsid.F__val)) + UintptrFromInt32(0)*4)))
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_flag = (*Tstatfs)(unsafe.Pointer(in)).Ff_flags
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_namemax = (*Tstatfs)(unsafe.Pointer(in)).Ff_namelen
}

func x_statvfs(tls *TLS, path uintptr, buf uintptr) (r int32) {
	bp := tls.Alloc(120) /* tlsAllocs 120 maxValist 0 */
	defer tls.Free(120)
	var _ /* kbuf at bp+0 */ Tstatfs
	if ___statfs(tls, path, bp) < int32(0) {
		return -int32(1)
	}
	_fixup(tls, buf, bp)
	return int32(0)
}

func x_fstatvfs(tls *TLS, fd int32, buf uintptr) (r int32) {
	bp := tls.Alloc(120) /* tlsAllocs 120 maxValist 0 */
	defer tls.Free(120)
	var _ /* kbuf at bp+0 */ Tstatfs
	if ___fstatfs(tls, fd, bp) < int32(0) {
		return -int32(1)
	}
	_fixup(tls, buf, bp)
	return int32(0)
}

func x_umask(tls *TLS, mode Tmode_t) (r Tmode_t) {
	return uint32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(95), int64(mode)))))
}

const m_UTIME_NOW = 1073741823
const m_UTIME_OMIT = 1073741822

func x_utimensat(tls *TLS, fd int32, path uintptr, times uintptr, flags int32) (r1 int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var i int32
	var r int32
	var tv uintptr
	var _ /* tmp at bp+0 */ [4]int64
	if times != 0 && (*(*Ttimespec)(unsafe.Pointer(times + UintptrFromInt32(0)*16))).Ftv_nsec == int64(m_UTIME_NOW) && (*(*Ttimespec)(unsafe.Pointer(times + UintptrFromInt32(1)*16))).Ftv_nsec == int64(m_UTIME_NOW) {
		times = uintptr(0)
	}
	r = int32(___syscall4(tls, int64(280), int64(fd), int64(path), int64(times), int64(flags)))
	if r != -int32(m_ENOSYS) || flags != 0 {
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	tv = uintptr(0)
	if times != 0 {
		tv = bp
		for i = int32(0); i < int32(2); i++ {
			if uint64((*(*Ttimespec)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_nsec) >= uint64(1000000000) {
				if (*(*Ttimespec)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_nsec == int64(m_UTIME_NOW) || (*(*Ttimespec)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_nsec == int64(m_UTIME_OMIT) {
					return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_ENOSYS))))
				}
				return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
			}
			(*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)*i+int32(0)] = (*(*Ttimespec)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_sec
			(*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)*i+int32(1)] = (*(*Ttimespec)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_nsec / int64(1000)
		}
	}
	r = int32(___syscall3(tls, int64(261), int64(fd), int64(path), int64(tv)))
	if r != -int32(m_ENOSYS) || fd != -int32(100) {
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	r = int32(___syscall2(tls, int64(235), int64(path), int64(tv)))
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x___fclose_ca(tls *TLS, f uintptr) (r int32) {
	return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
}

const m_BUFSIZ = 1024
const m_F_APP = 128
const m_F_NORD = 4
const m_F_NOWR = 8
const m_UNGET = 8

func x___fdopen(tls *TLS, fd int32, mode uintptr) (r uintptr) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var f uintptr
	var flags int32
	var _ /* wsz at bp+0 */ Twinsize
	var v1 uintptr
	var v2 int32
	var p3 uintptr
	/* Check for valid initial mode character */
	if !(x_strchr(tls, ts+3447, int32(*(*int8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	/* Allocate FILE+buffer or fail */
	v1 = _default_malloc(tls, Uint64FromInt64(232)+Uint64FromInt32(m_UNGET)+Uint64FromInt32(m_BUFSIZ))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	/* Zero-fill only the struct, not the buffer */
	x_memset(tls, f, int32(0), uint64(232))
	/* Impose mode restrictions */
	if !(x_strchr(tls, mode, int32('+')) != 0) {
		if int32(*(*int8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(m_F_NOWR)
		} else {
			v2 = int32(m_F_NORD)
		}
		(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(v2)
	}
	/* Apply close-on-exec flag */
	if x_strchr(tls, mode, int32('e')) != 0 {
		___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	/* Set append mode on fd if opened for append */
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('a') {
		flags = int32(___syscall2(tls, int64(72), int64(fd), int64(Int32FromInt32(3))))
		if !(flags&Int32FromInt32(m_O_APPEND) != 0) {
			___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(4)), int64(flags|Int32FromInt32(02000)))
		}
		p3 = f
		*(*uint32)(unsafe.Pointer(p3)) = *(*uint32)(unsafe.Pointer(p3)) | Uint32FromInt32(m_F_APP)
	}
	(*TFILE)(unsafe.Pointer(f)).Ffd = fd
	(*TFILE)(unsafe.Pointer(f)).Fbuf = f + uintptr(232) + uintptr(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(m_BUFSIZ)
	/* Activate line buffered mode for terminals */
	(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_NOWR) != 0) && !(___syscall3(tls, int64(16), int64(fd), int64(Int32FromInt32(0x5413)), int64(bp)) != 0) {
		(*TFILE)(unsafe.Pointer(f)).Flbf = int32('\n')
	}
	/* Initialize op ptrs. No problem if some are unneeded. */
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(x___stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fwrite = __ccgo_fp(x___stdio_write)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(x___stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(x___stdio_close)
	if !(x___libc.Fthreaded != 0) {
		(*TFILE)(unsafe.Pointer(f)).Flock = -int32(1)
	}
	/* Add new FILE to open file list */
	return x___ofl_add(tls, f)
}

const m_O_EXCL = 128

func x___fmodeflags(tls *TLS, mode uintptr) (r int32) {
	var flags int32
	if x_strchr(tls, mode, int32('+')) != 0 {
		flags = int32(m_O_RDWR)
	} else {
		if int32(*(*int8)(unsafe.Pointer(mode))) == int32('r') {
			flags = int32(m_O_RDONLY)
		} else {
			flags = int32(m_O_WRONLY)
		}
	}
	if x_strchr(tls, mode, int32('x')) != 0 {
		flags = flags | Int32FromInt32(m_O_EXCL)
	}
	if x_strchr(tls, mode, int32('e')) != 0 {
		flags = flags | Int32FromInt32(m_O_CLOEXEC)
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) != int32('r') {
		flags = flags | Int32FromInt32(m_O_CREAT)
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('w') {
		flags = flags | Int32FromInt32(m_O_TRUNC)
	}
	if int32(*(*int8)(unsafe.Pointer(mode))) == int32('a') {
		flags = flags | Int32FromInt32(m_O_APPEND)
	}
	return flags
}

const m_F_PERM = 1
const m_O_LARGEFILE1 = 524288

func x___fopen_rb_ca(tls *TLS, filename uintptr, f uintptr, buf uintptr, len1 Tsize_t) (r uintptr) {
	x_memset(tls, f, int32(0), uint64(232))
	(*TFILE)(unsafe.Pointer(f)).Ffd = int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(m_SYS_open), int64(filename), int64(Int32FromInt32(00)|Int32FromInt32(02000000)|Int32FromInt32(m_O_LARGEFILE1))))))
	if (*TFILE)(unsafe.Pointer(f)).Ffd < int32(0) {
		return uintptr(0)
	}
	___syscall3(tls, int64(72), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(Int32FromInt32(m_F_NOWR) | Int32FromInt32(m_F_PERM))
	(*TFILE)(unsafe.Pointer(f)).Fbuf = buf + uintptr(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = len1 - uint64(m_UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(x___stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(x___stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(x___stdio_close)
	(*TFILE)(unsafe.Pointer(f)).Flock = -int32(1)
	return f
}

const m_MAYBE_WAITERS = 1073741824

func x___lockfile(tls *TLS, f uintptr) (r int32) {
	var owner int32
	var tid int32
	var v1 int32
	owner = (*TFILE)(unsafe.Pointer(f)).Flock
	tid = (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid
	if owner & ^Int32FromInt32(m_MAYBE_WAITERS) == tid {
		return int32(0)
	}
	owner = _a_cas(tls, f+140, int32(0), tid)
	if !(owner != 0) {
		return int32(1)
	}
	for {
		v1 = _a_cas(tls, f+140, int32(0), tid|int32(m_MAYBE_WAITERS))
		owner = v1
		if !(v1 != 0) {
			break
		}
		if owner&int32(m_MAYBE_WAITERS) != 0 || _a_cas(tls, f+140, owner, owner|int32(m_MAYBE_WAITERS)) == owner {
			___futexwait(tls, f+140, owner|int32(m_MAYBE_WAITERS), int32(1))
		}
	}
	return int32(1)
}

func x___unlockfile(tls *TLS, f uintptr) {
	if _a_swap(tls, f+140, int32(0))&int32(m_MAYBE_WAITERS) != 0 {
		___wake(tls, f+140, int32(1), int32(1))
	}
}

func x___overflow(tls *TLS, f uintptr, _c int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* c at bp+0 */ uint8
	var v1 uint8
	var v2 uintptr
	var v3 uintptr
	*(*uint8)(unsafe.Pointer(bp)) = uint8(_c)
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) && x___towrite(tls, f) != 0 {
		return -int32(1)
	}
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend && int32(*(*uint8)(unsafe.Pointer(bp))) != (*TFILE)(unsafe.Pointer(f)).Flbf {
		v1 = *(*uint8)(unsafe.Pointer(bp))
		v3 = f + 40
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		*(*uint8)(unsafe.Pointer(v2)) = v1
		return int32(v1)
	}
	if (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, bp, uint64(1)) != uint64(1) {
		return -int32(1)
	}
	return int32(*(*uint8)(unsafe.Pointer(bp)))
}

func _dummy13(tls *TLS, fd int32) (r int32) {
	return fd
}

func x___stdio_close(tls *TLS, f uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(3), int64(x___aio_close(tls, (*TFILE)(unsafe.Pointer(f)).Ffd))))))
}

var _dummy_file = uintptr(0)

func _close_file(tls *TLS, f uintptr) {
	if !(f != 0) {
		return
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		x___lockfile(tls, f)
	} else {
		_ = int32(0)
	}
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		(*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Frend), int32(m_SEEK_CUR))
	}
}

func x___stdio_exit(tls *TLS) {
	var f uintptr
	for f = *(*uintptr)(unsafe.Pointer(x___ofl_lock(tls))); f != 0; f = (*TFILE)(unsafe.Pointer(f)).Fnext {
		_close_file(tls, f)
	}
	_close_file(tls, x___stdin_used)
	_close_file(tls, x___stdout_used)
	_close_file(tls, x___stderr_used)
}

const m_F_ERR = 32

func x___stdio_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var cnt Tssize_t
	var _ /* iov at bp+0 */ [2]Tiovec
	var v1 int64
	var v3 int32
	var v4 uintptr
	var v5 uintptr
	var p2 uintptr
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {Fiov_base: buf, Fiov_len: len1 - BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0))},
		1: {Fiov_base: (*TFILE)(unsafe.Pointer(f)).Fbuf, Fiov_len: (*TFILE)(unsafe.Pointer(f)).Fbuf_size}}
	if (*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(0)].Fiov_len != 0 {
		v1 = x___syscall_ret(tls, uint64(___syscall3(tls, int64(19), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(bp), int64(Int32FromInt32(2)))))
	} else {
		v1 = x___syscall_ret(tls, uint64(___syscall3(tls, int64(0), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64((*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_base), int64((*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_len))))
	}
	cnt = v1
	if cnt <= int64(0) {
		p2 = f
		if cnt != 0 {
			v3 = int32(m_F_ERR)
		} else {
			v3 = int32(m_F_EOF)
		}
		*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | uint32(v3)
		return uint64(0)
	}
	if uint64(cnt) <= (*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(0)].Fiov_len {
		return uint64(cnt)
	}
	cnt = Tssize_t(uint64(cnt) - (*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(0)].Fiov_len)
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(cnt)
	if (*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0 {
		v5 = f + 8
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5))++
		*(*uint8)(unsafe.Pointer(buf + uintptr(len1-Uint64FromInt32(1)))) = *(*uint8)(unsafe.Pointer(v4))
	}
	return len1
}

func x___stdio_seek(tls *TLS, f uintptr, off Toff_t, whence int32) (r Toff_t) {
	return x___lseek(tls, (*TFILE)(unsafe.Pointer(f)).Ffd, off, whence)
}

func x___stdio_write(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var cnt Tssize_t
	var iov uintptr
	var iovcnt int32
	var rem Tsize_t
	var _ /* iovs at bp+0 */ [2]Tiovec
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var v5 uint64
	var p4 uintptr
	var p6 uintptr
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {Fiov_base: (*TFILE)(unsafe.Pointer(f)).Fwbase, Fiov_len: uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))},
		1: {Fiov_base: buf, Fiov_len: len1}}
	iov = bp
	rem = (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_len + (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(1)*16))).Fiov_len
	iovcnt = int32(2)
	for {
		cnt = x___syscall_ret(tls, uint64(___syscall3(tls, int64(20), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(iov), int64(iovcnt))))
		if uint64(cnt) == rem {
			(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
			v1 = (*TFILE)(unsafe.Pointer(f)).Fbuf
			(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
			(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
			return len1
		}
		if cnt < int64(0) {
			v3 = UintptrFromInt32(0)
			(*TFILE)(unsafe.Pointer(f)).Fwend = v3
			v2 = v3
			(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
			(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
			p4 = f
			*(*uint32)(unsafe.Pointer(p4)) = *(*uint32)(unsafe.Pointer(p4)) | Uint32FromInt32(m_F_ERR)
			if iovcnt == int32(2) {
				v5 = uint64(0)
			} else {
				v5 = len1 - (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_len
			}
			return v5
		}
		rem = rem - uint64(cnt)
		if uint64(cnt) > (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_len {
			cnt = Tssize_t(uint64(cnt) - (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_len)
			iov += 16
			iovcnt--
		}
		(*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_base = (*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_base + uintptr(cnt)
		p6 = uintptr(unsafe.Pointer(&(*(*Tiovec)(unsafe.Pointer(iov + UintptrFromInt32(0)*16))).Fiov_len))
		*(*Tsize_t)(unsafe.Pointer(p6)) = *(*Tsize_t)(unsafe.Pointer(p6)) - uint64(cnt)
	}
	return r
}

const m_F_SVB = 64

func x___stdout_write(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* wsz at bp+0 */ Twinsize
	(*TFILE)(unsafe.Pointer(f)).Fwrite = __ccgo_fp(x___stdio_write)
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_SVB) != 0) && ___syscall3(tls, int64(16), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(0x5413)), int64(bp)) != 0 {
		(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	}
	return x___stdio_write(tls, f, buf, len1)
}

func x___toread(tls *TLS, f uintptr) (r int32) {
	var v2 uintptr
	var v3 uintptr
	var v5 uintptr
	var v6 int32
	var p1 uintptr
	var p4 uintptr
	p1 = f + 136
	*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
	}
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v3
	v2 = v3
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_NORD) != 0 {
		p4 = f
		*(*uint32)(unsafe.Pointer(p4)) = *(*uint32)(unsafe.Pointer(p4)) | Uint32FromInt32(m_F_ERR)
		return -int32(1)
	}
	v5 = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	(*TFILE)(unsafe.Pointer(f)).Frend = v5
	(*TFILE)(unsafe.Pointer(f)).Frpos = v5
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_EOF) != 0 {
		v6 = -int32(1)
	} else {
		v6 = int32(0)
	}
	return v6
}

func x___toread_needs_stdio_exit(tls *TLS) {
	x___stdio_exit(tls)
}

func x___towrite(tls *TLS, f uintptr) (r int32) {
	var v3 uintptr
	var v4 uintptr
	var p1 uintptr
	var p2 uintptr
	p1 = f + 136
	*(*int32)(unsafe.Pointer(p1)) = *(*int32)(unsafe.Pointer(p1)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_NOWR) != 0 {
		p2 = f
		*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | Uint32FromInt32(m_F_ERR)
		return -int32(1)
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	/* Activate write through the buffer. */
	v4 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v4
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v4
	(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	return int32(0)
}

func x___towrite_needs_stdio_exit(tls *TLS) {
	x___stdio_exit(tls)
}

func x___uflow(tls *TLS, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* c at bp+0 */ uint8
	if !(x___toread(tls, f) != 0) && (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, bp, uint64(1)) == uint64(1) {
		return int32(*(*uint8)(unsafe.Pointer(bp)))
	}
	return -int32(1)
}

func x_asprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vasprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func x_clearerr(tls *TLS, f uintptr) {
	var __need_unlock int32
	var v1 int32
	var p2 uintptr
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	p2 = f
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) & uint32(^(Int32FromInt32(m_F_EOF) | Int32FromInt32(m_F_ERR)))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
}

func x_dprintf(tls *TLS, fd int32, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vdprintf(tls, fd, fmt, ap)
	_ = ap
	return ret
}

func x__flushlbf(tls *TLS) {
	x_fflush(tls, uintptr(0))
}

func x___fsetlocking(tls *TLS, f uintptr, type1 int32) (r int32) {
	return int32(0)
}

func x___fwriting(tls *TLS, f uintptr) (r int32) {
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_NORD) != 0 || (*TFILE)(unsafe.Pointer(f)).Fwend != 0)
}

func x___freading(tls *TLS, f uintptr) (r int32) {
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_NOWR) != 0 || (*TFILE)(unsafe.Pointer(f)).Frend != 0)
}

func x___freadable(tls *TLS, f uintptr) (r int32) {
	return BoolInt32(!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_NORD) != 0))
}

func x___fwritable(tls *TLS, f uintptr) (r int32) {
	return BoolInt32(!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_NOWR) != 0))
}

func x___flbf(tls *TLS, f uintptr) (r int32) {
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Flbf >= int32(0))
}

func x___fbufsize(tls *TLS, f uintptr) (r Tsize_t) {
	return (*TFILE)(unsafe.Pointer(f)).Fbuf_size
}

func x___fpending(tls *TLS, f uintptr) (r Tsize_t) {
	var v1 int64
	if (*TFILE)(unsafe.Pointer(f)).Fwend != 0 {
		v1 = int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase)
	} else {
		v1 = int64(0)
	}
	return uint64(v1)
}

func x___fpurge(tls *TLS, f uintptr) (r int32) {
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	return int32(0)
}

func x___freadahead(tls *TLS, f uintptr) (r Tsize_t) {
	var v1 int64
	if (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		v1 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	} else {
		v1 = int64(0)
	}
	return uint64(v1)
}

func x___freadptr(tls *TLS, f uintptr, sizep uintptr) (r uintptr) {
	if (*TFILE)(unsafe.Pointer(f)).Frpos == (*TFILE)(unsafe.Pointer(f)).Frend {
		return uintptr(0)
	}
	*(*Tsize_t)(unsafe.Pointer(sizep)) = uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
	return (*TFILE)(unsafe.Pointer(f)).Frpos
}

func x___freadptrinc(tls *TLS, f uintptr, inc Tsize_t) {
	var p1 uintptr
	p1 = f + 8
	*(*uintptr)(unsafe.Pointer(p1)) = *(*uintptr)(unsafe.Pointer(p1)) + uintptr(inc)
}

func x___fseterr(tls *TLS, f uintptr) {
	var p1 uintptr
	p1 = f
	*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) | Uint32FromInt32(m_F_ERR)
}

func _dummy14(tls *TLS, f uintptr) {
}

func x_fclose(tls *TLS, f uintptr) (r1 int32) {
	var __need_unlock int32
	var head uintptr
	var r int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	r = x_fflush(tls, f)
	r = r | (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	/* Past this point, f is closed and any further explict access
	 * to it is undefined. However, it still exists as an entry in
	 * the open file list and possibly in the thread's locked files
	 * list, if it was closed while explicitly locked. Functions
	 * which process these lists must tolerate dead FILE objects
	 * (which necessarily have inactive buffer pointers) without
	 * producing any side effects. */
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_PERM) != 0 {
		return r
	}
	x___unlist_locked_file(tls, f)
	head = x___ofl_lock(tls)
	if (*TFILE)(unsafe.Pointer(f)).Fprev != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fprev)).Fnext = (*TFILE)(unsafe.Pointer(f)).Fnext
	}
	if (*TFILE)(unsafe.Pointer(f)).Fnext != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext)).Fprev = (*TFILE)(unsafe.Pointer(f)).Fprev
	}
	if *(*uintptr)(unsafe.Pointer(head)) == f {
		*(*uintptr)(unsafe.Pointer(head)) = (*TFILE)(unsafe.Pointer(f)).Fnext
	}
	x___ofl_unlock(tls)
	x_free(tls, (*TFILE)(unsafe.Pointer(f)).Fgetln_buf)
	x_free(tls, f)
	return r
}

func x_feof(tls *TLS, f uintptr) (r int32) {
	var __need_unlock int32
	var ret int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	ret = BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return ret
}

func x_ferror(tls *TLS, f uintptr) (r int32) {
	var __need_unlock int32
	var ret int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	ret = BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_ERR) != 0))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return ret
}

/* stdout.c will override this if linked */
var _dummy15 = uintptr(0)

func x_fflush(tls *TLS, f uintptr) (r1 int32) {
	var __need_unlock int32
	var __need_unlock1 int32
	var r int32
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	if !(f != 0) {
		r = int32(0)
		if x___stdout_used != 0 {
			r = r | x_fflush(tls, x___stdout_used)
		}
		if x___stderr_used != 0 {
			r = r | x_fflush(tls, x___stderr_used)
		}
		for f = *(*uintptr)(unsafe.Pointer(x___ofl_lock(tls))); f != 0; f = (*TFILE)(unsafe.Pointer(f)).Fnext {
			if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
				v1 = x___lockfile(tls, f)
			} else {
				v1 = int32(0)
			}
			__need_unlock = v1
			if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
				r = r | x_fflush(tls, f)
			}
			{
				if __need_unlock != 0 {
					x___unlockfile(tls, f)
				}
			}
		}
		x___ofl_unlock(tls)
		return r
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v2 = x___lockfile(tls, f)
	} else {
		v2 = int32(0)
	}
	__need_unlock1 = v2
	/* If writing, flush output */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fwpos != 0) {
			{
				if __need_unlock1 != 0 {
					x___unlockfile(tls, f)
				}
			}
			return -int32(1)
		}
	}
	/* If reading, sync position, per POSIX */
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		(*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Frend), int32(m_SEEK_CUR))
	}
	/* Clear read and write modes */
	v4 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v4
	v3 = v4
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
	v5 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v5
	(*TFILE)(unsafe.Pointer(f)).Frpos = v5
	{
		if __need_unlock1 != 0 {
			x___unlockfile(tls, f)
		}
	}
	return int32(0)
}

func x_fgetc(tls *TLS, f uintptr) (r int32) {
	return _do_getc(tls, f)
}

func x_fgetln(tls *TLS, f uintptr, plen uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3451, int32(8), uintptr(unsafe.Pointer(&___func__59)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__59 = [7]int8{'f', 'g', 'e', 't', 'l', 'n'}

func x_fgetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	var off Toff_t
	off = x___ftello(tls, f)
	if off < int64(0) {
		return -int32(1)
	}
	*(*int64)(unsafe.Pointer(pos)) = off
	return int32(0)
}

func x_fgets(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	var __need_unlock int32
	var c int32
	var k Tsize_t
	var p uintptr
	var z uintptr
	var v1 int32
	var v10 int8
	var v11 uintptr
	var v3 int64
	var v4 uint64
	var v6 int32
	var v7 int32
	var v8 uintptr
	var v9 uintptr
	var p2 uintptr
	var p5 uintptr
	p = s
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if n <= int32(1) {
		p2 = f + 136
		*(*int32)(unsafe.Pointer(p2)) = *(*int32)(unsafe.Pointer(p2)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
		{
			if __need_unlock != 0 {
				x___unlockfile(tls, f)
			}
		}
		if n < int32(1) {
			return uintptr(0)
		}
		*(*int8)(unsafe.Pointer(s)) = int8(0)
		return s
	}
	n--
	for n != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			z = x_memchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, int32('\n'), uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
			if z != 0 {
				v3 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
			} else {
				v3 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
			}
			k = uint64(v3)
			if k < uint64(n) {
				v4 = k
			} else {
				v4 = uint64(n)
			}
			k = v4
			x_memcpy(tls, p, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
			p5 = f + 8
			*(*uintptr)(unsafe.Pointer(p5)) = *(*uintptr)(unsafe.Pointer(p5)) + uintptr(k)
			p = p + uintptr(k)
			n = int32(uint64(n) - k)
			if z != 0 || !(n != 0) {
				break
			}
		}
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v9 = f + 8
			v8 = *(*uintptr)(unsafe.Pointer(v9))
			*(*uintptr)(unsafe.Pointer(v9))++
			v7 = int32(*(*uint8)(unsafe.Pointer(v8)))
		} else {
			v7 = x___uflow(tls, f)
		}
		v6 = v7
		c = v6
		if v6 < int32(0) {
			if p == s || !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0) {
				s = uintptr(0)
			}
			break
		}
		n--
		v10 = int8(c)
		v11 = p
		p++
		*(*int8)(unsafe.Pointer(v11)) = v10
		if int32(v10) == int32('\n') {
			break
		}
	}
	if s != 0 {
		*(*int8)(unsafe.Pointer(p)) = int8(0)
	}
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return s
}

func ___fgetwc_unlocked_internal(tls *TLS, f uintptr) (r Twint_t) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var c int32
	var first int32
	var l Tsize_t
	var _ /* b at bp+12 */ uint8
	var _ /* st at bp+4 */ Tmbstate_t
	var _ /* wc at bp+0 */ Twchar_t
	var v2 int32
	var v3 int32
	var v4 uintptr
	var v5 uintptr
	var p1 uintptr
	var p6 uintptr
	var p7 uintptr
	/* Convert character from buffer if possible */
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		l = uint64(x_mbtowc(tls, bp, (*TFILE)(unsafe.Pointer(f)).Frpos, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos))))
		if l+uint64(1) >= uint64(1) {
			p1 = f + 8
			*(*uintptr)(unsafe.Pointer(p1)) = *(*uintptr)(unsafe.Pointer(p1)) + uintptr(l+BoolUint64(!(l != 0))) /* l==0 means 1 byte, null */
			return uint32(*(*Twchar_t)(unsafe.Pointer(bp)))
		}
	}
	/* Convert character byte-by-byte */
	*(*Tmbstate_t)(unsafe.Pointer(bp + 4)) = Tmbstate_t{}
	first = int32(1)
	for cond := true; cond; cond = l == uint64(-Int32FromInt32(2)) {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v5 = f + 8
			v4 = *(*uintptr)(unsafe.Pointer(v5))
			*(*uintptr)(unsafe.Pointer(v5))++
			v3 = int32(*(*uint8)(unsafe.Pointer(v4)))
		} else {
			v3 = x___uflow(tls, f)
		}
		v2 = v3
		c = v2
		*(*uint8)(unsafe.Pointer(bp + 12)) = uint8(v2)
		if c < int32(0) {
			if !(first != 0) {
				p6 = f
				*(*uint32)(unsafe.Pointer(p6)) = *(*uint32)(unsafe.Pointer(p6)) | Uint32FromInt32(m_F_ERR)
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EILSEQ)
			}
			return uint32(0xffffffff)
		}
		l = x_mbrtowc(tls, bp, bp+12, uint64(1), bp+4)
		if l == uint64(-Int32FromInt32(1)) {
			if !(first != 0) {
				p7 = f
				*(*uint32)(unsafe.Pointer(p7)) = *(*uint32)(unsafe.Pointer(p7)) | Uint32FromInt32(m_F_ERR)
				x_ungetc(tls, int32(*(*uint8)(unsafe.Pointer(bp + 12))), f)
			}
			return uint32(0xffffffff)
		}
		first = int32(0)
	}
	return uint32(*(*Twchar_t)(unsafe.Pointer(bp)))
}

func x___fgetwc_unlocked(tls *TLS, f uintptr) (r Twint_t) {
	var loc Tlocale_t
	var ploc uintptr
	var wc Twchar_t
	ploc = ___get_tp(tls) + 168
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= int32(0) {
		x_fwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	wc = int32(___fgetwc_unlocked_internal(tls, f))
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return uint32(wc)
}

func x_fgetwc(tls *TLS, f uintptr) (r Twint_t) {
	var __need_unlock int32
	var c Twint_t
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	c = x___fgetwc_unlocked(tls, f)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return c
}

func x_fgetws(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	var __need_unlock int32
	var c Twint_t
	var p uintptr
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 uintptr
	p = s
	v1 = n
	n--
	if !(v1 != 0) {
		return s
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v2 = x___lockfile(tls, f)
	} else {
		v2 = int32(0)
	}
	__need_unlock = v2
	for ; n != 0; n-- {
		c = x___fgetwc_unlocked(tls, f)
		if c == uint32(0xffffffff) {
			break
		}
		v3 = p
		p += 4
		*(*Twchar_t)(unsafe.Pointer(v3)) = int32(c)
		if c == uint32('\n') {
			break
		}
	}
	*(*Twchar_t)(unsafe.Pointer(p)) = int32(0)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		p = s
	}
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	if p == s {
		v4 = UintptrFromInt32(0)
	} else {
		v4 = s
	}
	return v4
}

func x_fileno(tls *TLS, f uintptr) (r int32) {
	var __need_unlock int32
	var fd int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	fd = (*TFILE)(unsafe.Pointer(f)).Ffd
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	if fd < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EBADF)
		return -int32(1)
	}
	return fd
}

func x_flockfile(tls *TLS, f uintptr) {
	if !(x_ftrylockfile(tls, f) != 0) {
		return
	}
	x___lockfile(tls, f)
	x___register_locked_file(tls, f, ___get_tp(tls))
}

type Tcookie = struct {
	Fpos         Tsize_t
	Flen1        Tsize_t
	Fsize        Tsize_t
	Fbuf         uintptr
	Fmode        int32
	F__ccgo_pad5 [4]byte
}

type Tmem_FILE = struct {
	Ff   TFILE
	Fc   Tcookie
	Fbuf [1032]uint8
}

func x_fmemopen(tls *TLS, buf uintptr, size Tsize_t, mode uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3470, int32(24), uintptr(unsafe.Pointer(&___func__60)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__60 = [9]int8{'f', 'm', 'e', 'm', 'o', 'p', 'e', 'n'}

const m_O_LARGEFILE2 = 32768

func x_fopen(tls *TLS, filename uintptr, mode uintptr) (r uintptr) {
	var f uintptr
	var fd int32
	var flags int32
	/* Check for valid initial mode character */
	if !(x_strchr(tls, ts+3447, int32(*(*int8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	/* Compute the flags to pass to open() */
	flags = x___fmodeflags(tls, mode)
	fd = int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(m_SYS_open), int64(filename), int64(flags|Int32FromInt32(m_O_LARGEFILE2)), int64(Int32FromInt32(0666))))))
	if fd < int32(0) {
		return uintptr(0)
	}
	if flags&int32(m_O_CLOEXEC) != 0 {
		___syscall3(tls, int64(72), int64(fd), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	f = x___fdopen(tls, fd, mode)
	if f != 0 {
		return f
	}
	___syscall1(tls, int64(3), int64(fd))
	return uintptr(0)
}

type Tfcookie = struct {
	Fcookie  uintptr
	Fiofuncs Tcookie_io_functions_t
}

type Tcookie_FILE = struct {
	Ff   TFILE
	Ffc  Tfcookie
	Fbuf [1032]uint8
}

func _cookieread(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var fc uintptr
	var len2 Tsize_t
	var readlen Tsize_t
	var remain Tsize_t
	var ret Tssize_t
	var v1 Tsize_t
	var v2 uintptr
	var v3 uintptr
	var v5 int32
	var v6 uintptr
	var p4 uintptr
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	ret = int64(-int32(1))
	remain = len1
	readlen = uint64(0)
	len2 = len1 - BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0))
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread != 0) {
		goto bail
	}
	if len2 != 0 {
		ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, buf, len2)
		if ret <= int64(0) {
			goto bail
		}
		readlen = readlen + uint64(ret)
		remain = remain - uint64(ret)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0) || remain > BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0)) {
		return readlen
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, (*TFILE)(unsafe.Pointer(f)).Frpos, (*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	if ret <= int64(0) {
		goto bail
	}
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(ret)
	v1 = readlen
	readlen++
	v3 = f + 8
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uintptr)(unsafe.Pointer(v3))++
	*(*uint8)(unsafe.Pointer(buf + uintptr(v1))) = *(*uint8)(unsafe.Pointer(v2))
	return readlen
bail:
	p4 = f
	if ret == int64(0) {
		v5 = int32(m_F_EOF)
	} else {
		v5 = int32(m_F_ERR)
	}
	*(*uint32)(unsafe.Pointer(p4)) = *(*uint32)(unsafe.Pointer(p4)) | uint32(v5)
	v6 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = v6
	(*TFILE)(unsafe.Pointer(f)).Frpos = v6
	return readlen
}

func _cookiewrite(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var fc uintptr
	var len2 Tsize_t
	var ret Tssize_t
	var v1 uintptr
	var v2 uintptr
	var p3 uintptr
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	len2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fwrite != 0) {
		return len1
	}
	if len2 != 0 {
		(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
		if _cookiewrite(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwpos, len2) < len2 {
			return uint64(0)
		}
	}
	ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fwrite})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, buf, len1)
	if ret < int64(0) {
		v2 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v2
		v1 = v2
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
		p3 = f
		*(*uint32)(unsafe.Pointer(p3)) = *(*uint32)(unsafe.Pointer(p3)) | Uint32FromInt32(m_F_ERR)
		return uint64(0)
	}
	return uint64(ret)
}

func _cookieseek(tls *TLS, f uintptr, _off Toff_t, whence int32) (r Toff_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*Toff_t)(unsafe.Pointer(bp)) = _off
	var fc uintptr
	var res int32
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if uint32(whence) > uint32(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	}
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fseek != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOPNOTSUPP)
		return int64(-int32(1))
	}
	res = (*(*func(*TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fseek})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, bp, whence)
	if res < int32(0) {
		return int64(res)
	}
	return *(*Toff_t)(unsafe.Pointer(bp))
}

func _cookieclose(tls *TLS, f uintptr) (r int32) {
	var fc uintptr
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if (*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fclose1 != 0 {
		return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fclose1})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie)
	}
	return int32(0)
}

func x_fopencookie(tls *TLS, cookie uintptr, mode uintptr, iofuncs Tcookie_io_functions_t) (r uintptr) {
	var f uintptr
	var v1 uintptr
	var v2 int32
	/* Check for valid initial mode character */
	if !(x_strchr(tls, ts+3447, int32(*(*int8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	/* Allocate FILE+fcookie+buffer or fail */
	v1 = _default_malloc(tls, uint64(1304))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	/* Zero-fill only the struct, not the buffer */
	x_memset(tls, f, int32(0), uint64(232))
	/* Impose mode restrictions */
	if !(x_strchr(tls, mode, int32('+')) != 0) {
		if int32(*(*int8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(m_F_NOWR)
		} else {
			v2 = int32(m_F_NORD)
		}
		(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fflags = uint32(v2)
	}
	/* Set up our fcookie */
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ffc.Fcookie = cookie
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ffc.Fiofuncs = iofuncs
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Ffd = -int32(1)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fcookie = f + 232
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fbuf = f + 272 + uintptr(m_UNGET)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fbuf_size = Uint64FromInt64(1032) - Uint64FromInt32(m_UNGET)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Flbf = -int32(1)
	/* Initialize op ptrs. No problem if some are unneeded. */
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fread = __ccgo_fp(_cookieread)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fwrite = __ccgo_fp(_cookiewrite)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fseek = __ccgo_fp(_cookieseek)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fclose1 = __ccgo_fp(_cookieclose)
	/* Add new FILE to open file list */
	return x___ofl_add(tls, f)
}

func x_fprintf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vfprintf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x_fputc(tls *TLS, c int32, f uintptr) (r int32) {
	return _do_putc(tls, c, f)
}

func x_fputs(tls *TLS, s uintptr, f uintptr) (r int32) {
	var l Tsize_t
	l = x_strlen(tls, s)
	return BoolInt32(x_fwrite(tls, s, uint64(1), l, f) == l) - int32(1)
}

func x___fputwc_unlocked(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var l int32
	var loc Tlocale_t
	var ploc uintptr
	var _ /* mbc at bp+0 */ [4]int8
	var v1 int32
	var v2 uint8
	var v3 uintptr
	var v4 uintptr
	var p5 uintptr
	var p6 uintptr
	ploc = ___get_tp(tls) + 168
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= int32(0) {
		x_fwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	if BoolInt32(uint32(c) < uint32(128)) != 0 {
		if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
			v2 = uint8(c)
			v4 = f + 40
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			*(*uint8)(unsafe.Pointer(v3)) = v2
			v1 = int32(v2)
		} else {
			v1 = x___overflow(tls, f, int32(uint8(c)))
		}
		c = v1
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fwpos+uintptr(m_MB_LEN_MAX) < (*TFILE)(unsafe.Pointer(f)).Fwend {
			l = x_wctomb(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, c)
			if l < int32(0) {
				c = Int32FromUint32(0xffffffff)
			} else {
				p5 = f + 40
				*(*uintptr)(unsafe.Pointer(p5)) = *(*uintptr)(unsafe.Pointer(p5)) + uintptr(l)
			}
		} else {
			l = x_wctomb(tls, bp, c)
			if l < int32(0) || x___fwritex(tls, bp, uint64(l), f) < uint64(l) {
				c = Int32FromUint32(0xffffffff)
			}
		}
	}
	if uint32(c) == uint32(0xffffffff) {
		p6 = f
		*(*uint32)(unsafe.Pointer(p6)) = *(*uint32)(unsafe.Pointer(p6)) | Uint32FromInt32(m_F_ERR)
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return uint32(c)
}

func x_fputwc(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	var __need_unlock int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	c = int32(x___fputwc_unlocked(tls, c, f))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return uint32(c)
}

func x_fputws(tls *TLS, _ws uintptr, f uintptr) (r int32) {
	bp := tls.Alloc(1032) /* tlsAllocs 1032 maxValist 0 */
	defer tls.Free(1032)
	*(*uintptr)(unsafe.Pointer(bp)) = _ws
	var __need_unlock int32
	var l Tsize_t
	var loc Tlocale_t
	var ploc uintptr
	var _ /* buf at bp+8 */ [1024]uint8
	var v1 int32
	var v2 Tsize_t
	var v3 bool
	l = uint64(0)
	ploc = ___get_tp(tls) + 168
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	x_fwide(tls, f, int32(1))
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	for {
		if v3 = *(*uintptr)(unsafe.Pointer(bp)) != 0; v3 {
			v2 = x_wcsrtombs(tls, bp+8, bp, uint64(1024), uintptr(0))
			l = v2
		}
		if !(v3 && v2+uint64(1) > uint64(1)) {
			break
		}
		if x___fwritex(tls, bp+8, l, f) < l {
			{
				if __need_unlock != 0 {
					x___unlockfile(tls, f)
				}
			}
			*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
			return -int32(1)
		}
	}
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return int32(l) /* 0 or -1 */
}

func x_fread(tls *TLS, destv uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	var __need_unlock int32
	var dest uintptr
	var k Tsize_t
	var l Tsize_t
	var len1 Tsize_t
	var v1 int32
	var v3 uint64
	var v6 uint64
	var p2 uintptr
	var p4 uintptr
	dest = destv
	len1 = size * nmemb
	l = len1
	if !(size != 0) {
		nmemb = uint64(0)
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	p2 = f + 136
	*(*int32)(unsafe.Pointer(p2)) = *(*int32)(unsafe.Pointer(p2)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		/* First exhaust the buffer. */
		if uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)) < l {
			v3 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
		} else {
			v3 = l
		}
		k = v3
		x_memcpy(tls, dest, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
		p4 = f + 8
		*(*uintptr)(unsafe.Pointer(p4)) = *(*uintptr)(unsafe.Pointer(p4)) + uintptr(k)
		dest = dest + uintptr(k)
		l = l - k
	}
	/* Read the remainder directly */
	for l != 0 {
		if x___toread(tls, f) != 0 {
			v6 = uint64(0)
		} else {
			v6 = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, dest, l)
		}
		k = v6
		if !(k != 0) {
			{
				if __need_unlock != 0 {
					x___unlockfile(tls, f)
				}
			}
			return (len1 - l) / size
		}
		goto _5
	_5:
		l = l - k
		dest = dest + uintptr(k)
	}
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return nmemb
}

func x_freopen(tls *TLS, filename uintptr, mode uintptr, f uintptr) (r uintptr) {
	var __need_unlock int32
	var f2 uintptr
	var fl int32
	var v1 int32
	fl = x___fmodeflags(tls, mode)
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	x_fflush(tls, f)
	if !(filename != 0) {
		if fl&int32(m_O_CLOEXEC) != 0 {
			___syscall3(tls, int64(72), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		}
		fl = fl & ^(Int32FromInt32(m_O_CREAT) | Int32FromInt32(m_O_EXCL) | Int32FromInt32(m_O_CLOEXEC))
		if x___syscall_ret(tls, uint64(___syscall3(tls, int64(72), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(4)), int64(fl)))) < int64(0) {
			goto fail
		}
	} else {
		f2 = x_fopen(tls, filename, mode)
		if !(f2 != 0) {
			goto fail
		}
		if (*TFILE)(unsafe.Pointer(f2)).Ffd == (*TFILE)(unsafe.Pointer(f)).Ffd {
			(*TFILE)(unsafe.Pointer(f2)).Ffd = -int32(1)
		} else {
			if x___dup3(tls, (*TFILE)(unsafe.Pointer(f2)).Ffd, (*TFILE)(unsafe.Pointer(f)).Ffd, fl&int32(m_O_CLOEXEC)) < int32(0) {
				goto fail2
			}
		}
		(*TFILE)(unsafe.Pointer(f)).Fflags = (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_PERM) | (*TFILE)(unsafe.Pointer(f2)).Fflags
		(*TFILE)(unsafe.Pointer(f)).Fread = (*TFILE)(unsafe.Pointer(f2)).Fread
		(*TFILE)(unsafe.Pointer(f)).Fwrite = (*TFILE)(unsafe.Pointer(f2)).Fwrite
		(*TFILE)(unsafe.Pointer(f)).Fseek = (*TFILE)(unsafe.Pointer(f2)).Fseek
		(*TFILE)(unsafe.Pointer(f)).Fclose1 = (*TFILE)(unsafe.Pointer(f2)).Fclose1
		x_fclose(tls, f2)
	}
	(*TFILE)(unsafe.Pointer(f)).Fmode = int32(0)
	(*TFILE)(unsafe.Pointer(f)).Flocale = uintptr(0)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return f
fail2:
	x_fclose(tls, f2)
fail:
	x_fclose(tls, f)
	return UintptrFromInt32(0)
}

func x_fscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vfscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x___fseeko_unlocked(tls *TLS, f uintptr, off Toff_t, whence int32) (r int32) {
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	var p4 uintptr
	/* Fail immediately for invalid whence argument. */
	if whence != int32(m_SEEK_CUR) && whence != int32(m_SEEK_SET) && whence != int32(m_SEEK_END) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	/* Adjust relative offset for unread data in buffer, if any. */
	if whence == int32(m_SEEK_CUR) && (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		off = off - (int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
	}
	/* Flush write buffer, and report error on failure. */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fwpos != 0) {
			return -int32(1)
		}
	}
	/* Leave writing mode */
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
	/* Perform the underlying seek. */
	if (*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, off, whence) < int64(0) {
		return -int32(1)
	}
	/* If seek succeeded, file is seekable and we discard read buffer. */
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	p4 = f
	*(*uint32)(unsafe.Pointer(p4)) = *(*uint32)(unsafe.Pointer(p4)) & uint32(^Int32FromInt32(m_F_EOF))
	return int32(0)
}

func x___fseeko(tls *TLS, f uintptr, off Toff_t, whence int32) (r int32) {
	var __need_unlock int32
	var result int32
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	result = x___fseeko_unlocked(tls, f, off, whence)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return result
}

func x_fseek(tls *TLS, f uintptr, off int64, whence int32) (r int32) {
	return x___fseeko(tls, f, off, whence)
}

func x_fsetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	return x___fseeko(tls, f, *(*int64)(unsafe.Pointer(pos)), int32(m_SEEK_SET))
}

const m_EOVERFLOW = 75

func x___ftello_unlocked(tls *TLS, f uintptr) (r Toff_t) {
	var pos Toff_t
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_APP) != 0 && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		v1 = int32(m_SEEK_END)
	} else {
		v1 = int32(m_SEEK_CUR)
	}
	pos = (*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64(0), v1)
	if pos < int64(0) {
		return pos
	}
	/* Adjust for data in buffer. */
	if (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		pos = pos + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Frend))
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fwbase != 0 {
			pos = pos + (int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
		}
	}
	return pos
}

func x___ftello(tls *TLS, f uintptr) (r Toff_t) {
	var __need_unlock int32
	var pos Toff_t
	var v1 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	pos = x___ftello_unlocked(tls, f)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return pos
}

func x_ftell(tls *TLS, f uintptr) (r int64) {
	var pos Toff_t
	pos = x___ftello(tls, f)
	if pos > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return int64(-int32(1))
	}
	return pos
}

func x___do_orphaned_stdio_locks(tls *TLS) {
	var f uintptr
	for f = (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Fstdio_locks; f != 0; f = (*TFILE)(unsafe.Pointer(f)).Fnext_locked {
		_a_store(tls, f+140, int32(0x40000000))
	}
}

func x___unlist_locked_file(tls *TLS, f uintptr) {
	if (*TFILE)(unsafe.Pointer(f)).Flockcount != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Fnext_locked != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext_locked)).Fprev_locked = (*TFILE)(unsafe.Pointer(f)).Fprev_locked
		}
		if (*TFILE)(unsafe.Pointer(f)).Fprev_locked != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fprev_locked)).Fnext_locked = (*TFILE)(unsafe.Pointer(f)).Fnext_locked
		} else {
			(*T__pthread)(unsafe.Pointer(___get_tp(tls))).Fstdio_locks = (*TFILE)(unsafe.Pointer(f)).Fnext_locked
		}
	}
}

func x___register_locked_file(tls *TLS, f uintptr, self Tpthread_t) {
	(*TFILE)(unsafe.Pointer(f)).Flockcount = int64(1)
	(*TFILE)(unsafe.Pointer(f)).Fprev_locked = uintptr(0)
	(*TFILE)(unsafe.Pointer(f)).Fnext_locked = (*T__pthread)(unsafe.Pointer(self)).Fstdio_locks
	if (*TFILE)(unsafe.Pointer(f)).Fnext_locked != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext_locked)).Fprev_locked = f
	}
	(*T__pthread)(unsafe.Pointer(self)).Fstdio_locks = f
}

func x_ftrylockfile(tls *TLS, f uintptr) (r int32) {
	var owner int32
	var self Tpthread_t
	var tid int32
	var v1 int32
	self = ___get_tp(tls)
	tid = (*T__pthread)(unsafe.Pointer(self)).Ftid
	owner = (*TFILE)(unsafe.Pointer(f)).Flock
	if owner & ^Int32FromInt32(m_MAYBE_WAITERS) == tid {
		if (*TFILE)(unsafe.Pointer(f)).Flockcount == int64(0x7fffffffffffffff) {
			return -int32(1)
		}
		(*TFILE)(unsafe.Pointer(f)).Flockcount++
		return int32(0)
	}
	if owner < int32(0) {
		v1 = Int32FromInt32(0)
		owner = v1
		(*TFILE)(unsafe.Pointer(f)).Flock = v1
	}
	if owner != 0 || _a_cas(tls, f+140, int32(0), tid) != 0 {
		return -int32(1)
	}
	x___register_locked_file(tls, f, self)
	return int32(0)
}

func x_funlockfile(tls *TLS, f uintptr) {
	if (*TFILE)(unsafe.Pointer(f)).Flockcount == int64(1) {
		x___unlist_locked_file(tls, f)
		(*TFILE)(unsafe.Pointer(f)).Flockcount = int64(0)
		x___unlockfile(tls, f)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Flockcount--
	}
}

func x_fwide(tls *TLS, f uintptr, mode int32) (r int32) {
	var __need_unlock int32
	var v1 int32
	var v2 Tlocale_t
	var v3 int32
	var v4 int32
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if mode != 0 {
		if !((*TFILE)(unsafe.Pointer(f)).Flocale != 0) {
			if !!(*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + UintptrFromInt32(m_LC_CTYPE)*8)) != 0) {
				v3 = int32(4)
			} else {
				v3 = int32(1)
			}
			if v3 == int32(1) {
				v2 = uintptr(unsafe.Pointer(&x___c_locale))
			} else {
				v2 = uintptr(unsafe.Pointer(&x___c_dot_utf8_locale))
			}
			(*TFILE)(unsafe.Pointer(f)).Flocale = v2
		}
		if !((*TFILE)(unsafe.Pointer(f)).Fmode != 0) {
			if mode > int32(0) {
				v4 = int32(1)
			} else {
				v4 = -int32(1)
			}
			(*TFILE)(unsafe.Pointer(f)).Fmode = v4
		}
	}
	mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return mode
}

func x_fwprintf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vfwprintf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x___fwritex(tls *TLS, s uintptr, l Tsize_t, f uintptr) (r Tsize_t) {
	var i Tsize_t
	var n Tsize_t
	var p1 uintptr
	i = uint64(0)
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) && x___towrite(tls, f) != 0 {
		return uint64(0)
	}
	if l > uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwend)-int64((*TFILE)(unsafe.Pointer(f)).Fwpos)) {
		return (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, s, l)
	}
	if (*TFILE)(unsafe.Pointer(f)).Flbf >= int32(0) {
		/* Match /^(.*\n|)/ */
		for i = l; i != 0 && int32(*(*uint8)(unsafe.Pointer(s + uintptr(i-Uint64FromInt32(1))))) != int32('\n'); i-- {
		}
		if i != 0 {
			n = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, s, i)
			if n < i {
				return n
			}
			s = s + uintptr(i)
			l = l - i
		}
	}
	x_memcpy(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, s, l)
	p1 = f + 40
	*(*uintptr)(unsafe.Pointer(p1)) = *(*uintptr)(unsafe.Pointer(p1)) + uintptr(l)
	return l + i
}

func x_fwrite(tls *TLS, src uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	var __need_unlock int32
	var k Tsize_t
	var l Tsize_t
	var v1 int32
	var v2 uint64
	l = size * nmemb
	if !(size != 0) {
		nmemb = uint64(0)
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	k = x___fwritex(tls, src, l, f)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	if k == l {
		v2 = nmemb
	} else {
		v2 = k / size
	}
	return v2
}

func x_fwscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vfwscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func x_getc(tls *TLS, f uintptr) (r int32) {
	return _do_getc(tls, f)
}

func x_getc_unlocked(tls *TLS, f uintptr) (r int32) {
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___uflow(tls, f)
	}
	return v1
}

func x_getchar(tls *TLS) (r int32) {
	return _do_getc(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
}

func x_getchar_unlocked(tls *TLS) (r int32) {
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Frpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Frend {
		v3 = uintptr(unsafe.Pointer(&x___stdin_FILE)) + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = x___uflow(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
	}
	return v1
}

func x_getdelim(tls *TLS, s uintptr, n uintptr, delim int32, f uintptr) (r Tssize_t) {
	var __need_unlock int32
	var c int32
	var i Tsize_t
	var k Tsize_t
	var m Tsize_t
	var tmp uintptr
	var z uintptr
	var v1 int32
	var v10 int32
	var v11 uintptr
	var v12 uintptr
	var v13 uintptr
	var v14 uintptr
	var v15 int8
	var v16 Tsize_t
	var v4 int64
	var v9 int32
	var p2 uintptr
	var p3 uintptr
	var p5 uintptr
	var p6 uintptr
	var p7 uintptr
	var p8 uintptr
	i = uint64(0)
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if !(n != 0) || !(s != 0) {
		p2 = f + 136
		*(*int32)(unsafe.Pointer(p2)) = *(*int32)(unsafe.Pointer(p2)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
		p3 = f
		*(*uint32)(unsafe.Pointer(p3)) = *(*uint32)(unsafe.Pointer(p3)) | Uint32FromInt32(m_F_ERR)
		{
			if __need_unlock != 0 {
				x___unlockfile(tls, f)
			}
		}
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return int64(-int32(1))
	}
	if !(*(*uintptr)(unsafe.Pointer(s)) != 0) {
		*(*Tsize_t)(unsafe.Pointer(n)) = uint64(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			z = x_memchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, delim, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
			if z != 0 {
				v4 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
			} else {
				v4 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
			}
			k = uint64(v4)
		} else {
			z = uintptr(0)
			k = uint64(0)
		}
		if i+k >= *(*Tsize_t)(unsafe.Pointer(n)) {
			m = i + k + uint64(2)
			if !(z != 0) && m < Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(4) {
				m = m + m/Uint64FromInt32(2)
			}
			tmp = x_realloc(tls, *(*uintptr)(unsafe.Pointer(s)), m)
			if !(tmp != 0) {
				m = i + k + uint64(2)
				tmp = x_realloc(tls, *(*uintptr)(unsafe.Pointer(s)), m)
				if !(tmp != 0) {
					/* Copy as much as fits and ensure no
					 * pushback remains in the FILE buf. */
					k = *(*Tsize_t)(unsafe.Pointer(n)) - i
					x_memcpy(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(i), (*TFILE)(unsafe.Pointer(f)).Frpos, k)
					p5 = f + 8
					*(*uintptr)(unsafe.Pointer(p5)) = *(*uintptr)(unsafe.Pointer(p5)) + uintptr(k)
					p6 = f + 136
					*(*int32)(unsafe.Pointer(p6)) = *(*int32)(unsafe.Pointer(p6)) | ((*TFILE)(unsafe.Pointer(f)).Fmode - Int32FromInt32(1))
					p7 = f
					*(*uint32)(unsafe.Pointer(p7)) = *(*uint32)(unsafe.Pointer(p7)) | Uint32FromInt32(m_F_ERR)
					{
						if __need_unlock != 0 {
							x___unlockfile(tls, f)
						}
					}
					*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOMEM)
					return int64(-int32(1))
				}
			}
			*(*uintptr)(unsafe.Pointer(s)) = tmp
			*(*Tsize_t)(unsafe.Pointer(n)) = m
		}
		if k != 0 {
			x_memcpy(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(i), (*TFILE)(unsafe.Pointer(f)).Frpos, k)
			p8 = f + 8
			*(*uintptr)(unsafe.Pointer(p8)) = *(*uintptr)(unsafe.Pointer(p8)) + uintptr(k)
			i = i + k
		}
		if z != 0 {
			break
		}
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v12 = f + 8
			v11 = *(*uintptr)(unsafe.Pointer(v12))
			*(*uintptr)(unsafe.Pointer(v12))++
			v10 = int32(*(*uint8)(unsafe.Pointer(v11)))
		} else {
			v10 = x___uflow(tls, f)
		}
		v9 = v10
		c = v9
		if v9 == -int32(1) {
			if !(i != 0) || !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_EOF) != 0) {
				{
					if __need_unlock != 0 {
						x___unlockfile(tls, f)
					}
				}
				return int64(-int32(1))
			}
			break
		}
		/* If the byte read by getc won't fit without growing the
		 * output buffer, push it back for next iteration. */
		if i+uint64(1) >= *(*Tsize_t)(unsafe.Pointer(n)) {
			v14 = f + 8
			*(*uintptr)(unsafe.Pointer(v14))--
			v13 = *(*uintptr)(unsafe.Pointer(v14))
			*(*uint8)(unsafe.Pointer(v13)) = uint8(c)
		} else {
			v15 = int8(c)
			v16 = i
			i++
			*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + uintptr(v16))) = v15
			if int32(v15) == delim {
				break
			}
		}
	}
	*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + uintptr(i))) = int8(0)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return int64(i)
}

func x_getline(tls *TLS, s uintptr, n uintptr, f uintptr) (r Tssize_t) {
	return x_getdelim(tls, s, n, int32('\n'), f)
}

func x_gets(tls *TLS, s uintptr) (r uintptr) {
	var __need_unlock int32
	var c int32
	var i Tsize_t
	var v1 int32
	var v2 int32
	var v3 int32
	var v4 uintptr
	var v5 uintptr
	var v6 Tsize_t
	i = uint64(0)
	if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Flock >= int32(0) {
		v1 = x___lockfile(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	for {
		if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Frpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Frend {
			v5 = uintptr(unsafe.Pointer(&x___stdin_FILE)) + 8
			v4 = *(*uintptr)(unsafe.Pointer(v5))
			*(*uintptr)(unsafe.Pointer(v5))++
			v3 = int32(*(*uint8)(unsafe.Pointer(v4)))
		} else {
			v3 = x___uflow(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
		}
		v2 = v3
		c = v2
		if !(v2 != -int32(1) && c != int32('\n')) {
			break
		}
		v6 = i
		i++
		*(*int8)(unsafe.Pointer(s + uintptr(v6))) = int8(c)
	}
	*(*int8)(unsafe.Pointer(s + uintptr(i))) = int8(0)
	if c != int32('\n') && (!((*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdin_FILE)))).Fflags&Uint32FromInt32(m_F_EOF) != 0) || !(i != 0)) {
		s = uintptr(0)
	}
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
		}
	}
	return s
}

func x_getw(tls *TLS, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* x at bp+0 */ int32
	var v1 int32
	if x_fread(tls, bp, uint64(4), uint64(1), f) != 0 {
		v1 = *(*int32)(unsafe.Pointer(bp))
	} else {
		v1 = -int32(1)
	}
	return v1
}

func x_getwc(tls *TLS, f uintptr) (r Twint_t) {
	return x_fgetwc(tls, f)
}

func x_getwchar(tls *TLS) (r Twint_t) {
	return x_fgetwc(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)))
}

var _ofl_head uintptr
var _ofl_lock [1]int32

func x___ofl_lock(tls *TLS) (r uintptr) {
	x___lock(tls, uintptr(unsafe.Pointer(&_ofl_lock)))
	return uintptr(unsafe.Pointer(&_ofl_head))
}

func x___ofl_unlock(tls *TLS) {
	x___unlock(tls, uintptr(unsafe.Pointer(&_ofl_lock)))
}

func x___ofl_add(tls *TLS, f uintptr) (r uintptr) {
	var head uintptr
	head = x___ofl_lock(tls)
	(*TFILE)(unsafe.Pointer(f)).Fnext = *(*uintptr)(unsafe.Pointer(head))
	if *(*uintptr)(unsafe.Pointer(head)) != 0 {
		(*TFILE)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(head)))).Fprev = f
	}
	*(*uintptr)(unsafe.Pointer(head)) = f
	x___ofl_unlock(tls)
	return f
}

type Tcookie1 = struct {
	Fbufp  uintptr
	Fsizep uintptr
	Fpos   Tsize_t
	Fbuf   uintptr
	Flen1  Tsize_t
	Fspace Tsize_t
}

type Tms_FILE = struct {
	Ff   TFILE
	Fc   Tcookie1
	Fbuf [1024]uint8
}

func x_open_memstream(tls *TLS, bufp uintptr, sizep uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3491, int32(26), uintptr(unsafe.Pointer(&___func__61)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__61 = [15]int8{'o', 'p', 'e', 'n', '_', 'm', 'e', 'm', 's', 't', 'r', 'e', 'a', 'm'}

type Tcookie2 = struct {
	Fbufp  uintptr
	Fsizep uintptr
	Fpos   Tsize_t
	Fbuf   uintptr
	Flen1  Tsize_t
	Fspace Tsize_t
	Fmbs   Tmbstate_t
}

type Twms_FILE = struct {
	Ff           TFILE
	Fc           Tcookie2
	Fbuf         [1]uint8
	F__ccgo_pad3 [7]byte
}

func x_open_wmemstream(tls *TLS, bufp uintptr, sizep uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3518, int32(28), uintptr(unsafe.Pointer(&___func__62)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__62 = [16]int8{'o', 'p', 'e', 'n', '_', 'w', 'm', 'e', 'm', 's', 't', 'r', 'e', 'a', 'm'}

func x_pclose(tls *TLS, f uintptr) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var pid Tpid_t
	var r int32
	var _ /* status at bp+0 */ int32
	var v1 int32
	pid = (*TFILE)(unsafe.Pointer(f)).Fpipe_pid
	x_fclose(tls, f)
	for {
		v1 = int32(___syscall4(tls, int64(61), int64(pid), int64(bp), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
		r = v1
		if !(v1 == -int32(m_EINTR)) {
			break
		}
	}
	if r < int32(0) {
		return int32(x___syscall_ret(tls, uint64(r)))
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func x_perror(tls *TLS, msg uintptr) {
	var __need_unlock int32
	var errstr uintptr
	var f uintptr
	var old_locale uintptr
	var old_mode int32
	var v1 int32
	f = uintptr(unsafe.Pointer(&x___stderr_FILE))
	errstr = x_strerror(tls, *(*int32)(unsafe.Pointer(x___errno_location(tls))))
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	/* Save stderr's orientation and encoding rule, since perror is not
	 * permitted to change them. */
	old_locale = (*TFILE)(unsafe.Pointer(f)).Flocale
	old_mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	if msg != 0 && *(*int8)(unsafe.Pointer(msg)) != 0 {
		x_fwrite(tls, msg, x_strlen(tls, msg), uint64(1), f)
		x_fputc(tls, int32(':'), f)
		x_fputc(tls, int32(' '), f)
	}
	x_fwrite(tls, errstr, x_strlen(tls, errstr), uint64(1), f)
	x_fputc(tls, int32('\n'), f)
	(*TFILE)(unsafe.Pointer(f)).Fmode = old_mode
	(*TFILE)(unsafe.Pointer(f)).Flocale = old_locale
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
}

func x_popen(tls *TLS, cmd uintptr, mode uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3546, int32(14), uintptr(unsafe.Pointer(&___func__63)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__63 = [6]int8{'p', 'o', 'p', 'e', 'n'}

func x_printf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vfprintf(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)), fmt, ap)
	_ = ap
	return ret
}

func x_putc(tls *TLS, c int32, f uintptr) (r int32) {
	return _do_putc(tls, c, f)
}

func x_putc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	var v1 int32
	var v2 uint8
	var v3 uintptr
	var v4 uintptr
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
		v2 = uint8(c)
		v4 = f + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = x___overflow(tls, f, int32(uint8(c)))
	}
	return v1
}

func x_putchar(tls *TLS, c int32) (r int32) {
	return _do_putc(tls, c, uintptr(unsafe.Pointer(&x___stdout_FILE)))
}

func x_putchar_unlocked(tls *TLS, c int32) (r int32) {
	var v1 int32
	var v2 uint8
	var v3 uintptr
	var v4 uintptr
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Flbf && (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Fwpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Fwend {
		v2 = uint8(c)
		v4 = uintptr(unsafe.Pointer(&x___stdout_FILE)) + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = x___overflow(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)), int32(uint8(c)))
	}
	return v1
}

func x_puts(tls *TLS, s uintptr) (r1 int32) {
	var __need_unlock int32
	var r int32
	var v1 int32
	var v2 int32
	var v3 uint8
	var v4 uintptr
	var v5 uintptr
	var v6 bool
	if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Flock >= int32(0) {
		v1 = x___lockfile(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)))
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if v6 = x_fputs(tls, s, uintptr(unsafe.Pointer(&x___stdout_FILE))) < int32(0); !v6 {
		if int32(uint8(Int32FromUint8('\n'))) != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Flbf && (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Fwpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&x___stdout_FILE)))).Fwend {
			v3 = uint8(Int32FromUint8('\n'))
			v5 = uintptr(unsafe.Pointer(&x___stdout_FILE)) + 40
			v4 = *(*uintptr)(unsafe.Pointer(v5))
			*(*uintptr)(unsafe.Pointer(v5))++
			*(*uint8)(unsafe.Pointer(v4)) = v3
			v2 = int32(v3)
		} else {
			v2 = x___overflow(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)), int32(uint8(Int32FromUint8('\n'))))
		}
	}
	r = -BoolInt32(v6 || v2 < int32(0))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)))
		}
	}
	return r
}

func x_putw(tls *TLS, _x int32, f uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	*(*int32)(unsafe.Pointer(bp)) = _x
	return int32(x_fwrite(tls, bp, uint64(4), uint64(1), f)) - int32(1)
}

func x_putwc(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	return x_fputwc(tls, c, f)
}

func x_putwchar(tls *TLS, c Twchar_t) (r Twint_t) {
	return x_fputwc(tls, c, uintptr(unsafe.Pointer(&x___stdout_FILE)))
}

const m_EISDIR = 21

func x_remove(tls *TLS, path uintptr) (r1 int32) {
	var r int32
	r = int32(___syscall1(tls, int64(87), int64(path)))
	if r == -int32(m_EISDIR) {
		r = int32(___syscall1(tls, int64(84), int64(path)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_rename(tls *TLS, old uintptr, new1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(82), int64(old), int64(new1)))))
}

func x_rewind(tls *TLS, f uintptr) {
	var __need_unlock int32
	var v1 int32
	var p2 uintptr
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	x___fseeko_unlocked(tls, f, int64(0), int32(m_SEEK_SET))
	p2 = f
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) & uint32(^Int32FromInt32(m_F_ERR))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
}

func x_scanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vscanf(tls, fmt, ap)
	_ = ap
	return ret
}

const m__IOFBF = 0
const m__IONBF = 2

func x_setbuf(tls *TLS, f uintptr, buf uintptr) {
	var v1 int32
	if buf != 0 {
		v1 = int32(m__IOFBF)
	} else {
		v1 = int32(m__IONBF)
	}
	x_setvbuf(tls, f, buf, v1, uint64(m_BUFSIZ))
}

func x_setbuffer(tls *TLS, f uintptr, buf uintptr, size Tsize_t) {
	var v1 int32
	if buf != 0 {
		v1 = int32(m__IOFBF)
	} else {
		v1 = int32(m__IONBF)
	}
	x_setvbuf(tls, f, buf, v1, size)
}

const m__IOLBF = 1

func x_setlinebuf(tls *TLS, f uintptr) {
	x_setvbuf(tls, f, uintptr(0), int32(m__IOLBF), uint64(0))
}

func x_setvbuf(tls *TLS, f uintptr, buf uintptr, type1 int32, size Tsize_t) (r int32) {
	var p1 uintptr
	(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	if type1 == int32(m__IONBF) {
		(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(0)
	} else {
		if type1 == int32(m__IOLBF) || type1 == int32(m__IOFBF) {
			if buf != 0 && size >= uint64(m_UNGET) {
				(*TFILE)(unsafe.Pointer(f)).Fbuf = buf + UintptrFromInt32(m_UNGET)
				(*TFILE)(unsafe.Pointer(f)).Fbuf_size = size - uint64(m_UNGET)
			}
			if type1 == int32(m__IOLBF) && (*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0 {
				(*TFILE)(unsafe.Pointer(f)).Flbf = int32('\n')
			}
		} else {
			return -int32(1)
		}
	}
	p1 = f
	*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) | Uint32FromInt32(m_F_SVB)
	return int32(0)
}

func x_snprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vsnprintf(tls, s, n, fmt, ap)
	_ = ap
	return ret
}

func x_sprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vsprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func x_sscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vsscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

var _buf6 [8]uint8

func init() {
	p := unsafe.Pointer(&x___stderr_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(x___stdio_close)
	*(*uintptr)(unsafe.Add(p, 72)) = __ccgo_fp(x___stdio_write)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(x___stdio_seek)
}

var _buf7 [1032]uint8

func init() {
	p := unsafe.Pointer(&x___stdin_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(x___stdio_close)
	*(*uintptr)(unsafe.Add(p, 64)) = __ccgo_fp(x___stdio_read)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(x___stdio_seek)
}

var _buf8 [1032]uint8

func init() {
	p := unsafe.Pointer(&x___stdout_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(x___stdio_close)
	*(*uintptr)(unsafe.Add(p, 72)) = __ccgo_fp(x___stdout_write)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(x___stdio_seek)
}

func x_swprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vswprintf(tls, s, n, fmt, ap)
	_ = ap
	return ret
}

func x_swscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vswscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func x_tempnam(tls *TLS, dir uintptr, pfx uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3564, int32(15), uintptr(unsafe.Pointer(&___func__64)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__64 = [8]int8{'t', 'e', 'm', 'p', 'n', 'a', 'm'}

const m_MAXTRIES = 100
const m_O_LARGEFILE3 = 64

func x_tmpfile(tls *TLS) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var f uintptr
	var fd int32
	var try int32
	var _ /* s at bp+0 */ [20]int8
	*(*[20]int8)(unsafe.Pointer(bp)) = [20]int8{'/', 't', 'm', 'p', '/', 't', 'm', 'p', 'f', 'i', 'l', 'e', '_', 'X', 'X', 'X', 'X', 'X', 'X'}
	for try = int32(0); try < int32(m_MAXTRIES); try++ {
		x___randname(tls, bp+uintptr(13))
		fd = int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(m_SYS_open), int64(bp), int64(Int32FromInt32(02)|Int32FromInt32(0100)|Int32FromInt32(0200)|Int32FromInt32(m_O_LARGEFILE3)), int64(Int32FromInt32(0600))))))
		if fd >= int32(0) {
			___syscall1(tls, int64(87), int64(bp))
			f = x___fdopen(tls, fd, ts+3584)
			if !(f != 0) {
				___syscall1(tls, int64(3), int64(fd))
			}
			return f
		}
	}
	return uintptr(0)
}

func x_tmpnam(tls *TLS, buf uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3587, int32(14), uintptr(unsafe.Pointer(&___func__65)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__65 = [7]int8{'t', 'm', 'p', 'n', 'a', 'm'}

func x_ungetc(tls *TLS, c int32, f uintptr) (r int32) {
	var __need_unlock int32
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	var p4 uintptr
	if c == -int32(1) {
		return c
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		x___toread(tls, f)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) || (*TFILE)(unsafe.Pointer(f)).Frpos <= (*TFILE)(unsafe.Pointer(f)).Fbuf-uintptr(m_UNGET) {
		{
			if __need_unlock != 0 {
				x___unlockfile(tls, f)
			}
		}
		return -int32(1)
	}
	v3 = f + 8
	*(*uintptr)(unsafe.Pointer(v3))--
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uint8)(unsafe.Pointer(v2)) = uint8(c)
	p4 = f
	*(*uint32)(unsafe.Pointer(p4)) = *(*uint32)(unsafe.Pointer(p4)) & uint32(^Int32FromInt32(m_F_EOF))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return int32(uint8(c))
}

func x_ungetwc(tls *TLS, c Twint_t, f uintptr) (r Twint_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var __need_unlock int32
	var l int32
	var loc Tlocale_t
	var ploc uintptr
	var _ /* mbc at bp+0 */ [4]uint8
	var v1 int32
	var v2 int32
	var v3 bool
	var v4 uintptr
	var v5 uintptr
	var p6 uintptr
	var p7 uintptr
	ploc = ___get_tp(tls) + 168
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= int32(0) {
		x_fwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		x___toread(tls, f)
	}
	if v3 = !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) || c == uint32(0xffffffff); !v3 {
		v2 = int32(x_wcrtomb(tls, bp, int32(c), uintptr(0)))
		l = v2
	}
	if v3 || v2 < int32(0) || (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Fbuf-uintptr(m_UNGET)+uintptr(l) {
		{
			if __need_unlock != 0 {
				x___unlockfile(tls, f)
			}
		}
		*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
		return uint32(0xffffffff)
	}
	if BoolInt32(c < uint32(128)) != 0 {
		v5 = f + 8
		*(*uintptr)(unsafe.Pointer(v5))--
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uint8)(unsafe.Pointer(v4)) = uint8(c)
	} else {
		p6 = f + 8
		*(*uintptr)(unsafe.Pointer(p6)) = *(*uintptr)(unsafe.Pointer(p6)) - uintptr(l)
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(p6)), bp, uint64(l))
	}
	p7 = f
	*(*uint32)(unsafe.Pointer(p7)) = *(*uint32)(unsafe.Pointer(p7)) & uint32(^Int32FromInt32(m_F_EOF))
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return c
}

func x_vasprintf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	var ap2 Tva_list
	var l int32
	var v1 uintptr
	var v2 bool
	ap2 = ap
	l = x_vsnprintf(tls, uintptr(0), uint64(0), fmt, ap2)
	_ = ap2
	if v2 = l < int32(0); !v2 {
		v1 = _default_malloc(tls, uint64(uint32(l)+uint32(1)))
		*(*uintptr)(unsafe.Pointer(s)) = v1
	}
	if v2 || !(v1 != 0) {
		return -int32(1)
	}
	return x_vsnprintf(tls, *(*uintptr)(unsafe.Pointer(s)), uint64(uint32(l)+uint32(1)), fmt, ap)
}

func x_vdprintf(tls *TLS, fd int32, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(232) /* tlsAllocs 232 maxValist 0 */
	defer tls.Free(232)
	var _ /* f at bp+0 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp)) = TFILE{Fwrite: __ccgo_fp(x___stdio_write), Fbuf: fmt, Fbuf_size: uint64(0), Ffd: fd, Flock: -int32(1), Flbf: -int32(1)}
	return x_vfprintf(tls, bp, fmt, ap)
}

const _BARE = 0
const _LPRE = 1
const _LLPRE = 2
const _HPRE = 3
const _HHPRE = 4
const _BIGLPRE = 5
const _ZTPRE = 6
const _JPRE = 7
const _STOP = 8
const _PTR = 9
const _INT = 10
const _UINT = 11
const _ULLONG = 12
const _LONG = 13
const _ULONG = 14
const _SHORT = 15
const _USHORT = 16
const _CHAR = 17
const _UCHAR = 18
const _LLONG = 19
const _SIZET = 20
const _IMAX = 21
const _UMAX = 22
const _PDIFF = 23
const _UIPTR = 24
const _DBL = 25
const _LDBL = 26
const _NOARG = 27
const _MAXSTATE = 28

type Targ = struct {
	Ff [0]float64
	Fp [0]uintptr
	Fi Tuintmax_t
}

/* Do not override this check. The floating point printing code below
 * depends on the float.h constants being right. If they are wrong, it
 * may overflow the stack. */

type Tcompiler_defines_long_double_incorrectly = [1]int8

func x_vfprintf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3606, int32(70), uintptr(unsafe.Pointer(&___func__66)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__66 = [9]int8{'v', 'f', 'p', 'r', 'i', 'n', 't', 'f'}

const m_SIZE_L = 2
const m_SIZE_def = 0
const m_SIZE_l = 1
const m_SIZE_ll = 3

func _store_int(tls *TLS, dest uintptr, size int32, i uint64) {
	if !(dest != 0) {
		return
	}
	switch size {
	case -int32(2):
		*(*int8)(unsafe.Pointer(dest)) = int8(i)
	case -int32(1):
		*(*int16)(unsafe.Pointer(dest)) = int16(i)
	case int32(m_SIZE_def):
		*(*int32)(unsafe.Pointer(dest)) = int32(i)
	case int32(m_SIZE_l):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
	case int32(m_SIZE_ll):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	}
}

func _arg_n(tls *TLS, ap Tva_list, n uint32) (r uintptr) {
	var ap2 Tva_list
	var i uint32
	var p uintptr
	ap2 = ap
	for i = n; i > uint32(1); i-- {
		_ = VaUintptr(&ap2)
	}
	p = VaUintptr(&ap2)
	_ = ap2
	return p
}

func x_vfscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(280) /* tlsAllocs 280 maxValist 0 */
	defer tls.Free(280)
	var __need_unlock int32
	var alloc int32
	var base int32
	var c int32
	var dest uintptr
	var i Tsize_t
	var invert int32
	var k Tsize_t
	var matches int32
	var p uintptr
	var pos Toff_t
	var s uintptr
	var size int32
	var t int32
	var tmp uintptr
	var tmp1 uintptr
	var wcs uintptr
	var width int32
	var x uint64
	var y float64
	var _ /* scanset at bp+12 */ [257]uint8
	var _ /* st at bp+4 */ Tmbstate_t
	var _ /* wc at bp+272 */ Twchar_t
	var v1 int32
	var v10 int32
	var v11 uintptr
	var v12 uintptr
	var v14 uintptr
	var v15 int32
	var v16 uintptr
	var v17 uintptr
	var v19 int32
	var v2 int32
	var v20 uintptr
	var v21 uintptr
	var v3 uintptr
	var v4 uintptr
	var v42 uintptr
	var v43 uintptr
	var v44 uint32
	var v45 int32
	var v46 int32
	var v47 uintptr
	var v48 uintptr
	var v49 Tsize_t
	var v50 int32
	var v51 int32
	var v52 uintptr
	var v53 uintptr
	var v54 Tsize_t
	var v55 uintptr
	var v56 int32
	var v57 int32
	var v58 uintptr
	var v59 uintptr
	var v6 int32
	var v60 Tsize_t
	var v61 int32
	var v62 int32
	var v63 uintptr
	var v64 uintptr
	var v7 int32
	var v8 uintptr
	var v9 uintptr
	alloc = int32(0)
	dest = UintptrFromInt32(0)
	matches = int32(0)
	pos = int64(0)
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		x___toread(tls, f)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		goto input_fail
	}
	for p = fmt; *(*uint8)(unsafe.Pointer(p)) != 0; p++ {
		alloc = int32(0)
		if ___isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0 {
			for ___isspace(tls, int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1))))) != 0 {
				p++
			}
			x___shlim(tls, f, int64(Int32FromInt32(0)))
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v4 = f + 8
					v3 = *(*uintptr)(unsafe.Pointer(v4))
					*(*uintptr)(unsafe.Pointer(v4))++
					v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
				} else {
					v2 = x___shgetc(tls, f)
				}
				if !(___isspace(tls, v2) != 0) {
					break
				}
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			pos = pos + ((*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf)))
			continue
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) != int32('%') || int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))) == int32('%') {
			x___shlim(tls, f, int64(Int32FromInt32(0)))
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('%') {
				p++
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
						v9 = f + 8
						v8 = *(*uintptr)(unsafe.Pointer(v9))
						*(*uintptr)(unsafe.Pointer(v9))++
						v7 = int32(*(*uint8)(unsafe.Pointer(v8)))
					} else {
						v7 = x___shgetc(tls, f)
					}
					v6 = v7
					c = v6
					if !(___isspace(tls, v6) != 0) {
						break
					}
				}
			} else {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v12 = f + 8
					v11 = *(*uintptr)(unsafe.Pointer(v12))
					*(*uintptr)(unsafe.Pointer(v12))++
					v10 = int32(*(*uint8)(unsafe.Pointer(v11)))
				} else {
					v10 = x___shgetc(tls, f)
				}
				c = v10
			}
			if c != int32(*(*uint8)(unsafe.Pointer(p))) {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				} else {
					_ = 0
				}
				if c < int32(0) {
					goto input_fail
				}
				goto match_fail
			}
			pos = pos + ((*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf)))
			continue
		}
		p++
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('*') {
			dest = uintptr(0)
			p++
		} else {
			if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10)) != 0 && int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))) == int32('$') {
				dest = _arg_n(tls, ap, uint32(int32(*(*uint8)(unsafe.Pointer(p)))-int32('0')))
				p = p + UintptrFromInt32(2)
			} else {
				dest = VaUintptr(&ap)
			}
		}
		for width = int32(0); BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10)) != 0; p++ {
			width = int32(10)*width + int32(*(*uint8)(unsafe.Pointer(p))) - int32('0')
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('m') {
			wcs = uintptr(0)
			s = uintptr(0)
			alloc = BoolInt32(!!(dest != 0))
			p++
		} else {
			alloc = int32(0)
		}
		size = int32(m_SIZE_def)
		v14 = p
		p++
		switch int32(*(*uint8)(unsafe.Pointer(v14))) {
		case int32('h'):
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('h') {
				p++
				size = -Int32FromInt32(2)
			} else {
				size = -int32(1)
			}
		case int32('l'):
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('l') {
				p++
				size = Int32FromInt32(m_SIZE_ll)
			} else {
				size = int32(m_SIZE_l)
			}
		case int32('j'):
			size = int32(m_SIZE_ll)
		case int32('z'):
			fallthrough
		case int32('t'):
			size = int32(m_SIZE_l)
		case int32('L'):
			size = int32(m_SIZE_L)
		case int32('d'):
			fallthrough
		case int32('i'):
			fallthrough
		case int32('o'):
			fallthrough
		case int32('u'):
			fallthrough
		case int32('x'):
			fallthrough
		case int32('a'):
			fallthrough
		case int32('e'):
			fallthrough
		case int32('f'):
			fallthrough
		case int32('g'):
			fallthrough
		case int32('A'):
			fallthrough
		case int32('E'):
			fallthrough
		case int32('F'):
			fallthrough
		case int32('G'):
			fallthrough
		case int32('X'):
			fallthrough
		case int32('s'):
			fallthrough
		case int32('c'):
			fallthrough
		case int32('['):
			fallthrough
		case int32('S'):
			fallthrough
		case int32('C'):
			fallthrough
		case int32('p'):
			fallthrough
		case int32('n'):
			p--
		default:
			goto fmt_fail
		}
		t = int32(*(*uint8)(unsafe.Pointer(p)))
		/* C or S */
		if t&int32(0x2f) == int32(3) {
			t = t | Int32FromInt32(32)
			size = int32(m_SIZE_l)
		}
		switch t {
		case int32('c'):
			if width < int32(1) {
				width = int32(1)
			}
			fallthrough
		case int32('['):
		case int32('n'):
			_store_int(tls, dest, size, uint64(pos))
			/* do not increment match count, etc! */
			continue
			fallthrough
		default:
			x___shlim(tls, f, int64(Int32FromInt32(0)))
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v17 = f + 8
					v16 = *(*uintptr)(unsafe.Pointer(v17))
					*(*uintptr)(unsafe.Pointer(v17))++
					v15 = int32(*(*uint8)(unsafe.Pointer(v16)))
				} else {
					v15 = x___shgetc(tls, f)
				}
				if !(___isspace(tls, v15) != 0) {
					break
				}
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			} else {
				_ = 0
			}
			pos = pos + ((*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf)))
		}
		x___shlim(tls, f, int64(width))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v21 = f + 8
			v20 = *(*uintptr)(unsafe.Pointer(v21))
			*(*uintptr)(unsafe.Pointer(v21))++
			v19 = int32(*(*uint8)(unsafe.Pointer(v20)))
		} else {
			v19 = x___shgetc(tls, f)
		}
		if v19 < int32(0) {
			goto input_fail
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		switch t {
		case int32('['):
			goto _23
		case int32('c'):
			goto _24
		case int32('s'):
			goto _25
		case int32('x'):
			goto _26
		case int32('X'):
			goto _27
		case int32('p'):
			goto _28
		case int32('o'):
			goto _29
		case int32('u'):
			goto _30
		case int32('d'):
			goto _31
		case int32('i'):
			goto _32
		case int32('G'):
			goto _33
		case int32('g'):
			goto _34
		case int32('F'):
			goto _35
		case int32('f'):
			goto _36
		case int32('E'):
			goto _37
		case int32('e'):
			goto _38
		case int32('A'):
			goto _39
		case int32('a'):
			goto _40
		}
		goto _41
	_25:
	_24:
	_23:
		if t == int32('c') || t == int32('s') {
			x_memset(tls, bp+12, -int32(1), uint64(257))
			(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[int32(0)] = uint8(0)
			if t == int32('s') {
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('\t')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('\n')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('\v')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('\f')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('\r')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8(' ')] = uint8(0)
			}
		} else {
			p++
			v42 = p
			if int32(*(*uint8)(unsafe.Pointer(v42))) == int32('^') {
				p++
				invert = Int32FromInt32(1)
			} else {
				invert = int32(0)
			}
			x_memset(tls, bp+12, invert, uint64(257))
			(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[int32(0)] = uint8(0)
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') {
				p++
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8('-')] = uint8(Int32FromInt32(1) - invert)
			} else {
				if int32(*(*uint8)(unsafe.Pointer(p))) == int32(']') {
					p++
					(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[Int32FromInt32(1)+Int32FromUint8(']')] = uint8(Int32FromInt32(1) - invert)
				}
			}
			for ; int32(*(*uint8)(unsafe.Pointer(p))) != int32(']'); p++ {
				if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
					goto fmt_fail
				}
				if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') && *(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1))) != 0 && int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(1)))) != int32(']') {
					v43 = p
					p++
					c = int32(*(*uint8)(unsafe.Pointer(v43 + uintptr(-Int32FromInt32(1)))))
					for ; c < int32(*(*uint8)(unsafe.Pointer(p))); c++ {
						(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[int32(1)+c] = uint8(int32(1) - invert)
					}
				}
				(*(*[257]uint8)(unsafe.Pointer(bp + 12)))[int32(1)+int32(*(*uint8)(unsafe.Pointer(p)))] = uint8(int32(1) - invert)
			}
		}
		wcs = uintptr(0)
		s = uintptr(0)
		i = uint64(0)
		if t == int32('c') {
			v44 = uint32(width) + uint32(1)
		} else {
			v44 = uint32(31)
		}
		k = uint64(v44)
		if size == int32(m_SIZE_l) {
			if alloc != 0 {
				wcs = _default_malloc(tls, k*uint64(4))
				if !(wcs != 0) {
					goto alloc_fail
				}
			} else {
				wcs = dest
			}
			*(*Tmbstate_t)(unsafe.Pointer(bp + 4)) = Tmbstate_t{}
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v48 = f + 8
					v47 = *(*uintptr)(unsafe.Pointer(v48))
					*(*uintptr)(unsafe.Pointer(v48))++
					v46 = int32(*(*uint8)(unsafe.Pointer(v47)))
				} else {
					v46 = x___shgetc(tls, f)
				}
				v45 = v46
				c = v45
				if !((*(*[257]uint8)(unsafe.Pointer(bp + 12)))[v45+int32(1)] != 0) {
					break
				}
				*(*int8)(unsafe.Pointer(bp)) = int8(c)
				switch x_mbrtowc(tls, bp+272, bp, uint64(1), bp+4) {
				case uint64(-Int32FromInt32(1)):
					goto input_fail
				case uint64(-Int32FromInt32(2)):
					continue
				}
				if wcs != 0 {
					v49 = i
					i++
					*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(v49)*4)) = *(*Twchar_t)(unsafe.Pointer(bp + 272))
				}
				if alloc != 0 && i == k {
					k = k + (k + Uint64FromInt32(1))
					tmp = x_realloc(tls, wcs, k*uint64(4))
					if !(tmp != 0) {
						goto alloc_fail
					}
					wcs = tmp
				}
			}
			if !(x_mbsinit(tls, bp+4) != 0) {
				goto input_fail
			}
		} else {
			if alloc != 0 {
				s = _default_malloc(tls, k)
				if !(s != 0) {
					goto alloc_fail
				}
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
						v53 = f + 8
						v52 = *(*uintptr)(unsafe.Pointer(v53))
						*(*uintptr)(unsafe.Pointer(v53))++
						v51 = int32(*(*uint8)(unsafe.Pointer(v52)))
					} else {
						v51 = x___shgetc(tls, f)
					}
					v50 = v51
					c = v50
					if !((*(*[257]uint8)(unsafe.Pointer(bp + 12)))[v50+int32(1)] != 0) {
						break
					}
					v54 = i
					i++
					*(*int8)(unsafe.Pointer(s + uintptr(v54))) = int8(c)
					if i == k {
						k = k + (k + Uint64FromInt32(1))
						tmp1 = x_realloc(tls, s, k)
						if !(tmp1 != 0) {
							goto alloc_fail
						}
						s = tmp1
					}
				}
			} else {
				v55 = dest
				s = v55
				if v55 != 0 {
					for {
						if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
							v59 = f + 8
							v58 = *(*uintptr)(unsafe.Pointer(v59))
							*(*uintptr)(unsafe.Pointer(v59))++
							v57 = int32(*(*uint8)(unsafe.Pointer(v58)))
						} else {
							v57 = x___shgetc(tls, f)
						}
						v56 = v57
						c = v56
						if !((*(*[257]uint8)(unsafe.Pointer(bp + 12)))[v56+int32(1)] != 0) {
							break
						}
						v60 = i
						i++
						*(*int8)(unsafe.Pointer(s + uintptr(v60))) = int8(c)
					}
				} else {
					for {
						if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
							v64 = f + 8
							v63 = *(*uintptr)(unsafe.Pointer(v64))
							*(*uintptr)(unsafe.Pointer(v64))++
							v62 = int32(*(*uint8)(unsafe.Pointer(v63)))
						} else {
							v62 = x___shgetc(tls, f)
						}
						v61 = v62
						c = v61
						if !((*(*[257]uint8)(unsafe.Pointer(bp + 12)))[v61+int32(1)] != 0) {
							break
						}
					}
				}
			}
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= int64(0) {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		} else {
			_ = 0
		}
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if t == int32('c') && (*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != int64(width) {
			goto match_fail
		}
		if alloc != 0 {
			if size == int32(m_SIZE_l) {
				*(*uintptr)(unsafe.Pointer(dest)) = wcs
			} else {
				*(*uintptr)(unsafe.Pointer(dest)) = s
			}
		}
		if t != int32('c') {
			if wcs != 0 {
				*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) = int32(0)
			}
			if s != 0 {
				*(*int8)(unsafe.Pointer(s + uintptr(i))) = int8(0)
			}
		}
		goto _41
	_28:
	_27:
	_26:
		base = int32(16)
		goto int_common
	_29:
		base = int32(8)
		goto int_common
	_31:
	_30:
		base = int32(10)
		goto int_common
	_32:
		base = int32(0)
	int_common:
		x = x___intscan(tls, f, uint32(base), int32(0), Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if t == int32('p') && dest != 0 {
			*(*uintptr)(unsafe.Pointer(dest)) = uintptr(x)
		} else {
			_store_int(tls, dest, size, x)
		}
		goto _41
	_40:
	_39:
	_38:
	_37:
	_36:
	_35:
	_34:
	_33:
		y = x___floatscan(tls, f, size, int32(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if dest != 0 {
			switch size {
			case int32(m_SIZE_def):
				*(*float32)(unsafe.Pointer(dest)) = float32(y)
			case int32(m_SIZE_l):
				*(*float64)(unsafe.Pointer(dest)) = y
			case int32(m_SIZE_L):
				*(*float64)(unsafe.Pointer(dest)) = y
				break
			}
		}
		goto _41
	_41:
		pos = pos + ((*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf)))
		if dest != 0 {
			matches++
		}
	}
	if !(int32(0) != 0) {
		goto _66
	}
fmt_fail:
alloc_fail:
input_fail:
	if !(matches != 0) {
		matches--
	}
match_fail:
	if alloc != 0 {
		x_free(tls, s)
		x_free(tls, wcs)
	}
_66:
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	return matches
}

const m_NL_ARGMAX = 9

var _states = [8][58]uint8{
	0: {
		0:  uint8(_DBL),
		2:  uint8(_INT),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		11: uint8(_BIGLPRE),
		18: uint8(_PTR),
		23: uint8(_UINT),
		32: uint8(_DBL),
		34: uint8(_CHAR),
		35: uint8(_INT),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		39: uint8(_HPRE),
		40: uint8(_INT),
		41: uint8(_JPRE),
		43: uint8(_LPRE),
		44: uint8(_NOARG),
		45: uint8(_PTR),
		46: uint8(_UINT),
		47: uint8(_UIPTR),
		50: uint8(_PTR),
		51: uint8(_ZTPRE),
		52: uint8(_UINT),
		55: uint8(_UINT),
		57: uint8(_ZTPRE)},
	1: {
		0:  uint8(_DBL),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		23: uint8(_ULONG),
		32: uint8(_DBL),
		34: uint8(_INT),
		35: uint8(_LONG),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		40: uint8(_LONG),
		43: uint8(_LLPRE),
		45: uint8(_PTR),
		46: uint8(_ULONG),
		50: uint8(_PTR),
		52: uint8(_ULONG),
		55: uint8(_ULONG)},
	2: {
		23: uint8(_ULLONG),
		35: uint8(_LLONG),
		40: uint8(_LLONG),
		45: uint8(_PTR),
		46: uint8(_ULLONG),
		52: uint8(_ULLONG),
		55: uint8(_ULLONG)},
	3: {
		23: uint8(_USHORT),
		35: uint8(_SHORT),
		39: uint8(_HHPRE),
		40: uint8(_SHORT),
		45: uint8(_PTR),
		46: uint8(_USHORT),
		52: uint8(_USHORT),
		55: uint8(_USHORT)},
	4: {
		23: uint8(_UCHAR),
		35: uint8(_CHAR),
		40: uint8(_CHAR),
		45: uint8(_PTR),
		46: uint8(_UCHAR),
		52: uint8(_UCHAR),
		55: uint8(_UCHAR)},
	5: {
		0:  uint8(_LDBL),
		4:  uint8(_LDBL),
		5:  uint8(_LDBL),
		6:  uint8(_LDBL),
		32: uint8(_LDBL),
		36: uint8(_LDBL),
		37: uint8(_LDBL),
		38: uint8(_LDBL),
		45: uint8(_PTR)},
	6: {
		23: uint8(_SIZET),
		35: uint8(_PDIFF),
		40: uint8(_PDIFF),
		45: uint8(_PTR),
		46: uint8(_SIZET),
		52: uint8(_SIZET),
		55: uint8(_SIZET)},
	7: {
		23: uint8(_UMAX),
		35: uint8(_IMAX),
		40: uint8(_IMAX),
		45: uint8(_PTR),
		46: uint8(_UMAX),
		52: uint8(_UMAX),
		55: uint8(_UMAX)}}

func _pop_arg(tls *TLS, arg uintptr, type1 int32, ap uintptr) {
	switch type1 {
	case int32(_PTR):
		*(*uintptr)(unsafe.Pointer(arg)) = VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_INT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UINT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUint32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_LONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_ULONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_ULLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_SHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_USHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_CHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_UCHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_LLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_SIZET):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_IMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_PDIFF):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UIPTR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_DBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_LDBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	}
}

func _out(tls *TLS, f uintptr, s uintptr, l Tsize_t) {
	var v1 Tsize_t
	var v2 uintptr
	for {
		v1 = l
		l--
		if !(v1 != 0 && !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(m_F_ERR) != 0)) {
			break
		}
		v2 = s
		s += 4
		x_fputwc(tls, *(*Twchar_t)(unsafe.Pointer(v2)), f)
	}
}

func _pad3(tls *TLS, f uintptr, n int32, fl int32) {
	bp := tls.Alloc(24) /* tlsAllocs 0 maxValist 2 */
	defer tls.Free(24)
	if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0 || !(n != 0) || (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		return
	}
	x_fprintf(tls, f, ts+3627, VaList(bp+8, n, ts))
}

func _getint(tls *TLS, s uintptr) (r int32) {
	var i int32
	for i = int32(0); BoolInt32(uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-uint32('0') < uint32(10)) != 0; *(*uintptr)(unsafe.Pointer(s)) += 4 {
		if uint32(i) > Uint32FromInt32(m_INT_MAX)/Uint32FromUint32(10) || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))-int32('0') > int32(m_INT_MAX)-int32(10)*i {
			i = -int32(1)
		} else {
			i = int32(10)*i + (*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))) - int32('0'))
		}
	}
	return i
}

var _sizeprefix = [24]int8{
	0:  int8('L'),
	3:  int8('j'),
	4:  int8('L'),
	5:  int8('L'),
	6:  int8('L'),
	8:  int8('j'),
	14: int8('j'),
	15: int8('j'),
	20: int8('j'),
	23: int8('j')}

func _wprintf_core(tls *TLS, f uintptr, fmt uintptr, ap uintptr, nl_arg uintptr, nl_type uintptr) (r int32) {
	bp := tls.Alloc(112) /* tlsAllocs 48 maxValist 7 */
	defer tls.Free(112)
	var a uintptr
	var argpos int32
	var bs uintptr
	var cnt int32
	var fl uint32
	var i int32
	var l int32
	var l10n uint32
	var p int32
	var ps uint32
	var st uint32
	var t int32
	var w int32
	var xp int32
	var z uintptr
	var _ /* arg at bp+16 */ Targ
	var _ /* charfmt at bp+24 */ [16]int8
	var _ /* s at bp+8 */ uintptr
	var _ /* wc at bp+40 */ Twchar_t
	var v10 int32
	var v11 bool
	var v13 int32
	var v2 int32
	var v3 int32
	var v4 int32
	var v5 uintptr
	var v6 uint64
	var v7 int32
	var v8 int32
	var v9 int32
	*(*uintptr)(unsafe.Pointer(bp + 8)) = fmt
	l10n = uint32(0)
	cnt = int32(0)
	l = int32(0)
	for {
		/* This error is only specified for snprintf, but since it's
		 * unspecified for other forms, do the same. Stop immediately
		 * on overflow; otherwise %n could produce wrong results. */
		if l > int32(m_INT_MAX)-cnt {
			goto overflow
		}
		/* Update output count, end loop when fmt is exhausted */
		cnt = cnt + l
		if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0) {
			break
		}
		/* Handle literal text and %% format specifiers */
		for a = *(*uintptr)(unsafe.Pointer(bp + 8)); *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != int32('%'); *(*uintptr)(unsafe.Pointer(bp + 8)) += 4 {
		}
		for z = *(*uintptr)(unsafe.Pointer(bp + 8)); *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(0)*4)) == int32('%') && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4)) == int32('%'); {
			goto _1
		_1:
			z += 4
			*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4
		}
		if (int64(z)-int64(a))/4 > int64(int32(m_INT_MAX)-cnt) {
			goto overflow
		}
		l = int32((int64(z) - int64(a)) / 4)
		if f != 0 {
			_out(tls, f, a, uint64(l))
		}
		if l != 0 {
			continue
		}
		if BoolInt32(uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4)))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4)) == int32('$') {
			l10n = uint32(1)
			argpos = *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4)) - int32('0')
			*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(3)*4
		} else {
			argpos = -int32(1)
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
		}
		/* Read modifier flags */
		for fl = uint32(0); uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-uint32(' ') < uint32(32) && (Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('\'')-Int32FromUint8(' ')))&(uint32(1)<<(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))-int32(' '))) != 0; *(*uintptr)(unsafe.Pointer(bp + 8)) += 4 {
			fl = fl | Uint32FromUint32(1)<<(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))-Int32FromUint8(' '))
		}
		/* Read field width */
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == int32('*') {
			if BoolInt32(uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4)))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4)) == int32('$') {
				l10n = uint32(1)
				*(*int32)(unsafe.Pointer(nl_type + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4))-Int32FromUint8('0'))*4)) = int32(_INT)
				w = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4))-Int32FromUint8('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(3)*4
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v2 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v2 = int32(0)
					}
					w = v2
					*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
				} else {
					goto inval
				}
			}
			if w < int32(0) {
				fl = fl | Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))
				w = -w
			}
		} else {
			v3 = _getint(tls, bp+8)
			w = v3
			if v3 < int32(0) {
				goto overflow
			}
		}
		/* Read precision */
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == int32('.') && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(1)*4)) == int32('*') {
			if BoolInt32(uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4)))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(3)*4)) == int32('$') {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4))-Int32FromUint8('0'))*4)) = int32(_INT)
				p = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4))-Int32FromUint8('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(4)*4
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v4 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v4 = int32(0)
					}
					p = v4
					*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + UintptrFromInt32(2)*4
				} else {
					goto inval
				}
			}
			xp = BoolInt32(p >= int32(0))
		} else {
			if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == int32('.') {
				*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
				p = _getint(tls, bp+8)
				xp = int32(1)
			} else {
				p = -int32(1)
				xp = int32(0)
			}
		}
		/* Format specifier state machine */
		st = uint32(0)
		for cond := true; cond; cond = st-uint32(1) < uint32(_STOP) {
			if uint32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))-uint32('A') > uint32(Int32FromUint8('z')-Int32FromUint8('A')) {
				goto inval
			}
			ps = st
			v5 = *(*uintptr)(unsafe.Pointer(bp + 8))
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
			st = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_states)) + uintptr(st)*58 + uintptr(*(*Twchar_t)(unsafe.Pointer(v5))-Int32FromUint8('A')))))
		}
		if !(st != 0) {
			goto inval
		}
		/* Check validity of argument type (nl/normal) */
		if st == uint32(_NOARG) {
			if argpos >= int32(0) {
				goto inval
			}
		} else {
			if argpos >= int32(0) {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(argpos)*4)) = int32(st)
				*(*Targ)(unsafe.Pointer(bp + 16)) = *(*Targ)(unsafe.Pointer(nl_arg + uintptr(argpos)*8))
			} else {
				if f != 0 {
					_pop_arg(tls, bp+16, int32(st), ap)
				} else {
					return int32(0)
				}
			}
		}
		if !(f != 0) {
			continue
		}
		/* Do not process any new directives once in error state. */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
			return -int32(1)
		}
		t = *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(-Int32FromInt32(1))*4))
		if ps != 0 && t&int32(15) == int32(3) {
			t = t & ^Int32FromInt32(32)
		}
		switch t {
		case int32('n'):
			switch ps {
			case uint32(_BARE):
				*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = cnt
			case uint32(_LPRE):
				*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = int64(cnt)
			case uint32(_LLPRE):
				*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = int64(cnt)
			case uint32(_HPRE):
				*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint16(cnt)
			case uint32(_HHPRE):
				*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint8(cnt)
			case uint32(_ZTPRE):
				*(*Tsize_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint64(cnt)
			case uint32(_JPRE):
				*(*Tuintmax_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint64(cnt)
				break
			}
			continue
			fallthrough
		case int32('c'):
			fallthrough
		case int32('C'):
			if w < int32(1) {
				w = int32(1)
			}
			_pad3(tls, f, w-int32(1), int32(fl))
			if t == int32('C') {
				v6 = *(*Tuintmax_t)(unsafe.Pointer(bp + 16))
			} else {
				v6 = uint64(x_btowc(tls, int32(*(*Tuintmax_t)(unsafe.Pointer(bp + 16)))))
			}
			*(*Twchar_t)(unsafe.Pointer(bp)) = int32(v6)
			_out(tls, f, bp, uint64(1))
			_pad3(tls, f, w-int32(1), int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			continue
			fallthrough
		case int32('S'):
			a = *(*uintptr)(unsafe.Pointer(bp + 16))
			if p < int32(0) {
				v7 = int32(m_INT_MAX)
			} else {
				v7 = p
			}
			z = a + uintptr(x_wcsnlen(tls, a, uint64(v7)))*4
			if p < int32(0) && *(*Twchar_t)(unsafe.Pointer(z)) != 0 {
				goto overflow
			}
			p = int32((int64(z) - int64(a)) / 4)
			if w < p {
				w = p
			}
			_pad3(tls, f, w-p, int32(fl))
			_out(tls, f, a, uint64(p))
			_pad3(tls, f, w-p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			continue
			fallthrough
		case int32('m'):
			*(*uintptr)(unsafe.Pointer(bp + 16)) = x_strerror(tls, *(*int32)(unsafe.Pointer(x___errno_location(tls))))
			fallthrough
		case int32('s'):
			if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 16)) = ts + 3631
			}
			bs = *(*uintptr)(unsafe.Pointer(bp + 16))
			v8 = Int32FromInt32(0)
			l = v8
			i = v8
			for ; ; l++ {
				if p < int32(0) {
					v9 = int32(m_INT_MAX)
				} else {
					v9 = p
				}
				if v11 = l < v9; v11 {
					v10 = x_mbtowc(tls, bp+40, bs, uint64(m_MB_LEN_MAX))
					i = v10
				}
				if !(v11 && v10 > int32(0)) {
					break
				}
				goto _12
			_12:
				bs = bs + uintptr(i)
				l++
			}
			if i < int32(0) {
				return -int32(1)
			}
			if p < int32(0) && *(*int8)(unsafe.Pointer(bs)) != 0 {
				goto overflow
			}
			p = l
			if w < p {
				w = p
			}
			_pad3(tls, f, w-p, int32(fl))
			bs = *(*uintptr)(unsafe.Pointer(bp + 16))
			for {
				v13 = l
				l--
				if !(v13 != 0) {
					break
				}
				i = x_mbtowc(tls, bp+40, bs, uint64(m_MB_LEN_MAX))
				bs = bs + uintptr(i)
				_out(tls, f, bp+40, uint64(1))
			}
			_pad3(tls, f, w-p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			continue
		}
		if xp != 0 && p < int32(0) {
			goto overflow
		}
		x_snprintf(tls, bp+24, uint64(16), ts+3638, VaList(bp+56, ts+3658+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0)), ts+3660+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0)), ts+3662+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0)), ts+1169+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0)), ts+207+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))) != 0)), int32(_sizeprefix[t|int32(32)-int32('a')]), t))
		switch t | int32(32) {
		case int32('a'):
			fallthrough
		case int32('e'):
			fallthrough
		case int32('f'):
			fallthrough
		case int32('g'):
			l = x_fprintf(tls, f, bp+24, VaList(bp+56, w, p, *(*float64)(unsafe.Pointer(bp + 16))))
		case int32('d'):
			fallthrough
		case int32('i'):
			fallthrough
		case int32('o'):
			fallthrough
		case int32('u'):
			fallthrough
		case int32('x'):
			fallthrough
		case int32('p'):
			l = x_fprintf(tls, f, bp+24, VaList(bp+56, w, p, *(*Tuintmax_t)(unsafe.Pointer(bp + 16))))
			break
		}
	}
	if f != 0 {
		return cnt
	}
	if !(l10n != 0) {
		return int32(0)
	}
	for i = int32(1); i <= int32(m_NL_ARGMAX) && *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0; i++ {
		_pop_arg(tls, nl_arg+uintptr(i)*8, *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)), ap)
	}
	for ; i <= int32(m_NL_ARGMAX) && !(*(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0); i++ {
	}
	if i <= int32(m_NL_ARGMAX) {
		return -int32(1)
	}
	return int32(1)
inval:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
	return -int32(1)
overflow:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
	return -int32(1)
}

func x_vfwprintf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var __need_unlock int32
	var olderr int32
	var ret int32
	var _ /* ap2 at bp+0 */ Tva_list
	var _ /* nl_arg at bp+48 */ [10]Targ
	var _ /* nl_type at bp+8 */ [10]int32
	var v1 int32
	var p2 uintptr
	var p3 uintptr
	*(*[10]int32)(unsafe.Pointer(bp + 8)) = [10]int32{}
	/* the copy allows passing va_list* even if va_list is an array */
	*(*Tva_list)(unsafe.Pointer(bp)) = ap
	if _wprintf_core(tls, uintptr(0), fmt, bp, bp+48, bp+8) < int32(0) {
		_ = *(*Tva_list)(unsafe.Pointer(bp))
		return -int32(1)
	}
	if (*TFILE)(unsafe.Pointer(f)).Flock >= int32(0) {
		v1 = x___lockfile(tls, f)
	} else {
		v1 = int32(0)
	}
	__need_unlock = v1
	x_fwide(tls, f, int32(1))
	olderr = int32((*TFILE)(unsafe.Pointer(f)).Fflags & uint32(m_F_ERR))
	p2 = f
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) & uint32(^Int32FromInt32(m_F_ERR))
	ret = _wprintf_core(tls, f, fmt, bp, bp+48, bp+8)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(m_F_ERR) != 0 {
		ret = -int32(1)
	}
	p3 = f
	*(*uint32)(unsafe.Pointer(p3)) = *(*uint32)(unsafe.Pointer(p3)) | uint32(olderr)
	{
		if __need_unlock != 0 {
			x___unlockfile(tls, f)
		}
	}
	_ = *(*Tva_list)(unsafe.Pointer(bp))
	return ret
}

func x_vfwscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3664, int32(35), uintptr(unsafe.Pointer(&___func__67)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__67 = [9]int8{'v', 'f', 'w', 's', 'c', 'a', 'n', 'f'}

func x_vprintf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	return x_vfprintf(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)), fmt, ap)
}

func x_vscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	return x_vfscanf(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)), fmt, ap)
}

type Tcookie3 = struct {
	Fs uintptr
	Fn Tsize_t
}

func _sn_write(tls *TLS, f uintptr, s uintptr, l Tsize_t) (r Tsize_t) {
	var c uintptr
	var k Tsize_t
	var v1 uint64
	var v4 uint64
	var v7 uintptr
	var p2 uintptr
	var p3 uintptr
	var p5 uintptr
	var p6 uintptr
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if (*Tcookie3)(unsafe.Pointer(c)).Fn < uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos)-int64((*TFILE)(unsafe.Pointer(f)).Fwbase)) {
		v1 = (*Tcookie3)(unsafe.Pointer(c)).Fn
	} else {
		v1 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	}
	k = v1
	if k != 0 {
		x_memcpy(tls, (*Tcookie3)(unsafe.Pointer(c)).Fs, (*TFILE)(unsafe.Pointer(f)).Fwbase, k)
		p2 = c
		*(*uintptr)(unsafe.Pointer(p2)) = *(*uintptr)(unsafe.Pointer(p2)) + uintptr(k)
		p3 = c + 8
		*(*Tsize_t)(unsafe.Pointer(p3)) = *(*Tsize_t)(unsafe.Pointer(p3)) - k
	}
	if (*Tcookie3)(unsafe.Pointer(c)).Fn < l {
		v4 = (*Tcookie3)(unsafe.Pointer(c)).Fn
	} else {
		v4 = l
	}
	k = v4
	if k != 0 {
		x_memcpy(tls, (*Tcookie3)(unsafe.Pointer(c)).Fs, s, k)
		p5 = c
		*(*uintptr)(unsafe.Pointer(p5)) = *(*uintptr)(unsafe.Pointer(p5)) + uintptr(k)
		p6 = c + 8
		*(*Tsize_t)(unsafe.Pointer(p6)) = *(*Tsize_t)(unsafe.Pointer(p6)) - k
	}
	*(*int8)(unsafe.Pointer((*Tcookie3)(unsafe.Pointer(c)).Fs)) = int8(0)
	v7 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v7
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v7
	/* pretend to succeed, even if we discarded extra data */
	return l
}

func x_vsnprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var _ /* buf at bp+0 */ [1]uint8
	var _ /* c at bp+8 */ Tcookie3
	var _ /* dummy at bp+1 */ [1]int8
	var _ /* f at bp+24 */ TFILE
	var v1 uintptr
	var v2 uint64
	if n != 0 {
		v1 = s
	} else {
		v1 = bp + 1
	}
	if n != 0 {
		v2 = n - uint64(1)
	} else {
		v2 = uint64(0)
	}
	*(*Tcookie3)(unsafe.Pointer(bp + 8)) = Tcookie3{Fs: v1, Fn: v2}
	*(*TFILE)(unsafe.Pointer(bp + 24)) = TFILE{Fwrite: __ccgo_fp(_sn_write), Fbuf: bp, Flock: -int32(1), Flbf: -int32(1), Fcookie: bp + 8}
	if n > uint64(m_INT_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return -int32(1)
	}
	*(*int8)(unsafe.Pointer((*(*Tcookie3)(unsafe.Pointer(bp + 8))).Fs)) = int8(0)
	return x_vfprintf(tls, bp+24, fmt, ap)
}

func x_vsprintf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	return x_vsnprintf(tls, s, uint64(m_INT_MAX), fmt, ap)
}

func _string_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var end uintptr
	var k Tsize_t
	var src uintptr
	src = (*TFILE)(unsafe.Pointer(f)).Fcookie
	k = len1 + uint64(256)
	end = x_memchr(tls, src, int32(0), k)
	if end != 0 {
		k = uint64(int64(end) - int64(src))
	}
	if k < len1 {
		len1 = k
	}
	x_memcpy(tls, buf, src, len1)
	(*TFILE)(unsafe.Pointer(f)).Frpos = src + uintptr(len1)
	(*TFILE)(unsafe.Pointer(f)).Frend = src + uintptr(k)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = src + uintptr(k)
	return len1
}

func x_vsscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(232) /* tlsAllocs 232 maxValist 0 */
	defer tls.Free(232)
	var _ /* f at bp+0 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp)) = TFILE{Fread: __ccgo_fp(_string_read), Fbuf: s, Flock: -int32(1), Fcookie: s}
	return x_vfscanf(tls, bp, fmt, ap)
}

type Tcookie4 = struct {
	Fws uintptr
	Fl  Tsize_t
}

func _sw_write(tls *TLS, f uintptr, s uintptr, l Tsize_t) (r Tsize_t) {
	var c uintptr
	var i int32
	var l0 Tsize_t
	var v1 int32
	var v2 bool
	var v3 uintptr
	var v4 uintptr
	var v6 uintptr
	var p5 uintptr
	l0 = l
	i = int32(0)
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if s != (*TFILE)(unsafe.Pointer(f)).Fwbase && _sw_write(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwbase, uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos)-int64((*TFILE)(unsafe.Pointer(f)).Fwbase))) == uint64(-Int32FromInt32(1)) {
		return uint64(-Int32FromInt32(1))
	}
	for {
		if v2 = (*Tcookie4)(unsafe.Pointer(c)).Fl != 0 && l != 0; v2 {
			v1 = x_mbtowc(tls, (*Tcookie4)(unsafe.Pointer(c)).Fws, s, l)
			i = v1
		}
		if !(v2 && v1 >= int32(0)) {
			break
		}
		if !(i != 0) {
			i = int32(1)
		}
		s = s + uintptr(i)
		l = l - uint64(i)
		(*Tcookie4)(unsafe.Pointer(c)).Fl--
		(*Tcookie4)(unsafe.Pointer(c)).Fws += 4
	}
	*(*Twchar_t)(unsafe.Pointer((*Tcookie4)(unsafe.Pointer(c)).Fws)) = int32(0)
	if i < int32(0) {
		v4 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v4
		v3 = v4
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
		p5 = f
		*(*uint32)(unsafe.Pointer(p5)) = *(*uint32)(unsafe.Pointer(p5)) | Uint32FromInt32(m_F_ERR)
		return uint64(i)
	}
	(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	v6 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v6
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v6
	return l0
}

func x_vswprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, ap Tva_list) (r1 int32) {
	bp := tls.Alloc(504) /* tlsAllocs 504 maxValist 0 */
	defer tls.Free(504)
	var r int32
	var _ /* buf at bp+0 */ [256]uint8
	var _ /* c at bp+256 */ Tcookie4
	var _ /* f at bp+272 */ TFILE
	var v1 int32
	*(*Tcookie4)(unsafe.Pointer(bp + 256)) = Tcookie4{Fws: s, Fl: n - uint64(1)}
	*(*TFILE)(unsafe.Pointer(bp + 272)) = TFILE{Fwrite: __ccgo_fp(_sw_write), Fbuf: bp, Fbuf_size: uint64(256), Flock: -int32(1), Flbf: -int32(1), Fcookie: bp + 256}
	if !(n != 0) {
		return -int32(1)
	} else {
		if n > uint64(m_INT_MAX) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
			return -int32(1)
		}
	}
	r = x_vfwprintf(tls, bp+272, fmt, ap)
	_sw_write(tls, bp+272, uintptr(0), uint64(0))
	if uint64(r) >= n {
		v1 = -int32(1)
	} else {
		v1 = r
	}
	return v1
}

func _wstring_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var k Tsize_t
	var _ /* src at bp+0 */ uintptr
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
		return uint64(0)
	}
	k = x_wcsrtombs(tls, (*TFILE)(unsafe.Pointer(f)).Fbuf, bp, (*TFILE)(unsafe.Pointer(f)).Fbuf_size, uintptr(0))
	if k == uint64(-Int32FromInt32(1)) {
		v1 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Frend = v1
		(*TFILE)(unsafe.Pointer(f)).Frpos = v1
		return uint64(0)
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(k)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = *(*uintptr)(unsafe.Pointer(bp))
	if !(len1 != 0) || !(k != 0) {
		return uint64(0)
	}
	v3 = f + 8
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uintptr)(unsafe.Pointer(v3))++
	*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v2))
	return uint64(1)
}

func x_vswscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	bp := tls.Alloc(488) /* tlsAllocs 488 maxValist 0 */
	defer tls.Free(488)
	var _ /* buf at bp+0 */ [256]uint8
	var _ /* f at bp+256 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp + 256)) = TFILE{Fread: __ccgo_fp(_wstring_read), Fbuf: bp, Fbuf_size: uint64(256), Flock: -int32(1), Fcookie: s}
	return x_vfwscanf(tls, bp+256, fmt, ap)
}

func x_vwprintf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	return x_vfwprintf(tls, uintptr(unsafe.Pointer(&x___stdout_FILE)), fmt, ap)
}

func x_vwscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	return x_vfwscanf(tls, uintptr(unsafe.Pointer(&x___stdin_FILE)), fmt, ap)
}

func x_wprintf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vwprintf(tls, fmt, ap)
	_ = ap
	return ret
}

func x_wscanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	var ap Tva_list
	var ret int32
	ap = va
	ret = x_vwscanf(tls, fmt, ap)
	_ = ap
	return ret
}

func x_abs(tls *TLS, a int32) (r int32) {
	var v1 int32
	if a > int32(0) {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_atof(tls *TLS, s uintptr) (r float64) {
	return x_strtod(tls, s, uintptr(0))
}

func x_atoi(tls *TLS, s uintptr) (r int32) {
	var n int32
	var neg int32
	var v1 uintptr
	var v2 int32
	n = int32(0)
	neg = int32(0)
	for ___isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	for BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v1 = s
		s++
		n = int32(10)*n - (int32(*(*int8)(unsafe.Pointer(v1))) - int32('0'))
	}
	if neg != 0 {
		v2 = n
	} else {
		v2 = -n
	}
	return v2
}

func x_atol(tls *TLS, s uintptr) (r int64) {
	var n int64
	var neg int32
	var v1 uintptr
	var v2 int64
	n = int64(0)
	neg = int32(0)
	for ___isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	for BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v1 = s
		s++
		n = int64(10)*n - int64(int32(*(*int8)(unsafe.Pointer(v1)))-Int32FromUint8('0'))
	}
	if neg != 0 {
		v2 = n
	} else {
		v2 = -n
	}
	return v2
}

func x_atoll(tls *TLS, s uintptr) (r int64) {
	var n int64
	var neg int32
	var v1 uintptr
	var v2 int64
	n = int64(0)
	neg = int32(0)
	for ___isspace(tls, int32(*(*int8)(unsafe.Pointer(s)))) != 0 {
		s++
	}
	switch int32(*(*int8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on LLONG_MIN */
	for BoolInt32(uint32(*(*int8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v1 = s
		s++
		n = int64(10)*n - int64(int32(*(*int8)(unsafe.Pointer(v1)))-Int32FromUint8('0'))
	}
	if neg != 0 {
		v2 = n
	} else {
		v2 = -n
	}
	return v2
}

func x_bsearch(tls *TLS, key uintptr, base uintptr, nel Tsize_t, width Tsize_t, cmp uintptr) (r uintptr) {
	var sign int32
	var try uintptr
	for nel > uint64(0) {
		try = base + uintptr(width*(nel/uint64(2)))
		sign = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, try)
		if sign < int32(0) {
			nel = nel / Uint64FromInt32(2)
		} else {
			if sign > int32(0) {
				base = try + uintptr(width)
				nel = nel - (nel/Uint64FromInt32(2) + Uint64FromInt32(1))
			} else {
				return try
			}
		}
	}
	return UintptrFromInt32(0)
}

func x_div(tls *TLS, num int32, den int32) (r Tdiv_t) {
	return Tdiv_t{Fquot: num / den, Frem: num % den}
}

func x_ecvt(tls *TLS, x float64, n int32, dp uintptr, sign uintptr) (r uintptr) {
	bp := tls.Alloc(56) /* tlsAllocs 32 maxValist 2 */
	defer tls.Free(56)
	var i int32
	var j int32
	var _ /* tmp at bp+0 */ [32]int8
	var v1 int32
	var v2 int32
	if uint32(n)-uint32(1) > uint32(15) {
		n = int32(15)
	}
	x_sprintf(tls, bp, ts+3685, VaList(bp+40, n-int32(1), x))
	v1 = BoolInt32(int32((*(*[32]int8)(unsafe.Pointer(bp)))[int32(0)]) == Int32FromUint8('-'))
	*(*int32)(unsafe.Pointer(sign)) = v1
	i = v1
	for j = int32(0); int32((*(*[32]int8)(unsafe.Pointer(bp)))[i]) != int32('e'); {
		_buf9[j] = (*(*[32]int8)(unsafe.Pointer(bp)))[i]
		goto _3
	_3:
		v2 = i
		i++
		j = j + BoolInt32(int32((*(*[32]int8)(unsafe.Pointer(bp)))[v2]) != Int32FromUint8('.'))
	}
	_buf9[j] = int8(0)
	*(*int32)(unsafe.Pointer(dp)) = x_atoi(tls, bp+uintptr(i)+uintptr(1)) + int32(1)
	return uintptr(unsafe.Pointer(&_buf9))
}

var _buf9 [16]int8

func x_fcvt(tls *TLS, x float64, n int32, dp uintptr, sign uintptr) (r uintptr) {
	bp := tls.Alloc(1528) /* tlsAllocs 1504 maxValist 2 */
	defer tls.Free(1528)
	var i int32
	var lz int32
	var _ /* tmp at bp+0 */ [1500]int8
	if uint32(n) > uint32(1400) {
		n = int32(1400)
	}
	x_sprintf(tls, bp, ts+3690, VaList(bp+1512, n, x))
	i = BoolInt32(int32((*(*[1500]int8)(unsafe.Pointer(bp)))[int32(0)]) == int32('-'))
	if int32((*(*[1500]int8)(unsafe.Pointer(bp)))[i]) == int32('0') {
		lz = int32(x_strspn(tls, bp+uintptr(i)+uintptr(2), ts+207))
	} else {
		lz = -int32(x_strcspn(tls, bp+uintptr(i), ts+724))
	}
	if n <= lz {
		*(*int32)(unsafe.Pointer(sign)) = i
		*(*int32)(unsafe.Pointer(dp)) = int32(1)
		if uint32(n) > uint32(14) {
			n = int32(14)
		}
		return ts + 3695 + UintptrFromInt32(14) - uintptr(n)
	}
	return x_ecvt(tls, x, n-lz, dp, sign)
}

func x_gcvt(tls *TLS, x float64, n int32, b uintptr) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 0 maxValist 2 */
	defer tls.Free(24)
	x_sprintf(tls, b, ts+3711, VaList(bp+8, n, x))
	return b
}

func x_imaxabs(tls *TLS, a Tintmax_t) (r Tintmax_t) {
	var v1 int64
	if a > int64(0) {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_imaxdiv(tls *TLS, num Tintmax_t, den Tintmax_t) (r Timaxdiv_t) {
	return Timaxdiv_t{Fquot: num / den, Frem: num % den}
}

func x_labs(tls *TLS, a int64) (r int64) {
	var v1 int64
	if a > int64(0) {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_ldiv(tls *TLS, num int64, den int64) (r Tldiv_t) {
	return Tldiv_t{Fquot: num / den, Frem: num % den}
}

func x_llabs(tls *TLS, a int64) (r int64) {
	var v1 int64
	if a > int64(0) {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func x_lldiv(tls *TLS, num int64, den int64) (r Tlldiv_t) {
	return Tlldiv_t{Fquot: num / den, Frem: num % den}
}

type Tcmpfun = uintptr

func _pntz(tls *TLS, p uintptr) (r1 int32) {
	var r int32
	var v1 int32
	var v2 bool
	r = _a_ctz_l(tls, *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(0)*8))-uint64(1))
	if v2 = r != int32(0); !v2 {
		v1 = int32(Uint64FromInt32(8)*Uint64FromInt64(8) + uint64(_a_ctz_l(tls, *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(1)*8)))))
		r = v1
	}
	if v2 || uint64(v1) != Uint64FromInt32(8)*Uint64FromInt64(8) {
		return r
	}
	return int32(0)
}

func _cycle(tls *TLS, width Tsize_t, ar uintptr, n int32) {
	bp := tls.Alloc(256) /* tlsAllocs 256 maxValist 0 */
	defer tls.Free(256)
	var i int32
	var l Tsize_t
	var _ /* tmp at bp+0 */ [256]uint8
	var v1 uint64
	var p2 uintptr
	if n < int32(2) {
		return
	}
	*(*uintptr)(unsafe.Pointer(ar + uintptr(n)*8)) = bp
	for width != 0 {
		if uint64(256) < width {
			v1 = uint64(256)
		} else {
			v1 = width
		}
		l = v1
		x_memcpy(tls, *(*uintptr)(unsafe.Pointer(ar + uintptr(n)*8)), *(*uintptr)(unsafe.Pointer(ar + UintptrFromInt32(0)*8)), l)
		for i = int32(0); i < n; i++ {
			x_memcpy(tls, *(*uintptr)(unsafe.Pointer(ar + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(ar + uintptr(i+Int32FromInt32(1))*8)), l)
			p2 = ar + uintptr(i)*8
			*(*uintptr)(unsafe.Pointer(p2)) = *(*uintptr)(unsafe.Pointer(p2)) + uintptr(l)
		}
		width = width - l
	}
}

// C documentation
//
//	/* shl() and shr() need n > 0 */
func _shl(tls *TLS, p uintptr, n int32) {
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	if uint64(n) >= Uint64FromInt32(8)*Uint64FromInt64(8) {
		n = int32(uint64(n) - Uint64FromInt32(8)*Uint64FromInt64(8))
		*(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(1)*8)) = *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(0)*8))
		*(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) = uint64(0)
	}
	p1 = p + UintptrFromInt32(1)*8
	*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) << uint64(n)
	p2 = p + UintptrFromInt32(1)*8
	*(*Tsize_t)(unsafe.Pointer(p2)) = *(*Tsize_t)(unsafe.Pointer(p2)) | *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(0)*8))>>(Uint64FromInt64(8)*Uint64FromInt32(8)-uint64(n))
	p3 = p + UintptrFromInt32(0)*8
	*(*Tsize_t)(unsafe.Pointer(p3)) = *(*Tsize_t)(unsafe.Pointer(p3)) << uint64(n)
}

func _shr(tls *TLS, p uintptr, n int32) {
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	if uint64(n) >= Uint64FromInt32(8)*Uint64FromInt64(8) {
		n = int32(uint64(n) - Uint64FromInt32(8)*Uint64FromInt64(8))
		*(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(0)*8)) = *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(1)*8))
		*(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(1)*8)) = uint64(0)
	}
	p1 = p + UintptrFromInt32(0)*8
	*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) >> uint64(n)
	p2 = p + UintptrFromInt32(0)*8
	*(*Tsize_t)(unsafe.Pointer(p2)) = *(*Tsize_t)(unsafe.Pointer(p2)) | *(*Tsize_t)(unsafe.Pointer(p + UintptrFromInt32(1)*8))<<(Uint64FromInt64(8)*Uint64FromInt32(8)-uint64(n))
	p3 = p + UintptrFromInt32(1)*8
	*(*Tsize_t)(unsafe.Pointer(p3)) = *(*Tsize_t)(unsafe.Pointer(p3)) >> uint64(n)
}

func _sift(tls *TLS, head uintptr, width Tsize_t, cmp Tcmpfun, arg uintptr, pshift int32, lp uintptr) {
	bp := tls.Alloc(904) /* tlsAllocs 904 maxValist 0 */
	defer tls.Free(904)
	var i int32
	var lf uintptr
	var rt uintptr
	var _ /* ar at bp+0 */ [113]uintptr
	var v1 int32
	var v2 int32
	i = int32(1)
	(*(*[113]uintptr)(unsafe.Pointer(bp)))[int32(0)] = head
	for pshift > int32(1) {
		rt = head - uintptr(width)
		lf = head - uintptr(width) - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift-Int32FromInt32(2))*8)))
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, (*(*[113]uintptr)(unsafe.Pointer(bp)))[int32(0)], lf, arg) >= int32(0) && (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, (*(*[113]uintptr)(unsafe.Pointer(bp)))[int32(0)], rt, arg) >= int32(0) {
			break
		}
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, lf, rt, arg) >= int32(0) {
			v1 = i
			i++
			(*(*[113]uintptr)(unsafe.Pointer(bp)))[v1] = lf
			head = lf
			pshift = pshift - Int32FromInt32(1)
		} else {
			v2 = i
			i++
			(*(*[113]uintptr)(unsafe.Pointer(bp)))[v2] = rt
			head = rt
			pshift = pshift - Int32FromInt32(2)
		}
	}
	_cycle(tls, width, bp, i)
}

func _trinkle(tls *TLS, head uintptr, width Tsize_t, cmp Tcmpfun, arg uintptr, pp uintptr, pshift int32, trusty int32, lp uintptr) {
	bp := tls.Alloc(920) /* tlsAllocs 920 maxValist 0 */
	defer tls.Free(920)
	var i int32
	var lf uintptr
	var rt uintptr
	var stepson uintptr
	var trail int32
	var _ /* ar at bp+16 */ [113]uintptr
	var _ /* p at bp+0 */ [2]Tsize_t
	var v1 int32
	i = int32(1)
	(*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(0)] = *(*Tsize_t)(unsafe.Pointer(pp + UintptrFromInt32(0)*8))
	(*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] = *(*Tsize_t)(unsafe.Pointer(pp + UintptrFromInt32(1)*8))
	(*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[int32(0)] = head
	for (*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(0)] != uint64(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] != uint64(0) {
		stepson = head - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift)*8)))
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, stepson, (*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[int32(0)], arg) <= int32(0) {
			break
		}
		if !(trusty != 0) && pshift > int32(1) {
			rt = head - uintptr(width)
			lf = head - uintptr(width) - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift-Int32FromInt32(2))*8)))
			if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, rt, stepson, arg) >= int32(0) || (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, lf, stepson, arg) >= int32(0) {
				break
			}
		}
		v1 = i
		i++
		(*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[v1] = stepson
		head = stepson
		trail = _pntz(tls, bp)
		_shr(tls, bp, trail)
		pshift = pshift + trail
		trusty = int32(0)
	}
	if !(trusty != 0) {
		_cycle(tls, width, bp+16, i)
		_sift(tls, head, width, cmp, arg, pshift, lp)
	}
}

func x___qsort_r(tls *TLS, base uintptr, nel Tsize_t, width Tsize_t, cmp Tcmpfun, arg uintptr) {
	bp := tls.Alloc(784) /* tlsAllocs 784 maxValist 0 */
	defer tls.Free(784)
	var head uintptr
	var high uintptr
	var i Tsize_t
	var pshift int32
	var size Tsize_t
	var trail int32
	var _ /* lp at bp+0 */ [96]Tsize_t
	var _ /* p at bp+768 */ [2]Tsize_t
	var v1 Tsize_t
	var v2 Tsize_t
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	size = width * nel
	*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)) = [2]Tsize_t{
		0: uint64(1),
		1: uint64(0)}
	pshift = int32(1)
	if !(size != 0) {
		return
	}
	head = base
	high = head + uintptr(size) - uintptr(width)
	/* Precompute Leonardo numbers, scaled by element width */
	v1 = width
	(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] = v1
	(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[int32(0)] = v1
	i = Uint64FromInt32(2)
	for ; ; i++ {
		v2 = (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i-uint64(2)] + (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i-uint64(1)] + width
		(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i] = v2
		if !(v2 < size) {
			break
		}
	}
	for head < high {
		if (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[int32(0)]&uint64(3) == uint64(3) {
			_sift(tls, head, width, cmp, arg, pshift, bp)
			_shr(tls, bp+768, int32(2))
			pshift = pshift + Int32FromInt32(2)
		} else {
			if (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[pshift-int32(1)] >= uint64(int64(high)-int64(head)) {
				_trinkle(tls, head, width, cmp, arg, bp+768, pshift, int32(0), bp)
			} else {
				_sift(tls, head, width, cmp, arg, pshift, bp)
			}
			if pshift == int32(1) {
				_shl(tls, bp+768, int32(1))
				pshift = int32(0)
			} else {
				_shl(tls, bp+768, pshift-int32(1))
				pshift = int32(1)
			}
		}
		p3 = bp + 768 + UintptrFromInt32(0)*8
		*(*Tsize_t)(unsafe.Pointer(p3)) = *(*Tsize_t)(unsafe.Pointer(p3)) | Uint64FromInt32(1)
		head = head + uintptr(width)
	}
	_trinkle(tls, head, width, cmp, arg, bp+768, pshift, int32(0), bp)
	for pshift != int32(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[int32(0)] != uint64(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[int32(1)] != uint64(0) {
		if pshift <= int32(1) {
			trail = _pntz(tls, bp+768)
			_shr(tls, bp+768, trail)
			pshift = pshift + trail
		} else {
			_shl(tls, bp+768, int32(2))
			pshift = pshift - Int32FromInt32(2)
			p4 = bp + 768 + UintptrFromInt32(0)*8
			*(*Tsize_t)(unsafe.Pointer(p4)) = *(*Tsize_t)(unsafe.Pointer(p4)) ^ Uint64FromInt32(7)
			_shr(tls, bp+768, int32(1))
			_trinkle(tls, head-uintptr((*(*[96]Tsize_t)(unsafe.Pointer(bp)))[pshift])-uintptr(width), width, cmp, arg, bp+768, pshift+int32(1), int32(1), bp)
			_shl(tls, bp+768, int32(1))
			p5 = bp + 768 + UintptrFromInt32(0)*8
			*(*Tsize_t)(unsafe.Pointer(p5)) = *(*Tsize_t)(unsafe.Pointer(p5)) | Uint64FromInt32(1)
			_trinkle(tls, head-uintptr(width), width, cmp, arg, bp+768, pshift, int32(1), bp)
		}
		head = head - uintptr(width)
	}
}

func _wrapper_cmp(tls *TLS, v1 uintptr, v2 uintptr, cmp uintptr) (r int32) {
	return (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, v1, v2)
}

func x_qsort(tls *TLS, base uintptr, nel Tsize_t, width Tsize_t, cmp Tcmpfun) {
	x___qsort_r(tls, base, nel, width, __ccgo_fp(_wrapper_cmp), cmp)
}

func _strtox(tls *TLS, s uintptr, p uintptr, prec int32) (r float64) {
	bp := tls.Alloc(232) /* tlsAllocs 232 maxValist 0 */
	defer tls.Free(232)
	var cnt Toff_t
	var y float64
	var _ /* f at bp+0 */ TFILE
	var v1 uintptr
	var v2 uintptr
	v1 = s
	(*TFILE)(unsafe.Pointer(bp)).Frpos = v1
	(*TFILE)(unsafe.Pointer(bp)).Fbuf = v1
	(*TFILE)(unsafe.Pointer(bp)).Frend = uintptr(-Int32FromInt32(1))
	x___shlim(tls, bp, int64(Int32FromInt32(0)))
	y = x___floatscan(tls, bp, prec, int32(1))
	cnt = (*TFILE)(unsafe.Pointer(bp)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp)).Fbuf))
	if p != 0 {
		if cnt != 0 {
			v2 = s + uintptr(cnt)
		} else {
			v2 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v2
	}
	return y
}

func x_strtof(tls *TLS, s uintptr, p uintptr) (r float32) {
	return float32(_strtox(tls, s, p, int32(0)))
}

func x_strtod(tls *TLS, s uintptr, p uintptr) (r float64) {
	return _strtox(tls, s, p, int32(1))
}

func x_strtold(tls *TLS, s uintptr, p uintptr) (r float64) {
	return _strtox(tls, s, p, int32(2))
}

const m_LONG_MAX = 1

func _strtox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) (r uint64) {
	bp := tls.Alloc(232) /* tlsAllocs 232 maxValist 0 */
	defer tls.Free(232)
	var cnt Tsize_t
	var y uint64
	var _ /* f at bp+0 */ TFILE
	var v1 uintptr
	v1 = s
	(*TFILE)(unsafe.Pointer(bp)).Frpos = v1
	(*TFILE)(unsafe.Pointer(bp)).Fbuf = v1
	(*TFILE)(unsafe.Pointer(bp)).Frend = uintptr(-Int32FromInt32(1))
	x___shlim(tls, bp, int64(Int32FromInt32(0)))
	y = x___intscan(tls, bp, uint32(base), int32(1), lim)
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp)).Fbuf)))
		*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(cnt)
	}
	return y
}

func x_strtoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	return _strtox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func x_strtoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	return int64(_strtox1(tls, s, p, base, uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func x_strtoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	return _strtox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func x_strtol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	return int64(_strtox1(tls, s, p, base, Uint64FromUint64(0)+uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func x_strtoimax(tls *TLS, s uintptr, p uintptr, base int32) (r Tintmax_t) {
	return x_strtoll(tls, s, p, base)
}

func x_strtoumax(tls *TLS, s uintptr, p uintptr, base int32) (r Tuintmax_t) {
	return x_strtoull(tls, s, p, base)
}

func _do_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var wcs uintptr
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	wcs = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*Twchar_t)(unsafe.Pointer(wcs + UintptrFromInt32(0)*4)) != 0) {
		wcs = ts + 3716
	}
	for i = uint64(0); i < (*TFILE)(unsafe.Pointer(f)).Fbuf_size && *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) != 0; i++ {
		if *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) < int32(128) {
			v1 = *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4))
		} else {
			v1 = int32('@')
		}
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i))) = uint8(v1)
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = wcs + uintptr(i)*4
	if i != 0 && len1 != 0 {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v2))
		return uint64(1)
	}
	return uint64(0)
}

func _wcstox(tls *TLS, s uintptr, p uintptr, prec int32) (r float64) {
	bp := tls.Alloc(296) /* tlsAllocs 296 maxValist 0 */
	defer tls.Free(296)
	var cnt Tsize_t
	var t uintptr
	var y float64
	var _ /* buf at bp+0 */ [64]uint8
	var _ /* f at bp+64 */ TFILE
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	t = s
	*(*TFILE)(unsafe.Pointer(bp + 64)) = TFILE{}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fflags = uint32(0)
	v2 = bp + UintptrFromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf = v2
	v1 = v2
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frend = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frpos = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf_size = Uint64FromInt64(64) - Uint64FromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Flock = -int32(1)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fread = __ccgo_fp(_do_read)
	for x_iswspace(tls, uint32(*(*Twchar_t)(unsafe.Pointer(t)))) != 0 {
		t += 4
	}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fcookie = t
	x___shlim(tls, bp+64, int64(Int32FromInt32(0)))
	y = x___floatscan(tls, bp+64, prec, int32(1))
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp+64)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp+64)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp+64)).Fbuf)))
		if cnt != 0 {
			v3 = t + uintptr(cnt)*4
		} else {
			v3 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v3
	}
	return y
}

func x_wcstof(tls *TLS, s uintptr, p uintptr) (r float32) {
	return float32(_wcstox(tls, s, p, int32(0)))
}

func x_wcstod(tls *TLS, s uintptr, p uintptr) (r float64) {
	return _wcstox(tls, s, p, int32(1))
}

func x_wcstold(tls *TLS, s uintptr, p uintptr) (r float64) {
	return _wcstox(tls, s, p, int32(2))
}

func _do_read1(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var wcs uintptr
	var v1 int32
	var v2 uintptr
	var v3 uintptr
	wcs = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*Twchar_t)(unsafe.Pointer(wcs + UintptrFromInt32(0)*4)) != 0) {
		wcs = ts + 3716
	}
	for i = uint64(0); i < (*TFILE)(unsafe.Pointer(f)).Fbuf_size && *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) != 0; i++ {
		if *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) < int32(128) {
			v1 = *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4))
		} else {
			v1 = int32('@')
		}
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i))) = uint8(v1)
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = wcs + uintptr(i)*4
	if i != 0 && len1 != 0 {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v2))
		return uint64(1)
	}
	return uint64(0)
}

func _wcstox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) (r uint64) {
	bp := tls.Alloc(296) /* tlsAllocs 296 maxValist 0 */
	defer tls.Free(296)
	var cnt Tsize_t
	var t uintptr
	var y uint64
	var _ /* buf at bp+0 */ [64]uint8
	var _ /* f at bp+64 */ TFILE
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	t = s
	*(*TFILE)(unsafe.Pointer(bp + 64)) = TFILE{}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fflags = uint32(0)
	v2 = bp + UintptrFromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf = v2
	v1 = v2
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frend = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frpos = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf_size = Uint64FromInt64(64) - Uint64FromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Flock = -int32(1)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fread = __ccgo_fp(_do_read1)
	for x_iswspace(tls, uint32(*(*Twchar_t)(unsafe.Pointer(t)))) != 0 {
		t += 4
	}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fcookie = t
	x___shlim(tls, bp+64, int64(Int32FromInt32(0)))
	y = x___intscan(tls, bp+64, uint32(base), int32(1), lim)
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp+64)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp+64)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp+64)).Fbuf)))
		if cnt != 0 {
			v3 = t + uintptr(cnt)*4
		} else {
			v3 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v3
	}
	return y
}

func x_wcstoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	return _wcstox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func x_wcstoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	return int64(_wcstox1(tls, s, p, base, uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func x_wcstoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	return _wcstox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func x_wcstol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	return int64(_wcstox1(tls, s, p, base, Uint64FromUint64(0)+uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func x_wcstoimax(tls *TLS, s uintptr, p uintptr, base int32) (r Tintmax_t) {
	return x_wcstoll(tls, s, p, base)
}

func x_wcstoumax(tls *TLS, s uintptr, p uintptr, base int32) (r Tuintmax_t) {
	return x_wcstoull(tls, s, p, base)
}

func x_bcmp(tls *TLS, s1 uintptr, s2 uintptr, n Tsize_t) (r int32) {
	return x_memcmp(tls, s1, s2, n)
}

func x_bcopy(tls *TLS, s1 uintptr, s2 uintptr, n Tsize_t) {
	x_memmove(tls, s2, s1, n)
}

func x_bzero(tls *TLS, s uintptr, n Tsize_t) {
	x_memset(tls, s, int32(0), n)
}

func x_explicit_bzero(tls *TLS, d uintptr, n Tsize_t) {
	d = x_memset(tls, d, int32(0), n)
	// __asm__ __volatile__ ("" : : "r"(d) : "memory");
	___assert_fail(tls, ts+240, ts+3724, 7, ts+3741)
}

func x_index(tls *TLS, s uintptr, c int32) (r uintptr) {
	return x_strchr(tls, s, c)
}

const m_UCHAR_MAX = 255

func x_memccpy(tls *TLS, dest uintptr, src uintptr, c int32, n Tsize_t) (r uintptr) {
	var d uintptr
	var k Tsize_t
	var s uintptr
	var wd uintptr
	var ws uintptr
	var v1 uint8
	var v2 bool
	var v5 uint8
	var v6 bool
	d = dest
	s = src
	c = int32(uint8(c))
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v2 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v2 {
				v1 = *(*uint8)(unsafe.Pointer(s))
				*(*uint8)(unsafe.Pointer(d)) = v1
			}
			if !(v2 && int32(v1) != c) {
				break
			}
			goto _3
		_3:
			n--
			s++
			d++
		}
		if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 {
			goto tail
		}
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
		wd = d
		ws = s
		for n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(ws))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
			goto _4
		_4:
			n = n - Uint64FromInt64(8)
			ws += 8
			wd += 8
		}
		d = wd
		s = ws
	}
	for {
		if v6 = n != 0; v6 {
			v5 = *(*uint8)(unsafe.Pointer(s))
			*(*uint8)(unsafe.Pointer(d)) = v5
		}
		if !(v6 && int32(v5) != c) {
			break
		}
		goto _7
	_7:
		n--
		s++
		d++
	}
tail:
	if n != 0 {
		return d + uintptr(1)
	}
	return uintptr(0)
}

func x_memchr(tls *TLS, src uintptr, c int32, n Tsize_t) (r uintptr) {
	var k Tsize_t
	var s uintptr
	var w uintptr
	var v4 uintptr
	s = src
	c = int32(uint8(c))
	for uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		goto _1
	_1:
		s++
		n--
	}
	if n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
		for w = s; n >= Uint64FromInt64(8) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); {
			goto _2
		_2:
			w += 8
			n = n - Uint64FromInt64(8)
		}
		s = w
	}
	for n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		goto _3
	_3:
		s++
		n--
	}
	if n != 0 {
		v4 = s
	} else {
		v4 = uintptr(0)
	}
	return v4
}

func x_memcmp(tls *TLS, vl uintptr, vr uintptr, n Tsize_t) (r1 int32) {
	var l uintptr
	var r uintptr
	var v2 int32
	l = vl
	r = vr
	for n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) {
		goto _1
	_1:
		n--
		l++
		r++
	}
	if n != 0 {
		v2 = int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
	} else {
		v2 = int32(0)
	}
	return v2
}

func x_memcpy(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	var d uintptr
	var s uintptr
	var w Tuint32_t
	var x Tuint32_t
	var v1 uintptr
	var v10 uintptr
	var v11 uintptr
	var v12 uintptr
	var v13 uintptr
	var v15 uintptr
	var v16 uintptr
	var v17 uintptr
	var v18 uintptr
	var v2 uintptr
	var v20 uintptr
	var v21 uintptr
	var v23 uintptr
	var v24 uintptr
	var v25 uintptr
	var v26 uintptr
	var v27 uintptr
	var v28 uintptr
	var v29 uintptr
	var v30 uintptr
	var v31 uintptr
	var v32 uintptr
	var v33 uintptr
	var v34 uintptr
	var v35 uintptr
	var v36 uintptr
	var v37 uintptr
	var v38 uintptr
	var v39 uintptr
	var v4 uintptr
	var v40 uintptr
	var v41 uintptr
	var v42 uintptr
	var v43 uintptr
	var v44 uintptr
	var v45 uintptr
	var v46 uintptr
	var v47 uintptr
	var v48 uintptr
	var v49 uintptr
	var v5 uintptr
	var v50 uintptr
	var v51 uintptr
	var v52 uintptr
	var v53 uintptr
	var v54 uintptr
	var v55 uintptr
	var v56 uintptr
	var v57 uintptr
	var v58 uintptr
	var v59 uintptr
	var v6 uintptr
	var v60 uintptr
	var v61 uintptr
	var v62 uintptr
	var v63 uintptr
	var v64 uintptr
	var v65 uintptr
	var v66 uintptr
	var v67 uintptr
	var v68 uintptr
	var v69 uintptr
	var v7 uintptr
	var v70 uintptr
	var v71 uintptr
	var v72 uintptr
	var v73 uintptr
	var v74 uintptr
	var v75 uintptr
	var v76 uintptr
	var v77 uintptr
	var v78 uintptr
	var v79 uintptr
	var v8 uintptr
	var v80 uintptr
	var v81 uintptr
	var v82 uintptr
	var v83 uintptr
	var v84 uintptr
	var v9 uintptr
	d = dest
	s = src
	for ; uint64(s)%uint64(4) != 0 && n != 0; n-- {
		v1 = d
		d++
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v1)) = *(*uint8)(unsafe.Pointer(v2))
	}
	if uint64(d)%uint64(4) == uint64(0) {
		for n >= uint64(16) {
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(8)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(12)))
			goto _3
		_3:
			s = s + UintptrFromInt32(16)
			d = d + UintptrFromInt32(16)
			n = n - Uint64FromInt32(16)
		}
		if n&uint64(8) != 0 {
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4)))
			d = d + UintptrFromInt32(8)
			s = s + UintptrFromInt32(8)
		}
		if n&uint64(4) != 0 {
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			d = d + UintptrFromInt32(4)
			s = s + UintptrFromInt32(4)
		}
		if n&uint64(2) != 0 {
			v4 = d
			d++
			v5 = s
			s++
			*(*uint8)(unsafe.Pointer(v4)) = *(*uint8)(unsafe.Pointer(v5))
			v6 = d
			d++
			v7 = s
			s++
			*(*uint8)(unsafe.Pointer(v6)) = *(*uint8)(unsafe.Pointer(v7))
		}
		if n&uint64(1) != 0 {
			*(*uint8)(unsafe.Pointer(d)) = *(*uint8)(unsafe.Pointer(s))
		}
		return dest
	}
	if n >= uint64(32) {
		switch uint64(d) % uint64(4) {
		case uint64(1):
			w = *(*uint32)(unsafe.Pointer(s))
			v8 = d
			d++
			v9 = s
			s++
			*(*uint8)(unsafe.Pointer(v8)) = *(*uint8)(unsafe.Pointer(v9))
			v10 = d
			d++
			v11 = s
			s++
			*(*uint8)(unsafe.Pointer(v10)) = *(*uint8)(unsafe.Pointer(v11))
			v12 = d
			d++
			v13 = s
			s++
			*(*uint8)(unsafe.Pointer(v12)) = *(*uint8)(unsafe.Pointer(v13))
			n = n - Uint64FromInt32(3)
			for n >= uint64(17) {
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(1)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(24) | x<<Int32FromInt32(8)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(5)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(24) | w<<Int32FromInt32(8)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(9)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(24) | x<<Int32FromInt32(8)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(13)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(24) | w<<Int32FromInt32(8)
				goto _14
			_14:
				s = s + UintptrFromInt32(16)
				d = d + UintptrFromInt32(16)
				n = n - Uint64FromInt32(16)
			}
		case uint64(2):
			w = *(*uint32)(unsafe.Pointer(s))
			v15 = d
			d++
			v16 = s
			s++
			*(*uint8)(unsafe.Pointer(v15)) = *(*uint8)(unsafe.Pointer(v16))
			v17 = d
			d++
			v18 = s
			s++
			*(*uint8)(unsafe.Pointer(v17)) = *(*uint8)(unsafe.Pointer(v18))
			n = n - Uint64FromInt32(2)
			for n >= uint64(18) {
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(2)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(16) | x<<Int32FromInt32(16)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(6)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(16) | w<<Int32FromInt32(16)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(10)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(16) | x<<Int32FromInt32(16)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(14)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(16) | w<<Int32FromInt32(16)
				goto _19
			_19:
				s = s + UintptrFromInt32(16)
				d = d + UintptrFromInt32(16)
				n = n - Uint64FromInt32(16)
			}
		case uint64(3):
			w = *(*uint32)(unsafe.Pointer(s))
			v20 = d
			d++
			v21 = s
			s++
			*(*uint8)(unsafe.Pointer(v20)) = *(*uint8)(unsafe.Pointer(v21))
			n = n - Uint64FromInt32(1)
			for n >= uint64(19) {
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(3)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(8) | x<<Int32FromInt32(24)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(7)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(8) | w<<Int32FromInt32(24)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(11)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(8) | x<<Int32FromInt32(24)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(15)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(8) | w<<Int32FromInt32(24)
				goto _22
			_22:
				s = s + UintptrFromInt32(16)
				d = d + UintptrFromInt32(16)
				n = n - Uint64FromInt32(16)
			}
			break
		}
	}
	if n&uint64(16) != 0 {
		v23 = d
		d++
		v24 = s
		s++
		*(*uint8)(unsafe.Pointer(v23)) = *(*uint8)(unsafe.Pointer(v24))
		v25 = d
		d++
		v26 = s
		s++
		*(*uint8)(unsafe.Pointer(v25)) = *(*uint8)(unsafe.Pointer(v26))
		v27 = d
		d++
		v28 = s
		s++
		*(*uint8)(unsafe.Pointer(v27)) = *(*uint8)(unsafe.Pointer(v28))
		v29 = d
		d++
		v30 = s
		s++
		*(*uint8)(unsafe.Pointer(v29)) = *(*uint8)(unsafe.Pointer(v30))
		v31 = d
		d++
		v32 = s
		s++
		*(*uint8)(unsafe.Pointer(v31)) = *(*uint8)(unsafe.Pointer(v32))
		v33 = d
		d++
		v34 = s
		s++
		*(*uint8)(unsafe.Pointer(v33)) = *(*uint8)(unsafe.Pointer(v34))
		v35 = d
		d++
		v36 = s
		s++
		*(*uint8)(unsafe.Pointer(v35)) = *(*uint8)(unsafe.Pointer(v36))
		v37 = d
		d++
		v38 = s
		s++
		*(*uint8)(unsafe.Pointer(v37)) = *(*uint8)(unsafe.Pointer(v38))
		v39 = d
		d++
		v40 = s
		s++
		*(*uint8)(unsafe.Pointer(v39)) = *(*uint8)(unsafe.Pointer(v40))
		v41 = d
		d++
		v42 = s
		s++
		*(*uint8)(unsafe.Pointer(v41)) = *(*uint8)(unsafe.Pointer(v42))
		v43 = d
		d++
		v44 = s
		s++
		*(*uint8)(unsafe.Pointer(v43)) = *(*uint8)(unsafe.Pointer(v44))
		v45 = d
		d++
		v46 = s
		s++
		*(*uint8)(unsafe.Pointer(v45)) = *(*uint8)(unsafe.Pointer(v46))
		v47 = d
		d++
		v48 = s
		s++
		*(*uint8)(unsafe.Pointer(v47)) = *(*uint8)(unsafe.Pointer(v48))
		v49 = d
		d++
		v50 = s
		s++
		*(*uint8)(unsafe.Pointer(v49)) = *(*uint8)(unsafe.Pointer(v50))
		v51 = d
		d++
		v52 = s
		s++
		*(*uint8)(unsafe.Pointer(v51)) = *(*uint8)(unsafe.Pointer(v52))
		v53 = d
		d++
		v54 = s
		s++
		*(*uint8)(unsafe.Pointer(v53)) = *(*uint8)(unsafe.Pointer(v54))
	}
	if n&uint64(8) != 0 {
		v55 = d
		d++
		v56 = s
		s++
		*(*uint8)(unsafe.Pointer(v55)) = *(*uint8)(unsafe.Pointer(v56))
		v57 = d
		d++
		v58 = s
		s++
		*(*uint8)(unsafe.Pointer(v57)) = *(*uint8)(unsafe.Pointer(v58))
		v59 = d
		d++
		v60 = s
		s++
		*(*uint8)(unsafe.Pointer(v59)) = *(*uint8)(unsafe.Pointer(v60))
		v61 = d
		d++
		v62 = s
		s++
		*(*uint8)(unsafe.Pointer(v61)) = *(*uint8)(unsafe.Pointer(v62))
		v63 = d
		d++
		v64 = s
		s++
		*(*uint8)(unsafe.Pointer(v63)) = *(*uint8)(unsafe.Pointer(v64))
		v65 = d
		d++
		v66 = s
		s++
		*(*uint8)(unsafe.Pointer(v65)) = *(*uint8)(unsafe.Pointer(v66))
		v67 = d
		d++
		v68 = s
		s++
		*(*uint8)(unsafe.Pointer(v67)) = *(*uint8)(unsafe.Pointer(v68))
		v69 = d
		d++
		v70 = s
		s++
		*(*uint8)(unsafe.Pointer(v69)) = *(*uint8)(unsafe.Pointer(v70))
	}
	if n&uint64(4) != 0 {
		v71 = d
		d++
		v72 = s
		s++
		*(*uint8)(unsafe.Pointer(v71)) = *(*uint8)(unsafe.Pointer(v72))
		v73 = d
		d++
		v74 = s
		s++
		*(*uint8)(unsafe.Pointer(v73)) = *(*uint8)(unsafe.Pointer(v74))
		v75 = d
		d++
		v76 = s
		s++
		*(*uint8)(unsafe.Pointer(v75)) = *(*uint8)(unsafe.Pointer(v76))
		v77 = d
		d++
		v78 = s
		s++
		*(*uint8)(unsafe.Pointer(v77)) = *(*uint8)(unsafe.Pointer(v78))
	}
	if n&uint64(2) != 0 {
		v79 = d
		d++
		v80 = s
		s++
		*(*uint8)(unsafe.Pointer(v79)) = *(*uint8)(unsafe.Pointer(v80))
		v81 = d
		d++
		v82 = s
		s++
		*(*uint8)(unsafe.Pointer(v81)) = *(*uint8)(unsafe.Pointer(v82))
	}
	if n&uint64(1) != 0 {
		*(*uint8)(unsafe.Pointer(d)) = *(*uint8)(unsafe.Pointer(s))
	}
	return dest
	for ; n != 0; n-- {
		v83 = d
		d++
		v84 = s
		s++
		*(*uint8)(unsafe.Pointer(v83)) = *(*uint8)(unsafe.Pointer(v84))
	}
	return dest
}

func _twobyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw Tuint16_t
	var nw Tuint16_t
	var v1 uintptr
	var v3 uintptr
	nw = uint16(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1)))))
	hw = uint16(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1)))))
	h = h + UintptrFromInt32(2)
	k = k - Uint64FromInt32(2)
	for k != 0 {
		if int32(hw) == int32(nw) {
			return h - uintptr(2)
		}
		goto _2
	_2:
		k--
		v1 = h
		h++
		hw = uint16(int32(hw)<<Int32FromInt32(8) | int32(*(*uint8)(unsafe.Pointer(v1))))
	}
	if int32(hw) == int32(nw) {
		v3 = h - uintptr(2)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _threebyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw Tuint32_t
	var nw Tuint32_t
	var v1 uintptr
	var v3 uintptr
	nw = uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(2))))<<int32(8))
	hw = uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(2))))<<int32(8))
	h = h + UintptrFromInt32(3)
	k = k - Uint64FromInt32(3)
	for k != 0 {
		if hw == nw {
			return h - uintptr(3)
		}
		goto _2
	_2:
		k--
		v1 = h
		h++
		hw = (hw | uint32(*(*uint8)(unsafe.Pointer(v1)))) << Int32FromInt32(8)
	}
	if hw == nw {
		v3 = h - uintptr(3)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _fourbyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw Tuint32_t
	var nw Tuint32_t
	var v1 uintptr
	var v3 uintptr
	nw = uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(2))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(3))))
	hw = uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(2))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(3))))
	h = h + UintptrFromInt32(4)
	k = k - Uint64FromInt32(4)
	for k != 0 {
		if hw == nw {
			return h - uintptr(4)
		}
		goto _2
	_2:
		k--
		v1 = h
		h++
		hw = hw<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(v1)))
	}
	if hw == nw {
		v3 = h - uintptr(4)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _twoway_memmem(tls *TLS, h uintptr, z uintptr, n uintptr, l Tsize_t) (r uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var i Tsize_t
	var ip Tsize_t
	var jp Tsize_t
	var k Tsize_t
	var mem Tsize_t
	var mem0 Tsize_t
	var ms Tsize_t
	var p Tsize_t
	var p0 Tsize_t
	var shift [256]Tsize_t
	var _ /* byteset at bp+0 */ [4]Tsize_t
	var v2 Tsize_t
	var v3 Tsize_t
	var v4 Tsize_t
	var v5 Tsize_t
	var v6 Tsize_t
	var v7 Tsize_t
	var v8 uint64
	var v9 uint64
	var p1 uintptr
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	/* Computing length of needle and fill shift table */
	for i = uint64(0); i < l; i++ {
		p1 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(i))))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
		*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) | Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(i))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))
		shift[*(*uint8)(unsafe.Pointer(n + uintptr(i)))] = i + Uint64FromInt32(1)
	}
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v2 = Uint64FromInt32(1)
	p = v2
	k = v2
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) > int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v3 = jp
				jp++
				ip = v3
				v4 = Uint64FromInt32(1)
				p = v4
				k = v4
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v5 = Uint64FromInt32(1)
	p = v5
	k = v5
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) < int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v6 = jp
				jp++
				ip = v6
				v7 = Uint64FromInt32(1)
				p = v7
				k = v7
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if x_memcmp(tls, n, n+uintptr(p), ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v8 = ms
		} else {
			v8 = l - ms - uint64(1)
		}
		p = v8 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Search loop */
	for {
		/* If remainder of haystack is shorter than needle, done */
		if uint64(int64(z)-int64(h)) < l {
			return uintptr(0)
		}
		/* Check last byte first; advance by shift on mismatch */
		if (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1)))))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1)))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
			k = l - shift[*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1))))]
			if k != 0 {
				if k < mem {
					k = mem
				}
				h = h + uintptr(k)
				mem = uint64(0)
				continue
			}
		} else {
			h = h + uintptr(l)
			mem = uint64(0)
			continue
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v9 = ms + uint64(1)
		} else {
			v9 = mem
		}
		k = v9
		for ; k < l && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k)))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k)))); k++ {
		}
		if k < l {
			h = h + uintptr(k-ms)
			mem = uint64(0)
			continue
		}
		/* Compare left half */
		for k = ms + uint64(1); k > mem && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k-Uint64FromInt32(1))))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k-Uint64FromInt32(1))))); k-- {
		}
		if k <= mem {
			return h
		}
		h = h + uintptr(p)
		mem = mem0
	}
	return r
}

func x_memmem(tls *TLS, h0 uintptr, k Tsize_t, n0 uintptr, l Tsize_t) (r uintptr) {
	var h uintptr
	var n uintptr
	h = h0
	n = n0
	/* Return immediately on empty needle */
	if !(l != 0) {
		return h
	}
	/* Return immediately when needle is longer than haystack */
	if k < l {
		return uintptr(0)
	}
	/* Use faster algorithms for short needles */
	h = x_memchr(tls, h0, int32(*(*uint8)(unsafe.Pointer(n))), k)
	if !(h != 0) || l == uint64(1) {
		return h
	}
	k = k - uint64(int64(h)-int64(h0))
	if k < l {
		return uintptr(0)
	}
	if l == uint64(2) {
		return _twobyte_memmem(tls, h, k, n)
	}
	if l == uint64(3) {
		return _threebyte_memmem(tls, h, k, n)
	}
	if l == uint64(4) {
		return _fourbyte_memmem(tls, h, k, n)
	}
	return _twoway_memmem(tls, h, h+uintptr(k), n, l)
}

type TWT = uint64

func x_memmove(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	var d uintptr
	var s uintptr
	var v1 Tsize_t
	var v2 uintptr
	var v3 uintptr
	var v5 uintptr
	var v6 uintptr
	var v7 Tsize_t
	d = dest
	s = src
	if d == s {
		return d
	}
	if uint64(s)-uint64(d)-n <= uint64(-Int32FromInt32(2))*n {
		return x_memcpy(tls, d, s, n)
	}
	if d < s {
		if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
			for uint64(d)%Uint64FromInt64(8) != 0 {
				v1 = n
				n--
				if !(v1 != 0) {
					return dest
				}
				v2 = d
				d++
				v3 = s
				s++
				*(*int8)(unsafe.Pointer(v2)) = *(*int8)(unsafe.Pointer(v3))
			}
			for n >= Uint64FromInt64(8) {
				*(*TWT)(unsafe.Pointer(d)) = *(*TWT)(unsafe.Pointer(s))
				goto _4
			_4:
				n = n - Uint64FromInt64(8)
				d = d + uintptr(Uint64FromInt64(8))
				s = s + uintptr(Uint64FromInt64(8))
			}
		}
		for ; n != 0; n-- {
			v5 = d
			d++
			v6 = s
			s++
			*(*int8)(unsafe.Pointer(v5)) = *(*int8)(unsafe.Pointer(v6))
		}
	} else {
		if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
			for uint64(d+uintptr(n))%Uint64FromInt64(8) != 0 {
				v7 = n
				n--
				if !(v7 != 0) {
					return dest
				}
				*(*int8)(unsafe.Pointer(d + uintptr(n))) = *(*int8)(unsafe.Pointer(s + uintptr(n)))
			}
			for n >= Uint64FromInt64(8) {
				n = n - Uint64FromInt64(8)
				*(*TWT)(unsafe.Pointer(d + uintptr(n))) = *(*TWT)(unsafe.Pointer(s + uintptr(n)))
			}
		}
		for n != 0 {
			n--
			*(*int8)(unsafe.Pointer(d + uintptr(n))) = *(*int8)(unsafe.Pointer(s + uintptr(n)))
		}
	}
	return dest
}

func x_mempcpy(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	return x_memcpy(tls, dest, src, n) + uintptr(n)
}

func x___memrchr(tls *TLS, m uintptr, c int32, n Tsize_t) (r uintptr) {
	var s uintptr
	var v1 Tsize_t
	s = m
	c = int32(uint8(c))
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(s + uintptr(n)))) == c {
			return s + uintptr(n)
		}
	}
	return uintptr(0)
}

func x_memset(tls *TLS, dest uintptr, c int32, n Tsize_t) (r uintptr) {
	var c32 uint32
	var c64 uint64
	var k Tsize_t
	var s uintptr
	s = dest
	/* Fill head and tail with minimal branching. Each
	 * conditional ensures that all the subsequently used
	 * offsets are well-defined and in the dest region. */
	if !(n != 0) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(0))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-Uint64FromInt32(1)))) = uint8(c)
	if n <= uint64(2) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(1))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(2))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-Uint64FromInt32(2)))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-Uint64FromInt32(3)))) = uint8(c)
	if n <= uint64(6) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s + UintptrFromInt32(3))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-Uint64FromInt32(4)))) = uint8(c)
	if n <= uint64(8) {
		return dest
	}
	/* Advance pointer to align it at a 4-byte boundary,
	 * and truncate n to a multiple of 4. The previous code
	 * already took care of any head/tail that get cut off
	 * by the alignment. */
	k = -uint64(s) & uint64(3)
	s = s + uintptr(k)
	n = n - k
	n = n & uint64(-Int32FromInt32(4))
	c32 = uint32(-Int32FromInt32(1)) / Uint32FromInt32(255) * uint32(uint8(c))
	/* In preparation to copy 32 bytes at a time, aligned on
	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
	 * As in the initial byte-based head/tail fill, each
	 * conditional below ensures that the subsequent offsets
	 * are valid (e.g. !(n<=24) implies n>=28). */
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(4))) = c32
	if n <= uint64(8) {
		return dest
	}
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(8))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(12))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(8))) = c32
	if n <= uint64(24) {
		return dest
	}
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(12))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(16))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(20))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(24))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(28))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(24))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(20))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(16))) = c32
	/* Align to a multiple of 8 so we can fill 64 bits at a time,
	 * and avoid writing the same bytes twice as much as is
	 * practical without introducing additional branching. */
	k = uint64(24) + uint64(s)&uint64(4)
	s = s + uintptr(k)
	n = n - k
	/* If this loop is reached, 28 tail bytes have already been
	 * filled, so any remainder when n drops below 32 can be
	 * safely ignored. */
	c64 = uint64(c32) | uint64(c32)<<Int32FromInt32(32)
	for n >= uint64(32) {
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(0))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(8))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(16))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(24))) = c64
		goto _1
	_1:
		n = n - Uint64FromInt32(32)
		s = s + UintptrFromInt32(32)
	}
	return dest
}

func x_rindex(tls *TLS, s uintptr, c int32) (r uintptr) {
	return x_strrchr(tls, s, c)
}

func x___stpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	var wd uintptr
	var ws uintptr
	var v2 int8
	var v3 uintptr
	var v4 uintptr
	var v6 int8
	if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
		for uint64(s)%Uint64FromInt64(8) != 0 {
			v2 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v2
			if !(v2 != 0) {
				return d
			}
			goto _1
		_1:
			s++
			d++
		}
		wd = d
		ws = s
		for !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			goto _5
		_5:
			v3 = wd
			wd += 8
			v4 = ws
			ws += 8
			*(*uint64)(unsafe.Pointer(v3)) = *(*uint64)(unsafe.Pointer(v4))
		}
		d = wd
		s = ws
	}
	for {
		v6 = *(*int8)(unsafe.Pointer(s))
		*(*int8)(unsafe.Pointer(d)) = v6
		if !(v6 != 0) {
			break
		}
		goto _7
	_7:
		s++
		d++
	}
	return d
}

func x___stpncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var wd uintptr
	var ws uintptr
	var v1 int8
	var v2 bool
	var v5 int8
	var v6 bool
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v2 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v2 {
				v1 = *(*int8)(unsafe.Pointer(s))
				*(*int8)(unsafe.Pointer(d)) = v1
			}
			if !(v2 && v1 != 0) {
				break
			}
			goto _3
		_3:
			n--
			s++
			d++
		}
		if !(n != 0) || !(*(*int8)(unsafe.Pointer(s)) != 0) {
			goto tail
		}
		wd = d
		ws = s
		for n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
			goto _4
		_4:
			n = n - Uint64FromInt64(8)
			ws += 8
			wd += 8
		}
		d = wd
		s = ws
	}
	for {
		if v6 = n != 0; v6 {
			v5 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v5
		}
		if !(v6 && v5 != 0) {
			break
		}
		goto _7
	_7:
		n--
		s++
		d++
	}
tail:
	x_memset(tls, d, int32(0), n)
	return d
}

func x_strcasecmp(tls *TLS, _l uintptr, _r uintptr) (r1 int32) {
	var l uintptr
	var r uintptr
	l = _l
	r = _r
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))) {
		goto _1
	_1:
		l++
		r++
	}
	return x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func x___strcasecmp_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	return x_strcasecmp(tls, l, r)
}

func x_strcasestr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var l Tsize_t
	l = x_strlen(tls, n)
	for ; *(*int8)(unsafe.Pointer(h)) != 0; h++ {
		if !(x_strncasecmp(tls, h, n, l) != 0) {
			return h
		}
	}
	return uintptr(0)
}

func x_strcat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x_strcpy(tls, dest+uintptr(x_strlen(tls, dest)), src)
	return dest
}

func x_strchr(tls *TLS, s uintptr, c int32) (r1 uintptr) {
	var r uintptr
	var v1 uintptr
	r = x___strchrnul(tls, s, c)
	if int32(*(*uint8)(unsafe.Pointer(r))) == int32(uint8(c)) {
		v1 = r
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x___strchrnul(tls *TLS, s uintptr, c int32) (r uintptr) {
	var k Tsize_t
	var w uintptr
	c = int32(uint8(c))
	if !(c != 0) {
		return s + uintptr(x_strlen(tls, s))
	}
	for ; uint64(s)%Uint64FromInt64(8) != 0; s++ {
		if !(*(*int8)(unsafe.Pointer(s)) != 0) || int32(*(*uint8)(unsafe.Pointer(s))) == c {
			return s
		}
	}
	k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(m_UCHAR_MAX) * uint64(c)
	for w = s; !((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); w += 8 {
	}
	s = w
	for ; *(*int8)(unsafe.Pointer(s)) != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c; s++ {
	}
	return s
}

func x_strcmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	for int32(*(*int8)(unsafe.Pointer(l))) == int32(*(*int8)(unsafe.Pointer(r))) && *(*int8)(unsafe.Pointer(l)) != 0 {
		goto _1
	_1:
		l++
		r++
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func x_strcpy(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x___stpcpy(tls, dest, src)
	return dest
}

func x_strcspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var a uintptr
	var _ /* byteset at bp+0 */ [4]Tsize_t
	var v2 bool
	var p1 uintptr
	a = s
	if !(*(*int8)(unsafe.Pointer(c + UintptrFromInt32(0))) != 0) || !(*(*int8)(unsafe.Pointer(c + UintptrFromInt32(1))) != 0) {
		return uint64(int64(x___strchrnul(tls, s, int32(*(*int8)(unsafe.Pointer(c))))) - int64(a))
	}
	x_memset(tls, bp, int32(0), uint64(32))
	for ; ; c++ {
		if v2 = *(*int8)(unsafe.Pointer(c)) != 0; v2 {
			p1 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) | Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(c)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))
		}
		if !(v2 && *(*Tsize_t)(unsafe.Pointer(p1)) != 0) {
			break
		}
	}
	for ; *(*int8)(unsafe.Pointer(s)) != 0 && !((*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0); s++ {
	}
	return uint64(int64(s) - int64(a))
}

func x_strdup(tls *TLS, s uintptr) (r uintptr) {
	var d uintptr
	var l Tsize_t
	l = x_strlen(tls, s)
	d = _default_malloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	return x_memcpy(tls, d, s, l+uint64(1))
}

func x_strerror_r(tls *TLS, err int32, buf uintptr, buflen Tsize_t) (r int32) {
	var l Tsize_t
	var msg uintptr
	msg = x_strerror(tls, err)
	l = x_strlen(tls, msg)
	if l >= buflen {
		if buflen != 0 {
			x_memcpy(tls, buf, msg, buflen-uint64(1))
			*(*int8)(unsafe.Pointer(buf + uintptr(buflen-Uint64FromInt32(1)))) = int8(0)
		}
		return int32(m_ERANGE)
	}
	x_memcpy(tls, buf, msg, l+uint64(1))
	return int32(0)
}

func x_strlcat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r Tsize_t) {
	var l Tsize_t
	l = x_strnlen(tls, d, n)
	if l == n {
		return l + x_strlen(tls, s)
	}
	return l + x_strlcpy(tls, d+uintptr(l), s, n-l)
}

func x_strlcpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r Tsize_t) {
	var d0 uintptr
	var wd uintptr
	var ws uintptr
	var v1 Tsize_t
	var v2 int8
	var v3 bool
	var v6 int8
	var v7 bool
	d0 = d
	v1 = n
	n--
	if !(v1 != 0) {
		goto finish
	}
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v3 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v3 {
				v2 = *(*int8)(unsafe.Pointer(s))
				*(*int8)(unsafe.Pointer(d)) = v2
			}
			if !(v3 && v2 != 0) {
				break
			}
			goto _4
		_4:
			n--
			s++
			d++
		}
		if n != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
			wd = d
			ws = s
			for n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
				*(*Tsize_t)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
				goto _5
			_5:
				n = n - Uint64FromInt64(8)
				ws += 8
				wd += 8
			}
			d = wd
			s = ws
		}
	}
	for {
		if v7 = n != 0; v7 {
			v6 = *(*int8)(unsafe.Pointer(s))
			*(*int8)(unsafe.Pointer(d)) = v6
		}
		if !(v7 && v6 != 0) {
			break
		}
		goto _8
	_8:
		n--
		s++
		d++
	}
	*(*int8)(unsafe.Pointer(d)) = int8(0)
finish:
	return uint64(int64(d)-int64(d0)) + x_strlen(tls, s)
	return r
}

func x_strlen(tls *TLS, s uintptr) (r Tsize_t) {
	var a uintptr
	var w uintptr
	a = s
	for ; uint64(s)%Uint64FromInt64(8) != 0; s++ {
		if !(*(*int8)(unsafe.Pointer(s)) != 0) {
			return uint64(int64(s) - int64(a))
		}
	}
	for w = s; !((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(m_UCHAR_MAX)*uint64(Int32FromInt32(m_UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0); w += 8 {
	}
	s = w
	for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
	}
	return uint64(int64(s) - int64(a))
}

func x_strncasecmp(tls *TLS, _l uintptr, _r uintptr, n Tsize_t) (r1 int32) {
	var l uintptr
	var r uintptr
	var v1 Tsize_t
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return int32(0)
	}
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))) {
		goto _2
	_2:
		l++
		r++
		n--
	}
	return x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - x_tolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func x___strncasecmp_l(tls *TLS, l uintptr, r uintptr, n Tsize_t, loc Tlocale_t) (r1 int32) {
	return x_strncasecmp(tls, l, r, n)
}

func x_strncat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var a uintptr
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	a = d
	d = d + uintptr(x_strlen(tls, d))
	for n != 0 && *(*int8)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d++
		v2 = s
		s++
		*(*int8)(unsafe.Pointer(v1)) = *(*int8)(unsafe.Pointer(v2))
	}
	v3 = d
	d++
	*(*int8)(unsafe.Pointer(v3)) = int8(0)
	return a
}

func x_strncmp(tls *TLS, _l uintptr, _r uintptr, n Tsize_t) (r1 int32) {
	var l uintptr
	var r uintptr
	var v1 Tsize_t
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return int32(0)
	}
	for *(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) {
		goto _2
	_2:
		l++
		r++
		n--
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func x_strncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	x___stpncpy(tls, d, s, n)
	return d
}

func x_strndup(tls *TLS, s uintptr, n Tsize_t) (r uintptr) {
	var d uintptr
	var l Tsize_t
	l = x_strnlen(tls, s, n)
	d = _default_malloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	x_memcpy(tls, d, s, l)
	*(*int8)(unsafe.Pointer(d + uintptr(l))) = int8(0)
	return d
}

func x_strnlen(tls *TLS, s uintptr, n Tsize_t) (r Tsize_t) {
	var p uintptr
	var v1 uint64
	p = x_memchr(tls, s, int32(0), n)
	if p != 0 {
		v1 = uint64(int64(p) - int64(s))
	} else {
		v1 = n
	}
	return v1
}

func x_strpbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	var v1 uintptr
	s = s + uintptr(x_strcspn(tls, s, b))
	if *(*int8)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_strrchr(tls *TLS, s uintptr, c int32) (r uintptr) {
	return x___memrchr(tls, s, c, x_strlen(tls, s)+uint64(1))
}

func x_strsep(tls *TLS, str uintptr, sep uintptr) (r uintptr) {
	var end uintptr
	var s uintptr
	var v1 uintptr
	s = *(*uintptr)(unsafe.Pointer(str))
	if !(s != 0) {
		return UintptrFromInt32(0)
	}
	end = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(end)) != 0 {
		v1 = end
		end++
		*(*int8)(unsafe.Pointer(v1)) = int8(0)
	} else {
		end = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(str)) = end
	return s
}

var _strings = [671]int8{'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 'i', 'g', 'n', 'a', 'l', 0, 'H', 'a', 'n', 'g', 'u', 'p', 0, 'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 0, 'Q', 'u', 'i', 't', 0, 'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'i', 'n', 's', 't', 'r', 'u', 'c', 't', 'i', 'o', 'n', 0, 'T', 'r', 'a', 'c', 'e', '/', 'b', 'r', 'e', 'a', 'k', 'p', 'o', 'i', 'n', 't', ' ', 't', 'r', 'a', 'p', 0, 'A', 'b', 'o', 'r', 't', 'e', 'd', 0, 'B', 'u', 's', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'A', 'r', 'i', 't', 'h', 'm', 'e', 't', 'i', 'c', ' ', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 0, 'K', 'i', 'l', 'l', 'e', 'd', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '1', 0, 'S', 'e', 'g', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'u', 'l', 't', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '2', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e', 0, 'A', 'l', 'a', 'r', 'm', ' ', 'c', 'l', 'o', 'c', 'k', 0, 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', 0, 'S', 't', 'a', 'c', 'k', ' ', 'f', 'a', 'u', 'l', 't', 0, 'C', 'h', 'i', 'l', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', ' ', 's', 't', 'a', 't', 'u', 's', 0, 'C', 'o', 'n', 't', 'i', 'n', 'u', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 's', 'i', 'g', 'n', 'a', 'l', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'i', 'n', 'p', 'u', 't', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'o', 'u', 't', 'p', 'u', 't', ')', 0, 'U', 'r', 'g', 'e', 'n', 't', ' ', 'I', '/', 'O', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 0, 'C', 'P', 'U', ' ', 't', 'i', 'm', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'F', 'i', 'l', 'e', ' ', 's', 'i', 'z', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'V', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'P', 'r', 'o', 'f', 'i', 'l', 'i', 'n', 'g', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'W', 'i', 'n', 'd', 'o', 'w', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', 0, 'I', '/', 'O', ' ', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e', 0, 'P', 'o', 'w', 'e', 'r', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', 0, 'B', 'a', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l', 0, 'R', 'T', '3', '2', 0, 'R', 'T', '3', '3', 0, 'R', 'T', '3', '4', 0, 'R', 'T', '3', '5', 0, 'R', 'T', '3', '6', 0, 'R', 'T', '3', '7', 0, 'R', 'T', '3', '8', 0, 'R', 'T', '3', '9', 0, 'R', 'T', '4', '0', 0, 'R', 'T', '4', '1', 0, 'R', 'T', '4', '2', 0, 'R', 'T', '4', '3', 0, 'R', 'T', '4', '4', 0, 'R', 'T', '4', '5', 0, 'R', 'T', '4', '6', 0, 'R', 'T', '4', '7', 0, 'R', 'T', '4', '8', 0, 'R', 'T', '4', '9', 0, 'R', 'T', '5', '0', 0, 'R', 'T', '5', '1', 0, 'R', 'T', '5', '2', 0, 'R', 'T', '5', '3', 0, 'R', 'T', '5', '4', 0, 'R', 'T', '5', '5', 0, 'R', 'T', '5', '6', 0, 'R', 'T', '5', '7', 0, 'R', 'T', '5', '8', 0, 'R', 'T', '5', '9', 0, 'R', 'T', '6', '0', 0, 'R', 'T', '6', '1', 0, 'R', 'T', '6', '2', 0, 'R', 'T', '6', '3', 0, 'R', 'T', '6', '4'}

func x_strsignal(tls *TLS, signum int32) (r uintptr) {
	var s uintptr
	var v1 int32
	s = uintptr(unsafe.Pointer(&_strings))
	signum = signum
	if uint32(signum)-uint32(1) >= uint32(Int32FromInt32(m__NSIG)-Int32FromInt32(1)) {
		signum = int32(0)
	}
	for ; ; s++ {
		v1 = signum
		signum--
		if !(v1 != 0) {
			break
		}
		for ; *(*int8)(unsafe.Pointer(s)) != 0; s++ {
		}
	}
	return x___lctrans_cur(tls, s)
}

func x_strspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var a uintptr
	var _ /* byteset at bp+0 */ [4]Tsize_t
	var v2 bool
	var p1 uintptr
	a = s
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	if !(*(*int8)(unsafe.Pointer(c + UintptrFromInt32(0))) != 0) {
		return uint64(0)
	}
	if !(*(*int8)(unsafe.Pointer(c + UintptrFromInt32(1))) != 0) {
		for ; int32(*(*int8)(unsafe.Pointer(s))) == int32(*(*int8)(unsafe.Pointer(c))); s++ {
		}
		return uint64(int64(s) - int64(a))
	}
	for ; ; c++ {
		if v2 = *(*int8)(unsafe.Pointer(c)) != 0; v2 {
			p1 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) | Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(c)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))
		}
		if !(v2 && *(*Tsize_t)(unsafe.Pointer(p1)) != 0) {
			break
		}
	}
	for ; *(*int8)(unsafe.Pointer(s)) != 0 && (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0; s++ {
	}
	return uint64(int64(s) - int64(a))
}

func _twobyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw Tuint16_t
	var nw Tuint16_t
	var v1 uintptr
	var v3 uintptr
	nw = uint16(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1)))))
	hw = uint16(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1)))))
	for h++; *(*uint8)(unsafe.Pointer(h)) != 0 && int32(hw) != int32(nw); {
		goto _2
	_2:
		h++
		v1 = h
		hw = uint16(int32(hw)<<int32(8) | int32(*(*uint8)(unsafe.Pointer(v1))))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(1)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _threebyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw Tuint32_t
	var nw Tuint32_t
	var v1 uintptr
	var v3 uintptr
	nw = uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(2))))<<int32(8))
	hw = uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(2))))<<int32(8))
	h = h + UintptrFromInt32(2)
	for *(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw {
		goto _2
	_2:
		h++
		v1 = h
		hw = (hw | uint32(*(*uint8)(unsafe.Pointer(v1)))) << int32(8)
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(2)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _fourbyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw Tuint32_t
	var nw Tuint32_t
	var v1 uintptr
	var v3 uintptr
	nw = uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(2))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(n + UintptrFromInt32(3))))
	hw = uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(0))))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(1))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(2))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(h + UintptrFromInt32(3))))
	h = h + UintptrFromInt32(3)
	for *(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw {
		goto _2
	_2:
		h++
		v1 = h
		hw = hw<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(v1)))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(3)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _twoway_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var grow Tsize_t
	var ip Tsize_t
	var jp Tsize_t
	var k Tsize_t
	var l Tsize_t
	var mem Tsize_t
	var mem0 Tsize_t
	var ms Tsize_t
	var p Tsize_t
	var p0 Tsize_t
	var shift [256]Tsize_t
	var z uintptr
	var z2 uintptr
	var _ /* byteset at bp+0 */ [4]Tsize_t
	var v2 Tsize_t
	var v3 Tsize_t
	var v4 Tsize_t
	var v5 Tsize_t
	var v6 Tsize_t
	var v7 Tsize_t
	var v8 uint64
	var v9 uint64
	var p1 uintptr
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	/* Computing length of needle and fill shift table */
	for l = uint64(0); *(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 && *(*uint8)(unsafe.Pointer(h + uintptr(l))) != 0; l++ {
		p1 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l))))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
		*(*Tsize_t)(unsafe.Pointer(p1)) = *(*Tsize_t)(unsafe.Pointer(p1)) | Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))
		shift[*(*uint8)(unsafe.Pointer(n + uintptr(l)))] = l + Uint64FromInt32(1)
	}
	if *(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v2 = Uint64FromInt32(1)
	p = v2
	k = v2
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) > int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v3 = jp
				jp++
				ip = v3
				v4 = Uint64FromInt32(1)
				p = v4
				k = v4
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v5 = Uint64FromInt32(1)
	p = v5
	k = v5
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) < int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v6 = jp
				jp++
				ip = v6
				v7 = Uint64FromInt32(1)
				p = v7
				k = v7
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if x_memcmp(tls, n, n+uintptr(p), ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v8 = ms
		} else {
			v8 = l - ms - uint64(1)
		}
		p = v8 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64(int64(z)-int64(h)) < l {
			/* Fast estimate for MAX(l,63) */
			grow = l | uint64(63)
			z2 = x_memchr(tls, z, int32(0), grow)
			if z2 != 0 {
				z = z2
				if uint64(int64(z)-int64(h)) < l {
					return uintptr(0)
				}
			} else {
				z = z + uintptr(grow)
			}
		}
		/* Check last byte first; advance by shift on mismatch */
		if (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1)))))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1)))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
			k = l - shift[*(*uint8)(unsafe.Pointer(h + uintptr(l-Uint64FromInt32(1))))]
			if k != 0 {
				if k < mem {
					k = mem
				}
				h = h + uintptr(k)
				mem = uint64(0)
				continue
			}
		} else {
			h = h + uintptr(l)
			mem = uint64(0)
			continue
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v9 = ms + uint64(1)
		} else {
			v9 = mem
		}
		k = v9
		for ; *(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k)))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k)))); k++ {
		}
		if *(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 {
			h = h + uintptr(k-ms)
			mem = uint64(0)
			continue
		}
		/* Compare left half */
		for k = ms + uint64(1); k > mem && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k-Uint64FromInt32(1))))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k-Uint64FromInt32(1))))); k-- {
		}
		if k <= mem {
			return h
		}
		h = h + uintptr(p)
		mem = mem0
	}
	return r
}

func x_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	/* Return immediately on empty needle */
	if !(*(*int8)(unsafe.Pointer(n + UintptrFromInt32(0))) != 0) {
		return h
	}
	/* Use faster algorithms for short needles */
	h = x_strchr(tls, h, int32(*(*int8)(unsafe.Pointer(n))))
	if !(h != 0) || !(*(*int8)(unsafe.Pointer(n + UintptrFromInt32(1))) != 0) {
		return h
	}
	if !(*(*int8)(unsafe.Pointer(h + UintptrFromInt32(1))) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + UintptrFromInt32(2))) != 0) {
		return _twobyte_strstr(tls, h, n)
	}
	if !(*(*int8)(unsafe.Pointer(h + UintptrFromInt32(2))) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + UintptrFromInt32(3))) != 0) {
		return _threebyte_strstr(tls, h, n)
	}
	if !(*(*int8)(unsafe.Pointer(h + UintptrFromInt32(3))) != 0) {
		return uintptr(0)
	}
	if !(*(*int8)(unsafe.Pointer(n + UintptrFromInt32(4))) != 0) {
		return _fourbyte_strstr(tls, h, n)
	}
	return _twoway_strstr(tls, h, n)
}

func x_strtok(tls *TLS, s uintptr, sep uintptr) (r uintptr) {
	var v1 uintptr
	var v2 bool
	var v3 uintptr
	var v4 uintptr
	if v2 = !(s != 0); v2 {
		v1 = _p2
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s = s + uintptr(x_strspn(tls, s, sep))
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		_p2 = v3
		return v3
	}
	_p2 = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(_p2)) != 0 {
		v4 = _p2
		_p2++
		*(*int8)(unsafe.Pointer(v4)) = int8(0)
	} else {
		_p2 = uintptr(0)
	}
	return s
}

var _p2 uintptr

func x_strtok_r(tls *TLS, s uintptr, sep uintptr, p uintptr) (r uintptr) {
	var v1 uintptr
	var v2 bool
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	if v2 = !(s != 0); v2 {
		v1 = *(*uintptr)(unsafe.Pointer(p))
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s = s + uintptr(x_strspn(tls, s, sep))
	if !(*(*int8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		*(*uintptr)(unsafe.Pointer(p)) = v3
		return v3
	}
	*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(x_strcspn(tls, s, sep))
	if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))) != 0 {
		v5 = p
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5))++
		*(*int8)(unsafe.Pointer(v4)) = int8(0)
	} else {
		*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
	}
	return s
}

func x_strverscmp(tls *TLS, l0 uintptr, r0 uintptr) (r1 int32) {
	var c int32
	var dp Tsize_t
	var i Tsize_t
	var j Tsize_t
	var l uintptr
	var r uintptr
	var z int32
	var v1 Tsize_t
	l = l0
	r = r0
	z = int32(1)
	/* Find maximal matching prefix and track its maximal digit
	 * suffix and whether those digits are all zeros. */
	v1 = Uint64FromInt32(0)
	i = v1
	dp = v1
	for ; int32(*(*uint8)(unsafe.Pointer(l + uintptr(i)))) == int32(*(*uint8)(unsafe.Pointer(r + uintptr(i)))); i++ {
		c = int32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))
		if !(c != 0) {
			return int32(0)
		}
		if !(BoolInt32(uint32(c)-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			dp = i + uint64(1)
			z = Int32FromInt32(1)
		} else {
			if c != int32('0') {
				z = int32(0)
			}
		}
	}
	if uint32(int32(*(*uint8)(unsafe.Pointer(l + uintptr(dp))))-int32('1')) < uint32(9) && uint32(int32(*(*uint8)(unsafe.Pointer(r + uintptr(dp))))-int32('1')) < uint32(9) {
		/* If we're looking at non-degenerate digit sequences starting
		 * with nonzero digits, longest digit string is greater. */
		for j = i; BoolInt32(uint32(*(*uint8)(unsafe.Pointer(l + uintptr(j))))-uint32('0') < uint32(10)) != 0; j++ {
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(j))))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
				return int32(1)
			}
		}
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(j))))-uint32('0') < uint32(10)) != 0 {
			return -int32(1)
		}
	} else {
		if z != 0 && dp < i && (BoolInt32(uint32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))-uint32('0') < uint32(10)) != 0 || BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))-uint32('0') < uint32(10)) != 0) {
			/* Otherwise, if common prefix of digit sequence is
			 * all zeros, digits order less than non-digits. */
			return int32(uint8(int32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))-Int32FromUint8('0'))) - int32(uint8(int32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))-Int32FromUint8('0')))
		}
	}
	return int32(*(*uint8)(unsafe.Pointer(l + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))
}

func x_swab(tls *TLS, _src uintptr, _dest uintptr, n Tssize_t) {
	var dest uintptr
	var src uintptr
	src = _src
	dest = _dest
	for n > int64(1) {
		*(*int8)(unsafe.Pointer(dest + UintptrFromInt32(0))) = *(*int8)(unsafe.Pointer(src + UintptrFromInt32(1)))
		*(*int8)(unsafe.Pointer(dest + UintptrFromInt32(1))) = *(*int8)(unsafe.Pointer(src + UintptrFromInt32(0)))
		dest = dest + UintptrFromInt32(2)
		src = src + UintptrFromInt32(2)
		goto _1
	_1:
		n = n - Int64FromInt32(2)
	}
}

func x_wcpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	return x_wcscpy(tls, d, s) + uintptr(x_wcslen(tls, s))*4
}

func x_wcpncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	return x_wcsncpy(tls, d, s, n) + uintptr(x_wcsnlen(tls, s, n))*4
}

func x_wcscasecmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	return x_wcsncasecmp(tls, l, r, uint64(-Int32FromInt32(1)))
}

func x_wcscasecmp_l(tls *TLS, l uintptr, r uintptr, locale Tlocale_t) (r1 int32) {
	return x_wcscasecmp(tls, l, r)
}

func x_wcscat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	x_wcscpy(tls, dest+uintptr(x_wcslen(tls, dest))*4, src)
	return dest
}

func x_wcschr(tls *TLS, s uintptr, c Twchar_t) (r uintptr) {
	var v1 uintptr
	if !(c != 0) {
		return s + uintptr(x_wcslen(tls, s))*4
	}
	for ; *(*Twchar_t)(unsafe.Pointer(s)) != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != c; s += 4 {
	}
	if *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_wcscmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	var v2 int32
	for *(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) && *(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0 {
		goto _1
	_1:
		l += 4
		r += 4
	}
	if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
		v2 = -int32(1)
	} else {
		v2 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
	}
	return v2
}

func x_wcscpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	var a uintptr
	var v1 Twchar_t
	var v2 uintptr
	var v3 uintptr
	a = d
	for {
		v2 = s
		s += 4
		v1 = *(*Twchar_t)(unsafe.Pointer(v2))
		v3 = d
		d += 4
		*(*Twchar_t)(unsafe.Pointer(v3)) = v1
		if !(v1 != 0) {
			break
		}
	}
	return a
}

func x_wcscspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	var a uintptr
	var v1 uint64
	var v2 uintptr
	var v3 uintptr
	if !(*(*Twchar_t)(unsafe.Pointer(c + UintptrFromInt32(0)*4)) != 0) {
		return x_wcslen(tls, s)
	}
	if !(*(*Twchar_t)(unsafe.Pointer(c + UintptrFromInt32(1)*4)) != 0) {
		v3 = s
		a = v3
		v2 = x_wcschr(tls, v3, *(*Twchar_t)(unsafe.Pointer(c)))
		s = v2
		if v2 != 0 {
			v1 = uint64((int64(s) - int64(a)) / 4)
		} else {
			v1 = x_wcslen(tls, a)
		}
		return v1
	}
	for a = s; *(*Twchar_t)(unsafe.Pointer(s)) != 0 && !(x_wcschr(tls, c, *(*Twchar_t)(unsafe.Pointer(s))) != 0); s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func x_wcsdup(tls *TLS, s uintptr) (r uintptr) {
	var d uintptr
	var l Tsize_t
	l = x_wcslen(tls, s)
	d = _default_malloc(tls, (l+uint64(1))*uint64(4))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	return x_wmemcpy(tls, d, s, l+uint64(1))
}

func x_wcslen(tls *TLS, s uintptr) (r Tsize_t) {
	var a uintptr
	for a = s; *(*Twchar_t)(unsafe.Pointer(s)) != 0; s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func x_wcsncasecmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	var v1 Tsize_t
	v1 = n
	n--
	if !(v1 != 0) {
		return int32(0)
	}
	for *(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0 && n != 0 && (*(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) || x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(l)))) == x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(r))))) {
		goto _2
	_2:
		l += 4
		r += 4
		n--
	}
	return int32(x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(l)))) - x_towlower(tls, uint32(*(*Twchar_t)(unsafe.Pointer(r)))))
}

func x_wcsncasecmp_l(tls *TLS, l uintptr, r uintptr, n Tsize_t, locale Tlocale_t) (r1 int32) {
	return x_wcsncasecmp(tls, l, r, n)
}

func x_wcsncat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var a uintptr
	var v1 uintptr
	var v2 uintptr
	var v3 uintptr
	a = d
	d = d + uintptr(x_wcslen(tls, d))*4
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d += 4
		v2 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v1)) = *(*Twchar_t)(unsafe.Pointer(v2))
	}
	v3 = d
	d += 4
	*(*Twchar_t)(unsafe.Pointer(v3)) = int32(0)
	return a
}

func x_wcsncmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	var v2 int32
	var v3 int32
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) && *(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0 {
		goto _1
	_1:
		n--
		l += 4
		r += 4
	}
	if n != 0 {
		if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
			v3 = -int32(1)
		} else {
			v3 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
		}
		v2 = v3
	} else {
		v2 = int32(0)
	}
	return v2
}

func x_wcsncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var a uintptr
	var v1 uintptr
	var v2 uintptr
	a = d
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d += 4
		v2 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v1)) = *(*Twchar_t)(unsafe.Pointer(v2))
	}
	x_wmemset(tls, d, int32(0), n)
	return a
}

func x_wcsnlen(tls *TLS, s uintptr, n Tsize_t) (r Tsize_t) {
	var z uintptr
	z = x_wmemchr(tls, s, int32(0), n)
	if z != 0 {
		n = uint64((int64(z) - int64(s)) / 4)
	}
	return n
}

func x_wcspbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	var v1 uintptr
	s = s + uintptr(x_wcscspn(tls, s, b))*4
	if *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = UintptrFromInt32(0)
	}
	return v1
}

func x_wcsrchr(tls *TLS, s uintptr, c Twchar_t) (r uintptr) {
	var p uintptr
	var v1 uintptr
	for p = s + uintptr(x_wcslen(tls, s))*4; p >= s && *(*Twchar_t)(unsafe.Pointer(p)) != c; p -= 4 {
	}
	if p >= s {
		v1 = p
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_wcsspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	var a uintptr
	for a = s; *(*Twchar_t)(unsafe.Pointer(s)) != 0 && x_wcschr(tls, c, *(*Twchar_t)(unsafe.Pointer(s))) != 0; s += 4 {
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func _twoway_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var grow Tsize_t
	var ip Tsize_t
	var jp Tsize_t
	var k Tsize_t
	var l Tsize_t
	var mem Tsize_t
	var mem0 Tsize_t
	var ms Tsize_t
	var p Tsize_t
	var p0 Tsize_t
	var z uintptr
	var z2 uintptr
	var v1 Tsize_t
	var v2 Tsize_t
	var v3 Tsize_t
	var v4 Tsize_t
	var v5 Tsize_t
	var v6 Tsize_t
	var v7 uint64
	var v8 uint64
	/* Computing length of needle */
	for l = uint64(0); *(*Twchar_t)(unsafe.Pointer(n + uintptr(l)*4)) != 0 && *(*Twchar_t)(unsafe.Pointer(h + uintptr(l)*4)) != 0; l++ {
	}
	if *(*Twchar_t)(unsafe.Pointer(n + uintptr(l)*4)) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v1 = Uint64FromInt32(1)
	p = v1
	k = v1
	for jp+k < l {
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) > *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v2 = jp
				jp++
				ip = v2
				v3 = Uint64FromInt32(1)
				p = v3
				k = v3
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v4 = Uint64FromInt32(1)
	p = v4
	k = v4
	for jp+k < l {
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp = jp + p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) < *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp = jp + k
				k = uint64(1)
				p = jp - ip
			} else {
				v5 = jp
				jp++
				ip = v5
				v6 = Uint64FromInt32(1)
				p = v6
				k = v6
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if x_wmemcmp(tls, n, n+uintptr(p)*4, ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v7 = ms
		} else {
			v7 = l - ms - uint64(1)
		}
		p = v7 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64((int64(z)-int64(h))/4) < l {
			/* Fast estimate for MIN(l,63) */
			grow = l | uint64(63)
			z2 = x_wmemchr(tls, z, int32(0), grow)
			if z2 != 0 {
				z = z2
				if uint64((int64(z)-int64(h))/4) < l {
					return uintptr(0)
				}
			} else {
				z = z + uintptr(grow)*4
			}
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v8 = ms + uint64(1)
		} else {
			v8 = mem
		}
		k = v8
		for ; *(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) != 0 && *(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) == *(*Twchar_t)(unsafe.Pointer(h + uintptr(k)*4)); k++ {
		}
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) != 0 {
			h = h + uintptr(k-ms)*4
			mem = uint64(0)
			continue
		}
		/* Compare left half */
		for k = ms + uint64(1); k > mem && *(*Twchar_t)(unsafe.Pointer(n + uintptr(k-Uint64FromInt32(1))*4)) == *(*Twchar_t)(unsafe.Pointer(h + uintptr(k-Uint64FromInt32(1))*4)); k-- {
		}
		if k <= mem {
			return h
		}
		h = h + uintptr(p)*4
		mem = mem0
	}
	return r
}

func x_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	/* Return immediately on empty needle or haystack */
	if !(*(*Twchar_t)(unsafe.Pointer(n + UintptrFromInt32(0)*4)) != 0) {
		return h
	}
	if !(*(*Twchar_t)(unsafe.Pointer(h + UintptrFromInt32(0)*4)) != 0) {
		return uintptr(0)
	}
	/* Use faster algorithms for short needles */
	h = x_wcschr(tls, h, *(*Twchar_t)(unsafe.Pointer(n)))
	if !(h != 0) || !(*(*Twchar_t)(unsafe.Pointer(n + UintptrFromInt32(1)*4)) != 0) {
		return h
	}
	if !(*(*Twchar_t)(unsafe.Pointer(h + UintptrFromInt32(1)*4)) != 0) {
		return uintptr(0)
	}
	return _twoway_wcsstr(tls, h, n)
}

func x_wcstok(tls *TLS, s uintptr, sep uintptr, p uintptr) (r uintptr) {
	var v1 uintptr
	var v2 bool
	var v3 uintptr
	var v4 uintptr
	var v5 uintptr
	if v2 = !(s != 0); v2 {
		v1 = *(*uintptr)(unsafe.Pointer(p))
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s = s + uintptr(x_wcsspn(tls, s, sep))*4
	if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		*(*uintptr)(unsafe.Pointer(p)) = v3
		return v3
	}
	*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(x_wcscspn(tls, s, sep))*4
	if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))) != 0 {
		v5 = p
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5)) += 4
		*(*Twchar_t)(unsafe.Pointer(v4)) = int32(0)
	} else {
		*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
	}
	return s
}

func x_wcswcs(tls *TLS, haystack uintptr, needle uintptr) (r uintptr) {
	return x_wcsstr(tls, haystack, needle)
}

func x_wmemchr(tls *TLS, s uintptr, c Twchar_t, n Tsize_t) (r uintptr) {
	var v2 uintptr
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != c {
		goto _1
	_1:
		n--
		s += 4
	}
	if n != 0 {
		v2 = s
	} else {
		v2 = uintptr(0)
	}
	return v2
}

func x_wmemcmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	var v2 int32
	var v3 int32
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) {
		goto _1
	_1:
		n--
		l += 4
		r += 4
	}
	if n != 0 {
		if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
			v3 = -int32(1)
		} else {
			v3 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
		}
		v2 = v3
	} else {
		v2 = int32(0)
	}
	return v2
}

func x_wmemcpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var a uintptr
	var v1 Tsize_t
	var v2 uintptr
	var v3 uintptr
	a = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		v3 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v2)) = *(*Twchar_t)(unsafe.Pointer(v3))
	}
	return a
}

func x_wmemmove(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	var d0 uintptr
	var v1 Tsize_t
	var v2 Tsize_t
	var v3 uintptr
	var v4 uintptr
	d0 = d
	if d == s {
		return d
	}
	if uint64(d)-uint64(s) < n*uint64(4) {
		for {
			v1 = n
			n--
			if !(v1 != 0) {
				break
			}
			*(*Twchar_t)(unsafe.Pointer(d + uintptr(n)*4)) = *(*Twchar_t)(unsafe.Pointer(s + uintptr(n)*4))
		}
	} else {
		for {
			v2 = n
			n--
			if !(v2 != 0) {
				break
			}
			v3 = d
			d += 4
			v4 = s
			s += 4
			*(*Twchar_t)(unsafe.Pointer(v3)) = *(*Twchar_t)(unsafe.Pointer(v4))
		}
	}
	return d0
}

func x_wmemset(tls *TLS, d uintptr, c Twchar_t, n Tsize_t) (r uintptr) {
	var ret uintptr
	var v1 Tsize_t
	var v2 uintptr
	ret = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		*(*Twchar_t)(unsafe.Pointer(v2)) = c
	}
	return ret
}

// C documentation
//
//	/* This assumes that a check for the
//	   template size has already been made */
func x___randname(tls *TLS, template uintptr) (r1 uintptr) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var i int32
	var r uint64
	var _ /* ts at bp+0 */ Ttimespec
	x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp)
	r = uint64((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec+(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec) + uint64((*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid)*uint64(65537)
	for i = int32(0); i < int32(6); {
		*(*int8)(unsafe.Pointer(template + uintptr(i))) = int8(uint64('A') + r&uint64(15) + r&uint64(16)*uint64(2))
		goto _1
	_1:
		i++
		r = r >> Uint64FromInt32(5)
	}
	return template
}

const m_EEXIST = 17

func x_mkdtemp(tls *TLS, template uintptr) (r uintptr) {
	var l Tsize_t
	var retries int32
	var v1 int32
	l = x_strlen(tls, template)
	retries = int32(100)
	if l < uint64(6) || x_memcmp(tls, template+uintptr(l)-uintptr(6), ts+3756, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return uintptr(0)
	}
	for first := true; ; first = false {
		if !first {
			retries--
			v1 = retries
			if !(v1 != 0 && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EEXIST)) {
				break
			}
		}
		x___randname(tls, template+uintptr(l)-uintptr(6))
		if !(x_mkdir(tls, template, uint32(0700)) != 0) {
			return template
		}
	}
	x_memcpy(tls, template+uintptr(l)-uintptr(6), ts+3756, uint64(6))
	return uintptr(0)
}

func x_mkostemp(tls *TLS, template uintptr, flags int32) (r int32) {
	return x___mkostemps(tls, template, int32(0), flags)
}

func x___mkostemps(tls *TLS, template uintptr, len1 int32, flags int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	var fd int32
	var l Tsize_t
	var retries int32
	var v1 int32
	var v2 int32
	l = x_strlen(tls, template)
	if l < uint64(6) || uint64(len1) > l-uint64(6) || x_memcmp(tls, template+uintptr(l)-uintptr(len1)-uintptr(6), ts+3756, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	flags = flags - flags&(Int32FromInt32(03)|Int32FromInt32(m_O_PATH))
	retries = int32(100)
	for first := true; ; first = false {
		if !first {
			retries--
			v1 = retries
			if !(v1 != 0 && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EEXIST)) {
				break
			}
		}
		x___randname(tls, template+uintptr(l)-uintptr(len1)-uintptr(6))
		v2 = x_open(tls, template, flags|int32(m_O_RDWR)|int32(m_O_CREAT)|int32(m_O_EXCL), VaList(bp+8, int32(0600)))
		fd = v2
		if v2 >= int32(0) {
			return fd
		}
	}
	x_memcpy(tls, template+uintptr(l)-uintptr(len1)-uintptr(6), ts+3756, uint64(6))
	return -int32(1)
}

func x_mkstemp(tls *TLS, template uintptr) (r int32) {
	return x___mkostemps(tls, template, int32(0), int32(0))
}

func x_mkstemps(tls *TLS, template uintptr, len1 int32) (r int32) {
	return x___mkostemps(tls, template, len1, int32(0))
}

func x_mktemp(tls *TLS, template uintptr) (r uintptr) {
	bp := tls.Alloc(144) /* tlsAllocs 144 maxValist 0 */
	defer tls.Free(144)
	var l Tsize_t
	var retries int32
	var _ /* st at bp+0 */ Tstat
	var v1 int32
	l = x_strlen(tls, template)
	retries = int32(100)
	if l < uint64(6) || x_memcmp(tls, template+uintptr(l)-uintptr(6), ts+3756, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		*(*int8)(unsafe.Pointer(template)) = int8(0)
		return template
	}
	for first := true; ; first = false {
		if !first {
			retries--
			v1 = retries
			if !(v1 != 0) {
				break
			}
		}
		x___randname(tls, template+uintptr(l)-uintptr(6))
		if x_stat(tls, template, bp) != 0 {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOENT) {
				*(*int8)(unsafe.Pointer(template)) = int8(0)
			}
			return template
		}
	}
	*(*int8)(unsafe.Pointer(template)) = int8(0)
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EEXIST)
	return template
}

const m_CBAUD = 4111

func x_cfgetospeed(tls *TLS, tio uintptr) (r Tspeed_t) {
	return (*Ttermios)(unsafe.Pointer(tio)).Fc_cflag & uint32(m_CBAUD)
}

func x_cfgetispeed(tls *TLS, tio uintptr) (r Tspeed_t) {
	return x_cfgetospeed(tls, tio)
}

const m_BRKINT = 2
const m_CS8 = 48
const m_CSIZE = 48
const m_ECHONL = 64
const m_IEXTEN = 32768
const m_IGNBRK = 1
const m_ISTRIP = 32
const m_IXON = 1024
const m_OPOST = 1
const m_PARENB = 256
const m_PARMRK = 8
const m_VMIN = 6
const m_VTIME = 5

func x_cfmakeraw(tls *TLS, t uintptr) {
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	var p4 uintptr
	var p5 uintptr
	p1 = t
	*(*Ttcflag_t)(unsafe.Pointer(p1)) = *(*Ttcflag_t)(unsafe.Pointer(p1)) & uint32(^(Int32FromInt32(m_IGNBRK) | Int32FromInt32(m_BRKINT) | Int32FromInt32(m_PARMRK) | Int32FromInt32(m_ISTRIP) | Int32FromInt32(m_INLCR) | Int32FromInt32(m_IGNCR) | Int32FromInt32(m_ICRNL) | Int32FromInt32(m_IXON)))
	p2 = t + 4
	*(*Ttcflag_t)(unsafe.Pointer(p2)) = *(*Ttcflag_t)(unsafe.Pointer(p2)) & uint32(^Int32FromInt32(m_OPOST))
	p3 = t + 12
	*(*Ttcflag_t)(unsafe.Pointer(p3)) = *(*Ttcflag_t)(unsafe.Pointer(p3)) & uint32(^(Int32FromInt32(m_ECHO) | Int32FromInt32(m_ECHONL) | Int32FromInt32(m_ICANON) | Int32FromInt32(m_ISIG) | Int32FromInt32(m_IEXTEN)))
	p4 = t + 8
	*(*Ttcflag_t)(unsafe.Pointer(p4)) = *(*Ttcflag_t)(unsafe.Pointer(p4)) & uint32(^(Int32FromInt32(m_CSIZE) | Int32FromInt32(m_PARENB)))
	p5 = t + 8
	*(*Ttcflag_t)(unsafe.Pointer(p5)) = *(*Ttcflag_t)(unsafe.Pointer(p5)) | Uint32FromInt32(m_CS8)
	*(*Tcc_t)(unsafe.Pointer(t + 17 + UintptrFromInt32(m_VMIN))) = uint8(1)
	*(*Tcc_t)(unsafe.Pointer(t + 17 + UintptrFromInt32(m_VTIME))) = uint8(0)
}

func x_cfsetospeed(tls *TLS, tio uintptr, speed Tspeed_t) (r int32) {
	var p1 uintptr
	var p2 uintptr
	if speed&uint32(^Int32FromInt32(m_CBAUD)) != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	p1 = tio + 8
	*(*Ttcflag_t)(unsafe.Pointer(p1)) = *(*Ttcflag_t)(unsafe.Pointer(p1)) & uint32(^Int32FromInt32(m_CBAUD))
	p2 = tio + 8
	*(*Ttcflag_t)(unsafe.Pointer(p2)) = *(*Ttcflag_t)(unsafe.Pointer(p2)) | speed
	return int32(0)
}

func x_cfsetispeed(tls *TLS, tio uintptr, speed Tspeed_t) (r int32) {
	var v1 int32
	if speed != 0 {
		v1 = x_cfsetospeed(tls, tio, speed)
	} else {
		v1 = int32(0)
	}
	return v1
}

func x_tcdrain(tls *TLS, fd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(16), int64(fd), int64(Int32FromInt32(0x5409)), int64(Int32FromInt32(1)), int64(0), int64(0), int64(0)))))
}

const m_TCXONC = 21514

func x_tcflow(tls *TLS, fd int32, action int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	return x_ioctl(tls, fd, int32(m_TCXONC), VaList(bp+8, action))
}

const m_TCFLSH = 21515

func x_tcflush(tls *TLS, fd int32, queue int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	return x_ioctl(tls, fd, int32(m_TCFLSH), VaList(bp+8, queue))
}

const m_TCGETS = 21505

func x_tcgetattr(tls *TLS, fd int32, tio uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	if x_ioctl(tls, fd, int32(m_TCGETS), VaList(bp+8, tio)) != 0 {
		return -int32(1)
	}
	return int32(0)
}

const m_TIOCGSID = 21545

func x_tcgetsid(tls *TLS, fd int32) (r Tpid_t) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var _ /* sid at bp+0 */ int32
	if x_ioctl(tls, fd, int32(m_TIOCGSID), VaList(bp+16, bp)) < int32(0) {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func x_tcgetwinsize(tls *TLS, fd int32, wsz uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(16), int64(fd), int64(Int32FromInt32(0x5413)), int64(wsz)))))
}

const m_TCSBRK = 21513

func x_tcsendbreak(tls *TLS, fd int32, dur int32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	/* nonzero duration is implementation-defined, so ignore it */
	return x_ioctl(tls, fd, int32(m_TCSBRK), VaList(bp+8, int32(0)))
}

const m_TCSETS = 21506

func x_tcsetattr(tls *TLS, fd int32, act int32, tio uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 0 maxValist 1 */
	defer tls.Free(16)
	if act < int32(0) || act > int32(2) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	return x_ioctl(tls, fd, int32(m_TCSETS)+act, VaList(bp+8, tio))
}

func x_tcsetwinsize(tls *TLS, fd int32, wsz uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(16), int64(fd), int64(Int32FromInt32(0x5414)), int64(wsz)))))
}

func x___lock(tls *TLS, l uintptr) {
	var current int32
	var i uint32
	var need_locks int32
	var val int32
	var val1 int32
	need_locks = int32(x___libc.Fneed_locks)
	if !(need_locks != 0) {
		return
	}
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	current = _a_cas(tls, l, int32(0), -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+Int32FromInt32(1))
	if need_locks < int32(0) {
		x___libc.Fneed_locks = int8(0)
	}
	if !(current != 0) {
		return
	}
	/* A first spin loop, for medium congestion. */
	i = uint32(0)
	for ; i < uint32(10); i++ {
		if current < int32(0) {
			current = current - (-Int32FromInt32(1) - Int32FromInt32(0x7fffffff) + Int32FromInt32(1))
		}
		// assertion: current >= 0
		val = _a_cas(tls, l, current, -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+(current+int32(1)))
		if val == current {
			return
		}
		current = val
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = _a_fetch_add(tls, l, int32(1)) + int32(1)
	/* The main lock acquisition loop for heavy congestion. The only
	 * change to the value performed inside that loop is a successful
	 * lock via the CAS that acquires the lock. */
	for {
		/* We can only go into wait, if we know that somebody holds the
		 * lock and will eventually wake us up, again. */
		if current < int32(0) {
			___futexwait(tls, l, current, int32(1))
			current = current - (-Int32FromInt32(1) - Int32FromInt32(0x7fffffff) + Int32FromInt32(1))
		}
		/* assertion: current > 0, the count includes us already. */
		val1 = _a_cas(tls, l, current, -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+current)
		if val1 == current {
			return
		}
		current = val1
	}
}

func x___unlock(tls *TLS, l uintptr) {
	/* Check l[0] to see if we are multi-threaded. */
	if *(*int32)(unsafe.Pointer(l + UintptrFromInt32(0)*4)) < int32(0) {
		if _a_fetch_add(tls, l, -(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+Int32FromInt32(1))) != -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+Int32FromInt32(1) {
			___wake(tls, l, int32(1), int32(1))
		}
	}
}

func _sccp(tls *TLS, nr Tsyscall_arg_t, u Tsyscall_arg_t, v Tsyscall_arg_t, w Tsyscall_arg_t, x Tsyscall_arg_t, y Tsyscall_arg_t, z Tsyscall_arg_t) (r int64) {
	return ___syscall6(tls, nr, u, v, w, x, y, z)
}

func x___syscall_cp(tls *TLS, nr Tsyscall_arg_t, u Tsyscall_arg_t, v Tsyscall_arg_t, w Tsyscall_arg_t, x Tsyscall_arg_t, y Tsyscall_arg_t, z Tsyscall_arg_t) (r int64) {
	return x___syscall_cp_c(tls, nr, u, v, w, x, y, z)
}

const m_FUTEX_WAIT = 0

func ___futex4_cp(tls *TLS, addr uintptr, op int32, val int32, to uintptr) (r1 int32) {
	var r int32
	r = int32(x___syscall_cp(tls, int64(202), int64(addr), int64(op), int64(val), int64(to), int64(0), int64(0)))
	if r != -int32(m_ENOSYS) {
		return r
	}
	return int32(x___syscall_cp(tls, int64(202), int64(addr), int64(op & ^Int32FromInt32(128)), int64(val), int64(to), int64(0), int64(0)))
}

var _dummy16 = int32(0)

func x___timedwait_cp(tls *TLS, addr uintptr, val int32, clk Tclockid_t, at uintptr, priv int32) (r1 int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var r int32
	var top uintptr
	var _ /* to at bp+0 */ Ttimespec
	var v1 int64
	var p2 uintptr
	top = uintptr(0)
	if priv != 0 {
		priv = int32(m_FUTEX_PRIVATE)
	}
	if at != 0 {
		if uint64((*Ttimespec)(unsafe.Pointer(at)).Ftv_nsec) >= uint64(1000000000) {
			return int32(m_EINVAL)
		}
		if x___clock_gettime(tls, clk, bp) != 0 {
			return int32(m_EINVAL)
		}
		(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec = (*Ttimespec)(unsafe.Pointer(at)).Ftv_sec - (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
		v1 = (*Ttimespec)(unsafe.Pointer(at)).Ftv_nsec - (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec
		(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec = v1
		if v1 < int64(0) {
			(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec--
			p2 = uintptr(unsafe.Pointer(&(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec))
			*(*int64)(unsafe.Pointer(p2)) = *(*int64)(unsafe.Pointer(p2)) + Int64FromInt32(1000000000)
		}
		if (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec < int64(0) {
			return int32(m_ETIMEDOUT)
		}
		top = bp
	}
	r = -___futex4_cp(tls, addr, int32(m_FUTEX_WAIT)|priv, val, top)
	if r != int32(m_EINTR) && r != int32(m_ETIMEDOUT) && r != int32(m_ECANCELED) {
		r = int32(0)
	}
	/* Mitigate bug in old kernels wrongly reporting EINTR for non-
	 * interrupting (SA_RESTART) signal handlers. This is only practical
	 * when NO interrupting signal handlers have been installed, and
	 * works by sigaction tracking whether that's the case. */
	if r == int32(m_EINTR) && !(x___eintr_valid_flag != 0) {
		r = int32(0)
	}
	return r
}

func x___timedwait(tls *TLS, addr uintptr, val int32, clk Tclockid_t, at uintptr, priv int32) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r int32
	var _ /* cs at bp+0 */ int32
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	r = x___timedwait_cp(tls, addr, val, clk, at, priv)
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return r
}

func x___tls_get_addr(tls *TLS, v uintptr) (r uintptr) {
	var self Tpthread_t
	self = ___get_tp(tls)
	return uintptr(*(*Tuintptr_t)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Fdtv + uintptr(*(*Tsize_t)(unsafe.Pointer(v + UintptrFromInt32(0)*8)))*8)) + *(*Tsize_t)(unsafe.Pointer(v + UintptrFromInt32(1)*8)))
}

func x___wait(tls *TLS, addr uintptr, waiters uintptr, val int32, priv int32) {
	var spins int32
	var v1 int32
	spins = int32(100)
	if priv != 0 {
		priv = int32(m_FUTEX_PRIVATE)
	}
	for {
		v1 = spins
		spins--
		if !(v1 != 0 && (!(waiters != 0) || !(*(*int32)(unsafe.Pointer(waiters)) != 0))) {
			break
		}
		if *(*int32)(unsafe.Pointer(addr)) == val {
			_a_spin(tls)
		} else {
			return
		}
	}
	if waiters != 0 {
		_a_inc(tls, waiters)
	}
	for *(*int32)(unsafe.Pointer(addr)) == val {
		_ = ___syscall4(tls, int64(202), int64(addr), int64(Int32FromInt32(0)|priv), int64(val), int64(Int32FromInt32(0))) != int64(-int32(m_ENOSYS)) || ___syscall4(tls, int64(202), int64(addr), int64(Int32FromInt32(0)), int64(val), int64(Int32FromInt32(0))) != 0
	}
	if waiters != 0 {
		_a_dec(tls, waiters)
	}
}

type Tthrd_t = uintptr

type Tonce_flag = int32

type Ttss_t = uint32

type Tthrd_start_t = uintptr

type Ttss_dtor_t = uintptr

type Tmtx_t = struct {
	F__u struct {
		F__vi [0][10]int32
		F__p  [0][5]uintptr
		F__i  [10]int32
	}
}

type Tcnd_t = struct {
	F__u struct {
		F__vi [0][12]int32
		F__p  [0][6]uintptr
		F__i  [12]int32
	}
}

const _thrd_success = 0
const _thrd_busy = 1
const _thrd_error = 2
const _thrd_nomem = 3
const _thrd_timedout = 4
const _mtx_plain = 0
const _mtx_recursive = 1
const _mtx_timed = 2

func x_call_once(tls *TLS, flag uintptr, func1 uintptr) {
	x___pthread_once(tls, flag, func1)
}

func x_cnd_broadcast(tls *TLS, c uintptr) (r int32) {
	/* This internal function never fails, and always returns zero,
	 * which matches the value thrd_success is defined with. */
	return x___private_cond_signal(tls, c, -int32(1))
}

func x_cnd_destroy(tls *TLS, c uintptr) {
	/* For private cv this is a no-op */
}

func x_cnd_init(tls *TLS, c uintptr) (r int32) {
	*(*Tcnd_t)(unsafe.Pointer(c)) = Tcnd_t{}
	return int32(_thrd_success)
}

func x_cnd_signal(tls *TLS, c uintptr) (r int32) {
	/* This internal function never fails, and always returns zero,
	 * which matches the value thrd_success is defined with. */
	return x___private_cond_signal(tls, c, int32(1))
}

func x_cnd_timedwait(tls *TLS, c uintptr, m uintptr, ts uintptr) (r int32) {
	var ret int32
	ret = x___pthread_cond_timedwait(tls, c, m, ts)
	switch ret {
	/* May also return EINVAL or EPERM. */
	default:
		return int32(_thrd_error)
	case int32(0):
		return int32(_thrd_success)
	case int32(m_ETIMEDOUT):
		return int32(_thrd_timedout)
	}
	return r
}

func x_cnd_wait(tls *TLS, c uintptr, m uintptr) (r int32) {
	/* Calling cnd_timedwait with a null pointer is an extension.
	 * It is convenient here to avoid duplication of the logic
	 * for return values. */
	return x_cnd_timedwait(tls, c, m, uintptr(0))
}

const m_DEFAULT_GUARD_SIZE = 8192
const m_DEFAULT_STACK_SIZE = 131072

var _lock6 = Tpthread_rwlock_t{}

func x___inhibit_ptc(tls *TLS) {
	x___pthread_rwlock_wrlock(tls, uintptr(unsafe.Pointer(&_lock6)))
}

func x___acquire_ptc(tls *TLS) {
	x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_lock6)))
}

func x___release_ptc(tls *TLS) {
	x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_lock6)))
}

func x_mtx_destroy(tls *TLS, mtx uintptr) {
}

const m_PTHREAD_MUTEX_NORMAL = 0
const m_PTHREAD_MUTEX_RECURSIVE = 1

func x_mtx_init(tls *TLS, m uintptr, type1 int32) (r int32) {
	var v1 int32
	if type1&int32(_mtx_recursive) != 0 {
		v1 = int32(m_PTHREAD_MUTEX_RECURSIVE)
	} else {
		v1 = int32(m_PTHREAD_MUTEX_NORMAL)
	}
	*(*Tmtx_t)(unsafe.Pointer(m)) = Tmtx_t{F__u: *(*struct {
		F__vi [0][10]int32
		F__p  [0][5]uintptr
		F__i  [10]int32
	})(unsafe.Pointer(&struct {
		f int32
		_ [36]byte
	}{f: v1}))}
	return int32(_thrd_success)
}

const m_EBUSY = 16

func x_mtx_lock(tls *TLS, m uintptr) (r int32) {
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tmtx_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4)) == int32(m_PTHREAD_MUTEX_NORMAL) && !(_a_cas(tls, uintptr(unsafe.Pointer(&(*Tmtx_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(0), int32(m_EBUSY)) != 0) {
		return int32(_thrd_success)
	}
	/* Calling mtx_timedlock with a null pointer is an extension.
	 * It is convenient, here to avoid duplication of the logic
	 * for return values. */
	return x_mtx_timedlock(tls, m, uintptr(0))
}

func x_mtx_timedlock(tls *TLS, m uintptr, ts uintptr) (r int32) {
	var ret int32
	ret = x___pthread_mutex_timedlock(tls, m, ts)
	switch ret {
	default:
		return int32(_thrd_error)
	case int32(0):
		return int32(_thrd_success)
	case int32(m_ETIMEDOUT):
		return int32(_thrd_timedout)
	}
	return r
}

func x_mtx_trylock(tls *TLS, m uintptr) (r int32) {
	var ret int32
	var v1 int32
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tmtx_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4)) == int32(m_PTHREAD_MUTEX_NORMAL) {
		if _a_cas(tls, uintptr(unsafe.Pointer(&(*Tmtx_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(0), int32(m_EBUSY))&int32(m_EBUSY) != 0 {
			v1 = int32(_thrd_busy)
		} else {
			v1 = int32(_thrd_success)
		}
		return v1
	}
	ret = x___pthread_mutex_trylock(tls, m)
	switch ret {
	default:
		return int32(_thrd_error)
	case int32(0):
		return int32(_thrd_success)
	case int32(m_EBUSY):
		return int32(_thrd_busy)
	}
	return r
}

func x_mtx_unlock(tls *TLS, mtx uintptr) (r int32) {
	/* The only cases where pthread_mutex_unlock can return an
	 * error are undefined behavior for C11 mtx_unlock, so we can
	 * assume it does not return an error and simply tail call. */
	return x___pthread_mutex_unlock(tls, mtx)
}

type Tatfork_funcs = struct {
	Fprepare uintptr
	Fparent  uintptr
	Fchild   uintptr
	Fprev    uintptr
	Fnext    uintptr
}

var _funcs1 uintptr

var _lock7 [1]int32

func x___fork_handler(tls *TLS, who int32) {
	var p uintptr
	if !(_funcs1 != 0) {
		return
	}
	if who < int32(0) {
		x___lock(tls, uintptr(unsafe.Pointer(&_lock7)))
		for p = _funcs1; p != 0; p = (*Tatfork_funcs)(unsafe.Pointer(p)).Fnext {
			if (*Tatfork_funcs)(unsafe.Pointer(p)).Fprepare != 0 {
				(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{(*Tatfork_funcs)(unsafe.Pointer(p)).Fprepare})))(tls)
			}
			_funcs1 = p
		}
	} else {
		for p = _funcs1; p != 0; p = (*Tatfork_funcs)(unsafe.Pointer(p)).Fprev {
			if !(who != 0) && (*Tatfork_funcs)(unsafe.Pointer(p)).Fparent != 0 {
				(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{(*Tatfork_funcs)(unsafe.Pointer(p)).Fparent})))(tls)
			} else {
				if who != 0 && (*Tatfork_funcs)(unsafe.Pointer(p)).Fchild != 0 {
					(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{(*Tatfork_funcs)(unsafe.Pointer(p)).Fchild})))(tls)
				}
			}
			_funcs1 = p
		}
		x___unlock(tls, uintptr(unsafe.Pointer(&_lock7)))
	}
}

func x_pthread_atfork(tls *TLS, prepare uintptr, parent uintptr, child uintptr) (r int32) {
	var new1 uintptr
	new1 = x___libc_malloc(tls, uint64(40))
	if !(new1 != 0) {
		return int32(m_ENOMEM)
	}
	x___lock(tls, uintptr(unsafe.Pointer(&_lock7)))
	(*Tatfork_funcs)(unsafe.Pointer(new1)).Fnext = _funcs1
	(*Tatfork_funcs)(unsafe.Pointer(new1)).Fprev = uintptr(0)
	(*Tatfork_funcs)(unsafe.Pointer(new1)).Fprepare = prepare
	(*Tatfork_funcs)(unsafe.Pointer(new1)).Fparent = parent
	(*Tatfork_funcs)(unsafe.Pointer(new1)).Fchild = child
	if _funcs1 != 0 {
		(*Tatfork_funcs)(unsafe.Pointer(_funcs1)).Fprev = new1
	}
	_funcs1 = new1
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock7)))
	return int32(0)
}

func x_pthread_attr_destroy(tls *TLS, a uintptr) (r int32) {
	return int32(0)
}

const m_PTHREAD_SCOPE_SYSTEM = 0

func x_pthread_attr_getdetachstate(tls *TLS, a uintptr, state uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(state)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4))
	return int32(0)
}

func x_pthread_attr_getguardsize(tls *TLS, a uintptr, size uintptr) (r int32) {
	*(*Tsize_t)(unsafe.Pointer(size)) = *(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(1)*8))
	return int32(0)
}

func x_pthread_attr_getinheritsched(tls *TLS, a uintptr, inherit uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(inherit)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(1))*4))
	return int32(0)
}

func x_pthread_attr_getschedparam(tls *TLS, a uintptr, param uintptr) (r int32) {
	(*Tsched_param)(unsafe.Pointer(param)).Fsched_priority = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(3))*4))
	return int32(0)
}

func x_pthread_attr_getschedpolicy(tls *TLS, a uintptr, policy uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(policy)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(2))*4))
	return int32(0)
}

func x_pthread_attr_getscope(tls *TLS, a uintptr, scope uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(scope)) = int32(m_PTHREAD_SCOPE_SYSTEM)
	return int32(0)
}

func x_pthread_attr_getstack(tls *TLS, a uintptr, addr uintptr, size uintptr) (r int32) {
	if !(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) != 0) {
		return int32(m_EINVAL)
	}
	*(*Tsize_t)(unsafe.Pointer(size)) = *(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8))
	*(*uintptr)(unsafe.Pointer(addr)) = uintptr(*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) - *(*Tsize_t)(unsafe.Pointer(size)))
	return int32(0)
}

func x_pthread_attr_getstacksize(tls *TLS, a uintptr, size uintptr) (r int32) {
	*(*Tsize_t)(unsafe.Pointer(size)) = *(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8))
	return int32(0)
}

func x_pthread_barrierattr_getpshared(tls *TLS, a uintptr, pshared uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(pshared)) = BoolInt32(!!((*Tpthread_barrierattr_t)(unsafe.Pointer(a)).F__attr != 0))
	return int32(0)
}

func x_pthread_condattr_getclock(tls *TLS, a uintptr, clk uintptr) (r int32) {
	*(*Tclockid_t)(unsafe.Pointer(clk)) = int32((*Tpthread_condattr_t)(unsafe.Pointer(a)).F__attr & uint32(0x7fffffff))
	return int32(0)
}

func x_pthread_condattr_getpshared(tls *TLS, a uintptr, pshared uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(pshared)) = int32((*Tpthread_condattr_t)(unsafe.Pointer(a)).F__attr >> int32(31))
	return int32(0)
}

func x_pthread_mutexattr_getprotocol(tls *TLS, a uintptr, protocol uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(protocol)) = int32((*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr / uint32(8) % uint32(2))
	return int32(0)
}

func x_pthread_mutexattr_getpshared(tls *TLS, a uintptr, pshared uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(pshared)) = int32((*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr / uint32(128) % uint32(2))
	return int32(0)
}

func x_pthread_mutexattr_getrobust(tls *TLS, a uintptr, robust uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(robust)) = int32((*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr / uint32(4) % uint32(2))
	return int32(0)
}

func x_pthread_mutexattr_gettype(tls *TLS, a uintptr, type1 uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(type1)) = int32((*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr & uint32(3))
	return int32(0)
}

func x_pthread_rwlockattr_getpshared(tls *TLS, a uintptr, pshared uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(pshared)) = int32(*(*uint32)(unsafe.Pointer(a + UintptrFromInt32(0)*4)))
	return int32(0)
}

func x_pthread_attr_init(tls *TLS, a uintptr) (r int32) {
	*(*Tpthread_attr_t)(unsafe.Pointer(a)) = Tpthread_attr_t{}
	x___acquire_ptc(tls)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8)) = uint64(x___default_stacksize)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(1)*8)) = uint64(x___default_guardsize)
	x___release_ptc(tls)
	return int32(0)
}

func x_pthread_attr_setdetachstate(tls *TLS, a uintptr, state int32) (r int32) {
	if uint32(state) > uint32(1) {
		return int32(m_EINVAL)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4)) = state
	return int32(0)
}

func x_pthread_attr_setguardsize(tls *TLS, a uintptr, size Tsize_t) (r int32) {
	if size > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(8) {
		return int32(m_EINVAL)
	}
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(1)*8)) = size
	return int32(0)
}

func x_pthread_attr_setinheritsched(tls *TLS, a uintptr, inherit int32) (r int32) {
	if uint32(inherit) > uint32(1) {
		return int32(m_EINVAL)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(1))*4)) = inherit
	return int32(0)
}

func x_pthread_attr_setschedparam(tls *TLS, a uintptr, param uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(3))*4)) = (*Tsched_param)(unsafe.Pointer(param)).Fsched_priority
	return int32(0)
}

func x_pthread_attr_setschedpolicy(tls *TLS, a uintptr, policy int32) (r int32) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(2))*4)) = policy
	return int32(0)
}

const m_PTHREAD_SCOPE_PROCESS = 1

func x_pthread_attr_setscope(tls *TLS, a uintptr, scope int32) (r int32) {
	switch scope {
	case int32(m_PTHREAD_SCOPE_SYSTEM):
		return int32(0)
	case int32(m_PTHREAD_SCOPE_PROCESS):
		return int32(m_EOPNOTSUPP)
	default:
		return int32(m_EINVAL)
	}
	return r
}

func x_pthread_attr_setstack(tls *TLS, a uintptr, addr uintptr, size Tsize_t) (r int32) {
	if size-uint64(m_PTHREAD_STACK_MIN) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(4) {
		return int32(m_EINVAL)
	}
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) = uint64(addr) + size
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8)) = size
	return int32(0)
}

func x_pthread_attr_setstacksize(tls *TLS, a uintptr, size Tsize_t) (r int32) {
	if size-uint64(m_PTHREAD_STACK_MIN) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(4) {
		return int32(m_EINVAL)
	}
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) = uint64(0)
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8)) = size
	return int32(0)
}

func x_pthread_barrier_destroy(tls *TLS, b uintptr) (r int32) {
	var v int32
	var v1 int32
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + UintptrFromInt32(2)*4)) < int32(0) {
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(0)*4)) != 0 {
			_a_or(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, -Int32FromInt32(1)-Int32FromInt32(0x7fffffff))
			for {
				v1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(0)*4))
				v = v1
				if !(v1&int32(m_INT_MAX) != 0) {
					break
				}
				x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, uintptr(0), v, int32(0))
			}
		}
		x___vm_wait(tls)
	}
	return int32(0)
}

func x_pthread_barrier_init(tls *TLS, b uintptr, a uintptr, count uint32) (r int32) {
	var v1 uint32
	if count-uint32(1) > uint32(Int32FromInt32(m_INT_MAX)-Int32FromInt32(1)) {
		return int32(m_EINVAL)
	}
	if a != 0 {
		v1 = (*Tpthread_barrierattr_t)(unsafe.Pointer(a)).F__attr
	} else {
		v1 = uint32(0)
	}
	*(*Tpthread_barrier_t)(unsafe.Pointer(b)) = Tpthread_barrier_t{F__u: *(*struct {
		F__vi [0][8]int32
		F__p  [0][4]uintptr
		F__i  [8]int32
	})(unsafe.Pointer(&struct {
		_ [8]byte
		f int32
		_ [20]byte
	}{f: int32(count - Uint32FromInt32(1) | v1)}))}
	return int32(0)
}

func _pshared_barrier_wait(tls *TLS, b uintptr) (r int32) {
	var limit int32
	var ret int32
	var v int32
	var w int32
	var v1 int32
	var v2 int32
	var v3 uintptr
	var v4 int32
	var v5 int32
	var v6 int32
	limit = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + UintptrFromInt32(2)*4))&int32(m_INT_MAX) + int32(1)
	ret = int32(0)
	if limit == int32(1) {
		return -int32(1)
	}
	for {
		v1 = _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(0), limit)
		v = v1
		if !(v1 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(1)*4, v, int32(0))
	}
	/* Wait for <limit> threads to get to the barrier */
	v3 = uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*4
	*(*int32)(unsafe.Pointer(v3))++
	v2 = *(*int32)(unsafe.Pointer(v3))
	if v2 == limit {
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, int32(0))
		ret = -int32(1)
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(4)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, -int32(1), int32(0))
		}
	} else {
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(0))
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(1)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1), int32(0))
		}
		for {
			v4 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*4))
			v = v4
			if !(v4 > int32(0)) {
				break
			}
			x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(4)*4, v, int32(0))
		}
	}
	x___vm_lock(tls)
	/* Ensure all threads have a vm lock before proceeding */
	if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, -int32(1)) == int32(1)-limit {
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, int32(0))
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(4)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, -int32(1), int32(0))
		}
	} else {
		for {
			v5 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*4))
			v = v5
			if !(v5 != 0) {
				break
			}
			x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(3)*4, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(4)*4, v, int32(0))
		}
	}
	/* Perform a recursive unlock suitable for self-sync'd destruction */
	for first := true; ; first = false {
		if !first {
			if v == -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+Int32FromInt32(1) {
				v6 = int32(0)
			} else {
				v6 = v - int32(1)
			}
			if !(_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, v, v6) != v) {
				break
			}
		}
		v = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(0)*4))
		w = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(1)*4))
	}
	/* Wake a thread waiting to reuse or destroy the barrier */
	if v == -Int32FromInt32(1)-Int32FromInt32(0x7fffffff)+Int32FromInt32(1) || v == int32(1) && w != 0 {
		___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1), int32(0))
	}
	x___vm_unlock(tls)
	return ret
}

type Tinstance = struct {
	Fcount    int32
	Flast     int32
	Fwaiters  int32
	Ffinished int32
}

func x_pthread_barrier_wait(tls *TLS, b uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var inst uintptr
	var limit int32
	var spins int32
	var _ /* new_inst at bp+0 */ Tinstance
	var v1 uintptr
	var v2 int32
	var v3 int32
	var v4 uintptr
	limit = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u.F__i)) + UintptrFromInt32(2)*4))
	/* Trivial case: count was set at 1 */
	if !(limit != 0) {
		return -int32(1)
	}
	/* Process-shared barriers require a separate, inefficient wait */
	if limit < int32(0) {
		return _pshared_barrier_wait(tls, b)
	}
	/* Otherwise we need a lock on the barrier object */
	for _a_swap(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1)) != 0 {
		x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(1)*4, int32(1), int32(1))
	}
	inst = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*8))
	/* First thread to enter the barrier becomes the "instance owner" */
	if !(inst != 0) {
		*(*Tinstance)(unsafe.Pointer(bp)) = Tinstance{}
		spins = int32(200)
		v1 = bp
		inst = v1
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*8)) = v1
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(0))
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(1)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1), int32(1))
		}
		for {
			v2 = spins
			spins--
			if !(v2 != 0 && !((*Tinstance)(unsafe.Pointer(inst)).Ffinished != 0)) {
				break
			}
			_a_spin(tls)
		}
		_a_inc(tls, inst+12)
		for (*Tinstance)(unsafe.Pointer(inst)).Ffinished == int32(1) {
			_ = ___syscall4(tls, int64(202), int64(inst+12), int64(Int32FromInt32(0)|Int32FromInt32(128)), int64(Int32FromInt32(1)), int64(Int32FromInt32(0))) != int64(-int32(m_ENOSYS)) || ___syscall4(tls, int64(202), int64(inst+12), int64(Int32FromInt32(0)), int64(Int32FromInt32(1)), int64(Int32FromInt32(0))) != 0
		}
		return -int32(1)
	}
	/* Last thread to enter the barrier wakes all non-instance-owners */
	v4 = inst
	*(*int32)(unsafe.Pointer(v4))++
	v3 = *(*int32)(unsafe.Pointer(v4))
	if v3 == limit {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(3)*8)) = uintptr(0)
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(0))
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(1)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1), int32(1))
		}
		_a_store(tls, inst+4, int32(1))
		if (*Tinstance)(unsafe.Pointer(inst)).Fwaiters != 0 {
			___wake(tls, inst+4, -int32(1), int32(1))
		}
	} else {
		_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(0))
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u)) + UintptrFromInt32(1)*4)) != 0 {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_barrier_t)(unsafe.Pointer(b)).F__u))+UintptrFromInt32(0)*4, int32(1), int32(1))
		}
		x___wait(tls, inst+4, inst+8, int32(0), int32(1))
	}
	/* Last thread to exit the barrier wakes the instance owner */
	if _a_fetch_add(tls, inst, -int32(1)) == int32(1) && _a_fetch_add(tls, inst+12, int32(1)) != 0 {
		___wake(tls, inst+12, int32(1), int32(1))
	}
	return int32(0)
}

func x_pthread_barrierattr_destroy(tls *TLS, a uintptr) (r int32) {
	return int32(0)
}

func x_pthread_barrierattr_init(tls *TLS, a uintptr) (r int32) {
	*(*Tpthread_barrierattr_t)(unsafe.Pointer(a)) = Tpthread_barrierattr_t{}
	return int32(0)
}

func x_pthread_barrierattr_setpshared(tls *TLS, a uintptr, pshared int32) (r int32) {
	var v1 int32
	if uint32(pshared) > uint32(1) {
		return int32(m_EINVAL)
	}
	if pshared != 0 {
		v1 = -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
	} else {
		v1 = int32(0)
	}
	(*Tpthread_barrierattr_t)(unsafe.Pointer(a)).F__attr = uint32(v1)
	return int32(0)
}

const m_PTHREAD_CANCEL_ENABLE = 0
const m_REG_RIP = 16
const m_SA_SIGINFO = 4
const m_SIGCANCEL = 33
const m_SYS_close = 3

func x___cancel(tls *TLS) (r int64) {
	var self Tpthread_t
	self = ___get_tp(tls)
	if int32((*T__pthread)(unsafe.Pointer(self)).Fcanceldisable) == int32(m_PTHREAD_CANCEL_ENABLE) || (*T__pthread)(unsafe.Pointer(self)).Fcancelasync != 0 {
		x___pthread_exit(tls, uintptr(-Int32FromInt32(1)))
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcanceldisable = uint8(m_PTHREAD_CANCEL_DISABLE)
	return int64(-int32(m_ECANCELED))
}

func x___syscall_cp_c(tls *TLS, nr Tsyscall_arg_t, u Tsyscall_arg_t, v Tsyscall_arg_t, w Tsyscall_arg_t, x Tsyscall_arg_t, y Tsyscall_arg_t, z Tsyscall_arg_t) (r1 int64) {
	var r int64
	var self Tpthread_t
	var st int32
	var v1 int32
	var v2 Tpthread_t
	v2 = ___get_tp(tls)
	self = v2
	v1 = int32((*T__pthread)(unsafe.Pointer(v2)).Fcanceldisable)
	st = v1
	if v1 != 0 && (st == int32(m_PTHREAD_CANCEL_DISABLE) || nr == int64(m_SYS_close)) {
		return ___syscall6(tls, nr, u, v, w, x, y, z)
	}
	r = ___syscall_cp_asm(tls, self+60, nr, u, v, w, x, y, z)
	if r == int64(-int32(m_EINTR)) && nr != int64(m_SYS_close) && (*T__pthread)(unsafe.Pointer(self)).Fcancel != 0 && int32((*T__pthread)(unsafe.Pointer(self)).Fcanceldisable) != int32(m_PTHREAD_CANCEL_DISABLE) {
		r = x___cancel(tls)
	}
	return r
}

func __sigaddset(tls *TLS, set uintptr, sig int32) {
	var s uint32
	var p1 uintptr
	s = uint32(sig - int32(1))
	p1 = set + uintptr(uint64(s/Uint32FromInt32(8))/Uint64FromInt64(8))*8
	*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) | Uint64FromUint64(1)<<(uint64(s)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))
}

func _cancel_handler(tls *TLS, sig int32, si uintptr, ctx uintptr) {
	var pc Tuintptr_t
	var self Tpthread_t
	var uc uintptr
	self = ___get_tp(tls)
	uc = ctx
	pc = uint64(*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tucontext_t5)(unsafe.Pointer(uc)).Fuc_mcontext.Fgregs)) + uintptr(_REG_RIP)*8)))
	_a_barrier(tls)
	if !((*T__pthread)(unsafe.Pointer(self)).Fcancel != 0) || int32((*T__pthread)(unsafe.Pointer(self)).Fcanceldisable) == int32(m_PTHREAD_CANCEL_DISABLE) {
		return
	}
	__sigaddset(tls, uc+296, int32(m_SIGCANCEL))
	if (*T__pthread)(unsafe.Pointer(self)).Fcancelasync != 0 {
		x_pthread_sigmask(tls, int32(m_SIG_SETMASK), uc+296, uintptr(0))
		x___cancel(tls)
	}
	if pc >= Tuintptr_t(uintptr(unsafe.Pointer(&___cp_begin))) && pc < Tuintptr_t(uintptr(unsafe.Pointer(&___cp_end))) {
		*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tucontext_t5)(unsafe.Pointer(uc)).Fuc_mcontext.Fgregs)) + uintptr(_REG_RIP)*8)) = int64(Tuintptr_t(uintptr(unsafe.Pointer(&___cp_cancel))))
		return
	}
	___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(self)).Ftid), int64(Int32FromInt32(33)))
}

func x___testcancel(tls *TLS) {
	var self Tpthread_t
	self = ___get_tp(tls)
	if (*T__pthread)(unsafe.Pointer(self)).Fcancel != 0 && !((*T__pthread)(unsafe.Pointer(self)).Fcanceldisable != 0) {
		x___cancel(tls)
	}
}

func _init_cancellation(tls *TLS) {
	bp := tls.Alloc(152) /* tlsAllocs 152 maxValist 0 */
	defer tls.Free(152)
	var _ /* sa at bp+0 */ Tsigaction
	*(*Tsigaction)(unsafe.Pointer(bp)) = Tsigaction{F__sa_handler: *(*struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	})(unsafe.Pointer(&struct{ f uintptr }{f: __ccgo_fp(_cancel_handler)})), Fsa_flags: Int32FromInt32(m_SA_SIGINFO) | Int32FromInt32(m_SA_RESTART) | Int32FromInt32(m_SA_ONSTACK)}
	x_memset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp))).Fsa_mask)), -int32(1), uint64(Int32FromInt32(m__NSIG)/Int32FromInt32(8)))
	x___libc_sigaction(tls, int32(m_SIGCANCEL), bp, uintptr(0))
}

func x_pthread_cancel(tls *TLS, t Tpthread_t) (r int32) {
	if !(_init1 != 0) {
		_init_cancellation(tls)
		_init1 = int32(1)
	}
	_a_store(tls, t+60, int32(1))
	if t == ___pthread_self_internal(tls) {
		if int32((*T__pthread)(unsafe.Pointer(t)).Fcanceldisable) == int32(m_PTHREAD_CANCEL_ENABLE) && (*T__pthread)(unsafe.Pointer(t)).Fcancelasync != 0 {
			x___pthread_exit(tls, uintptr(-Int32FromInt32(1)))
		}
		return int32(0)
	}
	return x_pthread_kill(tls, t, int32(m_SIGCANCEL))
}

var _init1 int32

func _dummy17(tls *TLS, cb uintptr) {
}

func x__pthread_cleanup_push(tls *TLS, cb uintptr, f uintptr, x uintptr) {
	(*T__ptcb)(unsafe.Pointer(cb)).F__f = f
	(*T__ptcb)(unsafe.Pointer(cb)).F__x = x
	x___do_cleanup_push(tls, cb)
}

func x__pthread_cleanup_pop(tls *TLS, cb uintptr, run int32) {
	x___do_cleanup_pop(tls, cb)
	if run != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*T__ptcb)(unsafe.Pointer(cb)).F__f})))(tls, (*T__ptcb)(unsafe.Pointer(cb)).F__x)
	}
}

func x_pthread_cond_broadcast(tls *TLS, c uintptr) (r int32) {
	if !(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(0)*8)) != 0) {
		return x___private_cond_signal(tls, c, -int32(1))
	}
	if !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(3)*4)) != 0) {
		return int32(0)
	}
	_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4)
	___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4, -int32(1), int32(0))
	return int32(0)
}

func x_pthread_cond_destroy(tls *TLS, c uintptr) (r int32) {
	var cnt int32
	var v1 int32
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(0)*8)) != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(3)*4)) != 0 {
		_a_or(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(3)*4, Int32FromUint32(0x80000000))
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4)
		___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4, -int32(1), int32(0))
		for {
			v1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(3)*4))
			cnt = v1
			if !(v1&int32(0x7fffffff) != 0) {
				break
			}
			x___wait(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(3)*4, uintptr(0), cnt, int32(0))
		}
	}
	return int32(0)
}

func x_pthread_cond_init(tls *TLS, c uintptr, a uintptr) (r int32) {
	*(*Tpthread_cond_t)(unsafe.Pointer(c)) = Tpthread_cond_t{}
	if a != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)) + UintptrFromInt32(4)*4)) = int32((*Tpthread_condattr_t)(unsafe.Pointer(a)).F__attr & uint32(0x7fffffff))
		if (*Tpthread_condattr_t)(unsafe.Pointer(a)).F__attr>>int32(31) != 0 {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(0)*8)) = uintptr(-Int32FromInt32(1))
		}
	}
	return int32(0)
}

func x_pthread_cond_signal(tls *TLS, c uintptr) (r int32) {
	if !(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(0)*8)) != 0) {
		return x___private_cond_signal(tls, c, int32(1))
	}
	if !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(3)*4)) != 0) {
		return int32(0)
	}
	_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4)
	___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(2)*4, int32(1), int32(0))
	return int32(0)
}

const m_PTHREAD_CANCEL_MASKED = 2

/*
 * struct waiter
 *
 * Waiter objects have automatic storage on the waiting thread, and
 * are used in building a linked list representing waiters currently
 * waiting on the condition variable or a group of waiters woken
 * together by a broadcast or signal; in the case of signal, this is a
 * degenerate list of one member.
 *
 * Waiter lists attached to the condition variable itself are
 * protected by the lock on the cv. Detached waiter lists are never
 * modified again, but can only be traversed in reverse order, and are
 * protected by the "barrier" locks in each node, which are unlocked
 * in turn to control wake order.
 *
 * Since process-shared cond var semantics do not necessarily allow
 * one thread to see another's automatic storage (they may be in
 * different processes), the waiter list is not used for the
 * process-shared case, but the structure is still used to store data
 * needed by the cancellation cleanup handler.
 */

type Twaiter = struct {
	Fprev    uintptr
	Fnext    uintptr
	Fstate   int32
	Fbarrier int32
	Fnotify  uintptr
}

func _lock8(tls *TLS, l uintptr) {
	if _a_cas(tls, l, int32(0), int32(1)) != 0 {
		_a_cas(tls, l, int32(1), int32(2))
		for cond := true; cond; cond = _a_cas(tls, l, int32(0), int32(2)) != 0 {
			x___wait(tls, l, uintptr(0), int32(2), int32(1))
		}
	}
}

func _unlock(tls *TLS, l uintptr) {
	if _a_swap(tls, l, int32(0)) == int32(2) {
		___wake(tls, l, int32(1), int32(1))
	}
}

func _unlock_requeue(tls *TLS, l uintptr, r uintptr, w int32) {
	_a_store(tls, l, int32(0))
	if w != 0 {
		___wake(tls, l, int32(1), int32(1))
	} else {
		_ = ___syscall5(tls, int64(202), int64(l), int64(Int32FromInt32(3)|Int32FromInt32(128)), int64(Int32FromInt32(0)), int64(Int32FromInt32(1)), int64(r)) != int64(-int32(m_ENOSYS)) || ___syscall5(tls, int64(202), int64(l), int64(Int32FromInt32(3)), int64(Int32FromInt32(0)), int64(Int32FromInt32(1)), int64(r)) != 0
	}
}

const _WAITING = 0
const _SIGNALED = 1
const _LEAVING = 2

func x___pthread_cond_timedwait(tls *TLS, c uintptr, m uintptr, ts uintptr) (r int32) {
	bp := tls.Alloc(40) /* tlsAllocs 40 maxValist 0 */
	defer tls.Free(40)
	var clock int32
	var e int32
	var fut uintptr
	var oldstate int32
	var seq int32
	var shared int32
	var tmp int32
	var val int32
	var _ /* cs at bp+32 */ int32
	var _ /* node at bp+0 */ Twaiter
	var v1 int32
	var v2 int32
	*(*Twaiter)(unsafe.Pointer(bp)) = Twaiter{}
	clock = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u.F__i)) + UintptrFromInt32(4)*4))
	shared = int32(0)
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&int32(15) != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))&int32(m_INT_MAX) != (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		return int32(m_EPERM)
	}
	if ts != 0 && uint64((*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec) >= uint64(1000000000) {
		return int32(m_EINVAL)
	}
	x___pthread_testcancel(tls)
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(0)*8)) != 0 {
		shared = int32(1)
		fut = uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(2)*4
		seq = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(2)*4))
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(3)*4)
	} else {
		_lock8(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
		v1 = Int32FromInt32(2)
		(*(*Twaiter)(unsafe.Pointer(bp))).Fbarrier = v1
		seq = v1
		fut = uintptr(unsafe.Pointer(&(*(*Twaiter)(unsafe.Pointer(bp))).Fbarrier))
		(*(*Twaiter)(unsafe.Pointer(bp))).Fstate = int32(_WAITING)
		(*(*Twaiter)(unsafe.Pointer(bp))).Fnext = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(1)*8))
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(1)*8)) = bp
		if !(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)) != 0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)) = bp
		} else {
			(*Twaiter)(unsafe.Pointer((*(*Twaiter)(unsafe.Pointer(bp))).Fnext)).Fprev = bp
		}
		_unlock(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
	}
	x___pthread_mutex_unlock(tls, m)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_MASKED), bp+32)
	if *(*int32)(unsafe.Pointer(bp + 32)) == int32(m_PTHREAD_CANCEL_DISABLE) {
		x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 32)), uintptr(0))
	}
	for cond := true; cond; cond = *(*int32)(unsafe.Pointer(fut)) == seq && (!(e != 0) || e == int32(m_EINTR)) {
		e = x___timedwait_cp(tls, fut, seq, clock, ts, BoolInt32(!(shared != 0)))
	}
	if e == int32(m_EINTR) {
		e = int32(0)
	}
	if shared != 0 {
		/* Suppress cancellation if a signal was potentially
		 * consumed; this is a legitimate form of spurious
		 * wake even if not. */
		if e == int32(m_ECANCELED) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(2)*4)) != seq {
			e = int32(0)
		}
		if _a_fetch_add(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(3)*4, -int32(1)) == -int32(0x7fffffff) {
			___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(3)*4, int32(1), int32(0))
		}
		oldstate = int32(_WAITING)
		goto relock
	}
	oldstate = _a_cas(tls, uintptr(unsafe.Pointer(&(*(*Twaiter)(unsafe.Pointer(bp))).Fstate)), int32(_WAITING), int32(_LEAVING))
	if oldstate == int32(_WAITING) {
		/* Access to cv object is valid because this waiter was not
		 * yet signaled and a new signal/broadcast cannot return
		 * after seeing a LEAVING waiter without getting notified
		 * via the futex notify below. */
		_lock8(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(1)*8)) == bp {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(1)*8)) = (*(*Twaiter)(unsafe.Pointer(bp))).Fnext
		} else {
			if (*(*Twaiter)(unsafe.Pointer(bp))).Fprev != 0 {
				(*Twaiter)(unsafe.Pointer((*(*Twaiter)(unsafe.Pointer(bp))).Fprev)).Fnext = (*(*Twaiter)(unsafe.Pointer(bp))).Fnext
			}
		}
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)) == bp {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)) = (*(*Twaiter)(unsafe.Pointer(bp))).Fprev
		} else {
			if (*(*Twaiter)(unsafe.Pointer(bp))).Fnext != 0 {
				(*Twaiter)(unsafe.Pointer((*(*Twaiter)(unsafe.Pointer(bp))).Fnext)).Fprev = (*(*Twaiter)(unsafe.Pointer(bp))).Fprev
			}
		}
		_unlock(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
		if (*(*Twaiter)(unsafe.Pointer(bp))).Fnotify != 0 {
			if _a_fetch_add(tls, (*(*Twaiter)(unsafe.Pointer(bp))).Fnotify, -int32(1)) == int32(1) {
				___wake(tls, (*(*Twaiter)(unsafe.Pointer(bp))).Fnotify, int32(1), int32(1))
			}
		}
	} else {
		/* Lock barrier first to control wake order. */
		_lock8(tls, uintptr(unsafe.Pointer(&(*(*Twaiter)(unsafe.Pointer(bp))).Fbarrier)))
	}
relock:
	/* Errors locking the mutex override any existing error or
	 * cancellation, since the caller must see them to know the
	 * state of the mutex. */
	v2 = x___pthread_mutex_lock(tls, m)
	tmp = v2
	if v2 != 0 {
		e = tmp
	}
	if oldstate == int32(_WAITING) {
		goto done
	}
	if !((*(*Twaiter)(unsafe.Pointer(bp))).Fnext != 0) && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&Int32FromInt32(8) != 0) {
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4)
	}
	/* Unlock the barrier that's holding back the next waiter, and
	 * either wake it or requeue it to the mutex. */
	if (*(*Twaiter)(unsafe.Pointer(bp))).Fprev != 0 {
		val = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))
		if val > int32(0) {
			_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, val, int32(uint32(val)|uint32(0x80000000)))
		}
		_unlock_requeue(tls, (*(*Twaiter)(unsafe.Pointer(bp))).Fprev+20, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&(Int32FromInt32(8)|Int32FromInt32(128)))
	} else {
		if !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&Int32FromInt32(8) != 0) {
			_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4)
		}
	}
	/* Since a signal was consumed, cancellation is not permitted. */
	if e == int32(m_ECANCELED) {
		e = int32(0)
	}
done:
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 32)), uintptr(0))
	if e == int32(m_ECANCELED) {
		x___pthread_testcancel(tls)
		x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), uintptr(0))
	}
	return e
}

func x___private_cond_signal(tls *TLS, c uintptr, n int32) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var cur int32
	var first uintptr
	var p uintptr
	var _ /* ref at bp+0 */ int32
	var v1 int32
	first = uintptr(0)
	*(*int32)(unsafe.Pointer(bp)) = int32(0)
	_lock8(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
	for p = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)); n != 0 && p != 0; p = (*Twaiter)(unsafe.Pointer(p)).Fprev {
		if _a_cas(tls, p+16, int32(_WAITING), int32(_SIGNALED)) != int32(_WAITING) {
			*(*int32)(unsafe.Pointer(bp))++
			(*Twaiter)(unsafe.Pointer(p)).Fnotify = bp
		} else {
			n--
			if !(first != 0) {
				first = p
			}
		}
	}
	/* Split the list, leaving any remainder on the cv. */
	if p != 0 {
		if (*Twaiter)(unsafe.Pointer(p)).Fnext != 0 {
			(*Twaiter)(unsafe.Pointer((*Twaiter)(unsafe.Pointer(p)).Fnext)).Fprev = uintptr(0)
		}
		(*Twaiter)(unsafe.Pointer(p)).Fnext = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(1)*8)) = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u)) + UintptrFromInt32(5)*8)) = p
	_unlock(tls, uintptr(unsafe.Pointer(&(*Tpthread_cond_t)(unsafe.Pointer(c)).F__u))+UintptrFromInt32(8)*4)
	/* Wait for any waiters in the LEAVING state to remove
	 * themselves from the list before returning or allowing
	 * signaled threads to proceed. */
	for {
		v1 = *(*int32)(unsafe.Pointer(bp))
		cur = v1
		if !(v1 != 0) {
			break
		}
		x___wait(tls, bp, uintptr(0), cur, int32(1))
	}
	/* Allow first signaled waiter, if any, to proceed. */
	if first != 0 {
		_unlock(tls, first+20)
	}
	return int32(0)
}

func x_pthread_cond_wait(tls *TLS, c uintptr, m uintptr) (r int32) {
	return x___pthread_cond_timedwait(tls, c, m, uintptr(0))
}

func x_pthread_condattr_destroy(tls *TLS, a uintptr) (r int32) {
	return int32(0)
}

func x_pthread_condattr_init(tls *TLS, a uintptr) (r int32) {
	*(*Tpthread_condattr_t)(unsafe.Pointer(a)) = Tpthread_condattr_t{}
	return int32(0)
}

func x_pthread_condattr_setclock(tls *TLS, a uintptr, clk Tclockid_t) (r int32) {
	var p1 uintptr
	var p2 uintptr
	if clk < int32(0) || uint32(clk)-uint32(2) < uint32(2) {
		return int32(m_EINVAL)
	}
	p1 = a
	*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) & Uint32FromUint32(0x80000000)
	p2 = a
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | uint32(clk)
	return int32(0)
}

func x_pthread_condattr_setpshared(tls *TLS, a uintptr, pshared int32) (r int32) {
	var p1 uintptr
	var p2 uintptr
	if uint32(pshared) > uint32(1) {
		return int32(m_EINVAL)
	}
	p1 = a
	*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) & Uint32FromInt32(0x7fffffff)
	p2 = a
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | uint32(pshared)<<Int32FromInt32(31)
	return int32(0)
}

func _dummy_02(tls *TLS) {
}

func x___tl_lock(tls *TLS) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(23), uintptr(unsafe.Pointer(&___func__68)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__68 = [10]int8{'_', '_', 't', 'l', '_', 'l', 'o', 'c', 'k'}

func x___tl_unlock(tls *TLS) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(28), uintptr(unsafe.Pointer(&___func__69)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__69 = [12]int8{'_', '_', 't', 'l', '_', 'u', 'n', 'l', 'o', 'c', 'k'}

func x___tl_sync(tls *TLS, td Tpthread_t) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(33), uintptr(unsafe.Pointer(&___func__70)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__70 = [10]int8{'_', '_', 't', 'l', '_', 's', 'y', 'n', 'c'}

func x___pthread_exit(tls *TLS, result uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(38), uintptr(unsafe.Pointer(&___func__71)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__71 = [15]int8{'_', '_', 'p', 't', 'h', 'r', 'e', 'a', 'd', '_', 'e', 'x', 'i', 't'}

func x___do_cleanup_push(tls *TLS, cb uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(43), uintptr(unsafe.Pointer(&___func__72)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__72 = [18]int8{'_', '_', 'd', 'o', '_', 'c', 'l', 'e', 'a', 'n', 'u', 'p', '_', 'p', 'u', 's', 'h'}

func x___do_cleanup_pop(tls *TLS, cb uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(48), uintptr(unsafe.Pointer(&___func__73)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__73 = [17]int8{'_', '_', 'd', 'o', '_', 'c', 'l', 'e', 'a', 'n', 'u', 'p', '_', 'p', 'o', 'p'}

type Tstart_args = struct {
	Fstart_func uintptr
	Fstart_arg  uintptr
	Fcontrol    int32
	Fsig_mask   [1]uint64
}

/* pthread_key_create.c overrides this */
var _dummy18 = uint64(0)

var _dummy_tsd = [1]uintptr{}

var _dummy_file1 = uintptr(0)

func x___pthread_create(tls *TLS, res uintptr, attrp uintptr, entry uintptr, arg uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3763, int32(73), uintptr(unsafe.Pointer(&___func__74)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__74 = [17]int8{'_', '_', 'p', 't', 'h', 'r', 'e', 'a', 'd', '_', 'c', 'r', 'e', 'a', 't', 'e'}

func ___pthread_detach(tls *TLS, t Tpthread_t) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* cs at bp+0 */ int32
	/* If the cas fails, detach state is either already-detached
	 * or exiting/exited, and pthread_join will trap or cleanup. */
	if _a_cas(tls, t+56, int32(_DT_JOINABLE), int32(_DT_DETACHED)) != int32(_DT_JOINABLE) {
		x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
		x___pthread_join(tls, t, uintptr(0))
		x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	}
	return int32(0)
}

func ___pthread_equal(tls *TLS, a Tpthread_t, b Tpthread_t) (r int32) {
	return BoolInt32(a == b)
}

func x_pthread_getattr_np(tls *TLS, t Tpthread_t, a uintptr) (r int32) {
	var l Tsize_t
	var p uintptr
	*(*Tpthread_attr_t)(unsafe.Pointer(a)) = Tpthread_attr_t{}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u.F__i)) + uintptr(Uint64FromInt32(3)*(Uint64FromInt64(8)/Uint64FromInt64(4))+Uint64FromInt32(0))*4)) = BoolInt32((*T__pthread)(unsafe.Pointer(t)).Fdetach_state >= int32(_DT_DETACHED))
	*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(1)*8)) = (*T__pthread)(unsafe.Pointer(t)).Fguard_size
	if (*T__pthread)(unsafe.Pointer(t)).Fstack != 0 {
		*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) = uint64((*T__pthread)(unsafe.Pointer(t)).Fstack)
		*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8)) = (*T__pthread)(unsafe.Pointer(t)).Fstack_size
	} else {
		p = x___libc.Fauxv
		l = uint64(m_PAGESIZE)
		p = p + uintptr(-uint64(p)&uint64(Int32FromInt32(m_PAGESIZE)-Int32FromInt32(1)))
		*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(2)*8)) = uint64(p)
		for x___mremap(tls, p-uintptr(l)-uintptr(m_PAGESIZE), uint64(m_PAGESIZE), uint64(Int32FromInt32(2)*Int32FromInt32(m_PAGESIZE)), int32(0), 0) == uintptr(-Int32FromInt32(1)) && *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOMEM) {
			l = l + Uint64FromInt32(m_PAGESIZE)
		}
		*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_attr_t)(unsafe.Pointer(a)).F__u)) + UintptrFromInt32(0)*8)) = l
	}
	return int32(0)
}

func x_pthread_getconcurrency(tls *TLS) (r int32) {
	return int32(0)
}

func x_pthread_getcpuclockid(tls *TLS, t Tpthread_t, clockid uintptr) (r int32) {
	*(*Tclockid_t)(unsafe.Pointer(clockid)) = int32(uint32(-(*T__pthread)(unsafe.Pointer(t)).Ftid-Int32FromInt32(1))*uint32(8) + uint32(6))
	return int32(0)
}

const m_PR_GET_NAME = 16

func x_pthread_getname_np(tls *TLS, thread Tpthread_t, name uintptr, len1 Tsize_t) (r int32) {
	bp := tls.Alloc(80) /* tlsAllocs 40 maxValist 4 */
	defer tls.Free(80)
	var fd int32
	var status int32
	var _ /* cs at bp+0 */ int32
	var _ /* f at bp+4 */ [34]int8
	var v1 int32
	var v2 int32
	var v3 Tsize_t
	var v4 bool
	status = int32(0)
	if len1 < uint64(16) {
		return int32(m_ERANGE)
	}
	if thread == ___pthread_self_internal(tls) {
		if x_prctl(tls, int32(m_PR_GET_NAME), VaList(bp+48, uint64(name), uint64(0), uint64(0), uint64(0))) != 0 {
			v1 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		} else {
			v1 = int32(0)
		}
		return v1
	}
	x_snprintf(tls, bp+4, uint64(34), ts+3791, VaList(bp+48, (*T__pthread)(unsafe.Pointer(thread)).Ftid))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	v2 = x_open(tls, bp+4, Int32FromInt32(m_O_RDONLY)|Int32FromInt32(m_O_CLOEXEC), 0)
	fd = v2
	if v4 = v2 < int32(0); !v4 {
		v3 = uint64(x_read(tls, fd, name, len1))
		len1 = v3
	}
	if v4 || v3 == uint64(-Int32FromInt32(1)) {
		status = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	} else {
		*(*int8)(unsafe.Pointer(name + uintptr(len1-Uint64FromInt32(1)))) = int8(0)
	} /* remove trailing new line only if successful */
	if fd >= int32(0) {
		x_close(tls, fd)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return status
}

const m_ESRCH = 3

func x_pthread_getschedparam(tls *TLS, t Tpthread_t, policy uintptr, param uintptr) (r1 int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var r int32
	var _ /* set at bp+0 */ Tsigset_t
	x___block_app_sigs(tls, bp)
	x___lock(tls, t+176)
	if !((*T__pthread)(unsafe.Pointer(t)).Ftid != 0) {
		r = int32(m_ESRCH)
	} else {
		r = int32(-___syscall2(tls, int64(143), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(param)))
		if !(r != 0) {
			*(*int32)(unsafe.Pointer(policy)) = int32(___syscall1(tls, int64(145), int64((*T__pthread)(unsafe.Pointer(t)).Ftid)))
		}
	}
	x___unlock(tls, t+176)
	x___restore_sigs(tls, bp)
	return r
}

func ___pthread_getspecific(tls *TLS, k Tpthread_key_t) (r uintptr) {
	var self uintptr
	self = ___get_tp(tls)
	return *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8))
}

func _dummy19(tls *TLS, t Tpthread_t) {
}

func ___pthread_timedjoin_np(tls *TLS, t Tpthread_t, res uintptr, at uintptr) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r int32
	var state int32
	var _ /* cs at bp+0 */ int32
	var v1 int32
	r = int32(0)
	x___pthread_testcancel(tls)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	if *(*int32)(unsafe.Pointer(bp)) == int32(m_PTHREAD_CANCEL_ENABLE) {
		x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	}
	for {
		v1 = (*T__pthread)(unsafe.Pointer(t)).Fdetach_state
		state = v1
		if !(v1 != 0 && r != int32(m_ETIMEDOUT) && r != int32(m_EINVAL)) {
			break
		}
		if state >= int32(_DT_DETACHED) {
			_a_crash(tls)
		}
		r = x___timedwait_cp(tls, t+56, state, int32(m_CLOCK_REALTIME), at, int32(1))
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	if r == int32(m_ETIMEDOUT) || r == int32(m_EINVAL) {
		return r
	}
	x___tl_sync(tls, t)
	if res != 0 {
		*(*uintptr)(unsafe.Pointer(res)) = (*T__pthread)(unsafe.Pointer(t)).Fresult
	}
	if (*T__pthread)(unsafe.Pointer(t)).Fmap_base != 0 {
		x___munmap(tls, (*T__pthread)(unsafe.Pointer(t)).Fmap_base, (*T__pthread)(unsafe.Pointer(t)).Fmap_size)
	}
	return int32(0)
}

func x___pthread_join(tls *TLS, t Tpthread_t, res uintptr) (r int32) {
	return ___pthread_timedjoin_np(tls, t, res, uintptr(0))
}

func ___pthread_tryjoin_np(tls *TLS, t Tpthread_t, res uintptr) (r int32) {
	var v1 int32
	if (*T__pthread)(unsafe.Pointer(t)).Fdetach_state == int32(_DT_JOINABLE) {
		v1 = int32(m_EBUSY)
	} else {
		v1 = x___pthread_join(tls, t, res)
	}
	return v1
}

var _keys [128]uintptr

var _key_lock = Tpthread_rwlock_t{}

var _next_key Tpthread_key_t

func _nodtor(tls *TLS, dummy uintptr) {
}

func _dummy_03(tls *TLS) {
}

func x___pthread_key_atfork(tls *TLS, who int32) {
	if who < int32(0) {
		x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	} else {
		if !(who != 0) {
			x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
		} else {
			_key_lock = Tpthread_rwlock_t{}
		}
	}
}

func x___pthread_key_create(tls *TLS, k uintptr, dtor uintptr) (r int32) {
	var j Tpthread_key_t
	var self Tpthread_t
	var v1 Tpthread_key_t
	var v2 Tpthread_key_t
	var v3 Tpthread_key_t
	self = ___get_tp(tls)
	/* This can only happen in the main thread before
	 * pthread_create has been called. */
	if !((*T__pthread)(unsafe.Pointer(self)).Ftsd != 0) {
		(*T__pthread)(unsafe.Pointer(self)).Ftsd = uintptr(unsafe.Pointer(&x___pthread_tsd_main))
	}
	/* Purely a sentinel value since null means slot is free. */
	if !(dtor != 0) {
		dtor = __ccgo_fp(_nodtor)
	}
	x___pthread_rwlock_wrlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	j = _next_key
	for first := true; ; first = false {
		if !first {
			v1 = (j + Uint32FromInt32(1)) % Uint32FromInt32(m_PTHREAD_KEYS_MAX)
			j = v1
			if !(v1 != _next_key) {
				break
			}
		}
		if !(_keys[j] != 0) {
			v3 = j
			*(*Tpthread_key_t)(unsafe.Pointer(k)) = v3
			v2 = v3
			_next_key = v2
			_keys[v2] = dtor
			x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
			return int32(0)
		}
	}
	x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	return int32(m_EAGAIN)
}

func x___pthread_key_delete(tls *TLS, k Tpthread_key_t) (r int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var self Tpthread_t
	var td Tpthread_t
	var _ /* set at bp+0 */ Tsigset_t
	var v1 Tpthread_t
	self = ___get_tp(tls)
	td = self
	x___block_app_sigs(tls, bp)
	x___pthread_rwlock_wrlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	x___tl_lock(tls)
	for first := true; ; first = false {
		if !first {
			v1 = (*T__pthread)(unsafe.Pointer(td)).Fnext
			td = v1
			if !(v1 != self) {
				break
			}
		}
		*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(td)).Ftsd + uintptr(k)*8)) = uintptr(0)
	}
	x___tl_unlock(tls)
	_keys[k] = uintptr(0)
	x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	x___restore_sigs(tls, bp)
	return int32(0)
}

func x___pthread_tsd_run_dtors(tls *TLS) {
	var dtor uintptr
	var i int32
	var j int32
	var self Tpthread_t
	var val uintptr
	self = ___get_tp(tls)
	for j = int32(0); int32(*(*uint8)(unsafe.Pointer(self + 66))&0x1>>0) != 0 && j < int32(m_PTHREAD_DESTRUCTOR_ITERATIONS); j++ {
		x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
		SetBitFieldPtr8Uint8(self+66, Uint8FromInt32(0), 0, 0x1)
		for i = int32(0); i < int32(m_PTHREAD_KEYS_MAX); i++ {
			val = *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(i)*8))
			dtor = _keys[i]
			*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(i)*8)) = uintptr(0)
			if val != 0 && dtor != 0 && dtor != __ccgo_fp(_nodtor) {
				x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
				(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{dtor})))(tls, val)
				x___pthread_rwlock_rdlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
			}
		}
		x___pthread_rwlock_unlock(tls, uintptr(unsafe.Pointer(&_key_lock)))
	}
}

func x_pthread_kill(tls *TLS, t Tpthread_t, sig int32) (r1 int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var r int32
	var _ /* set at bp+0 */ Tsigset_t
	var v1 int64
	var v2 int32
	/* Block not just app signals, but internal ones too, since
	 * pthread_kill is used to implement pthread_cancel, which
	 * must be async-cancel-safe. */
	x___block_all_sigs(tls, bp)
	x___lock(tls, t+176)
	if (*T__pthread)(unsafe.Pointer(t)).Ftid != 0 {
		v1 = -___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(sig))
	} else {
		if uint32(sig)+uint32(0) >= uint32(m__NSIG) {
			v2 = int32(m_EINVAL)
		} else {
			v2 = int32(0)
		}
		v1 = int64(v2)
	}
	r = int32(v1)
	x___unlock(tls, t+176)
	x___restore_sigs(tls, bp)
	return r
}

func x_pthread_mutex_consistent(tls *TLS, m uintptr) (r int32) {
	var old int32
	var own int32
	old = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))
	own = old & int32(0x3fffffff)
	if !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&Int32FromInt32(4) != 0) || !(own != 0) || !(old&Int32FromInt32(0x40000000) != 0) {
		return int32(m_EINVAL)
	}
	if own != (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		return int32(m_EPERM)
	}
	_a_and(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, ^Int32FromInt32(0x40000000))
	return int32(0)
}

func x_pthread_mutex_destroy(tls *TLS, mutex uintptr) (r int32) {
	/* If the mutex being destroyed is process-shared and has nontrivial
	 * type (tracking ownership), it might be in the pending slot of a
	 * robust_list; wait for quiescence. */
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(mutex)).F__u.F__i)) + UintptrFromInt32(0)*4)) > int32(128) {
		x___vm_wait(tls)
	}
	return int32(0)
}

func x_pthread_mutex_getprioceiling(tls *TLS, m uintptr, ceiling uintptr) (r int32) {
	return int32(m_EINVAL)
}

func x_pthread_mutex_init(tls *TLS, m uintptr, a uintptr) (r int32) {
	*(*Tpthread_mutex_t)(unsafe.Pointer(m)) = Tpthread_mutex_t{}
	if a != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4)) = int32((*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr)
	}
	return int32(0)
}

func x___pthread_mutex_lock(tls *TLS, m uintptr) (r int32) {
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&int32(15) == int32(m_PTHREAD_MUTEX_NORMAL) && !(_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(0), int32(m_EBUSY)) != 0) {
		return int32(0)
	}
	return x___pthread_mutex_timedlock(tls, m, uintptr(0))
}

func x_pthread_mutex_setprioceiling(tls *TLS, m uintptr, ceiling int32, old uintptr) (r int32) {
	return int32(m_EINVAL)
}

const m_EDEADLK = 35
const m_FUTEX_LOCK_PI = 6
const m_PTHREAD_MUTEX_ERRORCHECK = 2

func ___futex4(tls *TLS, addr uintptr, op int32, val int32, to uintptr) (r int32) {
	return int32(___syscall4(tls, int64(202), int64(addr), int64(op), int64(val), int64(to)))
}

func _pthread_mutex_timedlock_pi(tls *TLS, m uintptr, at uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var e int32
	var priv int32
	var self Tpthread_t
	var type1 int32
	type1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))
	priv = type1&int32(128) ^ int32(128)
	self = ___get_tp(tls)
	if !(priv != 0) {
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8
	}
	for cond := true; cond; cond = e == int32(m_EINTR) {
		e = -___futex4(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(m_FUTEX_LOCK_PI)|priv, int32(0), at)
	}
	if e != 0 {
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
	}
	switch e {
	case int32(0):
		/* Catch spurious success for non-robust mutexes. */
		if !(type1&Int32FromInt32(4) != 0) && (*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))&int32(0x40000000) != 0 || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4)) != 0) {
			_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4, -int32(1))
			___syscall2(tls, int64(202), int64(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4), int64(Int32FromInt32(7)|priv))
			(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
			break
		}
		/* Signal to trylock that we already have the lock. */
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4)) = -int32(1)
		return x___pthread_mutex_trylock(tls, m)
	case int32(m_ETIMEDOUT):
		return e
	case int32(m_EDEADLK):
		if type1&int32(3) == int32(m_PTHREAD_MUTEX_ERRORCHECK) {
			return e
		}
	}
	for cond := true; cond; cond = e != int32(m_ETIMEDOUT) {
		*(*int32)(unsafe.Pointer(bp)) = int32(0)
		e = x___timedwait(tls, bp, int32(0), int32(m_CLOCK_REALTIME), at, int32(1))
	}
	return e
}

func x___pthread_mutex_timedlock(tls *TLS, m uintptr, at uintptr) (r1 int32) {
	var own int32
	var priv int32
	var r int32
	var spins int32
	var t int32
	var type1 int32
	var v1 int32
	var v2 int32
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&int32(15) == int32(m_PTHREAD_MUTEX_NORMAL) && !(_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(0), int32(m_EBUSY)) != 0) {
		return int32(0)
	}
	type1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))
	priv = type1&int32(128) ^ int32(128)
	r = x___pthread_mutex_trylock(tls, m)
	if r != int32(m_EBUSY) {
		return r
	}
	if type1&int32(8) != 0 {
		return _pthread_mutex_timedlock_pi(tls, m, at)
	}
	spins = int32(100)
	for {
		v1 = spins
		spins--
		if !(v1 != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4)) != 0 && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4)) != 0)) {
			break
		}
		_a_spin(tls)
	}
	for {
		v2 = x___pthread_mutex_trylock(tls, m)
		r = v2
		if !(v2 == int32(m_EBUSY)) {
			break
		}
		r = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))
		own = r & int32(0x3fffffff)
		if !(own != 0) && (!(r != 0) || type1&int32(4) != 0) {
			continue
		}
		if type1&int32(3) == int32(m_PTHREAD_MUTEX_ERRORCHECK) && own == (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
			return int32(m_EDEADLK)
		}
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4)
		t = int32(uint32(r) | uint32(0x80000000))
		_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, r, t)
		r = x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, t, int32(m_CLOCK_REALTIME), at, priv)
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4)
		if r != 0 && r != int32(m_EINTR) {
			break
		}
	}
	return r
}

const m_ENOTRECOVERABLE = 131
const m_EOWNERDEAD = 130

func x___pthread_mutex_trylock_owner(tls *TLS, m uintptr) (r int32) {
	var next uintptr
	var old int32
	var own int32
	var priv int32
	var self Tpthread_t
	var tid int32
	var type1 int32
	var v1 int32
	type1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))
	self = ___get_tp(tls)
	tid = (*T__pthread)(unsafe.Pointer(self)).Ftid
	old = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))
	own = old & int32(0x3fffffff)
	if own == tid {
		if type1&int32(8) != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4)) < int32(0) {
			old = old & Int32FromInt32(0x40000000)
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4)) = int32(0)
			goto success
		}
		if type1&int32(3) == int32(m_PTHREAD_MUTEX_RECURSIVE) {
			if uint32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4))) >= uint32(m_INT_MAX) {
				return int32(m_EAGAIN)
			}
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4))++
			return int32(0)
		}
	}
	if own == int32(0x3fffffff) {
		return int32(m_ENOTRECOVERABLE)
	}
	if own != 0 || old != 0 && !(type1&Int32FromInt32(4) != 0) {
		return int32(m_EBUSY)
	}
	if type1&int32(128) != 0 {
		if !((*T__pthread)(unsafe.Pointer(self)).Frobust_list.Foff != 0) {
			(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Foff = int64(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4) - int64(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(4)*8)
			___syscall2(tls, int64(273), int64(self+136), int64(Uint64FromInt32(3)*Uint64FromInt64(8)))
		}
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4)) != 0 {
			tid = int32(uint32(tid) | Uint32FromUint32(0x80000000))
		}
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8
	}
	tid = tid | old&Int32FromInt32(0x40000000)
	if _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, old, tid) != old {
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
		if type1&int32(12) == int32(12) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4)) != 0 {
			return int32(m_ENOTRECOVERABLE)
		}
		return int32(m_EBUSY)
	}
success:
	if type1&int32(8) != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4)) != 0 {
		priv = type1&int32(128) ^ int32(128)
		___syscall2(tls, int64(202), int64(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4), int64(Int32FromInt32(7)|priv))
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
		if type1&int32(4) != 0 {
			v1 = int32(m_ENOTRECOVERABLE)
		} else {
			v1 = int32(m_EBUSY)
		}
		return v1
	}
	next = (*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fhead
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8)) = next
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(3)*8)) = uintptr(unsafe.Pointer(&(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fhead))
	if next != uintptr(unsafe.Pointer(&(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fhead)) {
		*(*uintptr)(unsafe.Pointer(next - UintptrFromInt64(8))) = uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8
	}
	(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fhead = uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8
	(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
	if old != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4)) = int32(0)
		return int32(m_EOWNERDEAD)
	}
	return int32(0)
}

func x___pthread_mutex_trylock(tls *TLS, m uintptr) (r int32) {
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&int32(15) == int32(m_PTHREAD_MUTEX_NORMAL) {
		return _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(0), int32(m_EBUSY)) & int32(m_EBUSY)
	}
	return x___pthread_mutex_trylock_owner(tls, m)
}

func x___pthread_mutex_unlock(tls *TLS, m uintptr) (r int32) {
	var cont int32
	var new1 int32
	var next uintptr
	var old int32
	var own int32
	var prev uintptr
	var priv int32
	var self Tpthread_t
	var type1 int32
	var waiters int32
	waiters = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(2)*4))
	type1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4)) & int32(15)
	priv = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(0)*4))&int32(128) ^ int32(128)
	new1 = int32(0)
	if type1 != int32(m_PTHREAD_MUTEX_NORMAL) {
		self = ___get_tp(tls)
		old = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(1)*4))
		own = old & int32(0x3fffffff)
		if own != (*T__pthread)(unsafe.Pointer(self)).Ftid {
			return int32(m_EPERM)
		}
		if type1&int32(3) == int32(m_PTHREAD_MUTEX_RECURSIVE) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4)) != 0 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u.F__i)) + UintptrFromInt32(5)*4))--
			return Int32FromInt32(0)
		}
		if type1&int32(4) != 0 && old&int32(0x40000000) != 0 {
			new1 = int32(0x7fffffff)
		}
		if !(priv != 0) {
			(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8
			x___vm_lock(tls)
		}
		prev = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(3)*8))
		next = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u)) + UintptrFromInt32(4)*8))
		*(*uintptr)(unsafe.Pointer(prev)) = next
		if next != uintptr(unsafe.Pointer(&(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fhead)) {
			*(*uintptr)(unsafe.Pointer(next - UintptrFromInt64(8))) = prev
		}
	}
	if type1&int32(8) != 0 {
		if old < int32(0) || _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, old, new1) != old {
			if new1 != 0 {
				_a_store(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(2)*4, -int32(1))
			}
			___syscall2(tls, int64(202), int64(uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4), int64(Int32FromInt32(7)|priv))
		}
		cont = int32(0)
		waiters = int32(0)
	} else {
		cont = _a_swap(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, new1)
	}
	if type1 != int32(m_PTHREAD_MUTEX_NORMAL) && !(priv != 0) {
		(*T__pthread)(unsafe.Pointer(self)).Frobust_list.Fpending = uintptr(0)
		x___vm_unlock(tls)
	}
	if waiters != 0 || cont < int32(0) {
		___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_mutex_t)(unsafe.Pointer(m)).F__u))+UintptrFromInt32(1)*4, int32(1), priv)
	}
	return int32(0)
}

func x_pthread_mutexattr_destroy(tls *TLS, a uintptr) (r int32) {
	return int32(0)
}

func x_pthread_mutexattr_init(tls *TLS, a uintptr) (r int32) {
	*(*Tpthread_mutexattr_t)(unsafe.Pointer(a)) = Tpthread_mutexattr_t{}
	return int32(0)
}

const m_PTHREAD_PRIO_INHERIT = 1
const m_PTHREAD_PRIO_NONE = 0
const m_PTHREAD_PRIO_PROTECT = 2

var _check_pi_result = -int32(1)

func x_pthread_mutexattr_setprotocol(tls *TLS, a uintptr, protocol int32) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r int32
	var _ /* lk at bp+0 */ int32
	var p1 uintptr
	var p2 uintptr
	switch protocol {
	case int32(m_PTHREAD_PRIO_NONE):
		p1 = a
		*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) & uint32(^Int32FromInt32(8))
		return int32(0)
	case int32(m_PTHREAD_PRIO_INHERIT):
		r = _check_pi_result
		if r < int32(0) {
			*(*int32)(unsafe.Pointer(bp)) = int32(0)
			r = int32(-___syscall4(tls, int64(202), int64(bp), int64(Int32FromInt32(6)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
			_a_store(tls, uintptr(unsafe.Pointer(&_check_pi_result)), r)
		}
		if r != 0 {
			return r
		}
		p2 = a
		*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | Uint32FromInt32(8)
		return int32(0)
	case int32(m_PTHREAD_PRIO_PROTECT):
		return int32(m_EOPNOTSUPP)
	default:
		return int32(m_EINVAL)
	}
	return r1
}

func x_pthread_mutexattr_setpshared(tls *TLS, a uintptr, pshared int32) (r int32) {
	var p1 uintptr
	var p2 uintptr
	if uint32(pshared) > uint32(1) {
		return int32(m_EINVAL)
	}
	p1 = a
	*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) & ^Uint32FromUint32(128)
	p2 = a
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) | uint32(pshared<<Int32FromInt32(7))
	return int32(0)
}

var _check_robust_result = -int32(1)

func x_pthread_mutexattr_setrobust(tls *TLS, a uintptr, robust int32) (r1 int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var r int32
	var _ /* l at bp+8 */ Tsize_t
	var _ /* p at bp+0 */ uintptr
	var p1 uintptr
	var p2 uintptr
	if uint32(robust) > uint32(1) {
		return int32(m_EINVAL)
	}
	if robust != 0 {
		r = _check_robust_result
		if r < int32(0) {
			r = int32(-___syscall3(tls, int64(274), int64(Int32FromInt32(0)), int64(bp), int64(bp+8)))
			_a_store(tls, uintptr(unsafe.Pointer(&_check_robust_result)), r)
		}
		if r != 0 {
			return r
		}
		p1 = a
		*(*uint32)(unsafe.Pointer(p1)) = *(*uint32)(unsafe.Pointer(p1)) | Uint32FromInt32(4)
		return int32(0)
	}
	p2 = a
	*(*uint32)(unsafe.Pointer(p2)) = *(*uint32)(unsafe.Pointer(p2)) & uint32(^Int32FromInt32(4))
	return int32(0)
}

func x_pthread_mutexattr_settype(tls *TLS, a uintptr, type1 int32) (r int32) {
	if uint32(type1) > uint32(2) {
		return int32(m_EINVAL)
	}
	(*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr = (*Tpthread_mutexattr_t)(unsafe.Pointer(a)).F__attr&uint32(^Int32FromInt32(3)) | uint32(type1)
	return int32(0)
}

func _undo(tls *TLS, control uintptr) {
	/* Wake all waiters, since the waiter status is lost when
	 * resetting control to the initial state. */
	if _a_swap(tls, control, int32(0)) == int32(3) {
		___wake(tls, control, -int32(1), int32(1))
	}
}

func x___pthread_once_full(tls *TLS, control uintptr, init1 uintptr) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* __cb at bp+0 */ T__ptcb
	/* Try to enter initializing state. Four possibilities:
	 *  0 - we're the first or the other cancelled; run init
	 *  1 - another thread is running init; wait
	 *  2 - another thread finished running init; just return
	 *  3 - another thread is running init, waiters present; wait */
	for {
		switch _a_cas(tls, control, int32(0), int32(1)) {
		case int32(0):
			goto _1
		case int32(1):
			goto _2
		case int32(3):
			goto _3
		case int32(2):
			goto _4
		}
		goto _5
	_1:
	_7:
		x__pthread_cleanup_push(tls, bp, __ccgo_fp(_undo), control)
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{init1})))(tls)
		x__pthread_cleanup_pop(tls, bp, int32(0))
		if int32(0) != 0 {
			goto _7
		}
		goto _6
	_6:
		if _a_swap(tls, control, int32(2)) == int32(3) {
			___wake(tls, control, -int32(1), int32(1))
		}
		return int32(0)
	_2:
		/* If this fails, so will __wait. */
		_a_cas(tls, control, int32(1), int32(3))
	_3:
		x___wait(tls, control, uintptr(0), int32(3), int32(1))
		continue
	_4:
		return int32(0)
	_5:
	}
	return r
}

func x___pthread_once(tls *TLS, control uintptr, init1 uintptr) (r int32) {
	/* Return immediately if init finished before, but ensure that
	 * effects of the init routine are visible to the caller. */
	if *(*int32)(unsafe.Pointer(control)) == int32(2) {
		_a_barrier(tls)
		return int32(0)
	}
	return x___pthread_once_full(tls, control, init1)
}

func x_pthread_rwlock_destroy(tls *TLS, rw uintptr) (r int32) {
	return int32(0)
}

func x_pthread_rwlock_init(tls *TLS, rw uintptr, a uintptr) (r int32) {
	*(*Tpthread_rwlock_t)(unsafe.Pointer(rw)) = Tpthread_rwlock_t{}
	if a != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + UintptrFromInt32(2)*4)) = int32(*(*uint32)(unsafe.Pointer(a + UintptrFromInt32(0)*4)) * uint32(128))
	}
	return int32(0)
}

func x___pthread_rwlock_rdlock(tls *TLS, rw uintptr) (r int32) {
	return x___pthread_rwlock_timedrdlock(tls, rw, uintptr(0))
}

func x___pthread_rwlock_timedrdlock(tls *TLS, rw uintptr, at uintptr) (r1 int32) {
	var r int32
	var spins int32
	var t int32
	var v1 int32
	var v2 int32
	var v3 int32
	r = x___pthread_rwlock_tryrdlock(tls, rw)
	if r != int32(m_EBUSY) {
		return r
	}
	spins = int32(100)
	for {
		v1 = spins
		spins--
		if !(v1 != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4)) != 0 && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(1)*4)) != 0)) {
			break
		}
		_a_spin(tls)
	}
	for {
		v2 = x___pthread_rwlock_tryrdlock(tls, rw)
		r = v2
		if !(v2 == int32(m_EBUSY)) {
			break
		}
		v3 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4))
		r = v3
		if !(v3 != 0) || r&int32(0x7fffffff) != int32(0x7fffffff) {
			continue
		}
		t = int32(uint32(r) | uint32(0x80000000))
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(1)*4)
		_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, r, t)
		r = x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, t, int32(m_CLOCK_REALTIME), at, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + UintptrFromInt32(2)*4))^int32(128))
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(1)*4)
		if r != 0 && r != int32(m_EINTR) {
			return r
		}
	}
	return r
}

func x___pthread_rwlock_timedwrlock(tls *TLS, rw uintptr, at uintptr) (r1 int32) {
	var r int32
	var spins int32
	var t int32
	var v1 int32
	var v2 int32
	var v3 int32
	r = x___pthread_rwlock_trywrlock(tls, rw)
	if r != int32(m_EBUSY) {
		return r
	}
	spins = int32(100)
	for {
		v1 = spins
		spins--
		if !(v1 != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4)) != 0 && !(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(1)*4)) != 0)) {
			break
		}
		_a_spin(tls)
	}
	for {
		v2 = x___pthread_rwlock_trywrlock(tls, rw)
		r = v2
		if !(v2 == int32(m_EBUSY)) {
			break
		}
		v3 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4))
		r = v3
		if !(v3 != 0) {
			continue
		}
		t = int32(uint32(r) | uint32(0x80000000))
		_a_inc(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(1)*4)
		_a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, r, t)
		r = x___timedwait(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, t, int32(m_CLOCK_REALTIME), at, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + UintptrFromInt32(2)*4))^int32(128))
		_a_dec(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(1)*4)
		if r != 0 && r != int32(m_EINTR) {
			return r
		}
	}
	return r
}

func x___pthread_rwlock_tryrdlock(tls *TLS, rw uintptr) (r int32) {
	var cnt int32
	var val int32
	for cond := true; cond; cond = _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, val, val+int32(1)) != val {
		val = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4))
		cnt = val & int32(0x7fffffff)
		if cnt == int32(0x7fffffff) {
			return int32(m_EBUSY)
		}
		if cnt == int32(0x7ffffffe) {
			return int32(m_EAGAIN)
		}
	}
	return int32(0)
}

func x___pthread_rwlock_trywrlock(tls *TLS, rw uintptr) (r int32) {
	if _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, int32(0), int32(0x7fffffff)) != 0 {
		return int32(m_EBUSY)
	}
	return int32(0)
}

func x___pthread_rwlock_unlock(tls *TLS, rw uintptr) (r int32) {
	var cnt int32
	var new1 int32
	var priv int32
	var val int32
	var waiters int32
	var v1 int32
	priv = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u.F__i)) + UintptrFromInt32(2)*4)) ^ int32(128)
	for cond := true; cond; cond = _a_cas(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, val, new1) != val {
		val = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(0)*4))
		cnt = val & int32(0x7fffffff)
		waiters = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u)) + UintptrFromInt32(1)*4))
		if cnt == int32(0x7fffffff) || cnt == int32(1) {
			v1 = int32(0)
		} else {
			v1 = val - int32(1)
		}
		new1 = v1
	}
	if !(new1 != 0) && (waiters != 0 || val < int32(0)) {
		___wake(tls, uintptr(unsafe.Pointer(&(*Tpthread_rwlock_t)(unsafe.Pointer(rw)).F__u))+UintptrFromInt32(0)*4, cnt, priv)
	}
	return int32(0)
}

func x___pthread_rwlock_wrlock(tls *TLS, rw uintptr) (r int32) {
	return x___pthread_rwlock_timedwrlock(tls, rw, uintptr(0))
}

func x_pthread_rwlockattr_destroy(tls *TLS, a uintptr) (r int32) {
	return int32(0)
}

func x_pthread_rwlockattr_init(tls *TLS, a uintptr) (r int32) {
	*(*Tpthread_rwlockattr_t)(unsafe.Pointer(a)) = Tpthread_rwlockattr_t{}
	return int32(0)
}

func x_pthread_rwlockattr_setpshared(tls *TLS, a uintptr, pshared int32) (r int32) {
	if uint32(pshared) > uint32(1) {
		return int32(m_EINVAL)
	}
	*(*uint32)(unsafe.Pointer(a + UintptrFromInt32(0)*4)) = uint32(pshared)
	return int32(0)
}

func ___pthread_self_internal(tls *TLS) (r Tpthread_t) {
	return ___get_tp(tls)
}

func x_pthread_setattr_default_np(tls *TLS, attrp uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3815, int32(11), uintptr(unsafe.Pointer(&___func__75)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__75 = [27]int8{'p', 't', 'h', 'r', 'e', 'a', 'd', '_', 's', 'e', 't', 'a', 't', 't', 'r', '_', 'd', 'e', 'f', 'a', 'u', 'l', 't', '_', 'n', 'p'}

func x_pthread_getattr_default_np(tls *TLS, attrp uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3815, int32(16), uintptr(unsafe.Pointer(&___func__76)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__76 = [27]int8{'p', 't', 'h', 'r', 'e', 'a', 'd', '_', 'g', 'e', 't', 'a', 't', 't', 'r', '_', 'd', 'e', 'f', 'a', 'u', 'l', 't', '_', 'n', 'p'}

func x___pthread_setcancelstate(tls *TLS, new1 int32, old uintptr) (r int32) {
	var self uintptr
	if uint32(new1) > uint32(2) {
		return int32(m_EINVAL)
	}
	self = ___get_tp(tls)
	if old != 0 {
		*(*int32)(unsafe.Pointer(old)) = int32((*T__pthread)(unsafe.Pointer(self)).Fcanceldisable)
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcanceldisable = uint8(new1)
	return int32(0)
}

func x_pthread_setcanceltype(tls *TLS, new1 int32, old uintptr) (r int32) {
	var self uintptr
	self = ___get_tp(tls)
	if uint32(new1) > uint32(1) {
		return int32(m_EINVAL)
	}
	if old != 0 {
		*(*int32)(unsafe.Pointer(old)) = int32((*T__pthread)(unsafe.Pointer(self)).Fcancelasync)
	}
	(*T__pthread)(unsafe.Pointer(self)).Fcancelasync = uint8(new1)
	if new1 != 0 {
		x___pthread_testcancel(tls)
	}
	return int32(0)
}

func x_pthread_setconcurrency(tls *TLS, val int32) (r int32) {
	if val < int32(0) {
		return int32(m_EINVAL)
	}
	if val > int32(0) {
		return int32(m_EAGAIN)
	}
	return int32(0)
}

const m_PR_SET_NAME = 15

func x_pthread_setname_np(tls *TLS, thread Tpthread_t, name uintptr) (r int32) {
	bp := tls.Alloc(80) /* tlsAllocs 40 maxValist 4 */
	defer tls.Free(80)
	var fd int32
	var len1 Tsize_t
	var status int32
	var _ /* cs at bp+0 */ int32
	var _ /* f at bp+4 */ [34]int8
	var v1 Tsize_t
	var v2 int32
	var v3 int32
	status = int32(0)
	v1 = x_strnlen(tls, name, uint64(16))
	len1 = v1
	if v1 > uint64(15) {
		return int32(m_ERANGE)
	}
	if thread == ___pthread_self_internal(tls) {
		if x_prctl(tls, int32(m_PR_SET_NAME), VaList(bp+48, uint64(name), uint64(0), uint64(0), uint64(0))) != 0 {
			v2 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		} else {
			v2 = int32(0)
		}
		return v2
	}
	x_snprintf(tls, bp+4, uint64(34), ts+3791, VaList(bp+48, (*T__pthread)(unsafe.Pointer(thread)).Ftid))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	v3 = x_open(tls, bp+4, Int32FromInt32(m_O_WRONLY)|Int32FromInt32(m_O_CLOEXEC), 0)
	fd = v3
	if v3 < int32(0) || x_write(tls, fd, name, len1) < int64(0) {
		status = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	if fd >= int32(0) {
		x_close(tls, fd)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return status
}

func x_pthread_setschedparam(tls *TLS, t Tpthread_t, policy int32, param uintptr) (r1 int32) {
	bp := tls.Alloc(128) /* tlsAllocs 128 maxValist 0 */
	defer tls.Free(128)
	var r int32
	var _ /* set at bp+0 */ Tsigset_t
	var v1 int64
	x___block_app_sigs(tls, bp)
	x___lock(tls, t+176)
	if !((*T__pthread)(unsafe.Pointer(t)).Ftid != 0) {
		v1 = int64(m_ESRCH)
	} else {
		v1 = -___syscall3(tls, int64(144), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(policy), int64(param))
	}
	r = int32(v1)
	x___unlock(tls, t+176)
	x___restore_sigs(tls, bp)
	return r
}

func x_pthread_setschedprio(tls *TLS, t Tpthread_t, _prio int32) (r1 int32) {
	bp := tls.Alloc(136) /* tlsAllocs 136 maxValist 0 */
	defer tls.Free(136)
	*(*int32)(unsafe.Pointer(bp)) = _prio
	var r int32
	var _ /* set at bp+8 */ Tsigset_t
	var v1 int64
	x___block_app_sigs(tls, bp+8)
	x___lock(tls, t+176)
	if !((*T__pthread)(unsafe.Pointer(t)).Ftid != 0) {
		v1 = int64(m_ESRCH)
	} else {
		v1 = -___syscall2(tls, int64(142), int64((*T__pthread)(unsafe.Pointer(t)).Ftid), int64(bp))
	}
	r = int32(v1)
	x___unlock(tls, t+176)
	x___restore_sigs(tls, bp+8)
	return r
}

func x_pthread_setspecific(tls *TLS, k Tpthread_key_t, x uintptr) (r int32) {
	var self uintptr
	self = ___get_tp(tls)
	/* Avoid unnecessary COW */
	if *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) != x {
		*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) = x
		SetBitFieldPtr8Uint8(self+66, Uint8FromInt32(1), 0, 0x1)
	}
	return int32(0)
}

func x_pthread_sigmask(tls *TLS, how int32, set uintptr, old uintptr) (r int32) {
	var ret int32
	var p1 uintptr
	var p2 uintptr
	var p3 uintptr
	if set != 0 && uint32(how)-uint32(m_SIG_BLOCK) > uint32(2) {
		return int32(m_EINVAL)
	}
	ret = int32(-___syscall4(tls, int64(14), int64(how), int64(set), int64(old), int64(Int32FromInt32(65)/Int32FromInt32(8))))
	if !(ret != 0) && old != 0 {
		if uint64(8) == uint64(8) {
			p1 = old + UintptrFromInt32(0)*8
			*(*uint64)(unsafe.Pointer(p1)) = *(*uint64)(unsafe.Pointer(p1)) & ^Uint64FromUint64(0x380000000)
		} else {
			p2 = old + UintptrFromInt32(0)*8
			*(*uint64)(unsafe.Pointer(p2)) = *(*uint64)(unsafe.Pointer(p2)) & ^Uint64FromUint64(0x80000000)
			p3 = old + UintptrFromInt32(1)*8
			*(*uint64)(unsafe.Pointer(p3)) = *(*uint64)(unsafe.Pointer(p3)) & ^Uint64FromUint64(0x3)
		}
	}
	return ret
}

func x_pthread_spin_destroy(tls *TLS, s uintptr) (r int32) {
	return int32(0)
}

func x_pthread_spin_init(tls *TLS, s uintptr, shared int32) (r int32) {
	var v1 Tpthread_spinlock_t
	v1 = Int32FromInt32(0)
	*(*Tpthread_spinlock_t)(unsafe.Pointer(s)) = v1
	return v1
}

func x_pthread_spin_lock(tls *TLS, s uintptr) (r int32) {
	for *(*int32)(unsafe.Pointer(s)) != 0 || _a_cas(tls, s, int32(0), int32(m_EBUSY)) != 0 {
		_a_spin(tls)
	}
	return int32(0)
}

func x_pthread_spin_trylock(tls *TLS, s uintptr) (r int32) {
	return _a_cas(tls, s, int32(0), int32(m_EBUSY))
}

func x_pthread_spin_unlock(tls *TLS, s uintptr) (r int32) {
	_a_store(tls, s, int32(0))
	return int32(0)
}

func _dummy20(tls *TLS) {
}

func x___pthread_testcancel(tls *TLS) {
	x___testcancel(tls)
}

func x_sem_destroy(tls *TLS, sem uintptr) (r int32) {
	return int32(0)
}

func x_sem_getvalue(tls *TLS, sem uintptr, valp uintptr) (r int32) {
	var val int32
	val = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(0)*4))
	*(*int32)(unsafe.Pointer(valp)) = val & int32(m_SEM_VALUE_MAX)
	return int32(0)
}

func x_sem_init(tls *TLS, sem uintptr, pshared int32, value uint32) (r int32) {
	var v1 int32
	if value > uint32(m_SEM_VALUE_MAX) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(sem + UintptrFromInt32(0)*4)) = int32(value)
	*(*int32)(unsafe.Pointer(sem + UintptrFromInt32(1)*4)) = int32(0)
	if pshared != 0 {
		v1 = int32(0)
	} else {
		v1 = int32(128)
	}
	*(*int32)(unsafe.Pointer(sem + UintptrFromInt32(2)*4)) = v1
	return int32(0)
}

const m_EMFILE = 24
const m_F_OK = 0
const m_MAP_SHARED = 1

var _semtab uintptr
var _lock9 [1]int32

func x_sem_open(tls *TLS, name uintptr, flags int32, va uintptr) (r uintptr) {
	bp := tls.Alloc(552) /* tlsAllocs 536 maxValist 1 */
	defer tls.Free(552)
	var ap Tva_list
	var cnt int32
	var e int32
	var fd int32
	var first int32
	var i int32
	var map1 uintptr
	var mode Tmode_t
	var slot int32
	var value uint32
	var _ /* buf at bp+264 */ [265]int8
	var _ /* cs at bp+0 */ int32
	var _ /* newsem at bp+4 */ Tsem_t
	var _ /* st at bp+120 */ Tstat
	var _ /* tmp at bp+36 */ [64]int8
	var _ /* ts at bp+104 */ Ttimespec
	var v1 uintptr
	var v2 uintptr
	var v3 bool
	var v4 int32
	var v5 uintptr
	var v6 bool
	var v7 uintptr
	var v8 bool
	var v9 int32
	first = int32(1)
	v1 = x___shm_mapname(tls, name, bp+264)
	name = v1
	if !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	x___lock(tls, uintptr(unsafe.Pointer(&_lock9)))
	/* Allocate table if we don't have one yet */
	if v3 = !(_semtab != 0); v3 {
		v2 = x___libc_calloc(tls, uint64(24), uint64(m_SEM_NSEMS_MAX))
		_semtab = v2
	}
	if v3 && !(v2 != 0) {
		x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
		return UintptrFromInt32(0)
	}
	/* Reserve a slot in case this semaphore is not mapped yet;
	 * this is necessary because there is no way to handle
	 * failures after creation of the file. */
	slot = -int32(1)
	v4 = Int32FromInt32(0)
	i = v4
	cnt = v4
	for ; i < int32(m_SEM_NSEMS_MAX); i++ {
		cnt = cnt + (*(*struct {
			Fino         Tino_t
			Fsem         uintptr
			Frefcnt      int32
			F__ccgo_pad3 [4]byte
		})(unsafe.Pointer(_semtab + uintptr(i)*24))).Frefcnt
		if !((*(*struct {
			Fino         Tino_t
			Fsem         uintptr
			Frefcnt      int32
			F__ccgo_pad3 [4]byte
		})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fsem != 0) && slot < int32(0) {
			slot = i
		}
	}
	/* Avoid possibility of overflow later */
	if cnt == int32(m_INT_MAX) || slot < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EMFILE)
		x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
		return UintptrFromInt32(0)
	}
	/* Dummy pointer to make a reservation */
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Fsem = uintptr(-Int32FromInt32(1))
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
	flags = flags & (Int32FromInt32(m_O_CREAT) | Int32FromInt32(m_O_EXCL))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp)
	/* Early failure check for exclusive open; otherwise the case
	 * where the semaphore already exists is expensive. */
	if flags == Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_EXCL) && x_access(tls, name, int32(m_F_OK)) == int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EEXIST)
		goto fail
	}
	for {
		/* If exclusive mode is not requested, try opening an
		 * existing file first and fall back to creation. */
		if flags != Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_EXCL) {
			fd = x_open(tls, name, Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOFOLLOW)|Int32FromInt32(m_O_CLOEXEC)|Int32FromInt32(m_O_NONBLOCK), 0)
			if fd >= int32(0) {
				if v6 = x___fstat(tls, fd, bp+120) < int32(0); !v6 {
					v5 = x___mmap(tls, uintptr(0), uint64(32), Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), int32(m_MAP_SHARED), fd, int64(0))
					map1 = v5
				}
				if v6 || v5 == uintptr(-Int32FromInt32(1)) {
					x_close(tls, fd)
					goto fail
				}
				x_close(tls, fd)
				break
			}
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_ENOENT) {
				goto fail
			}
		}
		if !(flags&Int32FromInt32(m_O_CREAT) != 0) {
			goto fail
		}
		if first != 0 {
			first = int32(0)
			ap = va
			mode = VaUint32(&ap) & uint32(0666)
			value = VaUint32(&ap)
			_ = ap
			if value > uint32(m_SEM_VALUE_MAX) {
				*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EINVAL)
				goto fail
			}
			x_sem_init(tls, bp+4, int32(1), value)
		}
		/* Create a temp file with the new semaphore contents
		 * and attempt to atomically link it as the new name */
		x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp+104)
		x_snprintf(tls, bp+36, uint64(64), ts+3855, VaList(bp+544, int32((*(*Ttimespec)(unsafe.Pointer(bp + 104))).Ftv_nsec)))
		fd = x_open(tls, bp+36, Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_EXCL)|(Int32FromInt32(m_O_RDWR)|Int32FromInt32(m_O_NOFOLLOW)|Int32FromInt32(m_O_CLOEXEC)|Int32FromInt32(m_O_NONBLOCK)), VaList(bp+544, mode))
		if fd < int32(0) {
			if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EEXIST) {
				continue
			}
			goto fail
		}
		if v8 = uint64(x_write(tls, fd, bp+4, uint64(32))) != uint64(32) || x___fstat(tls, fd, bp+120) < int32(0); !v8 {
			v7 = x___mmap(tls, uintptr(0), uint64(32), Int32FromInt32(m_PROT_READ)|Int32FromInt32(m_PROT_WRITE), int32(m_MAP_SHARED), fd, int64(0))
			map1 = v7
		}
		if v8 || v7 == uintptr(-Int32FromInt32(1)) {
			x_close(tls, fd)
			x_unlink(tls, bp+36)
			goto fail
		}
		x_close(tls, fd)
		if x_link(tls, bp+36, name) != 0 {
			v9 = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
		} else {
			v9 = int32(0)
		}
		e = v9
		x_unlink(tls, bp+36)
		if !(e != 0) {
			break
		}
		x___munmap(tls, map1, uint64(32))
		/* Failure is only fatal when doing an exclusive open;
		 * otherwise, next iteration will try to open the
		 * existing file. */
		if e != int32(m_EEXIST) || flags == Int32FromInt32(m_O_CREAT)|Int32FromInt32(m_O_EXCL) {
			goto fail
		}
	}
	/* See if the newly mapped semaphore is already mapped. If
	 * so, unmap the new mapping and use the existing one. Otherwise,
	 * add it to the table of mapped semaphores. */
	x___lock(tls, uintptr(unsafe.Pointer(&_lock9)))
	for i = int32(0); i < int32(m_SEM_NSEMS_MAX) && (*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fino != (*(*Tstat)(unsafe.Pointer(bp + 120))).Fst_ino; i++ {
	}
	if i < int32(m_SEM_NSEMS_MAX) {
		x___munmap(tls, map1, uint64(32))
		(*(*struct {
			Fino         Tino_t
			Fsem         uintptr
			Frefcnt      int32
			F__ccgo_pad3 [4]byte
		})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Fsem = uintptr(0)
		slot = i
		map1 = (*(*struct {
			Fino         Tino_t
			Fsem         uintptr
			Frefcnt      int32
			F__ccgo_pad3 [4]byte
		})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fsem
	}
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Frefcnt++
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Fsem = map1
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Fino = (*(*Tstat)(unsafe.Pointer(bp + 120))).Fst_ino
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return map1
fail:
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	x___lock(tls, uintptr(unsafe.Pointer(&_lock9)))
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(slot)*24))).Fsem = uintptr(0)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
	return UintptrFromInt32(0)
}

func x_sem_close(tls *TLS, sem uintptr) (r int32) {
	var i int32
	var v1 int32
	var v2 uintptr
	x___lock(tls, uintptr(unsafe.Pointer(&_lock9)))
	for i = int32(0); i < int32(m_SEM_NSEMS_MAX) && (*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fsem != sem; i++ {
	}
	v2 = uintptr(unsafe.Pointer(&(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(i)*24))).Frefcnt))
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	if v1 != 0 {
		x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
		return int32(0)
	}
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fsem = uintptr(0)
	(*(*struct {
		Fino         Tino_t
		Fsem         uintptr
		Frefcnt      int32
		F__ccgo_pad3 [4]byte
	})(unsafe.Pointer(_semtab + uintptr(i)*24))).Fino = uint64(0)
	x___unlock(tls, uintptr(unsafe.Pointer(&_lock9)))
	x___munmap(tls, sem, uint64(32))
	return int32(0)
}

func x_sem_post(tls *TLS, sem uintptr) (r int32) {
	var new1 int32
	var priv int32
	var val int32
	var waiters int32
	var v1 int32
	priv = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(2)*4))
	for cond := true; cond; cond = _a_cas(tls, sem, val, new1) != val {
		val = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(0)*4))
		waiters = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(1)*4))
		if val&int32(m_SEM_VALUE_MAX) == int32(m_SEM_VALUE_MAX) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
			return -int32(1)
		}
		new1 = val + int32(1)
		if waiters <= int32(1) {
			new1 = int32(uint32(new1) & ^Uint32FromUint32(0x80000000))
		}
	}
	if val < int32(0) {
		if waiters > int32(1) {
			v1 = int32(1)
		} else {
			v1 = -int32(1)
		}
		___wake(tls, sem, v1, priv)
	}
	return int32(0)
}

func _cleanup2(tls *TLS, p uintptr) {
	_a_dec(tls, p)
}

func x_sem_timedwait(tls *TLS, sem uintptr, at uintptr) (r1 int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var priv int32
	var r int32
	var spins int32
	var _ /* __cb at bp+0 */ T__ptcb
	var v1 int32
	x___pthread_testcancel(tls)
	if !(x_sem_trywait(tls, sem) != 0) {
		return int32(0)
	}
	spins = int32(100)
	for {
		v1 = spins
		spins--
		if !(v1 != 0 && !(*(*int32)(unsafe.Pointer(sem + UintptrFromInt32(0)*4))&Int32FromInt32(m_SEM_VALUE_MAX) != 0) && !(*(*int32)(unsafe.Pointer(sem + UintptrFromInt32(1)*4)) != 0)) {
			break
		}
		_a_spin(tls)
	}
	for x_sem_trywait(tls, sem) != 0 {
		priv = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(2)*4))
		_a_inc(tls, sem+uintptr(1)*4)
		_a_cas(tls, sem, int32(0), Int32FromUint32(0x80000000))
		{
			x__pthread_cleanup_push(tls, bp, __ccgo_fp(_cleanup2), sem+UintptrFromInt32(1)*4)
			r = x___timedwait_cp(tls, sem, Int32FromUint32(0x80000000), int32(m_CLOCK_REALTIME), at, priv)
			x__pthread_cleanup_pop(tls, bp, int32(1))
		}
		if r != 0 {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = r
			return -int32(1)
		}
	}
	return int32(0)
}

func x_sem_trywait(tls *TLS, sem uintptr) (r int32) {
	var val int32
	var v1 int32
	for {
		v1 = *(*int32)(unsafe.Pointer(sem + UintptrFromInt32(0)*4))
		val = v1
		if !(v1&int32(m_SEM_VALUE_MAX) != 0) {
			break
		}
		if _a_cas(tls, sem, val, val-int32(1)) == val {
			return int32(0)
		}
	}
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EAGAIN)
	return -int32(1)
}

func x_sem_unlink(tls *TLS, name uintptr) (r int32) {
	return x_shm_unlink(tls, name)
}

func x_sem_wait(tls *TLS, sem uintptr) (r int32) {
	return x_sem_timedwait(tls, sem, uintptr(0))
}

func _dummy_04(tls *TLS) {
}

var _target_tid int32
var _callback uintptr
var _context uintptr
var _target_sem Tsem_t
var _caller_sem Tsem_t

func _dummy21(tls *TLS, p uintptr) {
}

func _handler(tls *TLS, sig int32) {
	var old_errno int32
	if (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid != _target_tid {
		return
	}
	old_errno = *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	/* Inform caller we have received signal and wait for
	 * the caller to let us make the callback. */
	x_sem_post(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	x_sem_wait(tls, uintptr(unsafe.Pointer(&_target_sem)))
	(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{_callback})))(tls, _context)
	/* Inform caller we've complered the callback and wait
	 * for the caller to release us to return. */
	x_sem_post(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	x_sem_wait(tls, uintptr(unsafe.Pointer(&_target_sem)))
	/* Inform caller we are returning and state is destroyable. */
	x_sem_post(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = old_errno
}

func x___synccall(tls *TLS, func1 uintptr, ctx uintptr) {
	bp := tls.Alloc(288) /* tlsAllocs 288 maxValist 0 */
	defer tls.Free(288)
	var count int32
	var i int32
	var r int32
	var self Tpthread_t
	var td Tpthread_t
	var _ /* cs at bp+128 */ int32
	var _ /* oldmask at bp+0 */ Tsigset_t
	var _ /* sa at bp+136 */ Tsigaction
	var v1 int32
	var v2 uintptr
	*(*Tsigaction)(unsafe.Pointer(bp + 136)) = Tsigaction{F__sa_handler: struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	}{Fsa_handler: __ccgo_fp(_handler)}, Fsa_flags: Int32FromInt32(m_SA_RESTART) | Int32FromInt32(m_SA_ONSTACK)}
	self = ___get_tp(tls)
	count = int32(0)
	/* Blocking signals in two steps, first only app-level signals
	 * before taking the lock, then all signals after taking the lock,
	 * is necessary to achieve AS-safety. Blocking them all first would
	 * deadlock if multiple threads called __synccall. Waiting to block
	 * any until after the lock would allow re-entry in the same thread
	 * with the lock already held. */
	x___block_app_sigs(tls, bp)
	x___tl_lock(tls)
	x___block_all_sigs(tls, uintptr(0))
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DISABLE), bp+128)
	x_sem_init(tls, uintptr(unsafe.Pointer(&_target_sem)), int32(0), uint32(0))
	x_sem_init(tls, uintptr(unsafe.Pointer(&_caller_sem)), int32(0), uint32(0))
	if !(x___libc.Fthreads_minus_1 != 0) || ___syscall0(tls, int64(186)) != int64((*T__pthread)(unsafe.Pointer(self)).Ftid) {
		goto single_threaded
	}
	_callback = func1
	_context = ctx
	/* Block even implementation-internal signals, so that nothing
	 * interrupts the SIGSYNCCALL handlers. The main possible source
	 * of trouble is asynchronous cancellation. */
	x_memset(tls, uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 136))).Fsa_mask)), -int32(1), uint64(128))
	x___libc_sigaction(tls, int32(m_SIGSYNCCALL), bp+136, uintptr(0))
	for td = (*T__pthread)(unsafe.Pointer(self)).Fnext; td != self; td = (*T__pthread)(unsafe.Pointer(td)).Fnext {
		_target_tid = (*T__pthread)(unsafe.Pointer(td)).Ftid
		for {
			v1 = int32(-___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(td)).Ftid), int64(Int32FromInt32(34))))
			r = v1
			if !(v1 == int32(m_EAGAIN)) {
				break
			}
		}
		if r != 0 {
			/* If we failed to signal any thread, nop out the
			 * callback to abort the synccall and just release
			 * any threads already caught. */
			v2 = __ccgo_fp(_dummy21)
			func1 = v2
			_callback = v2
			break
		}
		x_sem_wait(tls, uintptr(unsafe.Pointer(&_caller_sem)))
		count++
	}
	_target_tid = int32(0)
	/* Serialize execution of callback in caught threads, or just
	 * release them all if synccall is being aborted. */
	for i = int32(0); i < count; i++ {
		x_sem_post(tls, uintptr(unsafe.Pointer(&_target_sem)))
		x_sem_wait(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	}
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tsigaction)(unsafe.Pointer(bp + 136))).F__sa_handler)))) = UintptrFromInt32(1)
	x___libc_sigaction(tls, int32(m_SIGSYNCCALL), bp+136, uintptr(0))
single_threaded:
	(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{func1})))(tls, ctx)
	/* Only release the caught threads once all threads, including the
	 * caller, have returned from the callback function. */
	for i = int32(0); i < count; i++ {
		x_sem_post(tls, uintptr(unsafe.Pointer(&_target_sem)))
	}
	for i = int32(0); i < count; i++ {
		x_sem_wait(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	}
	x_sem_destroy(tls, uintptr(unsafe.Pointer(&_caller_sem)))
	x_sem_destroy(tls, uintptr(unsafe.Pointer(&_target_sem)))
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 128)), uintptr(0))
	x___tl_unlock(tls)
	x___restore_sigs(tls, bp)
}

func x_thrd_create(tls *TLS, thr uintptr, func1 Tthrd_start_t, arg uintptr) (r int32) {
	var ret int32
	ret = x___pthread_create(tls, thr, uintptr(uint64(-Int32FromInt32(1))), func1, arg)
	switch ret {
	case int32(0):
		return int32(_thrd_success)
	case int32(m_EAGAIN):
		return int32(_thrd_nomem)
	default:
		return int32(_thrd_error)
	}
	return r
}

func x_thrd_exit(tls *TLS, result int32) {
	x___pthread_exit(tls, uintptr(int64(result)))
}

func x_thrd_join(tls *TLS, t Tthrd_t, res uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var _ /* pthread_res at bp+0 */ uintptr
	x___pthread_join(tls, t, bp)
	if res != 0 {
		*(*int32)(unsafe.Pointer(res)) = int32(int64(*(*uintptr)(unsafe.Pointer(bp))))
	}
	return int32(_thrd_success)
}

func x_thrd_sleep(tls *TLS, req uintptr, rem uintptr) (r int32) {
	var ret int32
	ret = -x___clock_nanosleep(tls, int32(m_CLOCK_REALTIME), int32(0), req, rem)
	switch ret {
	case int32(0):
		return int32(0)
	case -int32(m_EINTR):
		return -int32(1) /* value specified by C11 */
	default:
		return -int32(2)
	}
	return r
}

func x_thrd_yield(tls *TLS) {
	___syscall0(tls, int64(24))
}

func x_tss_create(tls *TLS, tss uintptr, dtor Ttss_dtor_t) (r int32) {
	var v1 int32
	/* Different error returns are possible. C glues them together into
	 * just failure notification. Can't be optimized to a tail call,
	 * unless thrd_error equals EAGAIN. */
	if x___pthread_key_create(tls, tss, dtor) != 0 {
		v1 = int32(_thrd_error)
	} else {
		v1 = int32(_thrd_success)
	}
	return v1
}

func x_tss_delete(tls *TLS, key Ttss_t) {
	x___pthread_key_delete(tls, key)
}

func x_tss_set(tls *TLS, k Ttss_t, x uintptr) (r int32) {
	var self uintptr
	self = ___get_tp(tls)
	/* Avoid unnecessary COW */
	if *(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) != x {
		*(*uintptr)(unsafe.Pointer((*T__pthread)(unsafe.Pointer(self)).Ftsd + uintptr(k)*8)) = x
		SetBitFieldPtr8Uint8(self+66, Uint8FromInt32(1), 0, 0x1)
	}
	return int32(_thrd_success)
}

var _vmlock [2]int32

func x___vm_wait(tls *TLS) {
	var tmp int32
	var v1 int32
	for {
		v1 = _vmlock[int32(0)]
		tmp = v1
		if !(v1 != 0) {
			break
		}
		x___wait(tls, uintptr(unsafe.Pointer(&_vmlock)), uintptr(unsafe.Pointer(&_vmlock))+uintptr(1)*4, tmp, int32(1))
	}
}

func x___vm_lock(tls *TLS) {
	_a_inc(tls, uintptr(unsafe.Pointer(&_vmlock)))
}

func x___vm_unlock(tls *TLS) {
	if _a_fetch_add(tls, uintptr(unsafe.Pointer(&_vmlock)), -int32(1)) == int32(1) && _vmlock[int32(1)] != 0 {
		___wake(tls, uintptr(unsafe.Pointer(&_vmlock)), -int32(1), int32(1))
	}
}

const m_O_LARGEFILE4 = 524288

func x___map_file(tls *TLS, pathname uintptr, size uintptr) (r uintptr) {
	bp := tls.Alloc(144) /* tlsAllocs 144 maxValist 0 */
	defer tls.Free(144)
	var fd int32
	var map1 uintptr
	var _ /* st at bp+0 */ Tstat
	var v1 uintptr
	map1 = uintptr(-Int32FromInt32(1))
	fd = int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(m_SYS_open), int64(pathname), int64(Int32FromInt32(00)|Int32FromInt32(02000000)|Int32FromInt32(04000)|Int32FromInt32(m_O_LARGEFILE4))))))
	if fd < int32(0) {
		return uintptr(0)
	}
	if !(x___fstat(tls, fd, bp) != 0) {
		map1 = x___mmap(tls, uintptr(0), uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_size), int32(m_PROT_READ), int32(m_MAP_SHARED), fd, int64(0))
		*(*Tsize_t)(unsafe.Pointer(size)) = uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_size)
	}
	___syscall1(tls, int64(3), int64(fd))
	if map1 == uintptr(-Int32FromInt32(1)) {
		v1 = uintptr(0)
	} else {
		v1 = map1
	}
	return v1
}

func x___month_to_secs(tls *TLS, month int32, is_leap int32) (r int32) {
	var t int32
	t = _secs_through_month[month]
	if is_leap != 0 && month >= int32(2) {
		t = t + Int32FromInt32(86400)
	}
	return t
}

var _secs_through_month = [12]int32{
	0:  int32(0),
	1:  Int32FromInt32(31) * Int32FromInt32(86400),
	2:  Int32FromInt32(59) * Int32FromInt32(86400),
	3:  Int32FromInt32(90) * Int32FromInt32(86400),
	4:  Int32FromInt32(120) * Int32FromInt32(86400),
	5:  Int32FromInt32(151) * Int32FromInt32(86400),
	6:  Int32FromInt32(181) * Int32FromInt32(86400),
	7:  Int32FromInt32(212) * Int32FromInt32(86400),
	8:  Int32FromInt32(243) * Int32FromInt32(86400),
	9:  Int32FromInt32(273) * Int32FromInt32(86400),
	10: Int32FromInt32(304) * Int32FromInt32(86400),
	11: Int32FromInt32(334) * Int32FromInt32(86400)}

func x___secs_to_tm(tls *TLS, t int64, tm uintptr) (r int32) {
	var c_cycles int32
	var days int64
	var leap int32
	var months int32
	var q_cycles int32
	var qc_cycles int32
	var remdays int32
	var remsecs int32
	var remyears int32
	var secs int64
	var wday int32
	var yday int32
	var years int64
	/* Reject time_t values whose year would overflow int */
	if t < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff))*Int64FromInt64(31622400) || t > Int64FromInt32(m_INT_MAX)*Int64FromInt64(31622400) {
		return -int32(1)
	}
	secs = t - (Int64FromInt64(946684800) + int64(Int32FromInt32(86400)*(Int32FromInt32(31)+Int32FromInt32(29))))
	days = secs / int64(86400)
	remsecs = int32(secs % int64(86400))
	if remsecs < int32(0) {
		remsecs = remsecs + Int32FromInt32(86400)
		days--
	}
	wday = int32((int64(3) + days) % int64(7))
	if wday < int32(0) {
		wday = wday + Int32FromInt32(7)
	}
	qc_cycles = int32(days / int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)))
	remdays = int32(days % int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)))
	if remdays < int32(0) {
		remdays = remdays + (Int32FromInt32(365)*Int32FromInt32(400) + Int32FromInt32(97))
		qc_cycles--
	}
	c_cycles = remdays / (Int32FromInt32(365)*Int32FromInt32(100) + Int32FromInt32(24))
	if c_cycles == int32(4) {
		c_cycles--
	}
	remdays = remdays - c_cycles*(Int32FromInt32(365)*Int32FromInt32(100)+Int32FromInt32(24))
	q_cycles = remdays / (Int32FromInt32(365)*Int32FromInt32(4) + Int32FromInt32(1))
	if q_cycles == int32(25) {
		q_cycles--
	}
	remdays = remdays - q_cycles*(Int32FromInt32(365)*Int32FromInt32(4)+Int32FromInt32(1))
	remyears = remdays / int32(365)
	if remyears == int32(4) {
		remyears--
	}
	remdays = remdays - remyears*Int32FromInt32(365)
	leap = BoolInt32(!(remyears != 0) && (q_cycles != 0 || !(c_cycles != 0)))
	yday = remdays + int32(31) + int32(28) + leap
	if yday >= int32(365)+leap {
		yday = yday - (Int32FromInt32(365) + leap)
	}
	years = int64(remyears+int32(4)*q_cycles+int32(100)*c_cycles) + int64(400)*int64(qc_cycles)
	for months = int32(0); int32(_days_in_month[months]) <= remdays; months++ {
		remdays = remdays - int32(_days_in_month[months])
	}
	if months >= int32(10) {
		months = months - Int32FromInt32(12)
		years++
	}
	if years+int64(100) > int64(m_INT_MAX) || years+int64(100) < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
		return -int32(1)
	}
	(*Ttm)(unsafe.Pointer(tm)).Ftm_year = int32(years + int64(100))
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mon = months + int32(2)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mday = remdays + int32(1)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_wday = wday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_yday = yday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_hour = remsecs / int32(3600)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_min = remsecs / int32(60) % int32(60)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_sec = remsecs % int32(60)
	return int32(0)
}

var _days_in_month = [12]int8{
	0:  int8(31),
	1:  int8(30),
	2:  int8(31),
	3:  int8(30),
	4:  int8(31),
	5:  int8(31),
	6:  int8(30),
	7:  int8(31),
	8:  int8(30),
	9:  int8(31),
	10: int8(31),
	11: int8(29)}

func x___tm_to_secs(tls *TLS, tm uintptr) (r int64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var adj int32
	var month int32
	var t int64
	var year int64
	var _ /* is_leap at bp+0 */ int32
	year = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year)
	month = (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
	if month >= int32(12) || month < int32(0) {
		adj = month / int32(12)
		month = month % Int32FromInt32(12)
		if month < int32(0) {
			adj--
			month = month + Int32FromInt32(12)
		}
		year = year + int64(adj)
	}
	t = x___year_to_secs(tls, year, bp)
	t = t + int64(x___month_to_secs(tls, month, *(*int32)(unsafe.Pointer(bp))))
	t = t + Int64FromInt64(86400)*int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mday-Int32FromInt32(1))
	t = t + Int64FromInt64(3600)*int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
	t = t + Int64FromInt64(60)*int64((*Ttm)(unsafe.Pointer(tm)).Ftm_min)
	t = t + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_sec)
	return t
}

var _lock10 [1]int32

func x___secs_to_zone(tls *TLS, t int64, local int32, isdst uintptr, offset uintptr, oppoff uintptr, zonename uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3871, int32(36), uintptr(unsafe.Pointer(&___func__77)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__77 = [15]int8{'_', '_', 's', 'e', 'c', 's', '_', 't', 'o', '_', 'z', 'o', 'n', 'e'}

func ___tzset(tls *TLS) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3871, int32(41), uintptr(unsafe.Pointer(&___func__78)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__78 = [8]int8{'_', '_', 't', 'z', 's', 'e', 't'}

func x___tm_to_tzname(tls *TLS, tm uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+3871, int32(48), uintptr(unsafe.Pointer(&___func__79)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__79 = [15]int8{'_', '_', 't', 'm', '_', 't', 'o', '_', 't', 'z', 'n', 'a', 'm', 'e'}

func x___year_to_secs(tls *TLS, year int64, is_leap uintptr) (r int64) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var centuries int32
	var cycles int32
	var leaps int32
	var leaps1 int32
	var rem int32
	var y int32
	if uint64(year)-uint64(2) <= uint64(136) {
		y = int32(year)
		leaps = (y - int32(68)) >> int32(2)
		if !((y-Int32FromInt32(68))&Int32FromInt32(3) != 0) {
			leaps--
			if is_leap != 0 {
				*(*int32)(unsafe.Pointer(is_leap)) = int32(1)
			}
		} else {
			if is_leap != 0 {
				*(*int32)(unsafe.Pointer(is_leap)) = int32(0)
			}
		}
		return int64(int32(31536000)*(y-int32(70)) + int32(86400)*leaps)
	}
	if !(is_leap != 0) {
		*(*int32)(unsafe.Pointer(bp)) = int32(0)
		is_leap = bp
	}
	cycles = int32((year - int64(100)) / int64(400))
	rem = int32((year - int64(100)) % int64(400))
	if rem < int32(0) {
		cycles--
		rem = rem + Int32FromInt32(400)
	}
	if !(rem != 0) {
		*(*int32)(unsafe.Pointer(is_leap)) = int32(1)
		centuries = int32(0)
		leaps1 = int32(0)
	} else {
		if rem >= int32(200) {
			if rem >= int32(300) {
				centuries = int32(3)
				rem = rem - Int32FromInt32(300)
			} else {
				centuries = int32(2)
				rem = rem - Int32FromInt32(200)
			}
		} else {
			if rem >= int32(100) {
				centuries = int32(1)
				rem = rem - Int32FromInt32(100)
			} else {
				centuries = int32(0)
			}
		}
		if !(rem != 0) {
			*(*int32)(unsafe.Pointer(is_leap)) = int32(0)
			leaps1 = int32(0)
		} else {
			leaps1 = int32(uint32(rem) / uint32(4))
			rem = int32(uint32(rem) % Uint32FromUint32(4))
			*(*int32)(unsafe.Pointer(is_leap)) = BoolInt32(!(rem != 0))
		}
	}
	leaps1 = leaps1 + (Int32FromInt32(97)*cycles + Int32FromInt32(24)*centuries - *(*int32)(unsafe.Pointer(is_leap)))
	return (year-int64(100))*int64(31536000) + int64(leaps1)*int64(86400) + int64(946684800) + int64(86400)
}

func x_asctime(tls *TLS, tm uintptr) (r uintptr) {
	return x___asctime_r(tls, tm, uintptr(unsafe.Pointer(&_buf10)))
}

var _buf10 [26]int8

const m_ABDAY_1 = 131072
const m_ABMON_1 = 131086

func x___asctime_r(tls *TLS, tm uintptr, buf uintptr) (r uintptr) {
	bp := tls.Alloc(64) /* tlsAllocs 0 maxValist 7 */
	defer tls.Free(64)
	if x_snprintf(tls, buf, uint64(26), ts+3887, VaList(bp+8, x___nl_langinfo_l(tls, int32(m_ABDAY_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_wday, uintptr(unsafe.Pointer(&x___c_locale))), x___nl_langinfo_l(tls, int32(m_ABMON_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_mon, uintptr(unsafe.Pointer(&x___c_locale))), (*Ttm)(unsafe.Pointer(tm)).Ftm_mday, (*Ttm)(unsafe.Pointer(tm)).Ftm_hour, (*Ttm)(unsafe.Pointer(tm)).Ftm_min, (*Ttm)(unsafe.Pointer(tm)).Ftm_sec, int32(1900)+(*Ttm)(unsafe.Pointer(tm)).Ftm_year)) >= int32(26) {
		/* ISO C requires us to use the above format string,
		 * even if it will not fit in the buffer. Thus asctime_r
		 * is _supposed_ to crash if the fields in tm are too large.
		 * We follow this behavior and crash "gracefully" to warn
		 * application developers that they may not be so lucky
		 * on other implementations (e.g. stack smashing..).
		 */
		_a_crash(tls)
	}
	return buf
}

const m_CLOCK_PROCESS_CPUTIME_ID = 2

func x_clock(tls *TLS) (r Tclock_t) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	if x___clock_gettime(tls, int32(m_CLOCK_PROCESS_CPUTIME_ID), bp) != 0 {
		return int64(-int32(1))
	}
	if (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec > Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(1000000) || (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec/int64(1000) > int64(0x7fffffffffffffff)-int64(1000000)*(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec {
		return int64(-int32(1))
	}
	return (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec*int64(1000000) + (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec/int64(1000)
}

func x_clock_getcpuclockid(tls *TLS, pid Tpid_t, clk uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var id Tclockid_t
	var ret int32
	var _ /* ts at bp+0 */ Ttimespec
	id = int32(uint32(-pid-Int32FromInt32(1))*uint32(8) + uint32(2))
	ret = int32(___syscall2(tls, int64(229), int64(id), int64(bp)))
	if ret == -int32(m_EINVAL) {
		ret = -int32(m_ESRCH)
	}
	if ret != 0 {
		return -ret
	}
	*(*Tclockid_t)(unsafe.Pointer(clk)) = id
	return int32(0)
}

func x_clock_getres(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	/* If reaching this point, it's a 64-bit arch or time64-only
	 * 32-bit arch and we can get result directly into timespec. */
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(229), int64(clk), int64(ts)))))
}

const m_VDSO_CGT_SYM = "__vdso_clock_gettime"
const m_VDSO_CGT_VER = "LINUX_2.6"

func _cgt_init(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	var f uintptr
	var p uintptr
	var v1 int32
	p = x___vdsosym(tls, ts+3315, ts+3919)
	f = p
	_a_cas_p(tls, uintptr(unsafe.Pointer(&_vdso_func1)), __ccgo_fp(_cgt_init), p)
	if f != 0 {
		v1 = (*(*func(*TLS, Tclockid_t, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{f})))(tls, clk, ts)
	} else {
		v1 = -int32(m_ENOSYS)
	}
	return v1
}

var _vdso_func1 = uintptr(0)

func init() {
	p := unsafe.Pointer(&_vdso_func1)
	*(*uintptr)(unsafe.Add(p, 0)) = __ccgo_fp(_cgt_init)
}

func x___clock_gettime(tls *TLS, clk Tclockid_t, ts uintptr) (r1 int32) {
	var f uintptr
	var r int32
	f = _vdso_func1
	if f != 0 {
		r = (*(*func(*TLS, Tclockid_t, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{f})))(tls, clk, ts)
		if !(r != 0) {
			return r
		}
		if r == -int32(m_EINVAL) {
			return int32(x___syscall_ret(tls, uint64(r)))
		}
		/* Fall through on errors other than EINVAL. Some buggy
		 * vdso implementations return ENOSYS for clocks they
		 * can't handle, rather than making the syscall. This
		 * also handles the case where cgt_init fails to find
		 * a vdso function to use. */
	}
	r = int32(___syscall2(tls, int64(228), int64(clk), int64(ts)))
	if r == -int32(m_ENOSYS) {
		if clk == int32(m_CLOCK_REALTIME) {
			___syscall2(tls, int64(96), int64(ts), int64(Int32FromInt32(0)))
			(*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec = int64(int32((*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec) * int32(1000))
			return int32(0)
		}
		r = -int32(m_EINVAL)
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

const m_CLOCK_THREAD_CPUTIME_ID = 3

func x___clock_nanosleep(tls *TLS, clk Tclockid_t, flags int32, req uintptr, rem uintptr) (r int32) {
	if clk == int32(m_CLOCK_THREAD_CPUTIME_ID) {
		return int32(m_EINVAL)
	}
	if clk == int32(m_CLOCK_REALTIME) && !(flags != 0) {
		return int32(-x___syscall_cp(tls, int64(35), int64(req), int64(rem), int64(0), int64(0), int64(0), int64(0)))
	}
	return int32(-x___syscall_cp(tls, int64(230), int64(clk), int64(flags), int64(req), int64(rem), int64(0), int64(0)))
}

func x_clock_settime(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(227), int64(clk), int64(ts)))))
}

func x_ctime(tls *TLS, t uintptr) (r uintptr) {
	var tm uintptr
	tm = x_localtime(tls, t)
	if !(tm != 0) {
		return uintptr(0)
	}
	return x_asctime(tls, tm)
}

func x_ctime_r(tls *TLS, t uintptr, buf uintptr) (r uintptr) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxValist 0 */
	defer tls.Free(56)
	var tm_p uintptr
	var _ /* tm at bp+0 */ Ttm
	var v1 uintptr
	tm_p = x___localtime_r(tls, t, bp)
	if tm_p != 0 {
		v1 = x___asctime_r(tls, tm_p, buf)
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func x_difftime(tls *TLS, t1 Ttime_t, t0 Ttime_t) (r float64) {
	return float64(t1 - t0)
}

type Ttimeb = struct {
	Ftime        Ttime_t
	Fmillitm     uint16
	Ftimezone    int16
	Fdstflag     int16
	F__ccgo_pad4 [2]byte
}

func x_ftime(tls *TLS, tp uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	var v1 int16
	x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp)
	(*Ttimeb)(unsafe.Pointer(tp)).Ftime = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	(*Ttimeb)(unsafe.Pointer(tp)).Fmillitm = uint16((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec / int64(1000000))
	v1 = Int16FromInt32(0)
	(*Ttimeb)(unsafe.Pointer(tp)).Fdstflag = v1
	(*Ttimeb)(unsafe.Pointer(tp)).Ftimezone = v1
	return int32(0)
}

const m_PTHREAD_CANCEL_DEFERRED = 0

func x_getdate(tls *TLS, s uintptr) (r uintptr) {
	bp := tls.Alloc(104) /* tlsAllocs 104 maxValist 0 */
	defer tls.Free(104)
	var datemsk uintptr
	var f uintptr
	var p uintptr
	var ret uintptr
	var _ /* cs at bp+100 */ int32
	var _ /* fmt at bp+0 */ [100]int8
	ret = uintptr(0)
	datemsk = x_getenv(tls, ts+3940)
	f = uintptr(0)
	x___pthread_setcancelstate(tls, int32(m_PTHREAD_CANCEL_DEFERRED), bp+100)
	if !(datemsk != 0) {
		x_getdate_err = int32(1)
		goto out
	}
	f = x_fopen(tls, datemsk, ts+586)
	if !(f != 0) {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_ENOMEM) {
			x_getdate_err = int32(6)
		} else {
			x_getdate_err = int32(2)
		}
		goto out
	}
	for x_fgets(tls, bp, int32(100), f) != 0 {
		p = x_strptime(tls, s, bp, uintptr(unsafe.Pointer(&_tmbuf)))
		if p != 0 && !(*(*int8)(unsafe.Pointer(p)) != 0) {
			ret = uintptr(unsafe.Pointer(&_tmbuf))
			goto out
		}
	}
	if x_ferror(tls, f) != 0 {
		x_getdate_err = int32(5)
	} else {
		x_getdate_err = int32(7)
	}
out:
	if f != 0 {
		x_fclose(tls, f)
	}
	x___pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 100)), uintptr(0))
	return ret
}

var _tmbuf Ttm

func x_gettimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	if !(tv != 0) {
		return int32(0)
	}
	x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp)
	(*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	(*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec = int64(int32((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec) / int32(1000))
	return int32(0)
}

func x_gmtime(tls *TLS, t uintptr) (r uintptr) {
	return x___gmtime_r(tls, t, uintptr(unsafe.Pointer(&_tm)))
}

var _tm Ttm

func x___gmtime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	if x___secs_to_tm(tls, *(*Ttime_t)(unsafe.Pointer(t)), tm) < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return uintptr(0)
	}
	(*Ttm)(unsafe.Pointer(tm)).Ftm_isdst = int32(0)
	(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff = int64(0)
	(*Ttm)(unsafe.Pointer(tm)).F__tm_zone = uintptr(unsafe.Pointer(&x___utc))
	return tm
}

func x_localtime(tls *TLS, t uintptr) (r uintptr) {
	return x___localtime_r(tls, t, uintptr(unsafe.Pointer(&_tm1)))
}

var _tm1 Ttm

func x___localtime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	/* Reject time_t values whose year would overflow int because
	 * __secs_to_zone cannot safely handle them. */
	if *(*Ttime_t)(unsafe.Pointer(t)) < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff))*Int64FromInt64(31622400) || *(*Ttime_t)(unsafe.Pointer(t)) > Int64FromInt32(m_INT_MAX)*Int64FromInt64(31622400) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return uintptr(0)
	}
	x___secs_to_zone(tls, *(*Ttime_t)(unsafe.Pointer(t)), int32(0), tm+32, tm+40, uintptr(0), tm+48)
	if x___secs_to_tm(tls, *(*Ttime_t)(unsafe.Pointer(t))+(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff, tm) < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return uintptr(0)
	}
	return tm
}

func x_mktime(tls *TLS, tm uintptr) (r Ttime_t) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxValist 0 */
	defer tls.Free(64)
	var t int64
	var _ /* new at bp+0 */ Ttm
	var _ /* opp at bp+56 */ int64
	t = x___tm_to_secs(tls, tm)
	x___secs_to_zone(tls, t, int32(1), uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).Ftm_isdst)), uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff)), bp+56, uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).F__tm_zone)))
	if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst >= int32(0) && (*(*Ttm)(unsafe.Pointer(bp))).Ftm_isdst != (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst {
		t = t - (*(*int64)(unsafe.Pointer(bp + 56)) - (*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff)
	}
	t = t - (*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff
	if t != t {
		goto error
	}
	x___secs_to_zone(tls, t, int32(0), uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).Ftm_isdst)), uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff)), bp+56, uintptr(unsafe.Pointer(&(*(*Ttm)(unsafe.Pointer(bp))).F__tm_zone)))
	if x___secs_to_tm(tls, t+(*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff, bp) < int32(0) {
		goto error
	}
	*(*Ttm)(unsafe.Pointer(tm)) = *(*Ttm)(unsafe.Pointer(bp))
	return t
error:
	*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
	return int64(-int32(1))
}

func x_nanosleep(tls *TLS, req uintptr, rem uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(-x___clock_nanosleep(tls, int32(m_CLOCK_REALTIME), int32(0), req, rem))))
}

const m_AM_STR = 131110
const m_DAY_1 = 131079
const m_D_FMT = 131113
const m_D_T_FMT = 131112
const m_MON_1 = 131098
const m_PM_STR = 131111
const m_T_FMT = 131114
const m_T_FMT_AMPM = 131115

func _is_leap(tls *TLS, y int32) (r int32) {
	/* Avoid overflow */
	if y > Int32FromInt32(m_INT_MAX)-Int32FromInt32(1900) {
		y = y - Int32FromInt32(2000)
	}
	y = y + Int32FromInt32(1900)
	return BoolInt32(!(y%Int32FromInt32(4) != 0) && (y%int32(100) != 0 || !(y%Int32FromInt32(400) != 0)))
}

func _week_num(tls *TLS, tm uintptr) (r int32) {
	var dec31 int32
	var jan1 int32
	var val int32
	val = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(6))%uint32(7)) / uint32(7))
	/* If 1 Jan is just 1-3 days past Monday,
	 * the previous week is also in this year. */
	if (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(371)-uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday)-uint32(2))%uint32(7) <= uint32(2) {
		val++
	}
	if !(val != 0) {
		val = int32(52)
		/* If 31 December of prev year a Thursday,
		 * or Friday of a leap year, then the
		 * prev year has 53 weeks. */
		dec31 = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) + uint32(7) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) - uint32(1)) % uint32(7))
		if dec31 == int32(4) || dec31 == int32(5) && _is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year%int32(400)-int32(1)) != 0 {
			val++
		}
	} else {
		if val == int32(53) {
			/* If 1 January is not a Thursday, and not
			 * a Wednesday of a leap year, then this
			 * year has only 52 weeks. */
			jan1 = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) + uint32(371) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday)) % uint32(7))
			if jan1 != int32(4) && (jan1 != int32(3) || !(_is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year) != 0)) {
				val = int32(1)
			}
		}
	}
	return val
}

func x___strftime_fmt_1(tls *TLS, s uintptr, l uintptr, f int32, tm uintptr, loc Tlocale_t, pad int32) (r uintptr) {
	bp := tls.Alloc(24) /* tlsAllocs 0 maxValist 2 */
	defer tls.Free(24)
	var def_pad int32
	var fmt uintptr
	var item Tnl_item
	var val int64
	var width int32
	var v1 int32
	var v2 int32
	var v3 int32
	fmt = ts + 3662
	width = int32(2)
	def_pad = int32('0')
	switch f {
	case int32('a'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) > uint32(6) {
			goto string
		}
		item = int32(m_ABDAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		goto nl_strcat
	case int32('A'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) > uint32(6) {
			goto string
		}
		item = int32(m_DAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		goto nl_strcat
	case int32('h'):
		fallthrough
	case int32('b'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_mon) > uint32(11) {
			goto string
		}
		item = int32(m_ABMON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
		goto nl_strcat
	case int32('B'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_mon) > uint32(11) {
			goto string
		}
		item = int32(m_MON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
		goto nl_strcat
	case int32('c'):
		item = int32(m_D_T_FMT)
		goto nl_strftime
	case int32('C'):
		val = (int64(1900) + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year)) / int64(100)
		goto number
	case int32('e'):
		def_pad = int32('_')
		fallthrough
	case int32('d'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mday)
		goto number
	case int32('D'):
		fmt = ts + 3948
		goto recu_strftime
	case int32('F'):
		fmt = ts + 3957
		goto recu_strftime
	case int32('g'):
		fallthrough
	case int32('G'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_yday < int32(3) && _week_num(tls, tm) != int32(1) {
			val--
		} else {
			if (*Ttm)(unsafe.Pointer(tm)).Ftm_yday > int32(360) && _week_num(tls, tm) == int32(1) {
				val++
			}
		}
		if f == int32('g') {
			val = val % Int64FromInt32(100)
		} else {
			width = int32(4)
		}
		goto number
	case int32('H'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
		goto number
	case int32('I'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
		if !(val != 0) {
			val = int64(12)
		} else {
			if val > int64(12) {
				val = val - Int64FromInt32(12)
			}
		}
		goto number
	case int32('j'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_yday + int32(1))
		width = int32(3)
		goto number
	case int32('m'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mon + int32(1))
		goto number
	case int32('M'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_min)
		goto number
	case int32('n'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return ts + 572
	case int32('p'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_hour >= int32(12) {
			v1 = int32(m_PM_STR)
		} else {
			v1 = int32(m_AM_STR)
		}
		item = v1
		goto nl_strcat
	case int32('r'):
		item = int32(m_T_FMT_AMPM)
		goto nl_strftime
	case int32('R'):
		fmt = ts + 3966
		goto recu_strftime
	case int32('s'):
		val = x___tm_to_secs(tls, tm) - (*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff
		width = int32(1)
		goto number
	case int32('S'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_sec)
		goto number
	case int32('t'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return ts + 2513
	case int32('T'):
		fmt = ts + 3972
		goto recu_strftime
	case int32('u'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_wday != 0 {
			v2 = (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		} else {
			v2 = int32(7)
		}
		val = int64(v2)
		width = int32(1)
		goto number
	case int32('U'):
		val = int64((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)) / uint32(7))
		goto number
	case int32('W'):
		val = int64((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(6))%uint32(7)) / uint32(7))
		goto number
	case int32('V'):
		val = int64(_week_num(tls, tm))
		goto number
	case int32('w'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)
		width = int32(1)
		goto number
	case int32('x'):
		item = int32(m_D_FMT)
		goto nl_strftime
	case int32('X'):
		item = int32(m_T_FMT)
		goto nl_strftime
	case int32('y'):
		val = (int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)) % int64(100)
		if val < int64(0) {
			val = -val
		}
		goto number
	case int32('Y'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)
		if val >= int64(10000) {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(x_snprintf(tls, s, uint64(100), ts+3981, VaList(bp+8, val)))
			return s
		}
		width = int32(4)
		goto number
	case int32('z'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < int32(0) {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(0)
			return ts
		}
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(x_snprintf(tls, s, uint64(100), ts+3987, VaList(bp+8, (*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff/int64(3600)*int64(100)+(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff%int64(3600)/int64(60))))
		return s
	case int32('Z'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < int32(0) {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(0)
			return ts
		}
		fmt = x___tm_to_tzname(tls, tm)
		goto string
	case int32('%'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return ts + 637
	default:
		return uintptr(0)
	}
number:
	if pad != 0 {
		v3 = pad
	} else {
		v3 = def_pad
	}
	switch v3 {
	case int32('-'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(x_snprintf(tls, s, uint64(100), ts+3994, VaList(bp+8, val)))
	case int32('_'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(x_snprintf(tls, s, uint64(100), ts+3999, VaList(bp+8, width, val)))
	case int32('0'):
		fallthrough
	default:
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(x_snprintf(tls, s, uint64(100), ts+4005, VaList(bp+8, width, val)))
		break
	}
	return s
nl_strcat:
	fmt = x___nl_langinfo_l(tls, item, loc)
string:
	*(*Tsize_t)(unsafe.Pointer(l)) = x_strlen(tls, fmt)
	return fmt
nl_strftime:
	fmt = x___nl_langinfo_l(tls, item, loc)
recu_strftime:
	*(*Tsize_t)(unsafe.Pointer(l)) = x___strftime_l(tls, s, uint64(100), fmt, tm, loc)
	if !(*(*Tsize_t)(unsafe.Pointer(l)) != 0) {
		return uintptr(0)
	}
	return s
}

func x___strftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	bp := tls.Alloc(120) /* tlsAllocs 120 maxValist 0 */
	defer tls.Free(120)
	var d Tsize_t
	var l Tsize_t
	var pad int32
	var plus int32
	var t uintptr
	var width uint64
	var _ /* buf at bp+8 */ [100]int8
	var _ /* k at bp+0 */ Tsize_t
	var _ /* p at bp+112 */ uintptr
	var v1 Tsize_t
	var v2 uintptr
	var v3 int32
	var v5 Tsize_t
	var v6 int32
	var v7 bool
	var v8 Tsize_t
	var v9 Tsize_t
	for l = uint64(0); l < n; f++ {
		if !(*(*int8)(unsafe.Pointer(f)) != 0) {
			*(*int8)(unsafe.Pointer(s + uintptr(l))) = int8(0)
			return l
		}
		if int32(*(*int8)(unsafe.Pointer(f))) != int32('%') {
			v1 = l
			l++
			*(*int8)(unsafe.Pointer(s + uintptr(v1))) = *(*int8)(unsafe.Pointer(f))
			continue
		}
		f++
		pad = int32(0)
		if int32(*(*int8)(unsafe.Pointer(f))) == int32('-') || int32(*(*int8)(unsafe.Pointer(f))) == int32('_') || int32(*(*int8)(unsafe.Pointer(f))) == int32('0') {
			v2 = f
			f++
			pad = int32(*(*int8)(unsafe.Pointer(v2)))
		}
		v3 = BoolInt32(int32(*(*int8)(unsafe.Pointer(f))) == Int32FromUint8('+'))
		plus = v3
		if v3 != 0 {
			f++
		}
		width = x_strtoul(tls, f, bp+112, int32(10))
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('C') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('F') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('G') || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('Y') {
			if !(width != 0) && *(*uintptr)(unsafe.Pointer(bp + 112)) != f {
				width = uint64(1)
			}
		} else {
			width = uint64(0)
		}
		f = *(*uintptr)(unsafe.Pointer(bp + 112))
		if int32(*(*int8)(unsafe.Pointer(f))) == int32('E') || int32(*(*int8)(unsafe.Pointer(f))) == int32('O') {
			f++
		}
		t = x___strftime_fmt_1(tls, bp+8, bp, int32(*(*int8)(unsafe.Pointer(f))), tm, loc, pad)
		if !(t != 0) {
			break
		}
		if width != 0 {
			/* Trim off any sign and leading zeros, then
			 * count remaining digits to determine behavior
			 * for the + flag. */
			if int32(*(*int8)(unsafe.Pointer(t))) == int32('+') || int32(*(*int8)(unsafe.Pointer(t))) == int32('-') {
				t++
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			for int32(*(*int8)(unsafe.Pointer(t))) == int32('0') && uint32(int32(*(*int8)(unsafe.Pointer(t + UintptrFromInt32(1))))-int32('0')) < uint32(10) {
				goto _4
			_4:
				t++
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			if width < *(*Tsize_t)(unsafe.Pointer(bp)) {
				width = *(*Tsize_t)(unsafe.Pointer(bp))
			}
			for d = uint64(0); uint32(int32(*(*int8)(unsafe.Pointer(t + uintptr(d))))-int32('0')) < uint32(10); d++ {
			}
			if (*Ttm)(unsafe.Pointer(tm)).Ftm_year < -int32(1900) {
				v5 = l
				l++
				*(*int8)(unsafe.Pointer(s + uintptr(v5))) = int8('-')
				width--
			} else {
				if v7 = plus != 0; v7 {
					if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('C') {
						v6 = int32(3)
					} else {
						v6 = int32(5)
					}
				}
				if v7 && d+(width-*(*Tsize_t)(unsafe.Pointer(bp))) >= uint64(v6) {
					v8 = l
					l++
					*(*int8)(unsafe.Pointer(s + uintptr(v8))) = int8('+')
					width--
				}
			}
			for ; width > *(*Tsize_t)(unsafe.Pointer(bp)) && l < n; width-- {
				v9 = l
				l++
				*(*int8)(unsafe.Pointer(s + uintptr(v9))) = int8('0')
			}
		}
		if *(*Tsize_t)(unsafe.Pointer(bp)) > n-l {
			*(*Tsize_t)(unsafe.Pointer(bp)) = n - l
		}
		x_memcpy(tls, s+uintptr(l), t, *(*Tsize_t)(unsafe.Pointer(bp)))
		l = l + *(*Tsize_t)(unsafe.Pointer(bp))
	}
	if n != 0 {
		if l == n {
			l = n - uint64(1)
		}
		*(*int8)(unsafe.Pointer(s + uintptr(l))) = int8(0)
	}
	return uint64(0)
}

func x_strftime(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr) (r Tsize_t) {
	return x___strftime_l(tls, s, n, f, tm, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func x_strptime(tls *TLS, s uintptr, f uintptr, tm uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4012, int32(12), uintptr(unsafe.Pointer(&___func__80)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__80 = [9]int8{'s', 't', 'r', 'p', 't', 'i', 'm', 'e'}

func x_time(tls *TLS, t uintptr) (r Ttime_t) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	x___clock_gettime(tls, int32(m_CLOCK_REALTIME), bp)
	if t != 0 {
		*(*Ttime_t)(unsafe.Pointer(t)) = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	}
	return (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
}

func x_timegm(tls *TLS, tm uintptr) (r Ttime_t) {
	bp := tls.Alloc(56) /* tlsAllocs 56 maxValist 0 */
	defer tls.Free(56)
	var t int64
	var _ /* new at bp+0 */ Ttm1
	t = x___tm_to_secs(tls, tm)
	if x___secs_to_tm(tls, t, bp) < int32(0) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EOVERFLOW)
		return int64(-int32(1))
	}
	*(*Ttm1)(unsafe.Pointer(tm)) = *(*Ttm1)(unsafe.Pointer(bp))
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_isdst = int32(0)
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_gmtoff = int64(0)
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_zone = uintptr(unsafe.Pointer(&x___utc))
	return t
}

type Tksigevent = struct {
	Fsigev_value  Tsigval
	Fsigev_signo  int32
	Fsigev_notify int32
	Fsigev_tid    int32
	F__ccgo_pad4  [4]byte
}

type Tstart_args1 = struct {
	Fb   Tpthread_barrier_t
	Fsev uintptr
}

func _dummy_05(tls *TLS) {
}

func x_timer_create(tls *TLS, clk Tclockid_t, evp uintptr, res uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4032, int32(28), uintptr(unsafe.Pointer(&___func__81)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__81 = [13]int8{'t', 'i', 'm', 'e', 'r', '_', 'c', 'r', 'e', 'a', 't', 'e'}

func x_timer_delete(tls *TLS, t Ttimer_t) (r int32) {
	var td Tpthread_t
	if int64(t) < int64(0) {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		_a_store(tls, td+164, (*T__pthread)(unsafe.Pointer(td)).Ftimer_id|(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)))
		___syscall2(tls, int64(200), int64((*T__pthread)(unsafe.Pointer(td)).Ftid), int64(Int32FromInt32(32)))
		return int32(0)
	}
	return int32(___syscall1(tls, int64(226), int64(t)))
}

func x_timer_getoverrun(tls *TLS, t Ttimer_t) (r int32) {
	var td Tpthread_t
	if int64(t) < int64(0) {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64((*T__pthread)(unsafe.Pointer(td)).Ftimer_id & Int32FromInt32(m_INT_MAX)))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(225), int64(t)))))
}

func x_timer_gettime(tls *TLS, t Ttimer_t, val uintptr) (r int32) {
	var td Tpthread_t
	if int64(t) < int64(0) {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64((*T__pthread)(unsafe.Pointer(td)).Ftimer_id & Int32FromInt32(m_INT_MAX)))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(224), int64(t), int64(val)))))
}

func x_timer_settime(tls *TLS, t Ttimer_t, flags int32, val uintptr, old uintptr) (r int32) {
	var td Tpthread_t
	if int64(t) < int64(0) {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64((*T__pthread)(unsafe.Pointer(td)).Ftimer_id & Int32FromInt32(m_INT_MAX)))
	}
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(223), int64(t), int64(flags), int64(val), int64(old)))))
}

type Ttms = struct {
	Ftms_utime  Tclock_t
	Ftms_stime  Tclock_t
	Ftms_cutime Tclock_t
	Ftms_cstime Tclock_t
}

func x_times(tls *TLS, tms uintptr) (r Tclock_t) {
	return ___syscall1(tls, int64(100), int64(tms))
}

const m_TIME_UTC = 1

// C documentation
//
//	/* There is no other implemented value than TIME_UTC; all other values
//	 * are considered erroneous. */
func x_timespec_get(tls *TLS, ts uintptr, base int32) (r int32) {
	var ret int32
	var v1 int32
	if base != int32(m_TIME_UTC) {
		return int32(0)
	}
	ret = x___clock_gettime(tls, int32(m_CLOCK_REALTIME), ts)
	if ret < int32(0) {
		v1 = int32(0)
	} else {
		v1 = base
	}
	return v1
}

type Tutimbuf = struct {
	Factime  Ttime_t
	Fmodtime Ttime_t
}

func x_utime(tls *TLS, path uintptr, times uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4056, int32(9), uintptr(unsafe.Pointer(&___func__82)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__82 = [6]int8{'u', 't', 'i', 'm', 'e'}

func x___wcsftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	bp := tls.Alloc(520) /* tlsAllocs 520 maxValist 0 */
	defer tls.Free(520)
	var l Tsize_t
	var pad int32
	var plus int32
	var t uintptr
	var t_mb uintptr
	var width uint64
	var _ /* buf at bp+8 */ [100]int8
	var _ /* k at bp+0 */ Tsize_t
	var _ /* p at bp+512 */ uintptr
	var _ /* wbuf at bp+108 */ [100]Twchar_t
	var v1 Tsize_t
	var v2 uintptr
	var v3 int32
	var v5 Tsize_t
	var v6 Tsize_t
	var v7 Tsize_t
	for l = uint64(0); l < n; f += 4 {
		if !(*(*Twchar_t)(unsafe.Pointer(f)) != 0) {
			*(*Twchar_t)(unsafe.Pointer(s + uintptr(l)*4)) = int32(0)
			return l
		}
		if *(*Twchar_t)(unsafe.Pointer(f)) != int32('%') {
			v1 = l
			l++
			*(*Twchar_t)(unsafe.Pointer(s + uintptr(v1)*4)) = *(*Twchar_t)(unsafe.Pointer(f))
			continue
		}
		f += 4
		pad = int32(0)
		if *(*Twchar_t)(unsafe.Pointer(f)) == int32('-') || *(*Twchar_t)(unsafe.Pointer(f)) == int32('_') || *(*Twchar_t)(unsafe.Pointer(f)) == int32('0') {
			v2 = f
			f += 4
			pad = *(*Twchar_t)(unsafe.Pointer(v2))
		}
		v3 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(f)) == Int32FromUint8('+'))
		plus = v3
		if v3 != 0 {
			f += 4
		}
		width = x_wcstoul(tls, f, bp+512, int32(10))
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == int32('C') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == int32('F') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == int32('G') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == int32('Y') {
			if !(width != 0) && *(*uintptr)(unsafe.Pointer(bp + 512)) != f {
				width = uint64(1)
			}
		} else {
			width = uint64(0)
		}
		f = *(*uintptr)(unsafe.Pointer(bp + 512))
		if *(*Twchar_t)(unsafe.Pointer(f)) == int32('E') || *(*Twchar_t)(unsafe.Pointer(f)) == int32('O') {
			f += 4
		}
		t_mb = x___strftime_fmt_1(tls, bp+8, bp, *(*Twchar_t)(unsafe.Pointer(f)), tm, loc, pad)
		if !(t_mb != 0) {
			break
		}
		*(*Tsize_t)(unsafe.Pointer(bp)) = x_mbstowcs(tls, bp+108, t_mb, Uint64FromInt64(400)/Uint64FromInt64(4))
		if *(*Tsize_t)(unsafe.Pointer(bp)) == uint64(-Int32FromInt32(1)) {
			return uint64(0)
		}
		t = bp + 108
		if width != 0 {
			for *(*Twchar_t)(unsafe.Pointer(t)) == int32('+') || *(*Twchar_t)(unsafe.Pointer(t)) == int32('-') || *(*Twchar_t)(unsafe.Pointer(t)) == int32('0') && *(*Twchar_t)(unsafe.Pointer(t + UintptrFromInt32(1)*4)) != 0 {
				goto _4
			_4:
				t += 4
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			width--
			if plus != 0 && (*Ttm)(unsafe.Pointer(tm)).Ftm_year >= Int32FromInt32(10000)-Int32FromInt32(1900) {
				v5 = l
				l++
				*(*Twchar_t)(unsafe.Pointer(s + uintptr(v5)*4)) = int32('+')
			} else {
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_year < -int32(1900) {
					v6 = l
					l++
					*(*Twchar_t)(unsafe.Pointer(s + uintptr(v6)*4)) = int32('-')
				} else {
					width++
				}
			}
			for ; width > *(*Tsize_t)(unsafe.Pointer(bp)) && l < n; width-- {
				v7 = l
				l++
				*(*Twchar_t)(unsafe.Pointer(s + uintptr(v7)*4)) = int32('0')
			}
		}
		if *(*Tsize_t)(unsafe.Pointer(bp)) >= n-l {
			*(*Tsize_t)(unsafe.Pointer(bp)) = n - l
		}
		x_wmemcpy(tls, s+uintptr(l)*4, t, *(*Tsize_t)(unsafe.Pointer(bp)))
		l = l + *(*Tsize_t)(unsafe.Pointer(bp))
	}
	if n != 0 {
		if l == n {
			l = n - uint64(1)
		}
		*(*Twchar_t)(unsafe.Pointer(s + uintptr(l)*4)) = int32(0)
	}
	return uint64(0)
}

func x_wcsftime(tls *TLS, wcs uintptr, n Tsize_t, f uintptr, tm uintptr) (r Tsize_t) {
	return x___wcsftime_l(tls, wcs, n, f, tm, (*T__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func x__exit(tls *TLS, status int32) {
	x__Exit(tls, status)
}

func x_access(tls *TLS, filename uintptr, amode int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(21), int64(filename), int64(amode)))))
}

func x_acct(tls *TLS, filename uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(163), int64(filename)))))
}

const m_ITIMER_REAL = 0

func x_alarm(tls *TLS, seconds uint32) (r uint32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxValist 0 */
	defer tls.Free(64)
	var _ /* it at bp+0 */ Titimerval
	var _ /* old at bp+32 */ Titimerval
	*(*Titimerval)(unsafe.Pointer(bp)) = Titimerval{Fit_value: Ttimeval{Ftv_sec: int64(seconds)}}
	*(*Titimerval)(unsafe.Pointer(bp + 32)) = Titimerval{}
	x_setitimer(tls, int32(m_ITIMER_REAL), bp, bp+32)
	return uint32((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_sec + BoolInt64(!!((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_usec != 0)))
}

func x_chdir(tls *TLS, path uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(80), int64(path)))))
}

func x_chown(tls *TLS, path uintptr, uid Tuid_t, gid Tgid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(92), int64(path), int64(uid), int64(gid)))))
}

func _dummy22(tls *TLS, fd int32) (r int32) {
	return fd
}

func x_close(tls *TLS, fd int32) (r1 int32) {
	var r int32
	fd = x___aio_close(tls, fd)
	r = int32(x___syscall_cp(tls, int64(3), int64(fd), int64(0), int64(0), int64(0), int64(0), int64(0)))
	if r == -int32(m_EINTR) {
		r = int32(0)
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x_ctermid(tls *TLS, s uintptr) (r uintptr) {
	var v1 uintptr
	if s != 0 {
		v1 = x_strcpy(tls, s, ts+563)
	} else {
		v1 = ts + 563
	}
	return v1
}

func x_dup(tls *TLS, fd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(32), int64(fd)))))
}

func x_dup2(tls *TLS, old int32, new1 int32) (r1 int32) {
	var r int32
	var v1 int32
	for {
		v1 = int32(___syscall2(tls, int64(33), int64(old), int64(new1)))
		r = v1
		if !(v1 == -int32(m_EBUSY)) {
			break
		}
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

func x___dup3(tls *TLS, old int32, new1 int32, flags int32) (r1 int32) {
	var r int32
	var v1 int32
	var v2 int32
	if old == new1 {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	if flags != 0 {
		for {
			v1 = int32(___syscall3(tls, int64(292), int64(old), int64(new1), int64(flags)))
			r = v1
			if !(v1 == -int32(m_EBUSY)) {
				break
			}
		}
		if r != -int32(m_ENOSYS) {
			return int32(x___syscall_ret(tls, uint64(r)))
		}
		if flags & ^Int32FromInt32(m_O_CLOEXEC) != 0 {
			return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
		}
	}
	for {
		v2 = int32(___syscall2(tls, int64(33), int64(old), int64(new1)))
		r = v2
		if !(v2 == -int32(m_EBUSY)) {
			break
		}
	}
	if r >= int32(0) && flags&int32(m_O_CLOEXEC) != 0 {
		___syscall3(tls, int64(72), int64(new1), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	return int32(x___syscall_ret(tls, uint64(r)))
}

type Tctx2 = struct {
	Ffd       int32
	Ffilename uintptr
	Famode    int32
	Fp        int32
}

func _checker(tls *TLS, p uintptr) (r int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var c uintptr
	var _ /* ret at bp+0 */ int32
	c = p
	if ___syscall2(tls, int64(114), ___syscall0(tls, int64(108)), int64(-Int32FromInt32(1))) != 0 || ___syscall2(tls, int64(113), ___syscall0(tls, int64(107)), int64(-Int32FromInt32(1))) != 0 {
		___syscall1(tls, int64(60), int64(Int32FromInt32(1)))
	}
	*(*int32)(unsafe.Pointer(bp)) = int32(___syscall4(tls, int64(269), int64((*Tctx2)(unsafe.Pointer(c)).Ffd), int64((*Tctx2)(unsafe.Pointer(c)).Ffilename), int64((*Tctx2)(unsafe.Pointer(c)).Famode), int64(Int32FromInt32(0))))
	___syscall3(tls, int64(1), int64((*Tctx2)(unsafe.Pointer(c)).Fp), int64(bp), int64(Uint64FromInt64(4)))
	return int32(0)
}

func x_faccessat(tls *TLS, fd int32, filename uintptr, amode int32, flag int32) (r int32) {
	bp := tls.Alloc(1192) /* tlsAllocs 1192 maxValist 0 */
	defer tls.Free(1192)
	var pid Tpid_t
	var ret int32
	var _ /* c at bp+1168 */ Tctx2
	var _ /* p at bp+1160 */ [2]int32
	var _ /* ret at bp+1156 */ int32
	var _ /* set at bp+1024 */ Tsigset_t
	var _ /* stack at bp+0 */ [1024]int8
	var _ /* status at bp+1152 */ int32
	if flag != 0 {
		ret = int32(___syscall4(tls, int64(439), int64(fd), int64(filename), int64(amode), int64(flag)))
		if ret != -int32(m_ENOSYS) {
			return int32(x___syscall_ret(tls, uint64(ret)))
		}
	}
	if flag & ^Int32FromInt32(m_AT_EACCESS) != 0 {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	if !(flag != 0) || x_getuid(tls) == x_geteuid(tls) && x_getgid(tls) == x_getegid(tls) {
		return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(269), int64(fd), int64(filename), int64(amode)))))
	}
	if x_pipe2(tls, bp+1160, int32(m_O_CLOEXEC)) != 0 {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EBUSY))))
	}
	*(*Tctx2)(unsafe.Pointer(bp + 1168)) = Tctx2{Ffd: fd, Ffilename: filename, Famode: amode, Fp: (*(*[2]int32)(unsafe.Pointer(bp + 1160)))[int32(1)]}
	x___block_all_sigs(tls, bp+1024)
	pid = ___clone(tls, __ccgo_fp(_checker), bp+uintptr(1024), int32(0), bp+1168, 0)
	___syscall1(tls, int64(3), int64((*(*[2]int32)(unsafe.Pointer(bp + 1160)))[int32(1)]))
	if pid < int32(0) || uint64(___syscall3(tls, int64(0), int64((*(*[2]int32)(unsafe.Pointer(bp + 1160)))[int32(0)]), int64(bp+1156), int64(Uint64FromInt64(4)))) != uint64(4) {
		*(*int32)(unsafe.Pointer(bp + 1156)) = -int32(m_EBUSY)
	}
	___syscall1(tls, int64(3), int64((*(*[2]int32)(unsafe.Pointer(bp + 1160)))[int32(0)]))
	___syscall4(tls, int64(61), int64(pid), int64(bp+1152), int64(Uint32FromUint32(0x80000000)), int64(Int32FromInt32(0)))
	x___restore_sigs(tls, bp+1024)
	return int32(x___syscall_ret(tls, uint64(*(*int32)(unsafe.Pointer(bp + 1156)))))
}

func x_fchdir(tls *TLS, fd int32) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]int8
	ret = int32(___syscall1(tls, int64(81), int64(fd)))
	if ret != -int32(m_EBADF) || ___syscall2(tls, int64(72), int64(fd), int64(Int32FromInt32(1))) < int64(0) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	x___procfdname(tls, bp, uint32(fd))
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(80), int64(bp)))))
}

func x_fchown(tls *TLS, fd int32, uid Tuid_t, gid Tgid_t) (r int32) {
	bp := tls.Alloc(32) /* tlsAllocs 32 maxValist 0 */
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]int8
	ret = int32(___syscall3(tls, int64(93), int64(fd), int64(uid), int64(gid)))
	if ret != -int32(m_EBADF) || ___syscall2(tls, int64(72), int64(fd), int64(Int32FromInt32(1))) < int64(0) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	x___procfdname(tls, bp, uint32(fd))
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(92), int64(bp), int64(uid), int64(gid)))))
}

func x_fchownat(tls *TLS, fd int32, path uintptr, uid Tuid_t, gid Tgid_t, flag int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(260), int64(fd), int64(path), int64(uid), int64(gid), int64(flag)))))
}

func x_fdatasync(tls *TLS, fd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(75), int64(fd), int64(0), int64(0), int64(0), int64(0), int64(0)))))
}

func x_fsync(tls *TLS, fd int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(74), int64(fd), int64(0), int64(0), int64(0), int64(0), int64(0)))))
}

func x_ftruncate(tls *TLS, fd int32, length Toff_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(77), int64(fd), length))))
}

func x_getcwd(tls *TLS, buf uintptr, size Tsize_t) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4073, int32(10), uintptr(unsafe.Pointer(&___func__83)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__83 = [7]int8{'g', 'e', 't', 'c', 'w', 'd'}

func x_getegid(tls *TLS) (r Tgid_t) {
	return uint32(___syscall0(tls, int64(108)))
}

func x_geteuid(tls *TLS) (r Tuid_t) {
	return uint32(___syscall0(tls, int64(107)))
}

func x_getgid(tls *TLS) (r Tgid_t) {
	return uint32(___syscall0(tls, int64(104)))
}

func x_getgroups(tls *TLS, count int32, list uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(115), int64(count), int64(list)))))
}

func x_gethostname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	bp := tls.Alloc(392) /* tlsAllocs 392 maxValist 0 */
	defer tls.Free(392)
	var i Tsize_t
	var _ /* uts at bp+0 */ Tutsname1
	var v1 int8
	var v2 bool
	if x_uname(tls, bp) != 0 {
		return -int32(1)
	}
	if len1 > uint64(65) {
		len1 = uint64(65)
	}
	for i = uint64(0); ; i++ {
		if v2 = i < len1; v2 {
			v1 = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*Tutsname1)(unsafe.Pointer(bp))).Fnodename)) + uintptr(i)))
			*(*int8)(unsafe.Pointer(name + uintptr(i))) = v1
		}
		if !(v2 && v1 != 0) {
			break
		}
	}
	if i != 0 && i == len1 {
		*(*int8)(unsafe.Pointer(name + uintptr(i-Uint64FromInt32(1)))) = int8(0)
	}
	return int32(0)
}

func x_getlogin(tls *TLS) (r uintptr) {
	return x_getenv(tls, ts+4093)
}

func x_getlogin_r(tls *TLS, name uintptr, size Tsize_t) (r int32) {
	var logname uintptr
	logname = x_getlogin(tls)
	if !(logname != 0) {
		return int32(m_ENXIO)
	} /* or...? */
	if x_strlen(tls, logname) >= size {
		return int32(m_ERANGE)
	}
	x_strcpy(tls, name, logname)
	return int32(0)
}

func x_getpgid(tls *TLS, pid Tpid_t) (r Tpid_t) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(121), int64(pid)))))
}

func x_getpgrp(tls *TLS) (r Tpid_t) {
	return int32(___syscall1(tls, int64(121), int64(Int32FromInt32(0))))
}

func x_getpid(tls *TLS) (r Tpid_t) {
	return int32(___syscall0(tls, int64(39)))
}

func x_getppid(tls *TLS) (r Tpid_t) {
	return int32(___syscall0(tls, int64(110)))
}

func x_getsid(tls *TLS, pid Tpid_t) (r Tpid_t) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(124), int64(pid)))))
}

func x_getuid(tls *TLS) (r Tuid_t) {
	return uint32(___syscall0(tls, int64(102)))
}

func x_isatty(tls *TLS, fd int32) (r1 int32) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r uint64
	var _ /* wsz at bp+0 */ Twinsize
	r = uint64(x___syscall_ret(tls, uint64(___syscall3(tls, int64(16), int64(fd), int64(Int32FromInt32(0x5413)), int64(bp)))))
	if r == uint64(0) {
		return int32(1)
	}
	if *(*int32)(unsafe.Pointer(x___errno_location(tls))) != int32(m_EBADF) {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_ENOTTY)
	}
	return int32(0)
}

func x_lchown(tls *TLS, path uintptr, uid Tuid_t, gid Tgid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(94), int64(path), int64(uid), int64(gid)))))
}

func x_link(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(86), int64(existing), int64(new1)))))
}

func x_linkat(tls *TLS, fd1 int32, existing uintptr, fd2 int32, new1 uintptr, flag int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall5(tls, int64(265), int64(fd1), int64(existing), int64(fd2), int64(new1), int64(flag)))))
}

func x___lseek(tls *TLS, fd int32, offset Toff_t, whence int32) (r Toff_t) {
	return x___syscall_ret(tls, uint64(___syscall3(tls, int64(8), int64(fd), offset, int64(whence))))
}

const m_PRIO_PROCESS = 0

func x_nice(tls *TLS, inc int32) (r int32) {
	var prio int32
	prio = inc
	// Only query old priority if it can affect the result.
	// This also avoids issues with integer overflow.
	if inc > -Int32FromInt32(2)*Int32FromInt32(m_NZERO) && inc < Int32FromInt32(2)*Int32FromInt32(m_NZERO) {
		prio = prio + x_getpriority(tls, int32(m_PRIO_PROCESS), uint32(0))
	}
	if prio > Int32FromInt32(m_NZERO)-Int32FromInt32(1) {
		prio = Int32FromInt32(m_NZERO) - Int32FromInt32(1)
	}
	if prio < -int32(m_NZERO) {
		prio = -int32(m_NZERO)
	}
	if x_setpriority(tls, int32(m_PRIO_PROCESS), uint32(0), prio) != 0 {
		if *(*int32)(unsafe.Pointer(x___errno_location(tls))) == int32(m_EACCES) {
			*(*int32)(unsafe.Pointer(x___errno_location(tls))) = int32(m_EPERM)
		}
		return -int32(1)
	} else {
		return prio
	}
	return r
}

func x_pause(tls *TLS) (r int32) {
	return int32(x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(34), int64(0), int64(0), int64(0), int64(0), int64(0), int64(0)))))
}

func x_pipe(tls *TLS, fd uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(22), int64(fd)))))
}

func x_pipe2(tls *TLS, fd uintptr, flag int32) (r int32) {
	var ret int32
	if !(flag != 0) {
		return x_pipe(tls, fd)
	}
	ret = int32(___syscall2(tls, int64(293), int64(fd), int64(flag)))
	if ret != -int32(m_ENOSYS) {
		return int32(x___syscall_ret(tls, uint64(ret)))
	}
	if flag & ^(Int32FromInt32(m_O_CLOEXEC)|Int32FromInt32(m_O_NONBLOCK)) != 0 {
		return int32(x___syscall_ret(tls, uint64(-Int32FromInt32(m_EINVAL))))
	}
	ret = x_pipe(tls, fd)
	if ret != 0 {
		return ret
	}
	if flag&int32(m_O_CLOEXEC) != 0 {
		___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(0)*4))), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
		___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(1)*4))), int64(Int32FromInt32(2)), int64(Int32FromInt32(1)))
	}
	if flag&int32(m_O_NONBLOCK) != 0 {
		___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(0)*4))), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
		___syscall3(tls, int64(72), int64(*(*int32)(unsafe.Pointer(fd + UintptrFromInt32(1)*4))), int64(Int32FromInt32(4)), int64(Int32FromInt32(04000)))
	}
	return int32(0)
}

func x_posix_close(tls *TLS, fd int32, flags int32) (r int32) {
	return x_close(tls, fd)
}

func x_pread(tls *TLS, fd int32, buf uintptr, size Tsize_t, ofs Toff_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(17), int64(fd), int64(buf), int64(size), ofs, int64(0), int64(0))))
}

func x_preadv(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(295), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), int64(0))))
}

func x_pwrite(tls *TLS, fd int32, buf uintptr, size Tsize_t, ofs Toff_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(18), int64(fd), int64(buf), int64(size), ofs, int64(0), int64(0))))
}

func x_pwritev(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(296), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), int64(0))))
}

func x_read(tls *TLS, fd int32, buf uintptr, count Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(0), int64(fd), int64(buf), int64(count), int64(0), int64(0), int64(0))))
}

func x_readlink(tls *TLS, path uintptr, buf uintptr, bufsize Tsize_t) (r1 Tssize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r int32
	var _ /* dummy at bp+0 */ [1]int8
	if !(bufsize != 0) {
		buf = bp
		bufsize = uint64(1)
	}
	r = int32(___syscall3(tls, int64(89), int64(path), int64(buf), int64(bufsize)))
	if buf == bp && r > int32(0) {
		r = int32(0)
	}
	return x___syscall_ret(tls, uint64(r))
}

func x_readlinkat(tls *TLS, fd int32, path uintptr, buf uintptr, bufsize Tsize_t) (r1 Tssize_t) {
	bp := tls.Alloc(8) /* tlsAllocs 8 maxValist 0 */
	defer tls.Free(8)
	var r int32
	var _ /* dummy at bp+0 */ [1]int8
	if !(bufsize != 0) {
		buf = bp
		bufsize = uint64(1)
	}
	r = int32(___syscall4(tls, int64(267), int64(fd), int64(path), int64(buf), int64(bufsize)))
	if buf == bp && r > int32(0) {
		r = int32(0)
	}
	return x___syscall_ret(tls, uint64(r))
}

func x_readv(tls *TLS, fd int32, iov uintptr, count int32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(19), int64(fd), int64(iov), int64(count), int64(0), int64(0), int64(0))))
}

func x_renameat(tls *TLS, oldfd int32, old uintptr, newfd int32, new1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall4(tls, int64(264), int64(oldfd), int64(old), int64(newfd), int64(new1)))))
}

func x_rmdir(tls *TLS, path uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(84), int64(path)))))
}

const m_SYS_setresgid = 119

func x_setegid(tls *TLS, egid Tgid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setresgid), -int32(1), int32(egid), -int32(1))
}

const m_SYS_setresuid = 117

func x_seteuid(tls *TLS, euid Tuid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setresuid), -int32(1), int32(euid), -int32(1))
}

const m_SYS_setgid = 106

func x_setgid(tls *TLS, gid Tgid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setgid), int32(gid), int32(0), int32(0))
}

func x_setpgid(tls *TLS, pid Tpid_t, pgid Tpid_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(109), int64(pid), int64(pgid)))))
}

func x_setpgrp(tls *TLS) (r Tpid_t) {
	return x_setpgid(tls, int32(0), int32(0))
}

const m_SYS_setregid = 114

func x_setregid(tls *TLS, rgid Tgid_t, egid Tgid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setregid), int32(rgid), int32(egid), int32(0))
}

func x_setresgid(tls *TLS, rgid Tgid_t, egid Tgid_t, sgid Tgid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setresgid), int32(rgid), int32(egid), int32(sgid))
}

func x_setresuid(tls *TLS, ruid Tuid_t, euid Tuid_t, suid Tuid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setresuid), int32(ruid), int32(euid), int32(suid))
}

const m_SYS_setreuid = 113

func x_setreuid(tls *TLS, ruid Tuid_t, euid Tuid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setreuid), int32(ruid), int32(euid), int32(0))
}

func x_setsid(tls *TLS) (r Tpid_t) {
	return int32(x___syscall_ret(tls, uint64(___syscall0(tls, int64(112)))))
}

const m_SYS_setuid = 105

func x_setuid(tls *TLS, uid Tuid_t) (r int32) {
	return x___setxid(tls, int32(m_SYS_setuid), int32(uid), int32(0), int32(0))
}

type Tctx3 = struct {
	Fid  int32
	Feid int32
	Fsid int32
	Fnr  int32
	Fret int32
}

func _do_setxid(tls *TLS, p uintptr) {
	var c uintptr
	var ret int32
	c = p
	if (*Tctx3)(unsafe.Pointer(c)).Fret < int32(0) {
		return
	}
	ret = int32(___syscall3(tls, int64((*Tctx3)(unsafe.Pointer(c)).Fnr), int64((*Tctx3)(unsafe.Pointer(c)).Fid), int64((*Tctx3)(unsafe.Pointer(c)).Feid), int64((*Tctx3)(unsafe.Pointer(c)).Fsid)))
	if ret != 0 && !((*Tctx3)(unsafe.Pointer(c)).Fret != 0) {
		/* If one thread fails to set ids after another has already
		 * succeeded, forcibly killing the process is the only safe
		 * thing to do. State is inconsistent and dangerous. Use
		 * SIGKILL because it is uncatchable. */
		x___block_all_sigs(tls, uintptr(0))
		___syscall2(tls, int64(62), ___syscall0(tls, int64(39)), int64(Int32FromInt32(9)))
	}
	(*Tctx3)(unsafe.Pointer(c)).Fret = ret
}

func x___setxid(tls *TLS, nr int32, id int32, eid int32, sid int32) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 24 maxValist 0 */
	defer tls.Free(24)
	var _ /* c at bp+0 */ Tctx3
	/* ret is initially nonzero so that failure of the first thread does not
	 * trigger the safety kill above. */
	*(*Tctx3)(unsafe.Pointer(bp)) = Tctx3{Fid: id, Feid: eid, Fsid: sid, Fnr: nr, Fret: int32(1)}
	x___synccall(tls, __ccgo_fp(_do_setxid), bp)
	return int32(x___syscall_ret(tls, uint64((*(*Tctx3)(unsafe.Pointer(bp))).Fret)))
}

func x_sleep(tls *TLS, seconds uint32) (r uint32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{Ftv_sec: int64(seconds), Ftv_nsec: int64(0)}
	if x_nanosleep(tls, bp, bp) != 0 {
		return uint32((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec)
	}
	return uint32(0)
}

func x_symlink(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(88), int64(existing), int64(new1)))))
}

func x_symlinkat(tls *TLS, existing uintptr, fd int32, new1 uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(266), int64(existing), int64(fd), int64(new1)))))
}

func x_sync(tls *TLS) {
	___syscall0(tls, int64(162))
}

const m_TIOCGPGRP = 21519

func x_tcgetpgrp(tls *TLS, fd int32) (r Tpid_t) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var _ /* pgrp at bp+0 */ int32
	if x_ioctl(tls, fd, int32(m_TIOCGPGRP), VaList(bp+16, bp)) < int32(0) {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

const m_TIOCSPGRP = 21520

func x_tcsetpgrp(tls *TLS, fd int32, pgrp Tpid_t) (r int32) {
	bp := tls.Alloc(24) /* tlsAllocs 8 maxValist 1 */
	defer tls.Free(24)
	var _ /* pgrp_int at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = pgrp
	return x_ioctl(tls, fd, int32(m_TIOCSPGRP), VaList(bp+16, bp))
}

func x_truncate(tls *TLS, path uintptr, length Toff_t) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall2(tls, int64(76), int64(path), length))))
}

func x_ttyname(tls *TLS, fd int32) (r uintptr) {
	var result int32
	var v1 int32
	v1 = x_ttyname_r(tls, fd, uintptr(unsafe.Pointer(&_buf11)), uint64(32))
	result = v1
	if v1 != 0 {
		*(*int32)(unsafe.Pointer(x___errno_location(tls))) = result
		return UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&_buf11))
}

var _buf11 [32]int8

func x_ttyname_r(tls *TLS, fd int32, name uintptr, size Tsize_t) (r int32) {
	bp := tls.Alloc(320) /* tlsAllocs 320 maxValist 0 */
	defer tls.Free(320)
	var l Tssize_t
	var _ /* procname at bp+288 */ [29]int8
	var _ /* st1 at bp+0 */ Tstat
	var _ /* st2 at bp+144 */ Tstat
	if !(x_isatty(tls, fd) != 0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	x___procfdname(tls, bp+288, uint32(fd))
	l = x_readlink(tls, bp+288, name, size)
	if l < int64(0) {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	} else {
		if uint64(l) == size {
			return int32(m_ERANGE)
		}
	}
	*(*int8)(unsafe.Pointer(name + uintptr(l))) = int8(0)
	if x_stat(tls, name, bp) != 0 || x___fstat(tls, fd, bp+144) != 0 {
		return *(*int32)(unsafe.Pointer(x___errno_location(tls)))
	}
	if (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev != (*(*Tstat)(unsafe.Pointer(bp + 144))).Fst_dev || (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino != (*(*Tstat)(unsafe.Pointer(bp + 144))).Fst_ino {
		return int32(m_ENODEV)
	}
	return int32(0)
}

func x_ualarm(tls *TLS, value uint32, interval uint32) (r uint32) {
	bp := tls.Alloc(64) /* tlsAllocs 64 maxValist 0 */
	defer tls.Free(64)
	var _ /* it at bp+0 */ Titimerval
	var _ /* it_old at bp+32 */ Titimerval
	*(*Titimerval)(unsafe.Pointer(bp)) = Titimerval{Fit_interval: Ttimeval{Ftv_usec: int64(interval)}, Fit_value: Ttimeval{Ftv_usec: int64(value)}}
	x_setitimer(tls, int32(m_ITIMER_REAL), bp, bp+32)
	return uint32((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_sec*int64(1000000) + (*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_usec)
}

func x_unlink(tls *TLS, path uintptr) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall1(tls, int64(87), int64(path)))))
}

func x_unlinkat(tls *TLS, fd int32, path uintptr, flag int32) (r int32) {
	return int32(x___syscall_ret(tls, uint64(___syscall3(tls, int64(263), int64(fd), int64(path), int64(flag)))))
}

func x_usleep(tls *TLS, useconds uint32) (r int32) {
	bp := tls.Alloc(16) /* tlsAllocs 16 maxValist 0 */
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{Ftv_sec: int64(useconds / uint32(1000000)), Ftv_nsec: int64(useconds % uint32(1000000) * uint32(1000))}
	return x_nanosleep(tls, bp, bp)
}

func x_write(tls *TLS, fd int32, buf uintptr, count Tsize_t) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(1), int64(fd), int64(buf), int64(count), int64(0), int64(0), int64(0))))
}

func x_writev(tls *TLS, fd int32, iov uintptr, count int32) (r Tssize_t) {
	return x___syscall_ret(tls, uint64(x___syscall_cp(tls, int64(20), int64(fd), int64(iov), int64(count), int64(0), int64(0), int64(0))))
}

const m_AT_BASE = 7
const m_AUX_CNT1 = 32
const m_DT_MIPS_LOCAL_GOTNO = 1879048202
const m_DT_PLTGOT = 3
const m_DT_REL = 17
const m_DT_RELA = 7
const m_DT_RELASZ = 8
const m_DT_RELR = 36
const m_DT_RELRSZ = 35
const m_DT_RELSZ = 18
const m_DYN_CNT = 37
const m_NEED_MIPS_GOT_RELOCS = 0
const m_R_X86_64_RELATIVE = 8

func x__dlstart_c(tls *TLS, sp uintptr, dynv uintptr) {
	var argc int32
	var argv uintptr
	var aux [32]Tsize_t
	var auxv uintptr
	var base Tsize_t
	var bitmap Tsize_t
	var dls2 Tstage2_func
	var dyn [37]Tsize_t
	var got uintptr
	var i Tsize_t
	var i1 Tsize_t
	var local_cnt Tsize_t
	var ph uintptr
	var phentsize Tsize_t
	var phnum Tsize_t
	var rel uintptr
	var rel_addr uintptr
	var rel_addr1 uintptr
	var rel_size Tsize_t
	var relr_addr uintptr
	var v11 uintptr
	var v3 Tsize_t
	var p10 uintptr
	var p12 uintptr
	var p5 uintptr
	var p7 uintptr
	argc = int32(*(*Tsize_t)(unsafe.Pointer(sp)))
	argv = sp + UintptrFromInt32(1)*8
	for i = uint64(argc + int32(1)); *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0; i++ {
	}
	auxv = argv + uintptr(i)*8 + UintptrFromInt32(1)*8
	for i = uint64(0); i < uint64(m_AUX_CNT1); i++ {
		aux[i] = uint64(0)
	}
	for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8)) != 0; {
		if *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8)) < uint64(m_AUX_CNT1) {
			aux[*(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i)*8))] = *(*Tsize_t)(unsafe.Pointer(auxv + uintptr(i+Uint64FromInt32(1))*8))
		}
		goto _1
	_1:
		i = i + Uint64FromInt32(2)
	}
	for i = uint64(0); i < uint64(m_DYN_CNT); i++ {
		dyn[i] = uint64(0)
	}
	for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) != 0; {
		if *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) < uint64(m_DYN_CNT) {
			dyn[*(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8))] = *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i+Uint64FromInt32(1))*8))
		}
		goto _2
	_2:
		i = i + Uint64FromInt32(2)
	}
	/* If the dynamic linker is invoked as a command, its load
	 * address is not available in the aux vector. Instead, compute
	 * the load address as the difference between &_DYNAMIC and the
	 * virtual address in the PT_DYNAMIC program header. */
	base = aux[int32(m_AT_BASE)]
	if !(base != 0) {
		phnum = aux[int32(m_AT_PHNUM)]
		phentsize = aux[int32(m_AT_PHENT)]
		ph = uintptr(aux[int32(m_AT_PHDR)])
		for i = phnum; ; ph = ph + uintptr(phentsize) {
			v3 = i
			i--
			if !(v3 != 0) {
				break
			}
			if (*TPhdr)(unsafe.Pointer(ph)).Fp_type == uint32(m_PT_DYNAMIC) {
				base = uint64(dynv) - (*TPhdr)(unsafe.Pointer(ph)).Fp_vaddr
				break
			}
		}
	}
	/* MIPS uses an ugly packed form for GOT relocations. Since we
	 * can't make function calls yet and the code is tiny anyway,
	 * it's simply inlined here. */
	if int32(m_NEED_MIPS_GOT_RELOCS) != 0 {
		local_cnt = uint64(0)
		got = uintptr(base + dyn[int32(m_DT_PLTGOT)])
		for i = uint64(0); *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) != 0; {
			if *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i)*8)) == uint64(m_DT_MIPS_LOCAL_GOTNO) {
				local_cnt = *(*Tsize_t)(unsafe.Pointer(dynv + uintptr(i+Uint64FromInt32(1))*8))
			}
			goto _4
		_4:
			i = i + Uint64FromInt32(2)
		}
		for i = uint64(0); i < local_cnt; i++ {
			p5 = got + uintptr(i)*8
			*(*Tsize_t)(unsafe.Pointer(p5)) = *(*Tsize_t)(unsafe.Pointer(p5)) + base
		}
	}
	rel = uintptr(base + dyn[int32(m_DT_REL)])
	rel_size = dyn[int32(m_DT_RELSZ)]
	for rel_size != 0 {
		if !(*(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))&uint64(0x7fffffff) == uint64(m_R_X86_64_RELATIVE) || *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))&uint64(0x7fffffff) == Uint64FromInt32(_REL_SYM_OR_REL) && !(*(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))>>Int32FromInt32(32) != 0)) {
			goto _6
		}
		rel_addr = uintptr(base + *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(0)*8)))
		p7 = rel_addr
		*(*Tsize_t)(unsafe.Pointer(p7)) = *(*Tsize_t)(unsafe.Pointer(p7)) + base
		goto _6
	_6:
		rel = rel + UintptrFromInt32(2)*8
		rel_size = rel_size - Uint64FromInt32(2)*Uint64FromInt64(8)
	}
	rel = uintptr(base + dyn[int32(m_DT_RELA)])
	rel_size = dyn[int32(m_DT_RELASZ)]
	for rel_size != 0 {
		if !(*(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))&uint64(0x7fffffff) == uint64(m_R_X86_64_RELATIVE) || *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))&uint64(0x7fffffff) == Uint64FromInt32(_REL_SYM_OR_REL) && !(*(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(1)*8))>>Int32FromInt32(32) != 0)) {
			goto _8
		}
		rel_addr1 = uintptr(base + *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(0)*8)))
		*(*Tsize_t)(unsafe.Pointer(rel_addr1)) = base + *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(2)*8))
		goto _8
	_8:
		rel = rel + UintptrFromInt32(3)*8
		rel_size = rel_size - Uint64FromInt32(3)*Uint64FromInt64(8)
	}
	rel = uintptr(base + dyn[int32(m_DT_RELR)])
	rel_size = dyn[int32(m_DT_RELRSZ)]
	relr_addr = uintptr(0)
	for rel_size != 0 {
		if *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(0)*8))&uint64(1) == uint64(0) {
			relr_addr = uintptr(base + *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(0)*8)))
			v11 = relr_addr
			relr_addr += 8
			p10 = v11
			*(*Tsize_t)(unsafe.Pointer(p10)) = *(*Tsize_t)(unsafe.Pointer(p10)) + base
		} else {
			i1 = uint64(0)
			bitmap = *(*Tsize_t)(unsafe.Pointer(rel + UintptrFromInt32(0)*8))
			for ; ; i1++ {
				bitmap = bitmap >> Uint64FromInt32(1)
				if !(bitmap != 0) {
					break
				}
				if bitmap&uint64(1) != 0 {
					p12 = relr_addr + uintptr(i1)*8
					*(*Tsize_t)(unsafe.Pointer(p12)) = *(*Tsize_t)(unsafe.Pointer(p12)) + base
				}
			}
			relr_addr = relr_addr + uintptr(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1))*8
		}
		goto _9
	_9:
		rel += 8
		rel_size = rel_size - Uint64FromInt64(8)
	}
	// __asm__ ( 	  	 ".hidden __dls2\n	lea __dls2(%%rip),%0\n" 	: "=r"(*&dls2) : : "memory" );
	___assert_fail(tls, ts+240, ts+4101, 161, ts+4111)
	(*(*func(*TLS, uintptr, uintptr))(unsafe.Pointer(&struct{ uintptr }{dls2})))(tls, uintptr(base), sp)
}

type Tdebug = struct {
	Fver   int32
	Fhead  uintptr
	Fbp    uintptr
	Fstate int32
	Fbase  uintptr
}

type Ttd_index = struct {
	Fargs [2]Tsize_t
	Fnext uintptr
}

type Tdso = struct {
	Fbase           uintptr
	Fname           uintptr
	Fdynv           uintptr
	Fnext           uintptr
	Fprev           uintptr
	Fphdr           uintptr
	Fphnum          int32
	Fphentsize      Tsize_t
	Fsyms           uintptr
	Fhashtab        uintptr
	Fghashtab       uintptr
	Fversym         uintptr
	Fstrings        uintptr
	Fsyms_next      uintptr
	Flazy_next      uintptr
	Flazy           uintptr
	Flazy_cnt       Tsize_t
	Fmap1           uintptr
	Fmap_len        Tsize_t
	Fdev            Tdev_t
	Fino            Tino_t
	Frelocated      int8
	Fconstructed    int8
	Fkernel_mapped  int8
	Fmark           int8
	Fbfs_built      int8
	Fruntime_loaded int8
	Fdeps           uintptr
	Fneeded_by      uintptr
	Fndeps_direct   Tsize_t
	Fnext_dep       Tsize_t
	Fctor_visitor   Tpthread_t
	Frpath_orig     uintptr
	Frpath          uintptr
	Ftls            Ttls_module
	Ftls_id         Tsize_t
	Frelro_start    Tsize_t
	Frelro_end      Tsize_t
	Fnew_dtv        uintptr
	Fnew_tls        uintptr
	Ftd_index       uintptr
	Ffini_next      uintptr
	Fshortname      uintptr
	Floadmap        uintptr
	Ffuncdescs      uintptr
	Fgot            uintptr
}

type Tsymdef = struct {
	Fsym uintptr
	Fdso uintptr
}

type Tstage3_func = uintptr

var _debug Tdebug

func init() {
	p := unsafe.Pointer(&x___init_array_start)
	*(*uintptr)(unsafe.Add(p, 0)) = uintptr(0)
}

func init() {
	p := unsafe.Pointer(&x___fini_array_start)
	*(*uintptr)(unsafe.Add(p, 0)) = uintptr(0)
}

func _find_sym2(tls *TLS, dso uintptr, s uintptr, need_def int32, use_deps int32) (r Tsymdef) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(172), uintptr(unsafe.Pointer(&___func__84)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__84 = [10]int8{'f', 'i', 'n', 'd', '_', 's', 'y', 'm', '2'}

func x___libc_exit_fini(tls *TLS) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(177), uintptr(unsafe.Pointer(&___func__85)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__85 = [17]int8{'_', '_', 'l', 'i', 'b', 'c', '_', 'e', 'x', 'i', 't', '_', 'f', 'i', 'n', 'i'}

func x___ldso_atfork(tls *TLS, who int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(182), uintptr(unsafe.Pointer(&___func__86)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__86 = [14]int8{'_', '_', 'l', 'd', 's', 'o', '_', 'a', 't', 'f', 'o', 'r', 'k'}

func x___libc_start_init(tls *TLS) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(187), uintptr(unsafe.Pointer(&___func__87)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__87 = [18]int8{'_', '_', 'l', 'i', 'b', 'c', '_', 's', 't', 'a', 'r', 't', '_', 'i', 'n', 'i', 't'}

func _dl_debug_state(tls *TLS) {
}

func x___init_tls(tls *TLS, auxv uintptr) {
}

func x___dls2(tls *TLS, base uintptr, sp uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(202), uintptr(unsafe.Pointer(&___func__88)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__88 = [7]int8{'_', '_', 'd', 'l', 's', '2'}

func x___dls2b(tls *TLS, sp uintptr, auxv uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(207), uintptr(unsafe.Pointer(&___func__89)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__89 = [8]int8{'_', '_', 'd', 'l', 's', '2', 'b'}

func x___dls3(tls *TLS, sp uintptr, auxv uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(212), uintptr(unsafe.Pointer(&___func__90)))
	}
	_ = v1 || Int32FromInt32(0) != 0
}

var ___func__90 = [7]int8{'_', '_', 'd', 'l', 's', '3'}

func x_dlopen(tls *TLS, file uintptr, mode int32) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(217), uintptr(unsafe.Pointer(&___func__91)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__91 = [7]int8{'d', 'l', 'o', 'p', 'e', 'n'}

func x___dl_invalid_handle(tls *TLS, h uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(222), uintptr(unsafe.Pointer(&___func__92)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__92 = [20]int8{'_', '_', 'd', 'l', '_', 'i', 'n', 'v', 'a', 'l', 'i', 'd', '_', 'h', 'a', 'n', 'd', 'l', 'e'}

func x_dladdr(tls *TLS, addr_arg uintptr, info uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(227), uintptr(unsafe.Pointer(&___func__93)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__93 = [7]int8{'d', 'l', 'a', 'd', 'd', 'r'}

func x___dlsym(tls *TLS, p uintptr, s uintptr, ra uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(232), uintptr(unsafe.Pointer(&___func__94)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__94 = [8]int8{'_', '_', 'd', 'l', 's', 'y', 'm'}

func x___dlsym_redir_time64(tls *TLS, p uintptr, s uintptr, ra uintptr) (r uintptr) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(237), uintptr(unsafe.Pointer(&___func__95)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__95 = [21]int8{'_', '_', 'd', 'l', 's', 'y', 'm', '_', 'r', 'e', 'd', 'i', 'r', '_', 't', 'i', 'm', 'e', '6', '4'}

func x_dl_iterate_phdr(tls *TLS, callback uintptr, data uintptr) (r int32) {
	var v1 bool
	if v1 = int32(0) != 0; !v1 {
		___assert_fail(tls, ts+207, ts+4122, int32(242), uintptr(unsafe.Pointer(&___func__96)))
	}
	_ = v1 || Int32FromInt32(0) != 0
	return r
}

var ___func__96 = [16]int8{'d', 'l', '_', 'i', 't', 'e', 'r', 'a', 't', 'e', '_', 'p', 'h', 'd', 'r'}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

var x___abort_lock [1]int32

var x___aio_fut int32

var x___aligned_alloc_replaced int32

var x___at_quick_exit_lockptr = uintptr(unsafe.Pointer(&_lock))

var x___atexit_lockptr = uintptr(unsafe.Pointer(&_lock1))

var x___bump_lockptr = uintptr(unsafe.Pointer(&_lock3))

var x___c_dot_utf8 = T__locale_map{Fmap1: uintptr(unsafe.Pointer(&_empty_mo)), Fmap_size: uint64(20), Fname: [24]int8{'C', '.', 'U', 'T', 'F', '-', '8'}}

var x___c_dot_utf8_locale = T__locale_struct{Fcat: [6]uintptr{
	0: uintptr(unsafe.Pointer(&x___c_dot_utf8))}}

var x___c_locale = T__locale_struct{}

var x___daylight = int32(0)

var x___default_guardsize = uint32(m_DEFAULT_GUARD_SIZE)

var x___default_stacksize = uint32(m_DEFAULT_STACK_SIZE)

var x___eintr_valid_flag int32

var x___environ = uintptr(0)

var x___exp2f_data = Texp2f_data{Ftab: [32]Tuint64_t{
	0:  uint64(0x3ff0000000000000),
	1:  uint64(0x3fefd9b0d3158574),
	2:  uint64(0x3fefb5586cf9890f),
	3:  uint64(0x3fef9301d0125b51),
	4:  uint64(0x3fef72b83c7d517b),
	5:  uint64(0x3fef54873168b9aa),
	6:  uint64(0x3fef387a6e756238),
	7:  uint64(0x3fef1e9df51fdee1),
	8:  uint64(0x3fef06fe0a31b715),
	9:  uint64(0x3feef1a7373aa9cb),
	10: uint64(0x3feedea64c123422),
	11: uint64(0x3feece086061892d),
	12: uint64(0x3feebfdad5362a27),
	13: uint64(0x3feeb42b569d4f82),
	14: uint64(0x3feeab07dd485429),
	15: uint64(0x3feea47eb03a5585),
	16: uint64(0x3feea09e667f3bcd),
	17: uint64(0x3fee9f75e8ec5f74),
	18: uint64(0x3feea11473eb0187),
	19: uint64(0x3feea589994cce13),
	20: uint64(0x3feeace5422aa0db),
	21: uint64(0x3feeb737b0cdc5e5),
	22: uint64(0x3feec49182a3f090),
	23: uint64(0x3feed503b23e255d),
	24: uint64(0x3feee89f995ad3ad),
	25: uint64(0x3feeff76f2fb5e47),
	26: uint64(0x3fef199bdd85529c),
	27: uint64(0x3fef3720dcef9069),
	28: uint64(0x3fef5818dcfba487),
	29: uint64(0x3fef7c97337b9b5f),
	30: uint64(0x3fefa4afa2a490da),
	31: uint64(0x3fefd0765b6e4540)}, Fshift_scaled: Float64FromFloat64(6.755399441055744e+15) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)), Fpoly: [3]float64{
	0: float64(0.05550361559341535),
	1: float64(0.2402284522445722),
	2: float64(0.6931471806916203)}, Fshift: float64(6.755399441055744e+15), Finvln2_scaled: Float64FromFloat64(1.4426950408889634) * float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)), Fpoly_scaled: [3]float64{
	0: Float64FromFloat64(0.05550361559341535) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)),
	1: Float64FromFloat64(0.2402284522445722) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS)),
	2: Float64FromFloat64(0.6931471806916203) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP2F_TABLE_BITS))}}

var x___exp_data = Texp_data{Finvln2N: Float64FromFloat64(1.4426950408889634) * float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP_TABLE_BITS)), Fshift: float64(6.755399441055744e+15), Fnegln2hiN: -Float64FromFloat64(0.005415212348111709), Fnegln2loN: -Float64FromFloat64(1.2864023111638346e-14), Fpoly: [4]float64{
	0: float64(0.49999999999996786),
	1: float64(0.16666666666665886),
	2: float64(0.0416666808410674),
	3: float64(0.008333335853059549)}, Fexp2_shift: Float64FromFloat64(6.755399441055744e+15) / float64(Int32FromInt32(1)<<Int32FromInt32(m_EXP_TABLE_BITS)), Fexp2_poly: [5]float64{
	0: float64(0.6931471805599453),
	1: float64(0.24022650695909065),
	2: float64(0.0555041086686087),
	3: float64(0.009618131975721055),
	4: float64(0.0013332074570119598)}, Ftab: [256]Tuint64_t{
	0:   uint64(0x0),
	1:   uint64(0x3ff0000000000000),
	2:   uint64(0x3c9b3b4f1a88bf6e),
	3:   uint64(0x3feff63da9fb3335),
	4:   uint64(0xbc7160139cd8dc5d),
	5:   uint64(0x3fefec9a3e778061),
	6:   uint64(0xbc905e7a108766d1),
	7:   uint64(0x3fefe315e86e7f85),
	8:   uint64(0x3c8cd2523567f613),
	9:   uint64(0x3fefd9b0d3158574),
	10:  uint64(0xbc8bce8023f98efa),
	11:  uint64(0x3fefd06b29ddf6de),
	12:  uint64(0x3c60f74e61e6c861),
	13:  uint64(0x3fefc74518759bc8),
	14:  uint64(0x3c90a3e45b33d399),
	15:  uint64(0x3fefbe3ecac6f383),
	16:  uint64(0x3c979aa65d837b6d),
	17:  uint64(0x3fefb5586cf9890f),
	18:  uint64(0x3c8eb51a92fdeffc),
	19:  uint64(0x3fefac922b7247f7),
	20:  uint64(0x3c3ebe3d702f9cd1),
	21:  uint64(0x3fefa3ec32d3d1a2),
	22:  uint64(0xbc6a033489906e0b),
	23:  uint64(0x3fef9b66affed31b),
	24:  uint64(0xbc9556522a2fbd0e),
	25:  uint64(0x3fef9301d0125b51),
	26:  uint64(0xbc5080ef8c4eea55),
	27:  uint64(0x3fef8abdc06c31cc),
	28:  uint64(0xbc91c923b9d5f416),
	29:  uint64(0x3fef829aaea92de0),
	30:  uint64(0x3c80d3e3e95c55af),
	31:  uint64(0x3fef7a98c8a58e51),
	32:  uint64(0xbc801b15eaa59348),
	33:  uint64(0x3fef72b83c7d517b),
	34:  uint64(0xbc8f1ff055de323d),
	35:  uint64(0x3fef6af9388c8dea),
	36:  uint64(0x3c8b898c3f1353bf),
	37:  uint64(0x3fef635beb6fcb75),
	38:  uint64(0xbc96d99c7611eb26),
	39:  uint64(0x3fef5be084045cd4),
	40:  uint64(0x3c9aecf73e3a2f60),
	41:  uint64(0x3fef54873168b9aa),
	42:  uint64(0xbc8fe782cb86389d),
	43:  uint64(0x3fef4d5022fcd91d),
	44:  uint64(0x3c8a6f4144a6c38d),
	45:  uint64(0x3fef463b88628cd6),
	46:  uint64(0x3c807a05b0e4047d),
	47:  uint64(0x3fef3f49917ddc96),
	48:  uint64(0x3c968efde3a8a894),
	49:  uint64(0x3fef387a6e756238),
	50:  uint64(0x3c875e18f274487d),
	51:  uint64(0x3fef31ce4fb2a63f),
	52:  uint64(0x3c80472b981fe7f2),
	53:  uint64(0x3fef2b4565e27cdd),
	54:  uint64(0xbc96b87b3f71085e),
	55:  uint64(0x3fef24dfe1f56381),
	56:  uint64(0x3c82f7e16d09ab31),
	57:  uint64(0x3fef1e9df51fdee1),
	58:  uint64(0xbc3d219b1a6fbffa),
	59:  uint64(0x3fef187fd0dad990),
	60:  uint64(0x3c8b3782720c0ab4),
	61:  uint64(0x3fef1285a6e4030b),
	62:  uint64(0x3c6e149289cecb8f),
	63:  uint64(0x3fef0cafa93e2f56),
	64:  uint64(0x3c834d754db0abb6),
	65:  uint64(0x3fef06fe0a31b715),
	66:  uint64(0x3c864201e2ac744c),
	67:  uint64(0x3fef0170fc4cd831),
	68:  uint64(0x3c8fdd395dd3f84a),
	69:  uint64(0x3feefc08b26416ff),
	70:  uint64(0xbc86a3803b8e5b04),
	71:  uint64(0x3feef6c55f929ff1),
	72:  uint64(0xbc924aedcc4b5068),
	73:  uint64(0x3feef1a7373aa9cb),
	74:  uint64(0xbc9907f81b512d8e),
	75:  uint64(0x3feeecae6d05d866),
	76:  uint64(0xbc71d1e83e9436d2),
	77:  uint64(0x3feee7db34e59ff7),
	78:  uint64(0xbc991919b3ce1b15),
	79:  uint64(0x3feee32dc313a8e5),
	80:  uint64(0x3c859f48a72a4c6d),
	81:  uint64(0x3feedea64c123422),
	82:  uint64(0xbc9312607a28698a),
	83:  uint64(0x3feeda4504ac801c),
	84:  uint64(0xbc58a78f4817895b),
	85:  uint64(0x3feed60a21f72e2a),
	86:  uint64(0xbc7c2c9b67499a1b),
	87:  uint64(0x3feed1f5d950a897),
	88:  uint64(0x3c4363ed60c2ac11),
	89:  uint64(0x3feece086061892d),
	90:  uint64(0x3c9666093b0664ef),
	91:  uint64(0x3feeca41ed1d0057),
	92:  uint64(0x3c6ecce1daa10379),
	93:  uint64(0x3feec6a2b5c13cd0),
	94:  uint64(0x3c93ff8e3f0f1230),
	95:  uint64(0x3feec32af0d7d3de),
	96:  uint64(0x3c7690cebb7aafb0),
	97:  uint64(0x3feebfdad5362a27),
	98:  uint64(0x3c931dbdeb54e077),
	99:  uint64(0x3feebcb299fddd0d),
	100: uint64(0xbc8f94340071a38e),
	101: uint64(0x3feeb9b2769d2ca7),
	102: uint64(0xbc87deccdc93a349),
	103: uint64(0x3feeb6daa2cf6642),
	104: uint64(0xbc78dec6bd0f385f),
	105: uint64(0x3feeb42b569d4f82),
	106: uint64(0xbc861246ec7b5cf6),
	107: uint64(0x3feeb1a4ca5d920f),
	108: uint64(0x3c93350518fdd78e),
	109: uint64(0x3feeaf4736b527da),
	110: uint64(0x3c7b98b72f8a9b05),
	111: uint64(0x3feead12d497c7fd),
	112: uint64(0x3c9063e1e21c5409),
	113: uint64(0x3feeab07dd485429),
	114: uint64(0x3c34c7855019c6ea),
	115: uint64(0x3feea9268a5946b7),
	116: uint64(0x3c9432e62b64c035),
	117: uint64(0x3feea76f15ad2148),
	118: uint64(0xbc8ce44a6199769f),
	119: uint64(0x3feea5e1b976dc09),
	120: uint64(0xbc8c33c53bef4da8),
	121: uint64(0x3feea47eb03a5585),
	122: uint64(0xbc845378892be9ae),
	123: uint64(0x3feea34634ccc320),
	124: uint64(0xbc93cedd78565858),
	125: uint64(0x3feea23882552225),
	126: uint64(0x3c5710aa807e1964),
	127: uint64(0x3feea155d44ca973),
	128: uint64(0xbc93b3efbf5e2228),
	129: uint64(0x3feea09e667f3bcd),
	130: uint64(0xbc6a12ad8734b982),
	131: uint64(0x3feea012750bdabf),
	132: uint64(0xbc6367efb86da9ee),
	133: uint64(0x3fee9fb23c651a2f),
	134: uint64(0xbc80dc3d54e08851),
	135: uint64(0x3fee9f7df9519484),
	136: uint64(0xbc781f647e5a3ecf),
	137: uint64(0x3fee9f75e8ec5f74),
	138: uint64(0xbc86ee4ac08b7db0),
	139: uint64(0x3fee9f9a48a58174),
	140: uint64(0xbc8619321e55e68a),
	141: uint64(0x3fee9feb564267c9),
	142: uint64(0x3c909ccb5e09d4d3),
	143: uint64(0x3feea0694fde5d3f),
	144: uint64(0xbc7b32dcb94da51d),
	145: uint64(0x3feea11473eb0187),
	146: uint64(0x3c94ecfd5467c06b),
	147: uint64(0x3feea1ed0130c132),
	148: uint64(0x3c65ebe1abd66c55),
	149: uint64(0x3feea2f336cf4e62),
	150: uint64(0xbc88a1c52fb3cf42),
	151: uint64(0x3feea427543e1a12),
	152: uint64(0xbc9369b6f13b3734),
	153: uint64(0x3feea589994cce13),
	154: uint64(0xbc805e843a19ff1e),
	155: uint64(0x3feea71a4623c7ad),
	156: uint64(0xbc94d450d872576e),
	157: uint64(0x3feea8d99b4492ed),
	158: uint64(0x3c90ad675b0e8a00),
	159: uint64(0x3feeaac7d98a6699),
	160: uint64(0x3c8db72fc1f0eab4),
	161: uint64(0x3feeace5422aa0db),
	162: uint64(0xbc65b6609cc5e7ff),
	163: uint64(0x3feeaf3216b5448c),
	164: uint64(0x3c7bf68359f35f44),
	165: uint64(0x3feeb1ae99157736),
	166: uint64(0xbc93091fa71e3d83),
	167: uint64(0x3feeb45b0b91ffc6),
	168: uint64(0xbc5da9b88b6c1e29),
	169: uint64(0x3feeb737b0cdc5e5),
	170: uint64(0xbc6c23f97c90b959),
	171: uint64(0x3feeba44cbc8520f),
	172: uint64(0xbc92434322f4f9aa),
	173: uint64(0x3feebd829fde4e50),
	174: uint64(0xbc85ca6cd7668e4b),
	175: uint64(0x3feec0f170ca07ba),
	176: uint64(0x3c71affc2b91ce27),
	177: uint64(0x3feec49182a3f090),
	178: uint64(0x3c6dd235e10a73bb),
	179: uint64(0x3feec86319e32323),
	180: uint64(0xbc87c50422622263),
	181: uint64(0x3feecc667b5de565),
	182: uint64(0x3c8b1c86e3e231d5),
	183: uint64(0x3feed09bec4a2d33),
	184: uint64(0xbc91bbd1d3bcbb15),
	185: uint64(0x3feed503b23e255d),
	186: uint64(0x3c90cc319cee31d2),
	187: uint64(0x3feed99e1330b358),
	188: uint64(0x3c8469846e735ab3),
	189: uint64(0x3feede6b5579fdbf),
	190: uint64(0xbc82dfcd978e9db4),
	191: uint64(0x3feee36bbfd3f37a),
	192: uint64(0x3c8c1a7792cb3387),
	193: uint64(0x3feee89f995ad3ad),
	194: uint64(0xbc907b8f4ad1d9fa),
	195: uint64(0x3feeee07298db666),
	196: uint64(0xbc55c3d956dcaeba),
	197: uint64(0x3feef3a2b84f15fb),
	198: uint64(0xbc90a40e3da6f640),
	199: uint64(0x3feef9728de5593a),
	200: uint64(0xbc68d6f438ad9334),
	201: uint64(0x3feeff76f2fb5e47),
	202: uint64(0xbc91eee26b588a35),
	203: uint64(0x3fef05b030a1064a),
	204: uint64(0x3c74ffd70a5fddcd),
	205: uint64(0x3fef0c1e904bc1d2),
	206: uint64(0xbc91bdfbfa9298ac),
	207: uint64(0x3fef12c25bd71e09),
	208: uint64(0x3c736eae30af0cb3),
	209: uint64(0x3fef199bdd85529c),
	210: uint64(0x3c8ee3325c9ffd94),
	211: uint64(0x3fef20ab5fffd07a),
	212: uint64(0x3c84e08fd10959ac),
	213: uint64(0x3fef27f12e57d14b),
	214: uint64(0x3c63cdaf384e1a67),
	215: uint64(0x3fef2f6d9406e7b5),
	216: uint64(0x3c676b2c6c921968),
	217: uint64(0x3fef3720dcef9069),
	218: uint64(0xbc808a1883ccb5d2),
	219: uint64(0x3fef3f0b555dc3fa),
	220: uint64(0xbc8fad5d3ffffa6f),
	221: uint64(0x3fef472d4a07897c),
	222: uint64(0xbc900dae3875a949),
	223: uint64(0x3fef4f87080d89f2),
	224: uint64(0x3c74a385a63d07a7),
	225: uint64(0x3fef5818dcfba487),
	226: uint64(0xbc82919e2040220f),
	227: uint64(0x3fef60e316c98398),
	228: uint64(0x3c8e5a50d5c192ac),
	229: uint64(0x3fef69e603db3285),
	230: uint64(0x3c843a59ac016b4b),
	231: uint64(0x3fef7321f301b460),
	232: uint64(0xbc82d52107b43e1f),
	233: uint64(0x3fef7c97337b9b5f),
	234: uint64(0xbc892ab93b470dc9),
	235: uint64(0x3fef864614f5a129),
	236: uint64(0x3c74b604603a88d3),
	237: uint64(0x3fef902ee78b3ff6),
	238: uint64(0x3c83c5ec519d7271),
	239: uint64(0x3fef9a51fbc74c83),
	240: uint64(0xbc8ff7128fd391f0),
	241: uint64(0x3fefa4afa2a490da),
	242: uint64(0xbc8dae98e223747d),
	243: uint64(0x3fefaf482d8e67f1),
	244: uint64(0x3c8ec3bc41aa2008),
	245: uint64(0x3fefba1bee615a27),
	246: uint64(0x3c842b94c3a9eb32),
	247: uint64(0x3fefc52b376bba97),
	248: uint64(0x3c8a64a931d185ee),
	249: uint64(0x3fefd0765b6e4540),
	250: uint64(0xbc8e37bae43be3ed),
	251: uint64(0x3fefdbfdad9cbe14),
	252: uint64(0x3c77893b4d91cd9d),
	253: uint64(0x3fefe7c1819e90d8),
	254: uint64(0x3c5305c14160cc89),
	255: uint64(0x3feff3c22b8f71f1)}}

var x___fini_array_start = uintptr(0)

var x___fsmu8 = [1]Tuint32_t{}

var x___gettext_lockptr = uintptr(unsafe.Pointer(&_lock2))

var x___hwcap Tsize_t

var x___init_array_start = uintptr(0)

var x___libc T__libc

var x___libc_version = [6]int8{'1', '.', '2', '.', '4'}

var x___locale_lock [1]int32

var x___locale_lockptr = uintptr(unsafe.Pointer(&x___locale_lock))

var x___log2_data = Tlog2_data{Finvln2hi: float64(1.4426950407214463), Finvln2lo: float64(1.6751713164886512e-10), Fpoly: [6]float64{
	0: -Float64FromFloat64(0.7213475204444882),
	1: float64(0.4808983469629985),
	2: -Float64FromFloat64(0.36067375954075914),
	3: float64(0.2885390073180969),
	4: -Float64FromFloat64(0.2404693555628422),
	5: float64(0.2061202382173603)}, Fpoly1: [10]float64{
	0: -Float64FromFloat64(0.7213475204444817),
	1: float64(0.48089834696298744),
	2: -Float64FromFloat64(0.360673760222145),
	3: float64(0.2885390081805197),
	4: -Float64FromFloat64(0.24044917405728863),
	5: float64(0.2060992861022954),
	6: -Float64FromFloat64(0.18033596705327856),
	7: float64(0.1603032746063156),
	8: -Float64FromFloat64(0.14483316576701266),
	9: float64(0.13046826811283835)}, Ftab: [64]struct {
	Finvc float64
	Flogc float64
}{
	0:  {Finvc: float64(1.4463276106642393), Flogc: -Float64FromFloat64(0.5323943771486483)},
	1:  {Finvc: float64(1.4301675812282968), Flogc: -Float64FromFloat64(0.516184206053822)},
	2:  {Finvc: float64(1.4143648676229383), Flogc: -Float64FromFloat64(0.5001543441974263)},
	3:  {Finvc: float64(1.3989068970611538), Flogc: -Float64FromFloat64(0.4842999484799293)},
	4:  {Finvc: float64(1.3837838957784339), Flogc: -Float64FromFloat64(0.46861865624623533)},
	5:  {Finvc: float64(1.368983882697786), Flogc: -Float64FromFloat64(0.4531054615783887)},
	6:  {Finvc: float64(1.3544972916324536), Flogc: -Float64FromFloat64(0.43775750882059583)},
	7:  {Finvc: float64(1.3403139676437443), Flogc: -Float64FromFloat64(0.4225709906127122)},
	8:  {Finvc: float64(1.3264249304188642), Flogc: -Float64FromFloat64(0.40754302793970965)},
	9:  {Finvc: float64(1.3128203652112156), Flogc: -Float64FromFloat64(0.3926695240384106)},
	10: {Finvc: float64(1.299492412370217), Flogc: -Float64FromFloat64(0.3779482100565019)},
	11: {Finvc: float64(1.28643198385998), Flogc: -Float64FromFloat64(0.36337518101890964)},
	12: {Finvc: float64(1.2736319291846832), Flogc: -Float64FromFloat64(0.3489484089425332)},
	13: {Finvc: float64(1.2610838968062879), Flogc: -Float64FromFloat64(0.33466425780738973)},
	14: {Finvc: float64(1.248780314313572), Flogc: -Float64FromFloat64(0.3205197000629596)},
	15: {Finvc: float64(1.2367150450059063), Flogc: -Float64FromFloat64(0.3065131231801388)},
	16: {Finvc: float64(1.2248804968401878), Flogc: -Float64FromFloat64(0.2926410022678283)},
	17: {Finvc: float64(1.2132702353497795), Flogc: -Float64FromFloat64(0.2789009220805383)},
	18: {Finvc: float64(1.2018780785715362), Flogc: -Float64FromFloat64(0.2652905529862437)},
	19: {Finvc: float64(1.190697765061355), Flogc: -Float64FromFloat64(0.2518072602367738)},
	20: {Finvc: float64(1.1797235410550593), Flogc: -Float64FromFloat64(0.23844881494437686)},
	21: {Finvc: float64(1.1689498986205256), Flogc: -Float64FromFloat64(0.22521309705462045)},
	22: {Finvc: float64(1.158371137408455), Flogc: -Float64FromFloat64(0.21209756102439314)},
	23: {Finvc: float64(1.1479820146386086), Flogc: -Float64FromFloat64(0.1991000395789797)},
	24: {Finvc: float64(1.1377775576851088), Flogc: -Float64FromFloat64(0.18621852970682085)},
	25: {Finvc: float64(1.127753150630225), Flogc: -Float64FromFloat64(0.17345131655361)},
	26: {Finvc: float64(1.1179037012282074), Flogc: -Float64FromFloat64(0.16079591649577196)},
	27: {Finvc: float64(1.1082251967632821), Flogc: -Float64FromFloat64(0.14825107384353942)},
	28: {Finvc: float64(1.098712461056607), Flogc: -Float64FromFloat64(0.13581387465410444)},
	29: {Finvc: float64(1.0893619091634283), Flogc: -Float64FromFloat64(0.12348332762257996)},
	30: {Finvc: float64(1.0801689912316736), Flogc: -Float64FromFloat64(0.11125703807351783)},
	31: {Finvc: float64(1.071129489697672), Flogc: -Float64FromFloat64(0.09913289918449664)},
	32: {Finvc: float64(1.0622406576750423), Flogc: -Float64FromFloat64(0.08711065531497297)},
	33: {Finvc: float64(1.0534977607927976), Flogc: -Float64FromFloat64(0.07518724771330199)},
	34: {Finvc: float64(1.044897877982342), Flogc: -Float64FromFloat64(0.06336194888240243)},
	35: {Finvc: float64(1.0364370289499079), Flogc: -Float64FromFloat64(0.0516324649456692)},
	36: {Finvc: float64(1.0281122132034575), Flogc: -Float64FromFloat64(0.039997735929773626)},
	37: {Finvc: float64(1.0199202450036955), Flogc: -Float64FromFloat64(0.028456341769015125)},
	38: {Finvc: float64(1.0118577522306755), Flogc: -Float64FromFloat64(0.017006489068080555)},
	39: {Finvc: float64(1.003921649236766), Flogc: -Float64FromFloat64(0.005646678981520381)},
	40: {Finvc: float64(0.9922480467550775), Flogc: float64(0.011227277611396858)},
	41: {Finvc: float64(0.9770993366178549), Flogc: float64(0.033422853921138085)},
	42: {Finvc: float64(0.9624059787315814), Flogc: float64(0.05528248992573026)},
	43: {Finvc: float64(0.9481480598286369), Flogc: float64(0.07681573143713649)},
	44: {Finvc: float64(0.9343065931261065), Flogc: float64(0.09803204623631245)},
	45: {Finvc: float64(0.9208633936884979), Flogc: float64(0.11894094059630334)},
	46: {Finvc: float64(0.9078013641840602), Flogc: float64(0.13955143862290242)},
	47: {Finvc: float64(0.8951048181512927), Flogc: float64(0.15987146080919956)},
	48: {Finvc: float64(0.882758574260473), Flogc: float64(0.17990916589428707)},
	49: {Finvc: float64(0.8707481902241709), Flogc: float64(0.19967252559081317)},
	50: {Finvc: float64(0.8590602881746972), Flogc: float64(0.2191687127685782)},
	51: {Finvc: float64(0.8476822044336688), Flogc: float64(0.23840459427242422)},
	52: {Finvc: float64(0.8366013284053287), Flogc: float64(0.25738780610663525)},
	53: {Finvc: float64(0.8258064913621258), Flogc: float64(0.27612433583180973)},
	54: {Finvc: float64(0.8152865101579193), Flogc: float64(0.2946209507022104)},
	55: {Finvc: float64(0.8050314363208223), Flogc: float64(0.31288297359969874)},
	56: {Finvc: float64(0.7950310492640542), Flogc: float64(0.33091689015759584)},
	57: {Finvc: float64(0.7852760432487271), Flogc: float64(0.3487282100279572)},
	58: {Finvc: float64(0.7757575660314712), Flogc: float64(0.36632223233368677)},
	59: {Finvc: float64(0.7664670566588946), Flogc: float64(0.383704309808536)},
	60: {Finvc: float64(0.7573965608078645), Flogc: float64(0.4008792246509074)},
	61: {Finvc: float64(0.7485380168514022), Flogc: float64(0.41785250494945103)},
	62: {Finvc: float64(0.7398844213755009), Flogc: float64(0.4346281724315304)},
	63: {Finvc: float64(0.7314286113178112), Flogc: float64(0.45121103315341315)}}, Ftab2: [64]struct {
	Fchi float64
	Fclo float64
}{
	0:  {Fchi: float64(0.6914062848739648), Fclo: float64(4.339971893418182e-17)},
	1:  {Fchi: float64(0.6992187580850853), Fclo: float64(7.805593338712074e-18)},
	2:  {Fchi: float64(0.7070311366547563), Fclo: float64(3.20843320369626e-17)},
	3:  {Fchi: float64(0.7148438556567389), Fclo: float64(4.336491946473985e-17)},
	4:  {Fchi: float64(0.7226561915128084), Fclo: float64(4.681890319761607e-17)},
	5:  {Fchi: float64(0.730468789763508), Fclo: -Float64FromFloat64(1.647126642147294e-17)},
	6:  {Fchi: float64(0.7382812842650944), Fclo: float64(2.0846837208642192e-17)},
	7:  {Fchi: float64(0.7460938437864584), Fclo: -Float64FromFloat64(7.82131795361932e-18)},
	8:  {Fchi: float64(0.7539062159244969), Fclo: -Float64FromFloat64(3.470987810015201e-17)},
	9:  {Fchi: float64(0.761718835645205), Fclo: float64(1.2996798345429576e-17)},
	10: {Fchi: float64(0.7695312342578777), Fclo: -Float64FromFloat64(5.2071007285622585e-17)},
	11: {Fchi: float64(0.7773438569208053), Fclo: -Float64FromFloat64(4.513636731226183e-17)},
	12: {Fchi: float64(0.7851561955110148), Fclo: -Float64FromFloat64(2.0797044446832382e-17)},
	13: {Fchi: float64(0.7929686538163826), Fclo: -Float64FromFloat64(1.9947626198727574e-17)},
	14: {Fchi: float64(0.8007813612514213), Fclo: float64(1.472064871061342e-17)},
	15: {Fchi: float64(0.8085937047812207), Fclo: float64(5.290804109377209e-17)},
	16: {Fchi: float64(0.816406173973453), Fclo: -Float64FromFloat64(1.129659587857177e-17)},
	17: {Fchi: float64(0.8242186867064328), Fclo: float64(3.901543738154691e-17)},
	18: {Fchi: float64(0.8320311501051142), Fclo: -Float64FromFloat64(3.212482853127187e-17)},
	19: {Fchi: float64(0.8398436860662717), Fclo: float64(5.220081794706035e-18)},
	20: {Fchi: float64(0.8476562221566525), Fclo: -Float64FromFloat64(5.37416378988278e-17)},
	21: {Fchi: float64(0.8554686571084844), Fclo: float64(4.291992377471359e-18)},
	22: {Fchi: float64(0.8632811779454657), Fclo: float64(1.7319616935225806e-17)},
	23: {Fchi: float64(0.8710937865301015), Fclo: float64(1.8251073579011692e-17)},
	24: {Fchi: float64(0.8789064200163806), Fclo: float64(1.2113671810693101e-17)},
	25: {Fchi: float64(0.8867188705623812), Fclo: -Float64FromFloat64(2.431195196496269e-17)},
	26: {Fchi: float64(0.894531433164887), Fclo: -Float64FromFloat64(2.258952781769403e-17)},
	27: {Fchi: float64(0.9023436779100781), Fclo: float64(4.3322028821617186e-17)},
	28: {Fchi: float64(0.9101562378188762), Fclo: -Float64FromFloat64(5.2414676705491076e-18)},
	29: {Fchi: float64(0.9179685755379005), Fclo: -Float64FromFloat64(2.3432856904274634e-17)},
	30: {Fchi: float64(0.9257810658494647), Fclo: float64(3.9914341909758727e-17)},
	31: {Fchi: float64(0.9335939394986237), Fclo: -Float64FromFloat64(1.8218382846902827e-17)},
	32: {Fchi: float64(0.9414062555172099), Fclo: float64(4.423669374431538e-17)},
	33: {Fchi: float64(0.9492189136192009), Fclo: -Float64FromFloat64(2.6059674623550364e-17)},
	34: {Fchi: float64(0.9570313243730211), Fclo: -Float64FromFloat64(4.947019261946595e-17)},
	35: {Fchi: float64(0.9648439529540691), Fclo: -Float64FromFloat64(5.4644837229582306e-17)},
	36: {Fchi: float64(0.9726564738338594), Fclo: -Float64FromFloat64(5.4656321533328614e-17)},
	37: {Fchi: float64(0.9804688208697894), Fclo: -Float64FromFloat64(1.782581090537996e-18)},
	38: {Fchi: float64(0.98828120632121), Fclo: -Float64FromFloat64(5.2277711573086786e-18)},
	39: {Fchi: float64(0.9960936700192217), Fclo: float64(4.1586638841164565e-17)},
	40: {Fchi: float64(1.007812515499802), Fclo: float64(9.540912389137736e-17)},
	41: {Fchi: float64(1.0234373952820537), Fclo: float64(3.985821704561347e-17)},
	42: {Fchi: float64(1.0390625391978199), Fclo: -Float64FromFloat64(5.179495640960355e-18)},
	43: {Fchi: float64(1.0546875982436061), Fclo: -Float64FromFloat64(6.074512782488841e-17)},
	44: {Fchi: float64(1.07031247275489), Fclo: -Float64FromFloat64(4.853656019321416e-17)},
	45: {Fchi: float64(1.0859374005459401), Fclo: -Float64FromFloat64(1.0233609026899023e-16)},
	46: {Fchi: float64(1.101562565835984), Fclo: float64(9.714504510281668e-17)},
	47: {Fchi: float64(1.1171875960464082), Fclo: -Float64FromFloat64(5.728631491659617e-17)},
	48: {Fchi: float64(1.1328125595809087), Fclo: -Float64FromFloat64(4.3353271744463366e-17)},
	49: {Fchi: float64(1.1484376438870962), Fclo: float64(5.029455257812864e-17)},
	50: {Fchi: float64(1.1640626551656426), Fclo: -Float64FromFloat64(1.3886091944776072e-17)},
	51: {Fchi: float64(1.179687381390876), Fclo: float64(9.535864385063222e-17)},
	52: {Fchi: float64(1.19531246968748), Fclo: float64(2.5970710873556995e-17)},
	53: {Fchi: float64(1.2109374417129501), Fclo: -Float64FromFloat64(1.0412863482435496e-16)},
	54: {Fchi: float64(1.2265626715770166), Fclo: float64(1.903080930681457e-17)},
	55: {Fchi: float64(1.2421875157698543), Fclo: float64(9.884933154288451e-17)},
	56: {Fchi: float64(1.2578125104996614), Fclo: float64(2.605028401046449e-17)},
	57: {Fchi: float64(1.273437549250769), Fclo: float64(3.128070230699857e-17)},
	58: {Fchi: float64(1.2890625161616944), Fclo: -Float64FromFloat64(4.506460293510891e-17)},
	59: {Fchi: float64(1.3046875156762752), Fclo: -Float64FromFloat64(2.0874781900380847e-17)},
	60: {Fchi: float64(1.3203123063212308), Fclo: float64(8.50535702424751e-17)},
	61: {Fchi: float64(1.3359374907988373), Fclo: -Float64FromFloat64(3.99657459893118e-17)},
	62: {Fchi: float64(1.351562448282023), Fclo: float64(4.1576596545784e-17)},
	63: {Fchi: float64(1.3671874254389709), Fclo: -Float64FromFloat64(6.072295450780066e-17)}}}

var x___log2f_data = Tlog2f_data{Ftab: [16]struct {
	Finvc float64
	Flogc float64
}{
	0:  {Finvc: float64(1.398907162146528), Flogc: -Float64FromFloat64(0.48430022186289673)},
	1:  {Finvc: float64(1.3403141896637998), Flogc: -Float64FromFloat64(0.42257122959194704)},
	2:  {Finvc: float64(1.286432210124115), Flogc: -Float64FromFloat64(0.3633754347673556)},
	3:  {Finvc: float64(1.2367150214269895), Flogc: -Float64FromFloat64(0.30651309567405577)},
	4:  {Finvc: float64(1.1906977166711752), Flogc: -Float64FromFloat64(0.25180720160537634)},
	5:  {Finvc: float64(1.1479821020556429), Flogc: -Float64FromFloat64(0.19910014943794563)},
	6:  {Finvc: float64(1.1082251448272158), Flogc: -Float64FromFloat64(0.14825100623281615)},
	7:  {Finvc: float64(1.0711297413057381), Flogc: -Float64FromFloat64(0.09913323807318392)},
	8:  {Finvc: float64(1.036437278977283), Flogc: -Float64FromFloat64(0.051632812977629436)},
	9:  {Finvc: float64(1), Flogc: float64(0)},
	10: {Finvc: float64(0.9492859795739057), Flogc: float64(0.07508531937943004)},
	11: {Finvc: float64(0.8951049428609004), Flogc: float64(0.15987125980713107)},
	12: {Finvc: float64(0.8476821620351103), Flogc: float64(0.2384046664317681)},
	13: {Finvc: float64(0.8050314851692001), Flogc: float64(0.31288288605863257)},
	14: {Finvc: float64(0.7664671008843108), Flogc: float64(0.38370422656453185)},
	15: {Finvc: float64(0.731428603316328), Flogc: float64(0.451211048935815)}}, Fpoly: [4]float64{
	0: -Float64FromFloat64(0.36051725506874704),
	1: float64(0.4811247078767291),
	2: -Float64FromFloat64(0.7213476299867769),
	3: float64(1.4426950186867042)}}

var x___log_data = Tlog_data{Fln2hi: float64(0.6931471805598903), Fln2lo: float64(5.497923018708371e-14), Fpoly: [5]float64{
	0: -Float64FromFloat64(0.5000000000000001),
	1: float64(0.33333333331825593),
	2: -Float64FromFloat64(0.2499999999622955),
	3: float64(0.20000304511814496),
	4: -Float64FromFloat64(0.16667054827627667)}, Fpoly1: [11]float64{
	0:  -Float64FromFloat64(0.5),
	1:  float64(0.3333333333333352),
	2:  -Float64FromFloat64(0.24999999999998432),
	3:  float64(0.19999999999320328),
	4:  -Float64FromFloat64(0.16666666669929706),
	5:  float64(0.14285715076560868),
	6:  -Float64FromFloat64(0.12499997863982555),
	7:  float64(0.11110712032936046),
	8:  -Float64FromFloat64(0.10000486757818193),
	9:  float64(0.09181994006195467),
	10: -Float64FromFloat64(0.08328363062289341)}, Ftab: [128]struct {
	Finvc float64
	Flogc float64
}{
	0:   {Finvc: float64(1.4504249240398293), Flogc: -Float64FromFloat64(0.3718565645633589)},
	1:   {Finvc: float64(1.442253508327276), Flogc: -Float64FromFloat64(0.36620682668944937)},
	2:   {Finvc: float64(1.4341736174350004), Flogc: -Float64FromFloat64(0.3605888069791945)},
	3:   {Finvc: float64(1.426183816329995), Flogc: -Float64FromFloat64(0.3550022171419869)},
	4:   {Finvc: float64(1.4182825527052965), Flogc: -Float64FromFloat64(0.34944666968829097)},
	5:   {Finvc: float64(1.4104682921759335), Flogc: -Float64FromFloat64(0.3439217713603284)},
	6:   {Finvc: float64(1.4027396147468003), Flogc: -Float64FromFloat64(0.3384271921261188)},
	7:   {Finvc: float64(1.3950954438932313), Flogc: -Float64FromFloat64(0.332962831494342)},
	8:   {Finvc: float64(1.3875338232485754), Flogc: -Float64FromFloat64(0.32752794345742586)},
	9:   {Finvc: float64(1.3800539211058593), Flogc: -Float64FromFloat64(0.32212257167088865)},
	10:  {Finvc: float64(1.3726542695419708), Flogc: -Float64FromFloat64(0.3167462884799761)},
	11:  {Finvc: float64(1.3653332798446802), Flogc: -Float64FromFloat64(0.3113985598928366)},
	12:  {Finvc: float64(1.358090204587874), Flogc: -Float64FromFloat64(0.3060794515165526)},
	13:  {Finvc: float64(1.3509234892132138), Flogc: -Float64FromFloat64(0.300788424667644)},
	14:  {Finvc: float64(1.3438320840699889), Flogc: -Float64FromFloat64(0.2955252968476998)},
	15:  {Finvc: float64(1.3368146974742003), Flogc: -Float64FromFloat64(0.29028969275850613)},
	16:  {Finvc: float64(1.329870114677736), Flogc: -Float64FromFloat64(0.2850812793277555)},
	17:  {Finvc: float64(1.322997339161106), Flogc: -Float64FromFloat64(0.27989987391470095)},
	18:  {Finvc: float64(1.316195352741367), Flogc: -Float64FromFloat64(0.27474526621870154)},
	19:  {Finvc: float64(1.3094628125672239), Flogc: -Float64FromFloat64(0.2696169863701243)},
	20:  {Finvc: float64(1.3027990455471041), Flogc: -Float64FromFloat64(0.26451506180308115)},
	21:  {Finvc: float64(1.2962024229438942), Flogc: -Float64FromFloat64(0.2594387762767383)},
	22:  {Finvc: float64(1.2896726275815547), Flogc: -Float64FromFloat64(0.2543884090981692)},
	23:  {Finvc: float64(1.2832080305745537), Flogc: -Float64FromFloat64(0.24936321635129843)},
	24:  {Finvc: float64(1.276807885983376), Flogc: -Float64FromFloat64(0.24436312405975968)},
	25:  {Finvc: float64(1.2704714060687552), Flogc: -Float64FromFloat64(0.23938801747897287)},
	26:  {Finvc: float64(1.2641976054949482), Flogc: -Float64FromFloat64(0.23443761696705678)},
	27:  {Finvc: float64(1.257985357514882), Flogc: -Float64FromFloat64(0.22951151871518505)},
	28:  {Finvc: float64(1.2518337750655457), Flogc: -Float64FromFloat64(0.2246094963439873)},
	29:  {Finvc: float64(1.2457421919097305), Flogc: -Float64FromFloat64(0.21973149037705753)},
	30:  {Finvc: float64(1.2397094966625508), Flogc: -Float64FromFloat64(0.2148770752847895)},
	31:  {Finvc: float64(1.2337348463589233), Flogc: -Float64FromFloat64(0.210046029103637)},
	32:  {Finvc: float64(1.2278176973028803), Flogc: -Float64FromFloat64(0.20523836373934046)},
	33:  {Finvc: float64(1.2219570190618474), Flogc: -Float64FromFloat64(0.20045368751368642)},
	34:  {Finvc: float64(1.2161519732977757), Flogc: -Float64FromFloat64(0.1956917537758045)},
	35:  {Finvc: float64(1.2104018095009725), Flogc: -Float64FromFloat64(0.19095237845203883)},
	36:  {Finvc: float64(1.204705805718973), Flogc: -Float64FromFloat64(0.18623539250290833)},
	37:  {Finvc: float64(1.1990631185441964), Flogc: -Float64FromFloat64(0.18154051731551135)},
	38:  {Finvc: float64(1.1934733004462308), Flogc: -Float64FromFloat64(0.1768677957431919)},
	39:  {Finvc: float64(1.1879350812847385), Flogc: -Float64FromFloat64(0.17221657406412305)},
	40:  {Finvc: float64(1.1824481322833125), Flogc: -Float64FromFloat64(0.16758697765942543)},
	41:  {Finvc: float64(1.1770114976921955), Flogc: -Float64FromFloat64(0.16297859687290384)},
	42:  {Finvc: float64(1.1716248121809465), Flogc: -Float64FromFloat64(0.15839151377804228)},
	43:  {Finvc: float64(1.1662869231674715), Flogc: -Float64FromFloat64(0.15382513241456763)},
	44:  {Finvc: float64(1.1609977486762766), Flogc: -Float64FromFloat64(0.14927976358922024)},
	45:  {Finvc: float64(1.1557563220795803), Flogc: -Float64FromFloat64(0.14475495398119165)},
	46:  {Finvc: float64(1.1505619105480347), Flogc: -Float64FromFloat64(0.14025044090817573)},
	47:  {Finvc: float64(1.1454138888505974), Flogc: -Float64FromFloat64(0.1357660466685502)},
	48:  {Finvc: float64(1.140311877374656), Flogc: -Float64FromFloat64(0.1313018016355727)},
	49:  {Finvc: float64(1.1352550225747513), Flogc: -Float64FromFloat64(0.12685731518763532)},
	50:  {Finvc: float64(1.1302429094831266), Flogc: -Float64FromFloat64(0.1224325737671279)},
	51:  {Finvc: float64(1.1252747693068048), Flogc: -Float64FromFloat64(0.11802724521862729)},
	52:  {Finvc: float64(1.1203501571039876), Flogc: -Float64FromFloat64(0.11364127671663482)},
	53:  {Finvc: float64(1.1154683327680124), Flogc: -Float64FromFloat64(0.10927434611278386)},
	54:  {Finvc: float64(1.1106291463292157), Flogc: -Float64FromFloat64(0.10492665324943573)},
	55:  {Finvc: float64(1.1058315813301596), Flogc: -Float64FromFloat64(0.10059761422644442)},
	56:  {Finvc: float64(1.1010752177696026), Flogc: -Float64FromFloat64(0.09628717309055901)},
	57:  {Finvc: float64(1.0963597137952512), Flogc: -Float64FromFloat64(0.09199534069557558)},
	58:  {Finvc: float64(1.0916844827550398), Flogc: -Float64FromFloat64(0.08772190036688698)},
	59:  {Finvc: float64(1.0870487291277784), Flogc: -Float64FromFloat64(0.08346643613867855)},
	60:  {Finvc: float64(1.082452357388312), Flogc: -Float64FromFloat64(0.07922916827544668)},
	61:  {Finvc: float64(1.0778948225025884), Flogc: -Float64FromFloat64(0.0750099004750382)},
	62:  {Finvc: float64(1.0733751731601076), Flogc: -Float64FromFloat64(0.07080805133352897)},
	63:  {Finvc: float64(1.068893585073351), Flogc: -Float64FromFloat64(0.06662408085151128)},
	64:  {Finvc: float64(1.0644491706655506), Flogc: -Float64FromFloat64(0.06245745471915143)},
	65:  {Finvc: float64(1.0600414846328305), Flogc: -Float64FromFloat64(0.0583080438042316)},
	66:  {Finvc: float64(1.0556701316181605), Flogc: -Float64FromFloat64(0.05417576112313327)},
	67:  {Finvc: float64(1.051334750556926), Flogc: -Float64FromFloat64(0.050060547896805474)},
	68:  {Finvc: float64(1.0470347288442157), Flogc: -Float64FromFloat64(0.045962101199052086)},
	69:  {Finvc: float64(1.0427699229652954), Flogc: -Float64FromFloat64(0.04188056008865715)},
	70:  {Finvc: float64(1.0385395013738175), Flogc: -Float64FromFloat64(0.03781540056183985)},
	71:  {Finvc: float64(1.034343418940345), Flogc: -Float64FromFloat64(0.03376684757915882)},
	72:  {Finvc: float64(1.0301811073173315), Flogc: -Float64FromFloat64(0.029734619131772888)},
	73:  {Finvc: float64(1.026052043621297), Flogc: -Float64FromFloat64(0.025718470239212365)},
	74:  {Finvc: float64(1.0219561082336197), Flogc: -Float64FromFloat64(0.021718543925430822)},
	75:  {Finvc: float64(1.0178926505784922), Flogc: -Float64FromFloat64(0.01773446126981071)},
	76:  {Finvc: float64(1.0138614436244586), Flogc: -Float64FromFloat64(0.013766252464051831)},
	77:  {Finvc: float64(1.0098620186501341), Flogc: -Float64FromFloat64(0.009813706322574944)},
	78:  {Finvc: float64(1.0058938559734134), Flogc: -Float64FromFloat64(0.005876555150052809)},
	79:  {Finvc: float64(1.00195696235014), Flogc: -Float64FromFloat64(0.0019550499938532084)},
	80:  {Finvc: float64(0.9961089923088509), Flogc: float64(0.0038985973556009412)},
	81:  {Finvc: float64(0.9884170338185201), Flogc: float64(0.011650571286395461)},
	82:  {Finvc: float64(0.9808429191005297), Flogc: float64(0.019342955478919066)},
	83:  {Finvc: float64(0.9733840169987446), Flogc: float64(0.0269766014846482)},
	84:  {Finvc: float64(0.9660377568876556), Flogc: float64(0.034552359728422744)},
	85:  {Finvc: float64(0.9588014945307369), Flogc: float64(0.04207121767183253)},
	86:  {Finvc: float64(0.9516728569073111), Flogc: float64(0.049533940950141186)},
	87:  {Finvc: float64(0.9446494635965822), Flogc: float64(0.056941358295944156)},
	88:  {Finvc: float64(0.9377288993026223), Flogc: float64(0.06429439168346107)},
	89:  {Finvc: float64(0.9309091073790681), Flogc: float64(0.0715936354946507)},
	90:  {Finvc: float64(0.924187681612722), Flogc: float64(0.07884010933776153)},
	91:  {Finvc: float64(0.9175626765599192), Flogc: float64(0.08603438905970506)},
	92:  {Finvc: float64(0.9110320403624034), Flogc: float64(0.09317721180013905)},
	93:  {Finvc: float64(0.9045935839762024), Flogc: float64(0.10026951462748457)},
	94:  {Finvc: float64(0.8982456375922825), Flogc: float64(0.10731170956330516)},
	95:  {Finvc: float64(0.8919860966782501), Flogc: float64(0.11430473320717738)},
	96:  {Finvc: float64(0.8858131121185129), Flogc: float64(0.12124928503033061)},
	97:  {Finvc: float64(0.879725075760676), Flogc: float64(0.12814583422959913)},
	98:  {Finvc: float64(0.8737201372634685), Flogc: float64(0.1349951636851756)},
	99:  {Finvc: float64(0.8677966405782273), Flogc: float64(0.1417978768189414)},
	100: {Finvc: float64(0.8619528050060739), Flogc: float64(0.14855476039031146)},
	101: {Finvc: float64(0.8561872354420692), Flogc: float64(0.1552661937658968)},
	102: {Finvc: float64(0.8504983927816893), Flogc: float64(0.16193275688146969)},
	103: {Finvc: float64(0.8448844572790304), Flogc: float64(0.16855539792220497)},
	104: {Finvc: float64(0.8393442741575965), Flogc: float64(0.1751343179947753)},
	105: {Finvc: float64(0.8338762249349438), Flogc: float64(0.1816702989864325)},
	106: {Finvc: float64(0.8284789320557778), Flogc: float64(0.18816387146023317)},
	107: {Finvc: float64(0.8231510800065832), Flogc: float64(0.1946155228479256)},
	108: {Finvc: float64(0.8178913903778707), Flogc: float64(0.20102572579389744)},
	109: {Finvc: float64(0.8126984007245374), Flogc: float64(0.2073952090795501)},
	110: {Finvc: float64(0.8075710029460227), Flogc: float64(0.21372429840596396)},
	111: {Finvc: float64(0.8025078881160415), Flogc: float64(0.2200135945981856)},
	112: {Finvc: float64(0.7975077379364331), Flogc: float64(0.22626374162859975)},
	113: {Finvc: float64(0.792569604966373), Flogc: float64(0.23247494747693054)},
	114: {Finvc: float64(0.7876923641254114), Flogc: float64(0.23864766620658884)},
	115: {Finvc: float64(0.7828746724940998), Flogc: float64(0.24478265647405806)},
	116: {Finvc: float64(0.7781155388790811), Flogc: float64(0.25088025827324145)},
	117: {Finvc: float64(0.7734139557869777), Flogc: float64(0.2569408552510595)},
	118: {Finvc: float64(0.7687687179914933), Flogc: float64(0.26296511155101143)},
	119: {Finvc: float64(0.7641790698041854), Flogc: float64(0.2689531327189343)},
	120: {Finvc: float64(0.7596438763692399), Flogc: float64(0.27490553924610595)},
	121: {Finvc: float64(0.7551621951078668), Flogc: float64(0.2808227248478943)},
	122: {Finvc: float64(0.7507331780216866), Flogc: float64(0.286704979267256)},
	123: {Finvc: float64(0.7463557196361751), Flogc: float64(0.29255295645509705)},
	124: {Finvc: float64(0.7420289364869653), Flogc: float64(0.2983670386142876)},
	125: {Finvc: float64(0.7377521537065876), Flogc: float64(0.30414734587282055)},
	126: {Finvc: float64(0.7335242966002608), Flogc: float64(0.30989455774829366)},
	127: {Finvc: float64(0.729344777457841), Flogc: float64(0.31560871301871884)}}, Ftab2: [128]struct {
	Fchi float64
	Fclo float64
}{
	0:   {Fchi: float64(0.6894531274426304), Fclo: float64(2.60290652810535e-17)},
	1:   {Fchi: float64(0.6933593811533166), Fclo: float64(5.1607448519931415e-17)},
	2:   {Fchi: float64(0.6972656502972674), Fclo: float64(5.290672414887869e-17)},
	3:   {Fchi: float64(0.7011718886092148), Fclo: float64(7.801030634806013e-18)},
	4:   {Fchi: float64(0.7050781228976939), Fclo: -Float64FromFloat64(2.471355337688684e-17)},
	5:   {Fchi: float64(0.7089843887644558), Fclo: -Float64FromFloat64(4.6413389636862956e-17)},
	6:   {Fchi: float64(0.7128906815542553), Fclo: float64(3.3387408065940366e-17)},
	7:   {Fchi: float64(0.7167968359278303), Fclo: -Float64FromFloat64(2.6454587338050098e-17)},
	8:   {Fchi: float64(0.7207031520563163), Fclo: float64(2.4284096334522285e-17)},
	9:   {Fchi: float64(0.7246093683054673), Fclo: float64(4.85782435031982e-17)},
	10:  {Fchi: float64(0.7285155644718035), Fclo: -Float64FromFloat64(1.3014776598894487e-17)},
	11:  {Fchi: float64(0.7324219036935506), Fclo: -Float64FromFloat64(1.0402317671225898e-17)},
	12:  {Fchi: float64(0.73632811474659), Fclo: float64(3.078291427467431e-17)},
	13:  {Fchi: float64(0.7402343715130797), Fclo: -Float64FromFloat64(1.4304998976623033e-17)},
	14:  {Fchi: float64(0.7441405900738403), Fclo: -Float64FromFloat64(2.8625955785571303e-17)},
	15:  {Fchi: float64(0.7480468324364), Fclo: float64(5.1609093535635645e-17)},
	16:  {Fchi: float64(0.7519531335902885), Fclo: float64(4.423423949536319e-17)},
	17:  {Fchi: float64(0.7558594189116706), Fclo: -Float64FromFloat64(4.683016762099508e-17)},
	18:  {Fchi: float64(0.7597656365502305), Fclo: float64(4.466742007514772e-17)},
	19:  {Fchi: float64(0.7636719350887737), Fclo: -Float64FromFloat64(4.8134498775190266e-17)},
	20:  {Fchi: float64(0.767578087670501), Fclo: -Float64FromFloat64(4.3371015350542286e-17)},
	21:  {Fchi: float64(0.7714844396979536), Fclo: -Float64FromFloat64(2.515644472251707e-17)},
	22:  {Fchi: float64(0.7753905747966752), Fclo: -Float64FromFloat64(4.163636184961329e-17)},
	23:  {Fchi: float64(0.7792968686084766), Fclo: float64(3.3837161384165165e-17)},
	24:  {Fchi: float64(0.783203182701066), Fclo: float64(4.379206565056758e-17)},
	25:  {Fchi: float64(0.7871094109030913), Fclo: float64(2.7322930976146396e-17)},
	26:  {Fchi: float64(0.7910155783031153), Fclo: -Float64FromFloat64(5.463661225364046e-17)},
	27:  {Fchi: float64(0.7949218121071572), Fclo: -Float64FromFloat64(1.4320502634189868e-17)},
	28:  {Fchi: float64(0.7988281031542229), Fclo: -Float64FromFloat64(4.0766731402809024e-17)},
	29:  {Fchi: float64(0.8027343109146796), Fclo: -Float64FromFloat64(4.0338264352540086e-17)},
	30:  {Fchi: float64(0.8066405901480322), Fclo: float64(1.7241428071650815e-18)},
	31:  {Fchi: float64(0.8105469363625933), Fclo: -Float64FromFloat64(4.5534218930924523e-17)},
	32:  {Fchi: float64(0.8144531571720115), Fclo: float64(1.821216920589142e-17)},
	33:  {Fchi: float64(0.8183593894061396), Fclo: float64(4.9864288025894273e-17)},
	34:  {Fchi: float64(0.8222656559018297), Fclo: float64(4.335990416726689e-17)},
	35:  {Fchi: float64(0.8261719308006343), Fclo: -Float64FromFloat64(5.422001471661127e-17)},
	36:  {Fchi: float64(0.830078177803083), Fclo: -Float64FromFloat64(5.333603728929035e-17)},
	37:  {Fchi: float64(0.8339844538076674), Fclo: -Float64FromFloat64(1.1270648442682386e-17)},
	38:  {Fchi: float64(0.8378905498984414), Fclo: -Float64FromFloat64(3.165126734800398e-17)},
	39:  {Fchi: float64(0.8417968420618669), Fclo: float64(1.1286283062565865e-17)},
	40:  {Fchi: float64(0.8457030568173808), Fclo: float64(5.643595964448442e-18)},
	41:  {Fchi: float64(0.8496093725173733), Fclo: -Float64FromFloat64(2.1687834632368187e-17)},
	42:  {Fchi: float64(0.8535155534462677), Fclo: -Float64FromFloat64(2.2548234217914977e-17)},
	43:  {Fchi: float64(0.8574219432077146), Fclo: float64(4.683260556353139e-17)},
	44:  {Fchi: float64(0.8613281129443706), Fclo: float64(2.5148296884122795e-17)},
	45:  {Fchi: float64(0.8652342893532053), Fclo: -Float64FromFloat64(8.672187570949467e-18)},
	46:  {Fchi: float64(0.8691405397938828), Fclo: -Float64FromFloat64(1.2576268285559751e-17)},
	47:  {Fchi: float64(0.8730468608194392), Fclo: -Float64FromFloat64(2.9930851265148e-17)},
	48:  {Fchi: float64(0.8769530685783117), Fclo: float64(4.814801507681644e-17)},
	49:  {Fchi: float64(0.8808593488818101), Fclo: -Float64FromFloat64(9.10549533611022e-18)},
	50:  {Fchi: float64(0.8847655593409667), Fclo: -Float64FromFloat64(3.512414651620766e-17)},
	51:  {Fchi: float64(0.888671840226208), Fclo: float64(3.555261815374023e-17)},
	52:  {Fchi: float64(0.8925780870017613), Fclo: float64(1.692380503540994e-17)},
	53:  {Fchi: float64(0.8964844367374554), Fclo: -Float64FromFloat64(1.0837881791715702e-17)},
	54:  {Fchi: float64(0.9003905608862683), Fclo: float64(5.2900545724138363e-17)},
	55:  {Fchi: float64(0.9042968358682077), Fclo: float64(5.3330721088784517e-17)},
	56:  {Fchi: float64(0.9082031671057441), Fclo: float64(1.8640040753232978e-17)},
	57:  {Fchi: float64(0.9121093993305497), Fclo: float64(4.467972832054075e-17)},
	58:  {Fchi: float64(0.9160155849026457), Fclo: -Float64FromFloat64(5.216213419585033e-18)},
	59:  {Fchi: float64(0.9199219622862499), Fclo: -Float64FromFloat64(2.7324731032846873e-17)},
	60:  {Fchi: float64(0.9238281880717143), Fclo: -Float64FromFloat64(1.7769263393434193e-17)},
	61:  {Fchi: float64(0.9277343012727929), Fclo: float64(4.943363080817441e-17)},
	62:  {Fchi: float64(0.9316407021562788), Fclo: float64(4.164434042024055e-17)},
	63:  {Fchi: float64(0.935546825207466), Fclo: float64(1.3011820859795741e-17)},
	64:  {Fchi: float64(0.9394530312562943), Fclo: -Float64FromFloat64(2.7332907838481398e-17)},
	65:  {Fchi: float64(0.9433593066844669), Fclo: float64(2.342133170803292e-17)},
	66:  {Fchi: float64(0.9472655994038329), Fclo: float64(1.6478717480487438e-17)},
	67:  {Fchi: float64(0.9511718313032721), Fclo: -Float64FromFloat64(5.19608290131499e-18)},
	68:  {Fchi: float64(0.9550781578218178), Fclo: -Float64FromFloat64(3.5565573220579e-17)},
	69:  {Fchi: float64(0.9589843147339043), Fclo: float64(2.0816772146458738e-17)},
	70:  {Fchi: float64(0.9628906735633685), Fclo: -Float64FromFloat64(3.471962826146841e-18)},
	71:  {Fchi: float64(0.9667968893972092), Fclo: -Float64FromFloat64(3.68646834472642e-17)},
	72:  {Fchi: float64(0.9707031054025779), Fclo: -Float64FromFloat64(3.4674108076868834e-18)},
	73:  {Fchi: float64(0.9746094325494931), Fclo: float64(4.598152624774392e-17)},
	74:  {Fchi: float64(0.9785156054582722), Fclo: float64(4.553145752392568e-17)},
	75:  {Fchi: float64(0.9824218687812282), Fclo: -Float64FromFloat64(7.811259169418978e-18)},
	76:  {Fchi: float64(0.9863280690752917), Fclo: float64(2.0375615178047467e-17)},
	77:  {Fchi: float64(0.9902342909546034), Fclo: -Float64FromFloat64(1.344597043422914e-17)},
	78:  {Fchi: float64(0.9941406780264008), Fclo: float64(1.51853723695054e-17)},
	79:  {Fchi: float64(0.9980468598715558), Fclo: -Float64FromFloat64(1.301926039598001e-17)},
	80:  {Fchi: float64(1.0039062067717412), Fclo: -Float64FromFloat64(4.596120641744973e-17)},
	81:  {Fchi: float64(1.0117187035281372), Fclo: -Float64FromFloat64(8.152405002665349e-17)},
	82:  {Fchi: float64(1.0195312424919558), Fclo: float64(8.239927014757811e-17)},
	83:  {Fchi: float64(1.0273437641634193), Fclo: float64(3.122851005327045e-17)},
	84:  {Fchi: float64(1.0351562274561221), Fclo: -Float64FromFloat64(1.3010212611128995e-17)},
	85:  {Fchi: float64(1.0429687539123276), Fclo: -Float64FromFloat64(5.984116688633458e-17)},
	86:  {Fchi: float64(1.0507812561238108), Fclo: float64(2.860923854822335e-17)},
	87:  {Fchi: float64(1.0585937308350133), Fclo: -Float64FromFloat64(1.9962944508904598e-17)},
	88:  {Fchi: float64(1.0664062936992642), Fclo: float64(5.291469130309099e-17)},
	89:  {Fchi: float64(1.0742187309945372), Fclo: float64(1.0321575006732523e-16)},
	90:  {Fchi: float64(1.082031301537134), Fclo: float64(9.021194373419119e-17)},
	91:  {Fchi: float64(1.0898438063644336), Fclo: float64(5.202798992357953e-17)},
	92:  {Fchi: float64(1.0976562356711468), Fclo: float64(5.898318482500785e-17)},
	93:  {Fchi: float64(1.1054688179463226), Fclo: float64(8.846377690653252e-17)},
	94:  {Fchi: float64(1.113281220803328), Fclo: -Float64FromFloat64(9.529455965212574e-18)},
	95:  {Fchi: float64(1.1210937073167315), Fclo: float64(6.765080709377787e-17)},
	96:  {Fchi: float64(1.1289062967338532), Fclo: float64(1.0929327370933015e-16)},
	97:  {Fchi: float64(1.1367187631150848), Fclo: float64(6.938570551230516e-17)},
	98:  {Fchi: float64(1.1445312490244826), Fclo: float64(1.908841015045148e-17)},
	99:  {Fchi: float64(1.1523437096203593), Fclo: float64(2.7744504138979832e-17)},
	100: {Fchi: float64(1.1601563266482477), Fclo: -Float64FromFloat64(1.5621964097491672e-17)},
	101: {Fchi: float64(1.1679688257483505), Fclo: -Float64FromFloat64(6.4191661495975e-17)},
	102: {Fchi: float64(1.1757811754697645), Fclo: -Float64FromFloat64(4.336465165059268e-17)},
	103: {Fchi: float64(1.183593793665613), Fclo: -Float64FromFloat64(3.8159292551356396e-17)},
	104: {Fchi: float64(1.1914062331617676), Fclo: -Float64FromFloat64(2.94933042768015e-17)},
	105: {Fchi: float64(1.1992187450577771), Fclo: -Float64FromFloat64(6.244142916351348e-17)},
	106: {Fchi: float64(1.2070312971249755), Fclo: float64(7.458644622627413e-17)},
	107: {Fchi: float64(1.2148438169965134), Fclo: float64(2.7760519266147807e-17)},
	108: {Fchi: float64(1.222656225220801), Fclo: -Float64FromFloat64(7.025106921079665e-17)},
	109: {Fchi: float64(1.2304687681290862), Fclo: float64(3.7292622364618835e-17)},
	110: {Fchi: float64(1.2382812116234925), Fclo: float64(2.2558949940652082e-17)},
	111: {Fchi: float64(1.2460936706149877), Fclo: float64(8.499368944400665e-17)},
	112: {Fchi: float64(1.2539063289686938), Fclo: float64(1.039515474644361e-17)},
	113: {Fchi: float64(1.2617188367227732), Fclo: float64(3.297262223275499e-17)},
	114: {Fchi: float64(1.2695311590462317), Fclo: float64(4.509883253594155e-17)},
	115: {Fchi: float64(1.277343660657941), Fclo: -Float64FromFloat64(7.546987371769545e-17)},
	116: {Fchi: float64(1.2851561882963496), Fclo: float64(9.454295598818184e-17)},
	117: {Fchi: float64(1.2929686521915196), Fclo: -Float64FromFloat64(7.28545609119749e-17)},
	118: {Fchi: float64(1.3007813359167737), Fclo: -Float64FromFloat64(8.934357651462802e-17)},
	119: {Fchi: float64(1.3085938093753886), Fclo: float64(8.15257059458102e-17)},
	120: {Fchi: float64(1.3164063202609564), Fclo: float64(6.946341460765881e-18)},
	121: {Fchi: float64(1.3242188320313901), Fclo: -Float64FromFloat64(7.892731380721676e-17)},
	122: {Fchi: float64(1.3320311786874468), Fclo: -Float64FromFloat64(4.3384657500713545e-17)},
	123: {Fchi: float64(1.3398436880573092), Fclo: float64(9.627577954598792e-17)},
	124: {Fchi: float64(1.3476563390295309), Fclo: float64(4.2492400590204517e-17)},
	125: {Fchi: float64(1.3554687641043626), Fclo: -Float64FromFloat64(1.0843419551446047e-16)},
	126: {Fchi: float64(1.3632813590971713), Fclo: -Float64FromFloat64(8.50172782472025e-17)},
	127: {Fchi: float64(1.3710936595522603), Fclo: -Float64FromFloat64(7.110627206162922e-17)}}}

var x___logf_data = Tlogf_data{Ftab: [16]struct {
	Finvc float64
	Flogc float64
}{
	0:  {Finvc: float64(1.398907162146528), Flogc: -Float64FromFloat64(0.33569133332882284)},
	1:  {Finvc: float64(1.3403141896637998), Flogc: -Float64FromFloat64(0.2929040563774074)},
	2:  {Finvc: float64(1.286432210124115), Flogc: -Float64FromFloat64(0.2518726580937369)},
	3:  {Finvc: float64(1.2367150214269895), Flogc: -Float64FromFloat64(0.21245868807117255)},
	4:  {Finvc: float64(1.1906977166711752), Flogc: -Float64FromFloat64(0.17453945183745634)},
	5:  {Finvc: float64(1.1479821020556429), Flogc: -Float64FromFloat64(0.1380057072319758)},
	6:  {Finvc: float64(1.1082251448272158), Flogc: -Float64FromFloat64(0.10275976698545139)},
	7:  {Finvc: float64(1.0711297413057381), Flogc: -Float64FromFloat64(0.06871392447020525)},
	8:  {Finvc: float64(1.036437278977283), Flogc: -Float64FromFloat64(0.0357891387398228)},
	9:  {Finvc: float64(1), Flogc: float64(0)},
	10: {Finvc: float64(0.9492859795739057), Flogc: float64(0.05204517742929496)},
	11: {Finvc: float64(0.8951049428609004), Flogc: float64(0.11081431298787942)},
	12: {Finvc: float64(0.8476821620351103), Flogc: float64(0.1652495223695143)},
	13: {Finvc: float64(0.8050314851692001), Flogc: float64(0.21687389031699977)},
	14: {Finvc: float64(0.7664671008843108), Flogc: float64(0.2659635028121397)},
	15: {Finvc: float64(0.731428603316328), Flogc: float64(0.3127556664073557)}}, Fln2: float64(0.6931471805599453), Fpoly: [3]float64{
	0: -Float64FromFloat64(0.25089342214237154),
	1: float64(0.333456765744066),
	2: -Float64FromFloat64(0.4999997485802103)}}

var x___malloc_context = Tmalloc_context{}

var x___malloc_lock [1]int32

var x___malloc_replaced int32

var x___malloc_size_classes = [48]Tuint16_t{
	0:  uint16(1),
	1:  uint16(2),
	2:  uint16(3),
	3:  uint16(4),
	4:  uint16(5),
	5:  uint16(6),
	6:  uint16(7),
	7:  uint16(8),
	8:  uint16(9),
	9:  uint16(10),
	10: uint16(12),
	11: uint16(15),
	12: uint16(18),
	13: uint16(20),
	14: uint16(25),
	15: uint16(31),
	16: uint16(36),
	17: uint16(42),
	18: uint16(50),
	19: uint16(63),
	20: uint16(72),
	21: uint16(84),
	22: uint16(102),
	23: uint16(127),
	24: uint16(146),
	25: uint16(170),
	26: uint16(204),
	27: uint16(255),
	28: uint16(292),
	29: uint16(340),
	30: uint16(409),
	31: uint16(511),
	32: uint16(584),
	33: uint16(682),
	34: uint16(818),
	35: uint16(1023),
	36: uint16(1169),
	37: uint16(1364),
	38: uint16(1637),
	39: uint16(2047),
	40: uint16(2340),
	41: uint16(2730),
	42: uint16(3276),
	43: uint16(4095),
	44: uint16(4680),
	45: uint16(5460),
	46: uint16(6552),
	47: uint16(8191)}

var x___optpos int32

var x___optreset = int32(0)

var x___pow_log_data = Tpow_log_data{Fln2hi: float64(0.6931471805598903), Fln2lo: float64(5.497923018708371e-14), Fpoly: [7]float64{
	0: -Float64FromFloat64(0.5),
	1: Float64FromFloat64(0.3333333333333339) * float64(-Int32FromInt32(2)),
	2: -Float64FromFloat64(0.25000000000000033) * float64(-Int32FromInt32(2)),
	3: Float64FromFloat64(0.1999999998830994) * Float64FromInt32(4),
	4: -Float64FromFloat64(0.16666666658719348) * Float64FromInt32(4),
	5: Float64FromFloat64(0.14286370355743763) * float64(-Int32FromInt32(8)),
	6: -Float64FromFloat64(0.12500519079594427) * float64(-Int32FromInt32(8))}, Ftab: [128]struct {
	Finvc     float64
	Fpad      float64
	Flogc     float64
	Flogctail float64
}{
	0:   {Finvc: float64(1.4140625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.3464667673462145), Flogctail: float64(5.929407345889625e-15)},
	1:   {Finvc: float64(1.40625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.34092658697056777), Flogctail: -Float64FromFloat64(2.544157440035963e-14)},
	2:   {Finvc: float64(1.3984375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.3353555419211034), Flogctail: -Float64FromFloat64(3.443525940775045e-14)},
	3:   {Finvc: float64(1.390625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.3297532863724655), Flogctail: -Float64FromFloat64(2.500123826022799e-15)},
	4:   {Finvc: float64(1.3828125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.32411946865420305), Flogctail: -Float64FromFloat64(8.929337133850617e-15)},
	5:   {Finvc: float64(1.375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.31845373111855224), Flogctail: float64(1.7625431312172662e-14)},
	6:   {Finvc: float64(1.3671875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.31275571000389846), Flogctail: float64(1.5688303180062087e-15)},
	7:   {Finvc: float64(1.359375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.3070250352949415), Flogctail: float64(2.9655274673691784e-14)},
	8:   {Finvc: float64(1.3515625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.3012613305781997), Flogctail: float64(3.7923164802093147e-14)},
	9:   {Finvc: float64(1.34375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2954642128938758), Flogctail: float64(3.993416384387844e-14)},
	10:  {Finvc: float64(1.3359375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.28963329258306203), Flogctail: float64(1.9352855826489123e-14)},
	11:  {Finvc: float64(1.3359375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.28963329258306203), Flogctail: float64(1.9352855826489123e-14)},
	12:  {Finvc: float64(1.328125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.28376817313062475), Flogctail: -Float64FromFloat64(1.9852665484979036e-14)},
	13:  {Finvc: float64(1.3203125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.27786845100342816), Flogctail: -Float64FromFloat64(2.814323765595281e-14)},
	14:  {Finvc: float64(1.3125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2719337154836694), Flogctail: float64(2.7643769993528702e-14)},
	15:  {Finvc: float64(1.3046875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2659635484970977), Flogctail: -Float64FromFloat64(4.025092402293806e-14)},
	16:  {Finvc: float64(1.296875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.25995752443691345), Flogctail: -Float64FromFloat64(1.2621729398885316e-14)},
	17:  {Finvc: float64(1.2890625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.25391520998095984), Flogctail: -Float64FromFloat64(3.600176732637335e-15)},
	18:  {Finvc: float64(1.2890625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.25391520998095984), Flogctail: -Float64FromFloat64(3.600176732637335e-15)},
	19:  {Finvc: float64(1.28125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2478361639045943), Flogctail: float64(1.3029797173308663e-14)},
	20:  {Finvc: float64(1.2734375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2417199368871934), Flogctail: float64(4.8230289429940886e-14)},
	21:  {Finvc: float64(1.265625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.23556607131274632), Flogctail: -Float64FromFloat64(2.0592242769647135e-14)},
	22:  {Finvc: float64(1.2578125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.22937410106487732), Flogctail: float64(3.149265065191484e-14)},
	23:  {Finvc: float64(1.25), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.22314355131425145), Flogctail: float64(4.169796584527195e-14)},
	24:  {Finvc: float64(1.25), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.22314355131425145), Flogctail: float64(4.169796584527195e-14)},
	25:  {Finvc: float64(1.2421875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.21687393830063684), Flogctail: float64(2.2477465222466186e-14)},
	26:  {Finvc: float64(1.234375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.21056476910735), Flogctail: float64(3.6507188831790577e-16)},
	27:  {Finvc: float64(1.2265625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2042155414286526), Flogctail: -Float64FromFloat64(3.827767260205414e-14)},
	28:  {Finvc: float64(1.2265625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.2042155414286526), Flogctail: -Float64FromFloat64(3.827767260205414e-14)},
	29:  {Finvc: float64(1.21875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.19782574332987224), Flogctail: -Float64FromFloat64(4.7641388950792196e-14)},
	30:  {Finvc: float64(1.2109375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.19139485299967873), Flogctail: float64(4.9278276214647115e-14)},
	31:  {Finvc: float64(1.203125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.18492233849406148), Flogctail: float64(4.9485167661250996e-14)},
	32:  {Finvc: float64(1.203125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.18492233849406148), Flogctail: float64(4.9485167661250996e-14)},
	33:  {Finvc: float64(1.1953125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.1784076574728033), Flogctail: -Float64FromFloat64(1.5003333854266542e-14)},
	34:  {Finvc: float64(1.1875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.17185025692663203), Flogctail: -Float64FromFloat64(2.7194441649495324e-14)},
	35:  {Finvc: float64(1.1875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.17185025692663203), Flogctail: -Float64FromFloat64(2.7194441649495324e-14)},
	36:  {Finvc: float64(1.1796875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.1652495728952772), Flogctail: -Float64FromFloat64(2.99659267292569e-14)},
	37:  {Finvc: float64(1.171875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.15860503017665906), Flogctail: float64(2.0472357800461955e-14)},
	38:  {Finvc: float64(1.171875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.15860503017665906), Flogctail: float64(2.0472357800461955e-14)},
	39:  {Finvc: float64(1.1640625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.15191604202584585), Flogctail: float64(3.879296723063646e-15)},
	40:  {Finvc: float64(1.15625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.1451820098444614), Flogctail: -Float64FromFloat64(3.6506824353335045e-14)},
	41:  {Finvc: float64(1.1484375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.13840232285906495), Flogctail: -Float64FromFloat64(5.4183331379008994e-14)},
	42:  {Finvc: float64(1.1484375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.13840232285906495), Flogctail: -Float64FromFloat64(5.4183331379008994e-14)},
	43:  {Finvc: float64(1.140625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.131576357788731), Flogctail: float64(1.1729485484531301e-14)},
	44:  {Finvc: float64(1.140625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.131576357788731), Flogctail: float64(1.1729485484531301e-14)},
	45:  {Finvc: float64(1.1328125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.12470347850091912), Flogctail: -Float64FromFloat64(3.811763084710266e-14)},
	46:  {Finvc: float64(1.125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.11778303565643), Flogctail: float64(4.654729747598445e-14)},
	47:  {Finvc: float64(1.125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.11778303565643), Flogctail: float64(4.654729747598445e-14)},
	48:  {Finvc: float64(1.1171875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.11081436634026431), Flogctail: -Float64FromFloat64(2.5799991283069902e-14)},
	49:  {Finvc: float64(1.109375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.10379679368168127), Flogctail: float64(3.7700471749674615e-14)},
	50:  {Finvc: float64(1.109375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.10379679368168127), Flogctail: float64(3.7700471749674615e-14)},
	51:  {Finvc: float64(1.1015625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.09672962645856842), Flogctail: float64(1.7306161136093256e-14)},
	52:  {Finvc: float64(1.1015625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.09672962645856842), Flogctail: float64(1.7306161136093256e-14)},
	53:  {Finvc: float64(1.09375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.089612158689647), Flogctail: -Float64FromFloat64(4.012913552726574e-14)},
	54:  {Finvc: float64(1.0859375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.08244366921110213), Flogctail: float64(2.7541708360737882e-14)},
	55:  {Finvc: float64(1.0859375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.08244366921110213), Flogctail: float64(2.7541708360737882e-14)},
	56:  {Finvc: float64(1.078125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.07522342123763792), Flogctail: float64(5.0396178134370583e-14)},
	57:  {Finvc: float64(1.078125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.07522342123763792), Flogctail: float64(5.0396178134370583e-14)},
	58:  {Finvc: float64(1.0703125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.06795066190852594), Flogctail: float64(1.8195060030168815e-14)},
	59:  {Finvc: float64(1.0625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.06062462181648698), Flogctail: float64(5.213620639136504e-14)},
	60:  {Finvc: float64(1.0625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.06062462181648698), Flogctail: float64(5.213620639136504e-14)},
	61:  {Finvc: float64(1.0546875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.053244514518837605), Flogctail: float64(2.532168943117445e-14)},
	62:  {Finvc: float64(1.0546875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.053244514518837605), Flogctail: float64(2.532168943117445e-14)},
	63:  {Finvc: float64(1.046875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.045809536031242715), Flogctail: -Float64FromFloat64(5.148849572685811e-14)},
	64:  {Finvc: float64(1.046875), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.045809536031242715), Flogctail: -Float64FromFloat64(5.148849572685811e-14)},
	65:  {Finvc: float64(1.0390625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.038318864302141264), Flogctail: float64(4.6652946995830086e-15)},
	66:  {Finvc: float64(1.0390625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.038318864302141264), Flogctail: float64(4.6652946995830086e-15)},
	67:  {Finvc: float64(1.03125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.03077165866670839), Flogctail: -Float64FromFloat64(4.529814257790929e-14)},
	68:  {Finvc: float64(1.03125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.03077165866670839), Flogctail: -Float64FromFloat64(4.529814257790929e-14)},
	69:  {Finvc: float64(1.0234375), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.023167059281490765), Flogctail: -Float64FromFloat64(4.361324067851568e-14)},
	70:  {Finvc: float64(1.015625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.015504186535963527), Flogctail: -Float64FromFloat64(1.7274567499706107e-15)},
	71:  {Finvc: float64(1.015625), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.015504186535963527), Flogctail: -Float64FromFloat64(1.7274567499706107e-15)},
	72:  {Finvc: float64(1.0078125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.0077821404420319595), Flogctail: -Float64FromFloat64(2.298941004620351e-14)},
	73:  {Finvc: float64(1.0078125), Fpad: Float64FromInt32(0), Flogc: -Float64FromFloat64(0.0077821404420319595), Flogctail: -Float64FromFloat64(2.298941004620351e-14)},
	74:  {Finvc: float64(1), Fpad: Float64FromInt32(0), Flogc: float64(0), Flogctail: float64(0)},
	75:  {Finvc: float64(1), Fpad: Float64FromInt32(0), Flogc: float64(0), Flogctail: float64(0)},
	76:  {Finvc: float64(0.9921875), Fpad: Float64FromInt32(0), Flogc: float64(0.007843177461040796), Flogctail: -Float64FromFloat64(1.4902732911301337e-14)},
	77:  {Finvc: float64(0.984375), Fpad: Float64FromInt32(0), Flogc: float64(0.01574835696817445), Flogctail: -Float64FromFloat64(3.527980389655325e-14)},
	78:  {Finvc: float64(0.9765625), Fpad: Float64FromInt32(0), Flogc: float64(0.023716526617363343), Flogctail: -Float64FromFloat64(4.730054772033249e-14)},
	79:  {Finvc: float64(0.96875), Fpad: Float64FromInt32(0), Flogc: float64(0.03174869831457272), Flogctail: float64(7.580310369375161e-15)},
	80:  {Finvc: float64(0.9609375), Fpad: Float64FromInt32(0), Flogc: float64(0.039845908547249564), Flogctail: -Float64FromFloat64(4.9893776716773285e-14)},
	81:  {Finvc: float64(0.953125), Fpad: Float64FromInt32(0), Flogc: float64(0.048009219186383234), Flogctail: -Float64FromFloat64(2.262629393030674e-14)},
	82:  {Finvc: float64(0.9453125), Fpad: Float64FromInt32(0), Flogc: float64(0.056239718322899535), Flogctail: -Float64FromFloat64(2.345674491018699e-14)},
	83:  {Finvc: float64(0.94140625), Fpad: Float64FromInt32(0), Flogc: float64(0.06038051098892083), Flogctail: -Float64FromFloat64(1.3352588834854848e-14)},
	84:  {Finvc: float64(0.93359375), Fpad: Float64FromInt32(0), Flogc: float64(0.06871389254808946), Flogctail: -Float64FromFloat64(3.765296820388875e-14)},
	85:  {Finvc: float64(0.92578125), Fpad: Float64FromInt32(0), Flogc: float64(0.07711730334438016), Flogctail: float64(5.1128335719851986e-14)},
	86:  {Finvc: float64(0.91796875), Fpad: Float64FromInt32(0), Flogc: float64(0.08559193033545398), Flogctail: -Float64FromFloat64(5.046674438470119e-14)},
	87:  {Finvc: float64(0.9140625), Fpad: Float64FromInt32(0), Flogc: float64(0.08985632912185793), Flogctail: float64(3.1218748807418837e-15)},
	88:  {Finvc: float64(0.90625), Fpad: Float64FromInt32(0), Flogc: float64(0.09844007281321865), Flogctail: float64(3.3871241029241416e-14)},
	89:  {Finvc: float64(0.8984375), Fpad: Float64FromInt32(0), Flogc: float64(0.10709813555638448), Flogctail: -Float64FromFloat64(1.7376727386423858e-14)},
	90:  {Finvc: float64(0.89453125), Fpad: Float64FromInt32(0), Flogc: float64(0.11145544092528326), Flogctail: float64(3.957125899799804e-14)},
	91:  {Finvc: float64(0.88671875), Fpad: Float64FromInt32(0), Flogc: float64(0.12022742699821265), Flogctail: -Float64FromFloat64(5.2849453521890294e-14)},
	92:  {Finvc: float64(0.8828125), Fpad: Float64FromInt32(0), Flogc: float64(0.12464244520731427), Flogctail: -Float64FromFloat64(3.767012502308738e-14)},
	93:  {Finvc: float64(0.875), Fpad: Float64FromInt32(0), Flogc: float64(0.13353139262449076), Flogctail: float64(3.1859736349078334e-14)},
	94:  {Finvc: float64(0.87109375), Fpad: Float64FromInt32(0), Flogc: float64(0.13800567301939282), Flogctail: float64(5.0900642926060466e-14)},
	95:  {Finvc: float64(0.86328125), Fpad: Float64FromInt32(0), Flogc: float64(0.14701474296180095), Flogctail: float64(8.710783796122478e-15)},
	96:  {Finvc: float64(0.859375), Fpad: Float64FromInt32(0), Flogc: float64(0.15154989812720032), Flogctail: float64(6.157896229122976e-16)},
	97:  {Finvc: float64(0.8515625), Fpad: Float64FromInt32(0), Flogc: float64(0.16068238169043525), Flogctail: float64(3.821577743916796e-14)},
	98:  {Finvc: float64(0.84765625), Fpad: Float64FromInt32(0), Flogc: float64(0.16528009093906348), Flogctail: float64(3.9440046718453496e-14)},
	99:  {Finvc: float64(0.83984375), Fpad: Float64FromInt32(0), Flogc: float64(0.17453941635187675), Flogctail: float64(2.2924522154618074e-14)},
	100: {Finvc: float64(0.8359375), Fpad: Float64FromInt32(0), Flogc: float64(0.17920142945774842), Flogctail: -Float64FromFloat64(3.742530094732263e-14)},
	101: {Finvc: float64(0.83203125), Fpad: Float64FromInt32(0), Flogc: float64(0.18388527877016259), Flogctail: -Float64FromFloat64(2.5223102140407338e-14)},
	102: {Finvc: float64(0.82421875), Fpad: Float64FromInt32(0), Flogc: float64(0.1933193110035063), Flogctail: -Float64FromFloat64(1.0320443688698849e-14)},
	103: {Finvc: float64(0.8203125), Fpad: Float64FromInt32(0), Flogc: float64(0.19806991376208316), Flogctail: float64(1.0634128304268335e-14)},
	104: {Finvc: float64(0.8125), Fpad: Float64FromInt32(0), Flogc: float64(0.20763936477828793), Flogctail: -Float64FromFloat64(4.3425422595242564e-14)},
	105: {Finvc: float64(0.80859375), Fpad: Float64FromInt32(0), Flogc: float64(0.21245865121420593), Flogctail: -Float64FromFloat64(1.2527395755711364e-14)},
	106: {Finvc: float64(0.8046875), Fpad: Float64FromInt32(0), Flogc: float64(0.21730127569003344), Flogctail: -Float64FromFloat64(5.204008743405884e-14)},
	107: {Finvc: float64(0.80078125), Fpad: Float64FromInt32(0), Flogc: float64(0.22216746534115828), Flogctail: -Float64FromFloat64(3.979844515951702e-15)},
	108: {Finvc: float64(0.79296875), Fpad: Float64FromInt32(0), Flogc: float64(0.2319714654378231), Flogctail: -Float64FromFloat64(4.7955860343296286e-14)},
	109: {Finvc: float64(0.7890625), Fpad: Float64FromInt32(0), Flogc: float64(0.2369097470783572), Flogctail: float64(5.015686013791602e-16)},
	110: {Finvc: float64(0.78515625), Fpad: Float64FromInt32(0), Flogc: float64(0.24187253642048745), Flogctail: -Float64FromFloat64(7.252318953240293e-16)},
	111: {Finvc: float64(0.78125), Fpad: Float64FromInt32(0), Flogc: float64(0.2468600779315011), Flogctail: float64(2.4688324156011588e-14)},
	112: {Finvc: float64(0.7734375), Fpad: Float64FromInt32(0), Flogc: float64(0.2569104137850218), Flogctail: float64(5.465121253624792e-15)},
	113: {Finvc: float64(0.76953125), Fpad: Float64FromInt32(0), Flogc: float64(0.26197371574153294), Flogctail: float64(4.102651071698446e-14)},
	114: {Finvc: float64(0.765625), Fpad: Float64FromInt32(0), Flogc: float64(0.2670627852490952), Flogctail: -Float64FromFloat64(4.996736502345936e-14)},
	115: {Finvc: float64(0.76171875), Fpad: Float64FromInt32(0), Flogc: float64(0.27217788591576664), Flogctail: float64(4.903580708156347e-14)},
	116: {Finvc: float64(0.7578125), Fpad: Float64FromInt32(0), Flogc: float64(0.27731928541618345), Flogctail: float64(5.089628039500759e-14)},
	117: {Finvc: float64(0.75390625), Fpad: Float64FromInt32(0), Flogc: float64(0.28248725557466514), Flogctail: float64(1.1782016386565151e-14)},
	118: {Finvc: float64(0.74609375), Fpad: Float64FromInt32(0), Flogc: float64(0.29290401643288533), Flogctail: float64(4.727452940514406e-14)},
	119: {Finvc: float64(0.7421875), Fpad: Float64FromInt32(0), Flogc: float64(0.29815337231912054), Flogctail: -Float64FromFloat64(4.4204083338755686e-14)},
	120: {Finvc: float64(0.73828125), Fpad: Float64FromInt32(0), Flogc: float64(0.3034304294199046), Flogctail: float64(1.548345993498083e-14)},
	121: {Finvc: float64(0.734375), Fpad: Float64FromInt32(0), Flogc: float64(0.30873548164959175), Flogctail: float64(2.1522127491642888e-14)},
	122: {Finvc: float64(0.73046875), Fpad: Float64FromInt32(0), Flogc: float64(0.3140688276249648), Flogctail: float64(1.1054030169005386e-14)},
	123: {Finvc: float64(0.7265625), Fpad: Float64FromInt32(0), Flogc: float64(0.31943077076641657), Flogctail: -Float64FromFloat64(5.534326352070679e-14)},
	124: {Finvc: float64(0.72265625), Fpad: Float64FromInt32(0), Flogc: float64(0.3248216194012912), Flogctail: -Float64FromFloat64(5.351646604259541e-14)},
	125: {Finvc: float64(0.71875), Fpad: Float64FromInt32(0), Flogc: float64(0.33024168687052224), Flogctail: float64(5.4612144489920215e-14)},
	126: {Finvc: float64(0.71484375), Fpad: Float64FromInt32(0), Flogc: float64(0.3356912916381134), Flogctail: float64(2.8136969901227338e-14)},
	127: {Finvc: float64(0.7109375), Fpad: Float64FromInt32(0), Flogc: float64(0.3411707574027787), Flogctail: -Float64FromFloat64(1.156568624616423e-14)}}}

var x___powf_log2_data = Tpowf_log2_data{Ftab: [16]struct {
	Finvc float64
	Flogc float64
}{
	0:  {Finvc: float64(1.398907162146528), Flogc: -Float64FromFloat64(0.48430022186289673) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	1:  {Finvc: float64(1.3403141896637998), Flogc: -Float64FromFloat64(0.42257122959194704) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	2:  {Finvc: float64(1.286432210124115), Flogc: -Float64FromFloat64(0.3633754347673556) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	3:  {Finvc: float64(1.2367150214269895), Flogc: -Float64FromFloat64(0.30651309567405577) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	4:  {Finvc: float64(1.1906977166711752), Flogc: -Float64FromFloat64(0.25180720160537634) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	5:  {Finvc: float64(1.1479821020556429), Flogc: -Float64FromFloat64(0.19910014943794563) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	6:  {Finvc: float64(1.1082251448272158), Flogc: -Float64FromFloat64(0.14825100623281615) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	7:  {Finvc: float64(1.0711297413057381), Flogc: -Float64FromFloat64(0.09913323807318392) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	8:  {Finvc: float64(1.036437278977283), Flogc: -Float64FromFloat64(0.051632812977629436) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	9:  {Finvc: float64(1), Flogc: float64(0) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	10: {Finvc: float64(0.9492859795739057), Flogc: float64(0.07508531937943004) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	11: {Finvc: float64(0.8951049428609004), Flogc: float64(0.15987125980713107) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	12: {Finvc: float64(0.8476821620351103), Flogc: float64(0.2384046664317681) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	13: {Finvc: float64(0.8050314851692001), Flogc: float64(0.31288288605863257) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	14: {Finvc: float64(0.7664671008843108), Flogc: float64(0.38370422656453185) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))},
	15: {Finvc: float64(0.731428603316328), Flogc: float64(0.451211048935815) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))}}, Fpoly: [5]float64{
	0: float64(0.288457581109214) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)),
	1: -Float64FromFloat64(0.36092606229713164) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)),
	2: float64(0.480898481472577) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)),
	3: -Float64FromFloat64(0.7213474675006291) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS)),
	4: float64(1.4426950408774342) * float64(Int32FromInt32(1)<<Int32FromInt32(m_POWF_SCALE_BITS))}}

var x___predefined_declarator int32

var x___progname = uintptr(0)

var x___progname_full = uintptr(0)

var x___pthread_tsd_main = [128]uintptr{}

var x___pthread_tsd_size = Uint64FromInt64(8) * Uint64FromInt32(m_PTHREAD_KEYS_MAX)

var x___random_lockptr = uintptr(unsafe.Pointer(&_lock5))

var x___rsqrt_tab = [128]Tuint16_t{
	0:   uint16(0xb451),
	1:   uint16(0xb2f0),
	2:   uint16(0xb196),
	3:   uint16(0xb044),
	4:   uint16(0xaef9),
	5:   uint16(0xadb6),
	6:   uint16(0xac79),
	7:   uint16(0xab43),
	8:   uint16(0xaa14),
	9:   uint16(0xa8eb),
	10:  uint16(0xa7c8),
	11:  uint16(0xa6aa),
	12:  uint16(0xa592),
	13:  uint16(0xa480),
	14:  uint16(0xa373),
	15:  uint16(0xa26b),
	16:  uint16(0xa168),
	17:  uint16(0xa06a),
	18:  uint16(0x9f70),
	19:  uint16(0x9e7b),
	20:  uint16(0x9d8a),
	21:  uint16(0x9c9d),
	22:  uint16(0x9bb5),
	23:  uint16(0x9ad1),
	24:  uint16(0x99f0),
	25:  uint16(0x9913),
	26:  uint16(0x983a),
	27:  uint16(0x9765),
	28:  uint16(0x9693),
	29:  uint16(0x95c4),
	30:  uint16(0x94f8),
	31:  uint16(0x9430),
	32:  uint16(0x936b),
	33:  uint16(0x92a9),
	34:  uint16(0x91ea),
	35:  uint16(0x912e),
	36:  uint16(0x9075),
	37:  uint16(0x8fbe),
	38:  uint16(0x8f0a),
	39:  uint16(0x8e59),
	40:  uint16(0x8daa),
	41:  uint16(0x8cfe),
	42:  uint16(0x8c54),
	43:  uint16(0x8bac),
	44:  uint16(0x8b07),
	45:  uint16(0x8a64),
	46:  uint16(0x89c4),
	47:  uint16(0x8925),
	48:  uint16(0x8889),
	49:  uint16(0x87ee),
	50:  uint16(0x8756),
	51:  uint16(0x86c0),
	52:  uint16(0x862b),
	53:  uint16(0x8599),
	54:  uint16(0x8508),
	55:  uint16(0x8479),
	56:  uint16(0x83ec),
	57:  uint16(0x8361),
	58:  uint16(0x82d8),
	59:  uint16(0x8250),
	60:  uint16(0x81c9),
	61:  uint16(0x8145),
	62:  uint16(0x80c2),
	63:  uint16(0x8040),
	64:  uint16(0xff02),
	65:  uint16(0xfd0e),
	66:  uint16(0xfb25),
	67:  uint16(0xf947),
	68:  uint16(0xf773),
	69:  uint16(0xf5aa),
	70:  uint16(0xf3ea),
	71:  uint16(0xf234),
	72:  uint16(0xf087),
	73:  uint16(0xeee3),
	74:  uint16(0xed47),
	75:  uint16(0xebb3),
	76:  uint16(0xea27),
	77:  uint16(0xe8a3),
	78:  uint16(0xe727),
	79:  uint16(0xe5b2),
	80:  uint16(0xe443),
	81:  uint16(0xe2dc),
	82:  uint16(0xe17a),
	83:  uint16(0xe020),
	84:  uint16(0xdecb),
	85:  uint16(0xdd7d),
	86:  uint16(0xdc34),
	87:  uint16(0xdaf1),
	88:  uint16(0xd9b3),
	89:  uint16(0xd87b),
	90:  uint16(0xd748),
	91:  uint16(0xd61a),
	92:  uint16(0xd4f1),
	93:  uint16(0xd3cd),
	94:  uint16(0xd2ad),
	95:  uint16(0xd192),
	96:  uint16(0xd07b),
	97:  uint16(0xcf69),
	98:  uint16(0xce5b),
	99:  uint16(0xcd51),
	100: uint16(0xcc4a),
	101: uint16(0xcb48),
	102: uint16(0xca4a),
	103: uint16(0xc94f),
	104: uint16(0xc858),
	105: uint16(0xc764),
	106: uint16(0xc674),
	107: uint16(0xc587),
	108: uint16(0xc49d),
	109: uint16(0xc3b7),
	110: uint16(0xc2d4),
	111: uint16(0xc1f4),
	112: uint16(0xc116),
	113: uint16(0xc03c),
	114: uint16(0xbf65),
	115: uint16(0xbe90),
	116: uint16(0xbdbe),
	117: uint16(0xbcef),
	118: uint16(0xbc23),
	119: uint16(0xbb59),
	120: uint16(0xba91),
	121: uint16(0xb9cc),
	122: uint16(0xb90a),
	123: uint16(0xb84a),
	124: uint16(0xb78c),
	125: uint16(0xb6d0),
	126: uint16(0xb617),
	127: uint16(0xb560)}

var x___seed48 = [7]uint16{
	0: uint16(0),
	1: uint16(0),
	2: uint16(0),
	3: uint16(0xe66d),
	4: uint16(0xdeec),
	5: uint16(0x5),
	6: uint16(0xb)}

var x___sem_open_lockptr = uintptr(unsafe.Pointer(&_lock9))

var x___signgam = int32(0)

var x___stack_chk_guard Tuintptr_t

var x___stderr_FILE = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NORD)), Fclose1: uintptr(0), Fwrite: uintptr(0), Fseek: uintptr(0), Fbuf: uintptr(unsafe.Pointer(&_buf6)) + uintptr(m_UNGET), Fbuf_size: uint64(0), Ffd: int32(2), Flock: -int32(1), Flbf: -int32(1)}

var x___stderr_used = uintptr(unsafe.Pointer(&x___stderr_FILE))

var x___stdin_FILE = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NOWR)), Fclose1: uintptr(0), Fread: uintptr(0), Fseek: uintptr(0), Fbuf: uintptr(unsafe.Pointer(&_buf7)) + uintptr(m_UNGET), Fbuf_size: Uint64FromInt64(1032) - Uint64FromInt32(m_UNGET), Ffd: int32(0), Flock: -int32(1)}

var x___stdin_used = uintptr(unsafe.Pointer(&x___stdin_FILE))

var x___stdio_ofl_lockptr = uintptr(unsafe.Pointer(&_ofl_lock))

var x___stdout_FILE = TFILE{Fflags: uint32(Int32FromInt32(m_F_PERM) | Int32FromInt32(m_F_NORD)), Fclose1: uintptr(0), Fwrite: uintptr(0), Fseek: uintptr(0), Fbuf: uintptr(unsafe.Pointer(&_buf8)) + uintptr(m_UNGET), Fbuf_size: Uint64FromInt64(1032) - Uint64FromInt32(m_UNGET), Ffd: int32(1), Flock: -int32(1), Flbf: int32('\n')}

var x___stdout_used = uintptr(unsafe.Pointer(&x___stdout_FILE))

var x___sysinfo Tsize_t

var x___syslog_lockptr = uintptr(unsafe.Pointer(&_lock4))

var x___thread_list_lock int32

var x___timezone = int64(0)

var x___timezone_lockptr = uintptr(unsafe.Pointer(&_lock10))

var x___tzname = [2]uintptr{}

var x___utc = [4]int8{'U', 'T', 'C'}

var x___vmlock_lockptr = uintptr(unsafe.Pointer(&_vmlock))

var x__dl_debug_addr = uintptr(unsafe.Pointer(&_debug))

var x__ns_flagdata = [16]T_ns_flagdata{
	0:  {Fmask: int32(0x8000), Fshift: int32(15)},
	1:  {Fmask: int32(0x7800), Fshift: int32(11)},
	2:  {Fmask: int32(0x0400), Fshift: int32(10)},
	3:  {Fmask: int32(0x0200), Fshift: int32(9)},
	4:  {Fmask: int32(0x0100), Fshift: int32(8)},
	5:  {Fmask: int32(0x0080), Fshift: int32(7)},
	6:  {Fmask: int32(0x0040), Fshift: int32(6)},
	7:  {Fmask: int32(0x0020), Fshift: int32(5)},
	8:  {Fmask: int32(0x0010), Fshift: int32(4)},
	9:  {Fmask: int32(0x000f), Fshift: int32(0)},
	10: {},
	11: {},
	12: {},
	13: {},
	14: {},
	15: {}}

var x_getdate_err int32

var x_h_errno int32

var x_in6addr_any = Tin6_addr{}

var x_in6addr_loopback = Tin6_addr{F__in6_union: *(*struct {
	F__s6_addr16 [0][8]Tuint16_t
	F__s6_addr32 [0][4]Tuint32_t
	F__s6_addr   [16]Tuint8_t
})(unsafe.Pointer(&[16]Tuint8_t{
	0:  uint8(0),
	1:  uint8(0),
	2:  uint8(0),
	3:  uint8(0),
	4:  uint8(0),
	5:  uint8(0),
	6:  uint8(0),
	7:  uint8(0),
	8:  uint8(0),
	9:  uint8(0),
	10: uint8(0),
	11: uint8(0),
	12: uint8(0),
	13: uint8(0),
	14: uint8(0),
	15: uint8(1)}))}

var x_optarg uintptr

var x_opterr = int32(1)

var x_optind = int32(1)

var x_optopt int32

var x_stderr = uintptr(unsafe.Pointer(&x___stderr_FILE))

var x_stdin = uintptr(unsafe.Pointer(&x___stdin_FILE))

var x_stdout = uintptr(unsafe.Pointer(&x___stdout_FILE))

var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data

var ts1 = "\x00/bin:/usr/bin\x00%s\x008b \xd0\xc1\xd2\xcf\xcc\xd8\x00$2a$00$abcdefghijklmnopqrstuu\x00\xff4\xff\xff\xffE\x00*\x00\x80\xff\x80\x01 \x7f\x81\x80\x80\r\n\xff\x7f \x81 test\x00_0.../9Zz\x00_0.../9ZzX7iSJNd21sU\x00\x80x\x00\x80x22/wK52ZKGA\x00x\x00$1$\x00$5$\x00rounds=\x00rounds=%u$\x00$5$%s%.*s$\x00$6$\x00$6$%s%.*s$\x00toupper\x00tolower\x000\x00src/env/__init_tls.c\x00/dev/null\x00assembler statements not supported\x00__libc_start_main.c\x00__libc_start_main\x00infinity\x00nan\x00\x00\x01\x02\x04\a\x03\x06\x05\x00/proc/self/fd/\x00src/ipc/semctl.c\x00Symbol not found: %s\x00src/ldso/dl_iterate_phdr.c\x00Dynamic linker failed to allocate memory for error message\x00Invalid library handle %p\x00Unsupported request %d\x00Dynamic loading not supported\x00/\x00%s: \x00: \x00/dev/tty\x00\n\x00/etc/shells\x00rbe\x00rb\x00src/linux/ppoll.c\x00UTF-8\x00NLSPATH\x00LANG\x00_.@\x00.@\x00%\x00src/locale/dcngettext.c\x00src/locale/iconv.c\x00ASCII\x00C\x00LC_ALL\x00C.UTF-8\x00POSIX\x00MUSL_LOCPATH\x00.\x00src/locale/strfmon.c\x00messages\x00src/malloc/mallocng/free.c\x00mask\x00src/malloc/mallocng/malloc.c\x00src/math/__rem_pio2_large.c\x00fabsl.c\x00fabsl\x00fmodl.c\x00fmodl\x00llrint.c\x00llrint\x00llrintf.c\x00llrintf\x00llrintl.c\x00llrintl\x00lrint.c\x00lrint\x00lrintf.c\x00lrintf\x00lrintl.c\x00lrintl\x00remainderl.c\x00remainderl\x00src/math/x86_64/remquol.c\x00rintl.c\x00rintl\x00sqrt.c\x00sqrt\x00sqrtf.c\x00sqrtf\x00sqrtl.c\x00sqrtl\x00MSGVERB\x00label\x00severity\x00text\x00action\x00tag\x00HALT: \x00ERROR: \x00WARNING: \x00INFO: \x00/dev/console\x00\nTO FIX: \x00 \x00%s%s%s%s%s%s%s%s\n\x00PWD\x00: unrecognized option: \x00: option requires an argument: \x00: option does not take an argument: \x00: option is ambiguous: \x00%*[^\n]%*[\n]\x00 %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d\x00%s\t%s\t%s\t%s\t%d\t%d\n\x00/dev/ptmx\x00/dev/pts/%d\x00src/misc/realpath.c\x00%b %e %T\x00<%d>%s %n%s%s%.0d%s: \x00[\x00]\x00%.*s\x00src/misc/wordexp.c\x00/dev/shm/\x00src/multibyte/mbsrtowcs.c\x00%.2X\x00:%.2X\x00%d.%d.%d.%d.in-addr.arpa\x00ip6.arpa\x00/etc/hosts\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00/etc/services\x00/udp\x00/tcp\x00tcp\x00udp\x00src/network/getsockopt.c\x00%s%s%s\n\x00src/network/if_nameindex.c\x00%d.%d.%d.%d\x00%x:%x:%x:%x:%x:%x:%x:%x\x00%x:%x:%x:%x:%x:%x:%d.%d.%d.%d\x00:0\x00\x00ip\x00\x01icmp\x00\x02igmp\x00\x03ggp\x00\x04ipencap\x00\x05st\x00\x06tcp\x00\begp\x00\fpup\x00\x11udp\x00\x14hmp\x00\x16xns-idp\x00\x1brdp\x00\x1diso-tp4\x00$xtp\x00%ddp\x00&idpr-cmtp\x00)ipv6\x00+ipv6-route\x00,ipv6-frag\x00-idrp\x00.rsvp\x00/gre\x002esp\x003ah\x009skip\x00:ipv6-icmp\x00;ipv6-nonxt\x00<ipv6-opts\x00Irspf\x00Qvmtp\x00Yospf\x00^ipip\x00bencap\x00gpim\x00\xffraw\x00src/network/res_msend.c\x00/etc/resolv.conf\x00options\x00ndots:\x00attempts:\x00timeout:\x00nameserver\x00domain\x00search\x00127.0.0.1\x00src/network/setsockopt.c\x00/etc/group\x00src/passwd/getpw_a.c\x00/etc/passwd\x00/etc/tcb/%s/shadow\x00/etc/shadow\x00src/passwd/nscd_query.c\x00%s:%s:%u:\x00,\x00%s%s\x00%s:%s:%u:%u:%s:%s:%s\n\x00%s:%s:%.*ld:%.*ld:%.*ld:%.*ld:%.*ld:%.*ld:%.*lu\n\x00src/prng/srand48.c\x00src/process/execl.c\x00src/process/execle.c\x00src/process/execlp.c\x00src/process/execvp.c\x00src/process/posix_spawn.c\x00src/process/system.c\x00src/regex/glob.c\x00new_size > s->size\x00src/regex/regcomp.c\x00\t\x00\r\x00\f\x00\a\x00\x1b\x00[[:alnum:]_]\x00[^[:alnum:]_]\x00[[:space:]]\x00[^[:space:]]\x00[[:digit:]]\x00[^[:digit:]]\x00tnfa->submatch_data[id].parents == NULL\x00!IS_TAG(lit)\x00tree->num_tags == num_tags\x00lit->code_max >= 1 || lit->code_max <= ASSERT_LAST\x00cat->left->nullable\x00cat->right->nullable\x00(trans->assertions & ASSERT_CHAR_CLASS) == 0\x00p2->backref < 0\x00iter->max == -1 || iter->max == 1\x00iter->min == 0 || iter->min == 1\x00No error\x00No match\x00Invalid regexp\x00Unknown collating element\x00Unknown character class name\x00Trailing backslash\x00Invalid back reference\x00Missing ']'\x00Missing ')'\x00Missing '}'\x00Invalid contents of {}\x00Invalid character range\x00Out of memory\x00Repetition not preceded by valid expression\x00\x00Unknown error\x00reach_pos[trans_i->state_id].pos == pos\x00src/regex/regexec.c\x00stack->prev\x00pmatch[i].rm_so == -1\x00pmatch[i].rm_so <= pmatch[i].rm_eo\x00LINUX_2.6\x00__vdso_getcpu\x00src/search/lsearch.c\x00src/select/pselect.c\x00src/select/select.c\x00src/signal/setitimer.c\x00src/signal/sigaction.c\x00rwa\x00src/stdio/fgetln.c\x00src/stdio/fmemopen.c\x00src/stdio/open_memstream.c\x00src/stdio/open_wmemstream.c\x00src/stdio/popen.c\x00src/stdio/tempnam.c\x00w+\x00src/stdio/tmpnam.c\x00src/stdio/vfprintf.c\x00%*s\x00(null)\x00%%%s%s%s%s%s*.*%c%c\x00#\x00+\x00-\x00src/stdio/vfwscanf.c\x00%.*e\x00%.*f\x00000000000000000\x00%.*g\x00@\x00\x00\x00\x00\x00\x00\x00explicit_bzero.c\x00explicit_bzero\x00XXXXXX\x00src/thread/pthread_create.c\x00/proc/self/task/%d/comm\x00src/thread/pthread_setattr_default_np.c\x00/dev/shm/tmp-%d\x00src/time/__tz.c\x00%.3s %.3s%3d %.2d:%.2d:%.2d %d\n\x00__vdso_clock_gettime\x00DATEMSK\x00%m/%d/%y\x00%Y-%m-%d\x00%H:%M\x00%H:%M:%S\x00+%lld\x00%+.4ld\x00%lld\x00%*lld\x00%0*lld\x00src/time/strptime.c\x00src/time/timer_create.c\x00src/time/utime.c\x00src/unistd/getcwd.c\x00LOGNAME\x00dlstart.c\x00_dlstart_c\x00ldso/dynlink.c\x00"
